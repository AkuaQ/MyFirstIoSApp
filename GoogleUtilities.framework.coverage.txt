/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/AppDelegateSwizzler/GULAppDelegateSwizzler.m:
    1|       |// Copyright 2018 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "TargetConditionals.h"
   16|       |
   17|       |#if TARGET_OS_IOS
   18|       |
   19|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   20|       |#import <GoogleUtilities/GULLogger.h>
   21|       |#import <GoogleUtilities/GULMutableDictionary.h>
   22|       |#import "../Common/GULLoggerCodes.h"
   23|       |#import "Internal/GULAppDelegateSwizzler_Private.h"
   24|       |#import "Private/GULAppDelegateSwizzler.h"
   25|       |
   26|       |#import <UIKit/UIKit.h>
   27|       |#import <objc/runtime.h>
   28|       |
   29|       |// Implementations need to be typed before calling the implementation directly to cast the
   30|       |// arguments and the return types correctly. Otherwise, it will crash the app.
   31|       |typedef BOOL (*GULRealOpenURLSourceApplicationAnnotationIMP)(
   32|       |    id, SEL, UIApplication *, NSURL *, NSString *, id);
   33|       |
   34|       |typedef BOOL (*GULRealOpenURLOptionsIMP)(
   35|       |    id, SEL, UIApplication *, NSURL *, NSDictionary<NSString *, id> *);
   36|       |
   37|       |#pragma clang diagnostic push
   38|       |#pragma clang diagnostic ignored "-Wstrict-prototypes"
   39|       |typedef void (*GULRealHandleEventsForBackgroundURLSessionIMP)(
   40|       |    id, SEL, UIApplication *, NSString *, void (^)());
   41|       |#pragma clang diagnostic pop
   42|       |
   43|       |// This is needed to for the library to be warning free on iOS versions < 8.
   44|       |#pragma clang diagnostic push
   45|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   46|       |typedef BOOL (*GULRealContinueUserActivityIMP)(
   47|       |    id, SEL, UIApplication *, NSUserActivity *, void (^)(NSArray *restorableObjects));
   48|       |#pragma clang diagnostic pop
   49|       |
   50|       |typedef void (^GULAppDelegateInterceptorCallback)(id<UIApplicationDelegate>);
   51|       |
   52|       |// The strings below are the keys for associated objects.
   53|       |static char const *const kGULContinueUserActivityIMPKey = "GUL_continueUserActivityIMP";
   54|       |static char const *const kGULHandleBackgroundSessionIMPKey = "GUL_handleBackgroundSessionIMP";
   55|       |static char const *const kGULOpenURLOptionsIMPKey = "GUL_openURLOptionsIMP";
   56|       |static char const *const kGULOpenURLOptionsSourceAnnotationsIMPKey =
   57|       |    "GUL_openURLSourceApplicationAnnotationIMP";
   58|       |static char const *const kGULRealClassKey = "GUL_realClass";
   59|       |static NSString *const kGULAppDelegateKeyPath = @"delegate";
   60|       |
   61|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/AppDelegateSwizzler]";
   62|       |
   63|       |// Since Firebase SDKs also use this for app delegate proxying, in order to not be a breaking change
   64|       |// we disable App Delegate proxying when either of these two flags are set to NO.
   65|       |
   66|       |/** Plist key that allows Firebase developers to disable App Delegate Proxying. */
   67|       |static NSString *const kGULFirebaseAppDelegateProxyEnabledPlistKey =
   68|       |    @"FirebaseAppDelegateProxyEnabled";
   69|       |
   70|       |/** Plist key that allows developers not using Firebase to disable App Delegate Proxying. */
   71|       |static NSString *const kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey =
   72|       |    @"GoogleUtilitiesAppDelegateProxyEnabled";
   73|       |
   74|       |/** The prefix of the App Delegate. */
   75|       |static NSString *const kGULAppDelegatePrefix = @"GUL_";
   76|       |
   77|       |/** The original instance of App Delegate. */
   78|       |static id<UIApplicationDelegate> gOriginalAppDelegate;
   79|       |
   80|       |/**
   81|       | * This class is necessary to store the delegates in an NSArray without retaining them.
   82|       | * [NSValue valueWithNonRetainedObject] also provides this functionality, but does not provide a
   83|       | * zeroing pointer. This will cause EXC_BAD_ACCESS when trying to access the object after it is
   84|       | * dealloced. Instead, this container stores a weak, zeroing reference to the object, which
   85|       | * automatically is set to nil by the runtime when the object is dealloced.
   86|       | */
   87|       |@interface GULZeroingWeakContainer : NSObject
   88|       |
   89|       |/** Stores a weak object. */
   90|       |@property(nonatomic, weak) id object;
   91|       |
   92|       |@end
   93|       |
   94|       |@implementation GULZeroingWeakContainer
   95|       |@end
   96|       |
   97|       |@interface GULAppDelegateObserver : NSObject
   98|       |@end
   99|       |
  100|       |@implementation GULAppDelegateObserver {
  101|       |  BOOL _isObserving;
  102|       |}
  103|       |
  104|     14|+ (GULAppDelegateObserver *)sharedInstance {
  105|     14|  static GULAppDelegateObserver *instance;
  106|     14|  static dispatch_once_t once;
  107|     14|  dispatch_once(&once, ^{
  108|     14|    instance = [[GULAppDelegateObserver alloc] init];
  109|     14|  });
  110|     14|  return instance;
  111|     14|}
  112|       |
  113|     14|- (void)observeUIApplication {
  114|     14|  if (_isObserving) {
  115|      0|    return;
  116|      0|  }
  117|     14|  [[GULAppDelegateSwizzler sharedApplication]
  118|     14|      addObserver:self
  119|     14|       forKeyPath:kGULAppDelegateKeyPath
  120|     14|          options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
  121|     14|          context:nil];
  122|     14|  _isObserving = YES;
  123|     14|}
  124|       |
  125|       |- (void)observeValueForKeyPath:(NSString *)keyPath
  126|       |                      ofObject:(id)object
  127|       |                        change:(NSDictionary *)change
  128|      0|                       context:(void *)context {
  129|      0|  if ([keyPath isEqual:kGULAppDelegateKeyPath]) {
  130|      0|    id newValue = change[NSKeyValueChangeNewKey];
  131|      0|    id oldValue = change[NSKeyValueChangeOldKey];
  132|      0|    if ([newValue isEqual:oldValue]) {
  133|      0|      return;
  134|      0|    }
  135|      0|    // Free the stored app delegate instance because it has been changed to a different instance to
  136|      0|    // avoid keeping it alive forever.
  137|      0|    if ([oldValue isEqual:gOriginalAppDelegate]) {
  138|      0|      gOriginalAppDelegate = nil;
  139|      0|      // Remove the observer. Parse it to NSObject to avoid warning.
  140|      0|      [[GULAppDelegateSwizzler sharedApplication] removeObserver:self
  141|      0|                                                      forKeyPath:kGULAppDelegateKeyPath];
  142|      0|      _isObserving = NO;
  143|      0|    }
  144|      0|  }
  145|      0|}
  146|       |
  147|       |@end
  148|       |
  149|       |@implementation GULAppDelegateSwizzler
  150|       |
  151|       |static dispatch_once_t sProxyAppDelegateOnceToken;
  152|       |
  153|       |#pragma mark - Public methods
  154|       |
  155|     28|+ (BOOL)isAppDelegateProxyEnabled {
  156|     28|  NSDictionary *infoDictionary = [NSBundle mainBundle].infoDictionary;
  157|     28|
  158|     28|  id isFirebaseProxyEnabledPlistValue = infoDictionary[kGULFirebaseAppDelegateProxyEnabledPlistKey];
  159|     28|  id isGoogleProxyEnabledPlistValue =
  160|     28|      infoDictionary[kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey];
  161|     28|
  162|     28|  // Enabled by default.
  163|     28|  BOOL isFirebaseAppDelegateProxyEnabled = YES;
  164|     28|  BOOL isGoogleUtilitiesAppDelegateProxyEnabled = YES;
  165|     28|
  166|     28|  if ([isFirebaseProxyEnabledPlistValue isKindOfClass:[NSNumber class]]) {
  167|      0|    isFirebaseAppDelegateProxyEnabled = [isFirebaseProxyEnabledPlistValue boolValue];
  168|      0|  }
  169|     28|
  170|     28|  if ([isGoogleProxyEnabledPlistValue isKindOfClass:[NSNumber class]]) {
  171|      0|    isGoogleUtilitiesAppDelegateProxyEnabled = [isGoogleProxyEnabledPlistValue boolValue];
  172|      0|  }
  173|     28|
  174|     28|  // Only deactivate the proxy if it is explicitly disabled by app developers using either one of
  175|     28|  // the plist flags.
  176|     28|  return isFirebaseAppDelegateProxyEnabled && isGoogleUtilitiesAppDelegateProxyEnabled;
  177|     28|}
  178|       |
  179|       |+ (GULAppDelegateInterceptorID)registerAppDelegateInterceptor:
  180|     14|    (id<UIApplicationDelegate>)interceptor {
  181|     14|  NSAssert(interceptor, @"AppDelegateProxy cannot add nil interceptor");
  182|     14|  NSAssert([interceptor conformsToProtocol:@protocol(UIApplicationDelegate)],
  183|     14|           @"AppDelegateProxy interceptor does not conform to UIApplicationDelegate");
  184|     14|
  185|     14|  if (!interceptor) {
  186|      0|    GULLogError(kGULLoggerSwizzler, NO,
  187|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  188|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling000],
  189|      0|                @"AppDelegateProxy cannot add nil interceptor.");
  190|      0|    return nil;
  191|      0|  }
  192|     14|  if (![interceptor conformsToProtocol:@protocol(UIApplicationDelegate)]) {
  193|      0|    GULLogError(kGULLoggerSwizzler, NO,
  194|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  195|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling001],
  196|      0|                @"AppDelegateProxy interceptor does not conform to UIApplicationDelegate");
  197|      0|    return nil;
  198|      0|  }
  199|     14|
  200|     14|  // The ID should be the same given the same interceptor object.
  201|     14|  NSString *interceptorID = [NSString stringWithFormat:@"%@%p", kGULAppDelegatePrefix, interceptor];
  202|     14|  if (!interceptorID.length) {
  203|      0|    GULLogError(kGULLoggerSwizzler, NO,
  204|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  205|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling002],
  206|      0|                @"AppDelegateProxy cannot create Interceptor ID.");
  207|      0|    return nil;
  208|      0|  }
  209|     14|  GULZeroingWeakContainer *weakObject = [[GULZeroingWeakContainer alloc] init];
  210|     14|  weakObject.object = interceptor;
  211|     14|  [GULAppDelegateSwizzler interceptors][interceptorID] = weakObject;
  212|     14|  return interceptorID;
  213|     14|}
  214|       |
  215|      0|+ (void)unregisterAppDelegateInterceptorWithID:(GULAppDelegateInterceptorID)interceptorID {
  216|      0|  NSAssert(interceptorID, @"AppDelegateProxy cannot unregister nil interceptor ID.");
  217|      0|  NSAssert(((NSString *)interceptorID).length != 0,
  218|      0|           @"AppDelegateProxy cannot unregister empty interceptor ID.");
  219|      0|
  220|      0|  if (!interceptorID) {
  221|      0|    GULLogError(kGULLoggerSwizzler, NO,
  222|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  223|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling003],
  224|      0|                @"AppDelegateProxy cannot unregister empty interceptor ID.");
  225|      0|    return;
  226|      0|  }
  227|      0|
  228|      0|  GULZeroingWeakContainer *weakContainer = [GULAppDelegateSwizzler interceptors][interceptorID];
  229|      0|  if (!weakContainer.object) {
  230|      0|    GULLogError(kGULLoggerSwizzler, NO,
  231|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  232|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling004],
  233|      0|                @"AppDelegateProxy cannot unregister interceptor that was not registered. "
  234|      0|                 "Interceptor ID %@",
  235|      0|                interceptorID);
  236|      0|    return;
  237|      0|  }
  238|      0|
  239|      0|  [[GULAppDelegateSwizzler interceptors] removeObjectForKey:interceptorID];
  240|      0|}
  241|       |
  242|     14|+ (void)proxyOriginalDelegate {
  243|     14|  dispatch_once(&sProxyAppDelegateOnceToken, ^{
  244|     14|    id<UIApplicationDelegate> originalDelegate =
  245|     14|        [GULAppDelegateSwizzler sharedApplication].delegate;
  246|     14|    [GULAppDelegateSwizzler proxyAppDelegate:originalDelegate];
  247|     14|  });
  248|     14|}
  249|       |
  250|       |#pragma mark - Create proxy
  251|       |
  252|     70|+ (UIApplication *)sharedApplication {
  253|     70|  if ([GULAppEnvironmentUtil isAppExtension]) {
  254|      0|    return nil;
  255|      0|  }
  256|     70|  id sharedApplication = nil;
  257|     70|  Class uiApplicationClass = NSClassFromString(@"UIApplication");
  258|     70|  if (uiApplicationClass &&
  259|     70|      [uiApplicationClass respondsToSelector:(NSSelectorFromString(@"sharedApplication"))]) {
  260|     70|    sharedApplication = [uiApplicationClass sharedApplication];
  261|     70|  }
  262|     70|  return sharedApplication;
  263|     70|}
  264|       |
  265|       |#pragma mark - Override default methods
  266|       |
  267|       |/** Creates a new subclass of the class of the given object and sets the isa value of the given
  268|       | *  object to the new subclass. Additionally this copies methods to that new subclass that allow us
  269|       | *  to intercept UIApplicationDelegate methods. This is better known as isa swizzling.
  270|       | *
  271|       | *  @param anObject The object to which you want to isa swizzle. This has to conform to the
  272|       | *      UIApplicationDelegate subclass.
  273|       | */
  274|     14|+ (void)createSubclassWithObject:(id<UIApplicationDelegate>)anObject {
  275|     14|  Class realClass = [anObject class];
  276|     14|
  277|     14|  // Create GUL_<RealAppDelegate>_<timestampMs>
  278|     14|  NSString *classNameWithPrefix =
  279|     14|      [kGULAppDelegatePrefix stringByAppendingString:NSStringFromClass(realClass)];
  280|     14|  NSTimeInterval timestamp = [NSDate date].timeIntervalSince1970;
  281|     14|  NSString *newClassName =
  282|     14|      [NSString stringWithFormat:@"%@-%0.0f", classNameWithPrefix, timestamp * 1000];
  283|     14|
  284|     14|  if (NSClassFromString(newClassName)) {
  285|      0|    GULLogError(kGULLoggerSwizzler, NO,
  286|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  287|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling005],
  288|      0|                @"Cannot create a proxy for App Delegate. Subclass already exists. Original Class: "
  289|      0|                @"%@, subclass: %@",
  290|      0|                NSStringFromClass(realClass), newClassName);
  291|      0|    return;
  292|      0|  }
  293|     14|
  294|     14|  // Register the new class as subclass of the real one. Do not allocate more than the real class
  295|     14|  // size.
  296|     14|  Class appDelegateSubClass = objc_allocateClassPair(realClass, newClassName.UTF8String, 0);
  297|     14|  if (appDelegateSubClass == Nil) {
  298|      0|    GULLogError(kGULLoggerSwizzler, NO,
  299|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  300|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling006],
  301|      0|                @"Cannot create a proxy for App Delegate. Subclass already exists. Original Class: "
  302|      0|                @"%@, subclass: Nil",
  303|      0|                NSStringFromClass(realClass));
  304|      0|    return;
  305|      0|  }
  306|     14|
  307|     14|  // Add the following methods from GULAppDelegate class, and store the real implementation so it
  308|     14|  // can forward to the real one.
  309|     14|  // For application:openURL:options:
  310|     14|  NSValue *openURLOptionsIMPPointer;
  311|     14|  SEL applicationOpenURLOptionsSEL = @selector(application:openURL:options:);
  312|     14|  if ([anObject respondsToSelector:applicationOpenURLOptionsSEL]) {
  313|     14|    // Only add the application:openURL:options: method if the original AppDelegate implements it.
  314|     14|    // This fixes a bug if an app only implements application:openURL:sourceApplication:annotation:
  315|     14|    // (if we add the `options` method, iOS sees that one exists and does not call the
  316|     14|    // `sourceApplication` method, which in this case is the only one the app implements).
  317|     14|
  318|     14|    [GULAppDelegateSwizzler addInstanceMethodWithSelector:applicationOpenURLOptionsSEL
  319|     14|                                                fromClass:[GULAppDelegateSwizzler class]
  320|     14|                                                  toClass:appDelegateSubClass];
  321|     14|    GULRealOpenURLOptionsIMP openURLOptionsIMP = (GULRealOpenURLOptionsIMP)
  322|     14|        [GULAppDelegateSwizzler implementationOfMethodSelector:applicationOpenURLOptionsSEL
  323|     14|                                                     fromClass:realClass];
  324|     14|    openURLOptionsIMPPointer = [NSValue valueWithPointer:openURLOptionsIMP];
  325|     14|  }
  326|     14|
  327|     14|  // For application:continueUserActivity:restorationHandler:
  328|     14|  SEL continueUserActivitySEL = @selector(application:continueUserActivity:restorationHandler:);
  329|     14|  [GULAppDelegateSwizzler addInstanceMethodWithSelector:continueUserActivitySEL
  330|     14|                                              fromClass:[GULAppDelegateSwizzler class]
  331|     14|                                                toClass:appDelegateSubClass];
  332|     14|  GULRealContinueUserActivityIMP continueUserActivityIMP = (GULRealContinueUserActivityIMP)
  333|     14|      [GULAppDelegateSwizzler implementationOfMethodSelector:continueUserActivitySEL
  334|     14|                                                   fromClass:realClass];
  335|     14|  NSValue *continueUserActivityIMPPointer = [NSValue valueWithPointer:continueUserActivityIMP];
  336|     14|
  337|     14|  // For application:openURL:sourceApplication:annotation:
  338|     14|  SEL openURLSourceApplicationAnnotationSEL = @selector(application:
  339|     14|                                                            openURL:sourceApplication:annotation:);
  340|     14|  [GULAppDelegateSwizzler addInstanceMethodWithSelector:openURLSourceApplicationAnnotationSEL
  341|     14|                                              fromClass:[GULAppDelegateSwizzler class]
  342|     14|                                                toClass:appDelegateSubClass];
  343|     14|  GULRealOpenURLSourceApplicationAnnotationIMP openURLSourceApplicationAnnotationIMP =
  344|     14|      (GULRealOpenURLSourceApplicationAnnotationIMP)[GULAppDelegateSwizzler
  345|     14|          implementationOfMethodSelector:openURLSourceApplicationAnnotationSEL
  346|     14|                               fromClass:realClass];
  347|     14|  NSValue *openURLSourceAppAnnotationIMPPointer =
  348|     14|      [NSValue valueWithPointer:openURLSourceApplicationAnnotationIMP];
  349|     14|
  350|     14|  // For application:handleEventsForBackgroundURLSession:completionHandler:
  351|     14|  SEL handleEventsForBackgroundURLSessionSEL = @selector(application:
  352|     14|                                 handleEventsForBackgroundURLSession:completionHandler:);
  353|     14|  [GULAppDelegateSwizzler addInstanceMethodWithSelector:handleEventsForBackgroundURLSessionSEL
  354|     14|                                              fromClass:[GULAppDelegateSwizzler class]
  355|     14|                                                toClass:appDelegateSubClass];
  356|     14|  GULRealHandleEventsForBackgroundURLSessionIMP handleBackgroundSessionIMP =
  357|     14|      (GULRealHandleEventsForBackgroundURLSessionIMP)[GULAppDelegateSwizzler
  358|     14|          implementationOfMethodSelector:handleEventsForBackgroundURLSessionSEL
  359|     14|                               fromClass:realClass];
  360|     14|  NSValue *handleBackgroundSessionIMPPointer =
  361|     14|      [NSValue valueWithPointer:handleBackgroundSessionIMP];
  362|     14|
  363|     14|  // Override the description too so the custom class name will not show up.
  364|     14|  [GULAppDelegateSwizzler addInstanceMethodWithDestinationSelector:@selector(description)
  365|     14|                              withImplementationFromSourceSelector:@selector(fakeDescription)
  366|     14|                                                         fromClass:[self class]
  367|     14|                                                           toClass:appDelegateSubClass];
  368|     14|
  369|     14|  // Create fake properties for the real app delegate object.
  370|     14|  objc_setAssociatedObject(anObject, &kGULContinueUserActivityIMPKey,
  371|     14|                           continueUserActivityIMPPointer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  372|     14|  objc_setAssociatedObject(anObject, &kGULHandleBackgroundSessionIMPKey,
  373|     14|                           handleBackgroundSessionIMPPointer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  374|     14|  if (openURLOptionsIMPPointer) {
  375|     14|    objc_setAssociatedObject(anObject, &kGULOpenURLOptionsIMPKey, openURLOptionsIMPPointer,
  376|     14|                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  377|     14|  }
  378|     14|  objc_setAssociatedObject(anObject, &kGULOpenURLOptionsSourceAnnotationsIMPKey,
  379|     14|                           openURLSourceAppAnnotationIMPPointer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  380|     14|  objc_setAssociatedObject(anObject, &kGULRealClassKey, realClass,
  381|     14|                           OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  382|     14|
  383|     14|  // The subclass size has to be exactly the same size with the original class size. The subclass
  384|     14|  // cannot have more ivars/properties than its superclass since it will cause an offset in memory
  385|     14|  // that can lead to overwriting the isa of an object in the next frame.
  386|     14|  if (class_getInstanceSize(realClass) != class_getInstanceSize(appDelegateSubClass)) {
  387|      0|    GULLogError(kGULLoggerSwizzler, NO,
  388|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  389|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling007],
  390|      0|                @"Cannot create subclass of App Delegate, because the created subclass is not the "
  391|      0|                @"same size. %@",
  392|      0|                NSStringFromClass(realClass));
  393|      0|    NSAssert(NO, @"Classes must be the same size to swizzle isa");
  394|      0|    return;
  395|      0|  }
  396|     14|
  397|     14|  // Make the newly created class to be the subclass of the real App Delegate class.
  398|     14|  objc_registerClassPair(appDelegateSubClass);
  399|     14|  if (object_setClass(anObject, appDelegateSubClass)) {
  400|     14|    GULLogDebug(kGULLoggerSwizzler, NO,
  401|     14|                [NSString stringWithFormat:@"I-SWZ%06ld",
  402|     14|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling008],
  403|     14|                @"Successfully created App Delegate Proxy automatically. To disable the "
  404|     14|                @"proxy, set the flag %@ to NO (Boolean) in the Info.plist",
  405|     14|                [GULAppDelegateSwizzler correctAppDelegateProxyKey]);
  406|     14|  }
  407|     14|
  408|     14|  // We have to do this to invalidate the cache that caches the original respondsToSelector of
  409|     14|  // openURL handlers. Without this, it won't call the default implementations because the system
  410|     14|  // checks and caches them.
  411|     14|  // Register KVO only once. Otherwise, the observing method will be called as many times as
  412|     14|  // being registered.
  413|     14|  id<UIApplicationDelegate> delegate = [GULAppDelegateSwizzler sharedApplication].delegate;
  414|     14|  [GULAppDelegateSwizzler sharedApplication].delegate = nil;
  415|     14|  [GULAppDelegateSwizzler sharedApplication].delegate = delegate;
  416|     14|  gOriginalAppDelegate = delegate;
  417|     14|  [[GULAppDelegateObserver sharedInstance] observeUIApplication];
  418|     14|}
  419|       |
  420|       |#pragma mark - Helper methods
  421|       |
  422|     14|+ (GULMutableDictionary *)interceptors {
  423|     14|  static dispatch_once_t onceToken;
  424|     14|  static GULMutableDictionary *sInterceptors;
  425|     14|  dispatch_once(&onceToken, ^{
  426|     14|    sInterceptors = [[GULMutableDictionary alloc] init];
  427|     14|  });
  428|     14|  return sInterceptors;
  429|     14|}
  430|       |
  431|       |/** Copies a method identified by the methodSelector from one class to the other. After this method
  432|       | *  is called, performing [toClassInstance methodSelector] will be similar to calling
  433|       | *  [fromClassInstance methodSelector]. This method does nothing if toClass already has a method
  434|       | *  identified by methodSelector.
  435|       | *
  436|       | *  @param methodSelector The SEL that identifies both the method on the fromClass as well as the
  437|       | *      one on the toClass.
  438|       | *  @param fromClass The class from which a method is sourced.
  439|       | *  @param toClass The class to which the method is added. If the class already has a method with
  440|       | *      the same selector, this has no effect.
  441|       | */
  442|       |+ (void)addInstanceMethodWithSelector:(SEL)methodSelector
  443|       |                            fromClass:(Class)fromClass
  444|     56|                              toClass:(Class)toClass {
  445|     56|  [self addInstanceMethodWithDestinationSelector:methodSelector
  446|     56|            withImplementationFromSourceSelector:methodSelector
  447|     56|                                       fromClass:fromClass
  448|     56|                                         toClass:toClass];
  449|     56|}
  450|       |
  451|       |/** Copies a method identified by the sourceSelector from the fromClass as a method for the
  452|       | *  destinationSelector on the toClass. After this method is called, performing
  453|       | *  [toClassInstance destinationSelector] will be similar to calling
  454|       | *  [fromClassInstance sourceSelector]. This method does nothing if toClass already has a method
  455|       | *  identified by destinationSelector.
  456|       | *
  457|       | *  @param destinationSelector The SEL that identifies the method on the toClass.
  458|       | *  @param sourceSelector The SEL that identifies the method on the fromClass.
  459|       | *  @param fromClass The class from which a method is sourced.
  460|       | *  @param toClass The class to which the method is added. If the class already has a method with
  461|       | *      the same selector, this has no effect.
  462|       | */
  463|       |+ (void)addInstanceMethodWithDestinationSelector:(SEL)destinationSelector
  464|       |            withImplementationFromSourceSelector:(SEL)sourceSelector
  465|       |                                       fromClass:(Class)fromClass
  466|     70|                                         toClass:(Class)toClass {
  467|     70|  Method method = class_getInstanceMethod(fromClass, sourceSelector);
  468|     70|  IMP methodIMP = method_getImplementation(method);
  469|     70|  const char *types = method_getTypeEncoding(method);
  470|     70|  if (!class_addMethod(toClass, destinationSelector, methodIMP, types)) {
  471|      0|    GULLogWarning(kGULLoggerSwizzler, NO,
  472|      0|                  [NSString stringWithFormat:@"I-SWZ%06ld",
  473|      0|                                             (long)kGULSwizzlerMessageCodeAppDelegateSwizzling009],
  474|      0|                  @"Cannot copy method to destination selector %@ as it already exists",
  475|      0|                  NSStringFromSelector(destinationSelector));
  476|      0|  }
  477|     70|}
  478|       |
  479|       |/** Gets the IMP of the instance method on the class identified by the selector.
  480|       | *
  481|       | *  @param selector The selector of which the IMP is to be fetched.
  482|       | *  @param aClass The class from which the IMP is to be fetched.
  483|       | *  @return The IMP of the instance method identified by selector and aClass.
  484|       | */
  485|     56|+ (IMP)implementationOfMethodSelector:(SEL)selector fromClass:(Class)aClass {
  486|     56|  Method aMethod = class_getInstanceMethod(aClass, selector);
  487|     56|  return method_getImplementation(aMethod);
  488|     56|}
  489|       |
  490|       |/** Enumerates through all the interceptors and if they respond to a given selector, executes a
  491|       | *  GULAppDelegateInterceptorCallback with the interceptor.
  492|       | *
  493|       | *  @param methodSelector The SEL to check if an interceptor responds to.
  494|       | *  @param callback the GULAppDelegateInterceptorCallback.
  495|       | */
  496|       |+ (void)notifyInterceptorsWithMethodSelector:(SEL)methodSelector
  497|      0|                                    callback:(GULAppDelegateInterceptorCallback)callback {
  498|      0|  if (!callback) {
  499|      0|    return;
  500|      0|  }
  501|      0|
  502|      0|  NSDictionary *interceptors = [GULAppDelegateSwizzler interceptors].dictionary;
  503|      0|  [interceptors enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
  504|      0|    GULZeroingWeakContainer *interceptorContainer = obj;
  505|      0|    id interceptor = interceptorContainer.object;
  506|      0|    if (!interceptor) {
  507|      0|      GULLogWarning(
  508|      0|          kGULLoggerSwizzler, NO,
  509|      0|          [NSString
  510|      0|              stringWithFormat:@"I-SWZ%06ld", (long)kGULSwizzlerMessageCodeAppDelegateSwizzling010],
  511|      0|          @"AppDelegateProxy cannot find interceptor with ID %@. Removing the interceptor.", key);
  512|      0|      [[GULAppDelegateSwizzler interceptors] removeObjectForKey:key];
  513|      0|      return;
  514|      0|    }
  515|      0|    if ([interceptor respondsToSelector:methodSelector]) {
  516|      0|      callback(interceptor);
  517|      0|    }
  518|      0|  }];
  519|      0|}
  520|       |
  521|       |// The methods below are donor methods which are added to the dynamic subclass of the App Delegate.
  522|       |// They are called within the scope of the real App Delegate so |self| does not refer to the
  523|       |// GULAppDelegateSwizzler instance but the real App Delegate instance.
  524|       |
  525|       |#pragma mark - [Donor Methods] Overridden instance description method
  526|       |
  527|      0|- (NSString *)fakeDescription {
  528|      0|  Class realClass = objc_getAssociatedObject(self, &kGULRealClassKey);
  529|      0|  return [NSString stringWithFormat:@"<%@: %p>", realClass, self];
  530|      0|}
  531|       |
  532|       |#pragma mark - [Donor Methods] URL overridden handler methods
  533|       |
  534|       |- (BOOL)application:(UIApplication *)application
  535|       |            openURL:(NSURL *)url
  536|      0|            options:(NSDictionary<NSString *, id> *)options {
  537|      0|  // Call the real implementation if the real App Delegate has any.
  538|      0|  NSValue *openURLIMPPointer = objc_getAssociatedObject(self, &kGULOpenURLOptionsIMPKey);
  539|      0|  GULRealOpenURLOptionsIMP openURLOptionsIMP = [openURLIMPPointer pointerValue];
  540|      0|
  541|      0|  __block BOOL returnedValue = NO;
  542|      0|  SEL methodSelector = @selector(application:openURL:options:);
  543|      0|
  544|      0|// This is needed to for the library to be warning free on iOS versions < 9.
  545|      0|#pragma clang diagnostic push
  546|      0|#pragma clang diagnostic ignored "-Wunguarded-availability"
  547|      0|  [GULAppDelegateSwizzler
  548|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  549|      0|                                  callback:^(id<UIApplicationDelegate> interceptor) {
  550|      0|                                    returnedValue |= [interceptor application:application
  551|      0|                                                                      openURL:url
  552|      0|                                                                      options:options];
  553|      0|                                  }];
  554|      0|#pragma clang diagnostic pop
  555|      0|  if (openURLOptionsIMP) {
  556|      0|    returnedValue |= openURLOptionsIMP(self, methodSelector, application, url, options);
  557|      0|  }
  558|      0|  return returnedValue;
  559|      0|}
  560|       |
  561|       |- (BOOL)application:(UIApplication *)application
  562|       |              openURL:(NSURL *)url
  563|       |    sourceApplication:(NSString *)sourceApplication
  564|      0|           annotation:(id)annotation {
  565|      0|  // Call the real implementation if the real App Delegate has any.
  566|      0|  NSValue *openURLSourceAppAnnotationIMPPointer =
  567|      0|      objc_getAssociatedObject(self, &kGULOpenURLOptionsSourceAnnotationsIMPKey);
  568|      0|  GULRealOpenURLSourceApplicationAnnotationIMP openURLSourceApplicationAnnotationIMP =
  569|      0|      [openURLSourceAppAnnotationIMPPointer pointerValue];
  570|      0|
  571|      0|  __block BOOL returnedValue = NO;
  572|      0|  SEL methodSelector = @selector(application:openURL:sourceApplication:annotation:);
  573|      0|  [GULAppDelegateSwizzler
  574|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  575|      0|                                  callback:^(id<UIApplicationDelegate> interceptor) {
  576|      0|#pragma clang diagnostic push
  577|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  578|      0|                                    returnedValue |= [interceptor application:application
  579|      0|                                                                      openURL:url
  580|      0|                                                            sourceApplication:sourceApplication
  581|      0|                                                                   annotation:annotation];
  582|      0|#pragma clang diagnostic pop
  583|      0|                                  }];
  584|      0|  if (openURLSourceApplicationAnnotationIMP) {
  585|      0|    returnedValue |= openURLSourceApplicationAnnotationIMP(self, methodSelector, application, url,
  586|      0|                                                           sourceApplication, annotation);
  587|      0|  }
  588|      0|  return returnedValue;
  589|      0|}
  590|       |
  591|       |#pragma mark - [Donor Methods] Network overridden handler methods
  592|       |
  593|       |#pragma clang diagnostic push
  594|       |#pragma clang diagnostic ignored "-Wstrict-prototypes"
  595|       |- (void)application:(UIApplication *)application
  596|       |    handleEventsForBackgroundURLSession:(NSString *)identifier
  597|      0|                      completionHandler:(void (^)())completionHandler API_AVAILABLE(ios(7.0)) {
  598|      0|#pragma clang diagnostic pop
  599|      0|  NSValue *handleBackgroundSessionPointer =
  600|      0|      objc_getAssociatedObject(self, &kGULHandleBackgroundSessionIMPKey);
  601|      0|  GULRealHandleEventsForBackgroundURLSessionIMP handleBackgroundSessionIMP =
  602|      0|      [handleBackgroundSessionPointer pointerValue];
  603|      0|
  604|      0|  // Notify interceptors.
  605|      0|  SEL methodSelector = @selector(application:
  606|      0|         handleEventsForBackgroundURLSession:completionHandler:);
  607|      0|  [GULAppDelegateSwizzler
  608|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  609|      0|                                  callback:^(id<UIApplicationDelegate> interceptor) {
  610|      0|                                    [interceptor application:application
  611|      0|                                        handleEventsForBackgroundURLSession:identifier
  612|      0|                                                          completionHandler:completionHandler];
  613|      0|                                  }];
  614|      0|  // Call the real implementation if the real App Delegate has any.
  615|      0|  if (handleBackgroundSessionIMP) {
  616|      0|    handleBackgroundSessionIMP(self, methodSelector, application, identifier, completionHandler);
  617|      0|  }
  618|      0|}
  619|       |
  620|       |#pragma mark - [Donor Methods] User Activities overridden handler methods
  621|       |
  622|       |// This is needed to for the library to be warning free on iOS versions < 8.
  623|       |#pragma clang diagnostic push
  624|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
  625|       |- (BOOL)application:(UIApplication *)application
  626|       |    continueUserActivity:(NSUserActivity *)userActivity
  627|      0|      restorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler {
  628|      0|  NSValue *continueUserActivityIMPPointer =
  629|      0|      objc_getAssociatedObject(self, &kGULContinueUserActivityIMPKey);
  630|      0|  GULRealContinueUserActivityIMP continueUserActivityIMP =
  631|      0|      continueUserActivityIMPPointer.pointerValue;
  632|      0|
  633|      0|  __block BOOL returnedValue = NO;
  634|      0|  SEL methodSelector = @selector(application:continueUserActivity:restorationHandler:);
  635|      0|  [GULAppDelegateSwizzler
  636|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  637|      0|                                  callback:^(id<UIApplicationDelegate> interceptor) {
  638|      0|                                    returnedValue |= [interceptor application:application
  639|      0|                                                         continueUserActivity:userActivity
  640|      0|                                                           restorationHandler:restorationHandler];
  641|      0|                                  }];
  642|      0|  // Call the real implementation if the real App Delegate has any.
  643|      0|  if (continueUserActivityIMP) {
  644|      0|    returnedValue |= continueUserActivityIMP(self, methodSelector, application, userActivity,
  645|      0|                                             restorationHandler);
  646|      0|  }
  647|      0|  return returnedValue;
  648|      0|}
  649|       |#pragma clang diagnostic pop
  650|       |
  651|     14|+ (void)proxyAppDelegate:(id<UIApplicationDelegate>)appDelegate {
  652|     14|  id<UIApplicationDelegate> originalDelegate = appDelegate;
  653|     14|  // Do not create a subclass if it is not enabled.
  654|     14|  if (![GULAppDelegateSwizzler isAppDelegateProxyEnabled]) {
  655|      0|    GULLogNotice(kGULLoggerSwizzler, NO,
  656|      0|                 [NSString stringWithFormat:@"I-SWZ%06ld",
  657|      0|                                            (long)kGULSwizzlerMessageCodeAppDelegateSwizzling011],
  658|      0|                 @"App Delegate Proxy is disabled. %@",
  659|      0|                 [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
  660|      0|    return;
  661|      0|  }
  662|     14|  // Do not accept nil delegate.
  663|     14|  if (!originalDelegate) {
  664|      0|    GULLogError(kGULLoggerSwizzler, NO,
  665|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  666|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling012],
  667|      0|                @"Cannot create App Delegate Proxy because App Delegate instance is nil. %@",
  668|      0|                [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
  669|      0|    return;
  670|      0|  }
  671|     14|
  672|     14|  @try {
  673|     14|    [self createSubclassWithObject:originalDelegate];
  674|     14|  } @catch (NSException *exception) {
  675|     14|    GULLogError(kGULLoggerSwizzler, NO,
  676|     14|                [NSString stringWithFormat:@"I-SWZ%06ld",
  677|     14|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling013],
  678|     14|                @"Cannot create App Delegate Proxy. %@",
  679|     14|                [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
  680|     14|    return;
  681|     14|  }
  682|     14|}
  683|       |
  684|       |#pragma mark - Methods to print correct debug logs
  685|       |
  686|     14|+ (NSString *)correctAppDelegateProxyKey {
  687|     14|  return NSClassFromString(@"FIRCore") ? kGULFirebaseAppDelegateProxyEnabledPlistKey
  688|     14|                                       : kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey;
  689|     14|}
  690|       |
  691|      0|+ (NSString *)correctAlternativeWhenAppDelegateProxyNotCreated {
  692|      0|  return NSClassFromString(@"FIRCore")
  693|      0|             ? @"To log deep link campaigns manually, call the methods in "
  694|      0|               @"FIRAnalytics+AppDelegate.h."
  695|      0|             : @"";
  696|      0|}
  697|       |
  698|       |#pragma mark - Private Methods for Testing
  699|       |
  700|       |#ifdef GUL_APP_DELEGATE_TESTING
  701|       |
  702|       |+ (void)clearInterceptors {
  703|       |  [[self interceptors] removeAllObjects];
  704|       |}
  705|       |
  706|       |+ (void)resetProxyOriginalDelegateOnceToken {
  707|       |  sProxyAppDelegateOnceToken = 0;
  708|       |}
  709|       |
  710|       |+ (id<UIApplicationDelegate>)originalDelegate {
  711|       |  return gOriginalAppDelegate;
  712|       |}
  713|       |
  714|       |#endif  // GUL_APP_DELEGATE_TESTING
  715|       |
  716|       |@end
  717|       |
  718|       |#endif  // TARGET_OS_IOS

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/Environment/third_party/GULAppEnvironmentUtil.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GULAppEnvironmentUtil.h"
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |#import <dlfcn.h>
   19|       |#import <mach-o/dyld.h>
   20|       |#import <sys/utsname.h>
   21|       |
   22|       |#if TARGET_OS_IOS
   23|       |#import <UIKit/UIKit.h>
   24|       |#endif
   25|       |
   26|       |/// The encryption info struct and constants are missing from the iPhoneSimulator SDK, but not from
   27|       |/// the iPhoneOS or Mac OS X SDKs. Since one doesn't ever ship a Simulator binary, we'll just
   28|       |/// provide the definitions here.
   29|       |#if TARGET_OS_SIMULATOR && !defined(LC_ENCRYPTION_INFO)
   30|       |#define LC_ENCRYPTION_INFO 0x21
   31|       |struct encryption_info_command {
   32|       |  uint32_t cmd;
   33|       |  uint32_t cmdsize;
   34|       |  uint32_t cryptoff;
   35|       |  uint32_t cryptsize;
   36|       |  uint32_t cryptid;
   37|       |};
   38|       |#endif
   39|       |
   40|       |@implementation GULAppEnvironmentUtil
   41|       |
   42|       |/// A key for the Info.plist to enable or disable checking if the App Store is running in a sandbox.
   43|       |/// This will affect your data integrity when using Firebase Analytics, as it will disable some
   44|       |/// necessary checks.
   45|       |static NSString *const kFIRAppStoreReceiptURLCheckEnabledKey =
   46|       |    @"FirebaseAppStoreReceiptURLCheckEnabled";
   47|       |
   48|       |/// The file name of the sandbox receipt. This is available on iOS >= 8.0
   49|       |static NSString *const kFIRAIdentitySandboxReceiptFileName = @"sandboxReceipt";
   50|       |
   51|       |/// The following copyright from Landon J. Fuller applies to the isAppEncrypted function.
   52|       |///
   53|       |/// Copyright (c) 2017 Landon J. Fuller <landon@landonf.org>
   54|       |/// All rights reserved.
   55|       |///
   56|       |/// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
   57|       |/// and associated documentation files (the "Software"), to deal in the Software without
   58|       |/// restriction, including without limitation the rights to use, copy, modify, merge, publish,
   59|       |/// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
   60|       |/// Software is furnished to do so, subject to the following conditions:
   61|       |///
   62|       |/// The above copyright notice and this permission notice shall be included in all copies or
   63|       |/// substantial portions of the Software.
   64|       |///
   65|       |/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
   66|       |/// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   67|       |/// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   68|       |/// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   69|       |/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   70|       |///
   71|       |/// Comment from <a href="http://iphonedevwiki.net/index.php/Crack_prevention">iPhone Dev Wiki
   72|       |/// Crack Prevention</a>:
   73|       |/// App Store binaries are signed by both their developer and Apple. This encrypts the binary so
   74|       |/// that decryption keys are needed in order to make the binary readable. When iOS executes the
   75|       |/// binary, the decryption keys are used to decrypt the binary into a readable state where it is
   76|       |/// then loaded into memory and executed. iOS can tell the encryption status of a binary via the
   77|       |/// cryptid structure member of LC_ENCRYPTION_INFO MachO load command. If cryptid is a non-zero
   78|       |/// value then the binary is encrypted.
   79|       |///
   80|       |/// 'Cracking' works by letting the kernel decrypt the binary then siphoning the decrypted data into
   81|       |/// a new binary file, resigning, and repackaging. This will only work on jailbroken devices as
   82|       |/// codesignature validation has been removed. Resigning takes place because while the codesignature
   83|       |/// doesn't have to be valid thanks to the jailbreak, it does have to be in place unless you have
   84|       |/// AppSync or similar to disable codesignature checks.
   85|       |///
   86|       |/// More information at <a href="http://landonf.org/2009/02/index.html">Landon Fuller's blog</a>
   87|     14|static BOOL IsAppEncrypted() {
   88|     14|  const struct mach_header *executableHeader = NULL;
   89|     28|  for (uint32_t i = 0; i < _dyld_image_count(); i++) {
   90|     28|    const struct mach_header *header = _dyld_get_image_header(i);
   91|     28|    if (header && header->filetype == MH_EXECUTE) {
   92|     14|      executableHeader = header;
   93|     14|      break;
   94|     14|    }
   95|     28|  }
   96|     14|
   97|     14|  if (!executableHeader) {
   98|      0|    return NO;
   99|      0|  }
  100|     14|
  101|     14|  BOOL is64bit = (executableHeader->magic == MH_MAGIC_64);
  102|     14|  uintptr_t cursor = (uintptr_t)executableHeader +
  103|     14|                     (is64bit ? sizeof(struct mach_header_64) : sizeof(struct mach_header));
  104|     14|  const struct segment_command *segmentCommand = NULL;
  105|     14|  uint32_t i = 0;
  106|     14|
  107|    672|  while (i++ < executableHeader->ncmds) {
  108|    658|    segmentCommand = (struct segment_command *)cursor;
  109|    658|
  110|    658|    if (!segmentCommand) {
  111|      0|      continue;
  112|      0|    }
  113|    658|
  114|    658|    if ((!is64bit && segmentCommand->cmd == LC_ENCRYPTION_INFO) ||
  115|    658|        (is64bit && segmentCommand->cmd == LC_ENCRYPTION_INFO_64)) {
  116|      0|      if (is64bit) {
  117|      0|        struct encryption_info_command_64 *cryptCmd =
  118|      0|            (struct encryption_info_command_64 *)segmentCommand;
  119|      0|        return cryptCmd && cryptCmd->cryptid != 0;
  120|      0|      } else {
  121|      0|        struct encryption_info_command *cryptCmd = (struct encryption_info_command *)segmentCommand;
  122|      0|        return cryptCmd && cryptCmd->cryptid != 0;
  123|      0|      }
  124|    658|    }
  125|    658|    cursor += segmentCommand->cmdsize;
  126|    658|  }
  127|     14|
  128|     14|  return NO;
  129|     14|}
  130|       |
  131|      0|static BOOL HasSCInfoFolder() {
  132|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  133|      0|  NSString *bundlePath = [NSBundle mainBundle].bundlePath;
  134|      0|  NSString *scInfoPath = [bundlePath stringByAppendingPathComponent:@"SC_Info"];
  135|      0|  return [[NSFileManager defaultManager] fileExistsAtPath:scInfoPath];
  136|       |#elif TARGET_OS_OSX
  137|       |  return NO;
  138|       |#endif
  139|       |}
  140|       |
  141|      0|static BOOL HasEmbeddedMobileProvision() {
  142|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  143|      0|  return [[NSBundle mainBundle] pathForResource:@"embedded" ofType:@"mobileprovision"].length > 0;
  144|       |#elif TARGET_OS_OSX
  145|       |  return NO;
  146|       |#endif
  147|       |}
  148|       |
  149|     14|+ (BOOL)isFromAppStore {
  150|     14|  static dispatch_once_t isEncryptedOnce;
  151|     14|  static BOOL isEncrypted = NO;
  152|     14|
  153|     14|  dispatch_once(&isEncryptedOnce, ^{
  154|     14|    isEncrypted = IsAppEncrypted();
  155|     14|  });
  156|     14|
  157|     14|  if ([GULAppEnvironmentUtil isSimulator]) {
  158|     14|    return NO;
  159|     14|  }
  160|      0|
  161|      0|  // If an app contain the sandboxReceipt file, it means its coming from TestFlight
  162|      0|  // This must be checked before the SCInfo Folder check below since TestFlight apps may
  163|      0|  // also have an SCInfo folder.
  164|      0|  if ([GULAppEnvironmentUtil isAppStoreReceiptSandbox]) {
  165|      0|    return NO;
  166|      0|  }
  167|      0|
  168|      0|  if (HasSCInfoFolder()) {
  169|      0|    // When iTunes downloads a .ipa, it also gets a customized .sinf file which is added to the
  170|      0|    // main SC_Info directory.
  171|      0|    return YES;
  172|      0|  }
  173|      0|
  174|      0|  // For iOS >= 8.0, iTunesMetadata.plist is moved outside of the sandbox. Any attempt to read
  175|      0|  // the iTunesMetadata.plist outside of the sandbox will be rejected by Apple.
  176|      0|  // If the app does not contain the embedded.mobileprovision which is stripped out by Apple when
  177|      0|  // the app is submitted to store, then it is highly likely that it is from Apple Store.
  178|      0|  return isEncrypted && !HasEmbeddedMobileProvision();
  179|      0|}
  180|       |
  181|      0|+ (BOOL)isAppStoreReceiptSandbox {
  182|      0|  // Since checking the App Store's receipt URL can be memory intensive, check the option in the
  183|      0|  // Info.plist if developers opted out of this check.
  184|      0|  id enableSandboxCheck =
  185|      0|      [[NSBundle mainBundle] objectForInfoDictionaryKey:kFIRAppStoreReceiptURLCheckEnabledKey];
  186|      0|  if (enableSandboxCheck && [enableSandboxCheck isKindOfClass:[NSNumber class]] &&
  187|      0|      ![enableSandboxCheck boolValue]) {
  188|      0|    return NO;
  189|      0|  }
  190|      0|// The #else is for pre Xcode 9 where @available is not yet implemented.
  191|      0|#if __has_builtin(__builtin_available)
  192|      0|  if (@available(iOS 7.0, *)) {
  193|       |#else
  194|       |  if ([[UIDevice currentDevice].systemVersion integerValue] >= 7) {
  195|       |#endif
  196|       |    NSURL *appStoreReceiptURL = [NSBundle mainBundle].appStoreReceiptURL;
  197|      0|    NSString *appStoreReceiptFileName = appStoreReceiptURL.lastPathComponent;
  198|      0|    return [appStoreReceiptFileName isEqualToString:kFIRAIdentitySandboxReceiptFileName];
  199|      0|  }
  200|      0|  return NO;
  201|      0|}
  202|       |
  203|     14|+ (BOOL)isSimulator {
  204|     14|#if TARGET_OS_IOS || TARGET_OS_TV
  205|     14|  NSString *platform = [GULAppEnvironmentUtil deviceModel];
  206|     14|  return [platform isEqual:@"x86_64"] || [platform isEqual:@"i386"];
  207|       |#elif TARGET_OS_OSX
  208|       |  return NO;
  209|       |#endif
  210|       |}
  211|       |
  212|     14|+ (NSString *)deviceModel {
  213|     14|  static dispatch_once_t once;
  214|     14|  static NSString *deviceModel;
  215|     14|
  216|     14|  dispatch_once(&once, ^{
  217|     14|    struct utsname systemInfo;
  218|     14|    if (uname(&systemInfo) == 0) {
  219|     14|      deviceModel = [NSString stringWithUTF8String:systemInfo.machine];
  220|     14|    }
  221|     14|  });
  222|     14|  return deviceModel;
  223|     14|}
  224|       |
  225|     42|+ (NSString *)systemVersion {
  226|     42|#if TARGET_OS_IOS
  227|     42|  return [UIDevice currentDevice].systemVersion;
  228|       |#elif TARGET_OS_OSX || TARGET_OS_TV
  229|       |  // Assemble the systemVersion, excluding the patch version if it's 0.
  230|       |  NSOperatingSystemVersion osVersion = [NSProcessInfo processInfo].operatingSystemVersion;
  231|       |  NSMutableString *versionString = [[NSMutableString alloc]
  232|       |      initWithFormat:@"%ld.%ld", (long)osVersion.majorVersion, (long)osVersion.minorVersion];
  233|       |  if (osVersion.patchVersion != 0) {
  234|       |    [versionString appendFormat:@".%ld", (long)osVersion.patchVersion];
  235|       |  }
  236|       |  return versionString;
  237|       |#endif
  238|       |}
  239|       |
  240|     98|+ (BOOL)isAppExtension {
  241|     98|#if TARGET_OS_IOS || TARGET_OS_TV
  242|     98|  // Documented by <a href="https://goo.gl/RRB2Up">Apple</a>
  243|     98|  BOOL appExtension = [[[NSBundle mainBundle] bundlePath] hasSuffix:@".appex"];
  244|     98|  return appExtension;
  245|       |#elif TARGET_OS_OSX
  246|       |  return NO;
  247|       |#endif
  248|       |}
  249|       |
  250|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/Logger/GULLogger.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/GULLogger.h"
   16|       |
   17|       |#include <asl.h>
   18|       |
   19|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   20|       |#import "Public/GULLoggerLevel.h"
   21|       |
   22|       |/// ASL client facility name used by GULLogger.
   23|       |const char *kGULLoggerASLClientFacilityName = "com.google.utilities.logger";
   24|       |
   25|       |static dispatch_once_t sGULLoggerOnceToken;
   26|       |
   27|       |static aslclient sGULLoggerClient;
   28|       |
   29|       |static dispatch_queue_t sGULClientQueue;
   30|       |
   31|       |static BOOL sGULLoggerDebugMode;
   32|       |
   33|       |static GULLoggerLevel sGULLoggerMaximumLevel;
   34|       |
   35|       |// Allow clients to register a version to include in the log.
   36|       |static const char *sVersion = "";
   37|       |
   38|       |static GULLoggerService kGULLoggerLogger = @"[GULLogger]";
   39|       |
   40|       |#ifdef DEBUG
   41|       |/// The regex pattern for the message code.
   42|       |static NSString *const kMessageCodePattern = @"^I-[A-Z]{3}[0-9]{6}$";
   43|       |static NSRegularExpression *sMessageCodeRegex;
   44|       |#endif
   45|       |
   46|  1.31k|void GULLoggerInitializeASL(void) {
   47|  1.31k|  dispatch_once(&sGULLoggerOnceToken, ^{
   48|     14|    NSInteger majorOSVersion = [[GULAppEnvironmentUtil systemVersion] integerValue];
   49|     14|    uint32_t aslOptions = ASL_OPT_STDERR;
   50|     14|#if TARGET_OS_SIMULATOR
   51|     14|    // The iOS 11 simulator doesn't need the ASL_OPT_STDERR flag.
   52|     14|    if (majorOSVersion >= 11) {
   53|     14|      aslOptions = 0;
   54|     14|    }
   55|       |#else
   56|       |    // Devices running iOS 10 or higher don't need the ASL_OPT_STDERR flag.
   57|       |    if (majorOSVersion >= 10) {
   58|       |      aslOptions = 0;
   59|       |    }
   60|       |#endif  // TARGET_OS_SIMULATOR
   61|       |
   62|     14|#pragma clang diagnostic push
   63|     14|#pragma clang diagnostic ignored "-Wdeprecated-declarations"  // asl is deprecated
   64|     14|    // Initialize the ASL client handle.
   65|     14|    sGULLoggerClient = asl_open(NULL, kGULLoggerASLClientFacilityName, aslOptions);
   66|     14|    sGULLoggerMaximumLevel = GULLoggerLevelNotice;
   67|     14|
   68|     14|    // Set the filter used by system/device log. Initialize in default mode.
   69|     14|    asl_set_filter(sGULLoggerClient, ASL_FILTER_MASK_UPTO(ASL_LEVEL_NOTICE));
   70|     14|
   71|     14|    sGULClientQueue = dispatch_queue_create("GULLoggingClientQueue", DISPATCH_QUEUE_SERIAL);
   72|     14|    dispatch_set_target_queue(sGULClientQueue,
   73|     14|                              dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0));
   74|     14|#ifdef DEBUG
   75|     14|    sMessageCodeRegex = [NSRegularExpression regularExpressionWithPattern:kMessageCodePattern
   76|     14|                                                                  options:0
   77|     14|                                                                    error:NULL];
   78|     14|#endif
   79|     14|  });
   80|  1.31k|}
   81|       |
   82|      0|void GULLoggerEnableSTDERR(void) {
   83|      0|  asl_add_log_file(sGULLoggerClient, STDERR_FILENO);
   84|      0|}
   85|       |
   86|      0|void GULLoggerForceDebug(void) {
   87|      0|  // We should enable debug mode if we're not running from App Store.
   88|      0|  if (![GULAppEnvironmentUtil isFromAppStore]) {
   89|      0|    sGULLoggerDebugMode = YES;
   90|      0|    GULSetLoggerLevel(GULLoggerLevelDebug);
   91|      0|  }
   92|      0|}
   93|       |
   94|      0|__attribute__((no_sanitize("thread"))) void GULSetLoggerLevel(GULLoggerLevel loggerLevel) {
   95|      0|  if (loggerLevel < GULLoggerLevelMin || loggerLevel > GULLoggerLevelMax) {
   96|      0|    GULLogError(kGULLoggerLogger, NO, @"I-COR000023", @"Invalid logger level, %ld",
   97|      0|                (long)loggerLevel);
   98|      0|    return;
   99|      0|  }
  100|      0|  GULLoggerInitializeASL();
  101|      0|  // We should not raise the logger level if we are running from App Store.
  102|      0|  if (loggerLevel >= GULLoggerLevelNotice && [GULAppEnvironmentUtil isFromAppStore]) {
  103|      0|    return;
  104|      0|  }
  105|      0|
  106|      0|  sGULLoggerMaximumLevel = loggerLevel;
  107|      0|  dispatch_async(sGULClientQueue, ^{
  108|      0|    asl_set_filter(sGULLoggerClient, ASL_FILTER_MASK_UPTO(loggerLevel));
  109|      0|  });
  110|      0|}
  111|       |
  112|       |/**
  113|       | * Check if the level is high enough to be loggable.
  114|       | */
  115|  1.08k|__attribute__((no_sanitize("thread"))) BOOL GULIsLoggableLevel(GULLoggerLevel loggerLevel) {
  116|  1.08k|  GULLoggerInitializeASL();
  117|  1.08k|  if (sGULLoggerDebugMode) {
  118|      0|    return YES;
  119|      0|  }
  120|  1.08k|  return (BOOL)(loggerLevel <= sGULLoggerMaximumLevel);
  121|  1.08k|}
  122|       |
  123|       |#ifdef DEBUG
  124|      0|void GULResetLogger() {
  125|      0|  sGULLoggerOnceToken = 0;
  126|      0|}
  127|       |
  128|      0|aslclient getGULLoggerClient() {
  129|      0|  return sGULLoggerClient;
  130|      0|}
  131|       |
  132|      0|dispatch_queue_t getGULClientQueue() {
  133|      0|  return sGULClientQueue;
  134|      0|}
  135|       |
  136|      0|BOOL getGULLoggerDebugMode() {
  137|      0|  return sGULLoggerDebugMode;
  138|      0|}
  139|       |#endif
  140|       |
  141|     14|void GULLoggerRegisterVersion(const char *version) {
  142|     14|  sVersion = version;
  143|     14|}
  144|       |
  145|       |void GULLogBasic(GULLoggerLevel level,
  146|       |                 GULLoggerService service,
  147|       |                 BOOL forceLog,
  148|       |                 NSString *messageCode,
  149|       |                 NSString *message,
  150|    225|                 va_list args_ptr) {
  151|    225|  GULLoggerInitializeASL();
  152|    225|  if (!(level <= sGULLoggerMaximumLevel || sGULLoggerDebugMode || forceLog)) {
  153|    183|    return;
  154|    183|  }
  155|     42|
  156|     42|#ifdef DEBUG
  157|     42|  NSCAssert(messageCode.length == 11, @"Incorrect message code length.");
  158|     42|  NSRange messageCodeRange = NSMakeRange(0, messageCode.length);
  159|     42|  NSUInteger numberOfMatches = [sMessageCodeRegex numberOfMatchesInString:messageCode
  160|     42|                                                                  options:0
  161|     42|                                                                    range:messageCodeRange];
  162|     42|  NSCAssert(numberOfMatches == 1, @"Incorrect message code format.");
  163|     42|#endif
  164|     42|  NSString *logMsg = [[NSString alloc] initWithFormat:message arguments:args_ptr];
  165|     42|  logMsg = [NSString stringWithFormat:@"%s - %@[%@] %@", sVersion, service, messageCode, logMsg];
  166|     42|  dispatch_async(sGULClientQueue, ^{
  167|     42|    asl_log(sGULLoggerClient, NULL, level, "%s", logMsg.UTF8String);
  168|     42|  });
  169|     42|}
  170|       |#pragma clang diagnostic pop
  171|       |
  172|       |/**
  173|       | * Generates the logging functions using macros.
  174|       | *
  175|       | * Calling GULLogError(kGULLoggerCore, @"I-COR000001", @"Configure %@ failed.", @"blah") shows:
  176|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Error> [{service}][I-COR000001] Configure blah failed.
  177|       | * Calling GULLogDebug(kGULLoggerCore, @"I-COR000001", @"Configure succeed.") shows:
  178|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Debug> [{service}][I-COR000001] Configure succeed.
  179|       | */
  180|       |#define GUL_LOGGING_FUNCTION(level)                                                     \
  181|       |  void GULLog##level(GULLoggerService service, BOOL force, NSString *messageCode,       \
  182|     84|                     NSString *message, ...) {                                          \
  183|     84|    va_list args_ptr;                                                                   \
  184|     84|    va_start(args_ptr, message);                                                        \
  185|     84|    GULLogBasic(GULLoggerLevel##level, service, force, messageCode, message, args_ptr); \
  186|     84|    va_end(args_ptr);                                                                   \
  187|     84|  }
  ------------------
  | Unexecuted instantiation: GULLogError
  ------------------
  | Unexecuted instantiation: GULLogWarning
  ------------------
  | Unexecuted instantiation: GULLogNotice
  ------------------
  | GULLogInfo:
  |  182|     14|                     NSString *message, ...) {                                          \
  |  183|     14|    va_list args_ptr;                                                                   \
  |  184|     14|    va_start(args_ptr, message);                                                        \
  |  185|     14|    GULLogBasic(GULLoggerLevel##level, service, force, messageCode, message, args_ptr); \
  |  186|     14|    va_end(args_ptr);                                                                   \
  |  187|     14|  }
  ------------------
  | GULLogDebug:
  |  182|     70|                     NSString *message, ...) {                                          \
  |  183|     70|    va_list args_ptr;                                                                   \
  |  184|     70|    va_start(args_ptr, message);                                                        \
  |  185|     70|    GULLogBasic(GULLoggerLevel##level, service, force, messageCode, message, args_ptr); \
  |  186|     70|    va_end(args_ptr);                                                                   \
  |  187|     70|  }
  ------------------
  188|       |
  189|       |GUL_LOGGING_FUNCTION(Error)
  190|       |GUL_LOGGING_FUNCTION(Warning)
  191|       |GUL_LOGGING_FUNCTION(Notice)
  192|       |GUL_LOGGING_FUNCTION(Info)
  193|       |GUL_LOGGING_FUNCTION(Debug)
  194|       |
  195|       |#undef GUL_MAKE_LOGGER
  196|       |
  197|       |#pragma mark - GULLoggerWrapper
  198|       |
  199|       |@implementation GULLoggerWrapper
  200|       |
  201|       |+ (void)logWithLevel:(GULLoggerLevel)level
  202|       |         withService:(GULLoggerService)service
  203|       |            withCode:(NSString *)messageCode
  204|       |         withMessage:(NSString *)message
  205|      0|            withArgs:(va_list)args {
  206|      0|  GULLogBasic(level, service, NO, messageCode, message, args);
  207|      0|}
  208|       |
  209|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/MethodSwizzler/GULSwizzler.m:
    1|       |// Copyright 2018 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/GULSwizzler.h"
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |#import "../Common/GULLoggerCodes.h"
   21|       |
   22|       |#ifdef GUL_UNSWIZZLING_ENABLED
   23|       |#import <GoogleUtilities/GULSwizzlingCache.h>
   24|       |// We need a private method for an assert.
   25|       |#import <GoogleUtilities/GULSwizzlingCache_Private.h>
   26|       |#endif
   27|       |
   28|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilites/MethodSwizzler]";
   29|       |
   30|     56|dispatch_queue_t GetGULSwizzlingQueue() {
   31|     56|  static dispatch_queue_t queue;
   32|     56|  static dispatch_once_t onceToken;
   33|     56|  dispatch_once(&onceToken, ^{
   34|     14|    queue = dispatch_queue_create("com.google.GULSwizzler", DISPATCH_QUEUE_SERIAL);
   35|     14|  });
   36|     56|  return queue;
   37|     56|}
   38|       |
   39|       |@implementation GULSwizzler
   40|       |
   41|       |+ (void)swizzleClass:(Class)aClass
   42|       |            selector:(SEL)selector
   43|       |     isClassSelector:(BOOL)isClassSelector
   44|     28|           withBlock:(nullable id)block {
   45|     28|  dispatch_sync(GetGULSwizzlingQueue(), ^{
   46|     28|    NSAssert(selector, @"The selector cannot be NULL");
   47|     28|    NSAssert(aClass, @"The class cannot be Nil");
   48|     28|    Class resolvedClass = aClass;
   49|     28|    Method method = nil;
   50|     28|    if (isClassSelector) {
   51|      0|      method = class_getClassMethod(aClass, selector);
   52|      0|      resolvedClass = object_getClass(aClass);
   53|     28|    } else {
   54|     28|      method = class_getInstanceMethod(aClass, selector);
   55|     28|    }
   56|     28|    NSAssert(method, @"You're attempting to swizzle a method that doesn't exist. (%@, %@)",
   57|     28|             NSStringFromClass(resolvedClass), NSStringFromSelector(selector));
   58|     28|    IMP newImp = imp_implementationWithBlock(block);
   59|     28|
   60|       |#ifdef GUL_UNSWIZZLING_ENABLED
   61|       |    IMP currentImp = class_getMethodImplementation(resolvedClass, selector);
   62|       |    [[GULSwizzlingCache sharedInstance] cacheCurrentIMP:currentImp
   63|       |                                              forNewIMP:newImp
   64|       |                                               forClass:resolvedClass
   65|       |                                           withSelector:selector];
   66|       |#endif
   67|       |
   68|     28|    const char *typeEncoding = method_getTypeEncoding(method);
   69|     28|    __unused IMP originalImpOfClass =
   70|     28|        class_replaceMethod(resolvedClass, selector, newImp, typeEncoding);
   71|     28|
   72|       |#ifdef GUL_UNSWIZZLING_ENABLED
   73|       |    // If !originalImpOfClass, then the IMP came from a superclass.
   74|       |    if (originalImpOfClass) {
   75|       |      if (originalImpOfClass !=
   76|       |          [[GULSwizzlingCache sharedInstance] originalIMPOfCurrentIMP:currentImp]) {
   77|       |        GULLogWarning(kGULLoggerSwizzler, NO,
   78|       |                      [NSString stringWithFormat:@"I-SWZ%06ld",
   79|       |                                                 (long)kGULSwizzlerMessageCodeMethodSwizzling000],
   80|       |                      @"Swizzling class: %@ SEL:%@ after it has been previously been swizzled.",
   81|       |                      NSStringFromClass(resolvedClass), NSStringFromSelector(selector));
   82|       |      }
   83|       |    }
   84|       |#endif
   85|       |  });
   86|     28|}
   87|       |
   88|      0|+ (void)unswizzleClass:(Class)aClass selector:(SEL)selector isClassSelector:(BOOL)isClassSelector {
   89|       |#ifdef GUL_UNSWIZZLING_ENABLED
   90|       |  dispatch_sync(GetGULSwizzlingQueue(), ^{
   91|       |    NSAssert(aClass != nil && selector != nil, @"You cannot unswizzle a nil class or selector.");
   92|       |    Method method = nil;
   93|       |    Class resolvedClass = aClass;
   94|       |    if (isClassSelector) {
   95|       |      resolvedClass = object_getClass(aClass);
   96|       |      method = class_getClassMethod(aClass, selector);
   97|       |    } else {
   98|       |      method = class_getInstanceMethod(aClass, selector);
   99|       |    }
  100|       |    NSAssert(method, @"Couldn't find the method you're unswizzling in the runtime.");
  101|       |    IMP originalImp = [[GULSwizzlingCache sharedInstance] cachedIMPForClass:resolvedClass
  102|       |                                                               withSelector:selector];
  103|       |    NSAssert(originalImp, @"This class/selector combination hasn't been swizzled");
  104|       |    IMP currentImp = method_setImplementation(method, originalImp);
  105|       |    BOOL didRemoveBlock = imp_removeBlock(currentImp);
  106|       |    NSAssert(didRemoveBlock, @"Wasn't able to remove the block of a swizzled IMP.");
  107|       |    [[GULSwizzlingCache sharedInstance] clearCacheForSwizzledIMP:currentImp
  108|       |                                                        selector:selector
  109|       |                                                          aClass:resolvedClass];
  110|       |  });
  111|       |#else
  112|       |  NSAssert(NO, @"Unswizzling is disabled.");
  113|      0|#endif
  114|      0|}
  115|       |
  116|       |+ (nullable IMP)originalImplementationForClass:(Class)aClass
  117|       |                                      selector:(SEL)selector
  118|      0|                               isClassSelector:(BOOL)isClassSelector {
  119|       |#ifdef GUL_UNSWIZZLING_ENABLED
  120|       |  __block IMP originalImp = nil;
  121|       |  dispatch_sync(GetGULSwizzlingQueue(), ^{
  122|       |    Class resolvedClass = isClassSelector ? object_getClass(aClass) : aClass;
  123|       |    originalImp = [[GULSwizzlingCache sharedInstance] cachedIMPForClass:resolvedClass
  124|       |                                                           withSelector:selector];
  125|       |    NSAssert(originalImp, @"The IMP for this class/selector combo doesn't exist (%@, %@).",
  126|       |             NSStringFromClass(resolvedClass), NSStringFromSelector(selector));
  127|       |  });
  128|       |  return originalImp;
  129|       |#else
  130|       |  NSAssert(NO, @"Unswizzling is disabled and the original IMP is not cached.");
  131|      0|  return nil;
  132|      0|#endif
  133|      0|}
  134|       |
  135|       |+ (nullable IMP)currentImplementationForClass:(Class)aClass
  136|       |                                     selector:(SEL)selector
  137|     28|                              isClassSelector:(BOOL)isClassSelector {
  138|     28|  NSAssert(selector, @"The selector cannot be NULL");
  139|     28|  NSAssert(aClass, @"The class cannot be Nil");
  140|     28|  if (selector == NULL || aClass == nil) {
  141|      0|    return nil;
  142|      0|  }
  143|     28|  __block IMP currentIMP = nil;
  144|     28|  dispatch_sync(GetGULSwizzlingQueue(), ^{
  145|     28|    Method method = nil;
  146|     28|    if (isClassSelector) {
  147|      0|      method = class_getClassMethod(aClass, selector);
  148|     28|    } else {
  149|     28|      method = class_getInstanceMethod(aClass, selector);
  150|     28|    }
  151|     28|    NSAssert(method, @"The Method for this class/selector combo doesn't exist (%@, %@).",
  152|     28|             NSStringFromClass(aClass), NSStringFromSelector(selector));
  153|     28|    if (method == nil) {
  154|      0|      return;
  155|      0|    }
  156|     28|    currentIMP = method_getImplementation(method);
  157|     28|    NSAssert(currentIMP, @"The IMP for this class/selector combo doesn't exist (%@, %@).",
  158|     28|             NSStringFromClass(aClass), NSStringFromSelector(selector));
  159|     28|  });
  160|     28|  return currentIMP;
  161|     28|}
  162|       |
  163|      0|+ (BOOL)selector:(SEL)selector existsInClass:(Class)aClass isClassSelector:(BOOL)isClassSelector {
  164|      0|  Method method = isClassSelector ? class_getClassMethod(aClass, selector)
  165|      0|                                  : class_getInstanceMethod(aClass, selector);
  166|      0|  return method != nil;
  167|      0|}
  168|       |
  169|      0|+ (NSArray<id> *)ivarObjectsForObject:(id)object {
  170|      0|  NSMutableArray *array = [NSMutableArray array];
  171|      0|  unsigned int count;
  172|      0|  Ivar *vars = class_copyIvarList([object class], &count);
  173|      0|  for (NSUInteger i = 0; i < count; i++) {
  174|      0|    const char *typeEncoding = ivar_getTypeEncoding(vars[i]);
  175|      0|    // Check to see if the ivar is an object.
  176|      0|    if (strncmp(typeEncoding, "@", 1) == 0) {
  177|      0|      id ivarObject = object_getIvar(object, vars[i]);
  178|      0|      [array addObject:ivarObject];
  179|      0|    }
  180|      0|  }
  181|      0|  free(vars);
  182|      0|  return array;
  183|      0|}
  184|       |
  185|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/NSData+zlib/GULNSData+zlib.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GULNSData+zlib.h"
   16|       |
   17|       |#import <zlib.h>
   18|       |
   19|     46|#define kChunkSize 1024
   20|     20|#define Z_DEFAULT_COMPRESSION (-1)
   21|       |
   22|       |NSString *const GULNSDataZlibErrorDomain = @"com.google.GULNSDataZlibErrorDomain";
   23|       |NSString *const GULNSDataZlibErrorKey = @"GULNSDataZlibErrorKey";
   24|       |NSString *const GULNSDataZlibRemainingBytesKey = @"GULNSDataZlibRemainingBytesKey";
   25|       |
   26|       |@implementation NSData (GULGzip)
   27|       |
   28|      3|+ (NSData *)gul_dataByInflatingGzippedData:(NSData *)data error:(NSError **)error {
   29|      3|  const void *bytes = [data bytes];
   30|      3|  NSUInteger length = [data length];
   31|      3|  if (!bytes || !length) {
   32|      0|    return nil;
   33|      0|  }
   34|      3|
   35|      3|#if defined(__LP64__) && __LP64__
   36|      3|  // Don't support > 32bit length for 64 bit, see note in header.
   37|      3|  if (length > UINT_MAX) {
   38|      0|    return nil;
   39|      0|  }
   40|      3|#endif
   41|      3|
   42|      3|  z_stream strm;
   43|      3|  bzero(&strm, sizeof(z_stream));
   44|      3|
   45|      3|  // Setup the input.
   46|      3|  strm.avail_in = (unsigned int)length;
   47|      3|  strm.next_in = (unsigned char *)bytes;
   48|      3|
   49|      3|  int windowBits = 15;  // 15 to enable any window size
   50|      3|  windowBits += 32;     // and +32 to enable zlib or gzip header detection.
   51|      3|
   52|      3|  int retCode;
   53|      3|  if ((retCode = inflateInit2(&strm, windowBits)) != Z_OK) {
   54|      0|    if (error) {
   55|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
   56|      0|                                                           forKey:GULNSDataZlibErrorKey];
   57|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
   58|      0|                                   code:GULNSDataZlibErrorInternal
   59|      0|                               userInfo:userInfo];
   60|      0|    }
   61|      0|    return nil;
   62|      0|  }
   63|      3|
   64|      3|  // Hint the size at 4x the input size.
   65|      3|  NSMutableData *result = [NSMutableData dataWithCapacity:(length * 4)];
   66|      3|  unsigned char output[kChunkSize];
   67|      3|
   68|      3|  // Loop to collect the data.
   69|      3|  do {
   70|      3|    // Update what we're passing in.
   71|      3|    strm.avail_out = kChunkSize;
   72|      3|    strm.next_out = output;
   73|      3|    retCode = inflate(&strm, Z_NO_FLUSH);
   74|      3|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
   75|      0|      if (error) {
   76|      0|        NSMutableDictionary *userInfo =
   77|      0|            [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
   78|      0|                                               forKey:GULNSDataZlibErrorKey];
   79|      0|        if (strm.msg) {
   80|      0|          NSString *message = [NSString stringWithUTF8String:strm.msg];
   81|      0|          if (message) {
   82|      0|            [userInfo setObject:message forKey:NSLocalizedDescriptionKey];
   83|      0|          }
   84|      0|        }
   85|      0|        *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
   86|      0|                                     code:GULNSDataZlibErrorInternal
   87|      0|                                 userInfo:userInfo];
   88|      0|      }
   89|      0|      inflateEnd(&strm);
   90|      0|      return nil;
   91|      0|    }
   92|      3|    // Collect what we got.
   93|      3|    unsigned gotBack = kChunkSize - strm.avail_out;
   94|      3|    if (gotBack > 0) {
   95|      3|      [result appendBytes:output length:gotBack];
   96|      3|    }
   97|      3|
   98|      3|  } while (retCode == Z_OK);
   99|      3|
  100|      3|  // Make sure there wasn't more data tacked onto the end of a valid compressed stream.
  101|      3|  if (strm.avail_in != 0) {
  102|      0|    if (error) {
  103|      0|      NSDictionary *userInfo =
  104|      0|          [NSDictionary dictionaryWithObject:[NSNumber numberWithUnsignedInt:strm.avail_in]
  105|      0|                                      forKey:GULNSDataZlibRemainingBytesKey];
  106|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  107|      0|                                   code:GULNSDataZlibErrorDataRemaining
  108|      0|                               userInfo:userInfo];
  109|      0|    }
  110|      0|    result = nil;
  111|      0|  }
  112|      3|  // The only way out of the loop was by hitting the end of the stream.
  113|      3|  NSAssert(retCode == Z_STREAM_END,
  114|      3|           @"Thought we finished inflate w/o getting a result of stream end, code %d", retCode);
  115|      3|
  116|      3|  // Clean up.
  117|      3|  inflateEnd(&strm);
  118|      3|
  119|      3|  return result;
  120|      3|}
  121|       |
  122|     20|+ (NSData *)gul_dataByGzippingData:(NSData *)data error:(NSError **)error {
  123|     20|  const void *bytes = [data bytes];
  124|     20|  NSUInteger length = [data length];
  125|     20|
  126|     20|  int level = Z_DEFAULT_COMPRESSION;
  127|     20|  if (!bytes || !length) {
  128|      0|    return nil;
  129|      0|  }
  130|     20|
  131|     20|#if defined(__LP64__) && __LP64__
  132|     20|  // Don't support > 32bit length for 64 bit, see note in header.
  133|     20|  if (length > UINT_MAX) {
  134|      0|    if (error) {
  135|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  136|      0|                                   code:GULNSDataZlibErrorGreaterThan32BitsToCompress
  137|      0|                               userInfo:nil];
  138|      0|    }
  139|      0|    return nil;
  140|      0|  }
  141|     20|#endif
  142|     20|
  143|     20|  z_stream strm;
  144|     20|  bzero(&strm, sizeof(z_stream));
  145|     20|
  146|     20|  int memLevel = 8;          // Default.
  147|     20|  int windowBits = 15 + 16;  // Enable gzip header instead of zlib header.
  148|     20|
  149|     20|  int retCode;
  150|     20|  if ((retCode = deflateInit2(&strm, level, Z_DEFLATED, windowBits, memLevel,
  151|     20|                              Z_DEFAULT_STRATEGY)) != Z_OK) {
  152|      0|    if (error) {
  153|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  154|      0|                                                           forKey:GULNSDataZlibErrorKey];
  155|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  156|      0|                                   code:GULNSDataZlibErrorInternal
  157|      0|                               userInfo:userInfo];
  158|      0|    }
  159|      0|    return nil;
  160|      0|  }
  161|     20|
  162|     20|  // Hint the size at 1/4 the input size.
  163|     20|  NSMutableData *result = [NSMutableData dataWithCapacity:(length / 4)];
  164|     20|  unsigned char output[kChunkSize];
  165|     20|
  166|     20|  // Setup the input.
  167|     20|  strm.avail_in = (unsigned int)length;
  168|     20|  strm.next_in = (unsigned char *)bytes;
  169|     20|
  170|     20|  // Collect the data.
  171|     20|  do {
  172|     20|    // update what we're passing in
  173|     20|    strm.avail_out = kChunkSize;
  174|     20|    strm.next_out = output;
  175|     20|    retCode = deflate(&strm, Z_FINISH);
  176|     20|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
  177|      0|      if (error) {
  178|      0|        NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  179|      0|                                                             forKey:GULNSDataZlibErrorKey];
  180|      0|        *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  181|      0|                                     code:GULNSDataZlibErrorInternal
  182|      0|                                 userInfo:userInfo];
  183|      0|      }
  184|      0|      deflateEnd(&strm);
  185|      0|      return nil;
  186|      0|    }
  187|     20|    // Collect what we got.
  188|     20|    unsigned gotBack = kChunkSize - strm.avail_out;
  189|     20|    if (gotBack > 0) {
  190|     20|      [result appendBytes:output length:gotBack];
  191|     20|    }
  192|     20|
  193|     20|  } while (retCode == Z_OK);
  194|     20|
  195|     20|  // If the loop exits, it used all input and the stream ended.
  196|     20|  NSAssert(strm.avail_in == 0,
  197|     20|           @"Should have finished deflating without using all input, %u bytes left", strm.avail_in);
  198|     20|  NSAssert(retCode == Z_STREAM_END,
  199|     20|           @"thought we finished deflate w/o getting a result of stream end, code %d", retCode);
  200|     20|
  201|     20|  // Clean up.
  202|     20|  deflateEnd(&strm);
  203|     20|
  204|     20|  return result;
  205|     20|}
  206|       |
  207|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/Network/GULMutableDictionary.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/GULMutableDictionary.h"
   16|       |
   17|       |@implementation GULMutableDictionary {
   18|       |  /// The mutable dictionary.
   19|       |  NSMutableDictionary *_objects;
   20|       |
   21|       |  /// Serial synchronization queue. All reads should use dispatch_sync, while writes use
   22|       |  /// dispatch_async.
   23|       |  dispatch_queue_t _queue;
   24|       |}
   25|       |
   26|     70|- (instancetype)init {
   27|     70|  self = [super init];
   28|     70|
   29|     70|  if (self) {
   30|     70|    _objects = [[NSMutableDictionary alloc] init];
   31|     70|    _queue = dispatch_queue_create("GULMutableDictionary", DISPATCH_QUEUE_SERIAL);
   32|     70|  }
   33|     70|
   34|     70|  return self;
   35|     70|}
   36|       |
   37|      0|- (NSString *)description {
   38|      0|  __block NSString *description;
   39|      0|  dispatch_sync(_queue, ^{
   40|      0|    description = self->_objects.description;
   41|      0|  });
   42|      0|  return description;
   43|      0|}
   44|       |
   45|  1.95k|- (id)objectForKey:(id)key {
   46|  1.95k|  __block id object;
   47|  1.95k|  dispatch_sync(_queue, ^{
   48|  1.95k|    object = self->_objects[key];
   49|  1.95k|  });
   50|  1.95k|  return object;
   51|  1.95k|}
   52|       |
   53|    363|- (void)setObject:(id)object forKey:(id<NSCopying>)key {
   54|    363|  dispatch_async(_queue, ^{
   55|    363|    self->_objects[key] = object;
   56|    363|  });
   57|    363|}
   58|       |
   59|     18|- (void)removeObjectForKey:(id)key {
   60|     18|  dispatch_async(_queue, ^{
   61|     18|    [self->_objects removeObjectForKey:key];
   62|     18|  });
   63|     18|}
   64|       |
   65|     24|- (void)removeAllObjects {
   66|     24|  dispatch_async(_queue, ^{
   67|     24|    [self->_objects removeAllObjects];
   68|     24|  });
   69|     24|}
   70|       |
   71|     32|- (NSUInteger)count {
   72|     32|  __block NSUInteger count;
   73|     32|  dispatch_sync(_queue, ^{
   74|     32|    count = self->_objects.count;
   75|     32|  });
   76|     32|  return count;
   77|     32|}
   78|       |
   79|  1.95k|- (id)objectForKeyedSubscript:(id<NSCopying>)key {
   80|  1.95k|  // The method this calls is already synchronized.
   81|  1.95k|  return [self objectForKey:key];
   82|  1.95k|}
   83|       |
   84|    363|- (void)setObject:(id)obj forKeyedSubscript:(id<NSCopying>)key {
   85|    363|  // The method this calls is already synchronized.
   86|    363|  [self setObject:obj forKey:key];
   87|    363|}
   88|       |
   89|      0|- (NSDictionary *)dictionary {
   90|      0|  __block NSDictionary *dictionary;
   91|      0|  dispatch_sync(_queue, ^{
   92|      0|    dictionary = [self->_objects copy];
   93|      0|  });
   94|      0|  return dictionary;
   95|      0|}
   96|       |
   97|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/Network/GULNetwork.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/GULNetwork.h"
   16|       |#import "Private/GULNetworkMessageCode.h"
   17|       |
   18|       |#import <GoogleUtilities/GULLogger.h>
   19|       |#import <GoogleUtilities/GULNSData+zlib.h>
   20|       |#import <GoogleUtilities/GULReachabilityChecker.h>
   21|       |#import "Private/GULMutableDictionary.h"
   22|       |#import "Private/GULNetworkConstants.h"
   23|       |
   24|       |/// Constant string for request header Content-Encoding.
   25|       |static NSString *const kGULNetworkContentCompressionKey = @"Content-Encoding";
   26|       |
   27|       |/// Constant string for request header Content-Encoding value.
   28|       |static NSString *const kGULNetworkContentCompressionValue = @"gzip";
   29|       |
   30|       |/// Constant string for request header Content-Length.
   31|       |static NSString *const kGULNetworkContentLengthKey = @"Content-Length";
   32|       |
   33|       |/// Constant string for request header Content-Type.
   34|       |static NSString *const kGULNetworkContentTypeKey = @"Content-Type";
   35|       |
   36|       |/// Constant string for request header Content-Type value.
   37|       |static NSString *const kGULNetworkContentTypeValue = @"application/x-www-form-urlencoded";
   38|       |
   39|       |/// Constant string for GET request method.
   40|       |static NSString *const kGULNetworkGETRequestMethod = @"GET";
   41|       |
   42|       |/// Constant string for POST request method.
   43|       |static NSString *const kGULNetworkPOSTRequestMethod = @"POST";
   44|       |
   45|       |/// Default constant string as a prefix for network logger.
   46|       |static NSString *const kGULNetworkLogTag = @"Google/Utilities/Network";
   47|       |
   48|       |@interface GULNetwork () <GULReachabilityDelegate, GULNetworkLoggerDelegate>
   49|       |@end
   50|       |
   51|       |@implementation GULNetwork {
   52|       |  /// Network reachability.
   53|       |  GULReachabilityChecker *_reachability;
   54|       |
   55|       |  /// The dictionary of requests by session IDs { NSString : id }.
   56|       |  GULMutableDictionary *_requests;
   57|       |}
   58|       |
   59|     14|- (instancetype)init {
   60|     14|  return [self initWithReachabilityHost:kGULNetworkReachabilityHost];
   61|     14|}
   62|       |
   63|     28|- (instancetype)initWithReachabilityHost:(NSString *)reachabilityHost {
   64|     28|  self = [super init];
   65|     28|  if (self) {
   66|     28|    // Setup reachability.
   67|     28|    _reachability = [[GULReachabilityChecker alloc] initWithReachabilityDelegate:self
   68|     28|                                                                        withHost:reachabilityHost];
   69|     28|    if (![_reachability start]) {
   70|      0|      return nil;
   71|      0|    }
   72|     28|
   73|     28|    _requests = [[GULMutableDictionary alloc] init];
   74|     28|    _timeoutInterval = kGULNetworkTimeOutInterval;
   75|     28|  }
   76|     28|  return self;
   77|     28|}
   78|       |
   79|      0|- (void)dealloc {
   80|      0|  _reachability.reachabilityDelegate = nil;
   81|      0|  [_reachability stop];
   82|      0|}
   83|       |
   84|       |#pragma mark - External Methods
   85|       |
   86|       |+ (void)handleEventsForBackgroundURLSessionID:(NSString *)sessionID
   87|      0|                            completionHandler:(GULNetworkSystemCompletionHandler)completionHandler {
   88|      0|  [GULNetworkURLSession handleEventsForBackgroundURLSessionID:sessionID
   89|      0|                                            completionHandler:completionHandler];
   90|      0|}
   91|       |
   92|       |- (NSString *)postURL:(NSURL *)url
   93|       |                   payload:(NSData *)payload
   94|       |                     queue:(dispatch_queue_t)queue
   95|       |    usingBackgroundSession:(BOOL)usingBackgroundSession
   96|     17|         completionHandler:(GULNetworkCompletionHandler)handler {
   97|     17|  if (!url.absoluteString.length) {
   98|      0|    [self handleErrorWithCode:GULErrorCodeNetworkInvalidURL queue:queue withHandler:handler];
   99|      0|    return nil;
  100|      0|  }
  101|     17|
  102|     17|  NSTimeInterval timeOutInterval = _timeoutInterval ?: kGULNetworkTimeOutInterval;
  103|     17|
  104|     17|  NSMutableURLRequest *request =
  105|     17|      [[NSMutableURLRequest alloc] initWithURL:url
  106|     17|                                   cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
  107|     17|                               timeoutInterval:timeOutInterval];
  108|     17|
  109|     17|  if (!request) {
  110|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  111|      0|                        queue:queue
  112|      0|                  withHandler:handler];
  113|      0|    return nil;
  114|      0|  }
  115|     17|
  116|     17|  NSError *compressError = nil;
  117|     17|  NSData *compressedData = [NSData gul_dataByGzippingData:payload error:&compressError];
  118|     17|  if (!compressedData || compressError) {
  119|      0|    if (compressError || payload.length > 0) {
  120|      0|      // If the payload is not empty but it fails to compress the payload, something has been wrong.
  121|      0|      [self handleErrorWithCode:GULErrorCodeNetworkPayloadCompression
  122|      0|                          queue:queue
  123|      0|                    withHandler:handler];
  124|      0|      return nil;
  125|      0|    }
  126|      0|    compressedData = [[NSData alloc] init];
  127|      0|  }
  128|     17|
  129|     17|  NSString *postLength = @(compressedData.length).stringValue;
  130|     17|
  131|     17|  // Set up the request with the compressed data.
  132|     17|  [request setValue:postLength forHTTPHeaderField:kGULNetworkContentLengthKey];
  133|     17|  request.HTTPBody = compressedData;
  134|     17|  request.HTTPMethod = kGULNetworkPOSTRequestMethod;
  135|     17|  [request setValue:kGULNetworkContentTypeValue forHTTPHeaderField:kGULNetworkContentTypeKey];
  136|     17|  [request setValue:kGULNetworkContentCompressionValue
  137|     17|      forHTTPHeaderField:kGULNetworkContentCompressionKey];
  138|     17|
  139|     17|  GULNetworkURLSession *fetcher = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:self];
  140|     17|  fetcher.backgroundNetworkEnabled = usingBackgroundSession;
  141|     17|
  142|     17|  __weak GULNetwork *weakSelf = self;
  143|     17|  NSString *requestID = [fetcher
  144|     17|      sessionIDFromAsyncPOSTRequest:request
  145|     17|                  completionHandler:^(NSHTTPURLResponse *response, NSData *data,
  146|     17|                                      NSString *sessionID, NSError *error) {
  147|     17|                    GULNetwork *strongSelf = weakSelf;
  148|     17|                    if (!strongSelf) {
  149|      0|                      return;
  150|      0|                    }
  151|     17|                    dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  152|     17|                    dispatch_async(queueToDispatch, ^{
  153|     17|                      if (sessionID.length) {
  154|     17|                        [strongSelf->_requests removeObjectForKey:sessionID];
  155|     17|                      }
  156|     17|                      if (handler) {
  157|     17|                        handler(response, data, error);
  158|     17|                      }
  159|     17|                    });
  160|     17|                  }];
  161|     17|  if (!requestID) {
  162|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  163|      0|                        queue:queue
  164|      0|                  withHandler:handler];
  165|      0|    return nil;
  166|      0|  }
  167|     17|
  168|     17|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  169|     17|                    messageCode:kGULNetworkMessageCodeNetwork000
  170|     17|                        message:@"Uploading data. Host"
  171|     17|                        context:url];
  172|     17|  _requests[requestID] = fetcher;
  173|     17|  return requestID;
  174|     17|}
  175|       |
  176|       |- (NSString *)getURL:(NSURL *)url
  177|       |                   headers:(NSDictionary *)headers
  178|       |                     queue:(dispatch_queue_t)queue
  179|       |    usingBackgroundSession:(BOOL)usingBackgroundSession
  180|      1|         completionHandler:(GULNetworkCompletionHandler)handler {
  181|      1|  if (!url.absoluteString.length) {
  182|      0|    [self handleErrorWithCode:GULErrorCodeNetworkInvalidURL queue:queue withHandler:handler];
  183|      0|    return nil;
  184|      0|  }
  185|      1|
  186|      1|  NSTimeInterval timeOutInterval = _timeoutInterval ?: kGULNetworkTimeOutInterval;
  187|      1|  NSMutableURLRequest *request =
  188|      1|      [[NSMutableURLRequest alloc] initWithURL:url
  189|      1|                                   cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
  190|      1|                               timeoutInterval:timeOutInterval];
  191|      1|
  192|      1|  if (!request) {
  193|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  194|      0|                        queue:queue
  195|      0|                  withHandler:handler];
  196|      0|    return nil;
  197|      0|  }
  198|      1|
  199|      1|  request.HTTPMethod = kGULNetworkGETRequestMethod;
  200|      1|  request.allHTTPHeaderFields = headers;
  201|      1|
  202|      1|  GULNetworkURLSession *fetcher = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:self];
  203|      1|  fetcher.backgroundNetworkEnabled = usingBackgroundSession;
  204|      1|
  205|      1|  __weak GULNetwork *weakSelf = self;
  206|      1|  NSString *requestID = [fetcher
  207|      1|      sessionIDFromAsyncGETRequest:request
  208|      1|                 completionHandler:^(NSHTTPURLResponse *response, NSData *data, NSString *sessionID,
  209|      1|                                     NSError *error) {
  210|      1|                   GULNetwork *strongSelf = weakSelf;
  211|      1|                   if (!strongSelf) {
  212|      0|                     return;
  213|      0|                   }
  214|      1|                   dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  215|      1|                   dispatch_async(queueToDispatch, ^{
  216|      1|                     if (sessionID.length) {
  217|      1|                       [strongSelf->_requests removeObjectForKey:sessionID];
  218|      1|                     }
  219|      1|                     if (handler) {
  220|      1|                       handler(response, data, error);
  221|      1|                     }
  222|      1|                   });
  223|      1|                 }];
  224|      1|
  225|      1|  if (!requestID) {
  226|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  227|      0|                        queue:queue
  228|      0|                  withHandler:handler];
  229|      0|    return nil;
  230|      0|  }
  231|      1|
  232|      1|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  233|      1|                    messageCode:kGULNetworkMessageCodeNetwork001
  234|      1|                        message:@"Downloading data. Host"
  235|      1|                        context:url];
  236|      1|  _requests[requestID] = fetcher;
  237|      1|  return requestID;
  238|      1|}
  239|       |
  240|     32|- (BOOL)hasUploadInProgress {
  241|     32|  return _requests.count > 0;
  242|     32|}
  243|       |
  244|       |#pragma mark - Network Reachability
  245|       |
  246|       |/// Tells reachability delegate to call reachabilityDidChangeToStatus: to notify the network
  247|       |/// reachability has changed.
  248|       |- (void)reachability:(GULReachabilityChecker *)reachability
  249|     28|       statusChanged:(GULReachabilityStatus)status {
  250|     28|  _networkConnected = (status == kGULReachabilityViaCellular || status == kGULReachabilityViaWifi);
  251|     28|  [_reachabilityDelegate reachabilityDidChange];
  252|     28|}
  253|       |
  254|       |#pragma mark - Network logger delegate
  255|       |
  256|     14|- (void)setLoggerDelegate:(id<GULNetworkLoggerDelegate>)loggerDelegate {
  257|     14|  // Explicitly check whether the delegate responds to the methods because conformsToProtocol does
  258|     14|  // not work correctly even though the delegate does respond to the methods.
  259|     14|  if (!loggerDelegate ||
  260|     14|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  261|     14|                                                                messageCode:message:contexts:)] ||
  262|     14|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  263|     14|                                                                messageCode:message:context:)] ||
  264|     14|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  265|     14|                                                                messageCode:message:)]) {
  266|      0|    GULLogError(kGULLoggerNetwork, NO,
  267|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULNetworkMessageCodeNetwork002],
  268|      0|                @"Cannot set the network logger delegate: delegate does not conform to the network "
  269|      0|                 "logger protocol.");
  270|      0|    return;
  271|      0|  }
  272|     14|  _loggerDelegate = loggerDelegate;
  273|     14|}
  274|       |
  275|       |#pragma mark - Private methods
  276|       |
  277|       |/// Handles network error and calls completion handler with the error.
  278|       |- (void)handleErrorWithCode:(NSInteger)code
  279|       |                      queue:(dispatch_queue_t)queue
  280|      0|                withHandler:(GULNetworkCompletionHandler)handler {
  281|      0|  NSDictionary *userInfo = @{kGULNetworkErrorContext : @"Failed to create network request"};
  282|      0|  NSError *error = [[NSError alloc] initWithDomain:kGULNetworkErrorDomain
  283|      0|                                              code:code
  284|      0|                                          userInfo:userInfo];
  285|      0|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  286|      0|                    messageCode:kGULNetworkMessageCodeNetwork002
  287|      0|                        message:@"Failed to create network request. Code, error"
  288|      0|                       contexts:@[ @(code), error ]];
  289|      0|  if (handler) {
  290|      0|    dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  291|      0|    dispatch_async(queueToDispatch, ^{
  292|      0|      handler(nil, nil, error);
  293|      0|    });
  294|      0|  }
  295|      0|}
  296|       |
  297|       |#pragma mark - Network logger
  298|       |
  299|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  300|       |                    messageCode:(GULNetworkMessageCode)messageCode
  301|       |                        message:(NSString *)message
  302|     32|                       contexts:(NSArray *)contexts {
  303|     32|  // Let the delegate log the message if there is a valid logger delegate. Otherwise, just log
  304|     32|  // errors/warnings/info messages to the console log.
  305|     32|  if (_loggerDelegate) {
  306|      0|    [_loggerDelegate GULNetwork_logWithLevel:logLevel
  307|      0|                                 messageCode:messageCode
  308|      0|                                     message:message
  309|      0|                                    contexts:contexts];
  310|      0|    return;
  311|      0|  }
  312|     32|  if (_isDebugModeEnabled || logLevel == kGULNetworkLogLevelError ||
  313|     32|      logLevel == kGULNetworkLogLevelWarning || logLevel == kGULNetworkLogLevelInfo) {
  314|      0|    NSString *formattedMessage = GULStringWithLogMessage(message, logLevel, contexts);
  315|      0|    NSLog(@"%@", formattedMessage);
  316|      0|    GULLogBasic((GULLoggerLevel)logLevel, kGULLoggerNetwork, NO,
  317|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)messageCode], formattedMessage,
  318|      0|                NULL);
  319|      0|  }
  320|     32|}
  321|       |
  322|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  323|       |                    messageCode:(GULNetworkMessageCode)messageCode
  324|       |                        message:(NSString *)message
  325|     36|                        context:(id)context {
  326|     36|  if (_loggerDelegate) {
  327|      4|    [_loggerDelegate GULNetwork_logWithLevel:logLevel
  328|      4|                                 messageCode:messageCode
  329|      4|                                     message:message
  330|      4|                                     context:context];
  331|      4|    return;
  332|      4|  }
  333|     32|  NSArray *contexts = context ? @[ context ] : @[];
  334|     32|  [self GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message contexts:contexts];
  335|     32|}
  336|       |
  337|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  338|       |                    messageCode:(GULNetworkMessageCode)messageCode
  339|      0|                        message:(NSString *)message {
  340|      0|  if (_loggerDelegate) {
  341|      0|    [_loggerDelegate GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message];
  342|      0|    return;
  343|      0|  }
  344|      0|  [self GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message contexts:@[]];
  345|      0|}
  346|       |
  347|       |/// Returns a string for the given log level (e.g. kGULNetworkLogLevelError -> @"ERROR").
  348|      0|static NSString *GULLogLevelDescriptionFromLogLevel(GULNetworkLogLevel logLevel) {
  349|      0|  static NSDictionary *levelNames = nil;
  350|      0|  static dispatch_once_t onceToken;
  351|      0|  dispatch_once(&onceToken, ^{
  352|      0|    levelNames = @{
  353|      0|      @(kGULNetworkLogLevelError) : @"ERROR",
  354|      0|      @(kGULNetworkLogLevelWarning) : @"WARNING",
  355|      0|      @(kGULNetworkLogLevelInfo) : @"INFO",
  356|      0|      @(kGULNetworkLogLevelDebug) : @"DEBUG"
  357|      0|    };
  358|      0|  });
  359|      0|  return levelNames[@(logLevel)];
  360|      0|}
  361|       |
  362|       |/// Returns a formatted string to be used for console logging.
  363|       |static NSString *GULStringWithLogMessage(NSString *message,
  364|       |                                         GULNetworkLogLevel logLevel,
  365|      0|                                         NSArray *contexts) {
  366|      0|  if (!message) {
  367|      0|    message = @"(Message was nil)";
  368|      0|  } else if (!message.length) {
  369|      0|    message = @"(Message was empty)";
  370|      0|  }
  371|      0|  NSMutableString *result = [[NSMutableString alloc]
  372|      0|      initWithFormat:@"<%@/%@> %@", kGULNetworkLogTag, GULLogLevelDescriptionFromLogLevel(logLevel),
  373|      0|                     message];
  374|      0|
  375|      0|  if (!contexts.count) {
  376|      0|    return result;
  377|      0|  }
  378|      0|
  379|      0|  NSMutableArray *formattedContexts = [[NSMutableArray alloc] init];
  380|      0|  for (id item in contexts) {
  381|      0|    [formattedContexts addObject:(item != [NSNull null] ? item : @"(nil)")];
  382|      0|  }
  383|      0|
  384|      0|  [result appendString:@": "];
  385|      0|  [result appendString:[formattedContexts componentsJoinedByString:@", "]];
  386|      0|  return result;
  387|      0|}
  388|       |
  389|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/Network/GULNetworkURLSession.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "Private/GULNetworkURLSession.h"
   18|       |
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |#import "Private/GULMutableDictionary.h"
   21|       |#import "Private/GULNetworkConstants.h"
   22|       |#import "Private/GULNetworkMessageCode.h"
   23|       |
   24|       |@interface GULNetworkURLSession () <NSURLSessionDelegate,
   25|       |                                    NSURLSessionTaskDelegate,
   26|       |                                    NSURLSessionDownloadDelegate>
   27|       |@end
   28|       |
   29|       |@implementation GULNetworkURLSession {
   30|       |  /// The handler to be called when the request completes or error has occurs.
   31|       |  GULNetworkURLSessionCompletionHandler _completionHandler;
   32|       |
   33|       |  /// Session ID generated randomly with a fixed prefix.
   34|       |  NSString *_sessionID;
   35|       |
   36|       |#pragma clang diagnostic push
   37|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   38|       |  /// The session configuration. NSURLSessionConfiguration' is only available on iOS 7.0 or newer.
   39|       |  NSURLSessionConfiguration *_sessionConfig;
   40|       |
   41|       |  /// The current NSURLSession.
   42|       |  NSURLSession *__weak _Nullable _URLSession;
   43|       |#pragma clang diagnostic pop
   44|       |
   45|       |  /// The path to the directory where all temporary files are stored before uploading.
   46|       |  NSURL *_networkDirectoryURL;
   47|       |
   48|       |  /// The downloaded data from fetching.
   49|       |  NSData *_downloadedData;
   50|       |
   51|       |  /// The path to the temporary file which stores the uploading data.
   52|       |  NSURL *_uploadingFileURL;
   53|       |
   54|       |  /// The current request.
   55|       |  NSURLRequest *_request;
   56|       |}
   57|       |
   58|       |#pragma mark - Init
   59|       |
   60|     18|- (instancetype)initWithNetworkLoggerDelegate:(id<GULNetworkLoggerDelegate>)networkLoggerDelegate {
   61|     18|  self = [super init];
   62|     18|  if (self) {
   63|     18|    // Create URL to the directory where all temporary files to upload have to be stored.
   64|     18|    NSArray *paths =
   65|     18|        NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
   66|     18|    NSString *applicationSupportDirectory = paths.firstObject;
   67|     18|    NSArray *tempPathComponents = @[
   68|     18|      applicationSupportDirectory, kGULNetworkApplicationSupportSubdirectory,
   69|     18|      kGULNetworkTempDirectoryName
   70|     18|    ];
   71|     18|    _networkDirectoryURL = [NSURL fileURLWithPathComponents:tempPathComponents];
   72|     18|    _sessionID = [NSString stringWithFormat:@"%@-%@", kGULNetworkBackgroundSessionConfigIDPrefix,
   73|     18|                                            [[NSUUID UUID] UUIDString]];
   74|     18|    _loggerDelegate = networkLoggerDelegate;
   75|     18|  }
   76|     18|  return self;
   77|     18|}
   78|       |
   79|       |#pragma mark - External Methods
   80|       |
   81|       |#pragma mark - To be called from AppDelegate
   82|       |
   83|       |+ (void)handleEventsForBackgroundURLSessionID:(NSString *)sessionID
   84|       |                            completionHandler:
   85|      0|                                (GULNetworkSystemCompletionHandler)systemCompletionHandler {
   86|      0|  // The session may not be Analytics background. Ignore those that do not have the prefix.
   87|      0|  if (![sessionID hasPrefix:kGULNetworkBackgroundSessionConfigIDPrefix]) {
   88|      0|    return;
   89|      0|  }
   90|      0|  GULNetworkURLSession *fetcher = [self fetcherWithSessionIdentifier:sessionID];
   91|      0|  if (fetcher != nil) {
   92|      0|    [fetcher addSystemCompletionHandler:systemCompletionHandler forSession:sessionID];
   93|      0|  } else {
   94|      0|    GULLogError(kGULLoggerNetwork, NO,
   95|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULNetworkMessageCodeNetwork003],
   96|      0|                @"Failed to retrieve background session with ID %@ after app is relaunched.",
   97|      0|                sessionID);
   98|      0|  }
   99|      0|}
  100|       |
  101|       |#pragma mark - External Methods
  102|       |
  103|       |/// Sends an async POST request using NSURLSession for iOS >= 7.0, and returns an ID of the
  104|       |/// connection.
  105|       |- (nullable NSString *)sessionIDFromAsyncPOSTRequest:(NSURLRequest *)request
  106|       |                                   completionHandler:(GULNetworkURLSessionCompletionHandler)handler
  107|     17|    API_AVAILABLE(ios(7.0)) {
  108|     17|  // NSURLSessionUploadTask does not work with NSData in the background.
  109|     17|  // To avoid this issue, write the data to a temporary file to upload it.
  110|     17|  // Make a temporary file with the data subset.
  111|     17|  _uploadingFileURL = [self temporaryFilePathWithSessionID:_sessionID];
  112|     17|  NSError *writeError;
  113|     17|  NSURLSessionUploadTask *postRequestTask;
  114|     17|  NSURLSession *session;
  115|     17|  BOOL didWriteFile = NO;
  116|     17|
  117|     17|  // Clean up the entire temp folder to avoid temp files that remain in case the previous session
  118|     17|  // crashed and did not clean up.
  119|     17|  [self maybeRemoveTempFilesAtURL:_networkDirectoryURL
  120|     17|                     expiringTime:kGULNetworkTempFolderExpireTime];
  121|     17|
  122|     17|  // If there is no background network enabled, no need to write to file. This will allow default
  123|     17|  // network session which runs on the foreground.
  124|     17|  if (_backgroundNetworkEnabled && [self ensureTemporaryDirectoryExists]) {
  125|      0|    didWriteFile = [request.HTTPBody writeToFile:_uploadingFileURL.path
  126|      0|                                         options:NSDataWritingAtomic
  127|      0|                                           error:&writeError];
  128|      0|
  129|      0|    if (writeError) {
  130|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  131|      0|                                   messageCode:kGULNetworkMessageCodeURLSession000
  132|      0|                                       message:@"Failed to write request data to file"
  133|      0|                                       context:writeError];
  134|      0|    }
  135|      0|  }
  136|     17|
  137|     17|  if (didWriteFile) {
  138|      0|    // Exclude this file from backing up to iTunes. There are conflicting reports that excluding
  139|      0|    // directory from backing up does not exclude files of that directory from backing up.
  140|      0|    [self excludeFromBackupForURL:_uploadingFileURL];
  141|      0|
  142|      0|    _sessionConfig = [self backgroundSessionConfigWithSessionID:_sessionID];
  143|      0|    [self populateSessionConfig:_sessionConfig withRequest:request];
  144|      0|    session = [NSURLSession sessionWithConfiguration:_sessionConfig
  145|      0|                                            delegate:self
  146|      0|                                       delegateQueue:[NSOperationQueue mainQueue]];
  147|      0|    postRequestTask = [session uploadTaskWithRequest:request fromFile:_uploadingFileURL];
  148|     17|  } else {
  149|     17|    // If we cannot write to file, just send it in the foreground.
  150|     17|    _sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];
  151|     17|    [self populateSessionConfig:_sessionConfig withRequest:request];
  152|     17|    session = [NSURLSession sessionWithConfiguration:_sessionConfig
  153|     17|                                            delegate:self
  154|     17|                                       delegateQueue:[NSOperationQueue mainQueue]];
  155|     17|    postRequestTask = [session uploadTaskWithRequest:request fromData:request.HTTPBody];
  156|     17|  }
  157|     17|
  158|     17|  if (!session || !postRequestTask) {
  159|      0|    NSError *error = [[NSError alloc]
  160|      0|        initWithDomain:kGULNetworkErrorDomain
  161|      0|                  code:GULErrorCodeNetworkRequestCreation
  162|      0|              userInfo:@{kGULNetworkErrorContext : @"Cannot create network session"}];
  163|      0|    [self callCompletionHandler:handler withResponse:nil data:nil error:error];
  164|      0|    return nil;
  165|      0|  }
  166|     17|
  167|     17|  _URLSession = session;
  168|     17|
  169|     17|  // Save the session into memory.
  170|     17|  [[self class] setSessionInFetcherMap:self forSessionID:_sessionID];
  171|     17|
  172|     17|  _request = [request copy];
  173|     17|
  174|     17|  // Store completion handler because background session does not accept handler block but custom
  175|     17|  // delegate.
  176|     17|  _completionHandler = [handler copy];
  177|     17|  [postRequestTask resume];
  178|     17|
  179|     17|  return _sessionID;
  180|     17|}
  181|       |
  182|       |/// Sends an async GET request using NSURLSession for iOS >= 7.0, and returns an ID of the session.
  183|       |- (nullable NSString *)sessionIDFromAsyncGETRequest:(NSURLRequest *)request
  184|       |                                  completionHandler:(GULNetworkURLSessionCompletionHandler)handler
  185|      1|    API_AVAILABLE(ios(7.0)) {
  186|      1|  if (_backgroundNetworkEnabled) {
  187|      0|    _sessionConfig = [self backgroundSessionConfigWithSessionID:_sessionID];
  188|      1|  } else {
  189|      1|    _sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];
  190|      1|  }
  191|      1|
  192|      1|  [self populateSessionConfig:_sessionConfig withRequest:request];
  193|      1|
  194|      1|  // Do not cache the GET request.
  195|      1|  _sessionConfig.URLCache = nil;
  196|      1|
  197|      1|  NSURLSession *session = [NSURLSession sessionWithConfiguration:_sessionConfig
  198|      1|                                                        delegate:self
  199|      1|                                                   delegateQueue:[NSOperationQueue mainQueue]];
  200|      1|  NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request];
  201|      1|
  202|      1|  if (!session || !downloadTask) {
  203|      0|    NSError *error = [[NSError alloc]
  204|      0|        initWithDomain:kGULNetworkErrorDomain
  205|      0|                  code:GULErrorCodeNetworkRequestCreation
  206|      0|              userInfo:@{kGULNetworkErrorContext : @"Cannot create network session"}];
  207|      0|    [self callCompletionHandler:handler withResponse:nil data:nil error:error];
  208|      0|    return nil;
  209|      0|  }
  210|      1|
  211|      1|  _URLSession = session;
  212|      1|
  213|      1|  // Save the session into memory.
  214|      1|  [[self class] setSessionInFetcherMap:self forSessionID:_sessionID];
  215|      1|
  216|      1|  _request = [request copy];
  217|      1|
  218|      1|  _completionHandler = [handler copy];
  219|      1|  [downloadTask resume];
  220|      1|
  221|      1|  return _sessionID;
  222|      1|}
  223|       |
  224|       |#pragma mark - NSURLSessionTaskDelegate
  225|       |
  226|       |/// Called by the NSURLSession once the download task is completed. The file is saved in the
  227|       |/// provided URL so we need to read the data and store into _downloadedData. Once the session is
  228|       |/// completed, URLSession:task:didCompleteWithError will be called and the completion handler will
  229|       |/// be called with the downloaded data.
  230|       |- (void)URLSession:(NSURLSession *)session
  231|       |                 downloadTask:(NSURLSessionDownloadTask *)task
  232|      1|    didFinishDownloadingToURL:(NSURL *)url API_AVAILABLE(ios(7.0)) {
  233|      1|  if (!url.path) {
  234|      0|    [_loggerDelegate
  235|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  236|      0|                    messageCode:kGULNetworkMessageCodeURLSession001
  237|      0|                        message:@"Unable to read downloaded data from empty temp path"];
  238|      0|    _downloadedData = nil;
  239|      0|    return;
  240|      0|  }
  241|      1|
  242|      1|  NSError *error;
  243|      1|  _downloadedData = [NSData dataWithContentsOfFile:url.path options:0 error:&error];
  244|      1|
  245|      1|  if (error) {
  246|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  247|      0|                                 messageCode:kGULNetworkMessageCodeURLSession002
  248|      0|                                     message:@"Cannot read the content of downloaded data"
  249|      0|                                     context:error];
  250|      0|    _downloadedData = nil;
  251|      0|  }
  252|      1|}
  253|       |
  254|       |#if TARGET_OS_IOS || TARGET_OS_TV
  255|       |- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
  256|      0|    API_AVAILABLE(ios(7.0)) {
  257|      0|  [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  258|      0|                               messageCode:kGULNetworkMessageCodeURLSession003
  259|      0|                                   message:@"Background session finished"
  260|      0|                                   context:session.configuration.identifier];
  261|      0|  [self callSystemCompletionHandler:session.configuration.identifier];
  262|      0|}
  263|       |#endif
  264|       |
  265|       |- (void)URLSession:(NSURLSession *)session
  266|       |                    task:(NSURLSessionTask *)task
  267|     18|    didCompleteWithError:(NSError *)error API_AVAILABLE(ios(7.0)) {
  268|     18|  // Avoid any chance of recursive behavior leading to it being used repeatedly.
  269|     18|  GULNetworkURLSessionCompletionHandler handler = _completionHandler;
  270|     18|  _completionHandler = nil;
  271|     18|
  272|     18|  if (task.response) {
  273|     18|    // The following assertion should always be true for HTTP requests, see https://goo.gl/gVLxT7.
  274|     18|    NSAssert([task.response isKindOfClass:[NSHTTPURLResponse class]], @"URL response must be HTTP");
  275|     18|
  276|     18|    // The server responded so ignore the error created by the system.
  277|     18|    error = nil;
  278|     18|  } else if (!error) {
  279|      0|    error = [[NSError alloc]
  280|      0|        initWithDomain:kGULNetworkErrorDomain
  281|      0|                  code:GULErrorCodeNetworkInvalidResponse
  282|      0|              userInfo:@{kGULNetworkErrorContext : @"Network Error: Empty network response"}];
  283|      0|  }
  284|     18|
  285|     18|  [self callCompletionHandler:handler
  286|     18|                 withResponse:(NSHTTPURLResponse *)task.response
  287|     18|                         data:_downloadedData
  288|     18|                        error:error];
  289|     18|
  290|     18|  // Remove the temp file to avoid trashing devices with lots of temp files.
  291|     18|  [self removeTempItemAtURL:_uploadingFileURL];
  292|     18|
  293|     18|  // Try to clean up stale files again.
  294|     18|  [self maybeRemoveTempFilesAtURL:_networkDirectoryURL
  295|     18|                     expiringTime:kGULNetworkTempFolderExpireTime];
  296|     18|
  297|     18|  // This is called without checking the sessionID here since non-background sessions
  298|     18|  // won't have an ID.
  299|     18|  [session finishTasksAndInvalidate];
  300|     18|
  301|     18|  // Explicitly remove the session so it won't be reused. The weak map table should
  302|     18|  // remove the session on deallocation, but dealloc may not happen immediately after
  303|     18|  // calling `finishTasksAndInvalidate`.
  304|     18|  NSString *sessionID = session.configuration.identifier;
  305|     18|  [[self class] setSessionInFetcherMap:nil forSessionID:sessionID];
  306|     18|}
  307|       |
  308|       |- (void)URLSession:(NSURLSession *)session
  309|       |                   task:(NSURLSessionTask *)task
  310|       |    didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
  311|       |      completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition,
  312|       |                                  NSURLCredential *credential))completionHandler
  313|     18|    API_AVAILABLE(ios(7.0)) {
  314|     18|  // The handling is modeled after GTMSessionFetcher.
  315|     18|  if ([challenge.protectionSpace.authenticationMethod
  316|     18|          isEqualToString:NSURLAuthenticationMethodServerTrust]) {
  317|     18|    SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;
  318|     18|    if (serverTrust == NULL) {
  319|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  320|      0|                                   messageCode:kGULNetworkMessageCodeURLSession004
  321|      0|                                       message:@"Received empty server trust for host. Host"
  322|      0|                                       context:_request.URL];
  323|      0|      completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
  324|      0|      return;
  325|      0|    }
  326|     18|    NSURLCredential *credential = [NSURLCredential credentialForTrust:serverTrust];
  327|     18|    if (!credential) {
  328|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  329|      0|                                   messageCode:kGULNetworkMessageCodeURLSession005
  330|      0|                                       message:@"Unable to verify server identity. Host"
  331|      0|                                       context:_request.URL];
  332|      0|      completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
  333|      0|      return;
  334|      0|    }
  335|     18|
  336|     18|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  337|     18|                                 messageCode:kGULNetworkMessageCodeURLSession006
  338|     18|                                     message:@"Received SSL challenge for host. Host"
  339|     18|                                     context:_request.URL];
  340|     18|
  341|     18|    void (^callback)(BOOL) = ^(BOOL allow) {
  342|     18|      if (allow) {
  343|     18|        completionHandler(NSURLSessionAuthChallengeUseCredential, credential);
  344|     18|      } else {
  345|      0|        [self->_loggerDelegate
  346|      0|            GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  347|      0|                        messageCode:kGULNetworkMessageCodeURLSession007
  348|      0|                            message:@"Cancelling authentication challenge for host. Host"
  349|      0|                            context:self->_request.URL];
  350|      0|        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
  351|      0|      }
  352|     18|    };
  353|     18|
  354|     18|    // Retain the trust object to avoid a SecTrustEvaluate() crash on iOS 7.
  355|     18|    CFRetain(serverTrust);
  356|     18|
  357|     18|    // Evaluate the certificate chain.
  358|     18|    //
  359|     18|    // The delegate queue may be the main thread. Trust evaluation could cause some
  360|     18|    // blocking network activity, so we must evaluate async, as documented at
  361|     18|    // https://developer.apple.com/library/ios/technotes/tn2232/
  362|     18|    dispatch_queue_t evaluateBackgroundQueue =
  363|     18|        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
  364|     18|
  365|     18|    dispatch_async(evaluateBackgroundQueue, ^{
  366|     18|      SecTrustResultType trustEval = kSecTrustResultInvalid;
  367|     18|      BOOL shouldAllow;
  368|     18|      OSStatus trustError;
  369|     18|
  370|     18|      @synchronized([GULNetworkURLSession class]) {
  371|     18|        trustError = SecTrustEvaluate(serverTrust, &trustEval);
  372|     18|      }
  373|     18|
  374|     18|      if (trustError != errSecSuccess) {
  375|      0|        [self->_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  376|      0|                                           messageCode:kGULNetworkMessageCodeURLSession008
  377|      0|                                               message:@"Cannot evaluate server trust. Error, host"
  378|      0|                                              contexts:@[ @(trustError), self->_request.URL ]];
  379|      0|        shouldAllow = NO;
  380|     18|      } else {
  381|     18|        // Having a trust level "unspecified" by the user is the usual result, described at
  382|     18|        // https://developer.apple.com/library/mac/qa/qa1360
  383|     18|        shouldAllow =
  384|     18|            (trustEval == kSecTrustResultUnspecified || trustEval == kSecTrustResultProceed);
  385|     18|      }
  386|     18|
  387|     18|      // Call the call back with the permission.
  388|     18|      callback(shouldAllow);
  389|     18|
  390|     18|      CFRelease(serverTrust);
  391|     18|    });
  392|     18|    return;
  393|     18|  }
  394|      0|
  395|      0|  // Default handling for other Auth Challenges.
  396|      0|  completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
  397|      0|}
  398|       |
  399|       |#pragma mark - Internal Methods
  400|       |
  401|       |/// Stores system completion handler with session ID as key.
  402|       |- (void)addSystemCompletionHandler:(GULNetworkSystemCompletionHandler)handler
  403|      0|                        forSession:(NSString *)identifier {
  404|      0|  if (!handler) {
  405|      0|    [_loggerDelegate
  406|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  407|      0|                    messageCode:kGULNetworkMessageCodeURLSession009
  408|      0|                        message:@"Cannot store nil system completion handler in network"];
  409|      0|    return;
  410|      0|  }
  411|      0|
  412|      0|  if (!identifier.length) {
  413|      0|    [_loggerDelegate
  414|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  415|      0|                    messageCode:kGULNetworkMessageCodeURLSession010
  416|      0|                        message:@"Cannot store system completion handler with empty network "
  417|      0|                                 "session identifier"];
  418|      0|    return;
  419|      0|  }
  420|      0|
  421|      0|  GULMutableDictionary *systemCompletionHandlers =
  422|      0|      [[self class] sessionIDToSystemCompletionHandlerDictionary];
  423|      0|  if (systemCompletionHandlers[identifier]) {
  424|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  425|      0|                                 messageCode:kGULNetworkMessageCodeURLSession011
  426|      0|                                     message:@"Got multiple system handlers for a single session ID"
  427|      0|                                     context:identifier];
  428|      0|  }
  429|      0|
  430|      0|  systemCompletionHandlers[identifier] = handler;
  431|      0|}
  432|       |
  433|       |/// Calls the system provided completion handler with the session ID stored in the dictionary.
  434|       |/// The handler will be removed from the dictionary after being called.
  435|      0|- (void)callSystemCompletionHandler:(NSString *)identifier {
  436|      0|  GULMutableDictionary *systemCompletionHandlers =
  437|      0|      [[self class] sessionIDToSystemCompletionHandlerDictionary];
  438|      0|  GULNetworkSystemCompletionHandler handler = [systemCompletionHandlers objectForKey:identifier];
  439|      0|
  440|      0|  if (handler) {
  441|      0|    [systemCompletionHandlers removeObjectForKey:identifier];
  442|      0|
  443|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  444|      0|      handler();
  445|      0|    });
  446|      0|  }
  447|      0|}
  448|       |
  449|       |/// Sets or updates the session ID of this session.
  450|      0|- (void)setSessionID:(NSString *)sessionID {
  451|      0|  _sessionID = [sessionID copy];
  452|      0|}
  453|       |
  454|       |/// Creates a background session configuration with the session ID using the supported method.
  455|       |- (NSURLSessionConfiguration *)backgroundSessionConfigWithSessionID:(NSString *)sessionID
  456|      0|    API_AVAILABLE(ios(7.0)) {
  457|      0|#if (TARGET_OS_OSX && defined(MAC_OS_X_VERSION_10_10) &&         \
  458|      0|     MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10) || \
  459|      0|    TARGET_OS_TV ||                                              \
  460|      0|    (TARGET_OS_IOS && defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_8_0)
  461|      0|
  462|      0|  // iOS 8/10.10 builds require the new backgroundSessionConfiguration method name.
  463|      0|  return [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionID];
  464|      0|
  465|       |#elif (TARGET_OS_OSX && defined(MAC_OS_X_VERSION_10_10) &&        \
  466|       |       MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_10) || \
  467|       |    (TARGET_OS_IOS && defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_8_0)
  468|       |
  469|       |  // Do a runtime check to avoid a deprecation warning about using
  470|       |  // +backgroundSessionConfiguration: on iOS 8.
  471|       |  if ([NSURLSessionConfiguration
  472|       |          respondsToSelector:@selector(backgroundSessionConfigurationWithIdentifier:)]) {
  473|       |    // Running on iOS 8+/OS X 10.10+.
  474|       |#pragma clang diagnostic push
  475|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
  476|       |    return [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionID];
  477|       |#pragma clang diagnostic pop
  478|       |  } else {
  479|       |    // Running on iOS 7/OS X 10.9.
  480|       |    return [NSURLSessionConfiguration backgroundSessionConfiguration:sessionID];
  481|       |  }
  482|       |
  483|       |#else
  484|       |  // Building with an SDK earlier than iOS 8/OS X 10.10.
  485|       |  return [NSURLSessionConfiguration backgroundSessionConfiguration:sessionID];
  486|       |#endif
  487|       |}
  488|       |
  489|     35|- (void)maybeRemoveTempFilesAtURL:(NSURL *)folderURL expiringTime:(NSTimeInterval)staleTime {
  490|     35|  if (!folderURL.absoluteString.length) {
  491|      0|    return;
  492|      0|  }
  493|     35|
  494|     35|  NSFileManager *fileManager = [NSFileManager defaultManager];
  495|     35|  NSError *error = nil;
  496|     35|
  497|     35|  NSArray *properties = @[ NSURLCreationDateKey ];
  498|     35|  NSArray *directoryContent =
  499|     35|      [fileManager contentsOfDirectoryAtURL:folderURL
  500|     35|                 includingPropertiesForKeys:properties
  501|     35|                                    options:NSDirectoryEnumerationSkipsSubdirectoryDescendants
  502|     35|                                      error:&error];
  503|     35|  if (error && error.code != NSFileReadNoSuchFileError) {
  504|      0|    [_loggerDelegate
  505|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  506|      0|                    messageCode:kGULNetworkMessageCodeURLSession012
  507|      0|                        message:@"Cannot get files from the temporary network folder. Error"
  508|      0|                        context:error];
  509|      0|    return;
  510|      0|  }
  511|     35|
  512|     35|  if (!directoryContent.count) {
  513|     35|    return;
  514|     35|  }
  515|      0|
  516|      0|  NSTimeInterval now = [NSDate date].timeIntervalSince1970;
  517|      0|  for (NSURL *tempFile in directoryContent) {
  518|      0|    NSDate *creationDate;
  519|      0|    BOOL getCreationDate = [tempFile getResourceValue:&creationDate
  520|      0|                                               forKey:NSURLCreationDateKey
  521|      0|                                                error:NULL];
  522|      0|    if (!getCreationDate) {
  523|      0|      continue;
  524|      0|    }
  525|      0|    NSTimeInterval creationTimeInterval = creationDate.timeIntervalSince1970;
  526|      0|    if (fabs(now - creationTimeInterval) > staleTime) {
  527|      0|      [self removeTempItemAtURL:tempFile];
  528|      0|    }
  529|      0|  }
  530|      0|}
  531|       |
  532|       |/// Removes the temporary file written to disk for sending the request. It has to be cleaned up
  533|       |/// after the session is done.
  534|     18|- (void)removeTempItemAtURL:(NSURL *)fileURL {
  535|     18|  if (!fileURL.absoluteString.length) {
  536|      1|    return;
  537|      1|  }
  538|     17|
  539|     17|  NSFileManager *fileManager = [NSFileManager defaultManager];
  540|     17|  NSError *error = nil;
  541|     17|
  542|     17|  if (![fileManager removeItemAtURL:fileURL error:&error] && error.code != NSFileNoSuchFileError) {
  543|      0|    [_loggerDelegate
  544|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  545|      0|                    messageCode:kGULNetworkMessageCodeURLSession013
  546|      0|                        message:@"Failed to remove temporary uploading data file. Error"
  547|      0|                        context:error.localizedDescription];
  548|      0|  }
  549|     17|}
  550|       |
  551|       |/// Gets the fetcher with the session ID.
  552|      0|+ (instancetype)fetcherWithSessionIdentifier:(NSString *)sessionIdentifier {
  553|      0|  GULNetworkURLSession *session = [self sessionFromFetcherMapForSessionID:sessionIdentifier];
  554|      0|  if (!session && [sessionIdentifier hasPrefix:kGULNetworkBackgroundSessionConfigIDPrefix]) {
  555|      0|    session = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:nil];
  556|      0|    [session setSessionID:sessionIdentifier];
  557|      0|    [self setSessionInFetcherMap:session forSessionID:sessionIdentifier];
  558|      0|  }
  559|      0|  return session;
  560|      0|}
  561|       |
  562|       |/// Returns a map of the fetcher by session ID. Creates a map if it is not created.
  563|       |/// When reading and writing from/to the session map, don't use this method directly.
  564|       |/// To avoid thread safety issues, use one of the helper methods at the bottom of the
  565|       |/// file: setSessionInFetcherMap:forSessionID:, sessionFromFetcherMapForSessionID:
  566|     72|+ (NSMapTable<NSString *, GULNetworkURLSession *> *)sessionIDToFetcherMap {
  567|     72|  static NSMapTable *sessionIDToFetcherMap;
  568|     72|
  569|     72|  static dispatch_once_t sessionMapOnceToken;
  570|     72|  dispatch_once(&sessionMapOnceToken, ^{
  571|     14|    sessionIDToFetcherMap = [NSMapTable strongToWeakObjectsMapTable];
  572|     14|  });
  573|     72|  return sessionIDToFetcherMap;
  574|     72|}
  575|       |
  576|     72|+ (NSLock *)sessionIDToFetcherMapReadWriteLock {
  577|     72|  static NSLock *lock;
  578|     72|
  579|     72|  static dispatch_once_t onceToken;
  580|     72|  dispatch_once(&onceToken, ^{
  581|     14|    lock = [[NSLock alloc] init];
  582|     14|  });
  583|     72|  return lock;
  584|     72|}
  585|       |
  586|       |/// Returns a map of system provided completion handler by session ID. Creates a map if it is not
  587|       |/// created.
  588|      0|+ (GULMutableDictionary *)sessionIDToSystemCompletionHandlerDictionary {
  589|      0|  static GULMutableDictionary *systemCompletionHandlers;
  590|      0|
  591|      0|  static dispatch_once_t systemCompletionHandlerOnceToken;
  592|      0|  dispatch_once(&systemCompletionHandlerOnceToken, ^{
  593|      0|    systemCompletionHandlers = [[GULMutableDictionary alloc] init];
  594|      0|  });
  595|      0|  return systemCompletionHandlers;
  596|      0|}
  597|       |
  598|     17|- (NSURL *)temporaryFilePathWithSessionID:(NSString *)sessionID {
  599|     17|  NSString *tempName = [NSString stringWithFormat:@"GULUpload_temp_%@", sessionID];
  600|     17|  return [_networkDirectoryURL URLByAppendingPathComponent:tempName];
  601|     17|}
  602|       |
  603|       |/// Makes sure that the directory to store temp files exists. If not, tries to create it and returns
  604|       |/// YES. If there is anything wrong, returns NO.
  605|      0|- (BOOL)ensureTemporaryDirectoryExists {
  606|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  607|      0|  NSError *error = nil;
  608|      0|
  609|      0|  // Create a temporary directory if it does not exist or was deleted.
  610|      0|  if ([_networkDirectoryURL checkResourceIsReachableAndReturnError:&error]) {
  611|      0|    return YES;
  612|      0|  }
  613|      0|
  614|      0|  if (error && error.code != NSFileReadNoSuchFileError) {
  615|      0|    [_loggerDelegate
  616|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  617|      0|                    messageCode:kGULNetworkMessageCodeURLSession014
  618|      0|                        message:@"Error while trying to access Network temp folder. Error"
  619|      0|                        context:error];
  620|      0|  }
  621|      0|
  622|      0|  NSError *writeError = nil;
  623|      0|
  624|      0|  [fileManager createDirectoryAtURL:_networkDirectoryURL
  625|      0|        withIntermediateDirectories:YES
  626|      0|                         attributes:nil
  627|      0|                              error:&writeError];
  628|      0|  if (writeError) {
  629|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  630|      0|                                 messageCode:kGULNetworkMessageCodeURLSession015
  631|      0|                                     message:@"Cannot create temporary directory. Error"
  632|      0|                                     context:writeError];
  633|      0|    return NO;
  634|      0|  }
  635|      0|
  636|      0|  // Set the iCloud exclusion attribute on the Documents URL.
  637|      0|  [self excludeFromBackupForURL:_networkDirectoryURL];
  638|      0|
  639|      0|  return YES;
  640|      0|}
  641|       |
  642|      0|- (void)excludeFromBackupForURL:(NSURL *)url {
  643|      0|  if (!url.path) {
  644|      0|    return;
  645|      0|  }
  646|      0|
  647|      0|  // Set the iCloud exclusion attribute on the Documents URL.
  648|      0|  NSError *preventBackupError = nil;
  649|      0|  [url setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:&preventBackupError];
  650|      0|  if (preventBackupError) {
  651|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  652|      0|                                 messageCode:kGULNetworkMessageCodeURLSession016
  653|      0|                                     message:@"Cannot exclude temporary folder from iTunes backup"];
  654|      0|  }
  655|      0|}
  656|       |
  657|       |- (void)URLSession:(NSURLSession *)session
  658|       |                          task:(NSURLSessionTask *)task
  659|       |    willPerformHTTPRedirection:(NSHTTPURLResponse *)response
  660|       |                    newRequest:(NSURLRequest *)request
  661|      0|             completionHandler:(void (^)(NSURLRequest *))completionHandler API_AVAILABLE(ios(7.0)) {
  662|      0|  NSArray *nonAllowedRedirectionCodes = @[
  663|      0|    @(kGULNetworkHTTPStatusCodeFound), @(kGULNetworkHTTPStatusCodeMovedPermanently),
  664|      0|    @(kGULNetworkHTTPStatusCodeMovedTemporarily), @(kGULNetworkHTTPStatusCodeMultipleChoices)
  665|      0|  ];
  666|      0|
  667|      0|  // Allow those not in the non allowed list to be followed.
  668|      0|  if (![nonAllowedRedirectionCodes containsObject:@(response.statusCode)]) {
  669|      0|    completionHandler(request);
  670|      0|    return;
  671|      0|  }
  672|      0|
  673|      0|  // Do not allow redirection if the response code is in the non-allowed list.
  674|      0|  NSURLRequest *newRequest = request;
  675|      0|
  676|      0|  if (response) {
  677|      0|    newRequest = nil;
  678|      0|  }
  679|      0|
  680|      0|  completionHandler(newRequest);
  681|      0|}
  682|       |
  683|       |#pragma mark - Helper Methods
  684|       |
  685|     36|+ (void)setSessionInFetcherMap:(GULNetworkURLSession *)session forSessionID:(NSString *)sessionID {
  686|     36|  [[self sessionIDToFetcherMapReadWriteLock] lock];
  687|     36|  GULNetworkURLSession *existingSession =
  688|     36|      [[[self class] sessionIDToFetcherMap] objectForKey:sessionID];
  689|     36|  if (existingSession) {
  690|      0|    if (session) {
  691|      0|      NSString *message = [NSString stringWithFormat:@"Discarding session: %@", existingSession];
  692|      0|      [existingSession->_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelInfo
  693|      0|                                                    messageCode:kGULNetworkMessageCodeURLSession019
  694|      0|                                                        message:message];
  695|      0|    }
  696|      0|    [existingSession->_URLSession finishTasksAndInvalidate];
  697|      0|  }
  698|     36|  if (session) {
  699|     18|    [[[self class] sessionIDToFetcherMap] setObject:session forKey:sessionID];
  700|     18|  } else {
  701|     18|    [[[self class] sessionIDToFetcherMap] removeObjectForKey:sessionID];
  702|     18|  }
  703|     36|  [[self sessionIDToFetcherMapReadWriteLock] unlock];
  704|     36|}
  705|       |
  706|      0|+ (nullable GULNetworkURLSession *)sessionFromFetcherMapForSessionID:(NSString *)sessionID {
  707|      0|  [[self sessionIDToFetcherMapReadWriteLock] lock];
  708|      0|  GULNetworkURLSession *session = [[[self class] sessionIDToFetcherMap] objectForKey:sessionID];
  709|      0|  [[self sessionIDToFetcherMapReadWriteLock] unlock];
  710|      0|  return session;
  711|      0|}
  712|       |
  713|       |- (void)callCompletionHandler:(GULNetworkURLSessionCompletionHandler)handler
  714|       |                 withResponse:(NSHTTPURLResponse *)response
  715|       |                         data:(NSData *)data
  716|     18|                        error:(NSError *)error {
  717|     18|  if (error) {
  718|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  719|      0|                                 messageCode:kGULNetworkMessageCodeURLSession017
  720|      0|                                     message:@"Encounter network error. Code, error"
  721|      0|                                    contexts:@[ @(error.code), error ]];
  722|      0|  }
  723|     18|
  724|     18|  if (handler) {
  725|     18|    dispatch_async(dispatch_get_main_queue(), ^{
  726|     18|      handler(response, data, self->_sessionID, error);
  727|     18|    });
  728|     18|  }
  729|     18|}
  730|       |
  731|       |// Always use the request parameters even if the default session configuration is more restrictive.
  732|       |- (void)populateSessionConfig:(NSURLSessionConfiguration *)sessionConfig
  733|     18|                  withRequest:(NSURLRequest *)request API_AVAILABLE(ios(7.0)) {
  734|     18|  sessionConfig.HTTPAdditionalHeaders = request.allHTTPHeaderFields;
  735|     18|  sessionConfig.timeoutIntervalForRequest = request.timeoutInterval;
  736|     18|  sessionConfig.timeoutIntervalForResource = request.timeoutInterval;
  737|     18|  sessionConfig.requestCachePolicy = request.cachePolicy;
  738|     18|}
  739|       |
  740|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/Reachability/GULReachabilityChecker.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "GULReachabilityChecker+Internal.h"
   18|       |#import "Private/GULReachabilityChecker.h"
   19|       |#import "Private/GULReachabilityMessageCode.h"
   20|       |
   21|       |#import <GoogleUtilities/GULLogger.h>
   22|       |#import <GoogleUtilities/GULReachabilityChecker.h>
   23|       |
   24|       |static GULLoggerService kGULLoggerReachability = @"[GULReachability]";
   25|       |
   26|       |static void ReachabilityCallback(SCNetworkReachabilityRef reachability,
   27|       |                                 SCNetworkReachabilityFlags flags,
   28|       |                                 void *info);
   29|       |
   30|       |static const struct GULReachabilityApi kGULDefaultReachabilityApi = {
   31|       |    SCNetworkReachabilityCreateWithName,
   32|       |    SCNetworkReachabilitySetCallback,
   33|       |    SCNetworkReachabilityScheduleWithRunLoop,
   34|       |    SCNetworkReachabilityUnscheduleFromRunLoop,
   35|       |    CFRelease,
   36|       |};
   37|       |
   38|       |static NSString *const kGULReachabilityUnknownStatus = @"Unknown";
   39|       |static NSString *const kGULReachabilityConnectedStatus = @"Connected";
   40|       |static NSString *const kGULReachabilityDisconnectedStatus = @"Disconnected";
   41|       |
   42|       |@interface GULReachabilityChecker ()
   43|       |
   44|       |@property(nonatomic, assign) const struct GULReachabilityApi *reachabilityApi;
   45|       |@property(nonatomic, assign) GULReachabilityStatus reachabilityStatus;
   46|       |@property(nonatomic, copy) NSString *host;
   47|       |@property(nonatomic, assign) SCNetworkReachabilityRef reachability;
   48|       |
   49|       |@end
   50|       |
   51|       |@implementation GULReachabilityChecker
   52|       |
   53|       |@synthesize reachabilityApi = reachabilityApi_;
   54|       |@synthesize reachability = reachability_;
   55|       |
   56|      0|- (const struct GULReachabilityApi *)reachabilityApi {
   57|      0|  return reachabilityApi_;
   58|      0|}
   59|       |
   60|      0|- (void)setReachabilityApi:(const struct GULReachabilityApi *)reachabilityApi {
   61|      0|  if (reachability_) {
   62|      0|    GULLogError(kGULLoggerReachability, NO,
   63|      0|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode000],
   64|      0|                @"Cannot change reachability API while reachability is running. "
   65|      0|                @"Call stop first.");
   66|      0|    return;
   67|      0|  }
   68|      0|  reachabilityApi_ = reachabilityApi;
   69|      0|}
   70|       |
   71|       |@synthesize reachabilityStatus = reachabilityStatus_;
   72|       |@synthesize host = host_;
   73|       |@synthesize reachabilityDelegate = reachabilityDelegate_;
   74|       |
   75|      0|- (BOOL)isActive {
   76|      0|  return reachability_ != nil;
   77|      0|}
   78|       |
   79|     28|- (void)setReachabilityDelegate:(id<GULReachabilityDelegate>)reachabilityDelegate {
   80|     28|  if (reachabilityDelegate &&
   81|     28|      (![(NSObject *)reachabilityDelegate conformsToProtocol:@protocol(GULReachabilityDelegate)])) {
   82|      0|    GULLogError(kGULLoggerReachability, NO,
   83|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULReachabilityMessageCode005],
   84|      0|                @"Reachability delegate doesn't conform to Reachability protocol.");
   85|      0|    return;
   86|      0|  }
   87|     28|  reachabilityDelegate_ = reachabilityDelegate;
   88|     28|}
   89|       |
   90|       |- (instancetype)initWithReachabilityDelegate:(id<GULReachabilityDelegate>)reachabilityDelegate
   91|     28|                                    withHost:(NSString *)host {
   92|     28|  self = [super init];
   93|     28|
   94|     28|  if (!host || !host.length) {
   95|      0|    GULLogError(kGULLoggerReachability, NO,
   96|      0|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode001],
   97|      0|                @"Invalid host specified");
   98|      0|    return nil;
   99|      0|  }
  100|     28|  if (self) {
  101|     28|    [self setReachabilityDelegate:reachabilityDelegate];
  102|     28|    reachabilityApi_ = &kGULDefaultReachabilityApi;
  103|     28|    reachabilityStatus_ = kGULReachabilityUnknown;
  104|     28|    host_ = [host copy];
  105|     28|    reachability_ = nil;
  106|     28|  }
  107|     28|  return self;
  108|     28|}
  109|       |
  110|      0|- (void)dealloc {
  111|      0|  reachabilityDelegate_ = nil;
  112|      0|  [self stop];
  113|      0|}
  114|       |
  115|     28|- (BOOL)start {
  116|     28|  if (!reachability_) {
  117|     28|    reachability_ = reachabilityApi_->createWithNameFn(kCFAllocatorDefault, [host_ UTF8String]);
  118|     28|    if (!reachability_) {
  119|      0|      return NO;
  120|      0|    }
  121|     28|    SCNetworkReachabilityContext context = {
  122|     28|        0,                       /* version */
  123|     28|        (__bridge void *)(self), /* info (passed as last parameter to reachability callback) */
  124|     28|        NULL,                    /* retain */
  125|     28|        NULL,                    /* release */
  126|     28|        NULL                     /* copyDescription */
  127|     28|    };
  128|     28|    if (!reachabilityApi_->setCallbackFn(reachability_, ReachabilityCallback, &context) ||
  129|     28|        !reachabilityApi_->scheduleWithRunLoopFn(reachability_, CFRunLoopGetMain(),
  130|     28|                                                 kCFRunLoopCommonModes)) {
  131|      0|      reachabilityApi_->releaseFn(reachability_);
  132|      0|      reachability_ = nil;
  133|      0|
  134|      0|      GULLogError(kGULLoggerReachability, NO,
  135|      0|                  [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode002],
  136|      0|                  @"Failed to start reachability handle");
  137|      0|      return NO;
  138|      0|    }
  139|     28|  }
  140|     28|  GULLogDebug(kGULLoggerReachability, NO,
  141|     28|              [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode003],
  142|     28|              @"Monitoring the network status");
  143|     28|  return YES;
  144|     28|}
  145|       |
  146|      0|- (void)stop {
  147|      0|  if (reachability_) {
  148|      0|    reachabilityStatus_ = kGULReachabilityUnknown;
  149|      0|    reachabilityApi_->unscheduleFromRunLoopFn(reachability_, CFRunLoopGetMain(),
  150|      0|                                              kCFRunLoopCommonModes);
  151|      0|    reachabilityApi_->releaseFn(reachability_);
  152|      0|    reachability_ = nil;
  153|      0|  }
  154|      0|}
  155|       |
  156|     28|- (GULReachabilityStatus)statusForFlags:(SCNetworkReachabilityFlags)flags {
  157|     28|  GULReachabilityStatus status = kGULReachabilityNotReachable;
  158|     28|  // If the Reachable flag is not set, we definitely don't have connectivity.
  159|     28|  if (flags & kSCNetworkReachabilityFlagsReachable) {
  160|     28|    // Reachable flag is set. Check further flags.
  161|     28|    if (!(flags & kSCNetworkReachabilityFlagsConnectionRequired)) {
  162|     28|// Connection required flag is not set, so we have connectivity.
  163|     28|#if TARGET_OS_IOS || TARGET_OS_TV
  164|     28|      status = (flags & kSCNetworkReachabilityFlagsIsWWAN) ? kGULReachabilityViaCellular
  165|     28|                                                           : kGULReachabilityViaWifi;
  166|       |#elif TARGET_OS_OSX
  167|       |      status = kGULReachabilityViaWifi;
  168|       |#endif
  169|      0|    } else if ((flags & (kSCNetworkReachabilityFlagsConnectionOnDemand |
  170|      0|                         kSCNetworkReachabilityFlagsConnectionOnTraffic)) &&
  171|      0|               !(flags & kSCNetworkReachabilityFlagsInterventionRequired)) {
  172|      0|// If the connection on demand or connection on traffic flag is set, and user intervention
  173|      0|// is not required, we have connectivity.
  174|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  175|      0|      status = (flags & kSCNetworkReachabilityFlagsIsWWAN) ? kGULReachabilityViaCellular
  176|      0|                                                           : kGULReachabilityViaWifi;
  177|       |#elif TARGET_OS_OSX
  178|       |      status = kGULReachabilityViaWifi;
  179|       |#endif
  180|       |    }
  181|     28|  }
  182|     28|  return status;
  183|     28|}
  184|       |
  185|     28|- (void)reachabilityFlagsChanged:(SCNetworkReachabilityFlags)flags {
  186|     28|  GULReachabilityStatus status = [self statusForFlags:flags];
  187|     28|  if (reachabilityStatus_ != status) {
  188|     28|    NSString *reachabilityStatusString;
  189|     28|    if (status == kGULReachabilityUnknown) {
  190|      0|      reachabilityStatusString = kGULReachabilityUnknownStatus;
  191|     28|    } else {
  192|     28|      reachabilityStatusString = (status == kGULReachabilityNotReachable)
  193|     28|                                     ? kGULReachabilityDisconnectedStatus
  194|     28|                                     : kGULReachabilityConnectedStatus;
  195|     28|    }
  196|     28|
  197|     28|    GULLogDebug(kGULLoggerReachability, NO,
  198|     28|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode004],
  199|     28|                @"Network status has changed. Code:%@, status:%@", @(status),
  200|     28|                reachabilityStatusString);
  201|     28|    reachabilityStatus_ = status;
  202|     28|    [reachabilityDelegate_ reachability:self statusChanged:reachabilityStatus_];
  203|     28|  }
  204|     28|}
  205|       |
  206|       |@end
  207|       |
  208|       |static void ReachabilityCallback(SCNetworkReachabilityRef reachability,
  209|       |                                 SCNetworkReachabilityFlags flags,
  210|     28|                                 void *info) {
  211|     28|  GULReachabilityChecker *checker = (__bridge GULReachabilityChecker *)info;
  212|     28|  [checker reachabilityFlagsChanged:flags];
  213|     28|}
  214|       |
  215|       |// This function used to be at the top of the file, but it was moved here
  216|       |// as a workaround for a suspected compiler bug. When compiled in Release mode
  217|       |// and run on an iOS device with WiFi disabled, the reachability code crashed
  218|       |// when calling SCNetworkReachabilityScheduleWithRunLoop, or shortly thereafter.
  219|       |// After unsuccessfully trying to diagnose the cause of the crash, it was
  220|       |// discovered that moving this function to the end of the file magically fixed
  221|       |// the crash. If you are going to edit this file, exercise caution and make sure
  222|       |// to test thoroughly with an iOS device under various network conditions.
  223|      0|const NSString *GULReachabilityStatusString(GULReachabilityStatus status) {
  224|      0|  switch (status) {
  225|      0|    case kGULReachabilityUnknown:
  226|      0|      return @"Reachability Unknown";
  227|      0|
  228|      0|    case kGULReachabilityNotReachable:
  229|      0|      return @"Not reachable";
  230|      0|
  231|      0|    case kGULReachabilityViaWifi:
  232|      0|      return @"Reachable via Wifi";
  233|      0|
  234|      0|    case kGULReachabilityViaCellular:
  235|      0|      return @"Reachable via Cellular Data";
  236|      0|
  237|      0|    default:
  238|      0|      return [NSString stringWithFormat:@"Invalid reachability status %d", (int)status];
  239|      0|  }
  240|      0|}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/GoogleUtilities/GoogleUtilities/UserDefaults/GULUserDefaults.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/GULUserDefaults.h"
   16|       |
   17|       |#import <GoogleUtilities/GULLogger.h>
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |static NSTimeInterval const kGULSynchronizeInterval = 1.0;
   22|       |
   23|       |static NSString *const kGULLogFormat = @"I-GUL%06ld";
   24|       |
   25|       |static GULLoggerService kGULLogUserDefaultsService = @"[GoogleUtilities/UserDefaults]";
   26|       |
   27|       |typedef NS_ENUM(NSInteger, GULUDMessageCode) {
   28|       |  GULUDMessageCodeInvalidKeyGet = 1,
   29|       |  GULUDMessageCodeInvalidKeySet = 2,
   30|       |  GULUDMessageCodeInvalidObjectSet = 3,
   31|       |  GULUDMessageCodeSynchronizeFailed = 4,
   32|       |};
   33|       |
   34|       |@interface GULUserDefaults ()
   35|       |
   36|       |/// Equivalent to the suite name for NSUserDefaults.
   37|       |@property(readonly) CFStringRef appNameRef;
   38|       |
   39|       |@property(atomic) BOOL isPreferenceFileExcluded;
   40|       |
   41|       |@end
   42|       |
   43|       |@implementation GULUserDefaults {
   44|       |  // The application name is the same with the suite name of the NSUserDefaults, and it is used for
   45|       |  // preferences.
   46|       |  CFStringRef _appNameRef;
   47|       |}
   48|       |
   49|      0|+ (GULUserDefaults *)standardUserDefaults {
   50|      0|  static GULUserDefaults *standardUserDefaults;
   51|      0|  static dispatch_once_t onceToken;
   52|      0|  dispatch_once(&onceToken, ^{
   53|      0|    standardUserDefaults = [[GULUserDefaults alloc] init];
   54|      0|  });
   55|      0|  return standardUserDefaults;
   56|      0|}
   57|       |
   58|      0|- (instancetype)init {
   59|      0|  return [self initWithSuiteName:nil];
   60|      0|}
   61|       |
   62|     14|- (instancetype)initWithSuiteName:(nullable NSString *)suiteName {
   63|     14|  self = [super init];
   64|     14|
   65|     14|  NSString *name = [suiteName copy];
   66|     14|
   67|     14|  if (self) {
   68|     14|    // `kCFPreferencesCurrentApplication` maps to the same defaults database as
   69|     14|    // `[NSUserDefaults standardUserDefaults]`.
   70|     14|    _appNameRef =
   71|     14|        name.length ? (__bridge_retained CFStringRef)name : kCFPreferencesCurrentApplication;
   72|     14|  }
   73|     14|
   74|     14|  return self;
   75|     14|}
   76|       |
   77|      0|- (void)dealloc {
   78|      0|  // If we're using a custom `_appNameRef` it needs to be released. If it's a constant, it shouldn't
   79|      0|  // need to be released since we don't own it.
   80|      0|  if (CFStringCompare(_appNameRef, kCFPreferencesCurrentApplication, 0) != kCFCompareEqualTo) {
   81|      0|    CFRelease(_appNameRef);
   82|      0|  }
   83|      0|
   84|      0|  [NSObject cancelPreviousPerformRequestsWithTarget:self
   85|      0|                                           selector:@selector(synchronize)
   86|      0|                                             object:nil];
   87|      0|}
   88|       |
   89|     14|- (nullable id)objectForKey:(NSString *)defaultName {
   90|     14|  NSString *key = [defaultName copy];
   91|     14|  if (![key isKindOfClass:[NSString class]] || !key.length) {
   92|      0|    GULLogWarning(@"<GoogleUtilities>", NO,
   93|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidKeyGet],
   94|      0|                  @"Cannot get object for invalid user default key.");
   95|      0|    return nil;
   96|      0|  }
   97|     14|  return (__bridge_transfer id)CFPreferencesCopyAppValue((__bridge CFStringRef)key, _appNameRef);
   98|     14|}
   99|       |
  100|      0|- (void)setObject:(nullable id)value forKey:(NSString *)defaultName {
  101|      0|  NSString *key = [defaultName copy];
  102|      0|  if (![key isKindOfClass:[NSString class]] || !key.length) {
  103|      0|    GULLogWarning(kGULLogUserDefaultsService, NO,
  104|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidKeySet],
  105|      0|                  @"Cannot set object for invalid user default key.");
  106|      0|    return;
  107|      0|  }
  108|      0|  if (!value) {
  109|      0|    CFPreferencesSetAppValue((__bridge CFStringRef)key, NULL, _appNameRef);
  110|      0|    [self scheduleSynchronize];
  111|      0|    return;
  112|      0|  }
  113|      0|  BOOL isAcceptableValue =
  114|      0|      [value isKindOfClass:[NSString class]] || [value isKindOfClass:[NSNumber class]] ||
  115|      0|      [value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]] ||
  116|      0|      [value isKindOfClass:[NSDate class]] || [value isKindOfClass:[NSData class]];
  117|      0|  if (!isAcceptableValue) {
  118|      0|    GULLogWarning(kGULLogUserDefaultsService, NO,
  119|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidObjectSet],
  120|      0|                  @"Cannot set invalid object to user defaults. Must be a string, number, array, "
  121|      0|                  @"dictionary, date, or data. Value: %@",
  122|      0|                  value);
  123|      0|    return;
  124|      0|  }
  125|      0|
  126|      0|  CFPreferencesSetAppValue((__bridge CFStringRef)key, (__bridge CFStringRef)value, _appNameRef);
  127|      0|  [self scheduleSynchronize];
  128|      0|}
  129|       |
  130|      0|- (void)removeObjectForKey:(NSString *)key {
  131|      0|  [self setObject:nil forKey:key];
  132|      0|}
  133|       |
  134|       |#pragma mark - Getters
  135|       |
  136|      0|- (NSInteger)integerForKey:(NSString *)defaultName {
  137|      0|  NSNumber *object = [self objectForKey:defaultName];
  138|      0|  return object.integerValue;
  139|      0|}
  140|       |
  141|      0|- (float)floatForKey:(NSString *)defaultName {
  142|      0|  NSNumber *object = [self objectForKey:defaultName];
  143|      0|  return object.floatValue;
  144|      0|}
  145|       |
  146|      0|- (double)doubleForKey:(NSString *)defaultName {
  147|      0|  NSNumber *object = [self objectForKey:defaultName];
  148|      0|  return object.doubleValue;
  149|      0|}
  150|       |
  151|      0|- (BOOL)boolForKey:(NSString *)defaultName {
  152|      0|  NSNumber *object = [self objectForKey:defaultName];
  153|      0|  return object.boolValue;
  154|      0|}
  155|       |
  156|      0|- (nullable NSString *)stringForKey:(NSString *)defaultName {
  157|      0|  return [self objectForKey:defaultName];
  158|      0|}
  159|       |
  160|      0|- (nullable NSArray *)arrayForKey:(NSString *)defaultName {
  161|      0|  return [self objectForKey:defaultName];
  162|      0|}
  163|       |
  164|      0|- (nullable NSDictionary<NSString *, id> *)dictionaryForKey:(NSString *)defaultName {
  165|      0|  return [self objectForKey:defaultName];
  166|      0|}
  167|       |
  168|       |#pragma mark - Setters
  169|       |
  170|      0|- (void)setInteger:(NSInteger)integer forKey:(NSString *)defaultName {
  171|      0|  [self setObject:@(integer) forKey:defaultName];
  172|      0|}
  173|       |
  174|      0|- (void)setFloat:(float)value forKey:(NSString *)defaultName {
  175|      0|  [self setObject:@(value) forKey:defaultName];
  176|      0|}
  177|       |
  178|      0|- (void)setDouble:(double)doubleNumber forKey:(NSString *)defaultName {
  179|      0|  [self setObject:@(doubleNumber) forKey:defaultName];
  180|      0|}
  181|       |
  182|      0|- (void)setBool:(BOOL)boolValue forKey:(NSString *)defaultName {
  183|      0|  [self setObject:@(boolValue) forKey:defaultName];
  184|      0|}
  185|       |
  186|       |#pragma mark - Save data
  187|       |
  188|      0|- (void)synchronize {
  189|      0|  if (!CFPreferencesAppSynchronize(_appNameRef)) {
  190|      0|    GULLogError(kGULLogUserDefaultsService, NO,
  191|      0|                [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeSynchronizeFailed],
  192|      0|                @"Cannot synchronize user defaults to disk");
  193|      0|  }
  194|      0|}
  195|       |
  196|       |#pragma mark - Private methods
  197|       |
  198|       |/// Removes all values from the search list entry specified by 'domainName', the current user, and
  199|       |/// any host. The change is persistent. Equivalent to -removePersistentDomainForName: of
  200|       |/// NSUserDefaults.
  201|      0|- (void)clearAllData {
  202|      0|  // On macOS, using `kCFPreferencesCurrentHost` will not set all the keys necessary to match
  203|      0|  // `NSUserDefaults`.
  204|       |#if TARGET_OS_OSX
  205|       |  CFStringRef host = kCFPreferencesAnyHost;
  206|       |#else
  207|       |  CFStringRef host = kCFPreferencesCurrentHost;
  208|      0|#endif  // TARGET_OS_OSX
  209|      0|
  210|      0|  CFArrayRef keyList = CFPreferencesCopyKeyList(_appNameRef, kCFPreferencesCurrentUser, host);
  211|      0|  if (!keyList) {
  212|      0|    return;
  213|      0|  }
  214|      0|
  215|      0|  CFPreferencesSetMultiple(NULL, keyList, _appNameRef, kCFPreferencesCurrentUser, host);
  216|      0|  CFRelease(keyList);
  217|      0|  [self scheduleSynchronize];
  218|      0|}
  219|       |
  220|      0|- (void)scheduleSynchronize {
  221|      0|  // Synchronize data using a timer so that multiple set... calls can be coalesced under one
  222|      0|  // synchronize.
  223|      0|  [NSObject cancelPreviousPerformRequestsWithTarget:self
  224|      0|                                           selector:@selector(synchronize)
  225|      0|                                             object:nil];
  226|      0|  // This method may be called on multiple queues (due to set... methods can be called on any queue)
  227|      0|  // synchronize can be scheduled on different queues, so make sure that it does not crash. If this
  228|      0|  // instance goes away, self will be released also, no one will retain it and the schedule won't be
  229|      0|  // called.
  230|      0|  [self performSelector:@selector(synchronize) withObject:nil afterDelay:kGULSynchronizeInterval];
  231|      0|}
  232|       |
  233|       |@end
  234|       |
  235|       |NS_ASSUME_NONNULL_END

