/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/AppDelegateSwizzler/GULAppDelegateSwizzler.m:
    1|       |// Copyright 2018 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <TargetConditionals.h>
   16|       |
   17|       |#import <GoogleUtilities/GULAppDelegateSwizzler.h>
   18|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |#import <GoogleUtilities/GULMutableDictionary.h>
   21|       |#import "GoogleUtilities/AppDelegateSwizzler/Internal/GULAppDelegateSwizzler_Private.h"
   22|       |#import "GoogleUtilities/Common/GULLoggerCodes.h"
   23|       |
   24|       |#import <objc/runtime.h>
   25|       |
   26|       |// Implementations need to be typed before calling the implementation directly to cast the
   27|       |// arguments and the return types correctly. Otherwise, it will crash the app.
   28|       |typedef BOOL (*GULRealOpenURLSourceApplicationAnnotationIMP)(
   29|       |    id, SEL, GULApplication *, NSURL *, NSString *, id);
   30|       |
   31|       |typedef BOOL (*GULRealOpenURLOptionsIMP)(
   32|       |    id, SEL, GULApplication *, NSURL *, NSDictionary<NSString *, id> *);
   33|       |
   34|       |#pragma clang diagnostic push
   35|       |#pragma clang diagnostic ignored "-Wstrict-prototypes"
   36|       |typedef void (*GULRealHandleEventsForBackgroundURLSessionIMP)(
   37|       |    id, SEL, GULApplication *, NSString *, void (^)());
   38|       |#pragma clang diagnostic pop
   39|       |
   40|       |// This is needed to for the library to be warning free on iOS versions < 8.
   41|       |#pragma clang diagnostic push
   42|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   43|       |typedef BOOL (*GULRealContinueUserActivityIMP)(
   44|       |    id, SEL, GULApplication *, NSUserActivity *, void (^)(NSArray *restorableObjects));
   45|       |#pragma clang diagnostic pop
   46|       |
   47|       |typedef void (*GULRealDidRegisterForRemoteNotificationsIMP)(id, SEL, GULApplication *, NSData *);
   48|       |
   49|       |typedef void (*GULRealDidFailToRegisterForRemoteNotificationsIMP)(id,
   50|       |                                                                  SEL,
   51|       |                                                                  GULApplication *,
   52|       |                                                                  NSError *);
   53|       |
   54|       |typedef void (*GULRealDidReceiveRemoteNotificationIMP)(id, SEL, GULApplication *, NSDictionary *);
   55|       |
   56|       |// TODO: Since we don't support iOS 7 anymore, see if we can remove the check below.
   57|       |#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
   58|       |#pragma clang diagnostic push
   59|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   60|       |typedef void (*GULRealDidReceiveRemoteNotificationWithCompletionIMP)(
   61|       |    id, SEL, GULApplication *, NSDictionary *, void (^)(UIBackgroundFetchResult));
   62|       |#pragma clang diagnostic pop
   63|       |#endif  // __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
   64|       |
   65|       |typedef void (^GULAppDelegateInterceptorCallback)(id<GULApplicationDelegate>);
   66|       |
   67|       |// The strings below are the keys for associated objects.
   68|       |static char const *const kGULRealIMPBySelectorKey = "GUL_realIMPBySelector";
   69|       |static char const *const kGULRealClassKey = "GUL_realClass";
   70|       |
   71|       |static NSString *const kGULAppDelegateKeyPath = @"delegate";
   72|       |
   73|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/AppDelegateSwizzler]";
   74|       |
   75|       |// Since Firebase SDKs also use this for app delegate proxying, in order to not be a breaking change
   76|       |// we disable App Delegate proxying when either of these two flags are set to NO.
   77|       |
   78|       |/** Plist key that allows Firebase developers to disable App and Scene Delegate Proxying. */
   79|       |static NSString *const kGULFirebaseAppDelegateProxyEnabledPlistKey =
   80|       |    @"FirebaseAppDelegateProxyEnabled";
   81|       |
   82|       |/** Plist key that allows developers not using Firebase to disable App and Scene Delegate Proxying.
   83|       | */
   84|       |static NSString *const kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey =
   85|       |    @"GoogleUtilitiesAppDelegateProxyEnabled";
   86|       |
   87|       |/** The prefix of the App Delegate. */
   88|       |static NSString *const kGULAppDelegatePrefix = @"GUL_";
   89|       |
   90|       |/** The original instance of App Delegate. */
   91|       |static id<GULApplicationDelegate> gOriginalAppDelegate;
   92|       |
   93|       |/** The original App Delegate class */
   94|       |static Class gOriginalAppDelegateClass;
   95|       |
   96|       |/** The subclass of the original App Delegate. */
   97|       |static Class gAppDelegateSubclass;
   98|       |
   99|       |/** Remote notification methods selectors
  100|       | *
  101|       | *  We have to opt out of referencing APNS related App Delegate methods directly to prevent
  102|       | *  an Apple review warning email about missing Push Notification Entitlement
  103|       | *  (like here: https://github.com/firebase/firebase-ios-sdk/issues/2807). From our experience, the
  104|       | *  warning is triggered when any of the symbols is present in the application sent to review, even
  105|       | *  if the code is never executed. Because GULAppDelegateSwizzler may be used by applications that
  106|       | *  are not using APNS we have to refer to the methods indirectly using selector constructed from
  107|       | *  string.
  108|       | *
  109|       | *  NOTE: None of the methods is proxied unless it is explicitly requested by calling the method
  110|       | *  +[GULAppDelegateSwizzler proxyOriginalDelegateIncludingAPNSMethods]
  111|       | */
  112|       |static NSString *const kGULDidRegisterForRemoteNotificationsSEL =
  113|       |    @"application:didRegisterForRemoteNotificationsWithDeviceToken:";
  114|       |static NSString *const kGULDidFailToRegisterForRemoteNotificationsSEL =
  115|       |    @"application:didFailToRegisterForRemoteNotificationsWithError:";
  116|       |static NSString *const kGULDidReceiveRemoteNotificationSEL =
  117|       |    @"application:didReceiveRemoteNotification:";
  118|       |static NSString *const kGULDidReceiveRemoteNotificationWithCompletionSEL =
  119|       |    @"application:didReceiveRemoteNotification:fetchCompletionHandler:";
  120|       |
  121|       |/**
  122|       | * This class is necessary to store the delegates in an NSArray without retaining them.
  123|       | * [NSValue valueWithNonRetainedObject] also provides this functionality, but does not provide a
  124|       | * zeroing pointer. This will cause EXC_BAD_ACCESS when trying to access the object after it is
  125|       | * dealloced. Instead, this container stores a weak, zeroing reference to the object, which
  126|       | * automatically is set to nil by the runtime when the object is dealloced.
  127|       | */
  128|       |@interface GULZeroingWeakContainer : NSObject
  129|       |
  130|       |/** Stores a weak object. */
  131|       |@property(nonatomic, weak) id object;
  132|       |
  133|       |@end
  134|       |
  135|       |@implementation GULZeroingWeakContainer
  136|       |@end
  137|       |
  138|       |@interface GULAppDelegateObserver : NSObject
  139|       |@end
  140|       |
  141|       |@implementation GULAppDelegateObserver {
  142|       |  BOOL _isObserving;
  143|       |}
  144|       |
  145|      2|+ (GULAppDelegateObserver *)sharedInstance {
  146|      2|  static GULAppDelegateObserver *instance;
  147|      2|  static dispatch_once_t once;
  148|      2|  dispatch_once(&once, ^{
  149|      1|    instance = [[GULAppDelegateObserver alloc] init];
  150|      1|  });
  151|      2|  return instance;
  152|      2|}
  153|       |
  154|      2|- (void)observeUIApplication {
  155|      2|  if (_isObserving) {
  156|      0|    return;
  157|      0|  }
  158|      2|  [[GULAppDelegateSwizzler sharedApplication]
  159|      2|      addObserver:self
  160|      2|       forKeyPath:kGULAppDelegateKeyPath
  161|      2|          options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
  162|      2|          context:nil];
  163|      2|  _isObserving = YES;
  164|      2|}
  165|       |
  166|       |- (void)observeValueForKeyPath:(NSString *)keyPath
  167|       |                      ofObject:(id)object
  168|       |                        change:(NSDictionary *)change
  169|      1|                       context:(void *)context {
  170|      1|  if ([keyPath isEqual:kGULAppDelegateKeyPath]) {
  171|      1|    id newValue = change[NSKeyValueChangeNewKey];
  172|      1|    id oldValue = change[NSKeyValueChangeOldKey];
  173|      1|    if ([newValue isEqual:oldValue]) {
  174|      0|      return;
  175|      0|    }
  176|      1|    // Free the stored app delegate instance because it has been changed to a different instance to
  177|      1|    // avoid keeping it alive forever.
  178|      1|    if ([oldValue isEqual:gOriginalAppDelegate]) {
  179|      1|      gOriginalAppDelegate = nil;
  180|      1|      // Remove the observer. Parse it to NSObject to avoid warning.
  181|      1|      [[GULAppDelegateSwizzler sharedApplication] removeObserver:self
  182|      1|                                                      forKeyPath:kGULAppDelegateKeyPath];
  183|      1|      _isObserving = NO;
  184|      1|    }
  185|      1|  }
  186|      1|}
  187|       |
  188|       |@end
  189|       |
  190|       |@implementation GULAppDelegateSwizzler
  191|       |
  192|       |static dispatch_once_t sProxyAppDelegateOnceToken;
  193|       |static dispatch_once_t sProxyAppDelegateRemoteNotificationOnceToken;
  194|       |
  195|       |#pragma mark - Public methods
  196|       |
  197|      3|+ (BOOL)isAppDelegateProxyEnabled {
  198|      3|  NSDictionary *infoDictionary = [NSBundle mainBundle].infoDictionary;
  199|      3|
  200|      3|  id isFirebaseProxyEnabledPlistValue = infoDictionary[kGULFirebaseAppDelegateProxyEnabledPlistKey];
  201|      3|  id isGoogleProxyEnabledPlistValue =
  202|      3|      infoDictionary[kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey];
  203|      3|
  204|      3|  // Enabled by default.
  205|      3|  BOOL isFirebaseAppDelegateProxyEnabled = YES;
  206|      3|  BOOL isGoogleUtilitiesAppDelegateProxyEnabled = YES;
  207|      3|
  208|      3|  if ([isFirebaseProxyEnabledPlistValue isKindOfClass:[NSNumber class]]) {
  209|      0|    isFirebaseAppDelegateProxyEnabled = [isFirebaseProxyEnabledPlistValue boolValue];
  210|      0|  }
  211|      3|
  212|      3|  if ([isGoogleProxyEnabledPlistValue isKindOfClass:[NSNumber class]]) {
  213|      0|    isGoogleUtilitiesAppDelegateProxyEnabled = [isGoogleProxyEnabledPlistValue boolValue];
  214|      0|  }
  215|      3|
  216|      3|  // Only deactivate the proxy if it is explicitly disabled by app developers using either one of
  217|      3|  // the plist flags.
  218|      3|  return isFirebaseAppDelegateProxyEnabled && isGoogleUtilitiesAppDelegateProxyEnabled;
  219|      3|}
  220|       |
  221|       |+ (GULAppDelegateInterceptorID)registerAppDelegateInterceptor:
  222|      2|    (id<GULApplicationDelegate>)interceptor {
  223|      2|  NSAssert(interceptor, @"AppDelegateProxy cannot add nil interceptor");
  224|      2|  NSAssert([interceptor conformsToProtocol:@protocol(GULApplicationDelegate)],
  225|      2|           @"AppDelegateProxy interceptor does not conform to UIApplicationDelegate");
  226|      2|
  227|      2|  if (!interceptor) {
  228|      0|    GULLogError(kGULLoggerSwizzler, NO,
  229|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  230|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling000],
  231|      0|                @"AppDelegateProxy cannot add nil interceptor.");
  232|      0|    return nil;
  233|      0|  }
  234|      2|  if (![interceptor conformsToProtocol:@protocol(GULApplicationDelegate)]) {
  235|      0|    GULLogError(kGULLoggerSwizzler, NO,
  236|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  237|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling001],
  238|      0|                @"AppDelegateProxy interceptor does not conform to UIApplicationDelegate");
  239|      0|    return nil;
  240|      0|  }
  241|      2|
  242|      2|  // The ID should be the same given the same interceptor object.
  243|      2|  NSString *interceptorID = [NSString stringWithFormat:@"%@%p", kGULAppDelegatePrefix, interceptor];
  244|      2|  if (!interceptorID.length) {
  245|      0|    GULLogError(kGULLoggerSwizzler, NO,
  246|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  247|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling002],
  248|      0|                @"AppDelegateProxy cannot create Interceptor ID.");
  249|      0|    return nil;
  250|      0|  }
  251|      2|  GULZeroingWeakContainer *weakObject = [[GULZeroingWeakContainer alloc] init];
  252|      2|  weakObject.object = interceptor;
  253|      2|  [GULAppDelegateSwizzler interceptors][interceptorID] = weakObject;
  254|      2|  return interceptorID;
  255|      2|}
  256|       |
  257|      0|+ (void)unregisterAppDelegateInterceptorWithID:(GULAppDelegateInterceptorID)interceptorID {
  258|      0|  NSAssert(interceptorID, @"AppDelegateProxy cannot unregister nil interceptor ID.");
  259|      0|  NSAssert(((NSString *)interceptorID).length != 0,
  260|      0|           @"AppDelegateProxy cannot unregister empty interceptor ID.");
  261|      0|
  262|      0|  if (!interceptorID) {
  263|      0|    GULLogError(kGULLoggerSwizzler, NO,
  264|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  265|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling003],
  266|      0|                @"AppDelegateProxy cannot unregister empty interceptor ID.");
  267|      0|    return;
  268|      0|  }
  269|      0|
  270|      0|  GULZeroingWeakContainer *weakContainer = [GULAppDelegateSwizzler interceptors][interceptorID];
  271|      0|  if (!weakContainer.object) {
  272|      0|    GULLogError(kGULLoggerSwizzler, NO,
  273|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  274|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling004],
  275|      0|                @"AppDelegateProxy cannot unregister interceptor that was not registered. "
  276|      0|                 "Interceptor ID %@",
  277|      0|                interceptorID);
  278|      0|    return;
  279|      0|  }
  280|      0|
  281|      0|  [[GULAppDelegateSwizzler interceptors] removeObjectForKey:interceptorID];
  282|      0|}
  283|       |
  284|      2|+ (void)proxyOriginalDelegate {
  285|      2|  if ([GULAppEnvironmentUtil isAppExtension]) {
  286|      0|    return;
  287|      0|  }
  288|      2|
  289|      2|  dispatch_once(&sProxyAppDelegateOnceToken, ^{
  290|      1|    id<GULApplicationDelegate> originalDelegate =
  291|      1|        [GULAppDelegateSwizzler sharedApplication].delegate;
  292|      1|    [GULAppDelegateSwizzler proxyAppDelegate:originalDelegate];
  293|      1|  });
  294|      2|}
  295|       |
  296|      1|+ (void)proxyOriginalDelegateIncludingAPNSMethods {
  297|      1|  if ([GULAppEnvironmentUtil isAppExtension]) {
  298|      0|    return;
  299|      0|  }
  300|      1|
  301|      1|  [self proxyOriginalDelegate];
  302|      1|
  303|      1|  dispatch_once(&sProxyAppDelegateRemoteNotificationOnceToken, ^{
  304|      1|    id<GULApplicationDelegate> appDelegate = [GULAppDelegateSwizzler sharedApplication].delegate;
  305|      1|
  306|      1|    NSMutableDictionary *realImplementationsBySelector =
  307|      1|        [objc_getAssociatedObject(appDelegate, &kGULRealIMPBySelectorKey) mutableCopy];
  308|      1|
  309|      1|    [self proxyRemoteNotificationsMethodsWithAppDelegateSubClass:gAppDelegateSubclass
  310|      1|                                                       realClass:gOriginalAppDelegateClass
  311|      1|                                                     appDelegate:appDelegate
  312|      1|                                   realImplementationsBySelector:realImplementationsBySelector];
  313|      1|
  314|      1|    objc_setAssociatedObject(appDelegate, &kGULRealIMPBySelectorKey,
  315|      1|                             [realImplementationsBySelector copy], OBJC_ASSOCIATION_RETAIN);
  316|      1|    [self reassignAppDelegate];
  317|      1|  });
  318|      1|}
  319|       |
  320|       |#pragma mark - Create proxy
  321|       |
  322|     11|+ (GULApplication *)sharedApplication {
  323|     11|  if ([GULAppEnvironmentUtil isAppExtension]) {
  324|      0|    return nil;
  325|      0|  }
  326|     11|  id sharedApplication = nil;
  327|     11|  Class uiApplicationClass = NSClassFromString(kGULApplicationClassName);
  328|     11|  if (uiApplicationClass &&
  329|     11|      [uiApplicationClass respondsToSelector:(NSSelectorFromString(@"sharedApplication"))]) {
  330|     11|    sharedApplication = [uiApplicationClass sharedApplication];
  331|     11|  }
  332|     11|  return sharedApplication;
  333|     11|}
  334|       |
  335|       |#pragma mark - Override default methods
  336|       |
  337|       |/** Creates a new subclass of the class of the given object and sets the isa value of the given
  338|       | *  object to the new subclass. Additionally this copies methods to that new subclass that allow us
  339|       | *  to intercept UIApplicationDelegate methods. This is better known as isa swizzling.
  340|       | *
  341|       | *  @param appDelegate The object to which you want to isa swizzle. This has to conform to the
  342|       | *      UIApplicationDelegate subclass.
  343|       | *  @return Returns the new subclass.
  344|       | */
  345|      1|+ (nullable Class)createSubclassWithObject:(id<GULApplicationDelegate>)appDelegate {
  346|      1|  Class realClass = [appDelegate class];
  347|      1|
  348|      1|  // Create GUL_<RealAppDelegate>_<UUID>
  349|      1|  NSString *classNameWithPrefix =
  350|      1|      [kGULAppDelegatePrefix stringByAppendingString:NSStringFromClass(realClass)];
  351|      1|  NSString *newClassName =
  352|      1|      [NSString stringWithFormat:@"%@-%@", classNameWithPrefix, [NSUUID UUID].UUIDString];
  353|      1|
  354|      1|  if (NSClassFromString(newClassName)) {
  355|      0|    GULLogError(kGULLoggerSwizzler, NO,
  356|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  357|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling005],
  358|      0|                @"Cannot create a proxy for App Delegate. Subclass already exists. Original Class: "
  359|      0|                @"%@, subclass: %@",
  360|      0|                NSStringFromClass(realClass), newClassName);
  361|      0|    return nil;
  362|      0|  }
  363|      1|
  364|      1|  // Register the new class as subclass of the real one. Do not allocate more than the real class
  365|      1|  // size.
  366|      1|  Class appDelegateSubClass = objc_allocateClassPair(realClass, newClassName.UTF8String, 0);
  367|      1|  if (appDelegateSubClass == Nil) {
  368|      0|    GULLogError(kGULLoggerSwizzler, NO,
  369|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  370|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling006],
  371|      0|                @"Cannot create a proxy for App Delegate. Subclass already exists. Original Class: "
  372|      0|                @"%@, subclass: Nil",
  373|      0|                NSStringFromClass(realClass));
  374|      0|    return nil;
  375|      0|  }
  376|      1|
  377|      1|  NSMutableDictionary<NSString *, NSValue *> *realImplementationsBySelector =
  378|      1|      [[NSMutableDictionary alloc] init];
  379|      1|
  380|      1|  // For application:continueUserActivity:restorationHandler:
  381|      1|  SEL continueUserActivitySEL = @selector(application:continueUserActivity:restorationHandler:);
  382|      1|  [self proxyDestinationSelector:continueUserActivitySEL
  383|      1|      implementationsFromSourceSelector:continueUserActivitySEL
  384|      1|                              fromClass:[GULAppDelegateSwizzler class]
  385|      1|                                toClass:appDelegateSubClass
  386|      1|                              realClass:realClass
  387|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  388|      1|
  389|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  390|      1|  // Add the following methods from GULAppDelegate class, and store the real implementation so it
  391|      1|  // can forward to the real one.
  392|      1|  // For application:openURL:options:
  393|      1|  SEL applicationOpenURLOptionsSEL = @selector(application:openURL:options:);
  394|      1|  if ([appDelegate respondsToSelector:applicationOpenURLOptionsSEL]) {
  395|      0|    // Only add the application:openURL:options: method if the original AppDelegate implements it.
  396|      0|    // This fixes a bug if an app only implements application:openURL:sourceApplication:annotation:
  397|      0|    // (if we add the `options` method, iOS sees that one exists and does not call the
  398|      0|    // `sourceApplication` method, which in this case is the only one the app implements).
  399|      0|
  400|      0|    [self proxyDestinationSelector:applicationOpenURLOptionsSEL
  401|      0|        implementationsFromSourceSelector:applicationOpenURLOptionsSEL
  402|      0|                                fromClass:[GULAppDelegateSwizzler class]
  403|      0|                                  toClass:appDelegateSubClass
  404|      0|                                realClass:realClass
  405|      0|         storeDestinationImplementationTo:realImplementationsBySelector];
  406|      0|  }
  407|      1|
  408|      1|  // For application:handleEventsForBackgroundURLSession:completionHandler:
  409|      1|  SEL handleEventsForBackgroundURLSessionSEL = @selector(application:
  410|      1|                                 handleEventsForBackgroundURLSession:completionHandler:);
  411|      1|  [self proxyDestinationSelector:handleEventsForBackgroundURLSessionSEL
  412|      1|      implementationsFromSourceSelector:handleEventsForBackgroundURLSessionSEL
  413|      1|                              fromClass:[GULAppDelegateSwizzler class]
  414|      1|                                toClass:appDelegateSubClass
  415|      1|                              realClass:realClass
  416|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  417|      1|#endif  // TARGET_OS_IOS || TARGET_OS_TV
  418|      1|
  419|      1|#if TARGET_OS_IOS
  420|      1|  // For application:openURL:sourceApplication:annotation:
  421|      1|  SEL openURLSourceApplicationAnnotationSEL = @selector(application:
  422|      1|                                                            openURL:sourceApplication:annotation:);
  423|      1|
  424|      1|  [self proxyDestinationSelector:openURLSourceApplicationAnnotationSEL
  425|      1|      implementationsFromSourceSelector:openURLSourceApplicationAnnotationSEL
  426|      1|                              fromClass:[GULAppDelegateSwizzler class]
  427|      1|                                toClass:appDelegateSubClass
  428|      1|                              realClass:realClass
  429|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  430|      1|#endif  // TARGET_OS_IOS
  431|      1|
  432|      1|  // Override the description too so the custom class name will not show up.
  433|      1|  [GULAppDelegateSwizzler addInstanceMethodWithDestinationSelector:@selector(description)
  434|      1|                              withImplementationFromSourceSelector:@selector(fakeDescription)
  435|      1|                                                         fromClass:[self class]
  436|      1|                                                           toClass:appDelegateSubClass];
  437|      1|
  438|      1|  // Store original implementations to a fake property of the original delegate.
  439|      1|  objc_setAssociatedObject(appDelegate, &kGULRealIMPBySelectorKey,
  440|      1|                           [realImplementationsBySelector copy], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  441|      1|  objc_setAssociatedObject(appDelegate, &kGULRealClassKey, realClass,
  442|      1|                           OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  443|      1|
  444|      1|  // The subclass size has to be exactly the same size with the original class size. The subclass
  445|      1|  // cannot have more ivars/properties than its superclass since it will cause an offset in memory
  446|      1|  // that can lead to overwriting the isa of an object in the next frame.
  447|      1|  if (class_getInstanceSize(realClass) != class_getInstanceSize(appDelegateSubClass)) {
  448|      0|    GULLogError(kGULLoggerSwizzler, NO,
  449|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  450|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling007],
  451|      0|                @"Cannot create subclass of App Delegate, because the created subclass is not the "
  452|      0|                @"same size. %@",
  453|      0|                NSStringFromClass(realClass));
  454|      0|    NSAssert(NO, @"Classes must be the same size to swizzle isa");
  455|      0|    return nil;
  456|      0|  }
  457|      1|
  458|      1|  // Make the newly created class to be the subclass of the real App Delegate class.
  459|      1|  objc_registerClassPair(appDelegateSubClass);
  460|      1|  if (object_setClass(appDelegate, appDelegateSubClass)) {
  461|      1|    GULLogDebug(kGULLoggerSwizzler, NO,
  462|      1|                [NSString stringWithFormat:@"I-SWZ%06ld",
  463|      1|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling008],
  464|      1|                @"Successfully created App Delegate Proxy automatically. To disable the "
  465|      1|                @"proxy, set the flag %@ to NO (Boolean) in the Info.plist",
  466|      1|                [GULAppDelegateSwizzler correctAppDelegateProxyKey]);
  467|      1|  }
  468|      1|
  469|      1|  return appDelegateSubClass;
  470|      1|}
  471|       |
  472|       |+ (void)proxyRemoteNotificationsMethodsWithAppDelegateSubClass:(Class)appDelegateSubClass
  473|       |                                                     realClass:(Class)realClass
  474|       |                                                   appDelegate:(id)appDelegate
  475|       |                                 realImplementationsBySelector:
  476|      1|                                     (NSMutableDictionary *)realImplementationsBySelector {
  477|      1|  if (realClass == nil || appDelegateSubClass == nil || appDelegate == nil ||
  478|      1|      realImplementationsBySelector == nil) {
  479|      0|    // The App Delegate has not been swizzled.
  480|      0|    return;
  481|      0|  }
  482|      1|
  483|      1|  // For application:didRegisterForRemoteNotificationsWithDeviceToken:
  484|      1|  SEL didRegisterForRemoteNotificationsSEL =
  485|      1|      NSSelectorFromString(kGULDidRegisterForRemoteNotificationsSEL);
  486|      1|  SEL didRegisterForRemoteNotificationsDonorSEL = @selector(application:
  487|      1|                 donor_didRegisterForRemoteNotificationsWithDeviceToken:);
  488|      1|
  489|      1|  [self proxyDestinationSelector:didRegisterForRemoteNotificationsSEL
  490|      1|      implementationsFromSourceSelector:didRegisterForRemoteNotificationsDonorSEL
  491|      1|                              fromClass:[GULAppDelegateSwizzler class]
  492|      1|                                toClass:appDelegateSubClass
  493|      1|                              realClass:realClass
  494|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  495|      1|
  496|      1|  // For application:didFailToRegisterForRemoteNotificationsWithError:
  497|      1|  SEL didFailToRegisterForRemoteNotificationsSEL =
  498|      1|      NSSelectorFromString(kGULDidFailToRegisterForRemoteNotificationsSEL);
  499|      1|  SEL didFailToRegisterForRemoteNotificationsDonorSEL = @selector(application:
  500|      1|                       donor_didFailToRegisterForRemoteNotificationsWithError:);
  501|      1|
  502|      1|  [self proxyDestinationSelector:didFailToRegisterForRemoteNotificationsSEL
  503|      1|      implementationsFromSourceSelector:didFailToRegisterForRemoteNotificationsDonorSEL
  504|      1|                              fromClass:[GULAppDelegateSwizzler class]
  505|      1|                                toClass:appDelegateSubClass
  506|      1|                              realClass:realClass
  507|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  508|      1|
  509|      1|  // For application:didReceiveRemoteNotification:
  510|      1|  SEL didReceiveRemoteNotificationSEL = NSSelectorFromString(kGULDidReceiveRemoteNotificationSEL);
  511|      1|  SEL didReceiveRemoteNotificationDonotSEL = @selector(application:
  512|      1|                                donor_didReceiveRemoteNotification:);
  513|      1|
  514|      1|  [self proxyDestinationSelector:didReceiveRemoteNotificationSEL
  515|      1|      implementationsFromSourceSelector:didReceiveRemoteNotificationDonotSEL
  516|      1|                              fromClass:[GULAppDelegateSwizzler class]
  517|      1|                                toClass:appDelegateSubClass
  518|      1|                              realClass:realClass
  519|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  520|      1|
  521|      1|  // For application:didReceiveRemoteNotification:fetchCompletionHandler:
  522|      1|#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
  523|      1|  if ([GULAppEnvironmentUtil isIOS7OrHigher]) {
  524|      1|    SEL didReceiveRemoteNotificationWithCompletionSEL =
  525|      1|        NSSelectorFromString(kGULDidReceiveRemoteNotificationWithCompletionSEL);
  526|      1|    SEL didReceiveRemoteNotificationWithCompletionDonorSEL =
  527|      1|        @selector(application:donor_didReceiveRemoteNotification:fetchCompletionHandler:);
  528|      1|    if ([appDelegate respondsToSelector:didReceiveRemoteNotificationWithCompletionSEL]) {
  529|      0|      // Only add the application:didReceiveRemoteNotification:fetchCompletionHandler: method if
  530|      0|      // the original AppDelegate implements it.
  531|      0|      // This fixes a bug if an app only implements application:didReceiveRemoteNotification:
  532|      0|      // (if we add the method with completion, iOS sees that one exists and does not call
  533|      0|      // the method without the completion, which in this case is the only one the app implements).
  534|      0|
  535|      0|      [self proxyDestinationSelector:didReceiveRemoteNotificationWithCompletionSEL
  536|      0|          implementationsFromSourceSelector:didReceiveRemoteNotificationWithCompletionDonorSEL
  537|      0|                                  fromClass:[GULAppDelegateSwizzler class]
  538|      0|                                    toClass:appDelegateSubClass
  539|      0|                                  realClass:realClass
  540|      0|           storeDestinationImplementationTo:realImplementationsBySelector];
  541|      0|    }
  542|      1|  }
  543|      1|#endif  // __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
  544|      1|}
  545|       |
  546|       |/// We have to do this to invalidate the cache that caches the original respondsToSelector of
  547|       |/// openURL handlers. Without this, it won't call the default implementations because the system
  548|       |/// checks and caches them.
  549|       |/// Register KVO only once. Otherwise, the observing method will be called as many times as
  550|       |/// being registered.
  551|      2|+ (void)reassignAppDelegate {
  552|      2|#if !TARGET_OS_WATCH
  553|      2|  id<GULApplicationDelegate> delegate = [self sharedApplication].delegate;
  554|      2|  [self sharedApplication].delegate = nil;
  555|      2|  [self sharedApplication].delegate = delegate;
  556|      2|  gOriginalAppDelegate = delegate;
  557|      2|  [[GULAppDelegateObserver sharedInstance] observeUIApplication];
  558|      2|#endif
  559|      2|}
  560|       |
  561|       |#pragma mark - Helper methods
  562|       |
  563|      2|+ (GULMutableDictionary *)interceptors {
  564|      2|  static dispatch_once_t onceToken;
  565|      2|  static GULMutableDictionary *sInterceptors;
  566|      2|  dispatch_once(&onceToken, ^{
  567|      1|    sInterceptors = [[GULMutableDictionary alloc] init];
  568|      1|  });
  569|      2|  return sInterceptors;
  570|      2|}
  571|       |
  572|      0|+ (nullable NSValue *)originalImplementationForSelector:(SEL)selector object:(id)object {
  573|      0|  NSDictionary *realImplementationBySelector =
  574|      0|      objc_getAssociatedObject(object, &kGULRealIMPBySelectorKey);
  575|      0|  return realImplementationBySelector[NSStringFromSelector(selector)];
  576|      0|}
  577|       |
  578|       |+ (void)proxyDestinationSelector:(SEL)destinationSelector
  579|       |    implementationsFromSourceSelector:(SEL)sourceSelector
  580|       |                            fromClass:(Class)sourceClass
  581|       |                              toClass:(Class)destinationClass
  582|       |                            realClass:(Class)realClass
  583|       |     storeDestinationImplementationTo:
  584|      6|         (NSMutableDictionary<NSString *, NSValue *> *)destinationImplementationsBySelector {
  585|      6|  [self addInstanceMethodWithDestinationSelector:destinationSelector
  586|      6|            withImplementationFromSourceSelector:sourceSelector
  587|      6|                                       fromClass:sourceClass
  588|      6|                                         toClass:destinationClass];
  589|      6|  IMP sourceImplementation =
  590|      6|      [GULAppDelegateSwizzler implementationOfMethodSelector:destinationSelector
  591|      6|                                                   fromClass:realClass];
  592|      6|  NSValue *sourceImplementationPointer = [NSValue valueWithPointer:sourceImplementation];
  593|      6|
  594|      6|  NSString *destinationSelectorString = NSStringFromSelector(destinationSelector);
  595|      6|  destinationImplementationsBySelector[destinationSelectorString] = sourceImplementationPointer;
  596|      6|}
  597|       |
  598|       |/** Copies a method identified by the methodSelector from one class to the other. After this method
  599|       | *  is called, performing [toClassInstance methodSelector] will be similar to calling
  600|       | *  [fromClassInstance methodSelector]. This method does nothing if toClass already has a method
  601|       | *  identified by methodSelector.
  602|       | *
  603|       | *  @param methodSelector The SEL that identifies both the method on the fromClass as well as the
  604|       | *      one on the toClass.
  605|       | *  @param fromClass The class from which a method is sourced.
  606|       | *  @param toClass The class to which the method is added. If the class already has a method with
  607|       | *      the same selector, this has no effect.
  608|       | */
  609|       |+ (void)addInstanceMethodWithSelector:(SEL)methodSelector
  610|       |                            fromClass:(Class)fromClass
  611|      0|                              toClass:(Class)toClass {
  612|      0|  [self addInstanceMethodWithDestinationSelector:methodSelector
  613|      0|            withImplementationFromSourceSelector:methodSelector
  614|      0|                                       fromClass:fromClass
  615|      0|                                         toClass:toClass];
  616|      0|}
  617|       |
  618|       |/** Copies a method identified by the sourceSelector from the fromClass as a method for the
  619|       | *  destinationSelector on the toClass. After this method is called, performing
  620|       | *  [toClassInstance destinationSelector] will be similar to calling
  621|       | *  [fromClassInstance sourceSelector]. This method does nothing if toClass already has a method
  622|       | *  identified by destinationSelector.
  623|       | *
  624|       | *  @param destinationSelector The SEL that identifies the method on the toClass.
  625|       | *  @param sourceSelector The SEL that identifies the method on the fromClass.
  626|       | *  @param fromClass The class from which a method is sourced.
  627|       | *  @param toClass The class to which the method is added. If the class already has a method with
  628|       | *      the same selector, this has no effect.
  629|       | */
  630|       |+ (void)addInstanceMethodWithDestinationSelector:(SEL)destinationSelector
  631|       |            withImplementationFromSourceSelector:(SEL)sourceSelector
  632|       |                                       fromClass:(Class)fromClass
  633|      7|                                         toClass:(Class)toClass {
  634|      7|  Method method = class_getInstanceMethod(fromClass, sourceSelector);
  635|      7|  IMP methodIMP = method_getImplementation(method);
  636|      7|  const char *types = method_getTypeEncoding(method);
  637|      7|  if (!class_addMethod(toClass, destinationSelector, methodIMP, types)) {
  638|      0|    GULLogWarning(kGULLoggerSwizzler, NO,
  639|      0|                  [NSString stringWithFormat:@"I-SWZ%06ld",
  640|      0|                                             (long)kGULSwizzlerMessageCodeAppDelegateSwizzling009],
  641|      0|                  @"Cannot copy method to destination selector %@ as it already exists",
  642|      0|                  NSStringFromSelector(destinationSelector));
  643|      0|  }
  644|      7|}
  645|       |
  646|       |/** Gets the IMP of the instance method on the class identified by the selector.
  647|       | *
  648|       | *  @param selector The selector of which the IMP is to be fetched.
  649|       | *  @param aClass The class from which the IMP is to be fetched.
  650|       | *  @return The IMP of the instance method identified by selector and aClass.
  651|       | */
  652|      6|+ (IMP)implementationOfMethodSelector:(SEL)selector fromClass:(Class)aClass {
  653|      6|  Method aMethod = class_getInstanceMethod(aClass, selector);
  654|      6|  return method_getImplementation(aMethod);
  655|      6|}
  656|       |
  657|       |/** Enumerates through all the interceptors and if they respond to a given selector, executes a
  658|       | *  GULAppDelegateInterceptorCallback with the interceptor.
  659|       | *
  660|       | *  @param methodSelector The SEL to check if an interceptor responds to.
  661|       | *  @param callback the GULAppDelegateInterceptorCallback.
  662|       | */
  663|       |+ (void)notifyInterceptorsWithMethodSelector:(SEL)methodSelector
  664|      0|                                    callback:(GULAppDelegateInterceptorCallback)callback {
  665|      0|  if (!callback) {
  666|      0|    return;
  667|      0|  }
  668|      0|
  669|      0|  NSDictionary *interceptors = [GULAppDelegateSwizzler interceptors].dictionary;
  670|      0|  [interceptors enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
  671|      0|    GULZeroingWeakContainer *interceptorContainer = obj;
  672|      0|    id interceptor = interceptorContainer.object;
  673|      0|    if (!interceptor) {
  674|      0|      GULLogWarning(
  675|      0|          kGULLoggerSwizzler, NO,
  676|      0|          [NSString
  677|      0|              stringWithFormat:@"I-SWZ%06ld", (long)kGULSwizzlerMessageCodeAppDelegateSwizzling010],
  678|      0|          @"AppDelegateProxy cannot find interceptor with ID %@. Removing the interceptor.", key);
  679|      0|      [[GULAppDelegateSwizzler interceptors] removeObjectForKey:key];
  680|      0|      return;
  681|      0|    }
  682|      0|    if ([interceptor respondsToSelector:methodSelector]) {
  683|      0|      callback(interceptor);
  684|      0|    }
  685|      0|  }];
  686|      0|}
  687|       |
  688|       |// The methods below are donor methods which are added to the dynamic subclass of the App Delegate.
  689|       |// They are called within the scope of the real App Delegate so |self| does not refer to the
  690|       |// GULAppDelegateSwizzler instance but the real App Delegate instance.
  691|       |
  692|       |#pragma mark - [Donor Methods] Overridden instance description method
  693|       |
  694|      0|- (NSString *)fakeDescription {
  695|      0|  Class realClass = objc_getAssociatedObject(self, &kGULRealClassKey);
  696|      0|  return [NSString stringWithFormat:@"<%@: %p>", realClass, self];
  697|      0|}
  698|       |
  699|       |#pragma mark - [Donor Methods] URL overridden handler methods
  700|       |#if TARGET_OS_IOS || TARGET_OS_TV
  701|       |
  702|       |- (BOOL)application:(GULApplication *)application
  703|       |            openURL:(NSURL *)url
  704|      0|            options:(NSDictionary<NSString *, id> *)options {
  705|      0|  SEL methodSelector = @selector(application:openURL:options:);
  706|      0|  // Call the real implementation if the real App Delegate has any.
  707|      0|  NSValue *openURLIMPPointer =
  708|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  709|      0|  GULRealOpenURLOptionsIMP openURLOptionsIMP = [openURLIMPPointer pointerValue];
  710|      0|
  711|      0|  __block BOOL returnedValue = NO;
  712|      0|
  713|      0|// This is needed to for the library to be warning free on iOS versions < 9.
  714|      0|#pragma clang diagnostic push
  715|      0|#pragma clang diagnostic ignored "-Wunguarded-availability"
  716|      0|  [GULAppDelegateSwizzler
  717|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  718|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  719|      0|                                    returnedValue |= [interceptor application:application
  720|      0|                                                                      openURL:url
  721|      0|                                                                      options:options];
  722|      0|                                  }];
  723|      0|#pragma clang diagnostic pop
  724|      0|  if (openURLOptionsIMP) {
  725|      0|    returnedValue |= openURLOptionsIMP(self, methodSelector, application, url, options);
  726|      0|  }
  727|      0|  return returnedValue;
  728|      0|}
  729|       |
  730|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  731|       |
  732|       |#if TARGET_OS_IOS
  733|       |
  734|       |- (BOOL)application:(GULApplication *)application
  735|       |              openURL:(NSURL *)url
  736|       |    sourceApplication:(NSString *)sourceApplication
  737|      0|           annotation:(id)annotation {
  738|      0|  SEL methodSelector = @selector(application:openURL:sourceApplication:annotation:);
  739|      0|
  740|      0|  // Call the real implementation if the real App Delegate has any.
  741|      0|  NSValue *openURLSourceAppAnnotationIMPPointer =
  742|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  743|      0|  GULRealOpenURLSourceApplicationAnnotationIMP openURLSourceApplicationAnnotationIMP =
  744|      0|      [openURLSourceAppAnnotationIMPPointer pointerValue];
  745|      0|
  746|      0|  __block BOOL returnedValue = NO;
  747|      0|  [GULAppDelegateSwizzler
  748|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  749|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  750|      0|#pragma clang diagnostic push
  751|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  752|      0|                                    returnedValue |= [interceptor application:application
  753|      0|                                                                      openURL:url
  754|      0|                                                            sourceApplication:sourceApplication
  755|      0|                                                                   annotation:annotation];
  756|      0|#pragma clang diagnostic pop
  757|      0|                                  }];
  758|      0|  if (openURLSourceApplicationAnnotationIMP) {
  759|      0|    returnedValue |= openURLSourceApplicationAnnotationIMP(self, methodSelector, application, url,
  760|      0|                                                           sourceApplication, annotation);
  761|      0|  }
  762|      0|  return returnedValue;
  763|      0|}
  764|       |
  765|       |#endif  // TARGET_OS_IOS
  766|       |
  767|       |#pragma mark - [Donor Methods] Network overridden handler methods
  768|       |
  769|       |#if TARGET_OS_IOS || TARGET_OS_TV
  770|       |
  771|       |#pragma clang diagnostic push
  772|       |#pragma clang diagnostic ignored "-Wstrict-prototypes"
  773|       |- (void)application:(GULApplication *)application
  774|       |    handleEventsForBackgroundURLSession:(NSString *)identifier
  775|      0|                      completionHandler:(void (^)())completionHandler API_AVAILABLE(ios(7.0)) {
  776|      0|#pragma clang diagnostic pop
  777|      0|  SEL methodSelector = @selector(application:
  778|      0|         handleEventsForBackgroundURLSession:completionHandler:);
  779|      0|  NSValue *handleBackgroundSessionPointer =
  780|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  781|      0|  GULRealHandleEventsForBackgroundURLSessionIMP handleBackgroundSessionIMP =
  782|      0|      [handleBackgroundSessionPointer pointerValue];
  783|      0|
  784|      0|  // Notify interceptors.
  785|      0|  [GULAppDelegateSwizzler
  786|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  787|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  788|      0|                                    [interceptor application:application
  789|      0|                                        handleEventsForBackgroundURLSession:identifier
  790|      0|                                                          completionHandler:completionHandler];
  791|      0|                                  }];
  792|      0|  // Call the real implementation if the real App Delegate has any.
  793|      0|  if (handleBackgroundSessionIMP) {
  794|      0|    handleBackgroundSessionIMP(self, methodSelector, application, identifier, completionHandler);
  795|      0|  }
  796|      0|}
  797|       |
  798|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  799|       |
  800|       |#pragma mark - [Donor Methods] User Activities overridden handler methods
  801|       |
  802|       |// This is needed to for the library to be warning free on iOS versions < 8.
  803|       |#pragma clang diagnostic push
  804|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
  805|       |- (BOOL)application:(GULApplication *)application
  806|       |    continueUserActivity:(NSUserActivity *)userActivity
  807|      0|      restorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler {
  808|      0|  SEL methodSelector = @selector(application:continueUserActivity:restorationHandler:);
  809|      0|  NSValue *continueUserActivityIMPPointer =
  810|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  811|      0|  GULRealContinueUserActivityIMP continueUserActivityIMP =
  812|      0|      continueUserActivityIMPPointer.pointerValue;
  813|      0|
  814|      0|  __block BOOL returnedValue = NO;
  815|      0|#if !TARGET_OS_WATCH
  816|      0|  [GULAppDelegateSwizzler
  817|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  818|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  819|      0|                                    returnedValue |= [interceptor application:application
  820|      0|                                                         continueUserActivity:userActivity
  821|      0|                                                           restorationHandler:restorationHandler];
  822|      0|                                  }];
  823|      0|#endif
  824|      0|  // Call the real implementation if the real App Delegate has any.
  825|      0|  if (continueUserActivityIMP) {
  826|      0|    returnedValue |= continueUserActivityIMP(self, methodSelector, application, userActivity,
  827|      0|                                             restorationHandler);
  828|      0|  }
  829|      0|  return returnedValue;
  830|      0|}
  831|       |#pragma clang diagnostic pop
  832|       |
  833|       |#pragma mark - [Donor Methods] Remote Notifications
  834|       |
  835|       |- (void)application:(GULApplication *)application
  836|      0|    donor_didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
  837|      0|  SEL methodSelector = NSSelectorFromString(kGULDidRegisterForRemoteNotificationsSEL);
  838|      0|
  839|      0|  NSValue *didRegisterForRemoteNotificationsIMPPointer =
  840|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  841|      0|  GULRealDidRegisterForRemoteNotificationsIMP didRegisterForRemoteNotificationsIMP =
  842|      0|      [didRegisterForRemoteNotificationsIMPPointer pointerValue];
  843|      0|
  844|      0|  // Notify interceptors.
  845|      0|  [GULAppDelegateSwizzler
  846|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  847|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  848|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  849|      0|                                        appDelegateInvocationForSelector:methodSelector];
  850|      0|                                    [invocation setTarget:interceptor];
  851|      0|                                    [invocation setSelector:methodSelector];
  852|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  853|      0|                                    [invocation setArgument:(void *)(&deviceToken) atIndex:3];
  854|      0|                                    [invocation invoke];
  855|      0|                                  }];
  856|      0|  // Call the real implementation if the real App Delegate has any.
  857|      0|  if (didRegisterForRemoteNotificationsIMP) {
  858|      0|    didRegisterForRemoteNotificationsIMP(self, methodSelector, application, deviceToken);
  859|      0|  }
  860|      0|}
  861|       |
  862|       |- (void)application:(GULApplication *)application
  863|      0|    donor_didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {
  864|      0|  SEL methodSelector = NSSelectorFromString(kGULDidFailToRegisterForRemoteNotificationsSEL);
  865|      0|  NSValue *didFailToRegisterForRemoteNotificationsIMPPointer =
  866|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  867|      0|  GULRealDidFailToRegisterForRemoteNotificationsIMP didFailToRegisterForRemoteNotificationsIMP =
  868|      0|      [didFailToRegisterForRemoteNotificationsIMPPointer pointerValue];
  869|      0|
  870|      0|  // Notify interceptors.
  871|      0|  [GULAppDelegateSwizzler
  872|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  873|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  874|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  875|      0|                                        appDelegateInvocationForSelector:methodSelector];
  876|      0|                                    [invocation setTarget:interceptor];
  877|      0|                                    [invocation setSelector:methodSelector];
  878|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  879|      0|                                    [invocation setArgument:(void *)(&error) atIndex:3];
  880|      0|                                    [invocation invoke];
  881|      0|                                  }];
  882|      0|  // Call the real implementation if the real App Delegate has any.
  883|      0|  if (didFailToRegisterForRemoteNotificationsIMP) {
  884|      0|    didFailToRegisterForRemoteNotificationsIMP(self, methodSelector, application, error);
  885|      0|  }
  886|      0|}
  887|       |
  888|       |#if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
  889|       |#pragma clang diagnostic push
  890|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
  891|       |- (void)application:(GULApplication *)application
  892|       |    donor_didReceiveRemoteNotification:(NSDictionary *)userInfo
  893|      0|                fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
  894|      0|  SEL methodSelector = NSSelectorFromString(kGULDidReceiveRemoteNotificationWithCompletionSEL);
  895|      0|  NSValue *didReceiveRemoteNotificationWithCompletionIMPPointer =
  896|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  897|      0|  GULRealDidReceiveRemoteNotificationWithCompletionIMP
  898|      0|      didReceiveRemoteNotificationWithCompletionIMP =
  899|      0|          [didReceiveRemoteNotificationWithCompletionIMPPointer pointerValue];
  900|      0|
  901|      0|  // Notify interceptors.
  902|      0|  [GULAppDelegateSwizzler
  903|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  904|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  905|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  906|      0|                                        appDelegateInvocationForSelector:methodSelector];
  907|      0|                                    [invocation setTarget:interceptor];
  908|      0|                                    [invocation setSelector:methodSelector];
  909|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  910|      0|                                    [invocation setArgument:(void *)(&userInfo) atIndex:3];
  911|      0|                                    [invocation setArgument:(void *)(&completionHandler) atIndex:4];
  912|      0|                                    [invocation invoke];
  913|      0|                                  }];
  914|      0|  // Call the real implementation if the real App Delegate has any.
  915|      0|  if (didReceiveRemoteNotificationWithCompletionIMP) {
  916|      0|    didReceiveRemoteNotificationWithCompletionIMP(self, methodSelector, application, userInfo,
  917|      0|                                                  completionHandler);
  918|      0|  }
  919|      0|}
  920|       |#pragma clang diagnostic pop
  921|       |#endif  // __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 && !TARGET_OS_WATCH
  922|       |
  923|       |- (void)application:(GULApplication *)application
  924|      0|    donor_didReceiveRemoteNotification:(NSDictionary *)userInfo {
  925|      0|  SEL methodSelector = NSSelectorFromString(kGULDidReceiveRemoteNotificationSEL);
  926|      0|  NSValue *didReceiveRemoteNotificationIMPPointer =
  927|      0|      [GULAppDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  928|      0|  GULRealDidReceiveRemoteNotificationIMP didReceiveRemoteNotificationIMP =
  929|      0|      [didReceiveRemoteNotificationIMPPointer pointerValue];
  930|      0|
  931|      0|  // Notify interceptors.
  932|      0|#pragma clang diagnostic push
  933|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  934|      0|  [GULAppDelegateSwizzler
  935|      0|      notifyInterceptorsWithMethodSelector:methodSelector
  936|      0|                                  callback:^(id<GULApplicationDelegate> interceptor) {
  937|      0|                                    NSInvocation *invocation = [GULAppDelegateSwizzler
  938|      0|                                        appDelegateInvocationForSelector:methodSelector];
  939|      0|                                    [invocation setTarget:interceptor];
  940|      0|                                    [invocation setSelector:methodSelector];
  941|      0|                                    [invocation setArgument:(void *)(&application) atIndex:2];
  942|      0|                                    [invocation setArgument:(void *)(&userInfo) atIndex:3];
  943|      0|                                    [invocation invoke];
  944|      0|                                  }];
  945|      0|#pragma clang diagnostic pop
  946|      0|  // Call the real implementation if the real App Delegate has any.
  947|      0|  if (didReceiveRemoteNotificationIMP) {
  948|      0|    didReceiveRemoteNotificationIMP(self, methodSelector, application, userInfo);
  949|      0|  }
  950|      0|}
  951|       |
  952|      0|+ (nullable NSInvocation *)appDelegateInvocationForSelector:(SEL)selector {
  953|      0|  struct objc_method_description methodDescription =
  954|      0|      protocol_getMethodDescription(@protocol(GULApplicationDelegate), selector, NO, YES);
  955|      0|  if (methodDescription.types == NULL) {
  956|      0|    return nil;
  957|      0|  }
  958|      0|
  959|      0|  NSMethodSignature *signature = [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
  960|      0|  return [NSInvocation invocationWithMethodSignature:signature];
  961|      0|}
  962|       |
  963|      1|+ (void)proxyAppDelegate:(id<GULApplicationDelegate>)appDelegate {
  964|      1|  if (![appDelegate conformsToProtocol:@protocol(GULApplicationDelegate)]) {
  965|      0|    GULLogNotice(
  966|      0|        kGULLoggerSwizzler, NO,
  967|      0|        [NSString
  968|      0|            stringWithFormat:@"I-SWZ%06ld",
  969|      0|                             (long)kGULSwizzlerMessageCodeAppDelegateSwizzlingInvalidAppDelegate],
  970|      0|        @"App Delegate does not conform to UIApplicationDelegate protocol. %@",
  971|      0|        [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
  972|      0|    return;
  973|      0|  }
  974|      1|
  975|      1|  id<GULApplicationDelegate> originalDelegate = appDelegate;
  976|      1|  // Do not create a subclass if it is not enabled.
  977|      1|  if (![GULAppDelegateSwizzler isAppDelegateProxyEnabled]) {
  978|      0|    GULLogNotice(kGULLoggerSwizzler, NO,
  979|      0|                 [NSString stringWithFormat:@"I-SWZ%06ld",
  980|      0|                                            (long)kGULSwizzlerMessageCodeAppDelegateSwizzling011],
  981|      0|                 @"App Delegate Proxy is disabled. %@",
  982|      0|                 [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
  983|      0|    return;
  984|      0|  }
  985|      1|  // Do not accept nil delegate.
  986|      1|  if (!originalDelegate) {
  987|      0|    GULLogError(kGULLoggerSwizzler, NO,
  988|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  989|      0|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling012],
  990|      0|                @"Cannot create App Delegate Proxy because App Delegate instance is nil. %@",
  991|      0|                [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
  992|      0|    return;
  993|      0|  }
  994|      1|
  995|      1|  @try {
  996|      1|    gOriginalAppDelegateClass = [originalDelegate class];
  997|      1|    gAppDelegateSubclass = [self createSubclassWithObject:originalDelegate];
  998|      1|    [self reassignAppDelegate];
  999|      1|  } @catch (NSException *exception) {
 1000|      1|    GULLogError(kGULLoggerSwizzler, NO,
 1001|      1|                [NSString stringWithFormat:@"I-SWZ%06ld",
 1002|      1|                                           (long)kGULSwizzlerMessageCodeAppDelegateSwizzling013],
 1003|      1|                @"Cannot create App Delegate Proxy. %@",
 1004|      1|                [GULAppDelegateSwizzler correctAlternativeWhenAppDelegateProxyNotCreated]);
 1005|      1|    return;
 1006|      1|  }
 1007|      1|}
 1008|       |
 1009|       |#pragma mark - Methods to print correct debug logs
 1010|       |
 1011|      1|+ (NSString *)correctAppDelegateProxyKey {
 1012|      1|  return NSClassFromString(@"FIRCore") ? kGULFirebaseAppDelegateProxyEnabledPlistKey
 1013|      1|                                       : kGULGoogleUtilitiesAppDelegateProxyEnabledPlistKey;
 1014|      1|}
 1015|       |
 1016|      0|+ (NSString *)correctAlternativeWhenAppDelegateProxyNotCreated {
 1017|      0|  return NSClassFromString(@"FIRCore")
 1018|      0|             ? @"To log deep link campaigns manually, call the methods in "
 1019|      0|               @"FIRAnalytics+AppDelegate.h."
 1020|      0|             : @"";
 1021|      0|}
 1022|       |
 1023|       |#pragma mark - Private Methods for Testing
 1024|       |
 1025|      0|+ (void)clearInterceptors {
 1026|      0|  [[self interceptors] removeAllObjects];
 1027|      0|}
 1028|       |
 1029|      0|+ (void)resetProxyOriginalDelegateOnceToken {
 1030|      0|  sProxyAppDelegateOnceToken = 0;
 1031|      0|  sProxyAppDelegateRemoteNotificationOnceToken = 0;
 1032|      0|}
 1033|       |
 1034|      0|+ (id<GULApplicationDelegate>)originalDelegate {
 1035|      0|  return gOriginalAppDelegate;
 1036|      0|}
 1037|       |
 1038|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/Environment/GULHeartbeatDateStorage.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <GoogleUtilities/GULHeartbeatDateStorage.h>
   18|       |#import <GoogleUtilities/GULSecureCoding.h>
   19|       |
   20|       |@interface GULHeartbeatDateStorage ()
   21|       |/** The storage to store the date of the last sent heartbeat. */
   22|       |@property(nonatomic, readonly) NSFileCoordinator *fileCoordinator;
   23|       |@end
   24|       |
   25|       |@implementation GULHeartbeatDateStorage
   26|       |
   27|      1|- (instancetype)initWithFileName:(NSString *)fileName {
   28|      1|  if (fileName == nil) {
   29|      0|    return nil;
   30|      0|  }
   31|      1|
   32|      1|  self = [super init];
   33|      1|  if (self) {
   34|      1|    _fileCoordinator = [[NSFileCoordinator alloc] initWithFilePresenter:nil];
   35|      1|    NSURL *directoryURL = [[self class] directoryPathURL];
   36|      1|    [[self class] checkAndCreateDirectory:directoryURL fileCoordinator:_fileCoordinator];
   37|      1|    _fileURL = [directoryURL URLByAppendingPathComponent:fileName];
   38|      1|  }
   39|      1|  return self;
   40|      1|}
   41|       |
   42|       |/** Returns the URL path of the Application Support folder.
   43|       | * @return the URL path of Application Support.
   44|       | */
   45|      1|+ (NSURL *)directoryPathURL {
   46|      1|  NSArray<NSString *> *paths =
   47|      1|      NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
   48|      1|  NSArray<NSString *> *components = @[ paths.lastObject, @"Google/FIRApp" ];
   49|      1|  NSString *directoryString = [NSString pathWithComponents:components];
   50|      1|  NSURL *directoryURL = [NSURL fileURLWithPath:directoryString];
   51|      1|  return directoryURL;
   52|      1|}
   53|       |
   54|       |/** Checks and creates a directory for the directory specified by the
   55|       | * directory url
   56|       | * @param directoryPathURL The path to the directory which needs to be created.
   57|       | * @param fileCoordinator The fileCoordinator object to coordinate writes to the directory.
   58|       | */
   59|       |+ (void)checkAndCreateDirectory:(NSURL *)directoryPathURL
   60|      1|                fileCoordinator:(NSFileCoordinator *)fileCoordinator {
   61|      1|  NSError *fileCoordinatorError = nil;
   62|      1|  [fileCoordinator
   63|      1|      coordinateWritingItemAtURL:directoryPathURL
   64|      1|                         options:0
   65|      1|                           error:&fileCoordinatorError
   66|      1|                      byAccessor:^(NSURL *writingDirectoryURL) {
   67|      1|                        NSError *error;
   68|      1|                        if (![writingDirectoryURL checkResourceIsReachableAndReturnError:&error]) {
   69|      0|                          // If fail creating the Application Support directory, log warning.
   70|      0|                          NSError *error;
   71|      0|                          [[NSFileManager defaultManager] createDirectoryAtURL:writingDirectoryURL
   72|      0|                                                   withIntermediateDirectories:YES
   73|      0|                                                                    attributes:nil
   74|      0|                                                                         error:&error];
   75|      0|                        }
   76|      1|                      }];
   77|      1|}
   78|       |
   79|      2|- (nullable NSMutableDictionary *)heartbeatDictionaryWithFileURL:(NSURL *)readingFileURL {
   80|      2|  NSError *error;
   81|      2|  NSMutableDictionary *dict;
   82|      2|  NSData *objectData = [NSData dataWithContentsOfURL:readingFileURL options:0 error:&error];
   83|      2|  if (objectData == nil || error != nil) {
   84|      0|    dict = [NSMutableDictionary dictionary];
   85|      2|  } else {
   86|      2|    dict = [GULSecureCoding
   87|      2|        unarchivedObjectOfClasses:[NSSet setWithArray:@[ NSDictionary.class, NSDate.class ]]
   88|      2|                         fromData:objectData
   89|      2|                            error:&error];
   90|      2|    if (dict == nil || error != nil) {
   91|      0|      dict = [NSMutableDictionary dictionary];
   92|      0|    }
   93|      2|  }
   94|      2|  return dict;
   95|      2|}
   96|       |
   97|      2|- (nullable NSDate *)heartbeatDateForTag:(NSString *)tag {
   98|      2|  __block NSMutableDictionary *dict;
   99|      2|  NSError *error;
  100|      2|  [self.fileCoordinator coordinateReadingItemAtURL:self.fileURL
  101|      2|                                           options:0
  102|      2|                                             error:&error
  103|      2|                                        byAccessor:^(NSURL *readingURL) {
  104|      2|                                          dict = [self heartbeatDictionaryWithFileURL:readingURL];
  105|      2|                                        }];
  106|      2|  return dict[tag];
  107|      2|}
  108|       |
  109|      0|- (BOOL)setHearbeatDate:(NSDate *)date forTag:(NSString *)tag {
  110|      0|  NSError *error;
  111|      0|  __block BOOL isSuccess = false;
  112|      0|  [self.fileCoordinator coordinateReadingItemAtURL:self.fileURL
  113|      0|                                           options:0
  114|      0|                                  writingItemAtURL:self.fileURL
  115|      0|                                           options:0
  116|      0|                                             error:&error
  117|      0|                                        byAccessor:^(NSURL *readingURL, NSURL *writingURL) {
  118|      0|                                          NSMutableDictionary *dictionary =
  119|      0|                                              [self heartbeatDictionaryWithFileURL:readingURL];
  120|      0|                                          dictionary[tag] = date;
  121|      0|                                          NSError *error;
  122|      0|                                          isSuccess = [self writeDictionary:dictionary
  123|      0|                                                              forWritingURL:writingURL
  124|      0|                                                                      error:&error];
  125|      0|                                        }];
  126|      0|  return isSuccess;
  127|      0|}
  128|       |
  129|       |- (BOOL)writeDictionary:(NSMutableDictionary *)dictionary
  130|       |          forWritingURL:(NSURL *)writingFileURL
  131|      0|                  error:(NSError **)outError {
  132|      0|  NSData *data = [GULSecureCoding archivedDataWithRootObject:dictionary error:outError];
  133|      0|  if (*outError != nil) {
  134|      0|    return false;
  135|      0|  } else {
  136|      0|    return [data writeToURL:writingFileURL atomically:YES];
  137|      0|  }
  138|      0|}
  139|       |
  140|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/Environment/GULSecureCoding.m:
    1|       |// Copyright 2019 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Environment/Public/GULSecureCoding.h"
   16|       |
   17|       |NSString *const kGULSecureCodingError = @"GULSecureCodingError";
   18|       |
   19|       |@implementation GULSecureCoding
   20|       |
   21|       |+ (nullable id)unarchivedObjectOfClasses:(NSSet<Class> *)classes
   22|       |                                fromData:(NSData *)data
   23|      2|                                   error:(NSError **)outError {
   24|      2|  id object;
   25|      2|#if __has_builtin(__builtin_available)
   26|      2|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
   27|      2|    object = [NSKeyedUnarchiver unarchivedObjectOfClasses:classes fromData:data error:outError];
   28|      2|  } else
   29|      0|#endif  // __has_builtin(__builtin_available)
   30|      0|  {
   31|      0|    @try {
   32|      0|#pragma clang diagnostic push
   33|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   34|      0|      NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
   35|      0|#pragma clang diagnostic pop
   36|      0|      unarchiver.requiresSecureCoding = YES;
   37|      0|
   38|      0|      object = [unarchiver decodeObjectOfClasses:classes forKey:NSKeyedArchiveRootObjectKey];
   39|      0|    } @catch (NSException *exception) {
   40|      0|      if (outError) {
   41|      0|        *outError = [self archivingErrorWithException:exception];
   42|      0|      }
   43|      0|    }
   44|      0|
   45|      0|    if (object == nil && outError && *outError == nil) {
   46|      0|      NSString *failureReason = @"NSKeyedUnarchiver failed to unarchive data.";
   47|      0|      *outError = [NSError errorWithDomain:kGULSecureCodingError
   48|      0|                                      code:-1
   49|      0|                                  userInfo:@{NSLocalizedFailureReasonErrorKey : failureReason}];
   50|      0|    }
   51|      0|  }
   52|      2|
   53|      2|  return object;
   54|      2|}
   55|       |
   56|       |+ (nullable id)unarchivedObjectOfClass:(Class)class
   57|       |                              fromData:(NSData *)data
   58|      0|                                 error:(NSError **)outError {
   59|      0|  return [self unarchivedObjectOfClasses:[NSSet setWithObject:class] fromData:data error:outError];
   60|      0|}
   61|       |
   62|      0|+ (nullable NSData *)archivedDataWithRootObject:(id<NSCoding>)object error:(NSError **)outError {
   63|      0|  NSData *archiveData;
   64|      0|#if __has_builtin(__builtin_available)
   65|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
   66|      0|    archiveData = [NSKeyedArchiver archivedDataWithRootObject:object
   67|      0|                                        requiringSecureCoding:YES
   68|      0|                                                        error:outError];
   69|      0|  } else
   70|      0|#endif  // __has_builtin(__builtin_available)
   71|      0|  {
   72|      0|    @try {
   73|      0|      NSMutableData *data = [NSMutableData data];
   74|      0|#pragma clang diagnostic push
   75|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   76|      0|      NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];
   77|      0|#pragma clang diagnostic pop
   78|      0|      archiver.requiresSecureCoding = YES;
   79|      0|
   80|      0|      [archiver encodeObject:object forKey:NSKeyedArchiveRootObjectKey];
   81|      0|      [archiver finishEncoding];
   82|      0|
   83|      0|      archiveData = [data copy];
   84|      0|    } @catch (NSException *exception) {
   85|      0|      if (outError) {
   86|      0|        *outError = [self archivingErrorWithException:exception];
   87|      0|      }
   88|      0|    }
   89|      0|  }
   90|      0|
   91|      0|  return archiveData;
   92|      0|}
   93|       |
   94|      0|+ (NSError *)archivingErrorWithException:(NSException *)exception {
   95|      0|  NSString *failureReason = [NSString
   96|      0|      stringWithFormat:@"NSKeyedArchiver exception with name: %@, reason: %@, userInfo: %@",
   97|      0|                       exception.name, exception.reason, exception.userInfo];
   98|      0|  NSDictionary *errorUserInfo = @{NSLocalizedFailureReasonErrorKey : failureReason};
   99|      0|
  100|      0|  return [NSError errorWithDomain:kGULSecureCodingError code:-1 userInfo:errorUserInfo];
  101|      0|}
  102|       |
  103|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/Environment/third_party/GULAppEnvironmentUtil.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Environment/third_party/GULAppEnvironmentUtil.h"
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |#import <dlfcn.h>
   19|       |#import <mach-o/dyld.h>
   20|       |#import <sys/utsname.h>
   21|       |
   22|       |#if TARGET_OS_IOS
   23|       |#import <UIKit/UIKit.h>
   24|       |#endif
   25|       |
   26|       |/// The encryption info struct and constants are missing from the iPhoneSimulator SDK, but not from
   27|       |/// the iPhoneOS or Mac OS X SDKs. Since one doesn't ever ship a Simulator binary, we'll just
   28|       |/// provide the definitions here.
   29|       |#if TARGET_OS_SIMULATOR && !defined(LC_ENCRYPTION_INFO)
   30|       |#define LC_ENCRYPTION_INFO 0x21
   31|       |struct encryption_info_command {
   32|       |  uint32_t cmd;
   33|       |  uint32_t cmdsize;
   34|       |  uint32_t cryptoff;
   35|       |  uint32_t cryptsize;
   36|       |  uint32_t cryptid;
   37|       |};
   38|       |#endif
   39|       |
   40|       |@implementation GULAppEnvironmentUtil
   41|       |
   42|       |/// A key for the Info.plist to enable or disable checking if the App Store is running in a sandbox.
   43|       |/// This will affect your data integrity when using Firebase Analytics, as it will disable some
   44|       |/// necessary checks.
   45|       |static NSString *const kFIRAppStoreReceiptURLCheckEnabledKey =
   46|       |    @"FirebaseAppStoreReceiptURLCheckEnabled";
   47|       |
   48|       |/// The file name of the sandbox receipt. This is available on iOS >= 8.0
   49|       |static NSString *const kFIRAIdentitySandboxReceiptFileName = @"sandboxReceipt";
   50|       |
   51|       |/// The following copyright from Landon J. Fuller applies to the isAppEncrypted function.
   52|       |///
   53|       |/// Copyright (c) 2017 Landon J. Fuller <landon@landonf.org>
   54|       |/// All rights reserved.
   55|       |///
   56|       |/// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
   57|       |/// and associated documentation files (the "Software"), to deal in the Software without
   58|       |/// restriction, including without limitation the rights to use, copy, modify, merge, publish,
   59|       |/// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
   60|       |/// Software is furnished to do so, subject to the following conditions:
   61|       |///
   62|       |/// The above copyright notice and this permission notice shall be included in all copies or
   63|       |/// substantial portions of the Software.
   64|       |///
   65|       |/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
   66|       |/// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   67|       |/// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
   68|       |/// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   69|       |/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   70|       |///
   71|       |/// Comment from <a href="http://iphonedevwiki.net/index.php/Crack_prevention">iPhone Dev Wiki
   72|       |/// Crack Prevention</a>:
   73|       |/// App Store binaries are signed by both their developer and Apple. This encrypts the binary so
   74|       |/// that decryption keys are needed in order to make the binary readable. When iOS executes the
   75|       |/// binary, the decryption keys are used to decrypt the binary into a readable state where it is
   76|       |/// then loaded into memory and executed. iOS can tell the encryption status of a binary via the
   77|       |/// cryptid structure member of LC_ENCRYPTION_INFO MachO load command. If cryptid is a non-zero
   78|       |/// value then the binary is encrypted.
   79|       |///
   80|       |/// 'Cracking' works by letting the kernel decrypt the binary then siphoning the decrypted data into
   81|       |/// a new binary file, resigning, and repackaging. This will only work on jailbroken devices as
   82|       |/// codesignature validation has been removed. Resigning takes place because while the codesignature
   83|       |/// doesn't have to be valid thanks to the jailbreak, it does have to be in place unless you have
   84|       |/// AppSync or similar to disable codesignature checks.
   85|       |///
   86|       |/// More information at <a href="http://landonf.org/2009/02/index.html">Landon Fuller's blog</a>
   87|      1|static BOOL IsAppEncrypted() {
   88|      1|  const struct mach_header *executableHeader = NULL;
   89|      2|  for (uint32_t i = 0; i < _dyld_image_count(); i++) {
   90|      2|    const struct mach_header *header = _dyld_get_image_header(i);
   91|      2|    if (header && header->filetype == MH_EXECUTE) {
   92|      1|      executableHeader = header;
   93|      1|      break;
   94|      1|    }
   95|      2|  }
   96|      1|
   97|      1|  if (!executableHeader) {
   98|      0|    return NO;
   99|      0|  }
  100|      1|
  101|      1|  BOOL is64bit = (executableHeader->magic == MH_MAGIC_64);
  102|      1|  uintptr_t cursor = (uintptr_t)executableHeader +
  103|      1|                     (is64bit ? sizeof(struct mach_header_64) : sizeof(struct mach_header));
  104|      1|  const struct segment_command *segmentCommand = NULL;
  105|      1|  uint32_t i = 0;
  106|      1|
  107|     51|  while (i++ < executableHeader->ncmds) {
  108|     50|    segmentCommand = (struct segment_command *)cursor;
  109|     50|
  110|     50|    if (!segmentCommand) {
  111|      0|      continue;
  112|      0|    }
  113|     50|
  114|     50|    if ((!is64bit && segmentCommand->cmd == LC_ENCRYPTION_INFO) ||
  115|     50|        (is64bit && segmentCommand->cmd == LC_ENCRYPTION_INFO_64)) {
  116|      0|      if (is64bit) {
  117|      0|        struct encryption_info_command_64 *cryptCmd =
  118|      0|            (struct encryption_info_command_64 *)segmentCommand;
  119|      0|        return cryptCmd && cryptCmd->cryptid != 0;
  120|      0|      } else {
  121|      0|        struct encryption_info_command *cryptCmd = (struct encryption_info_command *)segmentCommand;
  122|      0|        return cryptCmd && cryptCmd->cryptid != 0;
  123|      0|      }
  124|     50|    }
  125|     50|    cursor += segmentCommand->cmdsize;
  126|     50|  }
  127|      1|
  128|      1|  return NO;
  129|      1|}
  130|       |
  131|      0|static BOOL HasSCInfoFolder() {
  132|      0|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  133|      0|  NSString *bundlePath = [NSBundle mainBundle].bundlePath;
  134|      0|  NSString *scInfoPath = [bundlePath stringByAppendingPathComponent:@"SC_Info"];
  135|      0|  return [[NSFileManager defaultManager] fileExistsAtPath:scInfoPath];
  136|       |#elif TARGET_OS_OSX
  137|       |  return NO;
  138|       |#endif
  139|       |}
  140|       |
  141|      0|static BOOL HasEmbeddedMobileProvision() {
  142|      0|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  143|      0|  return [[NSBundle mainBundle] pathForResource:@"embedded" ofType:@"mobileprovision"].length > 0;
  144|       |#elif TARGET_OS_OSX
  145|       |  return NO;
  146|       |#endif
  147|       |}
  148|       |
  149|      2|+ (BOOL)isFromAppStore {
  150|      2|  static dispatch_once_t isEncryptedOnce;
  151|      2|  static BOOL isEncrypted = NO;
  152|      2|
  153|      2|  dispatch_once(&isEncryptedOnce, ^{
  154|      1|    isEncrypted = IsAppEncrypted();
  155|      1|  });
  156|      2|
  157|      2|  if ([GULAppEnvironmentUtil isSimulator]) {
  158|      2|    return NO;
  159|      2|  }
  160|      0|
  161|      0|  // If an app contain the sandboxReceipt file, it means its coming from TestFlight
  162|      0|  // This must be checked before the SCInfo Folder check below since TestFlight apps may
  163|      0|  // also have an SCInfo folder.
  164|      0|  if ([GULAppEnvironmentUtil isAppStoreReceiptSandbox]) {
  165|      0|    return NO;
  166|      0|  }
  167|      0|
  168|      0|  if (HasSCInfoFolder()) {
  169|      0|    // When iTunes downloads a .ipa, it also gets a customized .sinf file which is added to the
  170|      0|    // main SC_Info directory.
  171|      0|    return YES;
  172|      0|  }
  173|      0|
  174|      0|  // For iOS >= 8.0, iTunesMetadata.plist is moved outside of the sandbox. Any attempt to read
  175|      0|  // the iTunesMetadata.plist outside of the sandbox will be rejected by Apple.
  176|      0|  // If the app does not contain the embedded.mobileprovision which is stripped out by Apple when
  177|      0|  // the app is submitted to store, then it is highly likely that it is from Apple Store.
  178|      0|  return isEncrypted && !HasEmbeddedMobileProvision();
  179|      0|}
  180|       |
  181|      0|+ (BOOL)isAppStoreReceiptSandbox {
  182|      0|  // Since checking the App Store's receipt URL can be memory intensive, check the option in the
  183|      0|  // Info.plist if developers opted out of this check.
  184|      0|  id enableSandboxCheck =
  185|      0|      [[NSBundle mainBundle] objectForInfoDictionaryKey:kFIRAppStoreReceiptURLCheckEnabledKey];
  186|      0|  if (enableSandboxCheck && [enableSandboxCheck isKindOfClass:[NSNumber class]] &&
  187|      0|      ![enableSandboxCheck boolValue]) {
  188|      0|    return NO;
  189|      0|  }
  190|      0|// The #else is for pre Xcode 9 where @available is not yet implemented.
  191|      0|#if __has_builtin(__builtin_available)
  192|      0|  if (@available(iOS 7.0, *)) {
  193|       |#else
  194|       |  if ([[UIDevice currentDevice].systemVersion integerValue] >= 7) {
  195|       |#endif
  196|       |    NSURL *appStoreReceiptURL = [NSBundle mainBundle].appStoreReceiptURL;
  197|      0|    NSString *appStoreReceiptFileName = appStoreReceiptURL.lastPathComponent;
  198|      0|    return [appStoreReceiptFileName isEqualToString:kFIRAIdentitySandboxReceiptFileName];
  199|      0|  }
  200|      0|  return NO;
  201|      0|}
  202|       |
  203|      2|+ (BOOL)isSimulator {
  204|      2|#if TARGET_OS_IOS || TARGET_OS_TV
  205|      2|  NSString *platform = [GULAppEnvironmentUtil deviceModel];
  206|      2|  return [platform isEqual:@"x86_64"] || [platform isEqual:@"i386"];
  207|       |#elif TARGET_OS_OSX
  208|       |  return NO;
  209|       |#endif
  210|      0|  return NO;
  211|      2|}
  212|       |
  213|      2|+ (NSString *)deviceModel {
  214|      2|  static dispatch_once_t once;
  215|      2|  static NSString *deviceModel;
  216|      2|
  217|      2|  dispatch_once(&once, ^{
  218|      1|    struct utsname systemInfo;
  219|      1|    if (uname(&systemInfo) == 0) {
  220|      1|      deviceModel = [NSString stringWithUTF8String:systemInfo.machine];
  221|      1|    }
  222|      1|  });
  223|      2|  return deviceModel;
  224|      2|}
  225|       |
  226|      3|+ (NSString *)systemVersion {
  227|      3|#if TARGET_OS_IOS
  228|      3|  return [UIDevice currentDevice].systemVersion;
  229|       |#elif TARGET_OS_OSX || TARGET_OS_TV || TARGET_OS_WATCH
  230|       |  // Assemble the systemVersion, excluding the patch version if it's 0.
  231|       |  NSOperatingSystemVersion osVersion = [NSProcessInfo processInfo].operatingSystemVersion;
  232|       |  NSMutableString *versionString = [[NSMutableString alloc]
  233|       |      initWithFormat:@"%ld.%ld", (long)osVersion.majorVersion, (long)osVersion.minorVersion];
  234|       |  if (osVersion.patchVersion != 0) {
  235|       |    [versionString appendFormat:@".%ld", (long)osVersion.patchVersion];
  236|       |  }
  237|       |  return versionString;
  238|       |#endif
  239|       |}
  240|       |
  241|     18|+ (BOOL)isAppExtension {
  242|     18|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  243|     18|  // Documented by <a href="https://goo.gl/RRB2Up">Apple</a>
  244|     18|  BOOL appExtension = [[[NSBundle mainBundle] bundlePath] hasSuffix:@".appex"];
  245|     18|  return appExtension;
  246|       |#elif TARGET_OS_OSX
  247|       |  return NO;
  248|       |#endif
  249|       |}
  250|       |
  251|      1|+ (BOOL)isIOS7OrHigher {
  252|      1|#if __has_builtin(__builtin_available)
  253|      1|  if (@available(iOS 7.0, *)) {
  254|       |#else
  255|       |  if ([[UIDevice currentDevice].systemVersion integerValue] >= 7) {
  256|       |#endif
  257|       |      return YES;
  258|      1|    }
  259|      0|
  260|      0|    return NO;
  261|      0|}
  262|       |
  263|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/Logger/GULLogger.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Logger/Private/GULLogger.h"
   16|       |
   17|       |#include <asl.h>
   18|       |
   19|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   20|       |#import <GoogleUtilities/GULLoggerLevel.h>
   21|       |
   22|       |/// ASL client facility name used by GULLogger.
   23|       |const char *kGULLoggerASLClientFacilityName = "com.google.utilities.logger";
   24|       |
   25|       |static dispatch_once_t sGULLoggerOnceToken;
   26|       |
   27|       |static aslclient sGULLoggerClient;
   28|       |
   29|       |static dispatch_queue_t sGULClientQueue;
   30|       |
   31|       |static BOOL sGULLoggerDebugMode;
   32|       |
   33|       |static GULLoggerLevel sGULLoggerMaximumLevel;
   34|       |
   35|       |// Allow clients to register a version to include in the log.
   36|       |static const char *sVersion = "";
   37|       |
   38|       |static GULLoggerService kGULLoggerLogger = @"[GULLogger]";
   39|       |
   40|       |#ifdef DEBUG
   41|       |/// The regex pattern for the message code.
   42|       |static NSString *const kMessageCodePattern = @"^I-[A-Z]{3}[0-9]{6}$";
   43|       |static NSRegularExpression *sMessageCodeRegex;
   44|       |#endif
   45|       |
   46|     54|void GULLoggerInitializeASL(void) {
   47|     54|  dispatch_once(&sGULLoggerOnceToken, ^{
   48|      1|    NSInteger majorOSVersion = [[GULAppEnvironmentUtil systemVersion] integerValue];
   49|      1|    uint32_t aslOptions = ASL_OPT_STDERR;
   50|      1|#if TARGET_OS_SIMULATOR
   51|      1|    // The iOS 11 simulator doesn't need the ASL_OPT_STDERR flag.
   52|      1|    if (majorOSVersion >= 11) {
   53|      1|      aslOptions = 0;
   54|      1|    }
   55|       |#else
   56|       |    // Devices running iOS 10 or higher don't need the ASL_OPT_STDERR flag.
   57|       |    if (majorOSVersion >= 10) {
   58|       |      aslOptions = 0;
   59|       |    }
   60|       |#endif  // TARGET_OS_SIMULATOR
   61|       |
   62|      1|#pragma clang diagnostic push
   63|      1|#pragma clang diagnostic ignored "-Wdeprecated-declarations"  // asl is deprecated
   64|      1|    // Initialize the ASL client handle.
   65|      1|    sGULLoggerClient = asl_open(NULL, kGULLoggerASLClientFacilityName, aslOptions);
   66|      1|    sGULLoggerMaximumLevel = GULLoggerLevelNotice;
   67|      1|
   68|      1|    // Set the filter used by system/device log. Initialize in default mode.
   69|      1|    asl_set_filter(sGULLoggerClient, ASL_FILTER_MASK_UPTO(ASL_LEVEL_NOTICE));
   70|      1|
   71|      1|    sGULClientQueue = dispatch_queue_create("GULLoggingClientQueue", DISPATCH_QUEUE_SERIAL);
   72|      1|    dispatch_set_target_queue(sGULClientQueue,
   73|      1|                              dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0));
   74|      1|#ifdef DEBUG
   75|      1|    sMessageCodeRegex = [NSRegularExpression regularExpressionWithPattern:kMessageCodePattern
   76|      1|                                                                  options:0
   77|      1|                                                                    error:NULL];
   78|      1|#endif
   79|      1|  });
   80|     54|}
   81|       |
   82|      0|void GULLoggerEnableSTDERR(void) {
   83|      0|  asl_add_log_file(sGULLoggerClient, STDERR_FILENO);
   84|      0|}
   85|       |
   86|      0|void GULLoggerForceDebug(void) {
   87|      0|  // We should enable debug mode if we're not running from App Store.
   88|      0|  if (![GULAppEnvironmentUtil isFromAppStore]) {
   89|      0|    sGULLoggerDebugMode = YES;
   90|      0|    GULSetLoggerLevel(GULLoggerLevelDebug);
   91|      0|  }
   92|      0|}
   93|       |
   94|      0|__attribute__((no_sanitize("thread"))) void GULSetLoggerLevel(GULLoggerLevel loggerLevel) {
   95|      0|  if (loggerLevel < GULLoggerLevelMin || loggerLevel > GULLoggerLevelMax) {
   96|      0|    GULLogError(kGULLoggerLogger, NO, @"I-COR000023", @"Invalid logger level, %ld",
   97|      0|                (long)loggerLevel);
   98|      0|    return;
   99|      0|  }
  100|      0|  GULLoggerInitializeASL();
  101|      0|  // We should not raise the logger level if we are running from App Store.
  102|      0|  if (loggerLevel >= GULLoggerLevelNotice && [GULAppEnvironmentUtil isFromAppStore]) {
  103|      0|    return;
  104|      0|  }
  105|      0|
  106|      0|  sGULLoggerMaximumLevel = loggerLevel;
  107|      0|  dispatch_async(sGULClientQueue, ^{
  108|      0|    asl_set_filter(sGULLoggerClient, ASL_FILTER_MASK_UPTO(loggerLevel));
  109|      0|  });
  110|      0|}
  111|       |
  112|       |/**
  113|       | * Check if the level is high enough to be loggable.
  114|       | */
  115|     39|__attribute__((no_sanitize("thread"))) BOOL GULIsLoggableLevel(GULLoggerLevel loggerLevel) {
  116|     39|  GULLoggerInitializeASL();
  117|     39|  if (sGULLoggerDebugMode) {
  118|      0|    return YES;
  119|      0|  }
  120|     39|  return (BOOL)(loggerLevel <= sGULLoggerMaximumLevel);
  121|     39|}
  122|       |
  123|       |#ifdef DEBUG
  124|      0|void GULResetLogger() {
  125|      0|  sGULLoggerOnceToken = 0;
  126|      0|}
  127|       |
  128|      0|aslclient getGULLoggerClient() {
  129|      0|  return sGULLoggerClient;
  130|      0|}
  131|       |
  132|      0|dispatch_queue_t getGULClientQueue() {
  133|      0|  return sGULClientQueue;
  134|      0|}
  135|       |
  136|      0|BOOL getGULLoggerDebugMode() {
  137|      0|  return sGULLoggerDebugMode;
  138|      0|}
  139|       |#endif
  140|       |
  141|      1|void GULLoggerRegisterVersion(const char *version) {
  142|      1|  sVersion = version;
  143|      1|}
  144|       |
  145|       |void GULLogBasic(GULLoggerLevel level,
  146|       |                 GULLoggerService service,
  147|       |                 BOOL forceLog,
  148|       |                 NSString *messageCode,
  149|       |                 NSString *message,
  150|     14|                 va_list args_ptr) {
  151|     14|  GULLoggerInitializeASL();
  152|     14|  if (!(level <= sGULLoggerMaximumLevel || sGULLoggerDebugMode || forceLog)) {
  153|     10|    return;
  154|     10|  }
  155|      4|
  156|      4|#ifdef DEBUG
  157|      4|  NSCAssert(messageCode.length == 11, @"Incorrect message code length.");
  158|      4|  NSRange messageCodeRange = NSMakeRange(0, messageCode.length);
  159|      4|  NSUInteger numberOfMatches = [sMessageCodeRegex numberOfMatchesInString:messageCode
  160|      4|                                                                  options:0
  161|      4|                                                                    range:messageCodeRange];
  162|      4|  NSCAssert(numberOfMatches == 1, @"Incorrect message code format.");
  163|      4|#endif
  164|      4|  NSString *logMsg;
  165|      4|  if (args_ptr == NULL) {
  166|      4|    logMsg = message;
  167|      4|  } else {
  168|      0|    logMsg = [[NSString alloc] initWithFormat:message arguments:args_ptr];
  169|      0|  }
  170|      4|  logMsg = [NSString stringWithFormat:@"%s - %@[%@] %@", sVersion, service, messageCode, logMsg];
  171|      4|  dispatch_async(sGULClientQueue, ^{
  172|      4|    asl_log(sGULLoggerClient, NULL, (int)level, "%s", logMsg.UTF8String);
  173|      4|  });
  174|      4|}
  175|       |#pragma clang diagnostic pop
  176|       |
  177|       |/**
  178|       | * Generates the logging functions using macros.
  179|       | *
  180|       | * Calling GULLogError({service}, @"I-XYZ000001", @"Configure %@ failed.", @"blah") shows:
  181|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Error> [{service}][I-XYZ000001] Configure blah failed.
  182|       | * Calling GULLogDebug({service}, @"I-XYZ000001", @"Configure succeed.") shows:
  183|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Debug> [{service}][I-XYZ000001] Configure succeed.
  184|       | */
  185|       |#define GUL_LOGGING_FUNCTION(level)                                                     \
  186|       |  void GULLog##level(GULLoggerService service, BOOL force, NSString *messageCode,       \
  187|      4|                     NSString *message, ...) {                                          \
  188|      4|    va_list args_ptr;                                                                   \
  189|      4|    va_start(args_ptr, message);                                                        \
  190|      4|    GULLogBasic(GULLoggerLevel##level, service, force, messageCode, message, args_ptr); \
  191|      4|    va_end(args_ptr);                                                                   \
  192|      4|  }
  ------------------
  | Unexecuted instantiation: GULLogError
  ------------------
  | Unexecuted instantiation: GULLogWarning
  ------------------
  | Unexecuted instantiation: GULLogNotice
  ------------------
  | Unexecuted instantiation: GULLogInfo
  ------------------
  | GULLogDebug:
  |  187|      4|                     NSString *message, ...) {                                          \
  |  188|      4|    va_list args_ptr;                                                                   \
  |  189|      4|    va_start(args_ptr, message);                                                        \
  |  190|      4|    GULLogBasic(GULLoggerLevel##level, service, force, messageCode, message, args_ptr); \
  |  191|      4|    va_end(args_ptr);                                                                   \
  |  192|      4|  }
  ------------------
  193|       |
  194|       |GUL_LOGGING_FUNCTION(Error)
  195|       |GUL_LOGGING_FUNCTION(Warning)
  196|       |GUL_LOGGING_FUNCTION(Notice)
  197|       |GUL_LOGGING_FUNCTION(Info)
  198|       |GUL_LOGGING_FUNCTION(Debug)
  199|       |
  200|       |#undef GUL_MAKE_LOGGER
  201|       |
  202|       |#pragma mark - GULLoggerWrapper
  203|       |
  204|       |@implementation GULLoggerWrapper
  205|       |
  206|       |+ (void)logWithLevel:(GULLoggerLevel)level
  207|       |         withService:(GULLoggerService)service
  208|       |            withCode:(NSString *)messageCode
  209|       |         withMessage:(NSString *)message
  210|      0|            withArgs:(va_list)args {
  211|      0|  GULLogBasic(level, service, NO, messageCode, message, args);
  212|      0|}
  213|       |
  214|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/MethodSwizzler/GULSwizzler.m:
    1|       |// Copyright 2018 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/MethodSwizzler/Private/GULSwizzler.h"
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |
   19|       |#ifdef DEBUG
   20|       |#import <GoogleUtilities/GULLogger.h>
   21|       |#import "GoogleUtilities/Common/GULLoggerCodes.h"
   22|       |
   23|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/MethodSwizzler]";
   24|       |#endif
   25|       |
   26|      4|dispatch_queue_t GetGULSwizzlingQueue(void) {
   27|      4|  static dispatch_queue_t queue;
   28|      4|  static dispatch_once_t onceToken;
   29|      4|  dispatch_once(&onceToken, ^{
   30|      1|    queue = dispatch_queue_create("com.google.GULSwizzler", DISPATCH_QUEUE_SERIAL);
   31|      1|  });
   32|      4|  return queue;
   33|      4|}
   34|       |
   35|       |@implementation GULSwizzler
   36|       |
   37|       |+ (void)swizzleClass:(Class)aClass
   38|       |            selector:(SEL)selector
   39|       |     isClassSelector:(BOOL)isClassSelector
   40|      2|           withBlock:(nullable id)block {
   41|      2|  dispatch_sync(GetGULSwizzlingQueue(), ^{
   42|      2|    NSAssert(selector, @"The selector cannot be NULL");
   43|      2|    NSAssert(aClass, @"The class cannot be Nil");
   44|      2|    Class resolvedClass = aClass;
   45|      2|    Method method = nil;
   46|      2|    if (isClassSelector) {
   47|      0|      method = class_getClassMethod(aClass, selector);
   48|      0|      resolvedClass = object_getClass(aClass);
   49|      2|    } else {
   50|      2|      method = class_getInstanceMethod(aClass, selector);
   51|      2|    }
   52|      2|    NSAssert(method, @"You're attempting to swizzle a method that doesn't exist. (%@, %@)",
   53|      2|             NSStringFromClass(resolvedClass), NSStringFromSelector(selector));
   54|      2|    IMP newImp = imp_implementationWithBlock(block);
   55|      2|#ifdef DEBUG
   56|      2|    IMP currentImp = class_getMethodImplementation(resolvedClass, selector);
   57|      2|    Class class = NSClassFromString(@"GULSwizzlingCache");
   58|      2|    if (class) {
   59|      0|      SEL cacheSelector = NSSelectorFromString(@"cacheCurrentIMP:forNewIMP:forClass:withSelector:");
   60|      0|      NSMethodSignature *methodSignature = [class methodSignatureForSelector:cacheSelector];
   61|      0|      if (methodSignature != nil) {
   62|      0|        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:methodSignature];
   63|      0|        [inv setSelector:cacheSelector];
   64|      0|        [inv setTarget:class];
   65|      0|        [inv setArgument:&(currentImp) atIndex:2];
   66|      0|        [inv setArgument:&(newImp) atIndex:3];
   67|      0|        [inv setArgument:&(resolvedClass) atIndex:4];
   68|      0|        [inv setArgument:(void *_Nonnull) & (selector) atIndex:5];
   69|      0|        [inv invoke];
   70|      0|      }
   71|      0|    }
   72|      2|#endif
   73|      2|
   74|      2|    const char *typeEncoding = method_getTypeEncoding(method);
   75|      2|    __unused IMP originalImpOfClass =
   76|      2|        class_replaceMethod(resolvedClass, selector, newImp, typeEncoding);
   77|      2|
   78|      2|#ifdef DEBUG
   79|      2|    // If !originalImpOfClass, then the IMP came from a superclass.
   80|      2|    if (originalImpOfClass) {
   81|      2|      SEL selector = NSSelectorFromString(@"originalIMPOfCurrentIMP:");
   82|      2|      NSMethodSignature *methodSignature = [class methodSignatureForSelector:selector];
   83|      2|      if (methodSignature != nil) {
   84|      0|        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:methodSignature];
   85|      0|        [inv setSelector:selector];
   86|      0|        [inv setTarget:class];
   87|      0|        [inv setArgument:&(currentImp) atIndex:2];
   88|      0|        [inv invoke];
   89|      0|        IMP testOriginal;
   90|      0|        [inv getReturnValue:&testOriginal];
   91|      0|        if (originalImpOfClass != testOriginal) {
   92|      0|          GULLogWarning(kGULLoggerSwizzler, NO,
   93|      0|                        [NSString stringWithFormat:@"I-SWZ%06ld",
   94|      0|                                                   (long)kGULSwizzlerMessageCodeMethodSwizzling000],
   95|      0|                        @"Swizzling class: %@ SEL:%@ after it has been previously been swizzled.",
   96|      0|                        NSStringFromClass(resolvedClass), NSStringFromSelector(selector));
   97|      0|        }
   98|      0|      }
   99|      2|    }
  100|      2|#endif
  101|      2|  });
  102|      2|}
  103|       |
  104|       |+ (nullable IMP)currentImplementationForClass:(Class)aClass
  105|       |                                     selector:(SEL)selector
  106|      2|                              isClassSelector:(BOOL)isClassSelector {
  107|      2|  NSAssert(selector, @"The selector cannot be NULL");
  108|      2|  NSAssert(aClass, @"The class cannot be Nil");
  109|      2|  if (selector == NULL || aClass == nil) {
  110|      0|    return nil;
  111|      0|  }
  112|      2|  __block IMP currentIMP = nil;
  113|      2|  dispatch_sync(GetGULSwizzlingQueue(), ^{
  114|      2|    Method method = nil;
  115|      2|    if (isClassSelector) {
  116|      0|      method = class_getClassMethod(aClass, selector);
  117|      2|    } else {
  118|      2|      method = class_getInstanceMethod(aClass, selector);
  119|      2|    }
  120|      2|    NSAssert(method, @"The Method for this class/selector combo doesn't exist (%@, %@).",
  121|      2|             NSStringFromClass(aClass), NSStringFromSelector(selector));
  122|      2|    if (method == nil) {
  123|      0|      return;
  124|      0|    }
  125|      2|    currentIMP = method_getImplementation(method);
  126|      2|    NSAssert(currentIMP, @"The IMP for this class/selector combo doesn't exist (%@, %@).",
  127|      2|             NSStringFromClass(aClass), NSStringFromSelector(selector));
  128|      2|  });
  129|      2|  return currentIMP;
  130|      2|}
  131|       |
  132|      0|+ (BOOL)selector:(SEL)selector existsInClass:(Class)aClass isClassSelector:(BOOL)isClassSelector {
  133|      0|  Method method = isClassSelector ? class_getClassMethod(aClass, selector)
  134|      0|                                  : class_getInstanceMethod(aClass, selector);
  135|      0|  return method != nil;
  136|      0|}
  137|       |
  138|      0|+ (NSArray<id> *)ivarObjectsForObject:(id)object {
  139|      0|  NSMutableArray *array = [NSMutableArray array];
  140|      0|  unsigned int count;
  141|      0|  Ivar *vars = class_copyIvarList([object class], &count);
  142|      0|  for (NSUInteger i = 0; i < count; i++) {
  143|      0|    const char *typeEncoding = ivar_getTypeEncoding(vars[i]);
  144|      0|    // Check to see if the ivar is an object.
  145|      0|    if (strncmp(typeEncoding, "@", 1) == 0) {
  146|      0|      id ivarObject = object_getIvar(object, vars[i]);
  147|      0|      [array addObject:ivarObject];
  148|      0|    }
  149|      0|  }
  150|      0|  free(vars);
  151|      0|  return array;
  152|      0|}
  153|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/NSData+zlib/GULNSData+zlib.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/NSData+zlib/GULNSData+zlib.h"
   16|       |
   17|       |#import <zlib.h>
   18|       |
   19|     22|#define kChunkSize 1024
   20|      1|#define Z_DEFAULT_COMPRESSION (-1)
   21|       |
   22|       |NSString *const GULNSDataZlibErrorDomain = @"com.google.GULNSDataZlibErrorDomain";
   23|       |NSString *const GULNSDataZlibErrorKey = @"GULNSDataZlibErrorKey";
   24|       |NSString *const GULNSDataZlibRemainingBytesKey = @"GULNSDataZlibRemainingBytesKey";
   25|       |
   26|       |@implementation NSData (GULGzip)
   27|       |
   28|      9|+ (NSData *)gul_dataByInflatingGzippedData:(NSData *)data error:(NSError **)error {
   29|      9|  const void *bytes = [data bytes];
   30|      9|  NSUInteger length = [data length];
   31|      9|  if (!bytes || !length) {
   32|      0|    return nil;
   33|      0|  }
   34|      9|
   35|      9|#if defined(__LP64__) && __LP64__
   36|      9|  // Don't support > 32bit length for 64 bit, see note in header.
   37|      9|  if (length > UINT_MAX) {
   38|      0|    return nil;
   39|      0|  }
   40|      9|#endif
   41|      9|
   42|      9|  z_stream strm;
   43|      9|  bzero(&strm, sizeof(z_stream));
   44|      9|
   45|      9|  // Setup the input.
   46|      9|  strm.avail_in = (unsigned int)length;
   47|      9|  strm.next_in = (unsigned char *)bytes;
   48|      9|
   49|      9|  int windowBits = 15;  // 15 to enable any window size
   50|      9|  windowBits += 32;     // and +32 to enable zlib or gzip header detection.
   51|      9|
   52|      9|  int retCode;
   53|      9|  if ((retCode = inflateInit2(&strm, windowBits)) != Z_OK) {
   54|      0|    if (error) {
   55|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
   56|      0|                                                           forKey:GULNSDataZlibErrorKey];
   57|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
   58|      0|                                   code:GULNSDataZlibErrorInternal
   59|      0|                               userInfo:userInfo];
   60|      0|    }
   61|      0|    return nil;
   62|      0|  }
   63|      9|
   64|      9|  // Hint the size at 4x the input size.
   65|      9|  NSMutableData *result = [NSMutableData dataWithCapacity:(length * 4)];
   66|      9|  unsigned char output[kChunkSize];
   67|      9|
   68|      9|  // Loop to collect the data.
   69|      9|  do {
   70|      9|    // Update what we're passing in.
   71|      9|    strm.avail_out = kChunkSize;
   72|      9|    strm.next_out = output;
   73|      9|    retCode = inflate(&strm, Z_NO_FLUSH);
   74|      9|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
   75|      0|      if (error) {
   76|      0|        NSMutableDictionary *userInfo =
   77|      0|            [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
   78|      0|                                               forKey:GULNSDataZlibErrorKey];
   79|      0|        if (strm.msg) {
   80|      0|          NSString *message = [NSString stringWithUTF8String:strm.msg];
   81|      0|          if (message) {
   82|      0|            [userInfo setObject:message forKey:NSLocalizedDescriptionKey];
   83|      0|          }
   84|      0|        }
   85|      0|        *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
   86|      0|                                     code:GULNSDataZlibErrorInternal
   87|      0|                                 userInfo:userInfo];
   88|      0|      }
   89|      0|      inflateEnd(&strm);
   90|      0|      return nil;
   91|      0|    }
   92|      9|    // Collect what we got.
   93|      9|    unsigned gotBack = kChunkSize - strm.avail_out;
   94|      9|    if (gotBack > 0) {
   95|      9|      [result appendBytes:output length:gotBack];
   96|      9|    }
   97|      9|
   98|      9|  } while (retCode == Z_OK);
   99|      9|
  100|      9|  // Make sure there wasn't more data tacked onto the end of a valid compressed stream.
  101|      9|  if (strm.avail_in != 0) {
  102|      0|    if (error) {
  103|      0|      NSDictionary *userInfo =
  104|      0|          [NSDictionary dictionaryWithObject:[NSNumber numberWithUnsignedInt:strm.avail_in]
  105|      0|                                      forKey:GULNSDataZlibRemainingBytesKey];
  106|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  107|      0|                                   code:GULNSDataZlibErrorDataRemaining
  108|      0|                               userInfo:userInfo];
  109|      0|    }
  110|      0|    result = nil;
  111|      0|  }
  112|      9|  // The only way out of the loop was by hitting the end of the stream.
  113|      9|  NSAssert(retCode == Z_STREAM_END,
  114|      9|           @"Thought we finished inflate w/o getting a result of stream end, code %d", retCode);
  115|      9|
  116|      9|  // Clean up.
  117|      9|  inflateEnd(&strm);
  118|      9|
  119|      9|  return result;
  120|      9|}
  121|       |
  122|      1|+ (NSData *)gul_dataByGzippingData:(NSData *)data error:(NSError **)error {
  123|      1|  const void *bytes = [data bytes];
  124|      1|  NSUInteger length = [data length];
  125|      1|
  126|      1|  int level = Z_DEFAULT_COMPRESSION;
  127|      1|  if (!bytes || !length) {
  128|      0|    return nil;
  129|      0|  }
  130|      1|
  131|      1|#if defined(__LP64__) && __LP64__
  132|      1|  // Don't support > 32bit length for 64 bit, see note in header.
  133|      1|  if (length > UINT_MAX) {
  134|      0|    if (error) {
  135|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  136|      0|                                   code:GULNSDataZlibErrorGreaterThan32BitsToCompress
  137|      0|                               userInfo:nil];
  138|      0|    }
  139|      0|    return nil;
  140|      0|  }
  141|      1|#endif
  142|      1|
  143|      1|  z_stream strm;
  144|      1|  bzero(&strm, sizeof(z_stream));
  145|      1|
  146|      1|  int memLevel = 8;          // Default.
  147|      1|  int windowBits = 15 + 16;  // Enable gzip header instead of zlib header.
  148|      1|
  149|      1|  int retCode;
  150|      1|  if ((retCode = deflateInit2(&strm, level, Z_DEFLATED, windowBits, memLevel,
  151|      1|                              Z_DEFAULT_STRATEGY)) != Z_OK) {
  152|      0|    if (error) {
  153|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  154|      0|                                                           forKey:GULNSDataZlibErrorKey];
  155|      0|      *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  156|      0|                                   code:GULNSDataZlibErrorInternal
  157|      0|                               userInfo:userInfo];
  158|      0|    }
  159|      0|    return nil;
  160|      0|  }
  161|      1|
  162|      1|  // Hint the size at 1/4 the input size.
  163|      1|  NSMutableData *result = [NSMutableData dataWithCapacity:(length / 4)];
  164|      1|  unsigned char output[kChunkSize];
  165|      1|
  166|      1|  // Setup the input.
  167|      1|  strm.avail_in = (unsigned int)length;
  168|      1|  strm.next_in = (unsigned char *)bytes;
  169|      1|
  170|      1|  // Collect the data.
  171|      2|  do {
  172|      2|    // update what we're passing in
  173|      2|    strm.avail_out = kChunkSize;
  174|      2|    strm.next_out = output;
  175|      2|    retCode = deflate(&strm, Z_FINISH);
  176|      2|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
  177|      0|      if (error) {
  178|      0|        NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  179|      0|                                                             forKey:GULNSDataZlibErrorKey];
  180|      0|        *error = [NSError errorWithDomain:GULNSDataZlibErrorDomain
  181|      0|                                     code:GULNSDataZlibErrorInternal
  182|      0|                                 userInfo:userInfo];
  183|      0|      }
  184|      0|      deflateEnd(&strm);
  185|      0|      return nil;
  186|      0|    }
  187|      2|    // Collect what we got.
  188|      2|    unsigned gotBack = kChunkSize - strm.avail_out;
  189|      2|    if (gotBack > 0) {
  190|      2|      [result appendBytes:output length:gotBack];
  191|      2|    }
  192|      2|
  193|      2|  } while (retCode == Z_OK);
  194|      1|
  195|      1|  // If the loop exits, it used all input and the stream ended.
  196|      1|  NSAssert(strm.avail_in == 0,
  197|      1|           @"Should have finished deflating without using all input, %u bytes left", strm.avail_in);
  198|      1|  NSAssert(retCode == Z_STREAM_END,
  199|      1|           @"thought we finished deflate w/o getting a result of stream end, code %d", retCode);
  200|      1|
  201|      1|  // Clean up.
  202|      1|  deflateEnd(&strm);
  203|      1|
  204|      1|  return result;
  205|      1|}
  206|       |
  207|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/Network/GULMutableDictionary.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Network/Private/GULMutableDictionary.h"
   16|       |
   17|       |@implementation GULMutableDictionary {
   18|       |  /// The mutable dictionary.
   19|       |  NSMutableDictionary *_objects;
   20|       |
   21|       |  /// Serial synchronization queue. All reads should use dispatch_sync, while writes use
   22|       |  /// dispatch_async.
   23|       |  dispatch_queue_t _queue;
   24|       |}
   25|       |
   26|      5|- (instancetype)init {
   27|      5|  self = [super init];
   28|      5|
   29|      5|  if (self) {
   30|      5|    _objects = [[NSMutableDictionary alloc] init];
   31|      5|    _queue = dispatch_queue_create("GULMutableDictionary", DISPATCH_QUEUE_SERIAL);
   32|      5|  }
   33|      5|
   34|      5|  return self;
   35|      5|}
   36|       |
   37|      0|- (NSString *)description {
   38|      0|  __block NSString *description;
   39|      0|  dispatch_sync(_queue, ^{
   40|      0|    description = self->_objects.description;
   41|      0|  });
   42|      0|  return description;
   43|      0|}
   44|       |
   45|      0|- (id)objectForKey:(id)key {
   46|      0|  __block id object;
   47|      0|  dispatch_sync(_queue, ^{
   48|      0|    object = [self->_objects objectForKey:key];
   49|      0|  });
   50|      0|  return object;
   51|      0|}
   52|       |
   53|      0|- (void)setObject:(id)object forKey:(id<NSCopying>)key {
   54|      0|  dispatch_async(_queue, ^{
   55|      0|    [self->_objects setObject:object forKey:key];
   56|      0|  });
   57|      0|}
   58|       |
   59|      1|- (void)removeObjectForKey:(id)key {
   60|      1|  dispatch_async(_queue, ^{
   61|      1|    [self->_objects removeObjectForKey:key];
   62|      1|  });
   63|      1|}
   64|       |
   65|      2|- (void)removeAllObjects {
   66|      2|  dispatch_async(_queue, ^{
   67|      2|    [self->_objects removeAllObjects];
   68|      2|  });
   69|      2|}
   70|       |
   71|      2|- (NSUInteger)count {
   72|      2|  __block NSUInteger count;
   73|      2|  dispatch_sync(_queue, ^{
   74|      2|    count = self->_objects.count;
   75|      2|  });
   76|      2|  return count;
   77|      2|}
   78|       |
   79|     54|- (id)objectForKeyedSubscript:(id<NSCopying>)key {
   80|     54|  __block id object;
   81|     54|  dispatch_sync(_queue, ^{
   82|     54|    object = self->_objects[key];
   83|     54|  });
   84|     54|  return object;
   85|     54|}
   86|       |
   87|     32|- (void)setObject:(id)obj forKeyedSubscript:(id<NSCopying>)key {
   88|     32|  dispatch_async(_queue, ^{
   89|     32|    self->_objects[key] = obj;
   90|     32|  });
   91|     32|}
   92|       |
   93|      0|- (NSDictionary *)dictionary {
   94|      0|  __block NSDictionary *dictionary;
   95|      0|  dispatch_sync(_queue, ^{
   96|      0|    dictionary = [self->_objects copy];
   97|      0|  });
   98|      0|  return dictionary;
   99|      0|}
  100|       |
  101|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/Network/GULNetwork.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "GoogleUtilities/Network/Private/GULNetwork.h"
   16|       |#import "GoogleUtilities/Network/Private/GULNetworkMessageCode.h"
   17|       |
   18|       |#import <GoogleUtilities/GULLogger.h>
   19|       |#import <GoogleUtilities/GULNSData+zlib.h>
   20|       |#import <GoogleUtilities/GULReachabilityChecker.h>
   21|       |#import "GoogleUtilities/Network/Private/GULMutableDictionary.h"
   22|       |#import "GoogleUtilities/Network/Private/GULNetworkConstants.h"
   23|       |
   24|       |/// Constant string for request header Content-Encoding.
   25|       |static NSString *const kGULNetworkContentCompressionKey = @"Content-Encoding";
   26|       |
   27|       |/// Constant string for request header Content-Encoding value.
   28|       |static NSString *const kGULNetworkContentCompressionValue = @"gzip";
   29|       |
   30|       |/// Constant string for request header Content-Length.
   31|       |static NSString *const kGULNetworkContentLengthKey = @"Content-Length";
   32|       |
   33|       |/// Constant string for request header Content-Type.
   34|       |static NSString *const kGULNetworkContentTypeKey = @"Content-Type";
   35|       |
   36|       |/// Constant string for request header Content-Type value.
   37|       |static NSString *const kGULNetworkContentTypeValue = @"application/x-www-form-urlencoded";
   38|       |
   39|       |/// Constant string for GET request method.
   40|       |static NSString *const kGULNetworkGETRequestMethod = @"GET";
   41|       |
   42|       |/// Constant string for POST request method.
   43|       |static NSString *const kGULNetworkPOSTRequestMethod = @"POST";
   44|       |
   45|       |/// Default constant string as a prefix for network logger.
   46|       |static NSString *const kGULNetworkLogTag = @"Google/Utilities/Network";
   47|       |
   48|       |@interface GULNetwork () <GULReachabilityDelegate, GULNetworkLoggerDelegate>
   49|       |@end
   50|       |
   51|       |@implementation GULNetwork {
   52|       |  /// Network reachability.
   53|       |  GULReachabilityChecker *_reachability;
   54|       |
   55|       |  /// The dictionary of requests by session IDs { NSString : id }.
   56|       |  GULMutableDictionary *_requests;
   57|       |}
   58|       |
   59|      0|- (instancetype)init {
   60|      0|  return [self initWithReachabilityHost:kGULNetworkReachabilityHost];
   61|      0|}
   62|       |
   63|      1|- (instancetype)initWithReachabilityHost:(NSString *)reachabilityHost {
   64|      1|  self = [super init];
   65|      1|  if (self) {
   66|      1|    // Setup reachability.
   67|      1|    _reachability = [[GULReachabilityChecker alloc] initWithReachabilityDelegate:self
   68|      1|                                                                        withHost:reachabilityHost];
   69|      1|    if (![_reachability start]) {
   70|      0|      return nil;
   71|      0|    }
   72|      1|
   73|      1|    _requests = [[GULMutableDictionary alloc] init];
   74|      1|    _timeoutInterval = kGULNetworkTimeOutInterval;
   75|      1|  }
   76|      1|  return self;
   77|      1|}
   78|       |
   79|      0|- (void)dealloc {
   80|      0|  _reachability.reachabilityDelegate = nil;
   81|      0|  [_reachability stop];
   82|      0|}
   83|       |
   84|       |#pragma mark - External Methods
   85|       |
   86|       |+ (void)handleEventsForBackgroundURLSessionID:(NSString *)sessionID
   87|      0|                            completionHandler:(GULNetworkSystemCompletionHandler)completionHandler {
   88|      0|  [GULNetworkURLSession handleEventsForBackgroundURLSessionID:sessionID
   89|      0|                                            completionHandler:completionHandler];
   90|      0|}
   91|       |
   92|       |- (NSString *)postURL:(NSURL *)url
   93|       |                   payload:(NSData *)payload
   94|       |                     queue:(dispatch_queue_t)queue
   95|       |    usingBackgroundSession:(BOOL)usingBackgroundSession
   96|      1|         completionHandler:(GULNetworkCompletionHandler)handler {
   97|      1|  if (!url.absoluteString.length) {
   98|      0|    [self handleErrorWithCode:GULErrorCodeNetworkInvalidURL queue:queue withHandler:handler];
   99|      0|    return nil;
  100|      0|  }
  101|      1|
  102|      1|  NSTimeInterval timeOutInterval = _timeoutInterval ?: kGULNetworkTimeOutInterval;
  103|      1|
  104|      1|  NSMutableURLRequest *request =
  105|      1|      [[NSMutableURLRequest alloc] initWithURL:url
  106|      1|                                   cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
  107|      1|                               timeoutInterval:timeOutInterval];
  108|      1|
  109|      1|  if (!request) {
  110|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  111|      0|                        queue:queue
  112|      0|                  withHandler:handler];
  113|      0|    return nil;
  114|      0|  }
  115|      1|
  116|      1|  NSError *compressError = nil;
  117|      1|  NSData *compressedData = [NSData gul_dataByGzippingData:payload error:&compressError];
  118|      1|  if (!compressedData || compressError) {
  119|      0|    if (compressError || payload.length > 0) {
  120|      0|      // If the payload is not empty but it fails to compress the payload, something has been wrong.
  121|      0|      [self handleErrorWithCode:GULErrorCodeNetworkPayloadCompression
  122|      0|                          queue:queue
  123|      0|                    withHandler:handler];
  124|      0|      return nil;
  125|      0|    }
  126|      0|    compressedData = [[NSData alloc] init];
  127|      0|  }
  128|      1|
  129|      1|  NSString *postLength = @(compressedData.length).stringValue;
  130|      1|
  131|      1|  // Set up the request with the compressed data.
  132|      1|  [request setValue:postLength forHTTPHeaderField:kGULNetworkContentLengthKey];
  133|      1|  request.HTTPBody = compressedData;
  134|      1|  request.HTTPMethod = kGULNetworkPOSTRequestMethod;
  135|      1|  [request setValue:kGULNetworkContentTypeValue forHTTPHeaderField:kGULNetworkContentTypeKey];
  136|      1|  [request setValue:kGULNetworkContentCompressionValue
  137|      1|      forHTTPHeaderField:kGULNetworkContentCompressionKey];
  138|      1|
  139|      1|  GULNetworkURLSession *fetcher = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:self];
  140|      1|  fetcher.backgroundNetworkEnabled = usingBackgroundSession;
  141|      1|
  142|      1|  __weak GULNetwork *weakSelf = self;
  143|      1|  NSString *requestID = [fetcher
  144|      1|      sessionIDFromAsyncPOSTRequest:request
  145|      1|                  completionHandler:^(NSHTTPURLResponse *response, NSData *data,
  146|      1|                                      NSString *sessionID, NSError *error) {
  147|      1|                    GULNetwork *strongSelf = weakSelf;
  148|      1|                    if (!strongSelf) {
  149|      0|                      return;
  150|      0|                    }
  151|      1|                    dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  152|      1|                    dispatch_async(queueToDispatch, ^{
  153|      1|                      if (sessionID.length) {
  154|      1|                        [strongSelf->_requests removeObjectForKey:sessionID];
  155|      1|                      }
  156|      1|                      if (handler) {
  157|      1|                        handler(response, data, error);
  158|      1|                      }
  159|      1|                    });
  160|      1|                  }];
  161|      1|  if (!requestID) {
  162|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  163|      0|                        queue:queue
  164|      0|                  withHandler:handler];
  165|      0|    return nil;
  166|      0|  }
  167|      1|
  168|      1|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  169|      1|                    messageCode:kGULNetworkMessageCodeNetwork000
  170|      1|                        message:@"Uploading data. Host"
  171|      1|                        context:url];
  172|      1|  _requests[requestID] = fetcher;
  173|      1|  return requestID;
  174|      1|}
  175|       |
  176|       |- (NSString *)getURL:(NSURL *)url
  177|       |                   headers:(NSDictionary *)headers
  178|       |                     queue:(dispatch_queue_t)queue
  179|       |    usingBackgroundSession:(BOOL)usingBackgroundSession
  180|      1|         completionHandler:(GULNetworkCompletionHandler)handler {
  181|      1|  if (!url.absoluteString.length) {
  182|      0|    [self handleErrorWithCode:GULErrorCodeNetworkInvalidURL queue:queue withHandler:handler];
  183|      0|    return nil;
  184|      0|  }
  185|      1|
  186|      1|  NSTimeInterval timeOutInterval = _timeoutInterval ?: kGULNetworkTimeOutInterval;
  187|      1|  NSMutableURLRequest *request =
  188|      1|      [[NSMutableURLRequest alloc] initWithURL:url
  189|      1|                                   cachePolicy:NSURLRequestReloadIgnoringLocalCacheData
  190|      1|                               timeoutInterval:timeOutInterval];
  191|      1|
  192|      1|  if (!request) {
  193|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  194|      0|                        queue:queue
  195|      0|                  withHandler:handler];
  196|      0|    return nil;
  197|      0|  }
  198|      1|
  199|      1|  request.HTTPMethod = kGULNetworkGETRequestMethod;
  200|      1|  request.allHTTPHeaderFields = headers;
  201|      1|
  202|      1|  GULNetworkURLSession *fetcher = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:self];
  203|      1|  fetcher.backgroundNetworkEnabled = usingBackgroundSession;
  204|      1|
  205|      1|  __weak GULNetwork *weakSelf = self;
  206|      1|  NSString *requestID = [fetcher
  207|      1|      sessionIDFromAsyncGETRequest:request
  208|      1|                 completionHandler:^(NSHTTPURLResponse *response, NSData *data, NSString *sessionID,
  209|      1|                                     NSError *error) {
  210|      0|                   GULNetwork *strongSelf = weakSelf;
  211|      0|                   if (!strongSelf) {
  212|      0|                     return;
  213|      0|                   }
  214|      0|                   dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  215|      0|                   dispatch_async(queueToDispatch, ^{
  216|      0|                     if (sessionID.length) {
  217|      0|                       [strongSelf->_requests removeObjectForKey:sessionID];
  218|      0|                     }
  219|      0|                     if (handler) {
  220|      0|                       handler(response, data, error);
  221|      0|                     }
  222|      0|                   });
  223|      0|                 }];
  224|      1|
  225|      1|  if (!requestID) {
  226|      0|    [self handleErrorWithCode:GULErrorCodeNetworkSessionTaskCreation
  227|      0|                        queue:queue
  228|      0|                  withHandler:handler];
  229|      0|    return nil;
  230|      0|  }
  231|      1|
  232|      1|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  233|      1|                    messageCode:kGULNetworkMessageCodeNetwork001
  234|      1|                        message:@"Downloading data. Host"
  235|      1|                        context:url];
  236|      1|  _requests[requestID] = fetcher;
  237|      1|  return requestID;
  238|      1|}
  239|       |
  240|      2|- (BOOL)hasUploadInProgress {
  241|      2|  return _requests.count > 0;
  242|      2|}
  243|       |
  244|       |#pragma mark - Network Reachability
  245|       |
  246|       |/// Tells reachability delegate to call reachabilityDidChangeToStatus: to notify the network
  247|       |/// reachability has changed.
  248|       |- (void)reachability:(GULReachabilityChecker *)reachability
  249|      1|       statusChanged:(GULReachabilityStatus)status {
  250|      1|  _networkConnected = (status == kGULReachabilityViaCellular || status == kGULReachabilityViaWifi);
  251|      1|  [_reachabilityDelegate reachabilityDidChange];
  252|      1|}
  253|       |
  254|       |#pragma mark - Network logger delegate
  255|       |
  256|      1|- (void)setLoggerDelegate:(id<GULNetworkLoggerDelegate>)loggerDelegate {
  257|      1|  // Explicitly check whether the delegate responds to the methods because conformsToProtocol does
  258|      1|  // not work correctly even though the delegate does respond to the methods.
  259|      1|  if (!loggerDelegate ||
  260|      1|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  261|      1|                                                                messageCode:message:contexts:)] ||
  262|      1|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  263|      1|                                                                messageCode:message:context:)] ||
  264|      1|      ![loggerDelegate respondsToSelector:@selector(GULNetwork_logWithLevel:
  265|      1|                                                                messageCode:message:)]) {
  266|      0|    GULLogError(kGULLoggerNetwork, NO,
  267|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULNetworkMessageCodeNetwork002],
  268|      0|                @"Cannot set the network logger delegate: delegate does not conform to the network "
  269|      0|                 "logger protocol.");
  270|      0|    return;
  271|      0|  }
  272|      1|  _loggerDelegate = loggerDelegate;
  273|      1|}
  274|       |
  275|       |#pragma mark - Private methods
  276|       |
  277|       |/// Handles network error and calls completion handler with the error.
  278|       |- (void)handleErrorWithCode:(NSInteger)code
  279|       |                      queue:(dispatch_queue_t)queue
  280|      0|                withHandler:(GULNetworkCompletionHandler)handler {
  281|      0|  NSDictionary *userInfo = @{kGULNetworkErrorContext : @"Failed to create network request"};
  282|      0|  NSError *error = [[NSError alloc] initWithDomain:kGULNetworkErrorDomain
  283|      0|                                              code:code
  284|      0|                                          userInfo:userInfo];
  285|      0|  [self GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  286|      0|                    messageCode:kGULNetworkMessageCodeNetwork002
  287|      0|                        message:@"Failed to create network request. Code, error"
  288|      0|                       contexts:@[ @(code), error ]];
  289|      0|  if (handler) {
  290|      0|    dispatch_queue_t queueToDispatch = queue ? queue : dispatch_get_main_queue();
  291|      0|    dispatch_async(queueToDispatch, ^{
  292|      0|      handler(nil, nil, error);
  293|      0|    });
  294|      0|  }
  295|      0|}
  296|       |
  297|       |#pragma mark - Network logger
  298|       |
  299|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  300|       |                    messageCode:(GULNetworkMessageCode)messageCode
  301|       |                        message:(NSString *)message
  302|      0|                       contexts:(NSArray *)contexts {
  303|      0|  // Let the delegate log the message if there is a valid logger delegate. Otherwise, just log
  304|      0|  // errors/warnings/info messages to the console log.
  305|      0|  if (_loggerDelegate) {
  306|      0|    [_loggerDelegate GULNetwork_logWithLevel:logLevel
  307|      0|                                 messageCode:messageCode
  308|      0|                                     message:message
  309|      0|                                    contexts:contexts];
  310|      0|    return;
  311|      0|  }
  312|      0|  if (_isDebugModeEnabled || logLevel == kGULNetworkLogLevelError ||
  313|      0|      logLevel == kGULNetworkLogLevelWarning || logLevel == kGULNetworkLogLevelInfo) {
  314|      0|    NSString *formattedMessage = GULStringWithLogMessage(message, logLevel, contexts);
  315|      0|    NSLog(@"%@", formattedMessage);
  316|      0|    GULLogBasic((GULLoggerLevel)logLevel, kGULLoggerNetwork, NO,
  317|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)messageCode], formattedMessage,
  318|      0|                NULL);
  319|      0|  }
  320|      0|}
  321|       |
  322|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  323|       |                    messageCode:(GULNetworkMessageCode)messageCode
  324|       |                        message:(NSString *)message
  325|      3|                        context:(id)context {
  326|      3|  if (_loggerDelegate) {
  327|      3|    [_loggerDelegate GULNetwork_logWithLevel:logLevel
  328|      3|                                 messageCode:messageCode
  329|      3|                                     message:message
  330|      3|                                     context:context];
  331|      3|    return;
  332|      3|  }
  333|      0|  NSArray *contexts = context ? @[ context ] : @[];
  334|      0|  [self GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message contexts:contexts];
  335|      0|}
  336|       |
  337|       |- (void)GULNetwork_logWithLevel:(GULNetworkLogLevel)logLevel
  338|       |                    messageCode:(GULNetworkMessageCode)messageCode
  339|      0|                        message:(NSString *)message {
  340|      0|  if (_loggerDelegate) {
  341|      0|    [_loggerDelegate GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message];
  342|      0|    return;
  343|      0|  }
  344|      0|  [self GULNetwork_logWithLevel:logLevel messageCode:messageCode message:message contexts:@[]];
  345|      0|}
  346|       |
  347|       |/// Returns a string for the given log level (e.g. kGULNetworkLogLevelError -> @"ERROR").
  348|      0|static NSString *GULLogLevelDescriptionFromLogLevel(GULNetworkLogLevel logLevel) {
  349|      0|  static NSDictionary *levelNames = nil;
  350|      0|  static dispatch_once_t onceToken;
  351|      0|  dispatch_once(&onceToken, ^{
  352|      0|    levelNames = @{
  353|      0|      @(kGULNetworkLogLevelError) : @"ERROR",
  354|      0|      @(kGULNetworkLogLevelWarning) : @"WARNING",
  355|      0|      @(kGULNetworkLogLevelInfo) : @"INFO",
  356|      0|      @(kGULNetworkLogLevelDebug) : @"DEBUG"
  357|      0|    };
  358|      0|  });
  359|      0|  return levelNames[@(logLevel)];
  360|      0|}
  361|       |
  362|       |/// Returns a formatted string to be used for console logging.
  363|       |static NSString *GULStringWithLogMessage(NSString *message,
  364|       |                                         GULNetworkLogLevel logLevel,
  365|      0|                                         NSArray *contexts) {
  366|      0|  if (!message) {
  367|      0|    message = @"(Message was nil)";
  368|      0|  } else if (!message.length) {
  369|      0|    message = @"(Message was empty)";
  370|      0|  }
  371|      0|  NSMutableString *result = [[NSMutableString alloc]
  372|      0|      initWithFormat:@"<%@/%@> %@", kGULNetworkLogTag, GULLogLevelDescriptionFromLogLevel(logLevel),
  373|      0|                     message];
  374|      0|
  375|      0|  if (!contexts.count) {
  376|      0|    return result;
  377|      0|  }
  378|      0|
  379|      0|  NSMutableArray *formattedContexts = [[NSMutableArray alloc] init];
  380|      0|  for (id item in contexts) {
  381|      0|    [formattedContexts addObject:(item != [NSNull null] ? item : @"(nil)")];
  382|      0|  }
  383|      0|
  384|      0|  [result appendString:@": "];
  385|      0|  [result appendString:[formattedContexts componentsJoinedByString:@", "]];
  386|      0|  return result;
  387|      0|}
  388|       |
  389|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/Network/GULNetworkURLSession.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "GoogleUtilities/Network/Private/GULNetworkURLSession.h"
   18|       |
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |#import "GoogleUtilities/Network/Private/GULMutableDictionary.h"
   21|       |#import "GoogleUtilities/Network/Private/GULNetworkConstants.h"
   22|       |#import "GoogleUtilities/Network/Private/GULNetworkMessageCode.h"
   23|       |
   24|       |@interface GULNetworkURLSession () <NSURLSessionDelegate,
   25|       |                                    NSURLSessionDataDelegate,
   26|       |                                    NSURLSessionDownloadDelegate,
   27|       |                                    NSURLSessionTaskDelegate>
   28|       |@end
   29|       |
   30|       |@implementation GULNetworkURLSession {
   31|       |  /// The handler to be called when the request completes or error has occurs.
   32|       |  GULNetworkURLSessionCompletionHandler _completionHandler;
   33|       |
   34|       |  /// Session ID generated randomly with a fixed prefix.
   35|       |  NSString *_sessionID;
   36|       |
   37|       |#pragma clang diagnostic push
   38|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   39|       |  /// The session configuration. NSURLSessionConfiguration' is only available on iOS 7.0 or newer.
   40|       |  NSURLSessionConfiguration *_sessionConfig;
   41|       |
   42|       |  /// The current NSURLSession.
   43|       |  NSURLSession *__weak _Nullable _URLSession;
   44|       |#pragma clang diagnostic pop
   45|       |
   46|       |  /// The path to the directory where all temporary files are stored before uploading.
   47|       |  NSURL *_networkDirectoryURL;
   48|       |
   49|       |  /// The downloaded data from fetching.
   50|       |  NSData *_downloadedData;
   51|       |
   52|       |  /// The path to the temporary file which stores the uploading data.
   53|       |  NSURL *_uploadingFileURL;
   54|       |
   55|       |  /// The current request.
   56|       |  NSURLRequest *_request;
   57|       |}
   58|       |
   59|       |#pragma mark - Init
   60|       |
   61|      2|- (instancetype)initWithNetworkLoggerDelegate:(id<GULNetworkLoggerDelegate>)networkLoggerDelegate {
   62|      2|  self = [super init];
   63|      2|  if (self) {
   64|      2|    // Create URL to the directory where all temporary files to upload have to be stored.
   65|      2|    NSArray *paths =
   66|      2|        NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
   67|      2|    NSString *applicationSupportDirectory = paths.firstObject;
   68|      2|    NSArray *tempPathComponents = @[
   69|      2|      applicationSupportDirectory, kGULNetworkApplicationSupportSubdirectory,
   70|      2|      kGULNetworkTempDirectoryName
   71|      2|    ];
   72|      2|    _networkDirectoryURL = [NSURL fileURLWithPathComponents:tempPathComponents];
   73|      2|    _sessionID = [NSString stringWithFormat:@"%@-%@", kGULNetworkBackgroundSessionConfigIDPrefix,
   74|      2|                                            [[NSUUID UUID] UUIDString]];
   75|      2|    _loggerDelegate = networkLoggerDelegate;
   76|      2|  }
   77|      2|  return self;
   78|      2|}
   79|       |
   80|       |#pragma mark - External Methods
   81|       |
   82|       |#pragma mark - To be called from AppDelegate
   83|       |
   84|       |+ (void)handleEventsForBackgroundURLSessionID:(NSString *)sessionID
   85|       |                            completionHandler:
   86|      0|                                (GULNetworkSystemCompletionHandler)systemCompletionHandler {
   87|      0|  // The session may not be Analytics background. Ignore those that do not have the prefix.
   88|      0|  if (![sessionID hasPrefix:kGULNetworkBackgroundSessionConfigIDPrefix]) {
   89|      0|    return;
   90|      0|  }
   91|      0|  GULNetworkURLSession *fetcher = [self fetcherWithSessionIdentifier:sessionID];
   92|      0|  if (fetcher != nil) {
   93|      0|    [fetcher addSystemCompletionHandler:systemCompletionHandler forSession:sessionID];
   94|      0|  } else {
   95|      0|    GULLogError(kGULLoggerNetwork, NO,
   96|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULNetworkMessageCodeNetwork003],
   97|      0|                @"Failed to retrieve background session with ID %@ after app is relaunched.",
   98|      0|                sessionID);
   99|      0|  }
  100|      0|}
  101|       |
  102|       |#pragma mark - External Methods
  103|       |
  104|       |/// Sends an async POST request using NSURLSession for iOS >= 7.0, and returns an ID of the
  105|       |/// connection.
  106|       |- (nullable NSString *)sessionIDFromAsyncPOSTRequest:(NSURLRequest *)request
  107|       |                                   completionHandler:(GULNetworkURLSessionCompletionHandler)handler
  108|      1|    API_AVAILABLE(ios(7.0)) {
  109|      1|  // NSURLSessionUploadTask does not work with NSData in the background.
  110|      1|  // To avoid this issue, write the data to a temporary file to upload it.
  111|      1|  // Make a temporary file with the data subset.
  112|      1|  _uploadingFileURL = [self temporaryFilePathWithSessionID:_sessionID];
  113|      1|  NSError *writeError;
  114|      1|  NSURLSessionUploadTask *postRequestTask;
  115|      1|  NSURLSession *session;
  116|      1|  BOOL didWriteFile = NO;
  117|      1|
  118|      1|  // Clean up the entire temp folder to avoid temp files that remain in case the previous session
  119|      1|  // crashed and did not clean up.
  120|      1|  [self maybeRemoveTempFilesAtURL:_networkDirectoryURL
  121|      1|                     expiringTime:kGULNetworkTempFolderExpireTime];
  122|      1|
  123|      1|  // If there is no background network enabled, no need to write to file. This will allow default
  124|      1|  // network session which runs on the foreground.
  125|      1|  if (_backgroundNetworkEnabled && [self ensureTemporaryDirectoryExists]) {
  126|      0|    didWriteFile = [request.HTTPBody writeToFile:_uploadingFileURL.path
  127|      0|                                         options:NSDataWritingAtomic
  128|      0|                                           error:&writeError];
  129|      0|
  130|      0|    if (writeError) {
  131|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  132|      0|                                   messageCode:kGULNetworkMessageCodeURLSession000
  133|      0|                                       message:@"Failed to write request data to file"
  134|      0|                                       context:writeError];
  135|      0|    }
  136|      0|  }
  137|      1|
  138|      1|  if (didWriteFile) {
  139|      0|    // Exclude this file from backing up to iTunes. There are conflicting reports that excluding
  140|      0|    // directory from backing up does not exclude files of that directory from backing up.
  141|      0|    [self excludeFromBackupForURL:_uploadingFileURL];
  142|      0|
  143|      0|    _sessionConfig = [self backgroundSessionConfigWithSessionID:_sessionID];
  144|      0|    [self populateSessionConfig:_sessionConfig withRequest:request];
  145|      0|    session = [NSURLSession sessionWithConfiguration:_sessionConfig
  146|      0|                                            delegate:self
  147|      0|                                       delegateQueue:[NSOperationQueue mainQueue]];
  148|      0|    postRequestTask = [session uploadTaskWithRequest:request fromFile:_uploadingFileURL];
  149|      1|  } else {
  150|      1|    // If we cannot write to file, just send it in the foreground.
  151|      1|    _sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];
  152|      1|    [self populateSessionConfig:_sessionConfig withRequest:request];
  153|      1|    session = [NSURLSession sessionWithConfiguration:_sessionConfig
  154|      1|                                            delegate:self
  155|      1|                                       delegateQueue:[NSOperationQueue mainQueue]];
  156|      1|    postRequestTask = [session uploadTaskWithRequest:request fromData:request.HTTPBody];
  157|      1|  }
  158|      1|
  159|      1|  if (!session || !postRequestTask) {
  160|      0|    NSError *error = [[NSError alloc]
  161|      0|        initWithDomain:kGULNetworkErrorDomain
  162|      0|                  code:GULErrorCodeNetworkRequestCreation
  163|      0|              userInfo:@{kGULNetworkErrorContext : @"Cannot create network session"}];
  164|      0|    [self callCompletionHandler:handler withResponse:nil data:nil error:error];
  165|      0|    return nil;
  166|      0|  }
  167|      1|
  168|      1|  _URLSession = session;
  169|      1|
  170|      1|  // Save the session into memory.
  171|      1|  [[self class] setSessionInFetcherMap:self forSessionID:_sessionID];
  172|      1|
  173|      1|  _request = [request copy];
  174|      1|
  175|      1|  // Store completion handler because background session does not accept handler block but custom
  176|      1|  // delegate.
  177|      1|  _completionHandler = [handler copy];
  178|      1|  [postRequestTask resume];
  179|      1|
  180|      1|  return _sessionID;
  181|      1|}
  182|       |
  183|       |/// Sends an async GET request using NSURLSession for iOS >= 7.0, and returns an ID of the session.
  184|       |- (nullable NSString *)sessionIDFromAsyncGETRequest:(NSURLRequest *)request
  185|       |                                  completionHandler:(GULNetworkURLSessionCompletionHandler)handler
  186|      1|    API_AVAILABLE(ios(7.0)) {
  187|      1|  if (_backgroundNetworkEnabled) {
  188|      0|    _sessionConfig = [self backgroundSessionConfigWithSessionID:_sessionID];
  189|      1|  } else {
  190|      1|    _sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];
  191|      1|  }
  192|      1|
  193|      1|  [self populateSessionConfig:_sessionConfig withRequest:request];
  194|      1|
  195|      1|  // Do not cache the GET request.
  196|      1|  _sessionConfig.URLCache = nil;
  197|      1|
  198|      1|  NSURLSession *session = [NSURLSession sessionWithConfiguration:_sessionConfig
  199|      1|                                                        delegate:self
  200|      1|                                                   delegateQueue:[NSOperationQueue mainQueue]];
  201|      1|  NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request];
  202|      1|
  203|      1|  if (!session || !downloadTask) {
  204|      0|    NSError *error = [[NSError alloc]
  205|      0|        initWithDomain:kGULNetworkErrorDomain
  206|      0|                  code:GULErrorCodeNetworkRequestCreation
  207|      0|              userInfo:@{kGULNetworkErrorContext : @"Cannot create network session"}];
  208|      0|    [self callCompletionHandler:handler withResponse:nil data:nil error:error];
  209|      0|    return nil;
  210|      0|  }
  211|      1|
  212|      1|  _URLSession = session;
  213|      1|
  214|      1|  // Save the session into memory.
  215|      1|  [[self class] setSessionInFetcherMap:self forSessionID:_sessionID];
  216|      1|
  217|      1|  _request = [request copy];
  218|      1|
  219|      1|  _completionHandler = [handler copy];
  220|      1|  [downloadTask resume];
  221|      1|
  222|      1|  return _sessionID;
  223|      1|}
  224|       |
  225|       |#pragma mark - NSURLSessionDataDelegate
  226|       |
  227|       |/// Called by the NSURLSession when the data task has received some of the expected data.
  228|       |/// Once the session is completed, URLSession:task:didCompleteWithError will be called and the
  229|       |/// completion handler will be called with the downloaded data.
  230|       |- (void)URLSession:(NSURLSession *)session
  231|       |          dataTask:(NSURLSessionDataTask *)dataTask
  232|      0|    didReceiveData:(NSData *)data {
  233|      0|  @synchronized(self) {
  234|      0|    NSMutableData *mutableData = [[NSMutableData alloc] init];
  235|      0|    if (_downloadedData) {
  236|      0|      mutableData = _downloadedData.mutableCopy;
  237|      0|    }
  238|      0|    [mutableData appendData:data];
  239|      0|    _downloadedData = mutableData;
  240|      0|  }
  241|      0|}
  242|       |
  243|       |#pragma mark - NSURLSessionTaskDelegate
  244|       |
  245|       |/// Called by the NSURLSession once the download task is completed. The file is saved in the
  246|       |/// provided URL so we need to read the data and store into _downloadedData. Once the session is
  247|       |/// completed, URLSession:task:didCompleteWithError will be called and the completion handler will
  248|       |/// be called with the downloaded data.
  249|       |- (void)URLSession:(NSURLSession *)session
  250|       |                 downloadTask:(NSURLSessionDownloadTask *)task
  251|      0|    didFinishDownloadingToURL:(NSURL *)url API_AVAILABLE(ios(7.0)) {
  252|      0|  if (!url.path) {
  253|      0|    [_loggerDelegate
  254|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  255|      0|                    messageCode:kGULNetworkMessageCodeURLSession001
  256|      0|                        message:@"Unable to read downloaded data from empty temp path"];
  257|      0|    _downloadedData = nil;
  258|      0|    return;
  259|      0|  }
  260|      0|
  261|      0|  NSError *error;
  262|      0|  _downloadedData = [NSData dataWithContentsOfFile:url.path options:0 error:&error];
  263|      0|
  264|      0|  if (error) {
  265|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  266|      0|                                 messageCode:kGULNetworkMessageCodeURLSession002
  267|      0|                                     message:@"Cannot read the content of downloaded data"
  268|      0|                                     context:error];
  269|      0|    _downloadedData = nil;
  270|      0|  }
  271|      0|}
  272|       |
  273|       |#if TARGET_OS_IOS || TARGET_OS_TV
  274|       |- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
  275|      0|    API_AVAILABLE(ios(7.0)) {
  276|      0|  [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  277|      0|                               messageCode:kGULNetworkMessageCodeURLSession003
  278|      0|                                   message:@"Background session finished"
  279|      0|                                   context:session.configuration.identifier];
  280|      0|  [self callSystemCompletionHandler:session.configuration.identifier];
  281|      0|}
  282|       |#endif
  283|       |
  284|       |- (void)URLSession:(NSURLSession *)session
  285|       |                    task:(NSURLSessionTask *)task
  286|      1|    didCompleteWithError:(NSError *)error API_AVAILABLE(ios(7.0)) {
  287|      1|  // Avoid any chance of recursive behavior leading to it being used repeatedly.
  288|      1|  GULNetworkURLSessionCompletionHandler handler = _completionHandler;
  289|      1|  _completionHandler = nil;
  290|      1|
  291|      1|  if (task.response) {
  292|      1|    // The following assertion should always be true for HTTP requests, see https://goo.gl/gVLxT7.
  293|      1|    NSAssert([task.response isKindOfClass:[NSHTTPURLResponse class]], @"URL response must be HTTP");
  294|      1|
  295|      1|    // The server responded so ignore the error created by the system.
  296|      1|    error = nil;
  297|      1|  } else if (!error) {
  298|      0|    error = [[NSError alloc]
  299|      0|        initWithDomain:kGULNetworkErrorDomain
  300|      0|                  code:GULErrorCodeNetworkInvalidResponse
  301|      0|              userInfo:@{kGULNetworkErrorContext : @"Network Error: Empty network response"}];
  302|      0|  }
  303|      1|
  304|      1|  [self callCompletionHandler:handler
  305|      1|                 withResponse:(NSHTTPURLResponse *)task.response
  306|      1|                         data:_downloadedData
  307|      1|                        error:error];
  308|      1|
  309|      1|  // Remove the temp file to avoid trashing devices with lots of temp files.
  310|      1|  [self removeTempItemAtURL:_uploadingFileURL];
  311|      1|
  312|      1|  // Try to clean up stale files again.
  313|      1|  [self maybeRemoveTempFilesAtURL:_networkDirectoryURL
  314|      1|                     expiringTime:kGULNetworkTempFolderExpireTime];
  315|      1|
  316|      1|  // This is called without checking the sessionID here since non-background sessions
  317|      1|  // won't have an ID.
  318|      1|  [session finishTasksAndInvalidate];
  319|      1|
  320|      1|  // Explicitly remove the session so it won't be reused. The weak map table should
  321|      1|  // remove the session on deallocation, but dealloc may not happen immediately after
  322|      1|  // calling `finishTasksAndInvalidate`.
  323|      1|  NSString *sessionID = session.configuration.identifier;
  324|      1|  [[self class] setSessionInFetcherMap:nil forSessionID:sessionID];
  325|      1|}
  326|       |
  327|       |- (void)URLSession:(NSURLSession *)session
  328|       |                   task:(NSURLSessionTask *)task
  329|       |    didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
  330|       |      completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition,
  331|       |                                  NSURLCredential *credential))completionHandler
  332|      1|    API_AVAILABLE(ios(7.0)) {
  333|      1|  // The handling is modeled after GTMSessionFetcher.
  334|      1|  if ([challenge.protectionSpace.authenticationMethod
  335|      1|          isEqualToString:NSURLAuthenticationMethodServerTrust]) {
  336|      1|    SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;
  337|      1|    if (serverTrust == NULL) {
  338|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  339|      0|                                   messageCode:kGULNetworkMessageCodeURLSession004
  340|      0|                                       message:@"Received empty server trust for host. Host"
  341|      0|                                       context:_request.URL];
  342|      0|      completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
  343|      0|      return;
  344|      0|    }
  345|      1|    NSURLCredential *credential = [NSURLCredential credentialForTrust:serverTrust];
  346|      1|    if (!credential) {
  347|      0|      [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  348|      0|                                   messageCode:kGULNetworkMessageCodeURLSession005
  349|      0|                                       message:@"Unable to verify server identity. Host"
  350|      0|                                       context:_request.URL];
  351|      0|      completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
  352|      0|      return;
  353|      0|    }
  354|      1|
  355|      1|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  356|      1|                                 messageCode:kGULNetworkMessageCodeURLSession006
  357|      1|                                     message:@"Received SSL challenge for host. Host"
  358|      1|                                     context:_request.URL];
  359|      1|
  360|      1|    void (^callback)(BOOL) = ^(BOOL allow) {
  361|      1|      if (allow) {
  362|      1|        completionHandler(NSURLSessionAuthChallengeUseCredential, credential);
  363|      1|      } else {
  364|      0|        [self->_loggerDelegate
  365|      0|            GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  366|      0|                        messageCode:kGULNetworkMessageCodeURLSession007
  367|      0|                            message:@"Cancelling authentication challenge for host. Host"
  368|      0|                            context:self->_request.URL];
  369|      0|        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
  370|      0|      }
  371|      1|    };
  372|      1|
  373|      1|    // Retain the trust object to avoid a SecTrustEvaluate() crash on iOS 7.
  374|      1|    CFRetain(serverTrust);
  375|      1|
  376|      1|    // Evaluate the certificate chain.
  377|      1|    //
  378|      1|    // The delegate queue may be the main thread. Trust evaluation could cause some
  379|      1|    // blocking network activity, so we must evaluate async, as documented at
  380|      1|    // https://developer.apple.com/library/ios/technotes/tn2232/
  381|      1|    dispatch_queue_t evaluateBackgroundQueue =
  382|      1|        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
  383|      1|
  384|      1|    dispatch_async(evaluateBackgroundQueue, ^{
  385|      1|      SecTrustResultType trustEval = kSecTrustResultInvalid;
  386|      1|      BOOL shouldAllow;
  387|      1|      OSStatus trustError;
  388|      1|
  389|      1|      @synchronized([GULNetworkURLSession class]) {
  390|      1|#pragma clang diagnostic push
  391|      1|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  392|      1|        trustError = SecTrustEvaluate(serverTrust, &trustEval);
  393|      1|#pragma clang dianostic pop
  394|      1|      }
  395|      1|
  396|      1|      if (trustError != errSecSuccess) {
  397|      0|        [self->_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  398|      0|                                           messageCode:kGULNetworkMessageCodeURLSession008
  399|      0|                                               message:@"Cannot evaluate server trust. Error, host"
  400|      0|                                              contexts:@[ @(trustError), self->_request.URL ]];
  401|      0|        shouldAllow = NO;
  402|      1|      } else {
  403|      1|        // Having a trust level "unspecified" by the user is the usual result, described at
  404|      1|        // https://developer.apple.com/library/mac/qa/qa1360
  405|      1|        shouldAllow =
  406|      1|            (trustEval == kSecTrustResultUnspecified || trustEval == kSecTrustResultProceed);
  407|      1|      }
  408|      1|
  409|      1|      // Call the call back with the permission.
  410|      1|      callback(shouldAllow);
  411|      1|
  412|      1|      CFRelease(serverTrust);
  413|      1|    });
  414|      1|    return;
  415|      1|  }
  416|      0|
  417|      0|  // Default handling for other Auth Challenges.
  418|      0|  completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
  419|      0|}
  420|       |
  421|       |#pragma mark - Internal Methods
  422|       |
  423|       |/// Stores system completion handler with session ID as key.
  424|       |- (void)addSystemCompletionHandler:(GULNetworkSystemCompletionHandler)handler
  425|      0|                        forSession:(NSString *)identifier {
  426|      0|  if (!handler) {
  427|      0|    [_loggerDelegate
  428|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  429|      0|                    messageCode:kGULNetworkMessageCodeURLSession009
  430|      0|                        message:@"Cannot store nil system completion handler in network"];
  431|      0|    return;
  432|      0|  }
  433|      0|
  434|      0|  if (!identifier.length) {
  435|      0|    [_loggerDelegate
  436|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  437|      0|                    messageCode:kGULNetworkMessageCodeURLSession010
  438|      0|                        message:@"Cannot store system completion handler with empty network "
  439|      0|                                 "session identifier"];
  440|      0|    return;
  441|      0|  }
  442|      0|
  443|      0|  GULMutableDictionary *systemCompletionHandlers =
  444|      0|      [[self class] sessionIDToSystemCompletionHandlerDictionary];
  445|      0|  if (systemCompletionHandlers[identifier]) {
  446|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  447|      0|                                 messageCode:kGULNetworkMessageCodeURLSession011
  448|      0|                                     message:@"Got multiple system handlers for a single session ID"
  449|      0|                                     context:identifier];
  450|      0|  }
  451|      0|
  452|      0|  systemCompletionHandlers[identifier] = handler;
  453|      0|}
  454|       |
  455|       |/// Calls the system provided completion handler with the session ID stored in the dictionary.
  456|       |/// The handler will be removed from the dictionary after being called.
  457|      0|- (void)callSystemCompletionHandler:(NSString *)identifier {
  458|      0|  GULMutableDictionary *systemCompletionHandlers =
  459|      0|      [[self class] sessionIDToSystemCompletionHandlerDictionary];
  460|      0|  GULNetworkSystemCompletionHandler handler = [systemCompletionHandlers objectForKey:identifier];
  461|      0|
  462|      0|  if (handler) {
  463|      0|    [systemCompletionHandlers removeObjectForKey:identifier];
  464|      0|
  465|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  466|      0|      handler();
  467|      0|    });
  468|      0|  }
  469|      0|}
  470|       |
  471|       |/// Sets or updates the session ID of this session.
  472|      0|- (void)setSessionID:(NSString *)sessionID {
  473|      0|  _sessionID = [sessionID copy];
  474|      0|}
  475|       |
  476|       |/// Creates a background session configuration with the session ID using the supported method.
  477|       |- (NSURLSessionConfiguration *)backgroundSessionConfigWithSessionID:(NSString *)sessionID
  478|      0|    API_AVAILABLE(ios(7.0)) {
  479|      0|#if (TARGET_OS_OSX && defined(MAC_OS_X_VERSION_10_10) &&         \
  480|      0|     MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_10) || \
  481|      0|    TARGET_OS_TV ||                                              \
  482|      0|    (TARGET_OS_IOS && defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_8_0)
  483|      0|
  484|      0|  // iOS 8/10.10 builds require the new backgroundSessionConfiguration method name.
  485|      0|  return [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionID];
  486|      0|
  487|       |#elif (TARGET_OS_OSX && defined(MAC_OS_X_VERSION_10_10) &&        \
  488|       |       MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_10) || \
  489|       |    (TARGET_OS_IOS && defined(__IPHONE_8_0) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_8_0)
  490|       |
  491|       |  // Do a runtime check to avoid a deprecation warning about using
  492|       |  // +backgroundSessionConfiguration: on iOS 8.
  493|       |  if ([NSURLSessionConfiguration
  494|       |          respondsToSelector:@selector(backgroundSessionConfigurationWithIdentifier:)]) {
  495|       |    // Running on iOS 8+/OS X 10.10+.
  496|       |#pragma clang diagnostic push
  497|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
  498|       |    return [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionID];
  499|       |#pragma clang diagnostic pop
  500|       |  } else {
  501|       |    // Running on iOS 7/OS X 10.9.
  502|       |    return [NSURLSessionConfiguration backgroundSessionConfiguration:sessionID];
  503|       |  }
  504|       |
  505|       |#else
  506|       |  // Building with an SDK earlier than iOS 8/OS X 10.10.
  507|       |  return [NSURLSessionConfiguration backgroundSessionConfiguration:sessionID];
  508|       |#endif
  509|       |}
  510|       |
  511|      2|- (void)maybeRemoveTempFilesAtURL:(NSURL *)folderURL expiringTime:(NSTimeInterval)staleTime {
  512|      2|  if (!folderURL.absoluteString.length) {
  513|      0|    return;
  514|      0|  }
  515|      2|
  516|      2|  NSFileManager *fileManager = [NSFileManager defaultManager];
  517|      2|  NSError *error = nil;
  518|      2|
  519|      2|  NSArray *properties = @[ NSURLCreationDateKey ];
  520|      2|  NSArray *directoryContent =
  521|      2|      [fileManager contentsOfDirectoryAtURL:folderURL
  522|      2|                 includingPropertiesForKeys:properties
  523|      2|                                    options:NSDirectoryEnumerationSkipsSubdirectoryDescendants
  524|      2|                                      error:&error];
  525|      2|  if (error && error.code != NSFileReadNoSuchFileError) {
  526|      0|    [_loggerDelegate
  527|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelDebug
  528|      0|                    messageCode:kGULNetworkMessageCodeURLSession012
  529|      0|                        message:@"Cannot get files from the temporary network folder. Error"
  530|      0|                        context:error];
  531|      0|    return;
  532|      0|  }
  533|      2|
  534|      2|  if (!directoryContent.count) {
  535|      2|    return;
  536|      2|  }
  537|      0|
  538|      0|  NSTimeInterval now = [NSDate date].timeIntervalSince1970;
  539|      0|  for (NSURL *tempFile in directoryContent) {
  540|      0|    NSDate *creationDate;
  541|      0|    BOOL getCreationDate = [tempFile getResourceValue:&creationDate
  542|      0|                                               forKey:NSURLCreationDateKey
  543|      0|                                                error:NULL];
  544|      0|    if (!getCreationDate) {
  545|      0|      continue;
  546|      0|    }
  547|      0|    NSTimeInterval creationTimeInterval = creationDate.timeIntervalSince1970;
  548|      0|    if (fabs(now - creationTimeInterval) > staleTime) {
  549|      0|      [self removeTempItemAtURL:tempFile];
  550|      0|    }
  551|      0|  }
  552|      0|}
  553|       |
  554|       |/// Removes the temporary file written to disk for sending the request. It has to be cleaned up
  555|       |/// after the session is done.
  556|      1|- (void)removeTempItemAtURL:(NSURL *)fileURL {
  557|      1|  if (!fileURL.absoluteString.length) {
  558|      0|    return;
  559|      0|  }
  560|      1|
  561|      1|  NSFileManager *fileManager = [NSFileManager defaultManager];
  562|      1|  NSError *error = nil;
  563|      1|
  564|      1|  if (![fileManager removeItemAtURL:fileURL error:&error] && error.code != NSFileNoSuchFileError) {
  565|      0|    [_loggerDelegate
  566|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelError
  567|      0|                    messageCode:kGULNetworkMessageCodeURLSession013
  568|      0|                        message:@"Failed to remove temporary uploading data file. Error"
  569|      0|                        context:error.localizedDescription];
  570|      0|  }
  571|      1|}
  572|       |
  573|       |/// Gets the fetcher with the session ID.
  574|      0|+ (instancetype)fetcherWithSessionIdentifier:(NSString *)sessionIdentifier {
  575|      0|  GULNetworkURLSession *session = [self sessionFromFetcherMapForSessionID:sessionIdentifier];
  576|      0|  if (!session && [sessionIdentifier hasPrefix:kGULNetworkBackgroundSessionConfigIDPrefix]) {
  577|      0|    session = [[GULNetworkURLSession alloc] initWithNetworkLoggerDelegate:nil];
  578|      0|    [session setSessionID:sessionIdentifier];
  579|      0|    [self setSessionInFetcherMap:session forSessionID:sessionIdentifier];
  580|      0|  }
  581|      0|  return session;
  582|      0|}
  583|       |
  584|       |/// Returns a map of the fetcher by session ID. Creates a map if it is not created.
  585|       |/// When reading and writing from/to the session map, don't use this method directly.
  586|       |/// To avoid thread safety issues, use one of the helper methods at the bottom of the
  587|       |/// file: setSessionInFetcherMap:forSessionID:, sessionFromFetcherMapForSessionID:
  588|      6|+ (NSMapTable<NSString *, GULNetworkURLSession *> *)sessionIDToFetcherMap {
  589|      6|  static NSMapTable *sessionIDToFetcherMap;
  590|      6|
  591|      6|  static dispatch_once_t sessionMapOnceToken;
  592|      6|  dispatch_once(&sessionMapOnceToken, ^{
  593|      1|    sessionIDToFetcherMap = [NSMapTable strongToWeakObjectsMapTable];
  594|      1|  });
  595|      6|  return sessionIDToFetcherMap;
  596|      6|}
  597|       |
  598|      6|+ (NSLock *)sessionIDToFetcherMapReadWriteLock {
  599|      6|  static NSLock *lock;
  600|      6|
  601|      6|  static dispatch_once_t onceToken;
  602|      6|  dispatch_once(&onceToken, ^{
  603|      1|    lock = [[NSLock alloc] init];
  604|      1|  });
  605|      6|  return lock;
  606|      6|}
  607|       |
  608|       |/// Returns a map of system provided completion handler by session ID. Creates a map if it is not
  609|       |/// created.
  610|      0|+ (GULMutableDictionary *)sessionIDToSystemCompletionHandlerDictionary {
  611|      0|  static GULMutableDictionary *systemCompletionHandlers;
  612|      0|
  613|      0|  static dispatch_once_t systemCompletionHandlerOnceToken;
  614|      0|  dispatch_once(&systemCompletionHandlerOnceToken, ^{
  615|      0|    systemCompletionHandlers = [[GULMutableDictionary alloc] init];
  616|      0|  });
  617|      0|  return systemCompletionHandlers;
  618|      0|}
  619|       |
  620|      1|- (NSURL *)temporaryFilePathWithSessionID:(NSString *)sessionID {
  621|      1|  NSString *tempName = [NSString stringWithFormat:@"GULUpload_temp_%@", sessionID];
  622|      1|  return [_networkDirectoryURL URLByAppendingPathComponent:tempName];
  623|      1|}
  624|       |
  625|       |/// Makes sure that the directory to store temp files exists. If not, tries to create it and returns
  626|       |/// YES. If there is anything wrong, returns NO.
  627|      0|- (BOOL)ensureTemporaryDirectoryExists {
  628|      0|  NSFileManager *fileManager = [NSFileManager defaultManager];
  629|      0|  NSError *error = nil;
  630|      0|
  631|      0|  // Create a temporary directory if it does not exist or was deleted.
  632|      0|  if ([_networkDirectoryURL checkResourceIsReachableAndReturnError:&error]) {
  633|      0|    return YES;
  634|      0|  }
  635|      0|
  636|      0|  if (error && error.code != NSFileReadNoSuchFileError) {
  637|      0|    [_loggerDelegate
  638|      0|        GULNetwork_logWithLevel:kGULNetworkLogLevelWarning
  639|      0|                    messageCode:kGULNetworkMessageCodeURLSession014
  640|      0|                        message:@"Error while trying to access Network temp folder. Error"
  641|      0|                        context:error];
  642|      0|  }
  643|      0|
  644|      0|  NSError *writeError = nil;
  645|      0|
  646|      0|  [fileManager createDirectoryAtURL:_networkDirectoryURL
  647|      0|        withIntermediateDirectories:YES
  648|      0|                         attributes:nil
  649|      0|                              error:&writeError];
  650|      0|  if (writeError) {
  651|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  652|      0|                                 messageCode:kGULNetworkMessageCodeURLSession015
  653|      0|                                     message:@"Cannot create temporary directory. Error"
  654|      0|                                     context:writeError];
  655|      0|    return NO;
  656|      0|  }
  657|      0|
  658|      0|  // Set the iCloud exclusion attribute on the Documents URL.
  659|      0|  [self excludeFromBackupForURL:_networkDirectoryURL];
  660|      0|
  661|      0|  return YES;
  662|      0|}
  663|       |
  664|      0|- (void)excludeFromBackupForURL:(NSURL *)url {
  665|      0|  if (!url.path) {
  666|      0|    return;
  667|      0|  }
  668|      0|
  669|      0|  // Set the iCloud exclusion attribute on the Documents URL.
  670|      0|  NSError *preventBackupError = nil;
  671|      0|  [url setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:&preventBackupError];
  672|      0|  if (preventBackupError) {
  673|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  674|      0|                                 messageCode:kGULNetworkMessageCodeURLSession016
  675|      0|                                     message:@"Cannot exclude temporary folder from iTunes backup"];
  676|      0|  }
  677|      0|}
  678|       |
  679|       |- (void)URLSession:(NSURLSession *)session
  680|       |                          task:(NSURLSessionTask *)task
  681|       |    willPerformHTTPRedirection:(NSHTTPURLResponse *)response
  682|       |                    newRequest:(NSURLRequest *)request
  683|      0|             completionHandler:(void (^)(NSURLRequest *))completionHandler API_AVAILABLE(ios(7.0)) {
  684|      0|  NSArray *nonAllowedRedirectionCodes = @[
  685|      0|    @(kGULNetworkHTTPStatusCodeFound), @(kGULNetworkHTTPStatusCodeMovedPermanently),
  686|      0|    @(kGULNetworkHTTPStatusCodeMovedTemporarily), @(kGULNetworkHTTPStatusCodeMultipleChoices)
  687|      0|  ];
  688|      0|
  689|      0|  // Allow those not in the non allowed list to be followed.
  690|      0|  if (![nonAllowedRedirectionCodes containsObject:@(response.statusCode)]) {
  691|      0|    completionHandler(request);
  692|      0|    return;
  693|      0|  }
  694|      0|
  695|      0|  // Do not allow redirection if the response code is in the non-allowed list.
  696|      0|  NSURLRequest *newRequest = request;
  697|      0|
  698|      0|  if (response) {
  699|      0|    newRequest = nil;
  700|      0|  }
  701|      0|
  702|      0|  completionHandler(newRequest);
  703|      0|}
  704|       |
  705|       |#pragma mark - Helper Methods
  706|       |
  707|      3|+ (void)setSessionInFetcherMap:(GULNetworkURLSession *)session forSessionID:(NSString *)sessionID {
  708|      3|  [[self sessionIDToFetcherMapReadWriteLock] lock];
  709|      3|  GULNetworkURLSession *existingSession =
  710|      3|      [[[self class] sessionIDToFetcherMap] objectForKey:sessionID];
  711|      3|  if (existingSession) {
  712|      0|    if (session) {
  713|      0|      NSString *message = [NSString stringWithFormat:@"Discarding session: %@", existingSession];
  714|      0|      [existingSession->_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelInfo
  715|      0|                                                    messageCode:kGULNetworkMessageCodeURLSession019
  716|      0|                                                        message:message];
  717|      0|    }
  718|      0|    [existingSession->_URLSession finishTasksAndInvalidate];
  719|      0|  }
  720|      3|  if (session) {
  721|      2|    [[[self class] sessionIDToFetcherMap] setObject:session forKey:sessionID];
  722|      2|  } else {
  723|      1|    [[[self class] sessionIDToFetcherMap] removeObjectForKey:sessionID];
  724|      1|  }
  725|      3|  [[self sessionIDToFetcherMapReadWriteLock] unlock];
  726|      3|}
  727|       |
  728|      0|+ (nullable GULNetworkURLSession *)sessionFromFetcherMapForSessionID:(NSString *)sessionID {
  729|      0|  [[self sessionIDToFetcherMapReadWriteLock] lock];
  730|      0|  GULNetworkURLSession *session = [[[self class] sessionIDToFetcherMap] objectForKey:sessionID];
  731|      0|  [[self sessionIDToFetcherMapReadWriteLock] unlock];
  732|      0|  return session;
  733|      0|}
  734|       |
  735|       |- (void)callCompletionHandler:(GULNetworkURLSessionCompletionHandler)handler
  736|       |                 withResponse:(NSHTTPURLResponse *)response
  737|       |                         data:(NSData *)data
  738|      1|                        error:(NSError *)error {
  739|      1|  if (error) {
  740|      0|    [_loggerDelegate GULNetwork_logWithLevel:kGULNetworkLogLevelError
  741|      0|                                 messageCode:kGULNetworkMessageCodeURLSession017
  742|      0|                                     message:@"Encounter network error. Code, error"
  743|      0|                                    contexts:@[ @(error.code), error ]];
  744|      0|  }
  745|      1|
  746|      1|  if (handler) {
  747|      1|    dispatch_async(dispatch_get_main_queue(), ^{
  748|      1|      handler(response, data, self->_sessionID, error);
  749|      1|    });
  750|      1|  }
  751|      1|}
  752|       |
  753|       |// Always use the request parameters even if the default session configuration is more restrictive.
  754|       |- (void)populateSessionConfig:(NSURLSessionConfiguration *)sessionConfig
  755|      2|                  withRequest:(NSURLRequest *)request API_AVAILABLE(ios(7.0)) {
  756|      2|  sessionConfig.HTTPAdditionalHeaders = request.allHTTPHeaderFields;
  757|      2|  sessionConfig.timeoutIntervalForRequest = request.timeoutInterval;
  758|      2|  sessionConfig.timeoutIntervalForResource = request.timeoutInterval;
  759|      2|  sessionConfig.requestCachePolicy = request.cachePolicy;
  760|      2|}
  761|       |
  762|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/Reachability/GULReachabilityChecker.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "GoogleUtilities/Reachability/GULReachabilityChecker+Internal.h"
   18|       |#import "GoogleUtilities/Reachability/Private/GULReachabilityChecker.h"
   19|       |#import "GoogleUtilities/Reachability/Private/GULReachabilityMessageCode.h"
   20|       |
   21|       |#import <GoogleUtilities/GULLogger.h>
   22|       |#import <GoogleUtilities/GULReachabilityChecker.h>
   23|       |
   24|       |static GULLoggerService kGULLoggerReachability = @"[GULReachability]";
   25|       |#if !TARGET_OS_WATCH
   26|       |static void ReachabilityCallback(SCNetworkReachabilityRef reachability,
   27|       |                                 SCNetworkReachabilityFlags flags,
   28|       |                                 void *info);
   29|       |
   30|       |static const struct GULReachabilityApi kGULDefaultReachabilityApi = {
   31|       |    SCNetworkReachabilityCreateWithName,
   32|       |    SCNetworkReachabilitySetCallback,
   33|       |    SCNetworkReachabilityScheduleWithRunLoop,
   34|       |    SCNetworkReachabilityUnscheduleFromRunLoop,
   35|       |    CFRelease,
   36|       |};
   37|       |
   38|       |static NSString *const kGULReachabilityUnknownStatus = @"Unknown";
   39|       |static NSString *const kGULReachabilityConnectedStatus = @"Connected";
   40|       |static NSString *const kGULReachabilityDisconnectedStatus = @"Disconnected";
   41|       |#endif
   42|       |@interface GULReachabilityChecker ()
   43|       |
   44|       |@property(nonatomic, assign) const struct GULReachabilityApi *reachabilityApi;
   45|       |@property(nonatomic, assign) GULReachabilityStatus reachabilityStatus;
   46|       |@property(nonatomic, copy) NSString *host;
   47|       |#if !TARGET_OS_WATCH
   48|       |@property(nonatomic, assign) SCNetworkReachabilityRef reachability;
   49|       |#endif
   50|       |
   51|       |@end
   52|       |
   53|       |@implementation GULReachabilityChecker
   54|       |
   55|       |@synthesize reachabilityApi = reachabilityApi_;
   56|       |#if !TARGET_OS_WATCH
   57|       |@synthesize reachability = reachability_;
   58|       |#endif
   59|       |
   60|      0|- (const struct GULReachabilityApi *)reachabilityApi {
   61|      0|  return reachabilityApi_;
   62|      0|}
   63|       |
   64|      0|- (void)setReachabilityApi:(const struct GULReachabilityApi *)reachabilityApi {
   65|      0|#if !TARGET_OS_WATCH
   66|      0|  if (reachability_) {
   67|      0|    GULLogError(kGULLoggerReachability, NO,
   68|      0|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode000],
   69|      0|                @"Cannot change reachability API while reachability is running. "
   70|      0|                @"Call stop first.");
   71|      0|    return;
   72|      0|  }
   73|      0|  reachabilityApi_ = reachabilityApi;
   74|      0|#endif
   75|      0|}
   76|       |
   77|       |@synthesize reachabilityStatus = reachabilityStatus_;
   78|       |@synthesize host = host_;
   79|       |@synthesize reachabilityDelegate = reachabilityDelegate_;
   80|       |
   81|      0|- (BOOL)isActive {
   82|      0|#if !TARGET_OS_WATCH
   83|      0|  return reachability_ != nil;
   84|       |#else
   85|       |  return NO;
   86|       |#endif
   87|       |}
   88|       |
   89|      1|- (void)setReachabilityDelegate:(id<GULReachabilityDelegate>)reachabilityDelegate {
   90|      1|  if (reachabilityDelegate &&
   91|      1|      (![(NSObject *)reachabilityDelegate conformsToProtocol:@protocol(GULReachabilityDelegate)])) {
   92|      0|    GULLogError(kGULLoggerReachability, NO,
   93|      0|                [NSString stringWithFormat:@"I-NET%06ld", (long)kGULReachabilityMessageCode005],
   94|      0|                @"Reachability delegate doesn't conform to Reachability protocol.");
   95|      0|    return;
   96|      0|  }
   97|      1|  reachabilityDelegate_ = reachabilityDelegate;
   98|      1|}
   99|       |
  100|       |- (instancetype)initWithReachabilityDelegate:(id<GULReachabilityDelegate>)reachabilityDelegate
  101|      1|                                    withHost:(NSString *)host {
  102|      1|  self = [super init];
  103|      1|
  104|      1|  if (!host || !host.length) {
  105|      0|    GULLogError(kGULLoggerReachability, NO,
  106|      0|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode001],
  107|      0|                @"Invalid host specified");
  108|      0|    return nil;
  109|      0|  }
  110|      1|  if (self) {
  111|      1|#if !TARGET_OS_WATCH
  112|      1|    [self setReachabilityDelegate:reachabilityDelegate];
  113|      1|    reachabilityApi_ = &kGULDefaultReachabilityApi;
  114|      1|    reachabilityStatus_ = kGULReachabilityUnknown;
  115|      1|    host_ = [host copy];
  116|      1|    reachability_ = nil;
  117|      1|#endif
  118|      1|  }
  119|      1|  return self;
  120|      1|}
  121|       |
  122|      0|- (void)dealloc {
  123|      0|  reachabilityDelegate_ = nil;
  124|      0|  [self stop];
  125|      0|}
  126|       |
  127|      1|- (BOOL)start {
  128|       |#if TARGET_OS_WATCH
  129|       |  return NO;
  130|       |#else
  131|       |
  132|      1|  if (!reachability_) {
  133|      1|    reachability_ = reachabilityApi_->createWithNameFn(kCFAllocatorDefault, [host_ UTF8String]);
  134|      1|    if (!reachability_) {
  135|      0|      return NO;
  136|      0|    }
  137|      1|    SCNetworkReachabilityContext context = {
  138|      1|        0,                       /* version */
  139|      1|        (__bridge void *)(self), /* info (passed as last parameter to reachability callback) */
  140|      1|        NULL,                    /* retain */
  141|      1|        NULL,                    /* release */
  142|      1|        NULL                     /* copyDescription */
  143|      1|    };
  144|      1|    if (!reachabilityApi_->setCallbackFn(reachability_, ReachabilityCallback, &context) ||
  145|      1|        !reachabilityApi_->scheduleWithRunLoopFn(reachability_, CFRunLoopGetMain(),
  146|      1|                                                 kCFRunLoopCommonModes)) {
  147|      0|      reachabilityApi_->releaseFn(reachability_);
  148|      0|      reachability_ = nil;
  149|      0|
  150|      0|      GULLogError(kGULLoggerReachability, NO,
  151|      0|                  [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode002],
  152|      0|                  @"Failed to start reachability handle");
  153|      0|      return NO;
  154|      0|    }
  155|      1|  }
  156|      1|  GULLogDebug(kGULLoggerReachability, NO,
  157|      1|              [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode003],
  158|      1|              @"Monitoring the network status");
  159|      1|  return YES;
  160|      1|#endif
  161|      1|}
  162|       |
  163|      0|- (void)stop {
  164|      0|#if !TARGET_OS_WATCH
  165|      0|  if (reachability_) {
  166|      0|    reachabilityStatus_ = kGULReachabilityUnknown;
  167|      0|    reachabilityApi_->unscheduleFromRunLoopFn(reachability_, CFRunLoopGetMain(),
  168|      0|                                              kCFRunLoopCommonModes);
  169|      0|    reachabilityApi_->releaseFn(reachability_);
  170|      0|    reachability_ = nil;
  171|      0|  }
  172|      0|#endif
  173|      0|}
  174|       |
  175|       |#if !TARGET_OS_WATCH
  176|      1|- (GULReachabilityStatus)statusForFlags:(SCNetworkReachabilityFlags)flags {
  177|      1|  GULReachabilityStatus status = kGULReachabilityNotReachable;
  178|      1|  // If the Reachable flag is not set, we definitely don't have connectivity.
  179|      1|  if (flags & kSCNetworkReachabilityFlagsReachable) {
  180|      1|    // Reachable flag is set. Check further flags.
  181|      1|    if (!(flags & kSCNetworkReachabilityFlagsConnectionRequired)) {
  182|      1|// Connection required flag is not set, so we have connectivity.
  183|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  184|      1|      status = (flags & kSCNetworkReachabilityFlagsIsWWAN) ? kGULReachabilityViaCellular
  185|      1|                                                           : kGULReachabilityViaWifi;
  186|       |#elif TARGET_OS_OSX
  187|       |      status = kGULReachabilityViaWifi;
  188|       |#endif
  189|      0|    } else if ((flags & (kSCNetworkReachabilityFlagsConnectionOnDemand |
  190|      0|                         kSCNetworkReachabilityFlagsConnectionOnTraffic)) &&
  191|      0|               !(flags & kSCNetworkReachabilityFlagsInterventionRequired)) {
  192|      0|// If the connection on demand or connection on traffic flag is set, and user intervention
  193|      0|// is not required, we have connectivity.
  194|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  195|      0|      status = (flags & kSCNetworkReachabilityFlagsIsWWAN) ? kGULReachabilityViaCellular
  196|      0|                                                           : kGULReachabilityViaWifi;
  197|       |#elif TARGET_OS_OSX
  198|       |      status = kGULReachabilityViaWifi;
  199|       |#endif
  200|       |    }
  201|      1|  }
  202|      1|  return status;
  203|      1|}
  204|       |
  205|      1|- (void)reachabilityFlagsChanged:(SCNetworkReachabilityFlags)flags {
  206|      1|  GULReachabilityStatus status = [self statusForFlags:flags];
  207|      1|  if (reachabilityStatus_ != status) {
  208|      1|    NSString *reachabilityStatusString;
  209|      1|    if (status == kGULReachabilityUnknown) {
  210|      0|      reachabilityStatusString = kGULReachabilityUnknownStatus;
  211|      1|    } else {
  212|      1|      reachabilityStatusString = (status == kGULReachabilityNotReachable)
  213|      1|                                     ? kGULReachabilityDisconnectedStatus
  214|      1|                                     : kGULReachabilityConnectedStatus;
  215|      1|    }
  216|      1|
  217|      1|    GULLogDebug(kGULLoggerReachability, NO,
  218|      1|                [NSString stringWithFormat:@"I-REA%06ld", (long)kGULReachabilityMessageCode004],
  219|      1|                @"Network status has changed. Code:%@, status:%@", @(status),
  220|      1|                reachabilityStatusString);
  221|      1|    reachabilityStatus_ = status;
  222|      1|    [reachabilityDelegate_ reachability:self statusChanged:reachabilityStatus_];
  223|      1|  }
  224|      1|}
  225|       |
  226|       |#endif
  227|       |@end
  228|       |
  229|       |#if !TARGET_OS_WATCH
  230|       |static void ReachabilityCallback(SCNetworkReachabilityRef reachability,
  231|       |                                 SCNetworkReachabilityFlags flags,
  232|      1|                                 void *info) {
  233|      1|  GULReachabilityChecker *checker = (__bridge GULReachabilityChecker *)info;
  234|      1|  [checker reachabilityFlagsChanged:flags];
  235|      1|}
  236|       |#endif
  237|       |
  238|       |// This function used to be at the top of the file, but it was moved here
  239|       |// as a workaround for a suspected compiler bug. When compiled in Release mode
  240|       |// and run on an iOS device with WiFi disabled, the reachability code crashed
  241|       |// when calling SCNetworkReachabilityScheduleWithRunLoop, or shortly thereafter.
  242|       |// After unsuccessfully trying to diagnose the cause of the crash, it was
  243|       |// discovered that moving this function to the end of the file magically fixed
  244|       |// the crash. If you are going to edit this file, exercise caution and make sure
  245|       |// to test thoroughly with an iOS device under various network conditions.
  246|      0|const NSString *GULReachabilityStatusString(GULReachabilityStatus status) {
  247|      0|  switch (status) {
  248|      0|    case kGULReachabilityUnknown:
  249|      0|      return @"Reachability Unknown";
  250|      0|
  251|      0|    case kGULReachabilityNotReachable:
  252|      0|      return @"Not reachable";
  253|      0|
  254|      0|    case kGULReachabilityViaWifi:
  255|      0|      return @"Reachable via Wifi";
  256|      0|
  257|      0|    case kGULReachabilityViaCellular:
  258|      0|      return @"Reachable via Cellular Data";
  259|      0|
  260|      0|    default:
  261|      0|      return [NSString stringWithFormat:@"Invalid reachability status %d", (int)status];
  262|      0|  }
  263|      0|}

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/SceneDelegateSwizzler/GULSceneDelegateSwizzler.m:
    1|       |// Copyright 2019 Google LLC
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "TargetConditionals.h"
   16|       |
   17|       |#import <GoogleUtilities/GULAppDelegateSwizzler.h>
   18|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |#import <GoogleUtilities/GULMutableDictionary.h>
   21|       |#import <GoogleUtilities/GULSceneDelegateSwizzler.h>
   22|       |#import "GoogleUtilities/Common/GULLoggerCodes.h"
   23|       |#import "GoogleUtilities/SceneDelegateSwizzler/Internal/GULSceneDelegateSwizzler_Private.h"
   24|       |
   25|       |#import <objc/runtime.h>
   26|       |
   27|       |#if UISCENE_SUPPORTED
   28|       |API_AVAILABLE(ios(13.0), tvos(13.0))
   29|       |typedef void (*GULOpenURLContextsIMP)(id, SEL, UIScene *, NSSet<UIOpenURLContext *> *);
   30|       |
   31|       |API_AVAILABLE(ios(13.0), tvos(13.0))
   32|       |typedef void (^GULSceneDelegateInterceptorCallback)(id<UISceneDelegate>);
   33|       |
   34|       |// The strings below are the keys for associated objects.
   35|       |static char const *const kGULRealIMPBySelectorKey = "GUL_realIMPBySelector";
   36|       |static char const *const kGULRealClassKey = "GUL_realClass";
   37|       |#endif  // UISCENE_SUPPORTED
   38|       |
   39|       |static GULLoggerService kGULLoggerSwizzler = @"[GoogleUtilities/SceneDelegateSwizzler]";
   40|       |
   41|       |// Since Firebase SDKs also use this for app delegate proxying, in order to not be a breaking change
   42|       |// we disable App Delegate proxying when either of these two flags are set to NO.
   43|       |
   44|       |/** Plist key that allows Firebase developers to disable App and Scene Delegate Proxying. */
   45|       |static NSString *const kGULFirebaseSceneDelegateProxyEnabledPlistKey =
   46|       |    @"FirebaseAppDelegateProxyEnabled";
   47|       |
   48|       |/** Plist key that allows developers not using Firebase to disable App and Scene Delegate Proxying.
   49|       | */
   50|       |static NSString *const kGULGoogleUtilitiesSceneDelegateProxyEnabledPlistKey =
   51|       |    @"GoogleUtilitiesAppDelegateProxyEnabled";
   52|       |
   53|       |/** The prefix of the Scene Delegate. */
   54|       |static NSString *const kGULSceneDelegatePrefix = @"GUL_";
   55|       |
   56|       |/**
   57|       | * This class is necessary to store the delegates in an NSArray without retaining them.
   58|       | * [NSValue valueWithNonRetainedObject] also provides this functionality, but does not provide a
   59|       | * zeroing pointer. This will cause EXC_BAD_ACCESS when trying to access the object after it is
   60|       | * dealloced. Instead, this container stores a weak, zeroing reference to the object, which
   61|       | * automatically is set to nil by the runtime when the object is dealloced.
   62|       | */
   63|       |@interface GULSceneZeroingWeakContainer : NSObject
   64|       |
   65|       |/** Stores a weak object. */
   66|       |@property(nonatomic, weak) id object;
   67|       |
   68|       |@end
   69|       |
   70|       |@implementation GULSceneZeroingWeakContainer
   71|       |@end
   72|       |
   73|       |@implementation GULSceneDelegateSwizzler
   74|       |
   75|       |#pragma mark - Public methods
   76|       |
   77|      1|+ (BOOL)isSceneDelegateProxyEnabled {
   78|      1|  return [GULAppDelegateSwizzler isAppDelegateProxyEnabled];
   79|      1|}
   80|       |
   81|      1|+ (void)proxyOriginalSceneDelegate {
   82|      1|#if UISCENE_SUPPORTED
   83|      1|  if ([GULAppEnvironmentUtil isAppExtension]) {
   84|      0|    return;
   85|      0|  }
   86|      1|
   87|      1|  static dispatch_once_t onceToken;
   88|      1|  dispatch_once(&onceToken, ^{
   89|      1|    if (@available(iOS 13.0, tvOS 13.0, *)) {
   90|      1|      if (![GULSceneDelegateSwizzler isSceneDelegateProxyEnabled]) {
   91|      0|        return;
   92|      0|      }
   93|      1|      [[NSNotificationCenter defaultCenter]
   94|      1|          addObserver:self
   95|      1|             selector:@selector(handleSceneWillConnectToNotification:)
   96|      1|                 name:UISceneWillConnectNotification
   97|      1|               object:nil];
   98|      1|    }
   99|      1|  });
  100|      1|#endif  // UISCENE_SUPPORTED
  101|      1|}
  102|       |
  103|       |#if UISCENE_SUPPORTED
  104|      1|+ (GULSceneDelegateInterceptorID)registerSceneDelegateInterceptor:(id<UISceneDelegate>)interceptor {
  105|      1|  NSAssert(interceptor, @"SceneDelegateProxy cannot add nil interceptor");
  106|      1|  NSAssert([interceptor conformsToProtocol:@protocol(UISceneDelegate)],
  107|      1|           @"SceneDelegateProxy interceptor does not conform to UIApplicationDelegate");
  108|      1|
  109|      1|  if (!interceptor) {
  110|      0|    GULLogError(kGULLoggerSwizzler, NO,
  111|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  112|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling000],
  113|      0|                @"SceneDelegateProxy cannot add nil interceptor.");
  114|      0|    return nil;
  115|      0|  }
  116|      1|  if (![interceptor conformsToProtocol:@protocol(UISceneDelegate)]) {
  117|      0|    GULLogError(kGULLoggerSwizzler, NO,
  118|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  119|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling001],
  120|      0|                @"SceneDelegateProxy interceptor does not conform to UIApplicationDelegate");
  121|      0|    return nil;
  122|      0|  }
  123|      1|
  124|      1|  // The ID should be the same given the same interceptor object.
  125|      1|  NSString *interceptorID =
  126|      1|      [NSString stringWithFormat:@"%@%p", kGULSceneDelegatePrefix, interceptor];
  127|      1|  if (!interceptorID.length) {
  128|      0|    GULLogError(kGULLoggerSwizzler, NO,
  129|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  130|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling002],
  131|      0|                @"SceneDelegateProxy cannot create Interceptor ID.");
  132|      0|    return nil;
  133|      0|  }
  134|      1|  GULSceneZeroingWeakContainer *weakObject = [[GULSceneZeroingWeakContainer alloc] init];
  135|      1|  weakObject.object = interceptor;
  136|      1|  [GULSceneDelegateSwizzler interceptors][interceptorID] = weakObject;
  137|      1|  return interceptorID;
  138|      1|}
  139|       |
  140|      0|+ (void)unregisterSceneDelegateInterceptorWithID:(GULSceneDelegateInterceptorID)interceptorID {
  141|      0|  NSAssert(interceptorID, @"SceneDelegateProxy cannot unregister nil interceptor ID.");
  142|      0|  NSAssert(((NSString *)interceptorID).length != 0,
  143|      0|           @"SceneDelegateProxy cannot unregister empty interceptor ID.");
  144|      0|
  145|      0|  if (!interceptorID) {
  146|      0|    GULLogError(kGULLoggerSwizzler, NO,
  147|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  148|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling003],
  149|      0|                @"SceneDelegateProxy cannot unregister empty interceptor ID.");
  150|      0|    return;
  151|      0|  }
  152|      0|
  153|      0|  GULSceneZeroingWeakContainer *weakContainer =
  154|      0|      [GULSceneDelegateSwizzler interceptors][interceptorID];
  155|      0|  if (!weakContainer.object) {
  156|      0|    GULLogError(kGULLoggerSwizzler, NO,
  157|      0|                [NSString stringWithFormat:@"I-SWZ%06ld",
  158|      0|                                           (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling004],
  159|      0|                @"SceneDelegateProxy cannot unregister interceptor that was not registered. "
  160|      0|                 "Interceptor ID %@",
  161|      0|                interceptorID);
  162|      0|    return;
  163|      0|  }
  164|      0|
  165|      0|  [[GULSceneDelegateSwizzler interceptors] removeObjectForKey:interceptorID];
  166|      0|}
  167|       |
  168|       |#pragma mark - Helper methods
  169|       |
  170|      1|+ (GULMutableDictionary *)interceptors {
  171|      1|  static dispatch_once_t onceToken;
  172|      1|  static GULMutableDictionary *sInterceptors;
  173|      1|  dispatch_once(&onceToken, ^{
  174|      1|    sInterceptors = [[GULMutableDictionary alloc] init];
  175|      1|  });
  176|      1|  return sInterceptors;
  177|      1|}
  178|       |
  179|      0|+ (void)clearInterceptors {
  180|      0|  [[self interceptors] removeAllObjects];
  181|      0|}
  182|       |
  183|      0|+ (nullable NSValue *)originalImplementationForSelector:(SEL)selector object:(id)object {
  184|      0|  NSDictionary *realImplementationBySelector =
  185|      0|      objc_getAssociatedObject(object, &kGULRealIMPBySelectorKey);
  186|      0|  return realImplementationBySelector[NSStringFromSelector(selector)];
  187|      0|}
  188|       |
  189|       |+ (void)proxyDestinationSelector:(SEL)destinationSelector
  190|       |    implementationsFromSourceSelector:(SEL)sourceSelector
  191|       |                            fromClass:(Class)sourceClass
  192|       |                              toClass:(Class)destinationClass
  193|       |                            realClass:(Class)realClass
  194|       |     storeDestinationImplementationTo:
  195|      1|         (NSMutableDictionary<NSString *, NSValue *> *)destinationImplementationsBySelector {
  196|      1|  [self addInstanceMethodWithDestinationSelector:destinationSelector
  197|      1|            withImplementationFromSourceSelector:sourceSelector
  198|      1|                                       fromClass:sourceClass
  199|      1|                                         toClass:destinationClass];
  200|      1|  IMP sourceImplementation =
  201|      1|      [GULSceneDelegateSwizzler implementationOfMethodSelector:destinationSelector
  202|      1|                                                     fromClass:realClass];
  203|      1|  NSValue *sourceImplementationPointer = [NSValue valueWithPointer:sourceImplementation];
  204|      1|
  205|      1|  NSString *destinationSelectorString = NSStringFromSelector(destinationSelector);
  206|      1|  destinationImplementationsBySelector[destinationSelectorString] = sourceImplementationPointer;
  207|      1|}
  208|       |
  209|       |/** Copies a method identified by the methodSelector from one class to the other. After this method
  210|       | *  is called, performing [toClassInstance methodSelector] will be similar to calling
  211|       | *  [fromClassInstance methodSelector]. This method does nothing if toClass already has a method
  212|       | *  identified by methodSelector.
  213|       | *
  214|       | *  @param methodSelector The SEL that identifies both the method on the fromClass as well as the
  215|       | *      one on the toClass.
  216|       | *  @param fromClass The class from which a method is sourced.
  217|       | *  @param toClass The class to which the method is added. If the class already has a method with
  218|       | *      the same selector, this has no effect.
  219|       | */
  220|       |+ (void)addInstanceMethodWithSelector:(SEL)methodSelector
  221|       |                            fromClass:(Class)fromClass
  222|      0|                              toClass:(Class)toClass {
  223|      0|  [self addInstanceMethodWithDestinationSelector:methodSelector
  224|      0|            withImplementationFromSourceSelector:methodSelector
  225|      0|                                       fromClass:fromClass
  226|      0|                                         toClass:toClass];
  227|      0|}
  228|       |
  229|       |/** Copies a method identified by the sourceSelector from the fromClass as a method for the
  230|       | *  destinationSelector on the toClass. After this method is called, performing
  231|       | *  [toClassInstance destinationSelector] will be similar to calling
  232|       | *  [fromClassInstance sourceSelector]. This method does nothing if toClass already has a method
  233|       | *  identified by destinationSelector.
  234|       | *
  235|       | *  @param destinationSelector The SEL that identifies the method on the toClass.
  236|       | *  @param sourceSelector The SEL that identifies the method on the fromClass.
  237|       | *  @param fromClass The class from which a method is sourced.
  238|       | *  @param toClass The class to which the method is added. If the class already has a method with
  239|       | *      the same selector, this has no effect.
  240|       | */
  241|       |+ (void)addInstanceMethodWithDestinationSelector:(SEL)destinationSelector
  242|       |            withImplementationFromSourceSelector:(SEL)sourceSelector
  243|       |                                       fromClass:(Class)fromClass
  244|      1|                                         toClass:(Class)toClass {
  245|      1|  Method method = class_getInstanceMethod(fromClass, sourceSelector);
  246|      1|  IMP methodIMP = method_getImplementation(method);
  247|      1|  const char *types = method_getTypeEncoding(method);
  248|      1|  if (!class_addMethod(toClass, destinationSelector, methodIMP, types)) {
  249|      0|    GULLogWarning(
  250|      0|        kGULLoggerSwizzler, NO,
  251|      0|        [NSString
  252|      0|            stringWithFormat:@"I-SWZ%06ld", (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling009],
  253|      0|        @"Cannot copy method to destination selector %@ as it already exists",
  254|      0|        NSStringFromSelector(destinationSelector));
  255|      0|  }
  256|      1|}
  257|       |
  258|       |/** Gets the IMP of the instance method on the class identified by the selector.
  259|       | *
  260|       | *  @param selector The selector of which the IMP is to be fetched.
  261|       | *  @param aClass The class from which the IMP is to be fetched.
  262|       | *  @return The IMP of the instance method identified by selector and aClass.
  263|       | */
  264|      1|+ (IMP)implementationOfMethodSelector:(SEL)selector fromClass:(Class)aClass {
  265|      1|  Method aMethod = class_getInstanceMethod(aClass, selector);
  266|      1|  return method_getImplementation(aMethod);
  267|      1|}
  268|       |
  269|       |/** Enumerates through all the interceptors and if they respond to a given selector, executes a
  270|       | *  GULSceneDelegateInterceptorCallback with the interceptor.
  271|       | *
  272|       | *  @param methodSelector The SEL to check if an interceptor responds to.
  273|       | *  @param callback the GULSceneDelegateInterceptorCallback.
  274|       | */
  275|       |+ (void)notifyInterceptorsWithMethodSelector:(SEL)methodSelector
  276|       |                                    callback:(GULSceneDelegateInterceptorCallback)callback
  277|      0|    API_AVAILABLE(ios(13.0)) {
  278|      0|  if (!callback) {
  279|      0|    return;
  280|      0|  }
  281|      0|
  282|      0|  NSDictionary *interceptors = [GULSceneDelegateSwizzler interceptors].dictionary;
  283|      0|  [interceptors enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
  284|      0|    GULSceneZeroingWeakContainer *interceptorContainer = obj;
  285|      0|    id interceptor = interceptorContainer.object;
  286|      0|    if (!interceptor) {
  287|      0|      GULLogWarning(
  288|      0|          kGULLoggerSwizzler, NO,
  289|      0|          [NSString stringWithFormat:@"I-SWZ%06ld",
  290|      0|                                     (long)kGULSwizzlerMessageCodeSceneDelegateSwizzling010],
  291|      0|          @"SceneDelegateProxy cannot find interceptor with ID %@. Removing the interceptor.", key);
  292|      0|      [[GULSceneDelegateSwizzler interceptors] removeObjectForKey:key];
  293|      0|      return;
  294|      0|    }
  295|      0|    if ([interceptor respondsToSelector:methodSelector]) {
  296|      0|      callback(interceptor);
  297|      0|    }
  298|      0|  }];
  299|      0|}
  300|       |
  301|      1|+ (void)handleSceneWillConnectToNotification:(NSNotification *)notification {
  302|      1|  if (@available(iOS 13.0, tvOS 13.0, *)) {
  303|      1|    if ([notification.object isKindOfClass:[UIScene class]]) {
  304|      1|      UIScene *scene = (UIScene *)notification.object;
  305|      1|      [GULSceneDelegateSwizzler proxySceneDelegateIfNeeded:scene];
  306|      1|    }
  307|      1|  }
  308|      1|}
  309|       |
  310|       |#pragma mark - [Donor Methods] UISceneDelegate URL handler
  311|       |
  312|       |- (void)scene:(UIScene *)scene
  313|      0|    openURLContexts:(NSSet<UIOpenURLContext *> *)URLContexts API_AVAILABLE(ios(13.0), tvos(13.0)) {
  314|      0|  if (@available(iOS 13.0, tvOS 13.0, *)) {
  315|      0|    SEL methodSelector = @selector(scene:openURLContexts:);
  316|      0|    // Call the real implementation if the real Scene Delegate has any.
  317|      0|    NSValue *openURLContextsIMPPointer =
  318|      0|        [GULSceneDelegateSwizzler originalImplementationForSelector:methodSelector object:self];
  319|      0|    GULOpenURLContextsIMP openURLContextsIMP = [openURLContextsIMPPointer pointerValue];
  320|      0|
  321|      0|    [GULSceneDelegateSwizzler
  322|      0|        notifyInterceptorsWithMethodSelector:methodSelector
  323|      0|                                    callback:^(id<UISceneDelegate> interceptor) {
  324|      0|                                      if ([interceptor
  325|      0|                                              conformsToProtocol:@protocol(UISceneDelegate)]) {
  326|      0|                                        id<UISceneDelegate> sceneInterceptor =
  327|      0|                                            (id<UISceneDelegate>)interceptor;
  328|      0|                                        [sceneInterceptor scene:scene openURLContexts:URLContexts];
  329|      0|                                      }
  330|      0|                                    }];
  331|      0|
  332|      0|    if (openURLContextsIMP) {
  333|      0|      openURLContextsIMP(self, methodSelector, scene, URLContexts);
  334|      0|    }
  335|      0|  }
  336|      0|}
  337|       |
  338|      1|+ (void)proxySceneDelegateIfNeeded:(UIScene *)scene {
  339|      1|  Class realClass = [scene.delegate class];
  340|      1|  NSString *className = NSStringFromClass(realClass);
  341|      1|
  342|      1|  // Skip proxying if failed to get the delegate class name for some reason (e.g. `delegate == nil`)
  343|      1|  // or the class has a prefix of kGULAppDelegatePrefix, which means it has been proxied before.
  344|      1|  if (className == nil || [className hasPrefix:kGULSceneDelegatePrefix]) {
  345|      0|    return;
  346|      0|  }
  347|      1|
  348|      1|  NSString *classNameWithPrefix = [kGULSceneDelegatePrefix stringByAppendingString:className];
  349|      1|  NSString *newClassName =
  350|      1|      [NSString stringWithFormat:@"%@-%@", classNameWithPrefix, [NSUUID UUID].UUIDString];
  351|      1|
  352|      1|  if (NSClassFromString(newClassName)) {
  353|      0|    GULLogError(
  354|      0|        kGULLoggerSwizzler, NO,
  355|      0|        [NSString
  356|      0|            stringWithFormat:@"I-SWZ%06ld",
  357|      0|                             (long)
  358|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  359|      0|        @"Cannot create a proxy for Scene Delegate. Subclass already exists. Original Class"
  360|      0|        @": %@, subclass: %@",
  361|      0|        className, newClassName);
  362|      0|    return;
  363|      0|  }
  364|      1|
  365|      1|  // Register the new class as subclass of the real one. Do not allocate more than the real class
  366|      1|  // size.
  367|      1|  Class sceneDelegateSubClass = objc_allocateClassPair(realClass, newClassName.UTF8String, 0);
  368|      1|  if (sceneDelegateSubClass == Nil) {
  369|      0|    GULLogError(
  370|      0|        kGULLoggerSwizzler, NO,
  371|      0|        [NSString
  372|      0|            stringWithFormat:@"I-SWZ%06ld",
  373|      0|                             (long)
  374|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  375|      0|        @"Cannot create a proxy for Scene Delegate. Subclass already exists. Original Class"
  376|      0|        @": %@, subclass: Nil",
  377|      0|        className);
  378|      0|    return;
  379|      0|  }
  380|      1|
  381|      1|  NSMutableDictionary<NSString *, NSValue *> *realImplementationsBySelector =
  382|      1|      [[NSMutableDictionary alloc] init];
  383|      1|
  384|      1|  // For scene:openURLContexts:
  385|      1|  SEL openURLContextsSEL = @selector(scene:openURLContexts:);
  386|      1|  [self proxyDestinationSelector:openURLContextsSEL
  387|      1|      implementationsFromSourceSelector:openURLContextsSEL
  388|      1|                              fromClass:[GULSceneDelegateSwizzler class]
  389|      1|                                toClass:sceneDelegateSubClass
  390|      1|                              realClass:realClass
  391|      1|       storeDestinationImplementationTo:realImplementationsBySelector];
  392|      1|
  393|      1|  // Store original implementations to a fake property of the original delegate.
  394|      1|  objc_setAssociatedObject(scene.delegate, &kGULRealIMPBySelectorKey,
  395|      1|                           [realImplementationsBySelector copy], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  396|      1|  objc_setAssociatedObject(scene.delegate, &kGULRealClassKey, realClass,
  397|      1|                           OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  398|      1|
  399|      1|  // The subclass size has to be exactly the same size with the original class size. The subclass
  400|      1|  // cannot have more ivars/properties than its superclass since it will cause an offset in memory
  401|      1|  // that can lead to overwriting the isa of an object in the next frame.
  402|      1|  if (class_getInstanceSize(realClass) != class_getInstanceSize(sceneDelegateSubClass)) {
  403|      0|    GULLogError(
  404|      0|        kGULLoggerSwizzler, NO,
  405|      0|        [NSString
  406|      0|            stringWithFormat:@"I-SWZ%06ld",
  407|      0|                             (long)
  408|      0|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  409|      0|        @"Cannot create subclass of Scene Delegate, because the created subclass is not the "
  410|      0|        @"same size. %@",
  411|      0|        className);
  412|      0|    NSAssert(NO, @"Classes must be the same size to swizzle isa");
  413|      0|    return;
  414|      0|  }
  415|      1|
  416|      1|  // Make the newly created class to be the subclass of the real Scene Delegate class.
  417|      1|  objc_registerClassPair(sceneDelegateSubClass);
  418|      1|  if (object_setClass(scene.delegate, sceneDelegateSubClass)) {
  419|      1|    GULLogDebug(
  420|      1|        kGULLoggerSwizzler, NO,
  421|      1|        [NSString
  422|      1|            stringWithFormat:@"I-SWZ%06ld",
  423|      1|                             (long)
  424|      1|                                 kGULSwizzlerMessageCodeSceneDelegateSwizzlingInvalidSceneDelegate],
  425|      1|        @"Successfully created Scene Delegate Proxy automatically. To disable the "
  426|      1|        @"proxy, set the flag %@ to NO (Boolean) in the Info.plist",
  427|      1|        [GULSceneDelegateSwizzler correctSceneDelegateProxyKey]);
  428|      1|  }
  429|      1|}
  430|       |
  431|      1|+ (NSString *)correctSceneDelegateProxyKey {
  432|      1|  return NSClassFromString(@"FIRCore") ? kGULFirebaseSceneDelegateProxyEnabledPlistKey
  433|      1|                                       : kGULGoogleUtilitiesSceneDelegateProxyEnabledPlistKey;
  434|      1|}
  435|       |
  436|       |#endif  // UISCENE_SUPPORTED
  437|       |
  438|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GoogleUtilities/GoogleUtilities/UserDefaults/GULUserDefaults.m:
    1|       |// Copyright 2018 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/GULUserDefaults.h"
   16|       |
   17|       |#import <GoogleUtilities/GULLogger.h>
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |static NSTimeInterval const kGULSynchronizeInterval = 1.0;
   22|       |
   23|       |static NSString *const kGULLogFormat = @"I-GUL%06ld";
   24|       |
   25|       |static GULLoggerService kGULLogUserDefaultsService = @"[GoogleUtilities/UserDefaults]";
   26|       |
   27|       |typedef NS_ENUM(NSInteger, GULUDMessageCode) {
   28|       |  GULUDMessageCodeInvalidKeyGet = 1,
   29|       |  GULUDMessageCodeInvalidKeySet = 2,
   30|       |  GULUDMessageCodeInvalidObjectSet = 3,
   31|       |  GULUDMessageCodeSynchronizeFailed = 4,
   32|       |};
   33|       |
   34|       |@interface GULUserDefaults ()
   35|       |
   36|       |/// Equivalent to the suite name for NSUserDefaults.
   37|       |@property(readonly) CFStringRef appNameRef;
   38|       |
   39|       |@property(atomic) BOOL isPreferenceFileExcluded;
   40|       |
   41|       |@end
   42|       |
   43|       |@implementation GULUserDefaults {
   44|       |  // The application name is the same with the suite name of the NSUserDefaults, and it is used for
   45|       |  // preferences.
   46|       |  CFStringRef _appNameRef;
   47|       |}
   48|       |
   49|      0|+ (GULUserDefaults *)standardUserDefaults {
   50|      0|  static GULUserDefaults *standardUserDefaults;
   51|      0|  static dispatch_once_t onceToken;
   52|      0|  dispatch_once(&onceToken, ^{
   53|      0|    standardUserDefaults = [[GULUserDefaults alloc] init];
   54|      0|  });
   55|      0|  return standardUserDefaults;
   56|      0|}
   57|       |
   58|      0|- (instancetype)init {
   59|      0|  return [self initWithSuiteName:nil];
   60|      0|}
   61|       |
   62|      1|- (instancetype)initWithSuiteName:(nullable NSString *)suiteName {
   63|      1|  self = [super init];
   64|      1|
   65|      1|  NSString *name = [suiteName copy];
   66|      1|
   67|      1|  if (self) {
   68|      1|    // `kCFPreferencesCurrentApplication` maps to the same defaults database as
   69|      1|    // `[NSUserDefaults standardUserDefaults]`.
   70|      1|    _appNameRef =
   71|      1|        name.length ? (__bridge_retained CFStringRef)name : kCFPreferencesCurrentApplication;
   72|      1|  }
   73|      1|
   74|      1|  return self;
   75|      1|}
   76|       |
   77|      0|- (void)dealloc {
   78|      0|  // If we're using a custom `_appNameRef` it needs to be released. If it's a constant, it shouldn't
   79|      0|  // need to be released since we don't own it.
   80|      0|  if (CFStringCompare(_appNameRef, kCFPreferencesCurrentApplication, 0) != kCFCompareEqualTo) {
   81|      0|    CFRelease(_appNameRef);
   82|      0|  }
   83|      0|
   84|      0|  [NSObject cancelPreviousPerformRequestsWithTarget:self
   85|      0|                                           selector:@selector(synchronize)
   86|      0|                                             object:nil];
   87|      0|}
   88|       |
   89|      1|- (nullable id)objectForKey:(NSString *)defaultName {
   90|      1|  NSString *key = [defaultName copy];
   91|      1|  if (![key isKindOfClass:[NSString class]] || !key.length) {
   92|      0|    GULLogWarning(@"<GoogleUtilities>", NO,
   93|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidKeyGet],
   94|      0|                  @"Cannot get object for invalid user default key.");
   95|      0|    return nil;
   96|      0|  }
   97|      1|  return (__bridge_transfer id)CFPreferencesCopyAppValue((__bridge CFStringRef)key, _appNameRef);
   98|      1|}
   99|       |
  100|      0|- (void)setObject:(nullable id)value forKey:(NSString *)defaultName {
  101|      0|  NSString *key = [defaultName copy];
  102|      0|  if (![key isKindOfClass:[NSString class]] || !key.length) {
  103|      0|    GULLogWarning(kGULLogUserDefaultsService, NO,
  104|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidKeySet],
  105|      0|                  @"Cannot set object for invalid user default key.");
  106|      0|    return;
  107|      0|  }
  108|      0|  if (!value) {
  109|      0|    CFPreferencesSetAppValue((__bridge CFStringRef)key, NULL, _appNameRef);
  110|      0|    [self scheduleSynchronize];
  111|      0|    return;
  112|      0|  }
  113|      0|  BOOL isAcceptableValue =
  114|      0|      [value isKindOfClass:[NSString class]] || [value isKindOfClass:[NSNumber class]] ||
  115|      0|      [value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]] ||
  116|      0|      [value isKindOfClass:[NSDate class]] || [value isKindOfClass:[NSData class]];
  117|      0|  if (!isAcceptableValue) {
  118|      0|    GULLogWarning(kGULLogUserDefaultsService, NO,
  119|      0|                  [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeInvalidObjectSet],
  120|      0|                  @"Cannot set invalid object to user defaults. Must be a string, number, array, "
  121|      0|                  @"dictionary, date, or data. Value: %@",
  122|      0|                  value);
  123|      0|    return;
  124|      0|  }
  125|      0|
  126|      0|  CFPreferencesSetAppValue((__bridge CFStringRef)key, (__bridge CFStringRef)value, _appNameRef);
  127|      0|  [self scheduleSynchronize];
  128|      0|}
  129|       |
  130|      0|- (void)removeObjectForKey:(NSString *)key {
  131|      0|  [self setObject:nil forKey:key];
  132|      0|}
  133|       |
  134|       |#pragma mark - Getters
  135|       |
  136|      0|- (NSInteger)integerForKey:(NSString *)defaultName {
  137|      0|  NSNumber *object = [self objectForKey:defaultName];
  138|      0|  return object.integerValue;
  139|      0|}
  140|       |
  141|      0|- (float)floatForKey:(NSString *)defaultName {
  142|      0|  NSNumber *object = [self objectForKey:defaultName];
  143|      0|  return object.floatValue;
  144|      0|}
  145|       |
  146|      0|- (double)doubleForKey:(NSString *)defaultName {
  147|      0|  NSNumber *object = [self objectForKey:defaultName];
  148|      0|  return object.doubleValue;
  149|      0|}
  150|       |
  151|      0|- (BOOL)boolForKey:(NSString *)defaultName {
  152|      0|  NSNumber *object = [self objectForKey:defaultName];
  153|      0|  return object.boolValue;
  154|      0|}
  155|       |
  156|      0|- (nullable NSString *)stringForKey:(NSString *)defaultName {
  157|      0|  return [self objectForKey:defaultName];
  158|      0|}
  159|       |
  160|      0|- (nullable NSArray *)arrayForKey:(NSString *)defaultName {
  161|      0|  return [self objectForKey:defaultName];
  162|      0|}
  163|       |
  164|      0|- (nullable NSDictionary<NSString *, id> *)dictionaryForKey:(NSString *)defaultName {
  165|      0|  return [self objectForKey:defaultName];
  166|      0|}
  167|       |
  168|       |#pragma mark - Setters
  169|       |
  170|      0|- (void)setInteger:(NSInteger)integer forKey:(NSString *)defaultName {
  171|      0|  [self setObject:@(integer) forKey:defaultName];
  172|      0|}
  173|       |
  174|      0|- (void)setFloat:(float)value forKey:(NSString *)defaultName {
  175|      0|  [self setObject:@(value) forKey:defaultName];
  176|      0|}
  177|       |
  178|      0|- (void)setDouble:(double)doubleNumber forKey:(NSString *)defaultName {
  179|      0|  [self setObject:@(doubleNumber) forKey:defaultName];
  180|      0|}
  181|       |
  182|      0|- (void)setBool:(BOOL)boolValue forKey:(NSString *)defaultName {
  183|      0|  [self setObject:@(boolValue) forKey:defaultName];
  184|      0|}
  185|       |
  186|       |#pragma mark - Save data
  187|       |
  188|      0|- (void)synchronize {
  189|      0|  if (!CFPreferencesAppSynchronize(_appNameRef)) {
  190|      0|    GULLogError(kGULLogUserDefaultsService, NO,
  191|      0|                [NSString stringWithFormat:kGULLogFormat, (long)GULUDMessageCodeSynchronizeFailed],
  192|      0|                @"Cannot synchronize user defaults to disk");
  193|      0|  }
  194|      0|}
  195|       |
  196|       |#pragma mark - Private methods
  197|       |
  198|      0|- (void)scheduleSynchronize {
  199|      0|  // Synchronize data using a timer so that multiple set... calls can be coalesced under one
  200|      0|  // synchronize.
  201|      0|  [NSObject cancelPreviousPerformRequestsWithTarget:self
  202|      0|                                           selector:@selector(synchronize)
  203|      0|                                             object:nil];
  204|      0|  // This method may be called on multiple queues (due to set... methods can be called on any queue)
  205|      0|  // synchronize can be scheduled on different queues, so make sure that it does not crash. If this
  206|      0|  // instance goes away, self will be released also, no one will retain it and the schedule won't be
  207|      0|  // called.
  208|      0|  [self performSelector:@selector(synchronize) withObject:nil afterDelay:kGULSynchronizeInterval];
  209|      0|}
  210|       |
  211|       |@end
  212|       |
  213|       |NS_ASSUME_NONNULL_END

