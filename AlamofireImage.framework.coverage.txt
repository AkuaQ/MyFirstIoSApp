/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/AlamofireImage/Source/AFIError.swift:
    1|       |//
    2|       |//  AFIError.swift
    3|       |//
    4|       |//  Copyright (c) 2015-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// `AFIError` is the error type returned by AlamofireImage.
   28|       |///
   29|       |/// - requestCancelled:         The request was explicitly cancelled.
   30|       |/// - imageSerializationFailed: Response data could not be serialized into an image.
   31|       |public enum AFIError: Error {
   32|       |    case requestCancelled
   33|       |    case imageSerializationFailed
   34|       |}
   35|       |
   36|       |// MARK: - Error Booleans
   37|       |
   38|       |extension AFIError {
   39|       |    /// Returns `true` if the `AFIError` is a request cancellation error, `false` otherwise.
   40|      0|    public var isRequestCancelledError: Bool {
   41|      0|        if case .requestCancelled = self { return true }
   42|      0|        return false
   43|      0|    }
   44|       |
   45|       |    /// Returns `true` if the `AFIError` is an image serialization error, `false` otherwise.
   46|      0|    public var isImageSerializationFailedError: Bool {
   47|      0|        if case .imageSerializationFailed = self { return true }
   48|      0|        return false
   49|      0|    }
   50|       |}
   51|       |
   52|       |// MARK: - Error Descriptions
   53|       |
   54|       |extension AFIError: LocalizedError {
   55|      0|    public var errorDescription: String? {
   56|      0|        switch self {
   57|      0|        case .requestCancelled:
   58|      0|            return "The request was explicitly cancelled."
   59|      0|        case .imageSerializationFailed:
   60|      0|            return "Response data could not be serialized into an image."
   61|      0|        }
   62|      0|    }
   63|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/AlamofireImage/Source/ImageCache.swift:
    1|       |//
    2|       |//  ImageCache.swift
    3|       |//
    4|       |//  Copyright (c) 2015-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Alamofire
   26|       |import Foundation
   27|       |
   28|       |#if os(iOS) || os(tvOS) || os(watchOS)
   29|       |import UIKit
   30|       |#elseif os(macOS)
   31|       |import Cocoa
   32|       |#endif
   33|       |
   34|       |// MARK: ImageCache
   35|       |
   36|       |/// The `ImageCache` protocol defines a set of APIs for adding, removing and fetching images from a cache.
   37|       |public protocol ImageCache {
   38|       |    /// Adds the image to the cache with the given identifier.
   39|       |    func add(_ image: Image, withIdentifier identifier: String)
   40|       |
   41|       |    /// Removes the image from the cache matching the given identifier.
   42|       |    func removeImage(withIdentifier identifier: String) -> Bool
   43|       |
   44|       |    /// Removes all images stored in the cache.
   45|       |    @discardableResult
   46|       |    func removeAllImages() -> Bool
   47|       |
   48|       |    /// Returns the image in the cache associated with the given identifier.
   49|       |    func image(withIdentifier identifier: String) -> Image?
   50|       |}
   51|       |
   52|       |/// The `ImageRequestCache` protocol extends the `ImageCache` protocol by adding methods for adding, removing and
   53|       |/// fetching images from a cache given an `URLRequest` and additional identifier.
   54|       |public protocol ImageRequestCache: ImageCache {
   55|       |    /// Adds the image to the cache using an identifier created from the request and identifier.
   56|       |    func add(_ image: Image, for request: URLRequest, withIdentifier identifier: String?)
   57|       |
   58|       |    /// Removes the image from the cache using an identifier created from the request and identifier.
   59|       |    func removeImage(for request: URLRequest, withIdentifier identifier: String?) -> Bool
   60|       |
   61|       |    /// Returns the image from the cache associated with an identifier created from the request and identifier.
   62|       |    func image(for request: URLRequest, withIdentifier identifier: String?) -> Image?
   63|       |}
   64|       |
   65|       |// MARK: -
   66|       |
   67|       |/// The `AutoPurgingImageCache` in an in-memory image cache used to store images up to a given memory capacity. When
   68|       |/// the memory capacity is reached, the image cache is sorted by last access date, then the oldest image is continuously
   69|       |/// purged until the preferred memory usage after purge is met. Each time an image is accessed through the cache, the
   70|       |/// internal access date of the image is updated.
   71|       |open class AutoPurgingImageCache: ImageRequestCache {
   72|       |    class CachedImage {
   73|       |        let image: Image
   74|       |        let identifier: String
   75|       |        let totalBytes: UInt64
   76|       |        var lastAccessDate: Date
   77|       |
   78|      0|        init(_ image: Image, identifier: String) {
   79|      0|            self.image = image
   80|      0|            self.identifier = identifier
   81|      0|            self.lastAccessDate = Date()
   82|      0|
   83|      0|            self.totalBytes = {
   84|      0|                #if os(iOS) || os(tvOS) || os(watchOS)
   85|      0|                    let size = CGSize(width: image.size.width * image.scale, height: image.size.height * image.scale)
   86|      0|                #elseif os(macOS)
   87|      0|                    let size = CGSize(width: image.size.width, height: image.size.height)
   88|      0|                #endif
   89|      0|
   90|      0|                let bytesPerPixel: CGFloat = 4.0
   91|      0|                let bytesPerRow = size.width * bytesPerPixel
   92|      0|                let totalBytes = UInt64(bytesPerRow) * UInt64(size.height)
   93|      0|
   94|      0|                return totalBytes
   95|      0|            }()
   96|      0|        }
   97|       |
   98|      0|        func accessImage() -> Image {
   99|      0|            lastAccessDate = Date()
  100|      0|            return image
  101|      0|        }
  102|       |    }
  103|       |
  104|       |    // MARK: Properties
  105|       |
  106|       |    /// The current total memory usage in bytes of all images stored within the cache.
  107|      0|    open var memoryUsage: UInt64 {
  108|      0|        var memoryUsage: UInt64 = 0
  109|      0|        synchronizationQueue.sync { memoryUsage = self.currentMemoryUsage }
  110|      0|
  111|      0|        return memoryUsage
  112|      0|    }
  113|       |
  114|       |    /// The total memory capacity of the cache in bytes.
  115|       |    public let memoryCapacity: UInt64
  116|       |
  117|       |    /// The preferred memory usage after purge in bytes. During a purge, images will be purged until the memory
  118|       |    /// capacity drops below this limit.
  119|       |    public let preferredMemoryUsageAfterPurge: UInt64
  120|       |
  121|       |    private let synchronizationQueue: DispatchQueue
  122|       |    private var cachedImages: [String: CachedImage]
  123|       |    private var currentMemoryUsage: UInt64
  124|       |
  125|       |    // MARK: Initialization
  126|       |
  127|       |    /// Initialies the `AutoPurgingImageCache` instance with the given memory capacity and preferred memory usage
  128|       |    /// after purge limit.
  129|       |    ///
  130|       |    /// Please note, the memory capacity must always be greater than or equal to the preferred memory usage after purge.
  131|       |    ///
  132|       |    /// - parameter memoryCapacity:                 The total memory capacity of the cache in bytes. `100 MB` by default.
  133|       |    /// - parameter preferredMemoryUsageAfterPurge: The preferred memory usage after purge in bytes. `60 MB` by default.
  134|       |    ///
  135|       |    /// - returns: The new `AutoPurgingImageCache` instance.
  136|      0|    public init(memoryCapacity: UInt64 = 100_000_000, preferredMemoryUsageAfterPurge: UInt64 = 60_000_000) {
  137|      0|        self.memoryCapacity = memoryCapacity
  138|      0|        self.preferredMemoryUsageAfterPurge = preferredMemoryUsageAfterPurge
  139|      0|
  140|      0|        precondition(
  141|      0|            memoryCapacity >= preferredMemoryUsageAfterPurge,
  142|      0|            "The `memoryCapacity` must be greater than or equal to `preferredMemoryUsageAfterPurge`"
  143|      0|        )
  144|      0|
  145|      0|        self.cachedImages = [:]
  146|      0|        self.currentMemoryUsage = 0
  147|      0|
  148|      0|        self.synchronizationQueue = {
  149|      0|            let name = String(format: "org.alamofire.autopurgingimagecache-%08x%08x", arc4random(), arc4random())
  150|      0|            return DispatchQueue(label: name, attributes: .concurrent)
  151|      0|        }()
  152|      0|
  153|      0|        #if os(iOS) || os(tvOS)
  154|      0|        #if swift(>=4.2)
  155|      0|        let notification = UIApplication.didReceiveMemoryWarningNotification
  156|      0|        #else
  157|      0|        let notification = Notification.Name.UIApplicationDidReceiveMemoryWarning
  158|      0|        #endif
  159|      0|        NotificationCenter.default.addObserver(
  160|      0|            self,
  161|      0|            selector: #selector(AutoPurgingImageCache.removeAllImages),
  162|      0|            name: notification,
  163|      0|            object: nil
  164|      0|        )
  165|      0|        #endif
  166|      0|    }
  167|       |
  168|      0|    deinit {
  169|      0|        NotificationCenter.default.removeObserver(self)
  170|      0|    }
  171|       |
  172|       |    // MARK: Add Image to Cache
  173|       |
  174|       |    /// Adds the image to the cache using an identifier created from the request and optional identifier.
  175|       |    ///
  176|       |    /// - parameter image:      The image to add to the cache.
  177|       |    /// - parameter request:    The request used to generate the image's unique identifier.
  178|       |    /// - parameter identifier: The additional identifier to append to the image's unique identifier.
  179|      0|    open func add(_ image: Image, for request: URLRequest, withIdentifier identifier: String? = nil) {
  180|      0|        let requestIdentifier = imageCacheKey(for: request, withIdentifier: identifier)
  181|      0|        add(image, withIdentifier: requestIdentifier)
  182|      0|    }
  183|       |
  184|       |    /// Adds the image to the cache with the given identifier.
  185|       |    ///
  186|       |    /// - parameter image:      The image to add to the cache.
  187|       |    /// - parameter identifier: The identifier to use to uniquely identify the image.
  188|      0|    open func add(_ image: Image, withIdentifier identifier: String) {
  189|      0|        synchronizationQueue.async(flags: [.barrier]) {
  190|      0|            let cachedImage = CachedImage(image, identifier: identifier)
  191|      0|
  192|      0|            if let previousCachedImage = self.cachedImages[identifier] {
  193|      0|                self.currentMemoryUsage -= previousCachedImage.totalBytes
  194|      0|            }
  195|      0|
  196|      0|            self.cachedImages[identifier] = cachedImage
  197|      0|            self.currentMemoryUsage += cachedImage.totalBytes
  198|      0|        }
  199|      0|
  200|      0|        synchronizationQueue.async(flags: [.barrier]) {
  201|      0|            if self.currentMemoryUsage > self.memoryCapacity {
  202|      0|                let bytesToPurge = self.currentMemoryUsage - self.preferredMemoryUsageAfterPurge
  203|      0|
  204|      0|                var sortedImages = self.cachedImages.map { $1 }
  205|      0|
  206|      0|                sortedImages.sort {
  207|      0|                    let date1 = $0.lastAccessDate
  208|      0|                    let date2 = $1.lastAccessDate
  209|      0|
  210|      0|                    return date1.timeIntervalSince(date2) < 0.0
  211|      0|                }
  212|      0|
  213|      0|                var bytesPurged = UInt64(0)
  214|      0|
  215|      0|                for cachedImage in sortedImages {
  216|      0|                    self.cachedImages.removeValue(forKey: cachedImage.identifier)
  217|      0|                    bytesPurged += cachedImage.totalBytes
  218|      0|
  219|      0|                    if bytesPurged >= bytesToPurge {
  220|      0|                        break
  221|      0|                    }
  222|      0|                }
  223|      0|
  224|      0|                self.currentMemoryUsage -= bytesPurged
  225|      0|            }
  226|      0|        }
  227|      0|    }
  228|       |
  229|       |    // MARK: Remove Image from Cache
  230|       |
  231|       |    /// Removes the image from the cache using an identifier created from the request and optional identifier.
  232|       |    ///
  233|       |    /// - parameter request:    The request used to generate the image's unique identifier.
  234|       |    /// - parameter identifier: The additional identifier to append to the image's unique identifier.
  235|       |    ///
  236|       |    /// - returns: `true` if the image was removed, `false` otherwise.
  237|       |    @discardableResult
  238|      0|    open func removeImage(for request: URLRequest, withIdentifier identifier: String?) -> Bool {
  239|      0|        let requestIdentifier = imageCacheKey(for: request, withIdentifier: identifier)
  240|      0|        return removeImage(withIdentifier: requestIdentifier)
  241|      0|    }
  242|       |
  243|       |    /// Removes all images from the cache created from the request.
  244|       |    ///
  245|       |    /// - parameter request: The request used to generate the image's unique identifier.
  246|       |    ///
  247|       |    /// - returns: `true` if any images were removed, `false` otherwise.
  248|       |    @discardableResult
  249|      0|    open func removeImages(matching request: URLRequest) -> Bool {
  250|      0|        let requestIdentifier = imageCacheKey(for: request, withIdentifier: nil)
  251|      0|        var removed = false
  252|      0|
  253|      0|        synchronizationQueue.sync {
  254|      0|            for key in self.cachedImages.keys where key.hasPrefix(requestIdentifier) {
  255|      0|                if let cachedImage = self.cachedImages.removeValue(forKey: key) {
  256|      0|                    self.currentMemoryUsage -= cachedImage.totalBytes
  257|      0|                    removed = true
  258|      0|                }
  259|      0|            }
  260|      0|        }
  261|      0|
  262|      0|        return removed
  263|      0|    }
  264|       |
  265|       |    /// Removes the image from the cache matching the given identifier.
  266|       |    ///
  267|       |    /// - parameter identifier: The unique identifier for the image.
  268|       |    ///
  269|       |    /// - returns: `true` if the image was removed, `false` otherwise.
  270|       |    @discardableResult
  271|      0|    open func removeImage(withIdentifier identifier: String) -> Bool {
  272|      0|        var removed = false
  273|      0|
  274|      0|        synchronizationQueue.sync {
  275|      0|            if let cachedImage = self.cachedImages.removeValue(forKey: identifier) {
  276|      0|                self.currentMemoryUsage -= cachedImage.totalBytes
  277|      0|                removed = true
  278|      0|            }
  279|      0|        }
  280|      0|
  281|      0|        return removed
  282|      0|    }
  283|       |
  284|       |    /// Removes all images stored in the cache.
  285|       |    ///
  286|       |    /// - returns: `true` if images were removed from the cache, `false` otherwise.
  287|       |    @discardableResult @objc
  288|      0|    open func removeAllImages() -> Bool {
  289|      0|        var removed = false
  290|      0|
  291|      0|        synchronizationQueue.sync {
  292|      0|            if !self.cachedImages.isEmpty {
  293|      0|                self.cachedImages.removeAll()
  294|      0|                self.currentMemoryUsage = 0
  295|      0|
  296|      0|                removed = true
  297|      0|            }
  298|      0|        }
  299|      0|
  300|      0|        return removed
  301|      0|    }
  302|       |
  303|       |    // MARK: Fetch Image from Cache
  304|       |
  305|       |    /// Returns the image from the cache associated with an identifier created from the request and optional identifier.
  306|       |    ///
  307|       |    /// - parameter request:    The request used to generate the image's unique identifier.
  308|       |    /// - parameter identifier: The additional identifier to append to the image's unique identifier.
  309|       |    ///
  310|       |    /// - returns: The image if it is stored in the cache, `nil` otherwise.
  311|      0|    open func image(for request: URLRequest, withIdentifier identifier: String? = nil) -> Image? {
  312|      0|        let requestIdentifier = imageCacheKey(for: request, withIdentifier: identifier)
  313|      0|        return image(withIdentifier: requestIdentifier)
  314|      0|    }
  315|       |
  316|       |    /// Returns the image in the cache associated with the given identifier.
  317|       |    ///
  318|       |    /// - parameter identifier: The unique identifier for the image.
  319|       |    ///
  320|       |    /// - returns: The image if it is stored in the cache, `nil` otherwise.
  321|      0|    open func image(withIdentifier identifier: String) -> Image? {
  322|      0|        var image: Image?
  323|      0|
  324|      0|        synchronizationQueue.sync {
  325|      0|            if let cachedImage = self.cachedImages[identifier] {
  326|      0|                image = cachedImage.accessImage()
  327|      0|            }
  328|      0|        }
  329|      0|
  330|      0|        return image
  331|      0|    }
  332|       |
  333|       |    // MARK: Image Cache Keys
  334|       |
  335|       |    /// Returns the unique image cache key for the specified request and additional identifier.
  336|       |    ///
  337|       |    /// - parameter request:    The request.
  338|       |    /// - parameter identifier: The additional identifier.
  339|       |    ///
  340|       |    /// - returns: The unique image cache key.
  341|      0|    open func imageCacheKey(for request: URLRequest, withIdentifier identifier: String?) -> String {
  342|      0|        var key = request.url?.absoluteString ?? ""
  343|      0|
  344|      0|        if let identifier = identifier {
  345|      0|            key += "-\(identifier)"
  346|      0|        }
  347|      0|
  348|      0|        return key
  349|      0|    }
  350|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/AlamofireImage/Source/ImageDownloader.swift:
    1|       |//
    2|       |//  ImageDownloader.swift
    3|       |//
    4|       |//  Copyright (c) 2015-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Alamofire
   26|       |import Foundation
   27|       |
   28|       |#if os(iOS) || os(tvOS) || os(watchOS)
   29|       |import UIKit
   30|       |#elseif os(macOS)
   31|       |import Cocoa
   32|       |#endif
   33|       |
   34|       |/// The `RequestReceipt` is an object vended by the `ImageDownloader` when starting a download request. It can be used
   35|       |/// to cancel active requests running on the `ImageDownloader` session. As a general rule, image download requests
   36|       |/// should be cancelled using the `RequestReceipt` instead of calling `cancel` directly on the `request` itself. The
   37|       |/// `ImageDownloader` is optimized to handle duplicate request scenarios as well as pending versus active downloads.
   38|       |open class RequestReceipt {
   39|       |    /// The download request created by the `ImageDownloader`.
   40|       |    public let request: Request
   41|       |
   42|       |    /// The unique identifier for the image filters and completion handlers when duplicate requests are made.
   43|       |    public let receiptID: String
   44|       |
   45|      0|    init(request: Request, receiptID: String) {
   46|      0|        self.request = request
   47|      0|        self.receiptID = receiptID
   48|      0|    }
   49|       |}
   50|       |
   51|       |// MARK: -
   52|       |
   53|       |/// The `ImageDownloader` class is responsible for downloading images in parallel on a prioritized queue. Incoming
   54|       |/// downloads are added to the front or back of the queue depending on the download prioritization. Each downloaded
   55|       |/// image is cached in the underlying `NSURLCache` as well as the in-memory image cache that supports image filters.
   56|       |/// By default, any download request with a cached image equivalent in the image cache will automatically be served the
   57|       |/// cached image representation. Additional advanced features include supporting multiple image filters and completion
   58|       |/// handlers for a single request.
   59|       |open class ImageDownloader {
   60|       |    /// The completion handler closure used when an image download completes.
   61|       |    public typealias CompletionHandler = (DataResponse<Image>) -> Void
   62|       |
   63|       |    /// The progress handler closure called periodically during an image download.
   64|       |    public typealias ProgressHandler = DataRequest.ProgressHandler
   65|       |
   66|       |    // MARK: Helper Types
   67|       |
   68|       |    /// Defines the order prioritization of incoming download requests being inserted into the queue.
   69|       |    ///
   70|       |    /// - fifo: All incoming downloads are added to the back of the queue.
   71|       |    /// - lifo: All incoming downloads are added to the front of the queue.
   72|       |    public enum DownloadPrioritization {
   73|       |        case fifo, lifo
   74|       |    }
   75|       |
   76|       |    class ResponseHandler {
   77|       |        let urlID: String
   78|       |        let handlerID: String
   79|       |        let request: DataRequest
   80|       |        var operations: [(receiptID: String, filter: ImageFilter?, completion: CompletionHandler?)]
   81|       |
   82|       |        init(
   83|       |            request: DataRequest,
   84|       |            handlerID: String,
   85|       |            receiptID: String,
   86|       |            filter: ImageFilter?,
   87|       |            completion: CompletionHandler?)
   88|      0|        {
   89|      0|            self.request = request
   90|      0|            self.urlID = ImageDownloader.urlIdentifier(for: request.request!)
   91|      0|            self.handlerID = handlerID
   92|      0|            self.operations = [(receiptID: receiptID, filter: filter, completion: completion)]
   93|      0|        }
   94|       |    }
   95|       |
   96|       |    // MARK: Properties
   97|       |
   98|       |    /// The image cache used to store all downloaded images in.
   99|       |    public let imageCache: ImageRequestCache?
  100|       |
  101|       |    /// The credential used for authenticating each download request.
  102|       |    open private(set) var credential: URLCredential?
  103|       |
  104|       |    /// Response serializer used to convert the image data to UIImage.
  105|       |    public var imageResponseSerializer = DataRequest.imageResponseSerializer()
  106|       |
  107|       |    /// The underlying Alamofire `Manager` instance used to handle all download requests.
  108|       |    public let sessionManager: SessionManager
  109|       |
  110|       |    let downloadPrioritization: DownloadPrioritization
  111|       |    let maximumActiveDownloads: Int
  112|       |
  113|       |    var activeRequestCount = 0
  114|       |    var queuedRequests: [Request] = []
  115|       |    var responseHandlers: [String: ResponseHandler] = [:]
  116|       |
  117|      0|    private let synchronizationQueue: DispatchQueue = {
  118|      0|        let name = String(format: "org.alamofire.imagedownloader.synchronizationqueue-%08x%08x", arc4random(), arc4random())
  119|      0|        return DispatchQueue(label: name)
  120|      0|    }()
  121|       |
  122|      0|    private let responseQueue: DispatchQueue = {
  123|      0|        let name = String(format: "org.alamofire.imagedownloader.responsequeue-%08x%08x", arc4random(), arc4random())
  124|      0|        return DispatchQueue(label: name, attributes: .concurrent)
  125|      0|    }()
  126|       |
  127|       |    // MARK: Initialization
  128|       |
  129|       |    /// The default instance of `ImageDownloader` initialized with default values.
  130|       |    public static let `default` = ImageDownloader()
  131|       |
  132|       |    /// Creates a default `URLSessionConfiguration` with common usage parameter values.
  133|       |    ///
  134|       |    /// - returns: The default `URLSessionConfiguration` instance.
  135|      0|    open class func defaultURLSessionConfiguration() -> URLSessionConfiguration {
  136|      0|        let configuration = URLSessionConfiguration.default
  137|      0|
  138|      0|        configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
  139|      0|        configuration.httpShouldSetCookies = true
  140|      0|        configuration.httpShouldUsePipelining = false
  141|      0|
  142|      0|        configuration.requestCachePolicy = .useProtocolCachePolicy
  143|      0|        configuration.allowsCellularAccess = true
  144|      0|        configuration.timeoutIntervalForRequest = 60
  145|      0|
  146|      0|        configuration.urlCache = ImageDownloader.defaultURLCache()
  147|      0|
  148|      0|        return configuration
  149|      0|    }
  150|       |
  151|       |    /// Creates a default `URLCache` with common usage parameter values.
  152|       |    ///
  153|       |    /// - returns: The default `URLCache` instance.
  154|      0|    open class func defaultURLCache() -> URLCache {
  155|      0|        return URLCache(
  156|      0|            memoryCapacity: 20 * 1024 * 1024, // 20 MB
  157|      0|            diskCapacity: 150 * 1024 * 1024,  // 150 MB
  158|      0|            diskPath: "org.alamofire.imagedownloader"
  159|      0|        )
  160|      0|    }
  161|       |
  162|       |    /// Initializes the `ImageDownloader` instance with the given configuration, download prioritization, maximum active
  163|       |    /// download count and image cache.
  164|       |    ///
  165|       |    /// - parameter configuration:          The `URLSessionConfiguration` to use to create the underlying Alamofire
  166|       |    ///                                     `SessionManager` instance.
  167|       |    /// - parameter downloadPrioritization: The download prioritization of the download queue. `.fifo` by default.
  168|       |    /// - parameter maximumActiveDownloads: The maximum number of active downloads allowed at any given time.
  169|       |    /// - parameter imageCache:             The image cache used to store all downloaded images in.
  170|       |    ///
  171|       |    /// - returns: The new `ImageDownloader` instance.
  172|       |    public init(
  173|       |        configuration: URLSessionConfiguration = ImageDownloader.defaultURLSessionConfiguration(),
  174|       |        downloadPrioritization: DownloadPrioritization = .fifo,
  175|       |        maximumActiveDownloads: Int = 4,
  176|       |        imageCache: ImageRequestCache? = AutoPurgingImageCache())
  177|      0|    {
  178|      0|        self.sessionManager = SessionManager(configuration: configuration)
  179|      0|        self.sessionManager.startRequestsImmediately = false
  180|      0|
  181|      0|        self.downloadPrioritization = downloadPrioritization
  182|      0|        self.maximumActiveDownloads = maximumActiveDownloads
  183|      0|        self.imageCache = imageCache
  184|      0|    }
  185|       |
  186|       |    /// Initializes the `ImageDownloader` instance with the given session manager, download prioritization, maximum
  187|       |    /// active download count and image cache.
  188|       |    ///
  189|       |    /// - parameter sessionManager:         The Alamofire `SessionManager` instance to handle all download requests.
  190|       |    /// - parameter downloadPrioritization: The download prioritization of the download queue. `.fifo` by default.
  191|       |    /// - parameter maximumActiveDownloads: The maximum number of active downloads allowed at any given time.
  192|       |    /// - parameter imageCache:             The image cache used to store all downloaded images in.
  193|       |    ///
  194|       |    /// - returns: The new `ImageDownloader` instance.
  195|       |    public init(
  196|       |        sessionManager: SessionManager,
  197|       |        downloadPrioritization: DownloadPrioritization = .fifo,
  198|       |        maximumActiveDownloads: Int = 4,
  199|       |        imageCache: ImageRequestCache? = AutoPurgingImageCache())
  200|      0|    {
  201|      0|        self.sessionManager = sessionManager
  202|      0|        self.sessionManager.startRequestsImmediately = false
  203|      0|
  204|      0|        self.downloadPrioritization = downloadPrioritization
  205|      0|        self.maximumActiveDownloads = maximumActiveDownloads
  206|      0|        self.imageCache = imageCache
  207|      0|    }
  208|       |
  209|       |    // MARK: Authentication
  210|       |
  211|       |    /// Associates an HTTP Basic Auth credential with all future download requests.
  212|       |    ///
  213|       |    /// - parameter user:        The user.
  214|       |    /// - parameter password:    The password.
  215|       |    /// - parameter persistence: The URL credential persistence. `.forSession` by default.
  216|       |    open func addAuthentication(
  217|       |        user: String,
  218|       |        password: String,
  219|       |        persistence: URLCredential.Persistence = .forSession)
  220|      0|    {
  221|      0|        let credential = URLCredential(user: user, password: password, persistence: persistence)
  222|      0|        addAuthentication(usingCredential: credential)
  223|      0|    }
  224|       |
  225|       |    /// Associates the specified credential with all future download requests.
  226|       |    ///
  227|       |    /// - parameter credential: The credential.
  228|      0|    open func addAuthentication(usingCredential credential: URLCredential) {
  229|      0|        synchronizationQueue.sync {
  230|      0|            self.credential = credential
  231|      0|        }
  232|      0|    }
  233|       |
  234|       |    // MARK: Download
  235|       |
  236|       |    /// Creates a download request using the internal Alamofire `SessionManager` instance for the specified URL request.
  237|       |    ///
  238|       |    /// If the same download request is already in the queue or currently being downloaded, the filter and completion
  239|       |    /// handler are appended to the already existing request. Once the request completes, all filters and completion
  240|       |    /// handlers attached to the request are executed in the order they were added. Additionally, any filters attached
  241|       |    /// to the request with the same identifiers are only executed once. The resulting image is then passed into each
  242|       |    /// completion handler paired with the filter.
  243|       |    ///
  244|       |    /// You should not attempt to directly cancel the `request` inside the request receipt since other callers may be
  245|       |    /// relying on the completion of that request. Instead, you should call `cancelRequestForRequestReceipt` with the
  246|       |    /// returned request receipt to allow the `ImageDownloader` to optimize the cancellation on behalf of all active
  247|       |    /// callers.
  248|       |    ///
  249|       |    /// - parameter urlRequest:     The URL request.
  250|       |    /// - parameter receiptID:      The `identifier` for the `RequestReceipt` returned. Defaults to a new, randomly
  251|       |    ///                             generated UUID.
  252|       |    /// - parameter filter:         The image filter to apply to the image after the download is complete. Defaults
  253|       |    ///                             to `nil`.
  254|       |    /// - parameter progress:       The closure to be executed periodically during the lifecycle of the request.
  255|       |    ///                             Defaults to `nil`.
  256|       |    /// - parameter progressQueue:  The dispatch queue to call the progress closure on. Defaults to the main queue.
  257|       |    /// - parameter completion:     The closure called when the download request is complete. Defaults to `nil`.
  258|       |    ///
  259|       |    /// - returns: The request receipt for the download request if available. `nil` if the image is stored in the image
  260|       |    ///            cache and the URL request cache policy allows the cache to be used.
  261|       |    @discardableResult
  262|       |    open func download(
  263|       |        _ urlRequest: URLRequestConvertible,
  264|       |        receiptID: String = UUID().uuidString,
  265|       |        filter: ImageFilter? = nil,
  266|       |        progress: ProgressHandler? = nil,
  267|       |        progressQueue: DispatchQueue = DispatchQueue.main,
  268|       |        completion: CompletionHandler?)
  269|       |        -> RequestReceipt?
  270|      0|    {
  271|      0|        var request: DataRequest!
  272|      0|
  273|      0|        synchronizationQueue.sync {
  274|      0|            // 1) Append the filter and completion handler to a pre-existing request if it already exists
  275|      0|            let urlID = ImageDownloader.urlIdentifier(for: urlRequest)
  276|      0|
  277|      0|            if let responseHandler = self.responseHandlers[urlID] {
  278|      0|                responseHandler.operations.append((receiptID: receiptID, filter: filter, completion: completion))
  279|      0|                request = responseHandler.request
  280|      0|                return
  281|      0|            }
  282|      0|
  283|      0|            // 2) Attempt to load the image from the image cache if the cache policy allows it
  284|      0|            if let request = urlRequest.urlRequest {
  285|      0|                switch request.cachePolicy {
  286|      0|                case .useProtocolCachePolicy, .returnCacheDataElseLoad, .returnCacheDataDontLoad:
  287|      0|                    if let image = self.imageCache?.image(for: request, withIdentifier: filter?.identifier) {
  288|      0|                        DispatchQueue.main.async {
  289|      0|                            let response = DataResponse<Image>(
  290|      0|                                request: urlRequest.urlRequest,
  291|      0|                                response: nil,
  292|      0|                                data: nil,
  293|      0|                                result: .success(image)
  294|      0|                            )
  295|      0|
  296|      0|                            completion?(response)
  297|      0|                        }
  298|      0|
  299|      0|                        return
  300|      0|                    }
  301|      0|                default:
  302|      0|                    break
  303|      0|                }
  304|      0|            }
  305|      0|
  306|      0|            // 3) Create the request and set up authentication, validation and response serialization
  307|      0|            request = self.sessionManager.request(urlRequest)
  308|      0|
  309|      0|            if let credential = self.credential {
  310|      0|                request.authenticate(usingCredential: credential)
  311|      0|            }
  312|      0|
  313|      0|            request.validate()
  314|      0|
  315|      0|            if let progress = progress {
  316|      0|                request.downloadProgress(queue: progressQueue, closure: progress)
  317|      0|            }
  318|      0|
  319|      0|            // Generate a unique handler id to check whether the active request has changed while downloading
  320|      0|            let handlerID = UUID().uuidString
  321|      0|
  322|      0|            request.response(
  323|      0|                queue: self.responseQueue,
  324|      0|                responseSerializer: imageResponseSerializer,
  325|      0|                completionHandler: { [weak self] response in
  326|      0|                    guard let strongSelf = self, let request = response.request else { return }
  327|      0|
  328|      0|                    defer {
  329|      0|                        strongSelf.safelyDecrementActiveRequestCount()
  330|      0|                        strongSelf.safelyStartNextRequestIfNecessary()
  331|      0|                    }
  332|      0|
  333|      0|                    // Early out if the request has changed out from under us
  334|      0|                    let handler = strongSelf.safelyFetchResponseHandler(withURLIdentifier: urlID)
  335|      0|                    guard handler?.handlerID == handlerID else { return }
  336|      0|
  337|      0|                    guard let responseHandler = strongSelf.safelyRemoveResponseHandler(withURLIdentifier: urlID) else {
  338|      0|                        return
  339|      0|                    }
  340|      0|
  341|      0|                    switch response.result {
  342|      0|                    case .success(let image):
  343|      0|                        var filteredImages: [String: Image] = [:]
  344|      0|
  345|      0|                        for (_, filter, completion) in responseHandler.operations {
  346|      0|                            var filteredImage: Image
  347|      0|
  348|      0|                            if let filter = filter {
  349|      0|                                if let alreadyFilteredImage = filteredImages[filter.identifier] {
  350|      0|                                    filteredImage = alreadyFilteredImage
  351|      0|                                } else {
  352|      0|                                    filteredImage = filter.filter(image)
  353|      0|                                    filteredImages[filter.identifier] = filteredImage
  354|      0|                                }
  355|      0|                            } else {
  356|      0|                                filteredImage = image
  357|      0|                            }
  358|      0|
  359|      0|                            strongSelf.imageCache?.add(filteredImage, for: request, withIdentifier: filter?.identifier)
  360|      0|
  361|      0|                            DispatchQueue.main.async {
  362|      0|                                let response = DataResponse<Image>(
  363|      0|                                    request: response.request,
  364|      0|                                    response: response.response,
  365|      0|                                    data: response.data,
  366|      0|                                    result: .success(filteredImage),
  367|      0|                                    timeline: response.timeline
  368|      0|                                )
  369|      0|
  370|      0|                                completion?(response)
  371|      0|                            }
  372|      0|                        }
  373|      0|                    case .failure:
  374|      0|                        for (_, _, completion) in responseHandler.operations {
  375|      0|                            DispatchQueue.main.async { completion?(response) }
  376|      0|                        }
  377|      0|                    }
  378|      0|                }
  379|      0|            )
  380|      0|
  381|      0|            // 4) Store the response handler for use when the request completes
  382|      0|            let responseHandler = ResponseHandler(
  383|      0|                request: request,
  384|      0|                handlerID: handlerID,
  385|      0|                receiptID: receiptID,
  386|      0|                filter: filter,
  387|      0|                completion: completion
  388|      0|            )
  389|      0|
  390|      0|            self.responseHandlers[urlID] = responseHandler
  391|      0|
  392|      0|            // 5) Either start the request or enqueue it depending on the current active request count
  393|      0|            if self.isActiveRequestCountBelowMaximumLimit() {
  394|      0|                self.start(request)
  395|      0|            } else {
  396|      0|                self.enqueue(request)
  397|      0|            }
  398|      0|        }
  399|      0|
  400|      0|        if let request = request {
  401|      0|            return RequestReceipt(request: request, receiptID: receiptID)
  402|      0|        }
  403|      0|
  404|      0|        return nil
  405|      0|    }
  406|       |
  407|       |    /// Creates a download request using the internal Alamofire `SessionManager` instance for each specified URL request.
  408|       |    ///
  409|       |    /// For each request, if the same download request is already in the queue or currently being downloaded, the
  410|       |    /// filter and completion handler are appended to the already existing request. Once the request completes, all
  411|       |    /// filters and completion handlers attached to the request are executed in the order they were added.
  412|       |    /// Additionally, any filters attached to the request with the same identifiers are only executed once. The
  413|       |    /// resulting image is then passed into each completion handler paired with the filter.
  414|       |    ///
  415|       |    /// You should not attempt to directly cancel any of the `request`s inside the request receipts array since other
  416|       |    /// callers may be relying on the completion of that request. Instead, you should call
  417|       |    /// `cancelRequestForRequestReceipt` with the returned request receipt to allow the `ImageDownloader` to optimize
  418|       |    /// the cancellation on behalf of all active callers.
  419|       |    ///
  420|       |    /// - parameter urlRequests:   The URL requests.
  421|       |    /// - parameter filter         The image filter to apply to the image after each download is complete.
  422|       |    /// - parameter progress:      The closure to be executed periodically during the lifecycle of the request. Defaults
  423|       |    ///                            to `nil`.
  424|       |    /// - parameter progressQueue: The dispatch queue to call the progress closure on. Defaults to the main queue.
  425|       |    /// - parameter completion:    The closure called when each download request is complete.
  426|       |    ///
  427|       |    /// - returns: The request receipts for the download requests if available. If an image is stored in the image
  428|       |    ///            cache and the URL request cache policy allows the cache to be used, a receipt will not be returned
  429|       |    ///            for that request.
  430|       |    @discardableResult
  431|       |    open func download(
  432|       |        _ urlRequests: [URLRequestConvertible],
  433|       |        filter: ImageFilter? = nil,
  434|       |        progress: ProgressHandler? = nil,
  435|       |        progressQueue: DispatchQueue = DispatchQueue.main,
  436|       |        completion: CompletionHandler? = nil)
  437|       |        -> [RequestReceipt]
  438|      0|    {
  439|      0|        #if swift(>=4.1)
  440|      0|        return urlRequests.compactMap {
  441|      0|            download($0, filter: filter, progress: progress, progressQueue: progressQueue, completion: completion)
  442|      0|        }
  443|      0|        #else
  444|      0|        return urlRequests.flatMap {
  445|      0|            download($0, filter: filter, progress: progress, progressQueue: progressQueue, completion: completion)
  446|      0|        }
  447|      0|        #endif
  448|      0|    }
  449|       |
  450|       |    /// Cancels the request in the receipt by removing the response handler and cancelling the request if necessary.
  451|       |    ///
  452|       |    /// If the request is pending in the queue, it will be cancelled if no other response handlers are registered with
  453|       |    /// the request. If the request is currently executing or is already completed, the response handler is removed and
  454|       |    /// will not be called.
  455|       |    ///
  456|       |    /// - parameter requestReceipt: The request receipt to cancel.
  457|      0|    open func cancelRequest(with requestReceipt: RequestReceipt) {
  458|      0|        synchronizationQueue.sync {
  459|      0|            let urlID = ImageDownloader.urlIdentifier(for: requestReceipt.request.request!)
  460|      0|            guard let responseHandler = self.responseHandlers[urlID] else { return }
  461|      0|
  462|      0|            if let index = responseHandler.operations.index(where: { $0.receiptID == requestReceipt.receiptID }) {
  463|      0|                let operation = responseHandler.operations.remove(at: index)
  464|      0|
  465|      0|                let response: DataResponse<Image> = {
  466|      0|                    let urlRequest = requestReceipt.request.request
  467|      0|                    let error = AFIError.requestCancelled
  468|      0|
  469|      0|                    return DataResponse(request: urlRequest, response: nil, data: nil, result: .failure(error))
  470|      0|                }()
  471|      0|
  472|      0|                DispatchQueue.main.async { operation.completion?(response) }
  473|      0|            }
  474|      0|
  475|      0|            if responseHandler.operations.isEmpty && requestReceipt.request.task?.state == .suspended {
  476|      0|                requestReceipt.request.cancel()
  477|      0|                self.responseHandlers.removeValue(forKey: urlID)
  478|      0|            }
  479|      0|        }
  480|      0|    }
  481|       |
  482|       |    // MARK: Internal - Thread-Safe Request Methods
  483|       |
  484|      0|    func safelyFetchResponseHandler(withURLIdentifier urlIdentifier: String) -> ResponseHandler? {
  485|      0|        var responseHandler: ResponseHandler?
  486|      0|
  487|      0|        synchronizationQueue.sync {
  488|      0|            responseHandler = self.responseHandlers[urlIdentifier]
  489|      0|        }
  490|      0|
  491|      0|        return responseHandler
  492|      0|    }
  493|       |
  494|      0|    func safelyRemoveResponseHandler(withURLIdentifier identifier: String) -> ResponseHandler? {
  495|      0|        var responseHandler: ResponseHandler?
  496|      0|
  497|      0|        synchronizationQueue.sync {
  498|      0|            responseHandler = self.responseHandlers.removeValue(forKey: identifier)
  499|      0|        }
  500|      0|
  501|      0|        return responseHandler
  502|      0|    }
  503|       |
  504|      0|    func safelyStartNextRequestIfNecessary() {
  505|      0|        synchronizationQueue.sync {
  506|      0|            guard self.isActiveRequestCountBelowMaximumLimit() else { return }
  507|      0|
  508|      0|            while !self.queuedRequests.isEmpty {
  509|      0|                if let request = self.dequeue(), request.task?.state == .suspended {
  510|      0|                    self.start(request)
  511|      0|                    break
  512|      0|                }
  513|      0|            }
  514|      0|        }
  515|      0|    }
  516|       |
  517|      0|    func safelyDecrementActiveRequestCount() {
  518|      0|        self.synchronizationQueue.sync {
  519|      0|            if self.activeRequestCount > 0 {
  520|      0|                self.activeRequestCount -= 1
  521|      0|            }
  522|      0|        }
  523|      0|    }
  524|       |
  525|       |    // MARK: Internal - Non Thread-Safe Request Methods
  526|       |
  527|      0|    func start(_ request: Request) {
  528|      0|        request.resume()
  529|      0|        activeRequestCount += 1
  530|      0|    }
  531|       |
  532|      0|    func enqueue(_ request: Request) {
  533|      0|        switch downloadPrioritization {
  534|      0|        case .fifo:
  535|      0|            queuedRequests.append(request)
  536|      0|        case .lifo:
  537|      0|            queuedRequests.insert(request, at: 0)
  538|      0|        }
  539|      0|    }
  540|       |
  541|       |    @discardableResult
  542|      0|    func dequeue() -> Request? {
  543|      0|        var request: Request?
  544|      0|
  545|      0|        if !queuedRequests.isEmpty {
  546|      0|            request = queuedRequests.removeFirst()
  547|      0|        }
  548|      0|
  549|      0|        return request
  550|      0|    }
  551|       |
  552|      0|    func isActiveRequestCountBelowMaximumLimit() -> Bool {
  553|      0|        return activeRequestCount < maximumActiveDownloads
  554|      0|    }
  555|       |
  556|      0|    static func urlIdentifier(for urlRequest: URLRequestConvertible) -> String {
  557|      0|        return urlRequest.urlRequest?.url?.absoluteString ?? ""
  558|      0|    }
  559|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/AlamofireImage/Source/ImageFilter.swift:
    1|       |//
    2|       |//  ImageFilter.swift
    3|       |//
    4|       |//  Copyright (c) 2015-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |#if os(iOS) || os(tvOS) || os(watchOS)
   28|       |import UIKit
   29|       |#elseif os(macOS)
   30|       |import Cocoa
   31|       |#endif
   32|       |
   33|       |// MARK: ImageFilter
   34|       |
   35|       |/// The `ImageFilter` protocol defines properties for filtering an image as well as identification of the filter.
   36|       |public protocol ImageFilter {
   37|       |    /// A closure used to create an alternative representation of the given image.
   38|       |    var filter: (Image) -> Image { get }
   39|       |
   40|       |    /// The string used to uniquely identify the filter operation.
   41|       |    var identifier: String { get }
   42|       |}
   43|       |
   44|       |extension ImageFilter {
   45|       |    /// The unique identifier for any `ImageFilter` type.
   46|      0|    public var identifier: String { return "\(type(of: self))" }
   47|       |}
   48|       |
   49|       |// MARK: - Sizable
   50|       |
   51|       |/// The `Sizable` protocol defines a size property intended for use with `ImageFilter` types.
   52|       |public protocol Sizable {
   53|       |    /// The size of the type.
   54|       |    var size: CGSize { get }
   55|       |}
   56|       |
   57|       |extension ImageFilter where Self: Sizable {
   58|       |    /// The unique idenitifier for an `ImageFilter` conforming to the `Sizable` protocol.
   59|      0|    public var identifier: String {
   60|      0|        let width = Int64(size.width.rounded())
   61|      0|        let height = Int64(size.height.rounded())
   62|      0|
   63|      0|        return "\(type(of: self))-size:(\(width)x\(height))"
   64|      0|    }
   65|       |}
   66|       |
   67|       |// MARK: - Roundable
   68|       |
   69|       |/// The `Roundable` protocol defines a radius property intended for use with `ImageFilter` types.
   70|       |public protocol Roundable {
   71|       |    /// The radius of the type.
   72|       |    var radius: CGFloat { get }
   73|       |}
   74|       |
   75|       |extension ImageFilter where Self: Roundable {
   76|       |    /// The unique idenitifier for an `ImageFilter` conforming to the `Roundable` protocol.
   77|      0|    public var identifier: String {
   78|      0|        let radius = Int64(self.radius.rounded())
   79|      0|        return "\(type(of: self))-radius:(\(radius))"
   80|      0|    }
   81|       |}
   82|       |
   83|       |// MARK: - DynamicImageFilter
   84|       |
   85|       |/// The `DynamicImageFilter` class simplifies custom image filter creation by using a trailing closure initializer.
   86|       |public struct DynamicImageFilter: ImageFilter {
   87|       |    /// The string used to uniquely identify the image filter operation.
   88|       |    public let identifier: String
   89|       |
   90|       |    /// A closure used to create an alternative representation of the given image.
   91|       |    public let filter: (Image) -> Image
   92|       |
   93|       |    /// Initializes the `DynamicImageFilter` instance with the specified identifier and filter closure.
   94|       |    ///
   95|       |    /// - parameter identifier: The unique identifier of the filter.
   96|       |    /// - parameter filter:     A closure used to create an alternative representation of the given image.
   97|       |    ///
   98|       |    /// - returns: The new `DynamicImageFilter` instance.
   99|      0|    public init(_ identifier: String, filter: @escaping (Image) -> Image) {
  100|      0|        self.identifier = identifier
  101|      0|        self.filter = filter
  102|      0|    }
  103|       |}
  104|       |
  105|       |// MARK: - CompositeImageFilter
  106|       |
  107|       |/// The `CompositeImageFilter` protocol defines an additional `filters` property to support multiple composite filters.
  108|       |public protocol CompositeImageFilter: ImageFilter {
  109|       |    /// The image filters to apply to the image in sequential order.
  110|       |    var filters: [ImageFilter] { get }
  111|       |}
  112|       |
  113|       |public extension CompositeImageFilter {
  114|       |    /// The unique idenitifier for any `CompositeImageFilter` type.
  115|      0|    var identifier: String {
  116|      0|        return filters.map { $0.identifier }.joined(separator: "_")
  117|      0|    }
  118|       |
  119|       |    /// The filter closure for any `CompositeImageFilter` type.
  120|      0|    var filter: (Image) -> Image {
  121|      0|        return { image in
  122|      0|            return self.filters.reduce(image) { $1.filter($0) }
  123|      0|        }
  124|      0|    }
  125|       |}
  126|       |
  127|       |// MARK: - DynamicCompositeImageFilter
  128|       |
  129|       |/// The `DynamicCompositeImageFilter` class is a composite image filter based on a specified array of filters.
  130|       |public struct DynamicCompositeImageFilter: CompositeImageFilter {
  131|       |    /// The image filters to apply to the image in sequential order.
  132|       |    public let filters: [ImageFilter]
  133|       |
  134|       |    /// Initializes the `DynamicCompositeImageFilter` instance with the given filters.
  135|       |    ///
  136|       |    /// - parameter filters: The filters taking part in the composite image filter.
  137|       |    ///
  138|       |    /// - returns: The new `DynamicCompositeImageFilter` instance.
  139|      0|    public init(_ filters: [ImageFilter]) {
  140|      0|        self.filters = filters
  141|      0|    }
  142|       |
  143|       |    /// Initializes the `DynamicCompositeImageFilter` instance with the given filters.
  144|       |    ///
  145|       |    /// - parameter filters: The filters taking part in the composite image filter.
  146|       |    ///
  147|       |    /// - returns: The new `DynamicCompositeImageFilter` instance.
  148|      0|    public init(_ filters: ImageFilter...) {
  149|      0|        self.init(filters)
  150|      0|    }
  151|       |}
  152|       |
  153|       |#if os(iOS) || os(tvOS) || os(watchOS)
  154|       |
  155|       |// MARK: - Single Pass Image Filters (iOS, tvOS and watchOS only) -
  156|       |
  157|       |/// Scales an image to a specified size.
  158|       |public struct ScaledToSizeFilter: ImageFilter, Sizable {
  159|       |    /// The size of the filter.
  160|       |    public let size: CGSize
  161|       |
  162|       |    /// Initializes the `ScaledToSizeFilter` instance with the given size.
  163|       |    ///
  164|       |    /// - parameter size: The size.
  165|       |    ///
  166|       |    /// - returns: The new `ScaledToSizeFilter` instance.
  167|      0|    public init(size: CGSize) {
  168|      0|        self.size = size
  169|      0|    }
  170|       |
  171|       |    /// The filter closure used to create the modified representation of the given image.
  172|      0|    public var filter: (Image) -> Image {
  173|      0|        return { image in
  174|      0|            return image.af_imageScaled(to: self.size)
  175|      0|        }
  176|      0|    }
  177|       |}
  178|       |
  179|       |// MARK: -
  180|       |
  181|       |/// Scales an image from the center while maintaining the aspect ratio to fit within a specified size.
  182|       |public struct AspectScaledToFitSizeFilter: ImageFilter, Sizable {
  183|       |    /// The size of the filter.
  184|       |    public let size: CGSize
  185|       |
  186|       |    /// Initializes the `AspectScaledToFitSizeFilter` instance with the given size.
  187|       |    ///
  188|       |    /// - parameter size: The size.
  189|       |    ///
  190|       |    /// - returns: The new `AspectScaledToFitSizeFilter` instance.
  191|      0|    public init(size: CGSize) {
  192|      0|        self.size = size
  193|      0|    }
  194|       |
  195|       |    /// The filter closure used to create the modified representation of the given image.
  196|      0|    public var filter: (Image) -> Image {
  197|      0|        return { image in
  198|      0|            return image.af_imageAspectScaled(toFit: self.size)
  199|      0|        }
  200|      0|    }
  201|       |}
  202|       |
  203|       |// MARK: -
  204|       |
  205|       |/// Scales an image from the center while maintaining the aspect ratio to fill a specified size. Any pixels that fall
  206|       |/// outside the specified size are clipped.
  207|       |public struct AspectScaledToFillSizeFilter: ImageFilter, Sizable {
  208|       |    /// The size of the filter.
  209|       |    public let size: CGSize
  210|       |
  211|       |    /// Initializes the `AspectScaledToFillSizeFilter` instance with the given size.
  212|       |    ///
  213|       |    /// - parameter size: The size.
  214|       |    ///
  215|       |    /// - returns: The new `AspectScaledToFillSizeFilter` instance.
  216|      0|    public init(size: CGSize) {
  217|      0|        self.size = size
  218|      0|    }
  219|       |
  220|       |    /// The filter closure used to create the modified representation of the given image.
  221|      0|    public var filter: (Image) -> Image {
  222|      0|        return { image in
  223|      0|            return image.af_imageAspectScaled(toFill: self.size)
  224|      0|        }
  225|      0|    }
  226|       |}
  227|       |
  228|       |// MARK: -
  229|       |
  230|       |/// Rounds the corners of an image to the specified radius.
  231|       |public struct RoundedCornersFilter: ImageFilter, Roundable {
  232|       |    /// The radius of the filter.
  233|       |    public let radius: CGFloat
  234|       |
  235|       |    /// Whether to divide the radius by the image scale.
  236|       |    public let divideRadiusByImageScale: Bool
  237|       |
  238|       |    /// Initializes the `RoundedCornersFilter` instance with the given radius.
  239|       |    ///
  240|       |    /// - parameter radius:                   The radius.
  241|       |    /// - parameter divideRadiusByImageScale: Whether to divide the radius by the image scale. Set to `true` when the
  242|       |    ///                                       image has the same resolution for all screen scales such as @1x, @2x and
  243|       |    ///                                       @3x (i.e. single image from web server). Set to `false` for images loaded
  244|       |    ///                                       from an asset catalog with varying resolutions for each screen scale.
  245|       |    ///                                       `false` by default.
  246|       |    ///
  247|       |    /// - returns: The new `RoundedCornersFilter` instance.
  248|      0|    public init(radius: CGFloat, divideRadiusByImageScale: Bool = false) {
  249|      0|        self.radius = radius
  250|      0|        self.divideRadiusByImageScale = divideRadiusByImageScale
  251|      0|    }
  252|       |
  253|       |    /// The filter closure used to create the modified representation of the given image.
  254|      0|    public var filter: (Image) -> Image {
  255|      0|        return { image in
  256|      0|            return image.af_imageRounded(
  257|      0|                withCornerRadius: self.radius,
  258|      0|                divideRadiusByImageScale: self.divideRadiusByImageScale
  259|      0|            )
  260|      0|        }
  261|      0|    }
  262|       |
  263|       |    /// The unique idenitifier for an `ImageFilter` conforming to the `Roundable` protocol.
  264|      0|    public var identifier: String {
  265|      0|        let radius = Int64(self.radius.rounded())
  266|      0|        return "\(type(of: self))-radius:(\(radius))-divided:(\(divideRadiusByImageScale))"
  267|      0|    }
  268|       |}
  269|       |
  270|       |// MARK: -
  271|       |
  272|       |/// Rounds the corners of an image into a circle.
  273|       |public struct CircleFilter: ImageFilter {
  274|       |    /// Initializes the `CircleFilter` instance.
  275|       |    ///
  276|       |    /// - returns: The new `CircleFilter` instance.
  277|      0|    public init() {}
  278|       |
  279|       |    /// The filter closure used to create the modified representation of the given image.
  280|      0|    public var filter: (Image) -> Image {
  281|      0|        return { image in
  282|      0|            return image.af_imageRoundedIntoCircle()
  283|      0|        }
  284|      0|    }
  285|       |}
  286|       |
  287|       |// MARK: -
  288|       |
  289|       |#if os(iOS) || os(tvOS)
  290|       |
  291|       |/// The `CoreImageFilter` protocol defines `parameters`, `filterName` properties used by CoreImage.
  292|       |@available(iOS 9.0, *)
  293|       |public protocol CoreImageFilter: ImageFilter {
  294|       |    /// The filter name of the CoreImage filter.
  295|       |	var filterName: String { get }
  296|       |
  297|       |    /// The image filter parameters passed to CoreImage.
  298|       |    var parameters: [String: Any] { get }
  299|       |}
  300|       |
  301|       |@available(iOS 9.0, *)
  302|       |public extension ImageFilter where Self: CoreImageFilter {
  303|       |	/// The filter closure used to create the modified representation of the given image.
  304|      0|	public var filter: (Image) -> Image {
  305|      0|		return { image in
  306|      0|            return image.af_imageFiltered(withCoreImageFilter: self.filterName, parameters: self.parameters) ?? image
  307|      0|		}
  308|      0|	}
  309|       |
  310|       |	/// The unique idenitifier for an `ImageFilter` conforming to the `CoreImageFilter` protocol.
  311|      0|	public var identifier: String { return "\(type(of: self))-parameters:(\(self.parameters))" }
  312|       |}
  313|       |
  314|       |/// Blurs an image using a `CIGaussianBlur` filter with the specified blur radius.
  315|       |@available(iOS 9.0, *)
  316|       |public struct BlurFilter: ImageFilter, CoreImageFilter {
  317|       |    /// The filter name.
  318|       |    public let filterName = "CIGaussianBlur"
  319|       |
  320|       |    /// The image filter parameters passed to CoreImage.
  321|       |    public let parameters: [String: Any]
  322|       |
  323|       |    /// Initializes the `BlurFilter` instance with the given blur radius.
  324|       |    ///
  325|       |    /// - parameter blurRadius: The blur radius.
  326|       |    ///
  327|       |    /// - returns: The new `BlurFilter` instance.
  328|      0|    public init(blurRadius: UInt = 10) {
  329|      0|        self.parameters = ["inputRadius": blurRadius]
  330|      0|    }
  331|       |}
  332|       |
  333|       |#endif
  334|       |
  335|       |// MARK: - Composite Image Filters (iOS, tvOS and watchOS only) -
  336|       |
  337|       |/// Scales an image to a specified size, then rounds the corners to the specified radius.
  338|       |public struct ScaledToSizeWithRoundedCornersFilter: CompositeImageFilter {
  339|       |    /// Initializes the `ScaledToSizeWithRoundedCornersFilter` instance with the given size and radius.
  340|       |    ///
  341|       |    /// - parameter size:                     The size.
  342|       |    /// - parameter radius:                   The radius.
  343|       |    /// - parameter divideRadiusByImageScale: Whether to divide the radius by the image scale. Set to `true` when the
  344|       |    ///                                       image has the same resolution for all screen scales such as @1x, @2x and
  345|       |    ///                                       @3x (i.e. single image from web server). Set to `false` for images loaded
  346|       |    ///                                       from an asset catalog with varying resolutions for each screen scale.
  347|       |    ///                                       `false` by default.
  348|       |    ///
  349|       |    /// - returns: The new `ScaledToSizeWithRoundedCornersFilter` instance.
  350|      0|    public init(size: CGSize, radius: CGFloat, divideRadiusByImageScale: Bool = false) {
  351|      0|        self.filters = [
  352|      0|            ScaledToSizeFilter(size: size),
  353|      0|            RoundedCornersFilter(radius: radius, divideRadiusByImageScale: divideRadiusByImageScale)
  354|      0|        ]
  355|      0|    }
  356|       |
  357|       |    /// The image filters to apply to the image in sequential order.
  358|       |    public let filters: [ImageFilter]
  359|       |}
  360|       |
  361|       |// MARK: -
  362|       |
  363|       |/// Scales an image from the center while maintaining the aspect ratio to fit within a specified size, then rounds the
  364|       |/// corners to the specified radius.
  365|       |public struct AspectScaledToFillSizeWithRoundedCornersFilter: CompositeImageFilter {
  366|       |    /// Initializes the `AspectScaledToFillSizeWithRoundedCornersFilter` instance with the given size and radius.
  367|       |    ///
  368|       |    /// - parameter size:                     The size.
  369|       |    /// - parameter radius:                   The radius.
  370|       |    /// - parameter divideRadiusByImageScale: Whether to divide the radius by the image scale. Set to `true` when the
  371|       |    ///                                       image has the same resolution for all screen scales such as @1x, @2x and
  372|       |    ///                                       @3x (i.e. single image from web server). Set to `false` for images loaded
  373|       |    ///                                       from an asset catalog with varying resolutions for each screen scale.
  374|       |    ///                                       `false` by default.
  375|       |    ///
  376|       |    /// - returns: The new `AspectScaledToFillSizeWithRoundedCornersFilter` instance.
  377|      0|    public init(size: CGSize, radius: CGFloat, divideRadiusByImageScale: Bool = false) {
  378|      0|        self.filters = [
  379|      0|            AspectScaledToFillSizeFilter(size: size),
  380|      0|            RoundedCornersFilter(radius: radius, divideRadiusByImageScale: divideRadiusByImageScale)
  381|      0|        ]
  382|      0|    }
  383|       |
  384|       |    /// The image filters to apply to the image in sequential order.
  385|       |    public let filters: [ImageFilter]
  386|       |}
  387|       |
  388|       |// MARK: -
  389|       |
  390|       |/// Scales an image to a specified size, then rounds the corners into a circle.
  391|       |public struct ScaledToSizeCircleFilter: CompositeImageFilter {
  392|       |    /// Initializes the `ScaledToSizeCircleFilter` instance with the given size.
  393|       |    ///
  394|       |    /// - parameter size: The size.
  395|       |    ///
  396|       |    /// - returns: The new `ScaledToSizeCircleFilter` instance.
  397|      0|    public init(size: CGSize) {
  398|      0|        self.filters = [ScaledToSizeFilter(size: size), CircleFilter()]
  399|      0|    }
  400|       |
  401|       |    /// The image filters to apply to the image in sequential order.
  402|       |    public let filters: [ImageFilter]
  403|       |}
  404|       |
  405|       |// MARK: -
  406|       |
  407|       |/// Scales an image from the center while maintaining the aspect ratio to fit within a specified size, then rounds the
  408|       |/// corners into a circle.
  409|       |public struct AspectScaledToFillSizeCircleFilter: CompositeImageFilter {
  410|       |    /// Initializes the `AspectScaledToFillSizeCircleFilter` instance with the given size.
  411|       |    ///
  412|       |    /// - parameter size: The size.
  413|       |    ///
  414|       |    /// - returns: The new `AspectScaledToFillSizeCircleFilter` instance.
  415|      0|    public init(size: CGSize) {
  416|      0|        self.filters = [AspectScaledToFillSizeFilter(size: size), CircleFilter()]
  417|      0|    }
  418|       |
  419|       |    /// The image filters to apply to the image in sequential order.
  420|       |    public let filters: [ImageFilter]
  421|       |}
  422|       |
  423|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/AlamofireImage/Source/Request+AlamofireImage.swift:
    1|       |//
    2|       |//  Request+AlamofireImage.swift
    3|       |//
    4|       |//  Copyright (c) 2015-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Alamofire
   26|       |import Foundation
   27|       |
   28|       |#if os(iOS) || os(tvOS)
   29|       |import UIKit
   30|       |#elseif os(watchOS)
   31|       |import UIKit
   32|       |import WatchKit
   33|       |#elseif os(macOS)
   34|       |import Cocoa
   35|       |#endif
   36|       |
   37|       |extension DataRequest {
   38|       |    static var acceptableImageContentTypes: Set<String> = [
   39|       |        "image/tiff",
   40|       |        "image/jpeg",
   41|       |        "image/gif",
   42|       |        "image/png",
   43|       |        "image/ico",
   44|       |        "image/x-icon",
   45|       |        "image/bmp",
   46|       |        "image/x-bmp",
   47|       |        "image/x-xbitmap",
   48|       |        "image/x-ms-bmp",
   49|       |        "image/x-win-bitmap"
   50|       |    ]
   51|       |
   52|       |    static let streamImageInitialBytePattern = Data(bytes: [255, 216]) // 0xffd8
   53|       |
   54|       |    /// Adds the content types specified to the list of acceptable images content types for validation.
   55|       |    ///
   56|       |    /// - parameter contentTypes: The additional content types.
   57|      0|    public class func addAcceptableImageContentTypes(_ contentTypes: Set<String>) {
   58|      0|        DataRequest.acceptableImageContentTypes.formUnion(contentTypes)
   59|      0|    }
   60|       |
   61|       |    // MARK: - iOS, tvOS and watchOS
   62|       |
   63|       |#if os(iOS) || os(tvOS) || os(watchOS)
   64|       |
   65|       |    /// Creates a response serializer that returns an image initialized from the response data using the specified
   66|       |    /// image options.
   67|       |    ///
   68|       |    /// - parameter imageScale:           The scale factor used when interpreting the image data to construct
   69|       |    ///                                   `responseImage`. Specifying a scale factor of 1.0 results in an image whose
   70|       |    ///                                   size matches the pixel-based dimensions of the image. Applying a different
   71|       |    ///                                   scale factor changes the size of the image as reported by the size property.
   72|       |    ///                                   `Screen.scale` by default.
   73|       |    /// - parameter inflateResponseImage: Whether to automatically inflate response image data for compressed formats
   74|       |    ///                                   (such as PNG or JPEG). Enabling this can significantly improve drawing
   75|       |    ///                                   performance as it allows a bitmap representation to be constructed in the
   76|       |    ///                                   background rather than on the main thread. `true` by default.
   77|       |    ///
   78|       |    /// - returns: An image response serializer.
   79|       |    public class func imageResponseSerializer(
   80|       |        imageScale: CGFloat = DataRequest.imageScale,
   81|       |        inflateResponseImage: Bool = true)
   82|       |        -> DataResponseSerializer<Image>
   83|    494|    {
   84|    494|        return DataResponseSerializer { request, response, data, error in
   85|    493|            let result = serializeResponseData(response: response, data: data, error: error)
   86|    493|
   87|    493|            guard case let .success(data) = result else { return .failure(result.error!) }
   88|    472|
   89|    472|            do {
   90|    472|                try DataRequest.validateContentType(for: request, response: response)
   91|    472|
   92|    472|                let image = try DataRequest.image(from: data, withImageScale: imageScale)
   93|    472|                if inflateResponseImage { image.af_inflate() }
   94|    472|
   95|    472|                return .success(image)
   96|    472|            } catch {
   97|      0|                return .failure(error)
   98|      0|            }
   99|      0|        }
  100|    494|    }
  101|       |
  102|       |    /// Adds a response handler to be called once the request has finished.
  103|       |    ///
  104|       |    /// - parameter imageScale:           The scale factor used when interpreting the image data to construct
  105|       |    ///                                   `responseImage`. Specifying a scale factor of 1.0 results in an image whose
  106|       |    ///                                   size matches the pixel-based dimensions of the image. Applying a different
  107|       |    ///                                   scale factor changes the size of the image as reported by the size property.
  108|       |    ///                                   This is set to the value of scale of the main screen by default, which
  109|       |    ///                                   automatically scales images for retina displays, for instance.
  110|       |    ///                                   `Screen.scale` by default.
  111|       |    /// - parameter inflateResponseImage: Whether to automatically inflate response image data for compressed formats
  112|       |    ///                                   (such as PNG or JPEG). Enabling this can significantly improve drawing
  113|       |    ///                                   performance as it allows a bitmap representation to be constructed in the
  114|       |    ///                                   background rather than on the main thread. `true` by default.
  115|       |    /// - parameter queue:                The queue on which the completion handler is dispatched. `nil` by default,
  116|       |    ///                                   which results in using `DispatchQueue.main`.
  117|       |    /// - parameter completionHandler:    A closure to be executed once the request has finished. The closure takes 4
  118|       |    ///                                   arguments: the URL request, the URL response, if one was received, the image,
  119|       |    ///                                   if one could be created from the URL response and data, and any error produced
  120|       |    ///                                   while creating the image.
  121|       |    ///
  122|       |    /// - returns: The request.
  123|       |    @discardableResult
  124|       |    public func responseImage(
  125|       |        imageScale: CGFloat = DataRequest.imageScale,
  126|       |        inflateResponseImage: Bool = true,
  127|       |        queue: DispatchQueue? = nil,
  128|       |        completionHandler: @escaping (DataResponse<Image>) -> Void)
  129|       |        -> Self
  130|    494|    {
  131|    494|        return response(
  132|    494|            queue: queue,
  133|    494|            responseSerializer: DataRequest.imageResponseSerializer(
  134|    494|                imageScale: imageScale,
  135|    494|                inflateResponseImage: inflateResponseImage
  136|    494|            ),
  137|    494|            completionHandler: completionHandler
  138|    494|        )
  139|    494|    }
  140|       |
  141|       |    /// Sets a closure to be called periodically during the lifecycle of the request as data is read from the server
  142|       |    /// and converted into images.
  143|       |    ///
  144|       |    /// - parameter imageScale:           The scale factor used when interpreting the image data to construct
  145|       |    ///                                   `responseImage`. Specifying a scale factor of 1.0 results in an image whose
  146|       |    ///                                   size matches the pixel-based dimensions of the image. Applying a different
  147|       |    ///                                   scale factor changes the size of the image as reported by the size property.
  148|       |    ///                                   This is set to the value of scale of the main screen by default, which
  149|       |    ///                                   automatically scales images for retina displays, for instance.
  150|       |    ///                                   `Screen.scale` by default.
  151|       |    /// - parameter inflateResponseImage: Whether to automatically inflate response image data for compressed formats
  152|       |    ///                                   (such as PNG or JPEG). Enabling this can significantly improve drawing
  153|       |    ///                                   performance as it allows a bitmap representation to be constructed in the
  154|       |    ///                                   background rather than on the main thread. `true` by default.
  155|       |    /// - parameter completionHandler:    A closure to be executed when the request has new image. The closure takes 1
  156|       |    ///                                   argument: the image, if one could be created from the data.
  157|       |    ///
  158|       |    /// - returns: The request.
  159|       |    @discardableResult
  160|       |    public func streamImage(
  161|       |        imageScale: CGFloat = DataRequest.imageScale,
  162|       |        inflateResponseImage: Bool = true,
  163|       |        completionHandler: @escaping (Image) -> Void)
  164|       |        -> Self
  165|      0|    {
  166|      0|        var imageData = Data()
  167|      0|
  168|      0|        return stream { chunkData in
  169|      0|            if chunkData.starts(with: DataRequest.streamImageInitialBytePattern) {
  170|      0|                imageData = Data()
  171|      0|            }
  172|      0|
  173|      0|            imageData.append(chunkData)
  174|      0|
  175|      0|            if let image = DataRequest.serializeImage(from: imageData) {
  176|      0|                completionHandler(image)
  177|      0|            }
  178|      0|        }
  179|      0|    }
  180|       |
  181|       |    private class func serializeImage(
  182|       |        from data: Data,
  183|       |        imageScale: CGFloat = DataRequest.imageScale,
  184|       |        inflateResponseImage: Bool = true)
  185|       |        -> UIImage?
  186|      0|    {
  187|      0|        guard data.count > 0 else { return nil }
  188|      0|
  189|      0|        do {
  190|      0|            let image = try DataRequest.image(from: data, withImageScale: imageScale)
  191|      0|            if inflateResponseImage { image.af_inflate() }
  192|      0|
  193|      0|            return image
  194|      0|        } catch {
  195|      0|            return nil
  196|      0|        }
  197|      0|    }
  198|       |
  199|    472|    private class func image(from data: Data, withImageScale imageScale: CGFloat) throws -> UIImage {
  200|    472|        if let image = UIImage.af_threadSafeImage(with: data, scale: imageScale) {
  201|    472|            return image
  202|    472|        }
  203|      0|
  204|      0|        throw AFIError.imageSerializationFailed
  205|    472|    }
  206|       |
  207|    494|    public class var imageScale: CGFloat {
  208|    494|        #if os(iOS) || os(tvOS)
  209|    494|            return UIScreen.main.scale
  210|    494|        #elseif os(watchOS)
  211|    494|            return WKInterfaceDevice.current().screenScale
  212|    494|        #endif
  213|    494|    }
  214|       |
  215|       |#elseif os(macOS)
  216|       |
  217|       |    // MARK: - macOS
  218|       |
  219|       |    /// Creates a response serializer that returns an image initialized from the response data.
  220|       |    ///
  221|       |    /// - returns: An image response serializer.
  222|       |    public class func imageResponseSerializer() -> DataResponseSerializer<Image> {
  223|       |        return DataResponseSerializer { request, response, data, error in
  224|       |            let result = serializeResponseData(response: response, data: data, error: error)
  225|       |
  226|       |            guard case let .success(data) = result else { return .failure(result.error!) }
  227|       |
  228|       |            do {
  229|       |                try DataRequest.validateContentType(for: request, response: response)
  230|       |            } catch {
  231|       |                return .failure(error)
  232|       |            }
  233|       |
  234|       |            guard let bitmapImage = NSBitmapImageRep(data: data) else {
  235|       |                return .failure(AFIError.imageSerializationFailed)
  236|       |            }
  237|       |
  238|       |            let image = NSImage(size: NSSize(width: bitmapImage.pixelsWide, height: bitmapImage.pixelsHigh))
  239|       |            image.addRepresentation(bitmapImage)
  240|       |
  241|       |            return .success(image)
  242|       |        }
  243|       |    }
  244|       |
  245|       |    /// Adds a response handler to be called once the request has finished.
  246|       |    ///
  247|       |    /// - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 4
  248|       |    ///                                arguments: the URL request, the URL response, if one was received, the image, if
  249|       |    ///                                one could be created from the URL response and data, and any error produced while
  250|       |    ///                                creating the image.
  251|       |    /// - parameter queue:             The queue on which the completion handler is dispatched. `nil` by default,
  252|       |    ///                                which results in using `DispatchQueue.main`.
  253|       |    ///
  254|       |    /// - returns: The request.
  255|       |    @discardableResult
  256|       |    public func responseImage(
  257|       |        queue: DispatchQueue? = nil,
  258|       |        completionHandler: @escaping (DataResponse<Image>) -> Void)
  259|       |        -> Self {
  260|       |        return response(
  261|       |            queue: queue,
  262|       |            responseSerializer: DataRequest.imageResponseSerializer(),
  263|       |            completionHandler: completionHandler
  264|       |        )
  265|       |    }
  266|       |
  267|       |    /// Sets a closure to be called periodically during the lifecycle of the request as data is read from the server
  268|       |    /// and converted into images.
  269|       |    ///
  270|       |    /// - parameter completionHandler: A closure to be executed when the request has new image. The closure takes 1
  271|       |    ///                                argument: the image, if one could be created from the data.
  272|       |    ///
  273|       |    /// - returns: The request.
  274|       |    @discardableResult
  275|       |    public func streamImage(completionHandler: @escaping (Image) -> Void) -> Self {
  276|       |        var imageData = Data()
  277|       |
  278|       |        return stream { chunkData in
  279|       |            if chunkData.starts(with: DataRequest.streamImageInitialBytePattern) {
  280|       |                imageData = Data()
  281|       |            }
  282|       |
  283|       |            imageData.append(chunkData)
  284|       |
  285|       |            if let image = DataRequest.serializeImage(from: imageData) {
  286|       |                completionHandler(image)
  287|       |            }
  288|       |        }
  289|       |    }
  290|       |
  291|       |    private class func serializeImage(from data: Data) -> NSImage? {
  292|       |        guard data.count > 0 else { return nil }
  293|       |        guard let bitmapImage = NSBitmapImageRep(data: data) else { return nil }
  294|       |
  295|       |        let image = NSImage(size: NSSize(width: bitmapImage.pixelsWide, height: bitmapImage.pixelsHigh))
  296|       |        image.addRepresentation(bitmapImage)
  297|       |
  298|       |        return image
  299|       |    }
  300|       |
  301|       |#endif
  302|       |
  303|       |    // MARK: - Content Type Validation
  304|       |
  305|       |    /// Returns whether the content type of the response matches one of the acceptable content types.
  306|       |    ///
  307|       |    /// - parameter request: The request.
  308|       |    /// - parameter response: The server response.
  309|       |    ///
  310|       |    /// - throws: An `AFError` response validation failure when an error is encountered.
  311|    472|    public class func validateContentType(for request: URLRequest?, response: HTTPURLResponse?) throws {
  312|    472|        if let url = request?.url, url.isFileURL { return }
  313|    472|
  314|    472|        guard let mimeType = response?.mimeType else {
  315|      0|            let contentTypes = Array(DataRequest.acceptableImageContentTypes)
  316|      0|            throw AFError.responseValidationFailed(reason: .missingContentType(acceptableContentTypes: contentTypes))
  317|    472|        }
  318|    472|
  319|    472|        guard DataRequest.acceptableImageContentTypes.contains(mimeType) else {
  320|      0|            let contentTypes = Array(DataRequest.acceptableImageContentTypes)
  321|      0|
  322|      0|            throw AFError.responseValidationFailed(
  323|      0|                reason: .unacceptableContentType(acceptableContentTypes: contentTypes, responseContentType: mimeType)
  324|      0|            )
  325|    472|        }
  326|    472|    }
  327|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/AlamofireImage/Source/UIButton+AlamofireImage.swift:
    1|       |//
    2|       |//  UIButton+AlamofireImage.swift
    3|       |//
    4|       |//  Copyright (c) 2015-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Alamofire
   26|       |import Foundation
   27|       |
   28|       |#if os(iOS) || os(tvOS)
   29|       |
   30|       |import UIKit
   31|       |
   32|       |#if swift(>=4.2)
   33|       |public typealias ControlState = UIControl.State
   34|       |#else
   35|       |public typealias ControlState = UIControlState
   36|       |#endif
   37|       |
   38|       |extension UIButton {
   39|       |
   40|       |    // MARK: - Private - AssociatedKeys
   41|       |
   42|       |    private struct AssociatedKey {
   43|       |        static var imageDownloader = "af_UIButton.ImageDownloader"
   44|       |        static var sharedImageDownloader = "af_UIButton.SharedImageDownloader"
   45|       |        static var imageReceipts = "af_UIButton.ImageReceipts"
   46|       |        static var backgroundImageReceipts = "af_UIButton.BackgroundImageReceipts"
   47|       |    }
   48|       |
   49|       |    // MARK: - Properties
   50|       |
   51|       |    /// The instance image downloader used to download all images. If this property is `nil`, the `UIButton` will
   52|       |    /// fallback on the `af_sharedImageDownloader` for all downloads. The most common use case for needing to use a
   53|       |    /// custom instance image downloader is when images are behind different basic auth credentials.
   54|       |    public var af_imageDownloader: ImageDownloader? {
   55|      0|        get {
   56|      0|            return objc_getAssociatedObject(self, &AssociatedKey.imageDownloader) as? ImageDownloader
   57|      0|        }
   58|      0|        set {
   59|      0|            objc_setAssociatedObject(self, &AssociatedKey.imageDownloader, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
   60|      0|        }
   61|       |    }
   62|       |
   63|       |    /// The shared image downloader used to download all images. By default, this is the default `ImageDownloader`
   64|       |    /// instance backed with an `AutoPurgingImageCache` which automatically evicts images from the cache when the memory
   65|       |    /// capacity is reached or memory warning notifications occur. The shared image downloader is only used if the
   66|       |    /// `af_imageDownloader` is `nil`.
   67|       |    public class var af_sharedImageDownloader: ImageDownloader {
   68|      0|        get {
   69|      0|            guard let
   70|      0|                downloader = objc_getAssociatedObject(self, &AssociatedKey.sharedImageDownloader) as? ImageDownloader
   71|      0|            else {
   72|      0|                return ImageDownloader.default
   73|      0|            }
   74|      0|
   75|      0|            return downloader
   76|      0|        }
   77|      0|        set {
   78|      0|            objc_setAssociatedObject(self, &AssociatedKey.sharedImageDownloader, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
   79|      0|        }
   80|       |    }
   81|       |
   82|       |    private var imageRequestReceipts: [UInt: RequestReceipt] {
   83|      0|        get {
   84|      0|            guard let
   85|      0|                receipts = objc_getAssociatedObject(self, &AssociatedKey.imageReceipts) as? [UInt: RequestReceipt]
   86|      0|            else {
   87|      0|                return [:]
   88|      0|            }
   89|      0|
   90|      0|            return receipts
   91|      0|        }
   92|      0|        set {
   93|      0|            objc_setAssociatedObject(self, &AssociatedKey.imageReceipts, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
   94|      0|        }
   95|       |    }
   96|       |
   97|       |    private var backgroundImageRequestReceipts: [UInt: RequestReceipt] {
   98|      0|        get {
   99|      0|            guard let
  100|      0|                receipts = objc_getAssociatedObject(self, &AssociatedKey.backgroundImageReceipts) as? [UInt: RequestReceipt]
  101|      0|            else {
  102|      0|                return [:]
  103|      0|            }
  104|      0|
  105|      0|            return receipts
  106|      0|        }
  107|      0|        set {
  108|      0|            objc_setAssociatedObject(self, &AssociatedKey.backgroundImageReceipts, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  109|      0|        }
  110|       |    }
  111|       |
  112|       |    // MARK: - Image Downloads
  113|       |
  114|       |    /// Asynchronously downloads an image from the specified URL and sets it once the request is finished.
  115|       |    ///
  116|       |    /// If the image is cached locally, the image is set immediately. Otherwise the specified placeholder image will be
  117|       |    /// set immediately, and then the remote image will be set once the image request is finished.
  118|       |    ///
  119|       |    /// - parameter state:            The control state of the button to set the image on.
  120|       |    /// - parameter url:              The URL used for your image request.
  121|       |    /// - parameter placeholderImage: The image to be set initially until the image request finished. If `nil`, the
  122|       |    ///                               image will not change its image until the image request finishes. Defaults
  123|       |    ///                               to `nil`.
  124|       |    /// - parameter filter:           The image filter applied to the image after the image request is finished.
  125|       |    ///                               Defaults to `nil`.
  126|       |    /// - parameter progress:         The closure to be executed periodically during the lifecycle of the request.
  127|       |    ///                               Defaults to `nil`.
  128|       |    /// - parameter progressQueue:    The dispatch queue to call the progress closure on. Defaults to the main queue.
  129|       |    /// - parameter completion:       A closure to be executed when the image request finishes. The closure takes a
  130|       |    ///                               single response value containing either the image or the error that occurred. If
  131|       |    ///                               the image was returned from the image cache, the response will be `nil`. Defaults
  132|       |    ///                               to `nil`.
  133|       |    public func af_setImage(
  134|       |        for state: ControlState,
  135|       |        url: URL,
  136|       |        placeholderImage: UIImage? = nil,
  137|       |        filter: ImageFilter? = nil,
  138|       |        progress: ImageDownloader.ProgressHandler? = nil,
  139|       |        progressQueue: DispatchQueue = DispatchQueue.main,
  140|       |        completion: ((DataResponse<UIImage>) -> Void)? = nil)
  141|      0|    {
  142|      0|        af_setImage(
  143|      0|            for: state,
  144|      0|            urlRequest: urlRequest(with: url),
  145|      0|            placeholderImage: placeholderImage,
  146|      0|            filter: filter,
  147|      0|            progress: progress,
  148|      0|            progressQueue: progressQueue,
  149|      0|            completion: completion
  150|      0|        )
  151|      0|    }
  152|       |
  153|       |    /// Asynchronously downloads an image from the specified URL request and sets it once the request is finished.
  154|       |    ///
  155|       |    /// If the image is cached locally, the image is set immediately. Otherwise the specified placeholder image will be
  156|       |    /// set immediately, and then the remote image will be set once the image request is finished.
  157|       |    ///
  158|       |    /// - parameter state:            The control state of the button to set the image on.
  159|       |    /// - parameter urlRequest:       The URL request.
  160|       |    /// - parameter placeholderImage: The image to be set initially until the image request finished. If `nil`, the
  161|       |    ///                               image will not change its image until the image request finishes. Defaults
  162|       |    ///                               to `nil`.
  163|       |    /// - parameter filter:           The image filter applied to the image after the image request is finished.
  164|       |    ///                               Defaults to `nil`.
  165|       |    /// - parameter progress:         The closure to be executed periodically during the lifecycle of the request.
  166|       |    ///                               Defaults to `nil`.
  167|       |    /// - parameter progressQueue:    The dispatch queue to call the progress closure on. Defaults to the main queue.
  168|       |    /// - parameter completion:       A closure to be executed when the image request finishes. The closure takes a
  169|       |    ///                               single response value containing either the image or the error that occurred. If
  170|       |    ///                               the image was returned from the image cache, the response will be `nil`. Defaults
  171|       |    ///                               to `nil`.
  172|       |    public func af_setImage(
  173|       |        for state: ControlState,
  174|       |        urlRequest: URLRequestConvertible,
  175|       |        placeholderImage: UIImage? = nil,
  176|       |        filter: ImageFilter? = nil,
  177|       |        progress: ImageDownloader.ProgressHandler? = nil,
  178|       |        progressQueue: DispatchQueue = DispatchQueue.main,
  179|       |        completion: ((DataResponse<UIImage>) -> Void)? = nil)
  180|      0|    {
  181|      0|        guard !isImageURLRequest(urlRequest, equalToActiveRequestURLForState: state) else {
  182|      0|            let error = AFIError.requestCancelled
  183|      0|            let response = DataResponse<UIImage>(request: nil, response: nil, data: nil, result: .failure(error))
  184|      0|
  185|      0|            completion?(response)
  186|      0|
  187|      0|            return
  188|      0|        }
  189|      0|
  190|      0|        af_cancelImageRequest(for: state)
  191|      0|
  192|      0|        let imageDownloader = af_imageDownloader ?? UIButton.af_sharedImageDownloader
  193|      0|        let imageCache = imageDownloader.imageCache
  194|      0|
  195|      0|        // Use the image from the image cache if it exists
  196|      0|        if
  197|      0|            let request = urlRequest.urlRequest,
  198|      0|            let image = imageCache?.image(for: request, withIdentifier: filter?.identifier)
  199|      0|        {
  200|      0|            let response = DataResponse<UIImage>(
  201|      0|                request: urlRequest.urlRequest,
  202|      0|                response: nil,
  203|      0|                data: nil,
  204|      0|                result: .success(image)
  205|      0|            )
  206|      0|
  207|      0|            setImage(image, for: state)
  208|      0|            completion?(response)
  209|      0|
  210|      0|            return
  211|      0|        }
  212|      0|
  213|      0|        // Set the placeholder since we're going to have to download
  214|      0|        if let placeholderImage = placeholderImage { setImage(placeholderImage, for: state)  }
  215|      0|
  216|      0|        // Generate a unique download id to check whether the active request has changed while downloading
  217|      0|        let downloadID = UUID().uuidString
  218|      0|
  219|      0|        // Download the image, then set the image for the control state
  220|      0|        let requestReceipt = imageDownloader.download(
  221|      0|            urlRequest,
  222|      0|            receiptID: downloadID,
  223|      0|            filter: filter,
  224|      0|            progress: progress,
  225|      0|            progressQueue: progressQueue,
  226|      0|            completion: { [weak self] response in
  227|      0|                guard
  228|      0|                    let strongSelf = self,
  229|      0|                    strongSelf.isImageURLRequest(response.request, equalToActiveRequestURLForState: state) &&
  230|      0|                    strongSelf.imageRequestReceipt(for: state)?.receiptID == downloadID
  231|      0|                else {
  232|      0|                    completion?(response)
  233|      0|                    return
  234|      0|                }
  235|      0|
  236|      0|                if let image = response.result.value {
  237|      0|                    strongSelf.setImage(image, for: state)
  238|      0|                }
  239|      0|
  240|      0|                strongSelf.setImageRequestReceipt(nil, for: state)
  241|      0|
  242|      0|                completion?(response)
  243|      0|            }
  244|      0|        )
  245|      0|
  246|      0|        setImageRequestReceipt(requestReceipt, for: state)
  247|      0|    }
  248|       |
  249|       |    /// Cancels the active download request for the image, if one exists.
  250|      0|    public func af_cancelImageRequest(for state: ControlState) {
  251|      0|        guard let receipt = imageRequestReceipt(for: state) else { return }
  252|      0|
  253|      0|        let imageDownloader = af_imageDownloader ?? UIButton.af_sharedImageDownloader
  254|      0|        imageDownloader.cancelRequest(with: receipt)
  255|      0|
  256|      0|        setImageRequestReceipt(nil, for: state)
  257|      0|    }
  258|       |
  259|       |    // MARK: - Background Image Downloads
  260|       |
  261|       |    /// Asynchronously downloads an image from the specified URL and sets it once the request is finished.
  262|       |    ///
  263|       |    /// If the image is cached locally, the image is set immediately. Otherwise the specified placeholder image will be
  264|       |    /// set immediately, and then the remote image will be set once the image request is finished.
  265|       |    ///
  266|       |    /// - parameter state:            The control state of the button to set the image on.
  267|       |    /// - parameter url:              The URL used for the image request.
  268|       |    /// - parameter placeholderImage: The image to be set initially until the image request finished. If `nil`, the
  269|       |    ///                               background image will not change its image until the image request finishes.
  270|       |    ///                               Defaults to `nil`.
  271|       |    /// - parameter filter:           The image filter applied to the image after the image request is finished.
  272|       |    ///                               Defaults to `nil`.
  273|       |    /// - parameter progress:         The closure to be executed periodically during the lifecycle of the request.
  274|       |    ///                               Defaults to `nil`.
  275|       |    /// - parameter progressQueue:    The dispatch queue to call the progress closure on. Defaults to the main queue.
  276|       |    /// - parameter completion:       A closure to be executed when the image request finishes. The closure takes a
  277|       |    ///                               single response value containing either the image or the error that occurred. If
  278|       |    ///                               the image was returned from the image cache, the response will be `nil`. Defaults
  279|       |    ///                               to `nil`.
  280|       |    public func af_setBackgroundImage(
  281|       |        for state: ControlState,
  282|       |        url: URL,
  283|       |        placeholderImage: UIImage? = nil,
  284|       |        filter: ImageFilter? = nil,
  285|       |        progress: ImageDownloader.ProgressHandler? = nil,
  286|       |        progressQueue: DispatchQueue = DispatchQueue.main,
  287|       |        completion: ((DataResponse<UIImage>) -> Void)? = nil)
  288|      0|    {
  289|      0|        af_setBackgroundImage(
  290|      0|            for: state,
  291|      0|            urlRequest: urlRequest(with: url),
  292|      0|            placeholderImage: placeholderImage,
  293|      0|            filter: filter,
  294|      0|            progress: progress,
  295|      0|            progressQueue: progressQueue,
  296|      0|            completion: completion
  297|      0|        )
  298|      0|    }
  299|       |
  300|       |    /// Asynchronously downloads an image from the specified URL request and sets it once the request is finished.
  301|       |    ///
  302|       |    /// If the image is cached locally, the image is set immediately. Otherwise the specified placeholder image will be
  303|       |    /// set immediately, and then the remote image will be set once the image request is finished.
  304|       |    ///
  305|       |    /// - parameter state:            The control state of the button to set the image on.
  306|       |    /// - parameter urlRequest:       The URL request.
  307|       |    /// - parameter placeholderImage: The image to be set initially until the image request finished. If `nil`, the
  308|       |    ///                               background image will not change its image until the image request finishes.
  309|       |    ///                               Defaults to `nil`.
  310|       |    /// - parameter filter:           The image filter applied to the image after the image request is finished.
  311|       |    ///                               Defaults to `nil`.
  312|       |    /// - parameter progress:         The closure to be executed periodically during the lifecycle of the request.
  313|       |    ///                               Defaults to `nil`.
  314|       |    /// - parameter progressQueue:    The dispatch queue to call the progress closure on. Defaults to the main queue.
  315|       |    /// - parameter completion:       A closure to be executed when the image request finishes. The closure takes a
  316|       |    ///                               single response value containing either the image or the error that occurred. If
  317|       |    ///                               the image was returned from the image cache, the response will be `nil`. Defaults
  318|       |    ///                               to `nil`.
  319|       |    public func af_setBackgroundImage(
  320|       |        for state: ControlState,
  321|       |        urlRequest: URLRequestConvertible,
  322|       |        placeholderImage: UIImage? = nil,
  323|       |        filter: ImageFilter? = nil,
  324|       |        progress: ImageDownloader.ProgressHandler? = nil,
  325|       |        progressQueue: DispatchQueue = DispatchQueue.main,
  326|       |        completion: ((DataResponse<UIImage>) -> Void)? = nil)
  327|      0|    {
  328|      0|        guard !isImageURLRequest(urlRequest, equalToActiveRequestURLForState: state) else {
  329|      0|            let error = AFIError.requestCancelled
  330|      0|            let response = DataResponse<UIImage>(request: nil, response: nil, data: nil, result: .failure(error))
  331|      0|
  332|      0|            completion?(response)
  333|      0|
  334|      0|            return
  335|      0|        }
  336|      0|
  337|      0|        af_cancelBackgroundImageRequest(for: state)
  338|      0|
  339|      0|        let imageDownloader = af_imageDownloader ?? UIButton.af_sharedImageDownloader
  340|      0|        let imageCache = imageDownloader.imageCache
  341|      0|
  342|      0|        // Use the image from the image cache if it exists
  343|      0|        if
  344|      0|            let request = urlRequest.urlRequest,
  345|      0|            let image = imageCache?.image(for: request, withIdentifier: filter?.identifier)
  346|      0|        {
  347|      0|            let response = DataResponse<UIImage>(
  348|      0|                request: urlRequest.urlRequest,
  349|      0|                response: nil,
  350|      0|                data: nil,
  351|      0|                result: .success(image)
  352|      0|            )
  353|      0|
  354|      0|            setBackgroundImage(image, for: state)
  355|      0|            completion?(response)
  356|      0|
  357|      0|            return
  358|      0|        }
  359|      0|
  360|      0|        // Set the placeholder since we're going to have to download
  361|      0|        if let placeholderImage = placeholderImage { self.setBackgroundImage(placeholderImage, for: state)  }
  362|      0|
  363|      0|        // Generate a unique download id to check whether the active request has changed while downloading
  364|      0|        let downloadID = UUID().uuidString
  365|      0|
  366|      0|        // Download the image, then set the image for the control state
  367|      0|        let requestReceipt = imageDownloader.download(
  368|      0|            urlRequest,
  369|      0|            receiptID: downloadID,
  370|      0|            filter: nil,
  371|      0|            progress: progress,
  372|      0|            progressQueue: progressQueue,
  373|      0|            completion: { [weak self] response in
  374|      0|                guard
  375|      0|                    let strongSelf = self,
  376|      0|                    strongSelf.isBackgroundImageURLRequest(response.request, equalToActiveRequestURLForState: state) &&
  377|      0|                    strongSelf.backgroundImageRequestReceipt(for: state)?.receiptID == downloadID
  378|      0|                else {
  379|      0|                    completion?(response)
  380|      0|                    return
  381|      0|                }
  382|      0|
  383|      0|                if let image = response.result.value {
  384|      0|                    strongSelf.setBackgroundImage(image, for: state)
  385|      0|                }
  386|      0|
  387|      0|                strongSelf.setBackgroundImageRequestReceipt(nil, for: state)
  388|      0|
  389|      0|                completion?(response)
  390|      0|            }
  391|      0|        )
  392|      0|
  393|      0|        setBackgroundImageRequestReceipt(requestReceipt, for: state)
  394|      0|    }
  395|       |
  396|       |    /// Cancels the active download request for the background image, if one exists.
  397|      0|    public func af_cancelBackgroundImageRequest(for state: ControlState) {
  398|      0|        guard let receipt = backgroundImageRequestReceipt(for: state) else { return }
  399|      0|
  400|      0|        let imageDownloader = af_imageDownloader ?? UIButton.af_sharedImageDownloader
  401|      0|        imageDownloader.cancelRequest(with: receipt)
  402|      0|
  403|      0|        setBackgroundImageRequestReceipt(nil, for: state)
  404|      0|    }
  405|       |
  406|       |    // MARK: - Internal - Image Request Receipts
  407|       |
  408|      0|    func imageRequestReceipt(for state: ControlState) -> RequestReceipt? {
  409|      0|        guard let receipt = imageRequestReceipts[state.rawValue] else { return nil }
  410|      0|        return receipt
  411|      0|    }
  412|       |
  413|      0|    func setImageRequestReceipt(_ receipt: RequestReceipt?, for state: ControlState) {
  414|      0|        var receipts = imageRequestReceipts
  415|      0|        receipts[state.rawValue] = receipt
  416|      0|
  417|      0|        imageRequestReceipts = receipts
  418|      0|    }
  419|       |
  420|       |    // MARK: - Internal - Background Image Request Receipts
  421|       |
  422|      0|    func backgroundImageRequestReceipt(for state: ControlState) -> RequestReceipt? {
  423|      0|        guard let receipt = backgroundImageRequestReceipts[state.rawValue] else { return nil }
  424|      0|        return receipt
  425|      0|    }
  426|       |
  427|      0|    func setBackgroundImageRequestReceipt(_ receipt: RequestReceipt?, for state: ControlState) {
  428|      0|        var receipts = backgroundImageRequestReceipts
  429|      0|        receipts[state.rawValue] = receipt
  430|      0|
  431|      0|        backgroundImageRequestReceipts = receipts
  432|      0|    }
  433|       |
  434|       |    // MARK: - Private - URL Request Helpers
  435|       |
  436|       |    private func isImageURLRequest(
  437|       |        _ urlRequest: URLRequestConvertible?,
  438|       |        equalToActiveRequestURLForState state: ControlState)
  439|       |        -> Bool
  440|      0|    {
  441|      0|        if
  442|      0|            let currentURL = imageRequestReceipt(for: state)?.request.task?.originalRequest?.url,
  443|      0|            let requestURL = urlRequest?.urlRequest?.url,
  444|      0|            currentURL == requestURL
  445|      0|        {
  446|      0|            return true
  447|      0|        }
  448|      0|
  449|      0|        return false
  450|      0|    }
  451|       |
  452|       |    private func isBackgroundImageURLRequest(
  453|       |        _ urlRequest: URLRequestConvertible?,
  454|       |        equalToActiveRequestURLForState state: ControlState)
  455|       |        -> Bool
  456|      0|    {
  457|      0|        if
  458|      0|            let currentRequestURL = backgroundImageRequestReceipt(for: state)?.request.task?.originalRequest?.url,
  459|      0|            let requestURL = urlRequest?.urlRequest?.url,
  460|      0|            currentRequestURL == requestURL
  461|      0|        {
  462|      0|            return true
  463|      0|        }
  464|      0|
  465|      0|        return false
  466|      0|    }
  467|       |
  468|      0|    private func urlRequest(with url: URL) -> URLRequest {
  469|      0|        var urlRequest = URLRequest(url: url)
  470|      0|
  471|      0|        for mimeType in DataRequest.acceptableImageContentTypes {
  472|      0|            urlRequest.addValue(mimeType, forHTTPHeaderField: "Accept")
  473|      0|        }
  474|      0|
  475|      0|        return urlRequest
  476|      0|    }
  477|       |}
  478|       |
  479|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/AlamofireImage/Source/UIImage+AlamofireImage.swift:
    1|       |//
    2|       |//  UIImage+AlamofireImage.swift
    3|       |//
    4|       |//  Copyright (c) 2015-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |#if os(iOS) || os(tvOS) || os(watchOS)
   26|       |
   27|       |import CoreGraphics
   28|       |import Foundation
   29|       |import UIKit
   30|       |
   31|       |// MARK: Initialization
   32|       |
   33|       |private let lock = NSLock()
   34|       |
   35|       |extension UIImage {
   36|       |    /// Initializes and returns the image object with the specified data in a thread-safe manner.
   37|       |    ///
   38|       |    /// It has been reported that there are thread-safety issues when initializing large amounts of images
   39|       |    /// simultaneously. In the event of these issues occurring, this method can be used in place of
   40|       |    /// the `init?(data:)` method.
   41|       |    ///
   42|       |    /// - parameter data: The data object containing the image data.
   43|       |    ///
   44|       |    /// - returns: An initialized `UIImage` object, or `nil` if the method failed.
   45|      0|    public static func af_threadSafeImage(with data: Data) -> UIImage? {
   46|      0|        lock.lock()
   47|      0|        let image = UIImage(data: data)
   48|      0|        lock.unlock()
   49|      0|
   50|      0|        return image
   51|      0|    }
   52|       |
   53|       |    /// Initializes and returns the image object with the specified data and scale in a thread-safe manner.
   54|       |    ///
   55|       |    /// It has been reported that there are thread-safety issues when initializing large amounts of images
   56|       |    /// simultaneously. In the event of these issues occurring, this method can be used in place of
   57|       |    /// the `init?(data:scale:)` method.
   58|       |    ///
   59|       |    /// - parameter data:  The data object containing the image data.
   60|       |    /// - parameter scale: The scale factor to assume when interpreting the image data. Applying a scale factor of 1.0
   61|       |    ///                    results in an image whose size matches the pixel-based dimensions of the image. Applying a
   62|       |    ///                    different scale factor changes the size of the image as reported by the size property.
   63|       |    ///
   64|       |    /// - returns: An initialized `UIImage` object, or `nil` if the method failed.
   65|    472|    public static func af_threadSafeImage(with data: Data, scale: CGFloat) -> UIImage? {
   66|    472|        lock.lock()
   67|    472|        let image = UIImage(data: data, scale: scale)
   68|    472|        lock.unlock()
   69|    472|
   70|    472|        return image
   71|    472|    }
   72|       |}
   73|       |
   74|       |// MARK: - Inflation
   75|       |
   76|       |extension UIImage {
   77|       |    private struct AssociatedKey {
   78|       |        static var inflated = "af_UIImage.Inflated"
   79|       |    }
   80|       |
   81|       |    /// Returns whether the image is inflated.
   82|       |    public var af_inflated: Bool {
   83|    472|        get {
   84|    472|            if let inflated = objc_getAssociatedObject(self, &AssociatedKey.inflated) as? Bool {
   85|      0|                return inflated
   86|    472|            } else {
   87|    472|                return false
   88|    472|            }
   89|      0|        }
   90|    472|        set {
   91|    472|            objc_setAssociatedObject(self, &AssociatedKey.inflated, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
   92|    472|        }
   93|       |    }
   94|       |
   95|       |    /// Inflates the underlying compressed image data to be backed by an uncompressed bitmap representation.
   96|       |    ///
   97|       |    /// Inflating compressed image formats (such as PNG or JPEG) can significantly improve drawing performance as it
   98|       |    /// allows a bitmap representation to be constructed in the background rather than on the main thread.
   99|    472|    public func af_inflate() {
  100|    472|        guard !af_inflated else { return }
  101|    472|
  102|    472|        af_inflated = true
  103|    472|        _ = cgImage?.dataProvider?.data
  104|    472|    }
  105|       |}
  106|       |
  107|       |// MARK: - Alpha
  108|       |
  109|       |extension UIImage {
  110|       |    /// Returns whether the image contains an alpha component.
  111|      0|    public var af_containsAlphaComponent: Bool {
  112|      0|        let alphaInfo = cgImage?.alphaInfo
  113|      0|
  114|      0|        return (
  115|      0|            alphaInfo == .first ||
  116|      0|            alphaInfo == .last ||
  117|      0|            alphaInfo == .premultipliedFirst ||
  118|      0|            alphaInfo == .premultipliedLast
  119|      0|        )
  120|      0|    }
  121|       |
  122|       |    /// Returns whether the image is opaque.
  123|      0|    public var af_isOpaque: Bool { return !af_containsAlphaComponent }
  124|       |}
  125|       |
  126|       |// MARK: - Scaling
  127|       |
  128|       |extension UIImage {
  129|       |    /// Returns a new version of the image scaled to the specified size.
  130|       |    ///
  131|       |    /// - parameter size: The size to use when scaling the new image.
  132|       |    ///
  133|       |    /// - returns: A new image object.
  134|      0|    public func af_imageScaled(to size: CGSize) -> UIImage {
  135|      0|        assert(size.width > 0 && size.height > 0, "You cannot safely scale an image to a zero width or height")
  136|      0|
  137|      0|        UIGraphicsBeginImageContextWithOptions(size, af_isOpaque, 0.0)
  138|      0|        draw(in: CGRect(origin: .zero, size: size))
  139|      0|
  140|      0|        let scaledImage = UIGraphicsGetImageFromCurrentImageContext() ?? self
  141|      0|        UIGraphicsEndImageContext()
  142|      0|
  143|      0|        return scaledImage
  144|      0|    }
  145|       |
  146|       |    /// Returns a new version of the image scaled from the center while maintaining the aspect ratio to fit within
  147|       |    /// a specified size.
  148|       |    ///
  149|       |    /// The resulting image contains an alpha component used to pad the width or height with the necessary transparent
  150|       |    /// pixels to fit the specified size. In high performance critical situations, this may not be the optimal approach.
  151|       |    /// To maintain an opaque image, you could compute the `scaledSize` manually, then use the `af_imageScaledToSize`
  152|       |    /// method in conjunction with a `.Center` content mode to achieve the same visual result.
  153|       |    ///
  154|       |    /// - parameter size: The size to use when scaling the new image.
  155|       |    ///
  156|       |    /// - returns: A new image object.
  157|      0|    public func af_imageAspectScaled(toFit size: CGSize) -> UIImage {
  158|      0|        assert(size.width > 0 && size.height > 0, "You cannot safely scale an image to a zero width or height")
  159|      0|
  160|      0|        let imageAspectRatio = self.size.width / self.size.height
  161|      0|        let canvasAspectRatio = size.width / size.height
  162|      0|
  163|      0|        var resizeFactor: CGFloat
  164|      0|
  165|      0|        if imageAspectRatio > canvasAspectRatio {
  166|      0|            resizeFactor = size.width / self.size.width
  167|      0|        } else {
  168|      0|            resizeFactor = size.height / self.size.height
  169|      0|        }
  170|      0|
  171|      0|        let scaledSize = CGSize(width: self.size.width * resizeFactor, height: self.size.height * resizeFactor)
  172|      0|        let origin = CGPoint(x: (size.width - scaledSize.width) / 2.0, y: (size.height - scaledSize.height) / 2.0)
  173|      0|
  174|      0|        UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
  175|      0|        draw(in: CGRect(origin: origin, size: scaledSize))
  176|      0|
  177|      0|        let scaledImage = UIGraphicsGetImageFromCurrentImageContext() ?? self
  178|      0|        UIGraphicsEndImageContext()
  179|      0|
  180|      0|        return scaledImage
  181|      0|    }
  182|       |
  183|       |    /// Returns a new version of the image scaled from the center while maintaining the aspect ratio to fill a
  184|       |    /// specified size. Any pixels that fall outside the specified size are clipped.
  185|       |    ///
  186|       |    /// - parameter size: The size to use when scaling the new image.
  187|       |    ///
  188|       |    /// - returns: A new image object.
  189|      0|    public func af_imageAspectScaled(toFill size: CGSize) -> UIImage {
  190|      0|        assert(size.width > 0 && size.height > 0, "You cannot safely scale an image to a zero width or height")
  191|      0|
  192|      0|        let imageAspectRatio = self.size.width / self.size.height
  193|      0|        let canvasAspectRatio = size.width / size.height
  194|      0|
  195|      0|        var resizeFactor: CGFloat
  196|      0|
  197|      0|        if imageAspectRatio > canvasAspectRatio {
  198|      0|            resizeFactor = size.height / self.size.height
  199|      0|        } else {
  200|      0|            resizeFactor = size.width / self.size.width
  201|      0|        }
  202|      0|
  203|      0|        let scaledSize = CGSize(width: self.size.width * resizeFactor, height: self.size.height * resizeFactor)
  204|      0|        let origin = CGPoint(x: (size.width - scaledSize.width) / 2.0, y: (size.height - scaledSize.height) / 2.0)
  205|      0|
  206|      0|        UIGraphicsBeginImageContextWithOptions(size, af_isOpaque, 0.0)
  207|      0|        draw(in: CGRect(origin: origin, size: scaledSize))
  208|      0|
  209|      0|        let scaledImage = UIGraphicsGetImageFromCurrentImageContext() ?? self
  210|      0|        UIGraphicsEndImageContext()
  211|      0|
  212|      0|        return scaledImage
  213|      0|    }
  214|       |}
  215|       |
  216|       |// MARK: - Rounded Corners
  217|       |
  218|       |extension UIImage {
  219|       |    /// Returns a new version of the image with the corners rounded to the specified radius.
  220|       |    ///
  221|       |    /// - parameter radius:                   The radius to use when rounding the new image.
  222|       |    /// - parameter divideRadiusByImageScale: Whether to divide the radius by the image scale. Set to `true` when the
  223|       |    ///                                       image has the same resolution for all screen scales such as @1x, @2x and
  224|       |    ///                                       @3x (i.e. single image from web server). Set to `false` for images loaded
  225|       |    ///                                       from an asset catalog with varying resolutions for each screen scale.
  226|       |    ///                                       `false` by default.
  227|       |    ///
  228|       |    /// - returns: A new image object.
  229|      0|    public func af_imageRounded(withCornerRadius radius: CGFloat, divideRadiusByImageScale: Bool = false) -> UIImage {
  230|      0|        UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
  231|      0|
  232|      0|        let scaledRadius = divideRadiusByImageScale ? radius / scale : radius
  233|      0|
  234|      0|        let clippingPath = UIBezierPath(roundedRect: CGRect(origin: CGPoint.zero, size: size), cornerRadius: scaledRadius)
  235|      0|        clippingPath.addClip()
  236|      0|
  237|      0|        draw(in: CGRect(origin: CGPoint.zero, size: size))
  238|      0|
  239|      0|        let roundedImage = UIGraphicsGetImageFromCurrentImageContext()!
  240|      0|        UIGraphicsEndImageContext()
  241|      0|
  242|      0|        return roundedImage
  243|      0|    }
  244|       |
  245|       |    /// Returns a new version of the image rounded into a circle.
  246|       |    ///
  247|       |    /// - returns: A new image object.
  248|      0|    public func af_imageRoundedIntoCircle() -> UIImage {
  249|      0|        let radius = min(size.width, size.height) / 2.0
  250|      0|        var squareImage = self
  251|      0|
  252|      0|        if size.width != size.height {
  253|      0|            let squareDimension = min(size.width, size.height)
  254|      0|            let squareSize = CGSize(width: squareDimension, height: squareDimension)
  255|      0|            squareImage = af_imageAspectScaled(toFill: squareSize)
  256|      0|        }
  257|      0|
  258|      0|        UIGraphicsBeginImageContextWithOptions(squareImage.size, false, 0.0)
  259|      0|
  260|      0|        let clippingPath = UIBezierPath(
  261|      0|            roundedRect: CGRect(origin: CGPoint.zero, size: squareImage.size),
  262|      0|            cornerRadius: radius
  263|      0|        )
  264|      0|
  265|      0|        clippingPath.addClip()
  266|      0|
  267|      0|        squareImage.draw(in: CGRect(origin: CGPoint.zero, size: squareImage.size))
  268|      0|
  269|      0|        let roundedImage = UIGraphicsGetImageFromCurrentImageContext()!
  270|      0|        UIGraphicsEndImageContext()
  271|      0|
  272|      0|        return roundedImage
  273|      0|    }
  274|       |}
  275|       |
  276|       |#endif
  277|       |
  278|       |#if os(iOS) || os(tvOS)
  279|       |
  280|       |import CoreImage
  281|       |
  282|       |// MARK: - Core Image Filters
  283|       |
  284|       |@available(iOS 9.0, *)
  285|       |extension UIImage {
  286|       |    /// Returns a new version of the image using a CoreImage filter with the specified name and parameters.
  287|       |    ///
  288|       |    /// - parameter name:       The name of the CoreImage filter to use on the new image.
  289|       |    /// - parameter parameters: The parameters to apply to the CoreImage filter.
  290|       |    ///
  291|       |    /// - returns: A new image object, or `nil` if the filter failed for any reason.
  292|      0|    public func af_imageFiltered(withCoreImageFilter name: String, parameters: [String: Any]? = nil) -> UIImage? {
  293|      0|        var image: CoreImage.CIImage? = ciImage
  294|      0|
  295|      0|        if image == nil, let CGImage = self.cgImage {
  296|      0|            image = CoreImage.CIImage(cgImage: CGImage)
  297|      0|        }
  298|      0|
  299|      0|        guard let coreImage = image else { return nil }
  300|      0|
  301|      0|        #if swift(>=4.2)
  302|      0|        let context = CIContext(options: [.priorityRequestLow: true])
  303|      0|        #else
  304|      0|        let context = CIContext(options: [kCIContextPriorityRequestLow: true])
  305|      0|        #endif
  306|      0|
  307|      0|        var parameters: [String: Any] = parameters ?? [:]
  308|      0|        parameters[kCIInputImageKey] = coreImage
  309|      0|        #if swift(>=4.2)
  310|      0|        guard let filter = CIFilter(name: name, parameters: parameters) else { return nil }
  311|      0|        #else
  312|      0|        guard let filter = CIFilter(name: name, withInputParameters: parameters) else { return nil }
  313|      0|        #endif
  314|      0|        guard let outputImage = filter.outputImage else { return nil }
  315|      0|
  316|      0|        let cgImageRef = context.createCGImage(outputImage, from: outputImage.extent)
  317|      0|
  318|      0|        return UIImage(cgImage: cgImageRef!, scale: scale, orientation: imageOrientation)
  319|      0|    }
  320|       |}
  321|       |
  322|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/AlamofireImage/Source/UIImageView+AlamofireImage.swift:
    1|       |//
    2|       |//  UIImageView+AlamofireImage.swift
    3|       |//
    4|       |//  Copyright (c) 2015-2018 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Alamofire
   26|       |import Foundation
   27|       |
   28|       |#if os(iOS) || os(tvOS)
   29|       |
   30|       |import UIKit
   31|       |
   32|       |#if swift(>=4.2)
   33|       |public typealias AnimationOptions = UIView.AnimationOptions
   34|       |#else
   35|       |public typealias AnimationOptions = UIViewAnimationOptions
   36|       |#endif
   37|       |
   38|       |extension UIImageView {
   39|       |
   40|       |    // MARK: - ImageTransition
   41|       |
   42|       |    /// Used to wrap all `UIView` animation transition options alongside a duration.
   43|       |    public enum ImageTransition {
   44|       |        case noTransition
   45|       |        case crossDissolve(TimeInterval)
   46|       |        case curlDown(TimeInterval)
   47|       |        case curlUp(TimeInterval)
   48|       |        case flipFromBottom(TimeInterval)
   49|       |        case flipFromLeft(TimeInterval)
   50|       |        case flipFromRight(TimeInterval)
   51|       |        case flipFromTop(TimeInterval)
   52|       |        case custom(
   53|       |            duration: TimeInterval,
   54|       |            animationOptions: AnimationOptions,
   55|       |            animations: (UIImageView, Image) -> Void,
   56|       |            completion: ((Bool) -> Void)?
   57|       |        )
   58|       |
   59|       |        /// The duration of the image transition in seconds.
   60|      0|        public var duration: TimeInterval {
   61|      0|            switch self {
   62|      0|            case .noTransition:
   63|      0|                return 0.0
   64|      0|            case .crossDissolve(let duration):
   65|      0|                return duration
   66|      0|            case .curlDown(let duration):
   67|      0|                return duration
   68|      0|            case .curlUp(let duration):
   69|      0|                return duration
   70|      0|            case .flipFromBottom(let duration):
   71|      0|                return duration
   72|      0|            case .flipFromLeft(let duration):
   73|      0|                return duration
   74|      0|            case .flipFromRight(let duration):
   75|      0|                return duration
   76|      0|            case .flipFromTop(let duration):
   77|      0|                return duration
   78|      0|            case .custom(let duration, _, _, _):
   79|      0|                return duration
   80|      0|            }
   81|      0|        }
   82|       |
   83|       |        /// The animation options of the image transition.
   84|      0|        public var animationOptions: AnimationOptions {
   85|      0|            switch self {
   86|      0|            case .noTransition:
   87|      0|                return []
   88|      0|            case .crossDissolve:
   89|      0|                return .transitionCrossDissolve
   90|      0|            case .curlDown:
   91|      0|                return .transitionCurlDown
   92|      0|            case .curlUp:
   93|      0|                return .transitionCurlUp
   94|      0|            case .flipFromBottom:
   95|      0|                return .transitionFlipFromBottom
   96|      0|            case .flipFromLeft:
   97|      0|                return .transitionFlipFromLeft
   98|      0|            case .flipFromRight:
   99|      0|                return .transitionFlipFromRight
  100|      0|            case .flipFromTop:
  101|      0|                return .transitionFlipFromTop
  102|      0|            case .custom(_, let animationOptions, _, _):
  103|      0|                return animationOptions
  104|      0|            }
  105|      0|        }
  106|       |
  107|       |        /// The animation options of the image transition.
  108|      0|        public var animations: ((UIImageView, Image) -> Void) {
  109|      0|            switch self {
  110|      0|            case .custom(_, _, let animations, _):
  111|      0|                return animations
  112|      0|            default:
  113|      0|                return { $0.image = $1 }
  114|      0|            }
  115|      0|        }
  116|       |
  117|       |        /// The completion closure associated with the image transition.
  118|      0|        public var completion: ((Bool) -> Void)? {
  119|      0|            switch self {
  120|      0|            case .custom(_, _, _, let completion):
  121|      0|                return completion
  122|      0|            default:
  123|      0|                return nil
  124|      0|            }
  125|      0|        }
  126|       |    }
  127|       |
  128|       |    // MARK: - Private - AssociatedKeys
  129|       |
  130|       |    private struct AssociatedKey {
  131|       |        static var imageDownloader = "af_UIImageView.ImageDownloader"
  132|       |        static var sharedImageDownloader = "af_UIImageView.SharedImageDownloader"
  133|       |        static var activeRequestReceipt = "af_UIImageView.ActiveRequestReceipt"
  134|       |    }
  135|       |
  136|       |    // MARK: - Associated Properties
  137|       |
  138|       |    /// The instance image downloader used to download all images. If this property is `nil`, the `UIImageView` will
  139|       |    /// fallback on the `af_sharedImageDownloader` for all downloads. The most common use case for needing to use a
  140|       |    /// custom instance image downloader is when images are behind different basic auth credentials.
  141|       |    public var af_imageDownloader: ImageDownloader? {
  142|      0|        get {
  143|      0|            return objc_getAssociatedObject(self, &AssociatedKey.imageDownloader) as? ImageDownloader
  144|      0|        }
  145|      0|        set(downloader) {
  146|      0|            objc_setAssociatedObject(self, &AssociatedKey.imageDownloader, downloader, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  147|      0|        }
  148|       |    }
  149|       |
  150|       |    /// The shared image downloader used to download all images. By default, this is the default `ImageDownloader`
  151|       |    /// instance backed with an `AutoPurgingImageCache` which automatically evicts images from the cache when the memory
  152|       |    /// capacity is reached or memory warning notifications occur. The shared image downloader is only used if the
  153|       |    /// `af_imageDownloader` is `nil`.
  154|       |    public class var af_sharedImageDownloader: ImageDownloader {
  155|      0|        get {
  156|      0|            if let downloader = objc_getAssociatedObject(self, &AssociatedKey.sharedImageDownloader) as? ImageDownloader {
  157|      0|                return downloader
  158|      0|            } else {
  159|      0|                return ImageDownloader.default
  160|      0|            }
  161|      0|        }
  162|      0|        set {
  163|      0|            objc_setAssociatedObject(self, &AssociatedKey.sharedImageDownloader, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  164|      0|        }
  165|       |    }
  166|       |
  167|       |    var af_activeRequestReceipt: RequestReceipt? {
  168|      0|        get {
  169|      0|            return objc_getAssociatedObject(self, &AssociatedKey.activeRequestReceipt) as? RequestReceipt
  170|      0|        }
  171|      0|        set {
  172|      0|            objc_setAssociatedObject(self, &AssociatedKey.activeRequestReceipt, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  173|      0|        }
  174|       |    }
  175|       |
  176|       |    // MARK: - Image Download
  177|       |
  178|       |    /// Asynchronously downloads an image from the specified URL, applies the specified image filter to the downloaded
  179|       |    /// image and sets it once finished while executing the image transition.
  180|       |    ///
  181|       |    /// If the image is cached locally, the image is set immediately. Otherwise the specified placeholder image will be
  182|       |    /// set immediately, and then the remote image will be set once the image request is finished.
  183|       |    ///
  184|       |    /// The `completion` closure is called after the image download and filtering are complete, but before the start of
  185|       |    /// the image transition. Please note it is no longer the responsibility of the `completion` closure to set the
  186|       |    /// image. It will be set automatically. If you require a second notification after the image transition completes,
  187|       |    /// use a `.Custom` image transition with a `completion` closure. The `.Custom` `completion` closure is called when
  188|       |    /// the image transition is finished.
  189|       |    ///
  190|       |    /// - parameter url:                        The URL used for the image request.
  191|       |    /// - parameter placeholderImage:           The image to be set initially until the image request finished. If
  192|       |    ///                                         `nil`, the image view will not change its image until the image
  193|       |    ///                                         request finishes. Defaults to `nil`.
  194|       |    /// - parameter filter:                     The image filter applied to the image after the image request is
  195|       |    ///                                         finished. Defaults to `nil`.
  196|       |    /// - parameter progress:                   The closure to be executed periodically during the lifecycle of the
  197|       |    ///                                         request. Defaults to `nil`.
  198|       |    /// - parameter progressQueue:              The dispatch queue to call the progress closure on. Defaults to the
  199|       |    ///                                         main queue.
  200|       |    /// - parameter imageTransition:            The image transition animation applied to the image when set.
  201|       |    ///                                         Defaults to `.None`.
  202|       |    /// - parameter runImageTransitionIfCached: Whether to run the image transition if the image is cached. Defaults
  203|       |    ///                                         to `false`.
  204|       |    /// - parameter completion:                 A closure to be executed when the image request finishes. The closure
  205|       |    ///                                         has no return value and takes three arguments: the original request,
  206|       |    ///                                         the response from the server and the result containing either the
  207|       |    ///                                         image or the error that occurred. If the image was returned from the
  208|       |    ///                                         image cache, the response will be `nil`. Defaults to `nil`.
  209|       |    public func af_setImage(
  210|       |        withURL url: URL,
  211|       |        placeholderImage: UIImage? = nil,
  212|       |        filter: ImageFilter? = nil,
  213|       |        progress: ImageDownloader.ProgressHandler? = nil,
  214|       |        progressQueue: DispatchQueue = DispatchQueue.main,
  215|       |        imageTransition: ImageTransition = .noTransition,
  216|       |        runImageTransitionIfCached: Bool = false,
  217|       |        completion: ((DataResponse<UIImage>) -> Void)? = nil)
  218|      0|    {
  219|      0|        af_setImage(
  220|      0|            withURLRequest: urlRequest(with: url),
  221|      0|            placeholderImage: placeholderImage,
  222|      0|            filter: filter,
  223|      0|            progress: progress,
  224|      0|            progressQueue: progressQueue,
  225|      0|            imageTransition: imageTransition,
  226|      0|            runImageTransitionIfCached: runImageTransitionIfCached,
  227|      0|            completion: completion
  228|      0|        )
  229|      0|    }
  230|       |
  231|       |    /// Asynchronously downloads an image from the specified URL Request, applies the specified image filter to the downloaded
  232|       |    /// image and sets it once finished while executing the image transition.
  233|       |    ///
  234|       |    /// If the image is cached locally, the image is set immediately. Otherwise the specified placeholder image will be
  235|       |    /// set immediately, and then the remote image will be set once the image request is finished.
  236|       |    ///
  237|       |    /// The `completion` closure is called after the image download and filtering are complete, but before the start of
  238|       |    /// the image transition. Please note it is no longer the responsibility of the `completion` closure to set the
  239|       |    /// image. It will be set automatically. If you require a second notification after the image transition completes,
  240|       |    /// use a `.Custom` image transition with a `completion` closure. The `.Custom` `completion` closure is called when
  241|       |    /// the image transition is finished.
  242|       |    ///
  243|       |    /// - parameter urlRequest:                 The URL request.
  244|       |    /// - parameter placeholderImage:           The image to be set initially until the image request finished. If
  245|       |    ///                                         `nil`, the image view will not change its image until the image
  246|       |    ///                                         request finishes. Defaults to `nil`.
  247|       |    /// - parameter filter:                     The image filter applied to the image after the image request is
  248|       |    ///                                         finished. Defaults to `nil`.
  249|       |    /// - parameter progress:                   The closure to be executed periodically during the lifecycle of the
  250|       |    ///                                         request. Defaults to `nil`.
  251|       |    /// - parameter progressQueue:              The dispatch queue to call the progress closure on. Defaults to the
  252|       |    ///                                         main queue.
  253|       |    /// - parameter imageTransition:            The image transition animation applied to the image when set.
  254|       |    ///                                         Defaults to `.None`.
  255|       |    /// - parameter runImageTransitionIfCached: Whether to run the image transition if the image is cached. Defaults
  256|       |    ///                                         to `false`.
  257|       |    /// - parameter completion:                 A closure to be executed when the image request finishes. The closure
  258|       |    ///                                         has no return value and takes three arguments: the original request,
  259|       |    ///                                         the response from the server and the result containing either the
  260|       |    ///                                         image or the error that occurred. If the image was returned from the
  261|       |    ///                                         image cache, the response will be `nil`. Defaults to `nil`.
  262|       |    public func af_setImage(
  263|       |        withURLRequest urlRequest: URLRequestConvertible,
  264|       |        placeholderImage: UIImage? = nil,
  265|       |        filter: ImageFilter? = nil,
  266|       |        progress: ImageDownloader.ProgressHandler? = nil,
  267|       |        progressQueue: DispatchQueue = DispatchQueue.main,
  268|       |        imageTransition: ImageTransition = .noTransition,
  269|       |        runImageTransitionIfCached: Bool = false,
  270|       |        completion: ((DataResponse<UIImage>) -> Void)? = nil)
  271|      0|    {
  272|      0|        guard !isURLRequestURLEqualToActiveRequestURL(urlRequest) else {
  273|      0|            let error = AFIError.requestCancelled
  274|      0|            let response = DataResponse<UIImage>(request: nil, response: nil, data: nil, result: .failure(error))
  275|      0|
  276|      0|            completion?(response)
  277|      0|
  278|      0|            return
  279|      0|        }
  280|      0|
  281|      0|        af_cancelImageRequest()
  282|      0|
  283|      0|        let imageDownloader = af_imageDownloader ?? UIImageView.af_sharedImageDownloader
  284|      0|        let imageCache = imageDownloader.imageCache
  285|      0|
  286|      0|        // Use the image from the image cache if it exists
  287|      0|        if
  288|      0|            let request = urlRequest.urlRequest,
  289|      0|            let image = imageCache?.image(for: request, withIdentifier: filter?.identifier)
  290|      0|        {
  291|      0|            let response = DataResponse<UIImage>(request: request, response: nil, data: nil, result: .success(image))
  292|      0|
  293|      0|            if runImageTransitionIfCached {
  294|      0|                let tinyDelay = DispatchTime.now() + Double(Int64(0.001 * Float(NSEC_PER_SEC))) / Double(NSEC_PER_SEC)
  295|      0|
  296|      0|                // Need to let the runloop cycle for the placeholder image to take affect
  297|      0|                DispatchQueue.main.asyncAfter(deadline: tinyDelay) {
  298|      0|                    self.run(imageTransition, with: image)
  299|      0|                    completion?(response)
  300|      0|                }
  301|      0|            } else {
  302|      0|                self.image = image
  303|      0|                completion?(response)
  304|      0|            }
  305|      0|
  306|      0|            return
  307|      0|        }
  308|      0|
  309|      0|        // Set the placeholder since we're going to have to download
  310|      0|        if let placeholderImage = placeholderImage { self.image = placeholderImage }
  311|      0|
  312|      0|        // Generate a unique download id to check whether the active request has changed while downloading
  313|      0|        let downloadID = UUID().uuidString
  314|      0|
  315|      0|        // Download the image, then run the image transition or completion handler
  316|      0|        let requestReceipt = imageDownloader.download(
  317|      0|            urlRequest,
  318|      0|            receiptID: downloadID,
  319|      0|            filter: filter,
  320|      0|            progress: progress,
  321|      0|            progressQueue: progressQueue,
  322|      0|            completion: { [weak self] response in
  323|      0|                guard
  324|      0|                    let strongSelf = self,
  325|      0|                    strongSelf.isURLRequestURLEqualToActiveRequestURL(response.request) &&
  326|      0|                    strongSelf.af_activeRequestReceipt?.receiptID == downloadID
  327|      0|                else {
  328|      0|                    completion?(response)
  329|      0|                    return
  330|      0|                }
  331|      0|
  332|      0|                if let image = response.result.value {
  333|      0|                    strongSelf.run(imageTransition, with: image)
  334|      0|                }
  335|      0|
  336|      0|                strongSelf.af_activeRequestReceipt = nil
  337|      0|
  338|      0|                completion?(response)
  339|      0|            }
  340|      0|        )
  341|      0|
  342|      0|        af_activeRequestReceipt = requestReceipt
  343|      0|    }
  344|       |
  345|       |    // MARK: - Image Download Cancellation
  346|       |
  347|       |    /// Cancels the active download request, if one exists.
  348|      0|    public func af_cancelImageRequest() {
  349|      0|        guard let activeRequestReceipt = af_activeRequestReceipt else { return }
  350|      0|
  351|      0|        let imageDownloader = af_imageDownloader ?? UIImageView.af_sharedImageDownloader
  352|      0|        imageDownloader.cancelRequest(with: activeRequestReceipt)
  353|      0|
  354|      0|        af_activeRequestReceipt = nil
  355|      0|    }
  356|       |
  357|       |    // MARK: - Image Transition
  358|       |
  359|       |    /// Runs the image transition on the image view with the specified image.
  360|       |    ///
  361|       |    /// - parameter imageTransition: The image transition to ran on the image view.
  362|       |    /// - parameter image:           The image to use for the image transition.
  363|      0|    public func run(_ imageTransition: ImageTransition, with image: Image) {
  364|      0|        UIView.transition(
  365|      0|            with: self,
  366|      0|            duration: imageTransition.duration,
  367|      0|            options: imageTransition.animationOptions,
  368|      0|            animations: { imageTransition.animations(self, image) },
  369|      0|            completion: imageTransition.completion
  370|      0|        )
  371|      0|    }
  372|       |
  373|       |    // MARK: - Private - URL Request Helper Methods
  374|       |
  375|      0|    private func urlRequest(with url: URL) -> URLRequest {
  376|      0|        var urlRequest = URLRequest(url: url)
  377|      0|
  378|      0|        for mimeType in DataRequest.acceptableImageContentTypes {
  379|      0|            urlRequest.addValue(mimeType, forHTTPHeaderField: "Accept")
  380|      0|        }
  381|      0|
  382|      0|        return urlRequest
  383|      0|    }
  384|       |
  385|      0|    private func isURLRequestURLEqualToActiveRequestURL(_ urlRequest: URLRequestConvertible?) -> Bool {
  386|      0|        if
  387|      0|            let currentRequestURL = af_activeRequestReceipt?.request.task?.originalRequest?.url,
  388|      0|            let requestURL = urlRequest?.urlRequest?.url,
  389|      0|            currentRequestURL == requestURL
  390|      0|        {
  391|      0|            return true
  392|      0|        }
  393|      0|
  394|      0|        return false
  395|      0|    }
  396|       |}
  397|       |
  398|       |#endif

