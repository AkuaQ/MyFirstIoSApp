/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GTMSessionFetcher/Source/GTMSessionFetcher.h:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |// GTMSessionFetcher is a wrapper around NSURLSession for http operations.
   17|       |//
   18|       |// What does this offer on top of of NSURLSession?
   19|       |//
   20|       |// - Block-style callbacks for useful functionality like progress rather
   21|       |//   than delegate methods.
   22|       |// - Out-of-process uploads and downloads using NSURLSession, including
   23|       |//   management of fetches after relaunch.
   24|       |// - Integration with GTMAppAuth for invisible management and refresh of
   25|       |//   authorization tokens.
   26|       |// - Pretty-printed http logging.
   27|       |// - Cookies handling that does not interfere with or get interfered with
   28|       |//   by WebKit cookies or on Mac by Safari and other apps.
   29|       |// - Credentials handling for the http operation.
   30|       |// - Rate-limiting and cookie grouping when fetchers are created with
   31|       |//   GTMSessionFetcherService.
   32|       |//
   33|       |// If the bodyData or bodyFileURL property is set, then a POST request is assumed.
   34|       |//
   35|       |// Each fetcher is assumed to be for a one-shot fetch request; don't reuse the object
   36|       |// for a second fetch.
   37|       |//
   38|       |// The fetcher will be self-retained as long as a connection is pending.
   39|       |//
   40|       |// To keep user activity private, URLs must have an https scheme (unless the property
   41|       |// allowedInsecureSchemes is set to permit the scheme.)
   42|       |//
   43|       |// Callbacks will be released when the fetch completes or is stopped, so there is no need
   44|       |// to use weak self references in the callback blocks.
   45|       |//
   46|       |// Sample usage:
   47|       |//
   48|       |//  _fetcherService = [[GTMSessionFetcherService alloc] init];
   49|       |//
   50|       |//  GTMSessionFetcher *myFetcher = [_fetcherService fetcherWithURLString:myURLString];
   51|       |//  myFetcher.retryEnabled = YES;
   52|       |//  myFetcher.comment = @"First profile image";
   53|       |//
   54|       |//  // Optionally specify a file URL or NSData for the request body to upload.
   55|       |//  myFetcher.bodyData = [postString dataUsingEncoding:NSUTF8StringEncoding];
   56|       |//
   57|       |//  [myFetcher beginFetchWithCompletionHandler:^(NSData *data, NSError *error) {
   58|       |//    if (error != nil) {
   59|       |//      // Server status code or network error.
   60|       |//      //
   61|       |//      // If the domain is kGTMSessionFetcherStatusDomain then the error code
   62|       |//      // is a failure status from the server.
   63|       |//    } else {
   64|       |//      // Fetch succeeded.
   65|       |//    }
   66|       |//  }];
   67|       |//
   68|       |// There is also a beginFetch call that takes a pointer and selector for the completion handler;
   69|       |// a pointer and selector is a better style when the callback is a substantial, separate method.
   70|       |//
   71|       |// NOTE:  Fetches may retrieve data from the server even though the server
   72|       |//        returned an error, so the criteria for success is a non-nil error.
   73|       |//        The completion handler is called when the server status is >= 300 with an NSError
   74|       |//        having domain kGTMSessionFetcherStatusDomain and code set to the server status.
   75|       |//
   76|       |//        Status codes are at <http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html>
   77|       |//
   78|       |//
   79|       |// Background session support:
   80|       |//
   81|       |// Out-of-process uploads and downloads may be created by setting the fetcher's
   82|       |// useBackgroundSession property. Data to be uploaded should be provided via
   83|       |// the uploadFileURL property; the download destination should be specified with
   84|       |// the destinationFileURL.  NOTE: Background upload files should be in a location
   85|       |// that will be valid even after the device is restarted, so the file should not
   86|       |// be uploaded from a system temporary or cache directory.
   87|       |//
   88|       |// Background session transfers are slower, and should typically be used only
   89|       |// for very large downloads or uploads (hundreds of megabytes).
   90|       |//
   91|       |// When background sessions are used in iOS apps, the application delegate must
   92|       |// pass through the parameters from UIApplicationDelegate's
   93|       |// application:handleEventsForBackgroundURLSession:completionHandler: to the
   94|       |// fetcher class.
   95|       |//
   96|       |// When the application has been relaunched, it may also create a new fetcher
   97|       |// instance to handle completion of the transfers.
   98|       |//
   99|       |//  - (void)application:(UIApplication *)application
  100|       |//      handleEventsForBackgroundURLSession:(NSString *)identifier
  101|       |//                        completionHandler:(void (^)())completionHandler {
  102|       |//    // Application was re-launched on completing an out-of-process download.
  103|       |//
  104|       |//    // Pass the URLSession info related to this re-launch to the fetcher class.
  105|       |//    [GTMSessionFetcher application:application
  106|       |//        handleEventsForBackgroundURLSession:identifier
  107|       |//                          completionHandler:completionHandler];
  108|       |//
  109|       |//    // Get a fetcher related to this re-launch and re-hook up a completionHandler to it.
  110|       |//    GTMSessionFetcher *fetcher = [GTMSessionFetcher fetcherWithSessionIdentifier:identifier];
  111|       |//    NSURL *destinationFileURL = fetcher.destinationFileURL;
  112|       |//    fetcher.completionHandler = ^(NSData *data, NSError *error) {
  113|       |//      [self downloadCompletedToFile:destinationFileURL error:error];
  114|       |//    };
  115|       |//  }
  116|       |//
  117|       |//
  118|       |// Threading and queue support:
  119|       |//
  120|       |// Networking always happens on a background thread; there is no advantage to
  121|       |// changing thread or queue to create or start a fetcher.
  122|       |//
  123|       |// Callbacks are run on the main thread; alternatively, the app may set the
  124|       |// fetcher's callbackQueue to a dispatch queue.
  125|       |//
  126|       |// Once the fetcher's beginFetch method has been called, the fetcher's methods and
  127|       |// properties may be accessed from any thread.
  128|       |//
  129|       |// Downloading to disk:
  130|       |//
  131|       |// To have downloaded data saved directly to disk, specify a file URL for the
  132|       |// destinationFileURL property.
  133|       |//
  134|       |// HTTP methods and headers:
  135|       |//
  136|       |// Alternative HTTP methods, like PUT, and custom headers can be specified by
  137|       |// creating the fetcher with an appropriate NSMutableURLRequest.
  138|       |//
  139|       |//
  140|       |// Caching:
  141|       |//
  142|       |// The fetcher avoids caching. That is best for API requests, but may hurt
  143|       |// repeat fetches of static data. Apps may enable a persistent disk cache by
  144|       |// customizing the config:
  145|       |//
  146|       |//  fetcher.configurationBlock = ^(GTMSessionFetcher *configFetcher,
  147|       |//                                 NSURLSessionConfiguration *config) {
  148|       |//    config.URLCache = [NSURLCache sharedURLCache];
  149|       |//  };
  150|       |//
  151|       |// Or use the standard system config to share cookie storage with web views
  152|       |// and to enable disk caching:
  153|       |//
  154|       |//  fetcher.configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
  155|       |//
  156|       |//
  157|       |// Cookies:
  158|       |//
  159|       |// There are three supported mechanisms for remembering cookies between fetches.
  160|       |//
  161|       |// By default, a standalone GTMSessionFetcher uses a mutable array held
  162|       |// statically to track cookies for all instantiated fetchers.  This avoids
  163|       |// cookies being set by servers for the application from interfering with
  164|       |// Safari and WebKit cookie settings, and vice versa.
  165|       |// The fetcher cookies are lost when the application quits.
  166|       |//
  167|       |// To rely instead on WebKit's global NSHTTPCookieStorage, set the fetcher's
  168|       |// cookieStorage property:
  169|       |//   myFetcher.cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
  170|       |//
  171|       |// To share cookies with other apps, use the method introduced in iOS 9/OS X 10.11:
  172|       |//   myFetcher.cookieStorage =
  173|       |//     [NSHTTPCookieStorage sharedCookieStorageForGroupContainerIdentifier:kMyCompanyContainedID];
  174|       |//
  175|       |// To ignore existing cookies and only have cookies related to the single fetch
  176|       |// be applied, make a temporary cookie storage object:
  177|       |//   myFetcher.cookieStorage = [[GTMSessionCookieStorage alloc] init];
  178|       |//
  179|       |// Note: cookies set while following redirects will be sent to the server, as
  180|       |// the redirects are followed by the fetcher.
  181|       |//
  182|       |// To completely disable cookies, similar to setting cookieStorageMethod to
  183|       |// kGTMHTTPFetcherCookieStorageMethodNone, adjust the session configuration
  184|       |// appropriately in the fetcher or fetcher service:
  185|       |//  fetcher.configurationBlock = ^(GTMSessionFetcher *configFetcher,
  186|       |//                                 NSURLSessionConfiguration *config) {
  187|       |//    config.HTTPCookieAcceptPolicy = NSHTTPCookieAcceptPolicyNever;
  188|       |//    config.HTTPShouldSetCookies = NO;
  189|       |//  };
  190|       |//
  191|       |// If the fetcher is created from a GTMSessionFetcherService object
  192|       |// then the cookie storage mechanism is set to use the cookie storage in the
  193|       |// service object rather than the static storage. Disabling cookies in the
  194|       |// session configuration set on a service object will disable cookies for all
  195|       |// fetchers created from that GTMSessionFetcherService object, since the session
  196|       |// configuration is propagated to the fetcher.
  197|       |//
  198|       |//
  199|       |// Monitoring data transfers.
  200|       |//
  201|       |// The fetcher supports a variety of properties for progress monitoring
  202|       |// progress with callback blocks.
  203|       |//  GTMSessionFetcherSendProgressBlock sendProgressBlock
  204|       |//  GTMSessionFetcherReceivedProgressBlock receivedProgressBlock
  205|       |//  GTMSessionFetcherDownloadProgressBlock downloadProgressBlock
  206|       |//
  207|       |// If supplied by the server, the anticipated total download size is available
  208|       |// as [[myFetcher response] expectedContentLength] (and may be -1 for unknown
  209|       |// download sizes.)
  210|       |//
  211|       |//
  212|       |// Automatic retrying of fetches
  213|       |//
  214|       |// The fetcher can optionally create a timer and reattempt certain kinds of
  215|       |// fetch failures (status codes 408, request timeout; 502, gateway failure;
  216|       |// 503, service unavailable; 504, gateway timeout; networking errors
  217|       |// NSURLErrorTimedOut and NSURLErrorNetworkConnectionLost.)  The user may
  218|       |// set a retry selector to customize the type of errors which will be retried.
  219|       |//
  220|       |// Retries are done in an exponential-backoff fashion (that is, after 1 second,
  221|       |// 2, 4, 8, and so on.)
  222|       |//
  223|       |// Enabling automatic retries looks like this:
  224|       |//  myFetcher.retryEnabled = YES;
  225|       |//
  226|       |// With retries enabled, the completion callbacks are called only
  227|       |// when no more retries will be attempted. Calling the fetcher's stopFetching
  228|       |// method will terminate the retry timer, without the finished or failure
  229|       |// selectors being invoked.
  230|       |//
  231|       |// Optionally, the client may set the maximum retry interval:
  232|       |//  myFetcher.maxRetryInterval = 60.0; // in seconds; default is 60 seconds
  233|       |//                                     // for downloads, 600 for uploads
  234|       |//
  235|       |// Servers should never send a 400 or 500 status for errors that are retryable
  236|       |// by clients, as those values indicate permanent failures. In nearly all
  237|       |// cases, the default standard retry behavior is correct for clients, and no
  238|       |// custom client retry behavior is needed or appropriate. Servers that send
  239|       |// non-retryable status codes and expect the client to retry the request are
  240|       |// faulty.
  241|       |//
  242|       |// Still, the client may provide a block to determine if a status code or other
  243|       |// error should be retried. The block returns YES to set the retry timer or NO
  244|       |// to fail without additional fetch attempts.
  245|       |//
  246|       |// The retry method may return the |suggestedWillRetry| argument to get the
  247|       |// default retry behavior.  Server status codes are present in the
  248|       |// error argument, and have the domain kGTMSessionFetcherStatusDomain. The
  249|       |// user's method may look something like this:
  250|       |//
  251|       |//  myFetcher.retryBlock = ^(BOOL suggestedWillRetry, NSError *error,
  252|       |//                           GTMSessionFetcherRetryResponse response) {
  253|       |//    // Perhaps examine error.domain and error.code, or fetcher.retryCount
  254|       |//    //
  255|       |//    // Respond with YES to start the retry timer, NO to proceed to the failure
  256|       |//    // callback, or suggestedWillRetry to get default behavior for the
  257|       |//    // current error domain and code values.
  258|       |//    response(suggestedWillRetry);
  259|       |//  };
  260|       |
  261|       |
  262|       |#import <Foundation/Foundation.h>
  263|       |
  264|       |#if TARGET_OS_IPHONE
  265|       |#import <UIKit/UIKit.h>
  266|       |#endif
  267|       |#if TARGET_OS_WATCH
  268|       |#import <WatchKit/WatchKit.h>
  269|       |#endif
  270|       |
  271|       |// By default it is stripped from non DEBUG builds. Developers can override
  272|       |// this in their project settings.
  273|       |#ifndef STRIP_GTM_FETCH_LOGGING
  274|       |  #if !DEBUG
  275|       |    #define STRIP_GTM_FETCH_LOGGING 1
  276|       |  #else
  277|       |    #define STRIP_GTM_FETCH_LOGGING 0
  278|       |  #endif
  279|       |#endif
  280|       |
  281|       |// Logs in debug builds.
  282|       |#ifndef GTMSESSION_LOG_DEBUG
  283|       |  #if DEBUG
  284|      0|    #define GTMSESSION_LOG_DEBUG(...) NSLog(__VA_ARGS__)
  285|       |  #else
  286|       |    #define GTMSESSION_LOG_DEBUG(...) do { } while (0)
  287|       |  #endif
  288|       |#endif
  289|       |
  290|       |// Asserts in debug builds (or logs in debug builds if GTMSESSION_ASSERT_AS_LOG
  291|       |// or NS_BLOCK_ASSERTIONS are defined.)
  292|       |#ifndef GTMSESSION_ASSERT_DEBUG
  293|       |  #if DEBUG && !defined(NS_BLOCK_ASSERTIONS) && !GTMSESSION_ASSERT_AS_LOG
  294|       |    #undef GTMSESSION_ASSERT_AS_LOG
  295|       |    #define GTMSESSION_ASSERT_AS_LOG 1
  296|       |  #endif
  297|       |
  298|       |  #if DEBUG && !GTMSESSION_ASSERT_AS_LOG
  299|       |    #define GTMSESSION_ASSERT_DEBUG(...) NSAssert(__VA_ARGS__)
  300|       |  #elif DEBUG
  301|    127|    #define GTMSESSION_ASSERT_DEBUG(pred, ...) if (!(pred)) { NSLog(__VA_ARGS__); }
  302|       |  #else
  303|       |    #define GTMSESSION_ASSERT_DEBUG(pred, ...) do { } while (0)
  304|       |  #endif
  305|       |#endif
  306|       |
  307|       |// Asserts in debug builds, logs in release builds (or logs in debug builds if
  308|       |// GTMSESSION_ASSERT_AS_LOG is defined.)
  309|       |#ifndef GTMSESSION_ASSERT_DEBUG_OR_LOG
  310|       |  #if DEBUG && !GTMSESSION_ASSERT_AS_LOG
  311|       |    #define GTMSESSION_ASSERT_DEBUG_OR_LOG(...) NSAssert(__VA_ARGS__)
  312|       |  #else
  313|      1|    #define GTMSESSION_ASSERT_DEBUG_OR_LOG(pred, ...) if (!(pred)) { NSLog(__VA_ARGS__); }
  314|       |  #endif
  315|       |#endif
  316|       |
  317|       |// Macro useful for examining messages from NSURLSession during debugging.
  318|       |#if 0
  319|       |#define GTM_LOG_SESSION_DELEGATE(...) GTMSESSION_LOG_DEBUG(__VA_ARGS__)
  320|       |#else
  321|       |#define GTM_LOG_SESSION_DELEGATE(...)
  322|       |#endif
  323|       |
  324|       |#ifndef GTM_NULLABLE
  325|       |  #if __has_feature(nullability)  // Available starting in Xcode 6.3
  326|       |    #define GTM_NULLABLE_TYPE __nullable
  327|       |    #define GTM_NONNULL_TYPE __nonnull
  328|       |    #define GTM_NULLABLE nullable
  329|       |    #define GTM_NONNULL_DECL nonnull  // GTM_NONNULL is used by GTMDefines.h
  330|       |    #define GTM_NULL_RESETTABLE null_resettable
  331|       |
  332|       |    #define GTM_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_BEGIN
  333|       |    #define GTM_ASSUME_NONNULL_END NS_ASSUME_NONNULL_END
  334|       |  #else
  335|       |    #define GTM_NULLABLE_TYPE
  336|       |    #define GTM_NONNULL_TYPE
  337|       |    #define GTM_NULLABLE
  338|       |    #define GTM_NONNULL_DECL
  339|       |    #define GTM_NULL_RESETTABLE
  340|       |    #define GTM_ASSUME_NONNULL_BEGIN
  341|       |    #define GTM_ASSUME_NONNULL_END
  342|       |  #endif  // __has_feature(nullability)
  343|       |#endif  // GTM_NULLABLE
  344|       |
  345|       |#ifndef GTM_DECLARE_GENERICS
  346|       |  #if __has_feature(objc_generics)
  347|       |    #define GTM_DECLARE_GENERICS 1
  348|       |  #else
  349|       |    #define GTM_DECLARE_GENERICS 0
  350|       |  #endif
  351|       |#endif
  352|       |
  353|       |#ifndef GTM_NSArrayOf
  354|       |  #if GTM_DECLARE_GENERICS
  355|       |    #define GTM_NSArrayOf(value) NSArray<value>
  356|       |    #define GTM_NSDictionaryOf(key, value) NSDictionary<key, value>
  357|       |  #else
  358|       |    #define GTM_NSArrayOf(value) NSArray
  359|       |    #define GTM_NSDictionaryOf(key, value) NSDictionary
  360|       |  #endif // __has_feature(objc_generics)
  361|       |#endif  // GTM_NSArrayOf
  362|       |
  363|       |// For iOS, the fetcher can declare itself a background task to allow fetches
  364|       |// to finish when the app leaves the foreground.
  365|       |//
  366|       |// (This is unrelated to providing a background configuration, which allows
  367|       |// out-of-process uploads and downloads.)
  368|       |//
  369|       |// To disallow use of background tasks during fetches, the target should define
  370|       |// GTM_BACKGROUND_TASK_FETCHING to 0, or alternatively may set the
  371|       |// skipBackgroundTask property to YES.
  372|       |#if TARGET_OS_IPHONE && !TARGET_OS_WATCH && !defined(GTM_BACKGROUND_TASK_FETCHING)
  373|       |  #define GTM_BACKGROUND_TASK_FETCHING 1
  374|       |#endif
  375|       |
  376|       |#ifdef __cplusplus
  377|       |extern "C" {
  378|       |#endif
  379|       |
  380|       |#if (TARGET_OS_TV \
  381|       |     || TARGET_OS_WATCH \
  382|       |     || (!TARGET_OS_IPHONE && defined(MAC_OS_X_VERSION_10_11) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_11) \
  383|       |     || (TARGET_OS_IPHONE && defined(__IPHONE_9_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_9_0))
  384|       |  #ifndef GTM_USE_SESSION_FETCHER
  385|       |    #define GTM_USE_SESSION_FETCHER 1
  386|       |  #endif
  387|       |#endif
  388|       |
  389|       |#if !defined(GTMBridgeFetcher)
  390|       |  // These bridge macros should be identical in GTMHTTPFetcher.h and GTMSessionFetcher.h
  391|       |  #if GTM_USE_SESSION_FETCHER
  392|       |  // Macros to new fetcher class.
  393|       |    #define GTMBridgeFetcher GTMSessionFetcher
  394|       |    #define GTMBridgeFetcherService GTMSessionFetcherService
  395|       |    #define GTMBridgeFetcherServiceProtocol GTMSessionFetcherServiceProtocol
  396|       |    #define GTMBridgeAssertValidSelector GTMSessionFetcherAssertValidSelector
  397|       |    #define GTMBridgeCookieStorage GTMSessionCookieStorage
  398|       |    #define GTMBridgeCleanedUserAgentString GTMFetcherCleanedUserAgentString
  399|       |    #define GTMBridgeSystemVersionString GTMFetcherSystemVersionString
  400|       |    #define GTMBridgeApplicationIdentifier GTMFetcherApplicationIdentifier
  401|       |    #define kGTMBridgeFetcherStatusDomain kGTMSessionFetcherStatusDomain
  402|       |    #define kGTMBridgeFetcherStatusBadRequest GTMSessionFetcherStatusBadRequest
  403|       |  #else
  404|       |    // Macros to old fetcher class.
  405|       |    #define GTMBridgeFetcher GTMHTTPFetcher
  406|       |    #define GTMBridgeFetcherService GTMHTTPFetcherService
  407|       |    #define GTMBridgeFetcherServiceProtocol GTMHTTPFetcherServiceProtocol
  408|       |    #define GTMBridgeAssertValidSelector GTMAssertSelectorNilOrImplementedWithArgs
  409|       |    #define GTMBridgeCookieStorage GTMCookieStorage
  410|       |    #define GTMBridgeCleanedUserAgentString GTMCleanedUserAgentString
  411|       |    #define GTMBridgeSystemVersionString GTMSystemVersionString
  412|       |    #define GTMBridgeApplicationIdentifier GTMApplicationIdentifier
  413|       |    #define kGTMBridgeFetcherStatusDomain kGTMHTTPFetcherStatusDomain
  414|       |    #define kGTMBridgeFetcherStatusBadRequest kGTMHTTPFetcherStatusBadRequest
  415|       |  #endif  // GTM_USE_SESSION_FETCHER
  416|       |#endif
  417|       |
  418|       |// When creating background sessions to perform out-of-process uploads and
  419|       |// downloads, on app launch any background sessions must be reconnected in
  420|       |// order to receive events that occurred while the app was not running.
  421|       |//
  422|       |// The fetcher will automatically attempt to recreate the sessions on app
  423|       |// start, but doing so reads from NSUserDefaults. This may have launch-time
  424|       |// performance impacts.
  425|       |//
  426|       |// To avoid launch performance impacts, on iPhone/iPad with iOS 13+ the
  427|       |// GTMSessionFetcher class will register for the app launch notification and
  428|       |// perform the reconnect then.
  429|       |//
  430|       |// Apps targeting Mac or older iOS SDKs can opt into the new behavior by defining
  431|       |// GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH=1.
  432|       |//
  433|       |// Apps targeting new SDKs can force the old behavior by defining
  434|       |// GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH = 0.
  435|       |#ifndef GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH
  436|       |  // Default to the on-launch behavior for iOS 13+.
  437|       |  #if TARGET_OS_IOS && defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_13_0
  438|       |    #define GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH 1
  439|       |  #else
  440|       |    #define GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH 0
  441|       |  #endif
  442|       |#endif
  443|       |
  444|       |GTM_ASSUME_NONNULL_BEGIN
  445|       |
  446|       |// Notifications
  447|       |//
  448|       |// Fetch started and stopped, and fetch retry delay started and stopped.
  449|       |extern NSString *const kGTMSessionFetcherStartedNotification;
  450|       |extern NSString *const kGTMSessionFetcherStoppedNotification;
  451|       |extern NSString *const kGTMSessionFetcherRetryDelayStartedNotification;
  452|       |extern NSString *const kGTMSessionFetcherRetryDelayStoppedNotification;
  453|       |
  454|       |// Completion handler notification. This is intended for use by code capturing
  455|       |// and replaying fetch requests and results for testing. For fetches where
  456|       |// destinationFileURL or accumulateDataBlock is set for the fetcher, the data
  457|       |// will be nil for successful fetches.
  458|       |//
  459|       |// This notification is posted on the main thread.
  460|       |extern NSString *const kGTMSessionFetcherCompletionInvokedNotification;
  461|       |extern NSString *const kGTMSessionFetcherCompletionDataKey;
  462|       |extern NSString *const kGTMSessionFetcherCompletionErrorKey;
  463|       |
  464|       |// Constants for NSErrors created by the fetcher (excluding server status errors,
  465|       |// and error objects originating in the OS.)
  466|       |extern NSString *const kGTMSessionFetcherErrorDomain;
  467|       |
  468|       |// The fetcher turns server error status values (3XX, 4XX, 5XX) into NSErrors
  469|       |// with domain kGTMSessionFetcherStatusDomain.
  470|       |//
  471|       |// Any server response body data accompanying the status error is added to the
  472|       |// userInfo dictionary with key kGTMSessionFetcherStatusDataKey.
  473|       |extern NSString *const kGTMSessionFetcherStatusDomain;
  474|       |extern NSString *const kGTMSessionFetcherStatusDataKey;
  475|       |extern NSString *const kGTMSessionFetcherStatusDataContentTypeKey;
  476|       |
  477|       |// When a fetch fails with an error, these keys are included in the error userInfo
  478|       |// dictionary if retries were attempted.
  479|       |extern NSString *const kGTMSessionFetcherNumberOfRetriesDoneKey;
  480|       |extern NSString *const kGTMSessionFetcherElapsedIntervalWithRetriesKey;
  481|       |
  482|       |// Background session support requires access to NSUserDefaults.
  483|       |// If [NSUserDefaults standardUserDefaults] doesn't yield the correct NSUserDefaults for your usage,
  484|       |// ie for an App Extension, then implement this class/method to return the correct NSUserDefaults.
  485|       |// https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW6
  486|       |@interface GTMSessionFetcherUserDefaultsFactory : NSObject
  487|       |
  488|       |+ (NSUserDefaults *)fetcherUserDefaults;
  489|       |
  490|       |@end
  491|       |
  492|       |#ifdef __cplusplus
  493|       |}
  494|       |#endif
  495|       |
  496|       |typedef NS_ENUM(NSInteger, GTMSessionFetcherError) {
  497|       |  GTMSessionFetcherErrorDownloadFailed = -1,
  498|       |  GTMSessionFetcherErrorUploadChunkUnavailable = -2,
  499|       |  GTMSessionFetcherErrorBackgroundExpiration = -3,
  500|       |  GTMSessionFetcherErrorBackgroundFetchFailed = -4,
  501|       |  GTMSessionFetcherErrorInsecureRequest = -5,
  502|       |  GTMSessionFetcherErrorTaskCreationFailed = -6,
  503|       |};
  504|       |
  505|       |typedef NS_ENUM(NSInteger, GTMSessionFetcherStatus) {
  506|       |  // Standard http status codes.
  507|       |  GTMSessionFetcherStatusNotModified = 304,
  508|       |  GTMSessionFetcherStatusBadRequest = 400,
  509|       |  GTMSessionFetcherStatusUnauthorized = 401,
  510|       |  GTMSessionFetcherStatusForbidden = 403,
  511|       |  GTMSessionFetcherStatusPreconditionFailed = 412
  512|       |};
  513|       |
  514|       |#ifdef __cplusplus
  515|       |extern "C" {
  516|       |#endif
  517|       |
  518|       |@class GTMSessionCookieStorage;
  519|       |@class GTMSessionFetcher;
  520|       |
  521|       |// The configuration block is for modifying the NSURLSessionConfiguration only.
  522|       |// DO NOT change any fetcher properties in the configuration block.
  523|       |typedef void (^GTMSessionFetcherConfigurationBlock)(GTMSessionFetcher *fetcher,
  524|       |                                                    NSURLSessionConfiguration *configuration);
  525|       |typedef void (^GTMSessionFetcherSystemCompletionHandler)(void);
  526|       |typedef void (^GTMSessionFetcherCompletionHandler)(NSData * GTM_NULLABLE_TYPE data,
  527|       |                                                   NSError * GTM_NULLABLE_TYPE error);
  528|       |typedef void (^GTMSessionFetcherBodyStreamProviderResponse)(NSInputStream *bodyStream);
  529|       |typedef void (^GTMSessionFetcherBodyStreamProvider)(GTMSessionFetcherBodyStreamProviderResponse response);
  530|       |typedef void (^GTMSessionFetcherDidReceiveResponseDispositionBlock)(NSURLSessionResponseDisposition disposition);
  531|       |typedef void (^GTMSessionFetcherDidReceiveResponseBlock)(NSURLResponse *response,
  532|       |                                                         GTMSessionFetcherDidReceiveResponseDispositionBlock dispositionBlock);
  533|       |typedef void (^GTMSessionFetcherChallengeDispositionBlock)(NSURLSessionAuthChallengeDisposition disposition,
  534|       |                                                           NSURLCredential * GTM_NULLABLE_TYPE credential);
  535|       |typedef void (^GTMSessionFetcherChallengeBlock)(GTMSessionFetcher *fetcher,
  536|       |                                                NSURLAuthenticationChallenge *challenge,
  537|       |                                                GTMSessionFetcherChallengeDispositionBlock dispositionBlock);
  538|       |typedef void (^GTMSessionFetcherWillRedirectResponse)(NSURLRequest * GTM_NULLABLE_TYPE redirectedRequest);
  539|       |typedef void (^GTMSessionFetcherWillRedirectBlock)(NSHTTPURLResponse *redirectResponse,
  540|       |                                                   NSURLRequest *redirectRequest,
  541|       |                                                   GTMSessionFetcherWillRedirectResponse response);
  542|       |typedef void (^GTMSessionFetcherAccumulateDataBlock)(NSData * GTM_NULLABLE_TYPE buffer);
  543|       |typedef void (^GTMSessionFetcherSimulateByteTransferBlock)(NSData * GTM_NULLABLE_TYPE buffer,
  544|       |                                                           int64_t bytesWritten,
  545|       |                                                           int64_t totalBytesWritten,
  546|       |                                                           int64_t totalBytesExpectedToWrite);
  547|       |typedef void (^GTMSessionFetcherReceivedProgressBlock)(int64_t bytesWritten,
  548|       |                                                       int64_t totalBytesWritten);
  549|       |typedef void (^GTMSessionFetcherDownloadProgressBlock)(int64_t bytesWritten,
  550|       |                                                       int64_t totalBytesWritten,
  551|       |                                                       int64_t totalBytesExpectedToWrite);
  552|       |typedef void (^GTMSessionFetcherSendProgressBlock)(int64_t bytesSent,
  553|       |                                                   int64_t totalBytesSent,
  554|       |                                                   int64_t totalBytesExpectedToSend);
  555|       |typedef void (^GTMSessionFetcherWillCacheURLResponseResponse)(NSCachedURLResponse * GTM_NULLABLE_TYPE cachedResponse);
  556|       |typedef void (^GTMSessionFetcherWillCacheURLResponseBlock)(NSCachedURLResponse *proposedResponse,
  557|       |                                                           GTMSessionFetcherWillCacheURLResponseResponse responseBlock);
  558|       |typedef void (^GTMSessionFetcherRetryResponse)(BOOL shouldRetry);
  559|       |typedef void (^GTMSessionFetcherRetryBlock)(BOOL suggestedWillRetry,
  560|       |                                            NSError * GTM_NULLABLE_TYPE error,
  561|       |                                            GTMSessionFetcherRetryResponse response);
  562|       |
  563|       |typedef void (^GTMSessionFetcherTestResponse)(NSHTTPURLResponse * GTM_NULLABLE_TYPE response,
  564|       |                                              NSData * GTM_NULLABLE_TYPE data,
  565|       |                                              NSError * GTM_NULLABLE_TYPE error);
  566|       |typedef void (^GTMSessionFetcherTestBlock)(GTMSessionFetcher *fetcherToTest,
  567|       |                                           GTMSessionFetcherTestResponse testResponse);
  568|       |
  569|       |void GTMSessionFetcherAssertValidSelector(id GTM_NULLABLE_TYPE obj, SEL GTM_NULLABLE_TYPE sel, ...);
  570|       |
  571|       |// Utility functions for applications self-identifying to servers via a
  572|       |// user-agent header
  573|       |
  574|       |// The "standard" user agent includes the application identifier, taken from the bundle,
  575|       |// followed by a space and the system version string. Pass nil to use +mainBundle as the source
  576|       |// of the bundle identifier.
  577|       |//
  578|       |// Applications may use this as a starting point for their own user agent strings, perhaps
  579|       |// with additional sections appended.  Use GTMFetcherCleanedUserAgentString() below to
  580|       |// clean up any string being added to the user agent.
  581|       |NSString *GTMFetcherStandardUserAgentString(NSBundle * GTM_NULLABLE_TYPE bundle);
  582|       |
  583|       |// Make a generic name and version for the current application, like
  584|       |// com.example.MyApp/1.2.3 relying on the bundle identifier and the
  585|       |// CFBundleShortVersionString or CFBundleVersion.
  586|       |//
  587|       |// The bundle ID may be overridden as the base identifier string by
  588|       |// adding to the bundle's Info.plist a "GTMUserAgentID" key.
  589|       |//
  590|       |// If no bundle ID or override is available, the process name preceded
  591|       |// by "proc_" is used.
  592|       |NSString *GTMFetcherApplicationIdentifier(NSBundle * GTM_NULLABLE_TYPE bundle);
  593|       |
  594|       |// Make an identifier like "MacOSX/10.7.1" or "iPod_Touch/4.1 hw/iPod1_1"
  595|       |NSString *GTMFetcherSystemVersionString(void);
  596|       |
  597|       |// Make a parseable user-agent identifier from the given string, replacing whitespace
  598|       |// and commas with underscores, and removing other characters that may interfere
  599|       |// with parsing of the full user-agent string.
  600|       |//
  601|       |// For example, @"[My App]" would become @"My_App"
  602|       |NSString *GTMFetcherCleanedUserAgentString(NSString *str);
  603|       |
  604|       |// Grab the data from an input stream. Since streams cannot be assumed to be rewindable,
  605|       |// this may be destructive; the caller can try to rewind the stream (by setting the
  606|       |// NSStreamFileCurrentOffsetKey property) or can just use the NSData to make a new
  607|       |// NSInputStream. This function is intended to facilitate testing rather than be used in
  608|       |// production.
  609|       |//
  610|       |// This function operates synchronously on the current thread. Depending on how the
  611|       |// input stream is implemented, it may be appropriate to dispatch to a different
  612|       |// queue before calling this function.
  613|       |//
  614|       |// Failure is indicated by a returned data value of nil.
  615|       |NSData * GTM_NULLABLE_TYPE GTMDataFromInputStream(NSInputStream *inputStream, NSError **outError);
  616|       |
  617|       |#ifdef __cplusplus
  618|       |}  // extern "C"
  619|       |#endif
  620|       |
  621|       |
  622|       |#if !GTM_USE_SESSION_FETCHER
  623|       |@protocol GTMHTTPFetcherServiceProtocol;
  624|       |#endif
  625|       |
  626|       |// This protocol allows abstract references to the fetcher service, primarily for
  627|       |// fetchers (which may be compiled without the fetcher service class present.)
  628|       |//
  629|       |// Apps should not need to use this protocol.
  630|       |@protocol GTMSessionFetcherServiceProtocol <NSObject>
  631|       |// This protocol allows us to call into the service without requiring
  632|       |// GTMSessionFetcherService sources in this project
  633|       |
  634|       |@property(atomic, strong) dispatch_queue_t callbackQueue;
  635|       |
  636|       |- (BOOL)fetcherShouldBeginFetching:(GTMSessionFetcher *)fetcher;
  637|       |- (void)fetcherDidCreateSession:(GTMSessionFetcher *)fetcher;
  638|       |- (void)fetcherDidBeginFetching:(GTMSessionFetcher *)fetcher;
  639|       |- (void)fetcherDidStop:(GTMSessionFetcher *)fetcher;
  640|       |
  641|       |- (GTMSessionFetcher *)fetcherWithRequest:(NSURLRequest *)request;
  642|       |- (BOOL)isDelayingFetcher:(GTMSessionFetcher *)fetcher;
  643|       |
  644|       |@property(atomic, assign) BOOL reuseSession;
  645|       |- (GTM_NULLABLE NSURLSession *)session;
  646|       |- (GTM_NULLABLE NSURLSession *)sessionForFetcherCreation;
  647|       |- (GTM_NULLABLE id<NSURLSessionDelegate>)sessionDelegate;
  648|       |- (GTM_NULLABLE NSDate *)stoppedAllFetchersDate;
  649|       |
  650|       |// Methods for compatibility with the old GTMHTTPFetcher.
  651|       |@property(atomic, readonly, strong, GTM_NULLABLE) NSOperationQueue *delegateQueue;
  652|       |
  653|       |@end  // @protocol GTMSessionFetcherServiceProtocol
  654|       |
  655|       |#ifndef GTM_FETCHER_AUTHORIZATION_PROTOCOL
  656|       |#define GTM_FETCHER_AUTHORIZATION_PROTOCOL 1
  657|       |@protocol GTMFetcherAuthorizationProtocol <NSObject>
  658|       |@required
  659|       |// This protocol allows us to call the authorizer without requiring its sources
  660|       |// in this project.
  661|       |- (void)authorizeRequest:(GTM_NULLABLE NSMutableURLRequest *)request
  662|       |                delegate:(id)delegate
  663|       |       didFinishSelector:(SEL)sel;
  664|       |
  665|       |- (void)stopAuthorization;
  666|       |
  667|       |- (void)stopAuthorizationForRequest:(NSURLRequest *)request;
  668|       |
  669|       |- (BOOL)isAuthorizingRequest:(NSURLRequest *)request;
  670|       |
  671|       |- (BOOL)isAuthorizedRequest:(NSURLRequest *)request;
  672|       |
  673|       |@property(atomic, strong, readonly, GTM_NULLABLE) NSString *userEmail;
  674|       |
  675|       |@optional
  676|       |
  677|       |// Indicate if authorization may be attempted. Even if this succeeds,
  678|       |// authorization may fail if the user's permissions have been revoked.
  679|       |@property(atomic, readonly) BOOL canAuthorize;
  680|       |
  681|       |// For development only, allow authorization of non-SSL requests, allowing
  682|       |// transmission of the bearer token unencrypted.
  683|       |@property(atomic, assign) BOOL shouldAuthorizeAllRequests;
  684|       |
  685|       |- (void)authorizeRequest:(GTM_NULLABLE NSMutableURLRequest *)request
  686|       |       completionHandler:(void (^)(NSError * GTM_NULLABLE_TYPE error))handler;
  687|       |
  688|       |#if GTM_USE_SESSION_FETCHER
  689|       |@property(atomic, weak, GTM_NULLABLE) id<GTMSessionFetcherServiceProtocol> fetcherService;
  690|       |#else
  691|       |@property(atomic, weak, GTM_NULLABLE) id<GTMHTTPFetcherServiceProtocol> fetcherService;
  692|       |#endif
  693|       |
  694|       |- (BOOL)primeForRefresh;
  695|       |
  696|       |@end
  697|       |#endif  // GTM_FETCHER_AUTHORIZATION_PROTOCOL
  698|       |
  699|       |#if GTM_BACKGROUND_TASK_FETCHING
  700|       |// A protocol for an alternative target for messages from GTMSessionFetcher to UIApplication.
  701|       |// Set the target using +[GTMSessionFetcher setSubstituteUIApplication:]
  702|       |@protocol GTMUIApplicationProtocol <NSObject>
  703|       |- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithName:(nullable NSString *)taskName
  704|       |                                        expirationHandler:(void(^ __nullable)(void))handler;
  705|       |- (void)endBackgroundTask:(UIBackgroundTaskIdentifier)identifier;
  706|       |@end
  707|       |#endif
  708|       |
  709|       |#pragma mark -
  710|       |
  711|       |// GTMSessionFetcher objects are used for async retrieval of an http get or post
  712|       |//
  713|       |// See additional comments at the beginning of this file
  714|       |@interface GTMSessionFetcher : NSObject <NSURLSessionDelegate>
  715|       |
  716|       |// Create a fetcher
  717|       |//
  718|       |// fetcherWithRequest will return an autoreleased fetcher, but if
  719|       |// the connection is successfully created, the connection should retain the
  720|       |// fetcher for the life of the connection as well. So the caller doesn't have
  721|       |// to retain the fetcher explicitly unless they want to be able to cancel it.
  722|       |+ (instancetype)fetcherWithRequest:(GTM_NULLABLE NSURLRequest *)request;
  723|       |
  724|       |// Convenience methods that make a request, like +fetcherWithRequest
  725|       |+ (instancetype)fetcherWithURL:(NSURL *)requestURL;
  726|       |+ (instancetype)fetcherWithURLString:(NSString *)requestURLString;
  727|       |
  728|       |// Methods for creating fetchers to continue previous fetches.
  729|       |+ (instancetype)fetcherWithDownloadResumeData:(NSData *)resumeData;
  730|       |+ (GTM_NULLABLE instancetype)fetcherWithSessionIdentifier:(NSString *)sessionIdentifier;
  731|       |
  732|       |// Returns an array of currently active fetchers for background sessions,
  733|       |// both restarted and newly created ones.
  734|       |+ (GTM_NSArrayOf(GTMSessionFetcher *) *)fetchersForBackgroundSessions;
  735|       |
  736|       |// Designated initializer.
  737|       |//
  738|       |// Applications should create fetchers with a "fetcherWith..." method on a fetcher
  739|       |// service or a class method, not with this initializer.
  740|       |//
  741|       |// The configuration should typically be nil. Applications needing to customize
  742|       |// the configuration may do so by setting the configurationBlock property.
  743|       |- (instancetype)initWithRequest:(GTM_NULLABLE NSURLRequest *)request
  744|       |                  configuration:(GTM_NULLABLE NSURLSessionConfiguration *)configuration;
  745|       |
  746|       |// The fetcher's request.  This may not be set after beginFetch has been invoked. The request
  747|       |// may change due to redirects.
  748|       |@property(atomic, strong, GTM_NULLABLE) NSURLRequest *request;
  749|       |
  750|       |// Set a header field value on the request. Header field value changes will not
  751|       |// affect a fetch after the fetch has begun.
  752|       |- (void)setRequestValue:(GTM_NULLABLE NSString *)value forHTTPHeaderField:(NSString *)field;
  753|       |
  754|       |// Data used for resuming a download task.
  755|       |@property(atomic, readonly, GTM_NULLABLE) NSData *downloadResumeData;
  756|       |
  757|       |// The configuration; this must be set before the fetch begins. If no configuration is
  758|       |// set or inherited from the fetcher service, then the fetcher uses an ephemeral config.
  759|       |//
  760|       |// NOTE: This property should typically be nil. Applications needing to customize
  761|       |// the configuration should do so by setting the configurationBlock property.
  762|       |// That allows the fetcher to pick an appropriate base configuration, with the
  763|       |// application setting only the configuration properties it needs to customize.
  764|       |@property(atomic, strong, GTM_NULLABLE) NSURLSessionConfiguration *configuration;
  765|       |
  766|       |// A block the client may use to customize the configuration used to create the session.
  767|       |//
  768|       |// This is called synchronously, either on the thread that begins the fetch or, during a retry,
  769|       |// on the main thread. The configuration block may be called repeatedly if multiple fetchers are
  770|       |// created.
  771|       |//
  772|       |// The configuration block is for modifying the NSURLSessionConfiguration only.
  773|       |// DO NOT change any fetcher properties in the configuration block. Fetcher properties
  774|       |// may be set in the fetcher service prior to fetcher creation, or on the fetcher prior
  775|       |// to invoking beginFetch.
  776|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherConfigurationBlock configurationBlock;
  777|       |
  778|       |// A session is created as needed by the fetcher.  A fetcher service object
  779|       |// may maintain sessions for multiple fetches to the same host.
  780|       |@property(atomic, strong, GTM_NULLABLE) NSURLSession *session;
  781|       |
  782|       |// The task in flight.
  783|       |@property(atomic, readonly, GTM_NULLABLE) NSURLSessionTask *sessionTask;
  784|       |
  785|       |// The background session identifier.
  786|       |@property(atomic, readonly, GTM_NULLABLE) NSString *sessionIdentifier;
  787|       |
  788|       |// Indicates a fetcher created to finish a background session task.
  789|       |@property(atomic, readonly) BOOL wasCreatedFromBackgroundSession;
  790|       |
  791|       |// Additional user-supplied data to encode into the session identifier. Since session identifier
  792|       |// length limits are unspecified, this should be kept small. Key names beginning with an underscore
  793|       |// are reserved for use by the fetcher.
  794|       |@property(atomic, strong, GTM_NULLABLE) GTM_NSDictionaryOf(NSString *, NSString *) *sessionUserInfo;
  795|       |
  796|       |// The human-readable description to be assigned to the task.
  797|       |@property(atomic, copy, GTM_NULLABLE) NSString *taskDescription;
  798|       |
  799|       |// The priority assigned to the task, if any.  Use NSURLSessionTaskPriorityLow,
  800|       |// NSURLSessionTaskPriorityDefault, or NSURLSessionTaskPriorityHigh.
  801|       |@property(atomic, assign) float taskPriority;
  802|       |
  803|       |// The fetcher encodes information used to resume a session in the session identifier.
  804|       |// This method, intended for internal use returns the encoded information.  The sessionUserInfo
  805|       |// dictionary is stored as identifier metadata.
  806|       |- (GTM_NULLABLE GTM_NSDictionaryOf(NSString *, NSString *) *)sessionIdentifierMetadata;
  807|       |
  808|       |#if TARGET_OS_IPHONE && !TARGET_OS_WATCH
  809|       |// The app should pass to this method the completion handler passed in the app delegate method
  810|       |// application:handleEventsForBackgroundURLSession:completionHandler:
  811|       |+ (void)application:(UIApplication *)application
  812|       |    handleEventsForBackgroundURLSession:(NSString *)identifier
  813|       |                      completionHandler:(GTMSessionFetcherSystemCompletionHandler)completionHandler;
  814|       |#endif
  815|       |
  816|       |// Indicate that a newly created session should be a background session.
  817|       |// A new session identifier will be created by the fetcher.
  818|       |//
  819|       |// Warning:  The only thing background sessions are for is rare download
  820|       |// of huge, batched files of data. And even just for those, there's a lot
  821|       |// of pain and hackery needed to get transfers to actually happen reliably
  822|       |// with background sessions.
  823|       |//
  824|       |// Don't try to upload or download in many background sessions, since the system
  825|       |// will impose an exponentially increasing time penalty to prevent the app from
  826|       |// getting too much background execution time.
  827|       |//
  828|       |// References:
  829|       |//
  830|       |//   "Moving to Fewer, Larger Transfers"
  831|       |//   https://forums.developer.apple.com/thread/14853
  832|       |//
  833|       |//   "NSURLSessionâ€™s Resume Rate Limiter"
  834|       |//   https://forums.developer.apple.com/thread/14854
  835|       |//
  836|       |//   "Background Session Task state persistence"
  837|       |//   https://forums.developer.apple.com/thread/11554
  838|       |//
  839|       |@property(atomic, assign) BOOL useBackgroundSession;
  840|       |
  841|       |// Indicates if the fetcher was started using a background session.
  842|       |@property(atomic, readonly, getter=isUsingBackgroundSession) BOOL usingBackgroundSession;
  843|       |
  844|       |// Indicates if uploads should use an upload task.  This is always set for file or stream-provider
  845|       |// bodies, but may be set explicitly for NSData bodies.
  846|       |@property(atomic, assign) BOOL useUploadTask;
  847|       |
  848|       |// Indicates that the fetcher is using a session that may be shared with other fetchers.
  849|       |@property(atomic, readonly) BOOL canShareSession;
  850|       |
  851|       |// By default, the fetcher allows only secure (https) schemes unless this
  852|       |// property is set, or the GTM_ALLOW_INSECURE_REQUESTS build flag is set.
  853|       |//
  854|       |// For example, during debugging when fetching from a development server that lacks SSL support,
  855|       |// this may be set to @[ @"http" ], or when the fetcher is used to retrieve local files,
  856|       |// this may be set to @[ @"file" ].
  857|       |//
  858|       |// This should be left as nil for release builds to avoid creating the opportunity for
  859|       |// leaking private user behavior and data.  If a server is providing insecure URLs
  860|       |// for fetching by the client app, report the problem as server security & privacy bug.
  861|       |//
  862|       |// For builds with the iOS 9/OS X 10.11 and later SDKs, this property is required only when
  863|       |// the app specifies NSAppTransportSecurity/NSAllowsArbitraryLoads in the main bundle's Info.plist.
  864|       |@property(atomic, copy, GTM_NULLABLE) GTM_NSArrayOf(NSString *) *allowedInsecureSchemes;
  865|       |
  866|       |// By default, the fetcher prohibits localhost requests unless this property is set,
  867|       |// or the GTM_ALLOW_INSECURE_REQUESTS build flag is set.
  868|       |//
  869|       |// For localhost requests, the URL scheme is not checked  when this property is set.
  870|       |//
  871|       |// For builds with the iOS 9/OS X 10.11 and later SDKs, this property is required only when
  872|       |// the app specifies NSAppTransportSecurity/NSAllowsArbitraryLoads in the main bundle's Info.plist.
  873|       |@property(atomic, assign) BOOL allowLocalhostRequest;
  874|       |
  875|       |// By default, the fetcher requires valid server certs.  This may be bypassed
  876|       |// temporarily for development against a test server with an invalid cert.
  877|       |@property(atomic, assign) BOOL allowInvalidServerCertificates;
  878|       |
  879|       |// Cookie storage object for this fetcher. If nil, the fetcher will use a static cookie
  880|       |// storage instance shared among fetchers. If this fetcher was created by a fetcher service
  881|       |// object, it will be set to use the service object's cookie storage. See Cookies section above for
  882|       |// the full discussion.
  883|       |//
  884|       |// Because as of Jan 2014 standalone instances of NSHTTPCookieStorage do not actually
  885|       |// store any cookies (Radar 15735276) we use our own subclass, GTMSessionCookieStorage,
  886|       |// to hold cookies in memory.
  887|       |@property(atomic, strong, GTM_NULLABLE) NSHTTPCookieStorage *cookieStorage;
  888|       |
  889|       |// Setting the credential is optional; it is used if the connection receives
  890|       |// an authentication challenge.
  891|       |@property(atomic, strong, GTM_NULLABLE) NSURLCredential *credential;
  892|       |
  893|       |// Setting the proxy credential is optional; it is used if the connection
  894|       |// receives an authentication challenge from a proxy.
  895|       |@property(atomic, strong, GTM_NULLABLE) NSURLCredential *proxyCredential;
  896|       |
  897|       |// If body data, body file URL, or body stream provider is not set, then a GET request
  898|       |// method is assumed.
  899|       |@property(atomic, strong, GTM_NULLABLE) NSData *bodyData;
  900|       |
  901|       |// File to use as the request body. This forces use of an upload task.
  902|       |@property(atomic, strong, GTM_NULLABLE) NSURL *bodyFileURL;
  903|       |
  904|       |// Length of body to send, expected or actual.
  905|       |@property(atomic, readonly) int64_t bodyLength;
  906|       |
  907|       |// The body stream provider may be called repeatedly to provide a body.
  908|       |// Setting a body stream provider forces use of an upload task.
  909|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherBodyStreamProvider bodyStreamProvider;
  910|       |
  911|       |// Object to add authorization to the request, if needed.
  912|       |//
  913|       |// This may not be changed once beginFetch has been invoked.
  914|       |@property(atomic, strong, GTM_NULLABLE) id<GTMFetcherAuthorizationProtocol> authorizer;
  915|       |
  916|       |// The service object that created and monitors this fetcher, if any.
  917|       |@property(atomic, strong) id<GTMSessionFetcherServiceProtocol> service;
  918|       |
  919|       |// The host, if any, used to classify this fetcher in the fetcher service.
  920|       |@property(atomic, copy, GTM_NULLABLE) NSString *serviceHost;
  921|       |
  922|       |// The priority, if any, used for starting fetchers in the fetcher service.
  923|       |//
  924|       |// Lower values are higher priority; the default is 0, and values may
  925|       |// be negative or positive. This priority affects only the start order of
  926|       |// fetchers that are being delayed by a fetcher service when the running fetchers
  927|       |// exceeds the service's maxRunningFetchersPerHost.  A priority of NSIntegerMin will
  928|       |// exempt this fetcher from delay.
  929|       |@property(atomic, assign) NSInteger servicePriority;
  930|       |
  931|       |// The delegate's optional didReceiveResponse block may be used to inspect or alter
  932|       |// the session task response.
  933|       |//
  934|       |// This is called on the callback queue.
  935|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherDidReceiveResponseBlock didReceiveResponseBlock;
  936|       |
  937|       |// The delegate's optional challenge block may be used to inspect or alter
  938|       |// the session task challenge.
  939|       |//
  940|       |// If this block is not set, the fetcher's default behavior for the NSURLSessionTask
  941|       |// didReceiveChallenge: delegate method is to use the fetcher's respondToChallenge: method
  942|       |// which relies on the fetcher's credential and proxyCredential properties.
  943|       |//
  944|       |// Warning: This may be called repeatedly if the challenge fails. Check
  945|       |// challenge.previousFailureCount to identify repeated invocations.
  946|       |//
  947|       |// This is called on the callback queue.
  948|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherChallengeBlock challengeBlock;
  949|       |
  950|       |// The delegate's optional willRedirect block may be used to inspect or alter
  951|       |// the redirection.
  952|       |//
  953|       |// This is called on the callback queue.
  954|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherWillRedirectBlock willRedirectBlock;
  955|       |
  956|       |// The optional send progress block reports body bytes uploaded.
  957|       |//
  958|       |// This is called on the callback queue.
  959|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherSendProgressBlock sendProgressBlock;
  960|       |
  961|       |// The optional accumulate block may be set by clients wishing to accumulate data
  962|       |// themselves rather than let the fetcher append each buffer to an NSData.
  963|       |//
  964|       |// When this is called with nil data (such as on redirect) the client
  965|       |// should empty its accumulation buffer.
  966|       |//
  967|       |// This is called on the callback queue.
  968|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherAccumulateDataBlock accumulateDataBlock;
  969|       |
  970|       |// The optional received progress block may be used to monitor data
  971|       |// received from a data task.
  972|       |//
  973|       |// This is called on the callback queue.
  974|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherReceivedProgressBlock receivedProgressBlock;
  975|       |
  976|       |// The delegate's optional downloadProgress block may be used to monitor download
  977|       |// progress in writing to disk.
  978|       |//
  979|       |// This is called on the callback queue.
  980|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherDownloadProgressBlock downloadProgressBlock;
  981|       |
  982|       |// The delegate's optional willCacheURLResponse block may be used to alter the cached
  983|       |// NSURLResponse. The user may prevent caching by passing nil to the block's response.
  984|       |//
  985|       |// This is called on the callback queue.
  986|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherWillCacheURLResponseBlock willCacheURLResponseBlock;
  987|       |
  988|       |// Enable retrying; see comments at the top of this file.  Setting
  989|       |// retryEnabled=YES resets the min and max retry intervals.
  990|       |@property(atomic, assign, getter=isRetryEnabled) BOOL retryEnabled;
  991|       |
  992|       |// Retry block is optional for retries.
  993|       |//
  994|       |// If present, this block should call the response block with YES to cause a retry or NO to end the
  995|       |// fetch.
  996|       |// See comments at the top of this file.
  997|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherRetryBlock retryBlock;
  998|       |
  999|       |// Retry intervals must be strictly less than maxRetryInterval, else
 1000|       |// they will be limited to maxRetryInterval and no further retries will
 1001|       |// be attempted.  Setting maxRetryInterval to 0.0 will reset it to the
 1002|       |// default value, 60 seconds for downloads and 600 seconds for uploads.
 1003|       |@property(atomic, assign) NSTimeInterval maxRetryInterval;
 1004|       |
 1005|       |// Starting retry interval.  Setting minRetryInterval to 0.0 will reset it
 1006|       |// to a random value between 1.0 and 2.0 seconds.  Clients should normally not
 1007|       |// set this except for unit testing.
 1008|       |@property(atomic, assign) NSTimeInterval minRetryInterval;
 1009|       |
 1010|       |// Multiplier used to increase the interval between retries, typically 2.0.
 1011|       |// Clients should not need to set this.
 1012|       |@property(atomic, assign) double retryFactor;
 1013|       |
 1014|       |// Number of retries attempted.
 1015|       |@property(atomic, readonly) NSUInteger retryCount;
 1016|       |
 1017|       |// Interval delay to precede next retry.
 1018|       |@property(atomic, readonly) NSTimeInterval nextRetryInterval;
 1019|       |
 1020|       |#if GTM_BACKGROUND_TASK_FETCHING
 1021|       |// Skip use of a UIBackgroundTask, thus requiring fetches to complete when the app is in the
 1022|       |// foreground.
 1023|       |//
 1024|       |// Targets should define GTM_BACKGROUND_TASK_FETCHING to 0 to avoid use of a UIBackgroundTask
 1025|       |// on iOS to allow fetches to complete in the background.  This property is available when
 1026|       |// it's not practical to set the preprocessor define.
 1027|       |@property(atomic, assign) BOOL skipBackgroundTask;
 1028|       |#endif  // GTM_BACKGROUND_TASK_FETCHING
 1029|       |
 1030|       |// Begin fetching the request
 1031|       |//
 1032|       |// The delegate may optionally implement the callback or pass nil for the selector or handler.
 1033|       |//
 1034|       |// The delegate and all callback blocks are retained between the beginFetch call until after the
 1035|       |// finish callback, or until the fetch is stopped.
 1036|       |//
 1037|       |// An error is passed to the callback for server statuses 300 or
 1038|       |// higher, with the status stored as the error object's code.
 1039|       |//
 1040|       |// finishedSEL has a signature like:
 1041|       |//   - (void)fetcher:(GTMSessionFetcher *)fetcher
 1042|       |//  finishedWithData:(NSData *)data
 1043|       |//             error:(NSError *)error;
 1044|       |//
 1045|       |// If the application has specified a destinationFileURL or an accumulateDataBlock
 1046|       |// for the fetcher, the data parameter passed to the callback will be nil.
 1047|       |
 1048|       |- (void)beginFetchWithDelegate:(GTM_NULLABLE id)delegate
 1049|       |             didFinishSelector:(GTM_NULLABLE SEL)finishedSEL;
 1050|       |
 1051|       |- (void)beginFetchWithCompletionHandler:(GTM_NULLABLE GTMSessionFetcherCompletionHandler)handler;
 1052|       |
 1053|       |// Returns YES if this fetcher is in the process of fetching a URL.
 1054|       |@property(atomic, readonly, getter=isFetching) BOOL fetching;
 1055|       |
 1056|       |// Cancel the fetch of the request that's currently in progress.  The completion handler
 1057|       |// will not be called.
 1058|       |- (void)stopFetching;
 1059|       |
 1060|       |// A block to be called when the fetch completes.
 1061|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherCompletionHandler completionHandler;
 1062|       |
 1063|       |// A block to be called if download resume data becomes available.
 1064|       |@property(atomic, strong, GTM_NULLABLE) void (^resumeDataBlock)(NSData *);
 1065|       |
 1066|       |// Return the status code from the server response.
 1067|       |@property(atomic, readonly) NSInteger statusCode;
 1068|       |
 1069|       |// Return the http headers from the response.
 1070|       |@property(atomic, strong, readonly, GTM_NULLABLE) GTM_NSDictionaryOf(NSString *, NSString *) *responseHeaders;
 1071|       |
 1072|       |// The response, once it's been received.
 1073|       |@property(atomic, strong, readonly, GTM_NULLABLE) NSURLResponse *response;
 1074|       |
 1075|       |// Bytes downloaded so far.
 1076|       |@property(atomic, readonly) int64_t downloadedLength;
 1077|       |
 1078|       |// Buffer of currently-downloaded data, if available.
 1079|       |@property(atomic, readonly, strong, GTM_NULLABLE) NSData *downloadedData;
 1080|       |
 1081|       |// Local path to which the downloaded file will be moved.
 1082|       |//
 1083|       |// If a file already exists at the path, it will be overwritten.
 1084|       |// Will create the enclosing folders if they are not present.
 1085|       |@property(atomic, strong, GTM_NULLABLE) NSURL *destinationFileURL;
 1086|       |
 1087|       |// The time this fetcher originally began fetching. This is useful as a time
 1088|       |// barrier for ignoring irrelevant fetch notifications or callbacks.
 1089|       |@property(atomic, strong, readonly, GTM_NULLABLE) NSDate *initialBeginFetchDate;
 1090|       |
 1091|       |// userData is retained solely for the convenience of the client.
 1092|       |@property(atomic, strong, GTM_NULLABLE) id userData;
 1093|       |
 1094|       |// Stored property values are retained solely for the convenience of the client.
 1095|       |@property(atomic, copy, GTM_NULLABLE) GTM_NSDictionaryOf(NSString *, id) *properties;
 1096|       |
 1097|       |- (void)setProperty:(GTM_NULLABLE id)obj forKey:(NSString *)key;  // Pass nil for obj to remove the property.
 1098|       |- (GTM_NULLABLE id)propertyForKey:(NSString *)key;
 1099|       |
 1100|       |- (void)addPropertiesFromDictionary:(GTM_NSDictionaryOf(NSString *, id) *)dict;
 1101|       |
 1102|       |// Comments are useful for logging, so are strongly recommended for each fetcher.
 1103|       |@property(atomic, copy, GTM_NULLABLE) NSString *comment;
 1104|       |
 1105|       |- (void)setCommentWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1, 2);
 1106|       |
 1107|       |// Log of request and response, if logging is enabled
 1108|       |@property(atomic, copy, GTM_NULLABLE) NSString *log;
 1109|       |
 1110|       |// Callbacks are run on this queue.  If none is supplied, the main queue is used.
 1111|       |@property(atomic, strong, GTM_NULL_RESETTABLE) dispatch_queue_t callbackQueue;
 1112|       |
 1113|       |// The queue used internally by the session to invoke its delegate methods in the fetcher.
 1114|       |//
 1115|       |// Application callbacks are always called by the fetcher on the callbackQueue above,
 1116|       |// not on this queue. Apps should generally not change this queue.
 1117|       |//
 1118|       |// The default delegate queue is the main queue.
 1119|       |//
 1120|       |// This value is ignored after the session has been created, so this
 1121|       |// property should be set in the fetcher service rather in the fetcher as it applies
 1122|       |// to a shared session.
 1123|       |@property(atomic, strong, GTM_NULL_RESETTABLE) NSOperationQueue *sessionDelegateQueue;
 1124|       |
 1125|       |// Spin the run loop or sleep the thread, discarding events, until the fetch has completed.
 1126|       |//
 1127|       |// This is only for use in testing or in tools without a user interface.
 1128|       |//
 1129|       |// Note:  Synchronous fetches should never be used by shipping apps; they are
 1130|       |// sufficient reason for rejection from the app store.
 1131|       |//
 1132|       |// Returns NO if timed out.
 1133|       |- (BOOL)waitForCompletionWithTimeout:(NSTimeInterval)timeoutInSeconds;
 1134|       |
 1135|       |// Test block is optional for testing.
 1136|       |//
 1137|       |// If present, this block will cause the fetcher to skip starting the session, and instead
 1138|       |// use the test block response values when calling the completion handler and delegate code.
 1139|       |//
 1140|       |// Test code can set this on the fetcher or on the fetcher service.  For testing libraries
 1141|       |// that use a fetcher without exposing either the fetcher or the fetcher service, the global
 1142|       |// method setGlobalTestBlock: will set the block for all fetchers that do not have a test
 1143|       |// block set.
 1144|       |//
 1145|       |// The test code can pass nil for all response parameters to indicate that the fetch
 1146|       |// should proceed.
 1147|       |//
 1148|       |// Applications can exclude test block support by setting GTM_DISABLE_FETCHER_TEST_BLOCK.
 1149|       |@property(atomic, copy, GTM_NULLABLE) GTMSessionFetcherTestBlock testBlock;
 1150|       |
 1151|       |+ (void)setGlobalTestBlock:(GTM_NULLABLE GTMSessionFetcherTestBlock)block;
 1152|       |
 1153|       |// When using the testBlock, |testBlockAccumulateDataChunkCount| is the desired number of chunks to
 1154|       |// divide the response data into if the client has streaming enabled. The data will be divided up to
 1155|       |// |testBlockAccumulateDataChunkCount| chunks; however, the exact amount may vary depending on the
 1156|       |// size of the response data (e.g. a 1-byte response can only be divided into one chunk).
 1157|       |@property(atomic, readwrite) NSUInteger testBlockAccumulateDataChunkCount;
 1158|       |
 1159|       |#if GTM_BACKGROUND_TASK_FETCHING
 1160|       |// For testing or to override UIApplication invocations, apps may specify an alternative
 1161|       |// target for messages to UIApplication.
 1162|       |+ (void)setSubstituteUIApplication:(nullable id<GTMUIApplicationProtocol>)substituteUIApplication;
 1163|       |+ (nullable id<GTMUIApplicationProtocol>)substituteUIApplication;
 1164|       |#endif  // GTM_BACKGROUND_TASK_FETCHING
 1165|       |
 1166|       |// Exposed for testing.
 1167|       |+ (GTMSessionCookieStorage *)staticCookieStorage;
 1168|       |+ (BOOL)appAllowsInsecureRequests;
 1169|       |
 1170|       |#if STRIP_GTM_FETCH_LOGGING
 1171|       |// If logging is stripped, provide a stub for the main method
 1172|       |// for controlling logging.
 1173|       |+ (void)setLoggingEnabled:(BOOL)flag;
 1174|       |+ (BOOL)isLoggingEnabled;
 1175|       |
 1176|       |#else
 1177|       |
 1178|       |// These methods let an application log specific body text, such as the text description of a binary
 1179|       |// request or response. The application should set the fetcher to defer response body logging until
 1180|       |// the response has been received and the log response body has been set by the app. For example:
 1181|       |//
 1182|       |//   fetcher.logRequestBody = [binaryObject stringDescription];
 1183|       |//   fetcher.deferResponseBodyLogging = YES;
 1184|       |//   [fetcher beginFetchWithCompletionHandler:^(NSData *data, NSError *error) {
 1185|       |//      if (error == nil) {
 1186|       |//        fetcher.logResponseBody = [[[MyThing alloc] initWithData:data] stringDescription];
 1187|       |//      }
 1188|       |//      fetcher.deferResponseBodyLogging = NO;
 1189|       |//   }];
 1190|       |
 1191|       |@property(atomic, copy, GTM_NULLABLE) NSString *logRequestBody;
 1192|       |@property(atomic, assign) BOOL deferResponseBodyLogging;
 1193|       |@property(atomic, copy, GTM_NULLABLE) NSString *logResponseBody;
 1194|       |
 1195|       |// Internal logging support.
 1196|       |@property(atomic, readonly) NSData *loggedStreamData;
 1197|       |@property(atomic, assign) BOOL hasLoggedError;
 1198|       |@property(atomic, strong, GTM_NULLABLE) NSURL *redirectedFromURL;
 1199|       |- (void)appendLoggedStreamData:(NSData *)dataToAdd;
 1200|       |- (void)clearLoggedStreamData;
 1201|       |
 1202|       |#endif // STRIP_GTM_FETCH_LOGGING
 1203|       |
 1204|       |@end
 1205|       |
 1206|       |@interface GTMSessionFetcher (BackwardsCompatibilityOnly)
 1207|       |// Clients using GTMSessionFetcher should set the cookie storage explicitly themselves.
 1208|       |// This method is just for compatibility with the old GTMHTTPFetcher class.
 1209|       |- (void)setCookieStorageMethod:(NSInteger)method;
 1210|       |@end
 1211|       |
 1212|       |// Until we can just instantiate NSHTTPCookieStorage for local use, we'll
 1213|       |// implement all the public methods ourselves.  This stores cookies only in
 1214|       |// memory.  Additional methods are provided for testing.
 1215|       |//
 1216|       |// iOS 9/OS X 10.11 added +[NSHTTPCookieStorage sharedCookieStorageForGroupContainerIdentifier:]
 1217|       |// which may also be used to create cookie storage.
 1218|       |@interface GTMSessionCookieStorage : NSHTTPCookieStorage
 1219|       |
 1220|       |// Add the array off cookies to the storage, replacing duplicates.
 1221|       |// Also removes expired cookies from the storage.
 1222|       |- (void)setCookies:(GTM_NULLABLE GTM_NSArrayOf(NSHTTPCookie *) *)cookies;
 1223|       |
 1224|       |- (void)removeAllCookies;
 1225|       |
 1226|       |@end
 1227|       |
 1228|       |// Macros to monitor synchronization blocks in debug builds.
 1229|       |// These report problems using GTMSessionCheckDebug.
 1230|       |//
 1231|       |// GTMSessionMonitorSynchronized           Start monitoring a top-level-only
 1232|       |//                                         @sync scope.
 1233|       |// GTMSessionMonitorRecursiveSynchronized  Start monitoring a top-level or
 1234|       |//                                         recursive @sync scope.
 1235|       |// GTMSessionCheckSynchronized             Verify that the current execution
 1236|       |//                                         is inside a @sync scope.
 1237|       |// GTMSessionCheckNotSynchronized          Verify that the current execution
 1238|       |//                                         is not inside a @sync scope.
 1239|       |//
 1240|       |// Example usage:
 1241|       |//
 1242|       |// - (void)myExternalMethod {
 1243|       |//   @synchronized(self) {
 1244|       |//     GTMSessionMonitorSynchronized(self)
 1245|       |//
 1246|       |// - (void)myInternalMethod {
 1247|       |//   GTMSessionCheckSynchronized(self);
 1248|       |//
 1249|       |// - (void)callMyCallbacks {
 1250|       |//   GTMSessionCheckNotSynchronized(self);
 1251|       |//
 1252|       |// GTMSessionCheckNotSynchronized is available for verifying the code isn't
 1253|       |// in a deadlockable @sync state when posting notifications and invoking
 1254|       |// callbacks. Don't use GTMSessionCheckNotSynchronized immediately before a
 1255|       |// @sync scope; the normal recursiveness check of GTMSessionMonitorSynchronized
 1256|       |// can catch those.
 1257|       |
 1258|       |#ifdef __OBJC__
 1259|       |// If asserts are entirely no-ops, the synchronization monitor is just a bunch
 1260|       |// of counting code that doesn't report exceptional circumstances in any way.
 1261|       |// Only build the synchronization monitor code if NS_BLOCK_ASSERTIONS is not
 1262|       |// defined or asserts are being logged instead.
 1263|       |#if DEBUG && (!defined(NS_BLOCK_ASSERTIONS) || GTMSESSION_ASSERT_AS_LOG)
 1264|       |  #define __GTMSessionMonitorSynchronizedVariableInner(varname, counter) \
 1265|       |      varname ## counter
 1266|       |  #define __GTMSessionMonitorSynchronizedVariable(varname, counter)  \
 1267|       |      __GTMSessionMonitorSynchronizedVariableInner(varname, counter)
 1268|       |
 1269|       |  #define GTMSessionMonitorSynchronized(obj)                                     \
 1270|     56|      NS_VALID_UNTIL_END_OF_SCOPE id                                             \
 1271|     56|        __GTMSessionMonitorSynchronizedVariable(__monitor, __COUNTER__) =        \
 1272|     56|        [[GTMSessionSyncMonitorInternal alloc] initWithSynchronizationObject:obj \
 1273|     56|                                                    allowRecursive:NO            \
 1274|     56|                                                     functionName:__func__]
 1275|       |
 1276|       |  #define GTMSessionMonitorRecursiveSynchronized(obj)                            \
 1277|       |      NS_VALID_UNTIL_END_OF_SCOPE id                                             \
 1278|       |        __GTMSessionMonitorSynchronizedVariable(__monitor, __COUNTER__) =        \
 1279|       |        [[GTMSessionSyncMonitorInternal alloc] initWithSynchronizationObject:obj \
 1280|       |                                                    allowRecursive:YES           \
 1281|       |                                                     functionName:__func__]
 1282|       |
 1283|      6|  #define GTMSessionCheckSynchronized(obj) {                                           \
 1284|      6|      GTMSESSION_ASSERT_DEBUG(                                                         \
 1285|      6|          [GTMSessionSyncMonitorInternal functionsHoldingSynchronizationOnObject:obj], \
 1286|      6|          @"GTMSessionCheckSynchronized(" #obj ") failed: not sync'd"                  \
 1287|      6|          @" on " #obj " in %s. Call stack:\n%@",                                      \
 1288|      6|          __func__, [NSThread callStackSymbols]);                                      \
 1289|      6|      }
 1290|       |
 1291|      4|  #define GTMSessionCheckNotSynchronized(obj) {                                       \
 1292|      4|      GTMSESSION_ASSERT_DEBUG(                                                        \
 1293|      4|        ![GTMSessionSyncMonitorInternal functionsHoldingSynchronizationOnObject:obj], \
 1294|      4|        @"GTMSessionCheckNotSynchronized(" #obj ") failed: was sync'd"                \
 1295|      4|        @" on " #obj " in %s by %@. Call stack:\n%@", __func__,                       \
 1296|      4|        [GTMSessionSyncMonitorInternal functionsHoldingSynchronizationOnObject:obj],  \
 1297|      4|        [NSThread callStackSymbols]);                                                 \
 1298|      4|      }
 1299|       |
 1300|       |// GTMSessionSyncMonitorInternal is a private class that keeps track of the
 1301|       |// beginning and end of synchronized scopes.
 1302|       |//
 1303|       |// This class should not be used directly, but only via the
 1304|       |// GTMSessionMonitorSynchronized macro.
 1305|       |@interface GTMSessionSyncMonitorInternal : NSObject
 1306|       |- (instancetype)initWithSynchronizationObject:(id)object
 1307|       |                               allowRecursive:(BOOL)allowRecursive
 1308|       |                                 functionName:(const char *)functionName;
 1309|       |// Return the names of the functions that hold sync on the object, or nil if none.
 1310|       |+ (NSArray *)functionsHoldingSynchronizationOnObject:(id)object;
 1311|       |@end
 1312|       |
 1313|       |#else
 1314|       |  #define GTMSessionMonitorSynchronized(obj) do { } while (0)
 1315|       |  #define GTMSessionMonitorRecursiveSynchronized(obj) do { } while (0)
 1316|       |  #define GTMSessionCheckSynchronized(obj) do { } while (0)
 1317|       |  #define GTMSessionCheckNotSynchronized(obj) do { } while (0)
 1318|       |#endif  // !DEBUG
 1319|       |#endif  // __OBJC__
 1320|       |
 1321|       |
 1322|       |GTM_ASSUME_NONNULL_END

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GTMSessionFetcher/Source/GTMSessionFetcher.m:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |#if !defined(__has_feature) || !__has_feature(objc_arc)
   17|       |#error "This file requires ARC support."
   18|       |#endif
   19|       |
   20|       |#import "GTMSessionFetcher.h"
   21|       |#if TARGET_OS_OSX && GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH
   22|       |// To reconnect background sessions on Mac outside +load requires importing and linking
   23|       |// AppKit to access the NSApplicationDidFinishLaunching symbol.
   24|       |#import <AppKit/AppKit.h>
   25|       |#endif
   26|       |
   27|       |#import <sys/utsname.h>
   28|       |
   29|       |#ifndef STRIP_GTM_FETCH_LOGGING
   30|       |  #error GTMSessionFetcher headers should have defaulted this if it wasn't already defined.
   31|       |#endif
   32|       |
   33|       |GTM_ASSUME_NONNULL_BEGIN
   34|       |
   35|       |NSString *const kGTMSessionFetcherStartedNotification           = @"kGTMSessionFetcherStartedNotification";
   36|       |NSString *const kGTMSessionFetcherStoppedNotification           = @"kGTMSessionFetcherStoppedNotification";
   37|       |NSString *const kGTMSessionFetcherRetryDelayStartedNotification = @"kGTMSessionFetcherRetryDelayStartedNotification";
   38|       |NSString *const kGTMSessionFetcherRetryDelayStoppedNotification = @"kGTMSessionFetcherRetryDelayStoppedNotification";
   39|       |
   40|       |NSString *const kGTMSessionFetcherCompletionInvokedNotification = @"kGTMSessionFetcherCompletionInvokedNotification";
   41|       |NSString *const kGTMSessionFetcherCompletionDataKey = @"data";
   42|       |NSString *const kGTMSessionFetcherCompletionErrorKey = @"error";
   43|       |
   44|       |NSString *const kGTMSessionFetcherErrorDomain       = @"com.google.GTMSessionFetcher";
   45|       |NSString *const kGTMSessionFetcherStatusDomain      = @"com.google.HTTPStatus";
   46|       |NSString *const kGTMSessionFetcherStatusDataKey     = @"data";  // data returned with a kGTMSessionFetcherStatusDomain error
   47|       |NSString *const kGTMSessionFetcherStatusDataContentTypeKey = @"data_content_type";
   48|       |
   49|       |NSString *const kGTMSessionFetcherNumberOfRetriesDoneKey        = @"kGTMSessionFetcherNumberOfRetriesDoneKey";
   50|       |NSString *const kGTMSessionFetcherElapsedIntervalWithRetriesKey = @"kGTMSessionFetcherElapsedIntervalWithRetriesKey";
   51|       |
   52|       |static NSString *const kGTMSessionIdentifierPrefix = @"com.google.GTMSessionFetcher";
   53|       |static NSString *const kGTMSessionIdentifierDestinationFileURLMetadataKey = @"_destURL";
   54|       |static NSString *const kGTMSessionIdentifierBodyFileURLMetadataKey        = @"_bodyURL";
   55|       |
   56|       |// The default max retry interview is 10 minutes for uploads (POST/PUT/PATCH),
   57|       |// 1 minute for downloads.
   58|       |static const NSTimeInterval kUnsetMaxRetryInterval = -1.0;
   59|       |static const NSTimeInterval kDefaultMaxDownloadRetryInterval = 60.0;
   60|       |static const NSTimeInterval kDefaultMaxUploadRetryInterval = 60.0 * 10.;
   61|       |
   62|       |// The maximum data length that can be loaded to the error userInfo
   63|       |static const int64_t kMaximumDownloadErrorDataLength = 20000;
   64|       |
   65|       |#ifdef GTMSESSION_PERSISTED_DESTINATION_KEY
   66|       |// Projects using unique class names should also define a unique persisted destination key.
   67|       |static NSString * const kGTMSessionFetcherPersistedDestinationKey =
   68|       |    GTMSESSION_PERSISTED_DESTINATION_KEY;
   69|       |#else
   70|       |static NSString * const kGTMSessionFetcherPersistedDestinationKey =
   71|       |    @"com.google.GTMSessionFetcher.downloads";
   72|       |#endif
   73|       |
   74|       |GTM_ASSUME_NONNULL_END
   75|       |
   76|       |//
   77|       |// GTMSessionFetcher
   78|       |//
   79|       |
   80|       |#if 0
   81|       |#define GTM_LOG_BACKGROUND_SESSION(...) GTMSESSION_LOG_DEBUG(__VA_ARGS__)
   82|       |#else
   83|       |#define GTM_LOG_BACKGROUND_SESSION(...)
   84|       |#endif
   85|       |
   86|       |#ifndef GTM_TARGET_SUPPORTS_APP_TRANSPORT_SECURITY
   87|       |  #if (TARGET_OS_TV \
   88|       |       || TARGET_OS_WATCH \
   89|       |       || (!TARGET_OS_IPHONE && defined(MAC_OS_X_VERSION_10_11) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_11) \
   90|       |       || (TARGET_OS_IPHONE && defined(__IPHONE_9_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_9_0))
   91|       |    #define GTM_TARGET_SUPPORTS_APP_TRANSPORT_SECURITY 1
   92|       |  #endif
   93|       |#endif
   94|       |
   95|       |#if ((defined(TARGET_OS_MACCATALYST) && TARGET_OS_MACCATALYST) || \
   96|       |     (TARGET_OS_OSX && defined(__MAC_10_15) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_15) || \
   97|       |     (TARGET_OS_IOS && defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_13_0) || \
   98|       |     (TARGET_OS_WATCH && defined(__WATCHOS_6_0) && __WATCHOS_VERSION_MIN_REQUIRED >= __WATCHOS_6_0) || \
   99|       |     (TARGET_OS_TV && defined(__TVOS_13_0) && __TVOS_VERSION_MIN_REQUIRED >= __TVOS_13_0))
  100|       |#define GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 1
  101|       |#define GTM_SDK_SUPPORTS_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 1
  102|       |#elif ((TARGET_OS_OSX && defined(__MAC_10_15) && __MAC_OS_X_VERSION_MAX_ALLOWED >= __MAC_10_15) || \
  103|       |       (TARGET_OS_IOS && defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_13_0) || \
  104|       |       (TARGET_OS_WATCH && defined(__WATCHOS_6_0) && __WATCHOS_VERSION_MAX_ALLOWED >= __WATCHOS_6_0) || \
  105|       |       (TARGET_OS_TV && defined(__TVOS_13_0) && __TVOS_VERSION_MAX_ALLOWED >= __TVOS_13_0))
  106|       |#define GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 0
  107|       |#define GTM_SDK_SUPPORTS_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 1
  108|       |#else
  109|       |#define GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 0
  110|       |#define GTM_SDK_SUPPORTS_TLSMINIMUMSUPPORTEDPROTOCOLVERSION 0
  111|       |#endif
  112|       |
  113|       |#if ((defined(TARGET_OS_MACCATALYST) && TARGET_OS_MACCATALYST) || \
  114|       |     (TARGET_OS_OSX && defined(__MAC_10_15) && __MAC_OS_X_VERSION_MIN_REQUIRED >= __MAC_10_15) || \
  115|       |     (TARGET_OS_IOS && defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_13_0) || \
  116|       |     (TARGET_OS_WATCH && defined(__WATCHOS_6_0) && __WATCHOS_VERSION_MIN_REQUIRED >= __WATCHOS_6_0) || \
  117|       |     (TARGET_OS_TV && defined(__TVOS_13_0) && __TVOS_VERSION_MIN_REQUIRED >= __TVOS_13_0))
  118|       |#define GTM_SDK_REQUIRES_SECTRUSTEVALUATEWITHERROR 1
  119|       |#else
  120|       |#define GTM_SDK_REQUIRES_SECTRUSTEVALUATEWITHERROR 0
  121|       |#endif
  122|       |
  123|       |@interface GTMSessionFetcher ()
  124|       |
  125|       |@property(atomic, strong, readwrite, GTM_NULLABLE) NSData *downloadedData;
  126|       |@property(atomic, strong, readwrite, GTM_NULLABLE) NSData *downloadResumeData;
  127|       |
  128|       |#if GTM_BACKGROUND_TASK_FETCHING
  129|       |// Should always be accessed within an @synchronized(self).
  130|       |@property(assign, nonatomic) UIBackgroundTaskIdentifier backgroundTaskIdentifier;
  131|       |#endif
  132|       |
  133|       |@property(atomic, readwrite, getter=isUsingBackgroundSession) BOOL usingBackgroundSession;
  134|       |
  135|       |@end
  136|       |
  137|       |#if !GTMSESSION_BUILD_COMBINED_SOURCES
  138|       |@interface GTMSessionFetcher (GTMSessionFetcherLoggingInternal)
  139|       |- (void)logFetchWithError:(NSError *)error;
  140|       |- (void)logNowWithError:(GTM_NULLABLE NSError *)error;
  141|       |- (NSInputStream *)loggedInputStreamForInputStream:(NSInputStream *)inputStream;
  142|       |- (GTMSessionFetcherBodyStreamProvider)loggedStreamProviderForStreamProvider:
  143|       |    (GTMSessionFetcherBodyStreamProvider)streamProvider;
  144|       |@end
  145|       |#endif  // !GTMSESSION_BUILD_COMBINED_SOURCES
  146|       |
  147|       |GTM_ASSUME_NONNULL_BEGIN
  148|       |
  149|      2|static NSTimeInterval InitialMinRetryInterval(void) {
  150|      2|  return 1.0 + ((double)(arc4random_uniform(0x0FFFF)) / (double) 0x0FFFF);
  151|      2|}
  152|       |
  153|      1|static BOOL IsLocalhost(NSString * GTM_NULLABLE_TYPE host) {
  154|      1|  // We check if there's host, and then make the comparisons.
  155|      1|  if (host == nil) return NO;
  156|      1|  return ([host caseInsensitiveCompare:@"localhost"] == NSOrderedSame
  157|      1|          || [host isEqual:@"::1"]
  158|      1|          || [host isEqual:@"127.0.0.1"]);
  159|      1|}
  160|       |
  161|       |static NSDictionary *GTM_NULLABLE_TYPE GTMErrorUserInfoForData(
  162|      0|    NSData *GTM_NULLABLE_TYPE data, NSDictionary *GTM_NULLABLE_TYPE responseHeaders) {
  163|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  164|      0|
  165|      0|  if (data.length > 0) {
  166|      0|    userInfo[kGTMSessionFetcherStatusDataKey] = data;
  167|      0|
  168|      0|    NSString *contentType = responseHeaders[@"Content-Type"];
  169|      0|    if (contentType) {
  170|      0|      userInfo[kGTMSessionFetcherStatusDataContentTypeKey] = contentType;
  171|      0|    }
  172|      0|  }
  173|      0|
  174|      0|  return userInfo.count > 0 ? userInfo : nil;
  175|      0|}
  176|       |
  177|       |static GTMSessionFetcherTestBlock GTM_NULLABLE_TYPE gGlobalTestBlock;
  178|       |
  179|       |@implementation GTMSessionFetcher {
  180|       |  NSMutableURLRequest *_request; // after beginFetch, changed only in delegate callbacks
  181|       |  BOOL _useUploadTask;           // immutable after beginFetch
  182|       |  NSURL *_bodyFileURL;           // immutable after beginFetch
  183|       |  GTMSessionFetcherBodyStreamProvider _bodyStreamProvider;  // immutable after beginFetch
  184|       |  NSURLSession *_session;
  185|       |  BOOL _shouldInvalidateSession;  // immutable after beginFetch
  186|       |  NSURLSession *_sessionNeedingInvalidation;
  187|       |  NSURLSessionConfiguration *_configuration;
  188|       |  NSURLSessionTask *_sessionTask;
  189|       |  NSString *_taskDescription;
  190|       |  float _taskPriority;
  191|       |  NSURLResponse *_response;
  192|       |  NSString *_sessionIdentifier;
  193|       |  BOOL _wasCreatedFromBackgroundSession;
  194|       |  BOOL _didCreateSessionIdentifier;
  195|       |  NSString *_sessionIdentifierUUID;
  196|       |  BOOL _userRequestedBackgroundSession;
  197|       |  BOOL _usingBackgroundSession;
  198|       |  NSMutableData * GTM_NULLABLE_TYPE _downloadedData;
  199|       |  NSError *_downloadFinishedError;
  200|       |  NSData *_downloadResumeData;  // immutable after construction
  201|       |  NSData * GTM_NULLABLE_TYPE _downloadTaskErrorData; // Data for when download task fails
  202|       |  NSURL *_destinationFileURL;
  203|       |  int64_t _downloadedLength;
  204|       |  NSURLCredential *_credential;     // username & password
  205|       |  NSURLCredential *_proxyCredential; // credential supplied to proxy servers
  206|       |  BOOL _isStopNotificationNeeded;   // set when start notification has been sent
  207|       |  BOOL _isUsingTestBlock;  // set when a test block was provided (remains set when the block is released)
  208|       |  id _userData;                      // retained, if set by caller
  209|       |  NSMutableDictionary *_properties;  // more data retained for caller
  210|       |  dispatch_queue_t _callbackQueue;
  211|       |  dispatch_group_t _callbackGroup;   // read-only after creation
  212|       |  NSOperationQueue *_delegateQueue;  // immutable after beginFetch
  213|       |
  214|       |  id<GTMFetcherAuthorizationProtocol> _authorizer;  // immutable after beginFetch
  215|       |
  216|       |  // The service object that created and monitors this fetcher, if any.
  217|       |  id<GTMSessionFetcherServiceProtocol> _service;  // immutable; set by the fetcher service upon creation
  218|       |  NSString *_serviceHost;
  219|       |  NSInteger _servicePriority;       // immutable after beginFetch
  220|       |  BOOL _hasStoppedFetching;         // counterpart to _initialBeginFetchDate
  221|       |  BOOL _userStoppedFetching;
  222|       |
  223|       |  BOOL _isRetryEnabled;             // user wants auto-retry
  224|       |  NSTimer *_retryTimer;
  225|       |  NSUInteger _retryCount;
  226|       |  NSTimeInterval _maxRetryInterval; // default 60 (download) or 600 (upload) seconds
  227|       |  NSTimeInterval _minRetryInterval; // random between 1 and 2 seconds
  228|       |  NSTimeInterval _retryFactor;      // default interval multiplier is 2
  229|       |  NSTimeInterval _lastRetryInterval;
  230|       |  NSDate *_initialBeginFetchDate;   // date that beginFetch was first invoked; immutable after initial beginFetch
  231|       |  NSDate *_initialRequestDate;      // date of first request to the target server (ignoring auth)
  232|       |  BOOL _hasAttemptedAuthRefresh;    // accessed only in shouldRetryNowForStatus:
  233|       |
  234|       |  NSString *_comment;               // comment for log
  235|       |  NSString *_log;
  236|       |#if !STRIP_GTM_FETCH_LOGGING
  237|       |  NSMutableData *_loggedStreamData;
  238|       |  NSURL *_redirectedFromURL;
  239|       |  NSString *_logRequestBody;
  240|       |  NSString *_logResponseBody;
  241|       |  BOOL _hasLoggedError;
  242|       |  BOOL _deferResponseBodyLogging;
  243|       |#endif
  244|       |}
  245|       |
  246|       |#if !GTMSESSION_UNIT_TESTING
  247|      1|+ (void)load {
  248|      1|#if GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH && TARGET_OS_IPHONE
  249|      1|  NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
  250|      1|  [nc addObserver:self
  251|      1|         selector:@selector(reconnectFetchersForBackgroundSessionsOnAppLaunch:)
  252|      1|             name:UIApplicationDidFinishLaunchingNotification
  253|      1|           object:nil];
  254|       |#elif GTMSESSION_RECONNECT_BACKGROUND_SESSIONS_ON_LAUNCH && TARGET_OS_OSX
  255|       |  NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
  256|       |  [nc addObserver:self
  257|       |         selector:@selector(reconnectFetchersForBackgroundSessionsOnAppLaunch:)
  258|       |             name:NSApplicationDidFinishLaunchingNotification
  259|       |           object:nil];
  260|       |#else
  261|       |  [self fetchersForBackgroundSessions];
  262|       |#endif
  263|       |}
  264|       |
  265|      1|+ (void)reconnectFetchersForBackgroundSessionsOnAppLaunch:(NSNotification *)notification {
  266|      1|  // Give all other app-did-launch handlers a chance to complete before
  267|      1|  // reconnecting the fetchers. Not doing this may lead to reconnecting
  268|      1|  // before the app delegate has a chance to run.
  269|      1|  dispatch_async(dispatch_get_main_queue(), ^{
  270|      1|    [self fetchersForBackgroundSessions];
  271|      1|  });
  272|      1|}
  273|       |#endif  // !GTMSESSION_UNIT_TESTING
  274|       |
  275|      0|+ (instancetype)fetcherWithRequest:(GTM_NULLABLE NSURLRequest *)request {
  276|      0|  return [[self alloc] initWithRequest:request configuration:nil];
  277|      0|}
  278|       |
  279|      0|+ (instancetype)fetcherWithURL:(NSURL *)requestURL {
  280|      0|  return [self fetcherWithRequest:[NSURLRequest requestWithURL:requestURL]];
  281|      0|}
  282|       |
  283|      0|+ (instancetype)fetcherWithURLString:(NSString *)requestURLString {
  284|      0|  return [self fetcherWithURL:(NSURL *)[NSURL URLWithString:requestURLString]];
  285|      0|}
  286|       |
  287|      0|+ (instancetype)fetcherWithDownloadResumeData:(NSData *)resumeData {
  288|      0|  GTMSessionFetcher *fetcher = [self fetcherWithRequest:nil];
  289|      0|  fetcher.comment = @"Resuming download";
  290|      0|  fetcher.downloadResumeData = resumeData;
  291|      0|  return fetcher;
  292|      0|}
  293|       |
  294|      0|+ (GTM_NULLABLE instancetype)fetcherWithSessionIdentifier:(NSString *)sessionIdentifier {
  295|      0|  GTMSESSION_ASSERT_DEBUG(sessionIdentifier != nil, @"Invalid session identifier");
  296|      0|  NSMapTable *sessionIdentifierToFetcherMap = [self sessionIdentifierToFetcherMap];
  297|      0|  GTMSessionFetcher *fetcher = [sessionIdentifierToFetcherMap objectForKey:sessionIdentifier];
  298|      0|  if (!fetcher && [sessionIdentifier hasPrefix:kGTMSessionIdentifierPrefix]) {
  299|      0|    fetcher = [self fetcherWithRequest:nil];
  300|      0|    [fetcher setSessionIdentifier:sessionIdentifier];
  301|      0|    [sessionIdentifierToFetcherMap setObject:fetcher forKey:sessionIdentifier];
  302|      0|    fetcher->_wasCreatedFromBackgroundSession = YES;
  303|      0|    [fetcher setCommentWithFormat:@"Resuming %@",
  304|      0|     fetcher && fetcher->_sessionIdentifierUUID ? fetcher->_sessionIdentifierUUID : @"?"];
  305|      0|  }
  306|      0|  return fetcher;
  307|      0|}
  308|       |
  309|      2|+ (NSMapTable *)sessionIdentifierToFetcherMap {
  310|      2|  // TODO: What if a service is involved in creating the fetcher? Currently, when re-creating
  311|      2|  // fetchers, if a service was involved, it is not re-created. Should the service maintain a map?
  312|      2|  static NSMapTable *gSessionIdentifierToFetcherMap = nil;
  313|      2|
  314|      2|  static dispatch_once_t onceToken;
  315|      2|  dispatch_once(&onceToken, ^{
  316|      1|    gSessionIdentifierToFetcherMap = [NSMapTable strongToWeakObjectsMapTable];
  317|      1|  });
  318|      2|  return gSessionIdentifierToFetcherMap;
  319|      2|}
  320|       |
  321|       |#if !GTM_ALLOW_INSECURE_REQUESTS
  322|      1|+ (BOOL)appAllowsInsecureRequests {
  323|      1|  // If the main bundle Info.plist key NSAppTransportSecurity is present, and it specifies
  324|      1|  // NSAllowsArbitraryLoads, then we need to explicitly enforce secure schemes.
  325|      1|#if GTM_TARGET_SUPPORTS_APP_TRANSPORT_SECURITY
  326|      1|  static BOOL allowsInsecureRequests;
  327|      1|  static dispatch_once_t onceToken;
  328|      1|  dispatch_once(&onceToken, ^{
  329|      1|    NSBundle *mainBundle = [NSBundle mainBundle];
  330|      1|    NSDictionary *appTransportSecurity =
  331|      1|        [mainBundle objectForInfoDictionaryKey:@"NSAppTransportSecurity"];
  332|      1|    allowsInsecureRequests =
  333|      1|        [[appTransportSecurity objectForKey:@"NSAllowsArbitraryLoads"] boolValue];
  334|      1|  });
  335|      1|  return allowsInsecureRequests;
  336|       |#else
  337|       |  // For builds targeting iOS 8 or 10.10 and earlier, we want to require fetcher
  338|       |  // security checks.
  339|       |  return YES;
  340|       |#endif  // GTM_TARGET_SUPPORTS_APP_TRANSPORT_SECURITY
  341|       |}
  342|       |#else  // GTM_ALLOW_INSECURE_REQUESTS
  343|       |+ (BOOL)appAllowsInsecureRequests {
  344|       |  return YES;
  345|       |}
  346|       |#endif  // !GTM_ALLOW_INSECURE_REQUESTS
  347|       |
  348|       |
  349|      0|- (instancetype)init {
  350|      0|  return [self initWithRequest:nil configuration:nil];
  351|      0|}
  352|       |
  353|      0|- (instancetype)initWithRequest:(NSURLRequest *)request  {
  354|      0|  return [self initWithRequest:request configuration:nil];
  355|      0|}
  356|       |
  357|       |- (instancetype)initWithRequest:(GTM_NULLABLE NSURLRequest *)request
  358|      1|                  configuration:(GTM_NULLABLE NSURLSessionConfiguration *)configuration {
  359|      1|  self = [super init];
  360|      1|  if (self) {
  361|      1|#if GTM_BACKGROUND_TASK_FETCHING
  362|      1|    _backgroundTaskIdentifier = UIBackgroundTaskInvalid;
  363|      1|#endif
  364|      1|    _request = [request mutableCopy];
  365|      1|    _configuration = configuration;
  366|      1|
  367|      1|    NSData *bodyData = request.HTTPBody;
  368|      1|    if (bodyData) {
  369|      0|      _bodyLength = (int64_t)bodyData.length;
  370|      1|    } else {
  371|      1|      _bodyLength = NSURLSessionTransferSizeUnknown;
  372|      1|    }
  373|      1|
  374|      1|    _callbackQueue = dispatch_get_main_queue();
  375|      1|    _callbackGroup = dispatch_group_create();
  376|      1|    _delegateQueue = [NSOperationQueue mainQueue];
  377|      1|
  378|      1|    _minRetryInterval = InitialMinRetryInterval();
  379|      1|    _maxRetryInterval = kUnsetMaxRetryInterval;
  380|      1|
  381|      1|    _taskPriority = -1.0f;  // Valid values if set are 0.0...1.0.
  382|      1|
  383|      1|    _testBlockAccumulateDataChunkCount = 1;
  384|      1|
  385|      1|#if !STRIP_GTM_FETCH_LOGGING
  386|      1|    // Encourage developers to set the comment property or use
  387|      1|    // setCommentWithFormat: by providing a default string.
  388|      1|    _comment = @"(No fetcher comment set)";
  389|      1|#endif
  390|      1|  }
  391|      1|  return self;
  392|      1|}
  393|       |
  394|      0|- (id)copyWithZone:(NSZone *)zone {
  395|      0|  // disallow use of fetchers in a copy property
  396|      0|  [self doesNotRecognizeSelector:_cmd];
  397|      0|  return nil;
  398|      0|}
  399|       |
  400|      0|- (NSString *)description {
  401|      0|  NSString *requestStr = self.request.URL.description;
  402|      0|  if (requestStr.length == 0) {
  403|      0|    if (self.downloadResumeData.length > 0) {
  404|      0|      requestStr = @"<download resume data>";
  405|      0|    } else if (_wasCreatedFromBackgroundSession) {
  406|      0|      requestStr = @"<from bg session>";
  407|      0|    } else {
  408|      0|      requestStr = @"<no request>";
  409|      0|    }
  410|      0|  }
  411|      0|  return [NSString stringWithFormat:@"%@ %p (%@)", [self class], self, requestStr];
  412|      0|}
  413|       |
  414|      0|- (void)dealloc {
  415|      0|  GTMSESSION_ASSERT_DEBUG(!_isStopNotificationNeeded,
  416|      0|                          @"unbalanced fetcher notification for %@", _request.URL);
  417|      0|  [self forgetSessionIdentifierForFetcherWithoutSyncCheck];
  418|      0|
  419|      0|  // Note: if a session task or a retry timer was pending, then this instance
  420|      0|  // would be retained by those so it wouldn't be getting dealloc'd,
  421|      0|  // hence we don't need to stopFetch here
  422|      0|}
  423|       |
  424|       |#pragma mark -
  425|       |
  426|       |// Begin fetching the URL (or begin a retry fetch).  The delegate is retained
  427|       |// for the duration of the fetch connection.
  428|       |
  429|      1|- (void)beginFetchWithCompletionHandler:(GTM_NULLABLE GTMSessionFetcherCompletionHandler)handler {
  430|      1|  GTMSessionCheckNotSynchronized(self);
  431|      1|
  432|      1|  _completionHandler = [handler copy];
  433|      1|
  434|      1|  // The user may have called setDelegate: earlier if they want to use other
  435|      1|  // delegate-style callbacks during the fetch; otherwise, the delegate is nil,
  436|      1|  // which is fine.
  437|      1|  [self beginFetchMayDelay:YES mayAuthorize:YES];
  438|      1|}
  439|       |
  440|       |// Begin fetching the URL for a retry fetch. The delegate and completion handler
  441|       |// are already provided, and do not need to be copied.
  442|      0|- (void)beginFetchForRetry {
  443|      0|  GTMSessionCheckNotSynchronized(self);
  444|      0|
  445|      0|  [self beginFetchMayDelay:YES mayAuthorize:YES];
  446|      0|}
  447|       |
  448|       |- (GTMSessionFetcherCompletionHandler)completionHandlerWithTarget:(GTM_NULLABLE_TYPE id)target
  449|      0|                                                didFinishSelector:(GTM_NULLABLE_TYPE SEL)finishedSelector {
  450|      0|  GTMSessionFetcherAssertValidSelector(target, finishedSelector, @encode(GTMSessionFetcher *),
  451|      0|                                       @encode(NSData *), @encode(NSError *), 0);
  452|      0|  GTMSessionFetcherCompletionHandler completionHandler = ^(NSData *data, NSError *error) {
  453|      0|      if (target && finishedSelector) {
  454|      0|        id selfArg = self;  // Placate ARC.
  455|      0|        NSMethodSignature *sig = [target methodSignatureForSelector:finishedSelector];
  456|      0|        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig];
  457|      0|        [invocation setSelector:(SEL)finishedSelector];
  458|      0|        [invocation setTarget:target];
  459|      0|        [invocation setArgument:&selfArg atIndex:2];
  460|      0|        [invocation setArgument:&data atIndex:3];
  461|      0|        [invocation setArgument:&error atIndex:4];
  462|      0|        [invocation invoke];
  463|      0|      }
  464|      0|  };
  465|      0|  return completionHandler;
  466|      0|}
  467|       |
  468|       |- (void)beginFetchWithDelegate:(GTM_NULLABLE_TYPE id)target
  469|      0|             didFinishSelector:(GTM_NULLABLE_TYPE SEL)finishedSelector {
  470|      0|  GTMSessionCheckNotSynchronized(self);
  471|      0|
  472|      0|  GTMSessionFetcherCompletionHandler handler =  [self completionHandlerWithTarget:target
  473|      0|                                                                didFinishSelector:finishedSelector];
  474|      0|  [self beginFetchWithCompletionHandler:handler];
  475|      0|}
  476|       |
  477|       |- (void)beginFetchMayDelay:(BOOL)mayDelay
  478|      1|              mayAuthorize:(BOOL)mayAuthorize {
  479|      1|  // This is the internal entry point for re-starting fetches.
  480|      1|  GTMSessionCheckNotSynchronized(self);
  481|      1|
  482|      1|  NSMutableURLRequest *fetchRequest = _request;  // The request property is now externally immutable.
  483|      1|  NSURL *fetchRequestURL = fetchRequest.URL;
  484|      1|  NSString *priorSessionIdentifier = self.sessionIdentifier;
  485|      1|
  486|      1|  // A utility block for creating error objects when we fail to start the fetch.
  487|      1|  NSError *(^beginFailureError)(NSInteger) = ^(NSInteger code){
  488|      0|    NSString *urlString = fetchRequestURL.absoluteString;
  489|      0|    NSDictionary *userInfo = @{
  490|      0|      NSURLErrorFailingURLStringErrorKey : (urlString ? urlString : @"(missing URL)")
  491|      0|    };
  492|      0|    return [NSError errorWithDomain:kGTMSessionFetcherErrorDomain
  493|      0|                               code:code
  494|      0|                           userInfo:userInfo];
  495|      0|  };
  496|      1|
  497|      1|  // Catch delegate queue maxConcurrentOperationCount values other than 1, particularly
  498|      1|  // NSOperationQueueDefaultMaxConcurrentOperationCount (-1), to avoid the additional complexity
  499|      1|  // of simultaneous or out-of-order delegate callbacks.
  500|      1|  GTMSESSION_ASSERT_DEBUG(_delegateQueue.maxConcurrentOperationCount == 1,
  501|      1|                          @"delegate queue %@ should support one concurrent operation, not %ld",
  502|      1|                          _delegateQueue.name,
  503|      1|                          (long)_delegateQueue.maxConcurrentOperationCount);
  504|      1|
  505|      1|  if (!_initialBeginFetchDate) {
  506|      1|    // This ivar is set only here on the initial beginFetch so need not be synchronized.
  507|      1|    _initialBeginFetchDate = [[NSDate alloc] init];
  508|      1|  }
  509|      1|
  510|      1|  if (self.sessionTask != nil) {
  511|      0|    // If cached fetcher returned through fetcherWithSessionIdentifier:, then it's
  512|      0|    // already begun, but don't consider this a failure, since the user need not know this.
  513|      0|    if (self.sessionIdentifier != nil) {
  514|      0|      return;
  515|      0|    }
  516|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"Fetch object %@ being reused; this should never happen", self);
  517|      0|    [self failToBeginFetchWithError:beginFailureError(GTMSessionFetcherErrorDownloadFailed)];
  518|      0|    return;
  519|      0|  }
  520|      1|
  521|      1|  if (fetchRequestURL == nil && !_downloadResumeData && !priorSessionIdentifier) {
  522|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"Beginning a fetch requires a request with a URL");
  523|      0|    [self failToBeginFetchWithError:beginFailureError(GTMSessionFetcherErrorDownloadFailed)];
  524|      0|    return;
  525|      0|  }
  526|      1|
  527|      1|  // We'll respect the user's request for a background session (unless this is
  528|      1|  // an upload fetcher, which does its initial request foreground.)
  529|      1|  self.usingBackgroundSession = self.useBackgroundSession && [self canFetchWithBackgroundSession];
  530|      1|
  531|      1|  NSURL *bodyFileURL = self.bodyFileURL;
  532|      1|  if (bodyFileURL) {
  533|      0|    NSError *fileCheckError;
  534|      0|    if (![bodyFileURL checkResourceIsReachableAndReturnError:&fileCheckError]) {
  535|      0|      // This assert fires when the file being uploaded no longer exists once
  536|      0|      // the fetcher is ready to start the upload.
  537|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(0, @"Body file is unreachable: %@\n  %@",
  538|      0|                                     bodyFileURL.path, fileCheckError);
  539|      0|      [self failToBeginFetchWithError:fileCheckError];
  540|      0|      return;
  541|      0|    }
  542|      1|  }
  543|      1|
  544|      1|  NSString *requestScheme = fetchRequestURL.scheme;
  545|      1|  BOOL isDataRequest = [requestScheme isEqual:@"data"];
  546|      1|  if (isDataRequest) {
  547|      0|    // NSURLSession does not support data URLs in background sessions.
  548|      0|#if DEBUG
  549|      0|    if (priorSessionIdentifier || self.sessionIdentifier) {
  550|      0|      GTMSESSION_LOG_DEBUG(@"Converting background to foreground session for %@",
  551|      0|                           fetchRequest);
  552|      0|    }
  553|      0|#endif
  554|      0|    [self setSessionIdentifierInternal:nil];
  555|      0|    self.useBackgroundSession = NO;
  556|      0|  }
  557|      1|
  558|       |#if GTM_ALLOW_INSECURE_REQUESTS
  559|       |  BOOL shouldCheckSecurity = NO;
  560|       |#else
  561|      1|  BOOL shouldCheckSecurity = (fetchRequestURL != nil
  562|      1|                              && !isDataRequest
  563|      1|                              && [[self class] appAllowsInsecureRequests]);
  564|      1|#endif
  565|      1|
  566|      1|  if (shouldCheckSecurity) {
  567|      0|    // Allow https only for requests, unless overridden by the client.
  568|      0|    //
  569|      0|    // Non-https requests may too easily be snooped, so we disallow them by default.
  570|      0|    //
  571|      0|    // file: and data: schemes are usually safe if they are hardcoded in the client or provided
  572|      0|    // by a trusted source, but since it's fairly rare to need them, it's safest to make clients
  573|      0|    // explicitly whitelist them.
  574|      0|    BOOL isSecure =
  575|      0|        requestScheme != nil && [requestScheme caseInsensitiveCompare:@"https"] == NSOrderedSame;
  576|      0|    if (!isSecure) {
  577|      0|      BOOL allowRequest = NO;
  578|      0|      NSString *host = fetchRequestURL.host;
  579|      0|
  580|      0|      // Check schemes first.  A file scheme request may be allowed here, or as a localhost request.
  581|      0|      for (NSString *allowedScheme in _allowedInsecureSchemes) {
  582|      0|        if (requestScheme != nil &&
  583|      0|            [requestScheme caseInsensitiveCompare:allowedScheme] == NSOrderedSame) {
  584|      0|          allowRequest = YES;
  585|      0|          break;
  586|      0|        }
  587|      0|      }
  588|      0|      if (!allowRequest) {
  589|      0|        // Check for localhost requests.  Security checks only occur for non-https requests, so
  590|      0|        // this check won't happen for an https request to localhost.
  591|      0|        BOOL isLocalhostRequest = (host.length == 0 && [fetchRequestURL isFileURL]) || IsLocalhost(host);
  592|      0|        if (isLocalhostRequest) {
  593|      0|          if (self.allowLocalhostRequest) {
  594|      0|            allowRequest = YES;
  595|      0|          } else {
  596|      0|            GTMSESSION_ASSERT_DEBUG(NO, @"Fetch request for localhost but fetcher"
  597|      0|                                        @" allowLocalhostRequest is not set: %@", fetchRequestURL);
  598|      0|          }
  599|      0|        } else {
  600|      0|          GTMSESSION_ASSERT_DEBUG(NO, @"Insecure fetch request has a scheme (%@)"
  601|      0|                                      @" not found in fetcher allowedInsecureSchemes (%@): %@",
  602|      0|                                  requestScheme, _allowedInsecureSchemes ?: @" @[] ", fetchRequestURL);
  603|      0|        }
  604|      0|      }
  605|      0|
  606|      0|      if (!allowRequest) {
  607|       |#if !DEBUG
  608|       |        NSLog(@"Insecure fetch disallowed for %@", fetchRequestURL.description ?: @"nil request URL");
  609|       |#endif
  610|       |        [self failToBeginFetchWithError:beginFailureError(GTMSessionFetcherErrorInsecureRequest)];
  611|      0|        return;
  612|      0|      }
  613|      1|    }  // !isSecure
  614|      0|  }  // (requestURL != nil) && !isDataRequest
  615|      1|
  616|      1|  if (self.cookieStorage == nil) {
  617|      1|    self.cookieStorage = [[self class] staticCookieStorage];
  618|      1|  }
  619|      1|
  620|      1|  BOOL isRecreatingSession = (self.sessionIdentifier != nil) && (fetchRequest == nil);
  621|      1|
  622|      1|  self.canShareSession = !isRecreatingSession && !self.usingBackgroundSession;
  623|      1|
  624|      1|  if (!self.session && self.canShareSession) {
  625|      1|    self.session = [_service sessionForFetcherCreation];
  626|      1|    // If _session is nil, then the service's session creation semaphore will block
  627|      1|    // until this fetcher invokes fetcherDidCreateSession: below, so this *must* invoke
  628|      1|    // that method, even if the session fails to be created.
  629|      1|  }
  630|      1|
  631|      1|  if (!self.session) {
  632|      1|    // Create a session.
  633|      1|    if (!_configuration) {
  634|      1|      if (priorSessionIdentifier || self.usingBackgroundSession) {
  635|      0|        NSString *sessionIdentifier = priorSessionIdentifier;
  636|      0|        if (!sessionIdentifier) {
  637|      0|          sessionIdentifier = [self createSessionIdentifierWithMetadata:nil];
  638|      0|        }
  639|      0|        NSMapTable *sessionIdentifierToFetcherMap = [[self class] sessionIdentifierToFetcherMap];
  640|      0|        [sessionIdentifierToFetcherMap setObject:self forKey:self.sessionIdentifier];
  641|      0|
  642|      0|        if (@available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)) {
  643|      0|          _configuration =
  644|      0|              [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:sessionIdentifier];
  645|      0|        } else {
  646|       |#if ((!TARGET_OS_IPHONE && MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_10) \
  647|       |     || (TARGET_OS_IPHONE && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_8_0))
  648|       |          // If building with support for iOS 7 or < macOS 10.10, allow using the older
  649|       |          // -backgroundSessionConfiguration: method, otherwise leave it out to avoid deprecated
  650|       |          // API warnings/errors.
  651|       |          _configuration =
  652|       |              [NSURLSessionConfiguration backgroundSessionConfiguration:sessionIdentifier];
  653|       |#endif
  654|       |        }
  655|      0|        self.usingBackgroundSession = YES;
  656|      0|        self.canShareSession = NO;
  657|      1|      } else {
  658|      1|        _configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
  659|      1|      }
  660|      1|#if !GTM_ALLOW_INSECURE_REQUESTS
  661|       |#if GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION
  662|       |      _configuration.TLSMinimumSupportedProtocolVersion = tls_protocol_version_TLSv12;
  663|       |#elif GTM_SDK_SUPPORTS_TLSMINIMUMSUPPORTEDPROTOCOLVERSION
  664|      1|      if (@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)) {
  665|      1|#if TARGET_OS_IOS
  666|      1|        // Early seeds of iOS 13 don't actually support the selector and several
  667|      1|        // months later, those seeds are still in use, so validate if the selector
  668|      1|        // is supported.
  669|      1|        if ([_configuration respondsToSelector:@selector(setTLSMinimumSupportedProtocolVersion:)]) {
  670|      1|          _configuration.TLSMinimumSupportedProtocolVersion = tls_protocol_version_TLSv12;
  671|      1|        } else {
  672|      0|          _configuration.TLSMinimumSupportedProtocol = kTLSProtocol12;
  673|      0|        }
  674|       |#else
  675|       |        _configuration.TLSMinimumSupportedProtocolVersion = tls_protocol_version_TLSv12;
  676|       |#endif  // TARGET_OS_IOS
  677|      0|      } else {
  678|      0|        _configuration.TLSMinimumSupportedProtocol = kTLSProtocol12;
  679|      0|      }
  680|       |#else
  681|       |      _configuration.TLSMinimumSupportedProtocol = kTLSProtocol12;
  682|       |#endif  // GTM_SDK_REQUIRES_TLSMINIMUMSUPPORTEDPROTOCOLVERSION
  683|       |#endif
  684|      1|    }  // !_configuration
  685|      1|    _configuration.HTTPCookieStorage = self.cookieStorage;
  686|      1|
  687|      1|    if (_configurationBlock) {
  688|      0|      _configurationBlock(self, _configuration);
  689|      0|    }
  690|      1|
  691|      1|    id<NSURLSessionDelegate> delegate = [_service sessionDelegate];
  692|      1|    if (!delegate || !self.canShareSession) {
  693|      1|      delegate = self;
  694|      1|    }
  695|      1|    self.session = [NSURLSession sessionWithConfiguration:_configuration
  696|      1|                                                 delegate:delegate
  697|      1|                                            delegateQueue:self.sessionDelegateQueue];
  698|      1|    GTMSESSION_ASSERT_DEBUG(self.session, @"Couldn't create session");
  699|      1|
  700|      1|    // Tell the service about the session created by this fetcher.  This also signals the
  701|      1|    // service's semaphore to allow other fetchers to request this session.
  702|      1|    [_service fetcherDidCreateSession:self];
  703|      1|
  704|      1|    // If this assertion fires, the client probably tried to use a session identifier that was
  705|      1|    // already used. The solution is to make the client use a unique identifier (or better yet let
  706|      1|    // the session fetcher assign the identifier).
  707|      1|    GTMSESSION_ASSERT_DEBUG(self.session.delegate == delegate, @"Couldn't assign delegate.");
  708|      1|
  709|      1|    if (self.session) {
  710|      1|      BOOL isUsingSharedDelegate = (delegate != self);
  711|      1|      if (!isUsingSharedDelegate) {
  712|      1|        _shouldInvalidateSession = YES;
  713|      1|      }
  714|      1|    }
  715|      1|  }
  716|      1|
  717|      1|  if (isRecreatingSession) {
  718|      0|    _shouldInvalidateSession = YES;
  719|      0|
  720|      0|    // Let's make sure there are tasks still running or if not that we get a callback from a
  721|      0|    // completed one; otherwise, we assume the tasks failed.
  722|      0|    // This is the observed behavior perhaps 25% of the time within the Simulator running 7.0.3 on
  723|      0|    // exiting the app after starting an upload and relaunching the app if we manage to relaunch
  724|      0|    // after the task has completed, but before the system relaunches us in the background.
  725|      0|    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks,
  726|      0|                                                  NSArray *downloadTasks) {
  727|      0|      if (dataTasks.count == 0 && uploadTasks.count == 0 && downloadTasks.count == 0) {
  728|      0|        double const kDelayInSeconds = 1.0;  // We should get progress indication or completion soon
  729|      0|        dispatch_time_t checkForFeedbackDelay =
  730|      0|            dispatch_time(DISPATCH_TIME_NOW, (int64_t)(kDelayInSeconds * NSEC_PER_SEC));
  731|      0|        dispatch_after(checkForFeedbackDelay, dispatch_get_main_queue(), ^{
  732|      0|          if (!self.sessionTask && !fetchRequest) {
  733|      0|            // If our task and/or request haven't been restored, then we assume task feedback lost.
  734|      0|            [self removePersistedBackgroundSessionFromDefaults];
  735|      0|            NSError *sessionError =
  736|      0|                [NSError errorWithDomain:kGTMSessionFetcherErrorDomain
  737|      0|                                    code:GTMSessionFetcherErrorBackgroundFetchFailed
  738|      0|                                userInfo:nil];
  739|      0|            [self failToBeginFetchWithError:sessionError];
  740|      0|          }
  741|      0|        });
  742|      0|      }
  743|      0|    }];
  744|      0|    return;
  745|      0|  }
  746|      1|
  747|      1|  self.downloadedData = nil;
  748|      1|  self.downloadedLength = 0;
  749|      1|
  750|      1|  if (_servicePriority == NSIntegerMin) {
  751|      0|    mayDelay = NO;
  752|      0|  }
  753|      1|  if (mayDelay && _service) {
  754|      1|    BOOL shouldFetchNow = [_service fetcherShouldBeginFetching:self];
  755|      1|    if (!shouldFetchNow) {
  756|      0|      // The fetch is deferred, but will happen later.
  757|      0|      //
  758|      0|      // If this session is held by the fetcher service, clear the session now so that we don't
  759|      0|      // assume it's still valid after the fetcher is restarted.
  760|      0|      if (self.canShareSession) {
  761|      0|        self.session = nil;
  762|      0|      }
  763|      0|      return;
  764|      0|    }
  765|      1|  }
  766|      1|
  767|      1|  NSString *effectiveHTTPMethod = [fetchRequest valueForHTTPHeaderField:@"X-HTTP-Method-Override"];
  768|      1|  if (effectiveHTTPMethod == nil) {
  769|      1|    effectiveHTTPMethod = fetchRequest.HTTPMethod;
  770|      1|  }
  771|      1|  BOOL isEffectiveHTTPGet = (effectiveHTTPMethod == nil
  772|      1|                             || [effectiveHTTPMethod isEqual:@"GET"]);
  773|      1|
  774|      1|  BOOL needsUploadTask = (self.useUploadTask || self.bodyFileURL || self.bodyStreamProvider);
  775|      1|  if (_bodyData || self.bodyStreamProvider || fetchRequest.HTTPBodyStream) {
  776|      1|    if (isEffectiveHTTPGet) {
  777|      1|      fetchRequest.HTTPMethod = @"POST";
  778|      1|      isEffectiveHTTPGet = NO;
  779|      1|    }
  780|      1|
  781|      1|    if (_bodyData) {
  782|      1|      if (!needsUploadTask) {
  783|      1|        fetchRequest.HTTPBody = _bodyData;
  784|      1|      }
  785|      1|#if !STRIP_GTM_FETCH_LOGGING
  786|      1|    } else if (fetchRequest.HTTPBodyStream) {
  787|      0|      if ([self respondsToSelector:@selector(loggedInputStreamForInputStream:)]) {
  788|      0|        fetchRequest.HTTPBodyStream =
  789|      0|            [self performSelector:@selector(loggedInputStreamForInputStream:)
  790|      0|                       withObject:fetchRequest.HTTPBodyStream];
  791|      0|      }
  792|      0|#endif
  793|      0|    }
  794|      1|  }
  795|      1|
  796|      1|  // We authorize after setting up the http method and body in the request
  797|      1|  // because OAuth 1 may need to sign the request body
  798|      1|  if (mayAuthorize && _authorizer && !isDataRequest) {
  799|      0|    BOOL isAuthorized = [_authorizer isAuthorizedRequest:fetchRequest];
  800|      0|    if (!isAuthorized) {
  801|      0|      // Authorization needed.
  802|      0|      //
  803|      0|      // If this session is held by the fetcher service, clear the session now so that we don't
  804|      0|      // assume it's still valid after authorization completes.
  805|      0|      if (self.canShareSession) {
  806|      0|        self.session = nil;
  807|      0|      }
  808|      0|
  809|      0|      // Authorizing the request will recursively call this beginFetch:mayDelay:
  810|      0|      // or failToBeginFetchWithError:.
  811|      0|      [self authorizeRequest];
  812|      0|      return;
  813|      0|    }
  814|      1|  }
  815|      1|
  816|      1|  // set the default upload or download retry interval, if necessary
  817|      1|  if ([self isRetryEnabled] && self.maxRetryInterval <= 0) {
  818|      0|    if (isEffectiveHTTPGet || [effectiveHTTPMethod isEqual:@"HEAD"]) {
  819|      0|      [self setMaxRetryInterval:kDefaultMaxDownloadRetryInterval];
  820|      0|    } else {
  821|      0|      [self setMaxRetryInterval:kDefaultMaxUploadRetryInterval];
  822|      0|    }
  823|      0|  }
  824|      1|
  825|      1|  // finally, start the connection
  826|      1|  NSURLSessionTask *newSessionTask;
  827|      1|  BOOL needsDataAccumulator = NO;
  828|      1|  if (_downloadResumeData) {
  829|      0|    newSessionTask = [_session downloadTaskWithResumeData:_downloadResumeData];
  830|      0|    GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask,
  831|      0|        @"Failed downloadTaskWithResumeData for %@, resume data %lu bytes",
  832|      0|        _session, (unsigned long)_downloadResumeData.length);
  833|      1|  } else if (_destinationFileURL && !isDataRequest) {
  834|      0|    newSessionTask = [_session downloadTaskWithRequest:fetchRequest];
  835|      0|    GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask, @"Failed downloadTaskWithRequest for %@, %@",
  836|      0|                                   _session, fetchRequest);
  837|      1|  } else if (needsUploadTask) {
  838|      0|    if (bodyFileURL) {
  839|      0|      newSessionTask = [_session uploadTaskWithRequest:fetchRequest
  840|      0|                                              fromFile:bodyFileURL];
  841|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask,
  842|      0|                                     @"Failed uploadTaskWithRequest for %@, %@, file %@",
  843|      0|                                     _session, fetchRequest, bodyFileURL.path);
  844|      0|    } else if (self.bodyStreamProvider) {
  845|      0|      newSessionTask = [_session uploadTaskWithStreamedRequest:fetchRequest];
  846|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask,
  847|      0|                                     @"Failed uploadTaskWithStreamedRequest for %@, %@",
  848|      0|                                     _session, fetchRequest);
  849|      0|    } else {
  850|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(_bodyData != nil,
  851|      0|                                     @"Upload task needs body data, %@", fetchRequest);
  852|      0|      newSessionTask = [_session uploadTaskWithRequest:fetchRequest
  853|      0|                                            fromData:(NSData * GTM_NONNULL_TYPE)_bodyData];
  854|      0|      GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask,
  855|      0|          @"Failed uploadTaskWithRequest for %@, %@, body data %lu bytes",
  856|      0|          _session, fetchRequest, (unsigned long)_bodyData.length);
  857|      0|    }
  858|      0|    needsDataAccumulator = YES;
  859|      1|  } else {
  860|      1|    newSessionTask = [_session dataTaskWithRequest:fetchRequest];
  861|      1|    needsDataAccumulator = YES;
  862|      1|    GTMSESSION_ASSERT_DEBUG_OR_LOG(newSessionTask, @"Failed dataTaskWithRequest for %@, %@",
  863|      1|                                   _session, fetchRequest);
  864|      1|  }
  865|      1|  self.sessionTask = newSessionTask;
  866|      1|
  867|      1|  if (!newSessionTask) {
  868|      0|    // We shouldn't get here; if we're here, an earlier assertion should have fired to explain
  869|      0|    // which session task creation failed.
  870|      0|    [self failToBeginFetchWithError:beginFailureError(GTMSessionFetcherErrorTaskCreationFailed)];
  871|      0|    return;
  872|      0|  }
  873|      1|
  874|      1|  if (needsDataAccumulator && _accumulateDataBlock == nil) {
  875|      1|    self.downloadedData = [NSMutableData data];
  876|      1|  }
  877|      1|  if (_taskDescription) {
  878|      0|    newSessionTask.taskDescription = _taskDescription;
  879|      0|  }
  880|      1|  if (_taskPriority >= 0) {
  881|      0|    if (@available(iOS 8.0, macOS 10.10, *)) {
  882|      0|      newSessionTask.priority = _taskPriority;
  883|      0|    }
  884|      0|  }
  885|      1|
  886|       |#if GTM_DISABLE_FETCHER_TEST_BLOCK
  887|       |  GTMSESSION_ASSERT_DEBUG(_testBlock == nil && gGlobalTestBlock == nil, @"test blocks disabled");
  888|       |  _testBlock = nil;
  889|       |#else
  890|      1|  if (!_testBlock) {
  891|      1|    if (gGlobalTestBlock) {
  892|      0|      // Note that the test block may pass nil for all of its response parameters,
  893|      0|      // indicating that the fetch should actually proceed. This is useful when the
  894|      0|      // global test block has been set, and the app is only testing a specific
  895|      0|      // fetcher.  The block simulation code will then resume the task.
  896|      0|      _testBlock = gGlobalTestBlock;
  897|      0|    }
  898|      1|  }
  899|      1|  _isUsingTestBlock = (_testBlock != nil);
  900|      1|#endif  // GTM_DISABLE_FETCHER_TEST_BLOCK
  901|      1|
  902|      1|#if GTM_BACKGROUND_TASK_FETCHING
  903|      1|  id<GTMUIApplicationProtocol> app = [[self class] fetcherUIApplication];
  904|      1|  // Background tasks seem to interfere with out-of-process uploads and downloads.
  905|      1|  if (app && !self.skipBackgroundTask && !self.useBackgroundSession) {
  906|      1|    // Tell UIApplication that we want to continue even when the app is in the
  907|      1|    // background.
  908|      1|#if DEBUG
  909|      1|    NSString *bgTaskName = [NSString stringWithFormat:@"%@-%@",
  910|      1|                            [self class], fetchRequest.URL.host];
  911|       |#else
  912|       |    NSString *bgTaskName = @"GTMSessionFetcher";
  913|       |#endif
  914|       |    __block UIBackgroundTaskIdentifier bgTaskID = [app beginBackgroundTaskWithName:bgTaskName
  915|      1|                                                                 expirationHandler:^{
  916|      0|      // Background task expiration callback - this block is always invoked by
  917|      0|      // UIApplication on the main thread.
  918|      0|      if (bgTaskID != UIBackgroundTaskInvalid) {
  919|      0|        @synchronized(self) {
  920|      0|          if (bgTaskID == self.backgroundTaskIdentifier) {
  921|      0|            self.backgroundTaskIdentifier = UIBackgroundTaskInvalid;
  922|      0|          }
  923|      0|        }
  924|      0|        [app endBackgroundTask:bgTaskID];
  925|      0|      }
  926|      0|    }];
  927|      1|    @synchronized(self) {
  928|      1|      self.backgroundTaskIdentifier = bgTaskID;
  929|      1|    }
  930|      1|  }
  931|      1|#endif
  932|      1|
  933|      1|  if (!_initialRequestDate) {
  934|      1|    _initialRequestDate = [[NSDate alloc] init];
  935|      1|  }
  936|      1|
  937|      1|  // We don't expect to reach here even on retry or auth until a stop notification has been sent
  938|      1|  // for the previous task, but we should ensure that we don't unbalance that.
  939|      1|  GTMSESSION_ASSERT_DEBUG(!_isStopNotificationNeeded, @"Start notification without a prior stop");
  940|      1|  [self sendStopNotificationIfNeeded];
  941|      1|
  942|      1|  [self addPersistedBackgroundSessionToDefaults];
  943|      1|
  944|      1|  [self setStopNotificationNeeded:YES];
  945|      1|
  946|      1|  [self postNotificationOnMainThreadWithName:kGTMSessionFetcherStartedNotification
  947|      1|                                    userInfo:nil
  948|      1|                                requireAsync:NO];
  949|      1|
  950|      1|  // The service needs to know our task if it is serving as NSURLSession delegate.
  951|      1|  [_service fetcherDidBeginFetching:self];
  952|      1|
  953|      1|  if (_testBlock) {
  954|      0|#if !GTM_DISABLE_FETCHER_TEST_BLOCK
  955|      0|    [self simulateFetchForTestBlock];
  956|      0|#endif
  957|      1|  } else {
  958|      1|    // We resume the session task after posting the notification since the
  959|      1|    // delegate callbacks may happen immediately if the fetch is started off
  960|      1|    // the main thread or the session delegate queue is on a background thread,
  961|      1|    // and we don't want to post a start notification after a premature finish
  962|      1|    // of the session task.
  963|      1|    [newSessionTask resume];
  964|      1|  }
  965|      1|}
  966|       |
  967|      0|NSData * GTM_NULLABLE_TYPE GTMDataFromInputStream(NSInputStream *inputStream, NSError **outError) {
  968|      0|  NSMutableData *data = [NSMutableData data];
  969|      0|
  970|      0|  [inputStream open];
  971|      0|  NSInteger numberOfBytesRead = 0;
  972|      0|  while ([inputStream hasBytesAvailable]) {
  973|      0|    uint8_t buffer[512];
  974|      0|    numberOfBytesRead = [inputStream read:buffer maxLength:sizeof(buffer)];
  975|      0|    if (numberOfBytesRead > 0) {
  976|      0|      [data appendBytes:buffer length:(NSUInteger)numberOfBytesRead];
  977|      0|    } else {
  978|      0|      break;
  979|      0|    }
  980|      0|  }
  981|      0|  [inputStream close];
  982|      0|  NSError *streamError = inputStream.streamError;
  983|      0|
  984|      0|  if (streamError) {
  985|      0|    data = nil;
  986|      0|  }
  987|      0|  if (outError) {
  988|      0|    *outError = streamError;
  989|      0|  }
  990|      0|  return data;
  991|      0|}
  992|       |
  993|       |#if !GTM_DISABLE_FETCHER_TEST_BLOCK
  994|       |
  995|      0|- (void)simulateFetchForTestBlock {
  996|      0|  // This is invoked on the same thread as the beginFetch method was.
  997|      0|  //
  998|      0|  // Callbacks will all occur on the callback queue.
  999|      0|  _testBlock(self, ^(NSURLResponse *response, NSData *responseData, NSError *error) {
 1000|      0|      // Callback from test block.
 1001|      0|      if (response == nil && responseData == nil && error == nil) {
 1002|      0|        // Assume the fetcher should execute rather than be tested.
 1003|      0|        self->_testBlock = nil;
 1004|      0|        self->_isUsingTestBlock = NO;
 1005|      0|        [self->_sessionTask resume];
 1006|      0|        return;
 1007|      0|      }
 1008|      0|
 1009|      0|      GTMSessionFetcherBodyStreamProvider bodyStreamProvider = self.bodyStreamProvider;
 1010|      0|      if (bodyStreamProvider) {
 1011|      0|        bodyStreamProvider(^(NSInputStream *bodyStream){
 1012|      0|          // Read from the input stream into an NSData buffer.  We'll drain the stream
 1013|      0|          // explicitly on a background queue.
 1014|      0|          [self invokeOnCallbackQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)
 1015|      0|                     afterUserStopped:NO
 1016|      0|                                block:^{
 1017|      0|            NSError *streamError;
 1018|      0|            NSData *streamedData = GTMDataFromInputStream(bodyStream, &streamError);
 1019|      0|
 1020|      0|            dispatch_async(dispatch_get_main_queue(), ^{
 1021|      0|              // Continue callbacks on the main thread, since serial behavior
 1022|      0|              // is more reliable for tests.
 1023|      0|              [self simulateDataCallbacksForTestBlockWithBodyData:streamedData
 1024|      0|                                                         response:response
 1025|      0|                                                     responseData:responseData
 1026|      0|                                                            error:(error ?: streamError)];
 1027|      0|            });
 1028|      0|          }];
 1029|      0|        });
 1030|      0|      } else {
 1031|      0|        // No input stream; use the supplied data or file URL.
 1032|      0|        NSURL *bodyFileURL = self.bodyFileURL;
 1033|      0|        if (bodyFileURL) {
 1034|      0|          NSError *readError;
 1035|      0|          self->_bodyData = [NSData dataWithContentsOfURL:bodyFileURL
 1036|      0|                                            options:NSDataReadingMappedIfSafe
 1037|      0|                                              error:&readError];
 1038|      0|          error = readError;
 1039|      0|        }
 1040|      0|
 1041|      0|        // No stream provider.
 1042|      0|
 1043|      0|        // In real fetches, nothing happens until the run loop spins, so apps have leeway to
 1044|      0|        // set callbacks after they call beginFetch. We'll mirror that fetcher behavior by
 1045|      0|        // delaying callbacks here at least to the next spin of the run loop.  That keeps
 1046|      0|        // immediate, synchronous setting of callback blocks after beginFetch working in tests.
 1047|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1048|      0|          [self simulateDataCallbacksForTestBlockWithBodyData:self->_bodyData
 1049|      0|                                                     response:response
 1050|      0|                                                 responseData:responseData
 1051|      0|                                                        error:error];
 1052|      0|        });
 1053|      0|      }
 1054|      0|    });
 1055|      0|}
 1056|       |
 1057|       |- (void)simulateByteTransferReportWithDataLength:(int64_t)totalDataLength
 1058|      0|                                           block:(GTMSessionFetcherSendProgressBlock)block {
 1059|      0|  // This utility method simulates transfer progress with up to three callbacks.
 1060|      0|  // It is used to call back to any of the progress blocks.
 1061|      0|  int64_t sendReportSize = totalDataLength / 3 + 1;
 1062|      0|  int64_t totalSent = 0;
 1063|      0|  while (totalSent < totalDataLength) {
 1064|      0|    int64_t bytesRemaining = totalDataLength - totalSent;
 1065|      0|    sendReportSize = MIN(sendReportSize, bytesRemaining);
 1066|      0|    totalSent += sendReportSize;
 1067|      0|    [self invokeOnCallbackQueueUnlessStopped:^{
 1068|      0|        block(sendReportSize, totalSent, totalDataLength);
 1069|      0|    }];
 1070|      0|  }
 1071|      0|}
 1072|       |
 1073|       |- (void)simulateDataCallbacksForTestBlockWithBodyData:(NSData * GTM_NULLABLE_TYPE)bodyData
 1074|       |                                             response:(NSURLResponse *)response
 1075|       |                                         responseData:(NSData *)suppliedData
 1076|      0|                                                error:(NSError *)suppliedError {
 1077|      0|  __block NSData *responseData = suppliedData;
 1078|      0|  __block NSError *responseError = suppliedError;
 1079|      0|
 1080|      0|  // This method does the test simulation of callbacks once the upload
 1081|      0|  // and download data are known.
 1082|      0|  @synchronized(self) {
 1083|      0|    GTMSessionMonitorSynchronized(self);
 1084|      0|
 1085|      0|    // Get copies of ivars we'll access in async invocations.  This simulation assumes
 1086|      0|    // they won't change during fetcher execution.
 1087|      0|    NSURL *destinationFileURL = _destinationFileURL;
 1088|      0|    GTMSessionFetcherWillRedirectBlock willRedirectBlock = _willRedirectBlock;
 1089|      0|    GTMSessionFetcherDidReceiveResponseBlock didReceiveResponseBlock = _didReceiveResponseBlock;
 1090|      0|    GTMSessionFetcherSendProgressBlock sendProgressBlock = _sendProgressBlock;
 1091|      0|    GTMSessionFetcherDownloadProgressBlock downloadProgressBlock = _downloadProgressBlock;
 1092|      0|    GTMSessionFetcherAccumulateDataBlock accumulateDataBlock = _accumulateDataBlock;
 1093|      0|    GTMSessionFetcherReceivedProgressBlock receivedProgressBlock = _receivedProgressBlock;
 1094|      0|    GTMSessionFetcherWillCacheURLResponseBlock willCacheURLResponseBlock =
 1095|      0|        _willCacheURLResponseBlock;
 1096|      0|    GTMSessionFetcherChallengeBlock challengeBlock = _challengeBlock;
 1097|      0|
 1098|      0|    // Simulate receipt of redirection.
 1099|      0|    if (willRedirectBlock) {
 1100|      0|      [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:YES
 1101|      0|                                                          block:^{
 1102|      0|          willRedirectBlock((NSHTTPURLResponse *)response, self->_request,
 1103|      0|                             ^(NSURLRequest *redirectRequest) {
 1104|      0|              // For simulation, we'll assume the app will just continue.
 1105|      0|          });
 1106|      0|      }];
 1107|      0|    }
 1108|      0|
 1109|      0|    // If the fetcher has a challenge block, simulate a challenge.
 1110|      0|    //
 1111|      0|    // It might be nice to eventually let the user determine which testBlock
 1112|      0|    // fetches get challenged rather than always executing the supplied
 1113|      0|    // challenge block.
 1114|      0|    if (challengeBlock) {
 1115|      0|      [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:YES
 1116|      0|                                                          block:^{
 1117|      0|        NSURL *requestURL = self->_request.URL;
 1118|      0|        NSString *host = requestURL.host;
 1119|      0|        NSURLProtectionSpace *pspace =
 1120|      0|            [[NSURLProtectionSpace alloc] initWithHost:host
 1121|      0|                                                  port:requestURL.port.integerValue
 1122|      0|                                              protocol:requestURL.scheme
 1123|      0|                                                 realm:nil
 1124|      0|                                  authenticationMethod:NSURLAuthenticationMethodHTTPBasic];
 1125|      0|        id<NSURLAuthenticationChallengeSender> unusedSender =
 1126|      0|            (id<NSURLAuthenticationChallengeSender>)[NSNull null];
 1127|      0|        NSURLAuthenticationChallenge *challenge =
 1128|      0|            [[NSURLAuthenticationChallenge alloc] initWithProtectionSpace:pspace
 1129|      0|                                                       proposedCredential:nil
 1130|      0|                                                     previousFailureCount:0
 1131|      0|                                                          failureResponse:nil
 1132|      0|                                                                    error:nil
 1133|      0|                                                                   sender:unusedSender];
 1134|      0|        challengeBlock(self, challenge, ^(NSURLSessionAuthChallengeDisposition disposition,
 1135|      0|                                          NSURLCredential * GTM_NULLABLE_TYPE credential){
 1136|      0|          // We could change the responseData and responseError based on the disposition,
 1137|      0|          // but it's easier for apps to just supply the expected data and error
 1138|      0|          // directly to the test block. So this simulation ignores the disposition.
 1139|      0|        });
 1140|      0|      }];
 1141|      0|    }
 1142|      0|
 1143|      0|    // Simulate receipt of an initial response.
 1144|      0|    if (response && didReceiveResponseBlock) {
 1145|      0|      [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:YES
 1146|      0|                                                          block:^{
 1147|      0|          didReceiveResponseBlock(response, ^(NSURLSessionResponseDisposition desiredDisposition) {
 1148|      0|            // For simulation, we'll assume the disposition is to continue.
 1149|      0|          });
 1150|      0|      }];
 1151|      0|    }
 1152|      0|
 1153|      0|    // Simulate reporting send progress.
 1154|      0|    if (sendProgressBlock) {
 1155|      0|      [self simulateByteTransferReportWithDataLength:(int64_t)bodyData.length
 1156|      0|                                               block:^(int64_t bytesSent,
 1157|      0|                                                       int64_t totalBytesSent,
 1158|      0|                                                       int64_t totalBytesExpectedToSend) {
 1159|      0|          // This is invoked on the callback queue unless stopped.
 1160|      0|          sendProgressBlock(bytesSent, totalBytesSent, totalBytesExpectedToSend);
 1161|      0|      }];
 1162|      0|    }
 1163|      0|
 1164|      0|    if (destinationFileURL) {
 1165|      0|      // Simulate download to file progress.
 1166|      0|      if (downloadProgressBlock) {
 1167|      0|        [self simulateByteTransferReportWithDataLength:(int64_t)responseData.length
 1168|      0|                                                 block:^(int64_t bytesDownloaded,
 1169|      0|                                                         int64_t totalBytesDownloaded,
 1170|      0|                                                         int64_t totalBytesExpectedToDownload) {
 1171|      0|            // This is invoked on the callback queue unless stopped.
 1172|      0|            downloadProgressBlock(bytesDownloaded, totalBytesDownloaded,
 1173|      0|                                  totalBytesExpectedToDownload);
 1174|      0|        }];
 1175|      0|      }
 1176|      0|
 1177|      0|      NSError *writeError;
 1178|      0|      [responseData writeToURL:destinationFileURL
 1179|      0|                       options:NSDataWritingAtomic
 1180|      0|                         error:&writeError];
 1181|      0|      if (writeError) {
 1182|      0|        // Tell the test code that writing failed.
 1183|      0|        responseError = writeError;
 1184|      0|      }
 1185|      0|    } else {
 1186|      0|      // Simulate download to NSData progress.
 1187|      0|      if ((accumulateDataBlock || receivedProgressBlock) && responseData) {
 1188|      0|        [self simulateByteTransferWithData:responseData
 1189|      0|                                     block:^(NSData *data,
 1190|      0|                                             int64_t bytesReceived,
 1191|      0|                                             int64_t totalBytesReceived,
 1192|      0|                                             int64_t totalBytesExpectedToReceive) {
 1193|      0|          // This is invoked on the callback queue unless stopped.
 1194|      0|          if (accumulateDataBlock) {
 1195|      0|            accumulateDataBlock(data);
 1196|      0|          }
 1197|      0|
 1198|      0|          if (receivedProgressBlock) {
 1199|      0|            receivedProgressBlock(bytesReceived, totalBytesReceived);
 1200|      0|          }
 1201|      0|        }];
 1202|      0|      }
 1203|      0|
 1204|      0|      if (!accumulateDataBlock) {
 1205|      0|        _downloadedData = [responseData mutableCopy];
 1206|      0|      }
 1207|      0|
 1208|      0|      if (willCacheURLResponseBlock) {
 1209|      0|        // Simulate letting the client inspect and alter the cached response.
 1210|      0|        NSData *cachedData = responseData ?: [[NSData alloc] init];  // Always have non-nil data.
 1211|      0|        NSCachedURLResponse *cachedResponse =
 1212|      0|            [[NSCachedURLResponse alloc] initWithResponse:response
 1213|      0|                                                     data:cachedData];
 1214|      0|        [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:YES
 1215|      0|                                                            block:^{
 1216|      0|            willCacheURLResponseBlock(cachedResponse, ^(NSCachedURLResponse *responseToCache){
 1217|      0|                // The app may provide an alternative response, or nil to defeat caching.
 1218|      0|            });
 1219|      0|        }];
 1220|      0|      }
 1221|      0|    }
 1222|      0|    _response = response;
 1223|      0|  }  // @synchronized(self)
 1224|      0|
 1225|      0|  NSOperationQueue *queue = self.sessionDelegateQueue;
 1226|      0|  [queue addOperationWithBlock:^{
 1227|      0|    // Rather than invoke failToBeginFetchWithError: we want to simulate completion of
 1228|      0|    // a connection that started and ended, so we'll call down to finishWithError:
 1229|      0|    NSInteger status = responseError ? responseError.code : 200;
 1230|      0|    if (status >= 200 && status <= 399) {
 1231|      0|      [self finishWithError:nil shouldRetry:NO];
 1232|      0|    } else {
 1233|      0|      [self shouldRetryNowForStatus:status
 1234|      0|                              error:responseError
 1235|      0|                   forceAssumeRetry:NO
 1236|      0|                           response:^(BOOL shouldRetry) {
 1237|      0|          [self finishWithError:responseError shouldRetry:shouldRetry];
 1238|      0|      }];
 1239|      0|    }
 1240|      0|  }];
 1241|      0|}
 1242|       |
 1243|       |- (void)simulateByteTransferWithData:(NSData *)responseData
 1244|      0|                               block:(GTMSessionFetcherSimulateByteTransferBlock)transferBlock {
 1245|      0|  // This utility method simulates transfering data to the client. It divides the data into at most
 1246|      0|  // "chunkCount" chunks and then passes each chunk along with a progress update to transferBlock.
 1247|      0|  // This function can be used with accumulateDataBlock or receivedProgressBlock.
 1248|      0|
 1249|      0|  NSUInteger chunkCount = MAX(self.testBlockAccumulateDataChunkCount, (NSUInteger) 1);
 1250|      0|  NSUInteger totalDataLength = responseData.length;
 1251|      0|  NSUInteger sendDataSize = totalDataLength / chunkCount + 1;
 1252|      0|  NSUInteger totalSent = 0;
 1253|      0|  while (totalSent < totalDataLength) {
 1254|      0|    NSUInteger bytesRemaining = totalDataLength - totalSent;
 1255|      0|    sendDataSize = MIN(sendDataSize, bytesRemaining);
 1256|      0|    NSData *chunkData = [responseData subdataWithRange:NSMakeRange(totalSent, sendDataSize)];
 1257|      0|    totalSent += sendDataSize;
 1258|      0|    [self invokeOnCallbackQueueUnlessStopped:^{
 1259|      0|      transferBlock(chunkData,
 1260|      0|                    (int64_t)sendDataSize,
 1261|      0|                    (int64_t)totalSent,
 1262|      0|                    (int64_t)totalDataLength);
 1263|      0|    }];
 1264|      0|  }
 1265|      0|}
 1266|       |
 1267|       |#endif  // !GTM_DISABLE_FETCHER_TEST_BLOCK
 1268|       |
 1269|      1|- (void)setSessionTask:(NSURLSessionTask *)sessionTask {
 1270|      1|  @synchronized(self) {
 1271|      1|    GTMSessionMonitorSynchronized(self);
 1272|      1|
 1273|      1|    if (_sessionTask != sessionTask) {
 1274|      1|      _sessionTask = sessionTask;
 1275|      1|      if (_sessionTask) {
 1276|      1|        // Request could be nil on restoring this fetcher from a background session.
 1277|      1|        if (!_request) {
 1278|      0|          _request = [_sessionTask.originalRequest mutableCopy];
 1279|      0|        }
 1280|      1|      }
 1281|      1|    }
 1282|      1|  }  // @synchronized(self)
 1283|      1|}
 1284|       |
 1285|      1|- (NSURLSessionTask * GTM_NULLABLE_TYPE)sessionTask {
 1286|      1|  @synchronized(self) {
 1287|      1|    GTMSessionMonitorSynchronized(self);
 1288|      1|
 1289|      1|    return _sessionTask;
 1290|      1|  }  // @synchronized(self)
 1291|      1|}
 1292|       |
 1293|      2|+ (NSUserDefaults *)fetcherUserDefaults {
 1294|      2|  static NSUserDefaults *gFetcherUserDefaults = nil;
 1295|      2|
 1296|      2|  static dispatch_once_t onceToken;
 1297|      2|  dispatch_once(&onceToken, ^{
 1298|      1|    Class fetcherUserDefaultsClass = NSClassFromString(@"GTMSessionFetcherUserDefaultsFactory");
 1299|      1|    if (fetcherUserDefaultsClass) {
 1300|      0|      gFetcherUserDefaults = [fetcherUserDefaultsClass fetcherUserDefaults];
 1301|      1|    } else {
 1302|      1|      gFetcherUserDefaults = [NSUserDefaults standardUserDefaults];
 1303|      1|    }
 1304|      1|  });
 1305|      2|  return gFetcherUserDefaults;
 1306|      2|}
 1307|       |
 1308|      1|- (void)addPersistedBackgroundSessionToDefaults {
 1309|      1|  NSString *sessionIdentifier = self.sessionIdentifier;
 1310|      1|  if (!sessionIdentifier) {
 1311|      1|    return;
 1312|      1|  }
 1313|      0|  NSArray *oldBackgroundSessions = [[self class] activePersistedBackgroundSessions];
 1314|      0|  if ([oldBackgroundSessions containsObject:_sessionIdentifier]) {
 1315|      0|    return;
 1316|      0|  }
 1317|      0|  NSMutableArray *newBackgroundSessions =
 1318|      0|      [NSMutableArray arrayWithArray:oldBackgroundSessions];
 1319|      0|  [newBackgroundSessions addObject:sessionIdentifier];
 1320|      0|  GTM_LOG_BACKGROUND_SESSION(@"Add to background sessions: %@", newBackgroundSessions);
 1321|      0|
 1322|      0|  NSUserDefaults *userDefaults = [[self class] fetcherUserDefaults];
 1323|      0|  [userDefaults setObject:newBackgroundSessions
 1324|      0|                   forKey:kGTMSessionFetcherPersistedDestinationKey];
 1325|      0|  [userDefaults synchronize];
 1326|      0|}
 1327|       |
 1328|      0|- (void)removePersistedBackgroundSessionFromDefaults {
 1329|      0|  NSString *sessionIdentifier = self.sessionIdentifier;
 1330|      0|  if (!sessionIdentifier) return;
 1331|      0|
 1332|      0|  NSArray *oldBackgroundSessions = [[self class] activePersistedBackgroundSessions];
 1333|      0|  if (!oldBackgroundSessions) {
 1334|      0|    return;
 1335|      0|  }
 1336|      0|  NSMutableArray *newBackgroundSessions =
 1337|      0|      [NSMutableArray arrayWithArray:oldBackgroundSessions];
 1338|      0|  NSUInteger sessionIndex = [newBackgroundSessions indexOfObject:sessionIdentifier];
 1339|      0|  if (sessionIndex == NSNotFound) {
 1340|      0|    return;
 1341|      0|  }
 1342|      0|  [newBackgroundSessions removeObjectAtIndex:sessionIndex];
 1343|      0|  GTM_LOG_BACKGROUND_SESSION(@"Remove from background sessions: %@", newBackgroundSessions);
 1344|      0|
 1345|      0|  NSUserDefaults *userDefaults = [[self class] fetcherUserDefaults];
 1346|      0|  if (newBackgroundSessions.count == 0) {
 1347|      0|    [userDefaults removeObjectForKey:kGTMSessionFetcherPersistedDestinationKey];
 1348|      0|  } else {
 1349|      0|    [userDefaults setObject:newBackgroundSessions
 1350|      0|                     forKey:kGTMSessionFetcherPersistedDestinationKey];
 1351|      0|  }
 1352|      0|  [userDefaults synchronize];
 1353|      0|}
 1354|       |
 1355|      0|+ (GTM_NULLABLE NSArray *)activePersistedBackgroundSessions {
 1356|      0|  NSUserDefaults *userDefaults = [[self class] fetcherUserDefaults];
 1357|      0|  NSArray *oldBackgroundSessions =
 1358|      0|      [userDefaults arrayForKey:kGTMSessionFetcherPersistedDestinationKey];
 1359|      0|  if (oldBackgroundSessions.count == 0) {
 1360|      0|    return nil;
 1361|      0|  }
 1362|      0|  NSMutableArray *activeBackgroundSessions = nil;
 1363|      0|  NSMapTable *sessionIdentifierToFetcherMap = [self sessionIdentifierToFetcherMap];
 1364|      0|  for (NSString *sessionIdentifier in oldBackgroundSessions) {
 1365|      0|    GTMSessionFetcher *fetcher = [sessionIdentifierToFetcherMap objectForKey:sessionIdentifier];
 1366|      0|    if (fetcher) {
 1367|      0|      if (!activeBackgroundSessions) {
 1368|      0|        activeBackgroundSessions = [[NSMutableArray alloc] init];
 1369|      0|      }
 1370|      0|      [activeBackgroundSessions addObject:sessionIdentifier];
 1371|      0|    }
 1372|      0|  }
 1373|      0|  return activeBackgroundSessions;
 1374|      0|}
 1375|       |
 1376|      2|+ (NSArray *)fetchersForBackgroundSessions {
 1377|      2|  NSUserDefaults *userDefaults = [[self class] fetcherUserDefaults];
 1378|      2|  NSArray *backgroundSessions =
 1379|      2|      [userDefaults arrayForKey:kGTMSessionFetcherPersistedDestinationKey];
 1380|      2|  NSMapTable *sessionIdentifierToFetcherMap = [self sessionIdentifierToFetcherMap];
 1381|      2|  NSMutableArray *fetchers = [NSMutableArray array];
 1382|      2|  for (NSString *sessionIdentifier in backgroundSessions) {
 1383|      0|    GTMSessionFetcher *fetcher = [sessionIdentifierToFetcherMap objectForKey:sessionIdentifier];
 1384|      0|    if (!fetcher) {
 1385|      0|      fetcher = [self fetcherWithSessionIdentifier:sessionIdentifier];
 1386|      0|      GTMSESSION_ASSERT_DEBUG(fetcher != nil,
 1387|      0|                              @"Unexpected invalid session identifier: %@", sessionIdentifier);
 1388|      0|      [fetcher beginFetchWithCompletionHandler:nil];
 1389|      0|    }
 1390|      0|    GTM_LOG_BACKGROUND_SESSION(@"%@ restoring session %@ by creating fetcher %@ %p",
 1391|      0|                               [self class], sessionIdentifier, fetcher, fetcher);
 1392|      0|    if (fetcher != nil) {
 1393|      0|      [fetchers addObject:fetcher];
 1394|      0|    }
 1395|      0|  }
 1396|      2|  return fetchers;
 1397|      2|}
 1398|       |
 1399|       |#if TARGET_OS_IPHONE && !TARGET_OS_WATCH
 1400|       |+ (void)application:(UIApplication *)application
 1401|       |    handleEventsForBackgroundURLSession:(NSString *)identifier
 1402|      0|                      completionHandler:(GTMSessionFetcherSystemCompletionHandler)completionHandler {
 1403|      0|  GTMSessionFetcher *fetcher = [self fetcherWithSessionIdentifier:identifier];
 1404|      0|  if (fetcher != nil) {
 1405|      0|    fetcher.systemCompletionHandler = completionHandler;
 1406|      0|  } else {
 1407|      0|    GTM_LOG_BACKGROUND_SESSION(@"%@ did not create background session identifier: %@",
 1408|      0|                               [self class], identifier);
 1409|      0|  }
 1410|      0|}
 1411|       |#endif
 1412|       |
 1413|      3|- (NSString * GTM_NULLABLE_TYPE)sessionIdentifier {
 1414|      3|  @synchronized(self) {
 1415|      3|    GTMSessionMonitorSynchronized(self);
 1416|      3|
 1417|      3|    return _sessionIdentifier;
 1418|      3|  }  // @synchronized(self)
 1419|      3|}
 1420|       |
 1421|      0|- (void)setSessionIdentifier:(NSString *)sessionIdentifier {
 1422|      0|  GTMSESSION_ASSERT_DEBUG(sessionIdentifier != nil, @"Invalid session identifier");
 1423|      0|  @synchronized(self) {
 1424|      0|    GTMSessionMonitorSynchronized(self);
 1425|      0|
 1426|      0|    GTMSESSION_ASSERT_DEBUG(!_session, @"Unable to set session identifier after session created");
 1427|      0|    _sessionIdentifier = [sessionIdentifier copy];
 1428|      0|    _usingBackgroundSession = YES;
 1429|      0|    _canShareSession = NO;
 1430|      0|    [self restoreDefaultStateForSessionIdentifierMetadata];
 1431|      0|  }  // @synchronized(self)
 1432|      0|}
 1433|       |
 1434|      0|- (void)setSessionIdentifierInternal:(GTM_NULLABLE NSString *)sessionIdentifier {
 1435|      0|  // This internal method only does a synchronized set of the session identifier.
 1436|      0|  // It does not have side effects on the background session, shared session, or
 1437|      0|  // session identifier metadata.
 1438|      0|  @synchronized(self) {
 1439|      0|    GTMSessionMonitorSynchronized(self);
 1440|      0|
 1441|      0|    _sessionIdentifier = [sessionIdentifier copy];
 1442|      0|  }  // @synchronized(self)
 1443|      0|}
 1444|       |
 1445|      0|- (NSDictionary * GTM_NULLABLE_TYPE)sessionUserInfo {
 1446|      0|  @synchronized(self) {
 1447|      0|    GTMSessionMonitorSynchronized(self);
 1448|      0|
 1449|      0|    if (_sessionUserInfo == nil) {
 1450|      0|      // We'll return the metadata dictionary with internal keys removed. This avoids the user
 1451|      0|      // re-using the userInfo dictionary later and accidentally including the internal keys.
 1452|      0|      NSMutableDictionary *metadata = [[self sessionIdentifierMetadataUnsynchronized] mutableCopy];
 1453|      0|      NSSet *keysToRemove = [metadata keysOfEntriesPassingTest:^BOOL(id key, id obj, BOOL *stop) {
 1454|      0|          return [key hasPrefix:@"_"];
 1455|      0|      }];
 1456|      0|      [metadata removeObjectsForKeys:[keysToRemove allObjects]];
 1457|      0|      if (metadata.count > 0) {
 1458|      0|        _sessionUserInfo = metadata;
 1459|      0|      }
 1460|      0|    }
 1461|      0|    return _sessionUserInfo;
 1462|      0|  }  // @synchronized(self)
 1463|      0|}
 1464|       |
 1465|      0|- (void)setSessionUserInfo:(NSDictionary * GTM_NULLABLE_TYPE)dictionary {
 1466|      0|  @synchronized(self) {
 1467|      0|    GTMSessionMonitorSynchronized(self);
 1468|      0|
 1469|      0|    GTMSESSION_ASSERT_DEBUG(_sessionIdentifier == nil, @"Too late to assign userInfo");
 1470|      0|    _sessionUserInfo = dictionary;
 1471|      0|  }  // @synchronized(self)
 1472|      0|}
 1473|       |
 1474|      0|- (GTM_NULLABLE NSDictionary *)sessionIdentifierDefaultMetadata {
 1475|      0|  GTMSessionCheckSynchronized(self);
 1476|      0|
 1477|      0|  NSMutableDictionary *defaultUserInfo = [[NSMutableDictionary alloc] init];
 1478|      0|  if (_destinationFileURL) {
 1479|      0|    defaultUserInfo[kGTMSessionIdentifierDestinationFileURLMetadataKey] =
 1480|      0|        [_destinationFileURL absoluteString];
 1481|      0|  }
 1482|      0|  if (_bodyFileURL) {
 1483|      0|    defaultUserInfo[kGTMSessionIdentifierBodyFileURLMetadataKey] = [_bodyFileURL absoluteString];
 1484|      0|  }
 1485|      0|  return (defaultUserInfo.count > 0) ? defaultUserInfo : nil;
 1486|      0|}
 1487|       |
 1488|      0|- (void)restoreDefaultStateForSessionIdentifierMetadata {
 1489|      0|  GTMSessionCheckSynchronized(self);
 1490|      0|
 1491|      0|  NSDictionary *metadata = [self sessionIdentifierMetadataUnsynchronized];
 1492|      0|  NSString *destinationFileURLString = metadata[kGTMSessionIdentifierDestinationFileURLMetadataKey];
 1493|      0|  if (destinationFileURLString) {
 1494|      0|    _destinationFileURL = [NSURL URLWithString:destinationFileURLString];
 1495|      0|    GTM_LOG_BACKGROUND_SESSION(@"Restoring destination file URL: %@", _destinationFileURL);
 1496|      0|  }
 1497|      0|  NSString *bodyFileURLString = metadata[kGTMSessionIdentifierBodyFileURLMetadataKey];
 1498|      0|  if (bodyFileURLString) {
 1499|      0|    _bodyFileURL = [NSURL URLWithString:bodyFileURLString];
 1500|      0|    GTM_LOG_BACKGROUND_SESSION(@"Restoring body file URL: %@", _bodyFileURL);
 1501|      0|  }
 1502|      0|}
 1503|       |
 1504|      0|- (NSDictionary * GTM_NULLABLE_TYPE)sessionIdentifierMetadata {
 1505|      0|  @synchronized(self) {
 1506|      0|    GTMSessionMonitorSynchronized(self);
 1507|      0|
 1508|      0|    return [self sessionIdentifierMetadataUnsynchronized];
 1509|      0|  }
 1510|      0|}
 1511|       |
 1512|      0|- (NSDictionary * GTM_NULLABLE_TYPE)sessionIdentifierMetadataUnsynchronized {
 1513|      0|  GTMSessionCheckSynchronized(self);
 1514|      0|
 1515|      0|  // Session Identifier format: "com.google.<ClassName>_<UUID>_<Metadata in JSON format>
 1516|      0|  if (!_sessionIdentifier) {
 1517|      0|    return nil;
 1518|      0|  }
 1519|      0|  NSScanner *metadataScanner = [NSScanner scannerWithString:_sessionIdentifier];
 1520|      0|  [metadataScanner setCharactersToBeSkipped:nil];
 1521|      0|  NSString *metadataString;
 1522|      0|  NSString *uuid;
 1523|      0|  if ([metadataScanner scanUpToString:@"_" intoString:NULL] &&
 1524|      0|      [metadataScanner scanString:@"_" intoString:NULL] &&
 1525|      0|      [metadataScanner scanUpToString:@"_" intoString:&uuid] &&
 1526|      0|      [metadataScanner scanString:@"_" intoString:NULL] &&
 1527|      0|      [metadataScanner scanUpToString:@"\n" intoString:&metadataString]) {
 1528|      0|    _sessionIdentifierUUID = uuid;
 1529|      0|    NSData *metadataData = [metadataString dataUsingEncoding:NSUTF8StringEncoding];
 1530|      0|    NSError *error;
 1531|      0|    NSDictionary *metadataDict =
 1532|      0|      [NSJSONSerialization JSONObjectWithData:metadataData
 1533|      0|                                      options:0
 1534|      0|                                        error:&error];
 1535|      0|    GTM_LOG_BACKGROUND_SESSION(@"User Info from session identifier: %@ %@",
 1536|      0|                               metadataDict, error ? error : @"");
 1537|      0|    return metadataDict;
 1538|      0|  }
 1539|      0|  return nil;
 1540|      0|}
 1541|       |
 1542|      0|- (NSString *)createSessionIdentifierWithMetadata:(NSDictionary * GTM_NULLABLE_TYPE)metadataToInclude {
 1543|      0|  NSString *result;
 1544|      0|  @synchronized(self) {
 1545|      0|    GTMSessionMonitorSynchronized(self);
 1546|      0|
 1547|      0|    // Session Identifier format: "com.google.<ClassName>_<UUID>_<Metadata in JSON format>
 1548|      0|    GTMSESSION_ASSERT_DEBUG(!_sessionIdentifier, @"Session identifier already created");
 1549|      0|    _sessionIdentifierUUID = [[NSUUID UUID] UUIDString];
 1550|      0|    _sessionIdentifier =
 1551|      0|      [NSString stringWithFormat:@"%@_%@", kGTMSessionIdentifierPrefix, _sessionIdentifierUUID];
 1552|      0|    // Start with user-supplied keys so they cannot accidentally override the fetcher's keys.
 1553|      0|    NSMutableDictionary *metadataDict =
 1554|      0|        [NSMutableDictionary dictionaryWithDictionary:(NSDictionary * GTM_NONNULL_TYPE)_sessionUserInfo];
 1555|      0|
 1556|      0|    if (metadataToInclude) {
 1557|      0|      [metadataDict addEntriesFromDictionary:(NSDictionary *)metadataToInclude];
 1558|      0|    }
 1559|      0|    NSDictionary *defaultMetadataDict = [self sessionIdentifierDefaultMetadata];
 1560|      0|    if (defaultMetadataDict) {
 1561|      0|      [metadataDict addEntriesFromDictionary:defaultMetadataDict];
 1562|      0|    }
 1563|      0|    if (metadataDict.count > 0) {
 1564|      0|      NSData *metadataData = [NSJSONSerialization dataWithJSONObject:metadataDict
 1565|      0|                                                             options:0
 1566|      0|                                                               error:NULL];
 1567|      0|      GTMSESSION_ASSERT_DEBUG(metadataData != nil,
 1568|      0|                              @"Session identifier user info failed to convert to JSON");
 1569|      0|      if (metadataData.length > 0) {
 1570|      0|        NSString *metadataString = [[NSString alloc] initWithData:metadataData
 1571|      0|                                                         encoding:NSUTF8StringEncoding];
 1572|      0|        _sessionIdentifier =
 1573|      0|          [_sessionIdentifier stringByAppendingFormat:@"_%@", metadataString];
 1574|      0|      }
 1575|      0|    }
 1576|      0|    _didCreateSessionIdentifier = YES;
 1577|      0|    result = _sessionIdentifier;
 1578|      0|  }  // @synchronized(self)
 1579|      0|  return result;
 1580|      0|}
 1581|       |
 1582|      0|- (void)failToBeginFetchWithError:(NSError *)error {
 1583|      0|  @synchronized(self) {
 1584|      0|    GTMSessionMonitorSynchronized(self);
 1585|      0|
 1586|      0|    _hasStoppedFetching = YES;
 1587|      0|  }
 1588|      0|
 1589|      0|  if (error == nil) {
 1590|      0|    error = [NSError errorWithDomain:kGTMSessionFetcherErrorDomain
 1591|      0|                                code:GTMSessionFetcherErrorDownloadFailed
 1592|      0|                            userInfo:nil];
 1593|      0|  }
 1594|      0|
 1595|      0|  [self invokeFetchCallbacksOnCallbackQueueWithData:nil
 1596|      0|                                              error:error];
 1597|      0|  [self releaseCallbacks];
 1598|      0|
 1599|      0|  [_service fetcherDidStop:self];
 1600|      0|
 1601|      0|  self.authorizer = nil;
 1602|      0|}
 1603|       |
 1604|      1|+ (GTMSessionCookieStorage *)staticCookieStorage {
 1605|      1|  static GTMSessionCookieStorage *gCookieStorage = nil;
 1606|      1|
 1607|      1|  static dispatch_once_t onceToken;
 1608|      1|  dispatch_once(&onceToken, ^{
 1609|      1|    gCookieStorage = [[GTMSessionCookieStorage alloc] init];
 1610|      1|  });
 1611|      1|  return gCookieStorage;
 1612|      1|}
 1613|       |
 1614|       |#if GTM_BACKGROUND_TASK_FETCHING
 1615|       |
 1616|      0|- (void)endBackgroundTask {
 1617|      0|  // Whenever the connection stops or background execution expires,
 1618|      0|  // we need to tell UIApplication we're done.
 1619|      0|  UIBackgroundTaskIdentifier bgTaskID;
 1620|      0|  @synchronized(self) {
 1621|      0|    bgTaskID = self.backgroundTaskIdentifier;
 1622|      0|    if (bgTaskID != UIBackgroundTaskInvalid) {
 1623|      0|      self.backgroundTaskIdentifier = UIBackgroundTaskInvalid;
 1624|      0|    }
 1625|      0|  }
 1626|      0|
 1627|      0|  if (bgTaskID != UIBackgroundTaskInvalid) {
 1628|      0|    id<GTMUIApplicationProtocol> app = [[self class] fetcherUIApplication];
 1629|      0|    [app endBackgroundTask:bgTaskID];
 1630|      0|  }
 1631|      0|}
 1632|       |
 1633|       |#endif // GTM_BACKGROUND_TASK_FETCHING
 1634|       |
 1635|      0|- (void)authorizeRequest {
 1636|      0|  GTMSessionCheckNotSynchronized(self);
 1637|      0|
 1638|      0|  id authorizer = self.authorizer;
 1639|      0|  SEL asyncAuthSel = @selector(authorizeRequest:delegate:didFinishSelector:);
 1640|      0|  if ([authorizer respondsToSelector:asyncAuthSel]) {
 1641|      0|    SEL callbackSel = @selector(authorizer:request:finishedWithError:);
 1642|      0|    NSMutableURLRequest *mutableRequest = [self.request mutableCopy];
 1643|      0|    [authorizer authorizeRequest:mutableRequest
 1644|      0|                        delegate:self
 1645|      0|               didFinishSelector:callbackSel];
 1646|      0|  } else {
 1647|      0|    GTMSESSION_ASSERT_DEBUG(authorizer == nil, @"invalid authorizer for fetch");
 1648|      0|
 1649|      0|    // No authorizing possible, and authorizing happens only after any delay;
 1650|      0|    // just begin fetching
 1651|      0|    [self beginFetchMayDelay:NO
 1652|      0|                mayAuthorize:NO];
 1653|      0|  }
 1654|      0|}
 1655|       |
 1656|       |- (void)authorizer:(id<GTMFetcherAuthorizationProtocol>)auth
 1657|       |           request:(NSMutableURLRequest *)authorizedRequest
 1658|      0| finishedWithError:(NSError *)error {
 1659|      0|  GTMSessionCheckNotSynchronized(self);
 1660|      0|
 1661|      0|  if (error != nil) {
 1662|      0|    // We can't fetch without authorization
 1663|      0|    [self failToBeginFetchWithError:error];
 1664|      0|  } else {
 1665|      0|    @synchronized(self) {
 1666|      0|      _request = authorizedRequest;
 1667|      0|    }
 1668|      0|    [self beginFetchMayDelay:NO
 1669|      0|                mayAuthorize:NO];
 1670|      0|  }
 1671|      0|}
 1672|       |
 1673|       |
 1674|      0|- (BOOL)canFetchWithBackgroundSession {
 1675|      0|  // Subclasses may override.
 1676|      0|  return YES;
 1677|      0|}
 1678|       |
 1679|       |// Returns YES if the fetcher has been started and has not yet stopped.
 1680|       |//
 1681|       |// Fetching includes waiting for authorization or for retry, waiting to be allowed by the
 1682|       |// service object to start the request, and actually fetching the request.
 1683|      1|- (BOOL)isFetching {
 1684|      1|  @synchronized(self) {
 1685|      1|    GTMSessionMonitorSynchronized(self);
 1686|      1|
 1687|      1|    return [self isFetchingUnsynchronized];
 1688|      1|  }
 1689|      1|}
 1690|       |
 1691|      2|- (BOOL)isFetchingUnsynchronized {
 1692|      2|  GTMSessionCheckSynchronized(self);
 1693|      2|
 1694|      2|  BOOL hasBegun = (_initialBeginFetchDate != nil);
 1695|      2|  return hasBegun && !_hasStoppedFetching;
 1696|      2|}
 1697|       |
 1698|      0|- (NSURLResponse * GTM_NULLABLE_TYPE)response {
 1699|      0|  @synchronized(self) {
 1700|      0|    GTMSessionMonitorSynchronized(self);
 1701|      0|
 1702|      0|    NSURLResponse *response = [self responseUnsynchronized];
 1703|      0|    return response;
 1704|      0|  }  // @synchronized(self)
 1705|      0|}
 1706|       |
 1707|      0|- (NSURLResponse * GTM_NULLABLE_TYPE)responseUnsynchronized {
 1708|      0|  GTMSessionCheckSynchronized(self);
 1709|      0|
 1710|      0|  NSURLResponse *response = _sessionTask.response;
 1711|      0|  if (!response) response = _response;
 1712|      0|  return response;
 1713|      0|}
 1714|       |
 1715|      0|- (NSInteger)statusCode {
 1716|      0|  @synchronized(self) {
 1717|      0|    GTMSessionMonitorSynchronized(self);
 1718|      0|
 1719|      0|    NSInteger statusCode = [self statusCodeUnsynchronized];
 1720|      0|    return statusCode;
 1721|      0|  }  // @synchronized(self)
 1722|      0|}
 1723|       |
 1724|      0|- (NSInteger)statusCodeUnsynchronized {
 1725|      0|  GTMSessionCheckSynchronized(self);
 1726|      0|
 1727|      0|  NSURLResponse *response = [self responseUnsynchronized];
 1728|      0|  NSInteger statusCode;
 1729|      0|
 1730|      0|  if ([response respondsToSelector:@selector(statusCode)]) {
 1731|      0|    statusCode = [(NSHTTPURLResponse *)response statusCode];
 1732|      0|  } else {
 1733|      0|    //  Default to zero, in hopes of hinting "Unknown" (we can't be
 1734|      0|    //  sure that things are OK enough to use 200).
 1735|      0|    statusCode = 0;
 1736|      0|  }
 1737|      0|  return statusCode;
 1738|      0|}
 1739|       |
 1740|      0|- (NSDictionary * GTM_NULLABLE_TYPE)responseHeaders {
 1741|      0|  GTMSessionCheckNotSynchronized(self);
 1742|      0|
 1743|      0|  NSURLResponse *response = self.response;
 1744|      0|  if ([response respondsToSelector:@selector(allHeaderFields)]) {
 1745|      0|    NSDictionary *headers = [(NSHTTPURLResponse *)response allHeaderFields];
 1746|      0|    return headers;
 1747|      0|  }
 1748|      0|  return nil;
 1749|      0|}
 1750|       |
 1751|      0|- (NSDictionary * GTM_NULLABLE_TYPE)responseHeadersUnsynchronized {
 1752|      0|  GTMSessionCheckSynchronized(self);
 1753|      0|
 1754|      0|  NSURLResponse *response = [self responseUnsynchronized];
 1755|      0|  if ([response respondsToSelector:@selector(allHeaderFields)]) {
 1756|      0|    NSDictionary *headers = [(NSHTTPURLResponse *)response allHeaderFields];
 1757|      0|    return headers;
 1758|      0|  }
 1759|      0|  return nil;
 1760|      0|}
 1761|       |
 1762|      0|- (void)releaseCallbacks {
 1763|      0|  // Avoid releasing blocks in the sync section since objects dealloc'd by
 1764|      0|  // the blocks being released may call back into the fetcher or fetcher
 1765|      0|  // service.
 1766|      0|  dispatch_queue_t NS_VALID_UNTIL_END_OF_SCOPE holdCallbackQueue;
 1767|      0|  GTMSessionFetcherCompletionHandler NS_VALID_UNTIL_END_OF_SCOPE holdCompletionHandler;
 1768|      0|  @synchronized(self) {
 1769|      0|    GTMSessionMonitorSynchronized(self);
 1770|      0|
 1771|      0|    holdCallbackQueue = _callbackQueue;
 1772|      0|    holdCompletionHandler = _completionHandler;
 1773|      0|
 1774|      0|    _callbackQueue = nil;
 1775|      0|    _completionHandler = nil;  // Setter overridden in upload. Setter assumed to be used externally.
 1776|      0|  }
 1777|      0|
 1778|      0|  // Set local callback pointers to nil here rather than let them release at the end of the scope
 1779|      0|  // to make any problems due to the blocks being released be a bit more obvious in a stack trace.
 1780|      0|  holdCallbackQueue = nil;
 1781|      0|  holdCompletionHandler = nil;
 1782|      0|
 1783|      0|  self.configurationBlock = nil;
 1784|      0|  self.didReceiveResponseBlock = nil;
 1785|      0|  self.challengeBlock = nil;
 1786|      0|  self.willRedirectBlock = nil;
 1787|      0|  self.sendProgressBlock = nil;
 1788|      0|  self.receivedProgressBlock = nil;
 1789|      0|  self.downloadProgressBlock = nil;
 1790|      0|  self.accumulateDataBlock = nil;
 1791|      0|  self.willCacheURLResponseBlock = nil;
 1792|      0|  self.retryBlock = nil;
 1793|      0|  self.testBlock = nil;
 1794|      0|  self.resumeDataBlock = nil;
 1795|      0|}
 1796|       |
 1797|      0|- (void)forgetSessionIdentifierForFetcher {
 1798|      0|  GTMSessionCheckSynchronized(self);
 1799|      0|  [self forgetSessionIdentifierForFetcherWithoutSyncCheck];
 1800|      0|}
 1801|       |
 1802|      0|- (void)forgetSessionIdentifierForFetcherWithoutSyncCheck {
 1803|      0|  // This should be called inside a @synchronized block (except during dealloc.)
 1804|      0|  if (_sessionIdentifier) {
 1805|      0|    NSMapTable *sessionIdentifierToFetcherMap = [[self class] sessionIdentifierToFetcherMap];
 1806|      0|    [sessionIdentifierToFetcherMap removeObjectForKey:_sessionIdentifier];
 1807|      0|    _sessionIdentifier = nil;
 1808|      0|    _didCreateSessionIdentifier = NO;
 1809|      0|  }
 1810|      0|}
 1811|       |
 1812|       |// External stop method
 1813|      0|- (void)stopFetching {
 1814|      0|  @synchronized(self) {
 1815|      0|    GTMSessionMonitorSynchronized(self);
 1816|      0|
 1817|      0|    // Prevent enqueued callbacks from executing.
 1818|      0|    _userStoppedFetching = YES;
 1819|      0|  }  // @synchronized(self)
 1820|      0|  [self stopFetchReleasingCallbacks:YES];
 1821|      0|}
 1822|       |
 1823|       |// Cancel the fetch of the URL that's currently in progress.
 1824|       |//
 1825|       |// If shouldReleaseCallbacks is NO then the fetch will be retried so the callbacks
 1826|       |// need to still be retained.
 1827|      0|- (void)stopFetchReleasingCallbacks:(BOOL)shouldReleaseCallbacks {
 1828|      0|  [self removePersistedBackgroundSessionFromDefaults];
 1829|      0|
 1830|      0|  id<GTMSessionFetcherServiceProtocol> service;
 1831|      0|  NSMutableURLRequest *request;
 1832|      0|
 1833|      0|  // If the task or the retry timer is all that's retaining the fetcher,
 1834|      0|  // we want to be sure this instance survives stopping at least long enough for
 1835|      0|  // the stack to unwind.
 1836|      0|  __autoreleasing GTMSessionFetcher *holdSelf = self;
 1837|      0|
 1838|      0|  BOOL hasCanceledTask = NO;
 1839|      0|
 1840|      0|  [holdSelf destroyRetryTimer];
 1841|      0|
 1842|      0|  @synchronized(self) {
 1843|      0|    GTMSessionMonitorSynchronized(self);
 1844|      0|
 1845|      0|    _hasStoppedFetching = YES;
 1846|      0|
 1847|      0|    service = _service;
 1848|      0|    request = _request;
 1849|      0|
 1850|      0|    if (_sessionTask) {
 1851|      0|      // In case cancelling the task or session calls this recursively, we want
 1852|      0|      // to ensure that we'll only release the task and delegate once,
 1853|      0|      // so first set _sessionTask to nil
 1854|      0|      //
 1855|      0|      // This may be called in a callback from the task, so use autorelease to avoid
 1856|      0|      // releasing the task in its own callback.
 1857|      0|      __autoreleasing NSURLSessionTask *oldTask = _sessionTask;
 1858|      0|      if (!_isUsingTestBlock) {
 1859|      0|        _response = _sessionTask.response;
 1860|      0|      }
 1861|      0|      _sessionTask = nil;
 1862|      0|
 1863|      0|      if ([oldTask state] != NSURLSessionTaskStateCompleted) {
 1864|      0|        // For download tasks, when the fetch is stopped, we may provide resume data that can
 1865|      0|        // be used to create a new session.
 1866|      0|        BOOL mayResume = (_resumeDataBlock
 1867|      0|                          && [oldTask respondsToSelector:@selector(cancelByProducingResumeData:)]);
 1868|      0|        if (!mayResume) {
 1869|      0|          [oldTask cancel];
 1870|      0|          // A side effect of stopping the task is that URLSession:task:didCompleteWithError:
 1871|      0|          // will be invoked asynchronously on the delegate queue.
 1872|      0|        } else {
 1873|      0|          void (^resumeBlock)(NSData *) = _resumeDataBlock;
 1874|      0|          _resumeDataBlock = nil;
 1875|      0|
 1876|      0|          // Save callbackQueue since releaseCallbacks clears it.
 1877|      0|          dispatch_queue_t callbackQueue = _callbackQueue;
 1878|      0|          dispatch_group_enter(_callbackGroup);
 1879|      0|          [(NSURLSessionDownloadTask *)oldTask cancelByProducingResumeData:^(NSData *resumeData) {
 1880|      0|              [self invokeOnCallbackQueue:callbackQueue
 1881|      0|                         afterUserStopped:YES
 1882|      0|                                    block:^{
 1883|      0|                  resumeBlock(resumeData);
 1884|      0|                  dispatch_group_leave(self->_callbackGroup);
 1885|      0|              }];
 1886|      0|          }];
 1887|      0|        }
 1888|      0|        hasCanceledTask = YES;
 1889|      0|      }
 1890|      0|    }
 1891|      0|
 1892|      0|    // If the task was canceled, wait until the URLSession:task:didCompleteWithError: to call
 1893|      0|    // finishTasksAndInvalidate, since calling it immediately tends to crash, see radar 18471901.
 1894|      0|    if (_session) {
 1895|      0|      BOOL shouldInvalidate = _shouldInvalidateSession;
 1896|      0|#if TARGET_OS_IPHONE
 1897|      0|      // Don't invalidate if we've got a systemCompletionHandler, since
 1898|      0|      // URLSessionDidFinishEventsForBackgroundURLSession: won't be called if invalidated.
 1899|      0|      shouldInvalidate = shouldInvalidate && !self.systemCompletionHandler;
 1900|      0|#endif
 1901|      0|      if (shouldInvalidate) {
 1902|      0|        __autoreleasing NSURLSession *oldSession = _session;
 1903|      0|        _session = nil;
 1904|      0|
 1905|      0|        if (!hasCanceledTask) {
 1906|      0|          [oldSession finishTasksAndInvalidate];
 1907|      0|        } else {
 1908|      0|          _sessionNeedingInvalidation = oldSession;
 1909|      0|        }
 1910|      0|      }
 1911|      0|    }
 1912|      0|  }  // @synchronized(self)
 1913|      0|
 1914|      0|  // send the stopped notification
 1915|      0|  [self sendStopNotificationIfNeeded];
 1916|      0|
 1917|      0|  [_authorizer stopAuthorizationForRequest:request];
 1918|      0|
 1919|      0|  if (shouldReleaseCallbacks) {
 1920|      0|    [self releaseCallbacks];
 1921|      0|
 1922|      0|    self.authorizer = nil;
 1923|      0|  }
 1924|      0|
 1925|      0|  [service fetcherDidStop:self];
 1926|      0|
 1927|      0|#if GTM_BACKGROUND_TASK_FETCHING
 1928|      0|  [self endBackgroundTask];
 1929|      0|#endif
 1930|      0|}
 1931|       |
 1932|      1|- (void)setStopNotificationNeeded:(BOOL)flag {
 1933|      1|  @synchronized(self) {
 1934|      1|    GTMSessionMonitorSynchronized(self);
 1935|      1|
 1936|      1|    _isStopNotificationNeeded = flag;
 1937|      1|  }  // @synchronized(self)
 1938|      1|}
 1939|       |
 1940|      1|- (void)sendStopNotificationIfNeeded {
 1941|      1|  BOOL sendNow = NO;
 1942|      1|  @synchronized(self) {
 1943|      1|    GTMSessionMonitorSynchronized(self);
 1944|      1|
 1945|      1|    if (_isStopNotificationNeeded) {
 1946|      0|      _isStopNotificationNeeded = NO;
 1947|      0|      sendNow = YES;
 1948|      0|    }
 1949|      1|  }  // @synchronized(self)
 1950|      1|
 1951|      1|  if (sendNow) {
 1952|      0|    [self postNotificationOnMainThreadWithName:kGTMSessionFetcherStoppedNotification
 1953|      0|                                      userInfo:nil
 1954|      0|                                  requireAsync:NO];
 1955|      0|  }
 1956|      1|}
 1957|       |
 1958|      0|- (void)retryFetch {
 1959|      0|  [self stopFetchReleasingCallbacks:NO];
 1960|      0|
 1961|      0|  // A retry will need a configuration with a fresh session identifier.
 1962|      0|  @synchronized(self) {
 1963|      0|    GTMSessionMonitorSynchronized(self);
 1964|      0|
 1965|      0|    if (_sessionIdentifier && _didCreateSessionIdentifier) {
 1966|      0|      [self forgetSessionIdentifierForFetcher];
 1967|      0|      _configuration = nil;
 1968|      0|    }
 1969|      0|
 1970|      0|    if (_canShareSession) {
 1971|      0|      // Force a grab of the current session from the fetcher service in case
 1972|      0|      // the service's old one has become invalid.
 1973|      0|      _session = nil;
 1974|      0|    }
 1975|      0|  }  // @synchronized(self)
 1976|      0|
 1977|      0|  [self beginFetchForRetry];
 1978|      0|}
 1979|       |
 1980|      0|- (BOOL)waitForCompletionWithTimeout:(NSTimeInterval)timeoutInSeconds {
 1981|      0|  // Uncovered in upload fetcher testing, because the chunk fetcher is being waited on, and gets
 1982|      0|  // released by the upload code. The uploader just holds onto it with an ivar, and that gets
 1983|      0|  // nilled in the chunk fetcher callback.
 1984|      0|  // Used once in while loop just to avoid unused variable compiler warning.
 1985|      0|  __autoreleasing GTMSessionFetcher *holdSelf = self;
 1986|      0|
 1987|      0|  NSDate *giveUpDate = [NSDate dateWithTimeIntervalSinceNow:timeoutInSeconds];
 1988|      0|
 1989|      0|  BOOL shouldSpinRunLoop = ([NSThread isMainThread] &&
 1990|      0|                            (!self.callbackQueue
 1991|      0|                             || self.callbackQueue == dispatch_get_main_queue()));
 1992|      0|  BOOL expired = NO;
 1993|      0|
 1994|      0|  // Loop until the callbacks have been called and released, and until
 1995|      0|  // the connection is no longer pending, until there are no callback dispatches
 1996|      0|  // in flight, or until the timeout has expired.
 1997|      0|  int64_t delta = (int64_t)(100 * NSEC_PER_MSEC);  // 100 ms
 1998|      0|  while (1) {
 1999|      0|    BOOL isTaskInProgress = (holdSelf->_sessionTask
 2000|      0|                             && [_sessionTask state] != NSURLSessionTaskStateCompleted);
 2001|      0|    BOOL needsToCallCompletion = (_completionHandler != nil);
 2002|      0|    BOOL isCallbackInProgress = (_callbackGroup
 2003|      0|        && dispatch_group_wait(_callbackGroup, dispatch_time(DISPATCH_TIME_NOW, delta)));
 2004|      0|
 2005|      0|    if (!isTaskInProgress && !needsToCallCompletion && !isCallbackInProgress) break;
 2006|      0|
 2007|      0|    expired = ([giveUpDate timeIntervalSinceNow] < 0);
 2008|      0|    if (expired) {
 2009|      0|      GTMSESSION_LOG_DEBUG(@"GTMSessionFetcher waitForCompletionWithTimeout:%0.1f expired -- "
 2010|      0|                           @"%@%@%@", timeoutInSeconds,
 2011|      0|                           isTaskInProgress ? @"taskInProgress " : @"",
 2012|      0|                           needsToCallCompletion ? @"needsToCallCompletion " : @"",
 2013|      0|                           isCallbackInProgress ? @"isCallbackInProgress" : @"");
 2014|      0|      break;
 2015|      0|    }
 2016|      0|
 2017|      0|    // Run the current run loop 1/1000 of a second to give the networking
 2018|      0|    // code a chance to work
 2019|      0|    const NSTimeInterval kSpinInterval = 0.001;
 2020|      0|    if (shouldSpinRunLoop) {
 2021|      0|      NSDate *stopDate = [NSDate dateWithTimeIntervalSinceNow:kSpinInterval];
 2022|      0|      [[NSRunLoop currentRunLoop] runUntilDate:stopDate];
 2023|      0|    } else {
 2024|      0|      [NSThread sleepForTimeInterval:kSpinInterval];
 2025|      0|    }
 2026|      0|  }
 2027|      0|  return !expired;
 2028|      0|}
 2029|       |
 2030|      0|+ (void)setGlobalTestBlock:(GTMSessionFetcherTestBlock GTM_NULLABLE_TYPE)block {
 2031|       |#if GTM_DISABLE_FETCHER_TEST_BLOCK
 2032|       |  GTMSESSION_ASSERT_DEBUG(block == nil, @"test blocks disabled");
 2033|       |#endif
 2034|       |  gGlobalTestBlock = [block copy];
 2035|      0|}
 2036|       |
 2037|       |#if GTM_BACKGROUND_TASK_FETCHING
 2038|       |
 2039|       |static GTM_NULLABLE_TYPE id<GTMUIApplicationProtocol> gSubstituteUIApp;
 2040|       |
 2041|      0|+ (void)setSubstituteUIApplication:(nullable id<GTMUIApplicationProtocol>)app {
 2042|      0|  gSubstituteUIApp = app;
 2043|      0|}
 2044|       |
 2045|      0|+ (nullable id<GTMUIApplicationProtocol>)substituteUIApplication {
 2046|      0|  return gSubstituteUIApp;
 2047|      0|}
 2048|       |
 2049|      1|+ (nullable id<GTMUIApplicationProtocol>)fetcherUIApplication {
 2050|      1|  id<GTMUIApplicationProtocol> app = gSubstituteUIApp;
 2051|      1|  if (app) return app;
 2052|      1|
 2053|      1|  // iOS App extensions should not call [UIApplication sharedApplication], even
 2054|      1|  // if UIApplication responds to it.
 2055|      1|
 2056|      1|  static Class applicationClass = nil;
 2057|      1|  static dispatch_once_t onceToken;
 2058|      1|  dispatch_once(&onceToken, ^{
 2059|      1|    BOOL isAppExtension = [[[NSBundle mainBundle] bundlePath] hasSuffix:@".appex"];
 2060|      1|    if (!isAppExtension) {
 2061|      1|      Class cls = NSClassFromString(@"UIApplication");
 2062|      1|      if (cls && [cls respondsToSelector:NSSelectorFromString(@"sharedApplication")]) {
 2063|      1|        applicationClass = cls;
 2064|      1|      }
 2065|      1|    }
 2066|      1|  });
 2067|      1|
 2068|      1|  if (applicationClass) {
 2069|      1|    app = (id<GTMUIApplicationProtocol>)[applicationClass sharedApplication];
 2070|      1|  }
 2071|      1|  return app;
 2072|      1|}
 2073|       |#endif //  GTM_BACKGROUND_TASK_FETCHING
 2074|       |
 2075|       |#pragma mark NSURLSession Delegate Methods
 2076|       |
 2077|       |// NSURLSession documentation indicates that redirectRequest can be passed to the handler
 2078|       |// but empirically redirectRequest lacks the HTTP body, so passing it will break POSTs.
 2079|       |// Instead, we construct a new request, a copy of the original, with overrides from the
 2080|       |// redirect.
 2081|       |
 2082|       |- (void)URLSession:(NSURLSession *)session
 2083|       |              task:(NSURLSessionTask *)task
 2084|       |willPerformHTTPRedirection:(NSHTTPURLResponse *)redirectResponse
 2085|       |        newRequest:(NSURLRequest *)redirectRequest
 2086|      0| completionHandler:(void (^)(NSURLRequest * GTM_NULLABLE_TYPE))handler {
 2087|      0|  [self setSessionTask:task];
 2088|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ willPerformHTTPRedirection:%@ newRequest:%@",
 2089|      0|                           [self class], self, session, task, redirectResponse, redirectRequest);
 2090|      0|
 2091|      0|  if ([self userStoppedFetching]) {
 2092|      0|    handler(nil);
 2093|      0|    return;
 2094|      0|  }
 2095|      0|  if (redirectRequest && redirectResponse) {
 2096|      0|    // Copy the original request, including the body.
 2097|      0|    NSURLRequest *originalRequest = self.request;
 2098|      0|    NSMutableURLRequest *newRequest = [originalRequest mutableCopy];
 2099|      0|
 2100|      0|    // The new requests's URL overrides the original's URL.
 2101|      0|    [newRequest setURL:[GTMSessionFetcher redirectURLWithOriginalRequestURL:originalRequest.URL
 2102|      0|                                                         redirectRequestURL:redirectRequest.URL]];
 2103|      0|
 2104|      0|    // Any headers in the redirect override headers in the original.
 2105|      0|    NSDictionary *redirectHeaders = redirectRequest.allHTTPHeaderFields;
 2106|      0|    for (NSString *key in redirectHeaders) {
 2107|      0|      NSString *value = [redirectHeaders objectForKey:key];
 2108|      0|      [newRequest setValue:value forHTTPHeaderField:key];
 2109|      0|    }
 2110|      0|
 2111|      0|    redirectRequest = newRequest;
 2112|      0|
 2113|      0|      // Log the response we just received
 2114|      0|    [self setResponse:redirectResponse];
 2115|      0|    [self logNowWithError:nil];
 2116|      0|
 2117|      0|    GTMSessionFetcherWillRedirectBlock willRedirectBlock = self.willRedirectBlock;
 2118|      0|    if (willRedirectBlock) {
 2119|      0|      @synchronized(self) {
 2120|      0|        GTMSessionMonitorSynchronized(self);
 2121|      0|        [self invokeOnCallbackQueueAfterUserStopped:YES
 2122|      0|                                              block:^{
 2123|      0|            willRedirectBlock(redirectResponse, redirectRequest, ^(NSURLRequest *clientRequest) {
 2124|      0|
 2125|      0|                // Update the request for future logging.
 2126|      0|                [self updateMutableRequest:[clientRequest mutableCopy]];
 2127|      0|
 2128|      0|                handler(clientRequest);
 2129|      0|            });
 2130|      0|        }];
 2131|      0|      }  // @synchronized(self)
 2132|      0|      return;
 2133|      0|    }
 2134|      0|    // Continues here if the client did not provide a redirect block.
 2135|      0|
 2136|      0|    // Update the request for future logging.
 2137|      0|    [self updateMutableRequest:[redirectRequest mutableCopy]];
 2138|      0|  }
 2139|      0|  handler(redirectRequest);
 2140|      0|}
 2141|       |
 2142|       |- (void)URLSession:(NSURLSession *)session
 2143|       |          dataTask:(NSURLSessionDataTask *)dataTask
 2144|       |didReceiveResponse:(NSURLResponse *)response
 2145|      0| completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))handler {
 2146|      0|  [self setSessionTask:dataTask];
 2147|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ dataTask:%@ didReceiveResponse:%@",
 2148|      0|                           [self class], self, session, dataTask, response);
 2149|      0|  void (^accumulateAndFinish)(NSURLSessionResponseDisposition) =
 2150|      0|      ^(NSURLSessionResponseDisposition dispositionValue) {
 2151|      0|      // This method is called when the server has determined that it
 2152|      0|      // has enough information to create the NSURLResponse
 2153|      0|      // it can be called multiple times, for example in the case of a
 2154|      0|      // redirect, so each time we reset the data.
 2155|      0|      @synchronized(self) {
 2156|      0|        GTMSessionMonitorSynchronized(self);
 2157|      0|
 2158|      0|        BOOL hadPreviousData = self->_downloadedLength > 0;
 2159|      0|
 2160|      0|        [self->_downloadedData setLength:0];
 2161|      0|        self->_downloadedLength = 0;
 2162|      0|
 2163|      0|        if (hadPreviousData && (dispositionValue != NSURLSessionResponseCancel)) {
 2164|      0|          // Tell the accumulate block to discard prior data.
 2165|      0|          GTMSessionFetcherAccumulateDataBlock accumulateBlock = self->_accumulateDataBlock;
 2166|      0|          if (accumulateBlock) {
 2167|      0|            [self invokeOnCallbackQueueUnlessStopped:^{
 2168|      0|                accumulateBlock(nil);
 2169|      0|            }];
 2170|      0|          }
 2171|      0|        }
 2172|      0|      }  // @synchronized(self)
 2173|      0|      handler(dispositionValue);
 2174|      0|  };
 2175|      0|
 2176|      0|  GTMSessionFetcherDidReceiveResponseBlock receivedResponseBlock;
 2177|      0|  @synchronized(self) {
 2178|      0|    GTMSessionMonitorSynchronized(self);
 2179|      0|
 2180|      0|    receivedResponseBlock = _didReceiveResponseBlock;
 2181|      0|    if (receivedResponseBlock) {
 2182|      0|      // We will ultimately need to call back to NSURLSession's handler with the disposition value
 2183|      0|      // for this delegate method even if the user has stopped the fetcher.
 2184|      0|      [self invokeOnCallbackQueueAfterUserStopped:YES
 2185|      0|                                            block:^{
 2186|      0|        receivedResponseBlock(response, ^(NSURLSessionResponseDisposition desiredDisposition) {
 2187|      0|          accumulateAndFinish(desiredDisposition);
 2188|      0|        });
 2189|      0|      }];
 2190|      0|    }
 2191|      0|  }  // @synchronized(self)
 2192|      0|
 2193|      0|  if (receivedResponseBlock == nil) {
 2194|      0|    accumulateAndFinish(NSURLSessionResponseAllow);
 2195|      0|  }
 2196|      0|}
 2197|       |
 2198|       |- (void)URLSession:(NSURLSession *)session
 2199|       |          dataTask:(NSURLSessionDataTask *)dataTask
 2200|      0|didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask {
 2201|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ dataTask:%@ didBecomeDownloadTask:%@",
 2202|      0|                           [self class], self, session, dataTask, downloadTask);
 2203|      0|  [self setSessionTask:downloadTask];
 2204|      0|}
 2205|       |
 2206|       |
 2207|       |- (void)URLSession:(NSURLSession *)session
 2208|       |              task:(NSURLSessionTask *)task
 2209|       |didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 2210|       | completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition,
 2211|      0|                             NSURLCredential * GTM_NULLABLE_TYPE credential))handler {
 2212|      0|  [self setSessionTask:task];
 2213|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ didReceiveChallenge:%@",
 2214|      0|                           [self class], self, session, task, challenge);
 2215|      0|
 2216|      0|  GTMSessionFetcherChallengeBlock challengeBlock = self.challengeBlock;
 2217|      0|  if (challengeBlock) {
 2218|      0|    // The fetcher user has provided custom challenge handling.
 2219|      0|    //
 2220|      0|    // We will ultimately need to call back to NSURLSession's handler with the disposition value
 2221|      0|    // for this delegate method even if the user has stopped the fetcher.
 2222|      0|    @synchronized(self) {
 2223|      0|      GTMSessionMonitorSynchronized(self);
 2224|      0|
 2225|      0|      [self invokeOnCallbackQueueAfterUserStopped:YES
 2226|      0|                                            block:^{
 2227|      0|        challengeBlock(self, challenge, handler);
 2228|      0|      }];
 2229|      0|    }
 2230|      0|  } else {
 2231|      0|    // No challenge block was provided by the client.
 2232|      0|    [self respondToChallenge:challenge
 2233|      0|           completionHandler:handler];
 2234|      0|  }
 2235|      0|}
 2236|       |
 2237|       |- (void)respondToChallenge:(NSURLAuthenticationChallenge *)challenge
 2238|       |         completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition,
 2239|      0|                                     NSURLCredential * GTM_NULLABLE_TYPE credential))handler {
 2240|      0|  @synchronized(self) {
 2241|      0|    GTMSessionMonitorSynchronized(self);
 2242|      0|
 2243|      0|    NSInteger previousFailureCount = [challenge previousFailureCount];
 2244|      0|    if (previousFailureCount <= 2) {
 2245|      0|      NSURLProtectionSpace *protectionSpace = [challenge protectionSpace];
 2246|      0|      NSString *authenticationMethod = [protectionSpace authenticationMethod];
 2247|      0|      if ([authenticationMethod isEqual:NSURLAuthenticationMethodServerTrust]) {
 2248|      0|        // SSL.
 2249|      0|        //
 2250|      0|        // Background sessions seem to require an explicit check of the server trust object
 2251|      0|        // rather than default handling.
 2252|      0|        SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;
 2253|      0|        if (serverTrust == NULL) {
 2254|      0|          // No server trust information is available.
 2255|      0|          handler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
 2256|      0|        } else {
 2257|      0|          // Server trust information is available.
 2258|      0|          void (^callback)(SecTrustRef, BOOL) = ^(SecTrustRef trustRef, BOOL allow){
 2259|      0|            if (allow) {
 2260|      0|              NSURLCredential *trustCredential = [NSURLCredential credentialForTrust:trustRef];
 2261|      0|              handler(NSURLSessionAuthChallengeUseCredential, trustCredential);
 2262|      0|            } else {
 2263|      0|              GTMSESSION_LOG_DEBUG(@"Cancelling authentication challenge for %@", self->_request.URL);
 2264|      0|              handler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
 2265|      0|            }
 2266|      0|          };
 2267|      0|          if (_allowInvalidServerCertificates) {
 2268|      0|            callback(serverTrust, YES);
 2269|      0|          } else {
 2270|      0|            [[self class] evaluateServerTrust:serverTrust
 2271|      0|                                   forRequest:_request
 2272|      0|                            completionHandler:callback];
 2273|      0|          }
 2274|      0|        }
 2275|      0|        return;
 2276|      0|      }
 2277|      0|
 2278|      0|      NSURLCredential *credential = _credential;
 2279|      0|
 2280|      0|      if ([[challenge protectionSpace] isProxy] && _proxyCredential != nil) {
 2281|      0|        credential = _proxyCredential;
 2282|      0|      }
 2283|      0|
 2284|      0|      if (credential) {
 2285|      0|        handler(NSURLSessionAuthChallengeUseCredential, credential);
 2286|      0|      } else {
 2287|      0|        // The credential is still nil; tell the OS to use the default handling. This is needed
 2288|      0|        // for things that can come out of the keychain (proxies, client certificates, etc.).
 2289|      0|        //
 2290|      0|        // Note: Looking up a credential with NSURLCredentialStorage's
 2291|      0|        // defaultCredentialForProtectionSpace: is *not* the same invoking the handler with
 2292|      0|        // NSURLSessionAuthChallengePerformDefaultHandling. In the case of
 2293|      0|        // NSURLAuthenticationMethodClientCertificate, you can get nil back from
 2294|      0|        // NSURLCredentialStorage, while using this code path instead works.
 2295|      0|        handler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
 2296|      0|      }
 2297|      0|
 2298|      0|    } else {
 2299|      0|      // We've failed auth 3 times.  The completion handler will be called with code
 2300|      0|      // NSURLErrorCancelled.
 2301|      0|      handler(NSURLSessionAuthChallengeCancelAuthenticationChallenge, nil);
 2302|      0|    }
 2303|      0|  }  // @synchronized(self)
 2304|      0|}
 2305|       |
 2306|       |// Return redirect URL based on the original request URL and redirect request URL.
 2307|       |//
 2308|       |// Method disallows any scheme changes between the original request URL and redirect request URL
 2309|       |// aside from "http" to "https". If a change in scheme is detected the redirect URL inherits the
 2310|       |// scheme from the original request URL.
 2311|       |+ (GTM_NULLABLE NSURL *)redirectURLWithOriginalRequestURL:(GTM_NULLABLE NSURL *)originalRequestURL
 2312|      0|                                       redirectRequestURL:(GTM_NULLABLE NSURL *)redirectRequestURL {
 2313|      0|  // In the case of an NSURLSession redirect, neither URL should ever be nil; as a sanity check
 2314|      0|  // if either is nil return the other URL.
 2315|      0|  if (!redirectRequestURL) return originalRequestURL;
 2316|      0|  if (!originalRequestURL) return redirectRequestURL;
 2317|      0|
 2318|      0|  NSString *originalScheme = originalRequestURL.scheme;
 2319|      0|  NSString *redirectScheme = redirectRequestURL.scheme;
 2320|      0|  BOOL insecureToSecureRedirect =
 2321|      0|      (originalScheme != nil && [originalScheme caseInsensitiveCompare:@"http"] == NSOrderedSame &&
 2322|      0|       redirectScheme != nil && [redirectScheme caseInsensitiveCompare:@"https"] == NSOrderedSame);
 2323|      0|
 2324|      0|  // This can't really be nil for the inputs, but to keep the analyzer happy
 2325|      0|  // for the -caseInsensitiveCompare: call below, give it a value if it were.
 2326|      0|  if (!originalScheme) originalScheme = @"https";
 2327|      0|
 2328|      0|  // Check for changes to the scheme and disallow any changes except for http to https.
 2329|      0|  if (!insecureToSecureRedirect &&
 2330|      0|      (redirectScheme.length != originalScheme.length ||
 2331|      0|       [redirectScheme caseInsensitiveCompare:originalScheme] != NSOrderedSame)) {
 2332|      0|    NSURLComponents *components =
 2333|      0|        [NSURLComponents componentsWithURL:(NSURL * _Nonnull)redirectRequestURL
 2334|      0|                   resolvingAgainstBaseURL:NO];
 2335|      0|    components.scheme = originalScheme;
 2336|      0|    return components.URL;
 2337|      0|  }
 2338|      0|
 2339|      0|  return redirectRequestURL;
 2340|      0|}
 2341|       |
 2342|       |// Validate the certificate chain.
 2343|       |//
 2344|       |// This may become a public method if it appears to be useful to users.
 2345|       |+ (void)evaluateServerTrust:(SecTrustRef)serverTrust
 2346|       |                 forRequest:(NSURLRequest *)request
 2347|      0|          completionHandler:(void (^)(SecTrustRef trustRef, BOOL allow))handler {
 2348|      0|  // Retain the trust object to avoid a SecTrustEvaluate() crash on iOS 7.
 2349|      0|  CFRetain(serverTrust);
 2350|      0|
 2351|      0|  // Evaluate the certificate chain.
 2352|      0|  //
 2353|      0|  // The delegate queue may be the main thread. Trust evaluation could cause some
 2354|      0|  // blocking network activity, so we must evaluate async, as documented at
 2355|      0|  // https://developer.apple.com/library/ios/technotes/tn2232/
 2356|      0|  //
 2357|      0|  // We must also avoid multiple uses of the trust object, per docs:
 2358|      0|  // "It is not safe to call this function concurrently with any other function that uses
 2359|      0|  // the same trust management object, or to re-enter this function for the same trust
 2360|      0|  // management object."
 2361|      0|  //
 2362|      0|  // SecTrustEvaluateAsync both does sync execution of Evaluate and calls back on the
 2363|      0|  // queue passed to it, according to at sources in
 2364|      0|  // http://www.opensource.apple.com/source/libsecurity_keychain/libsecurity_keychain-55050.9/lib/SecTrust.cpp
 2365|      0|  // It would require a global serial queue to ensure the evaluate happens only on a
 2366|      0|  // single thread at a time, so we'll stick with using SecTrustEvaluate on a background
 2367|      0|  // thread.
 2368|      0|  dispatch_queue_t evaluateBackgroundQueue =
 2369|      0|    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
 2370|      0|  dispatch_async(evaluateBackgroundQueue, ^{
 2371|      0|    // It looks like the implementation of SecTrustEvaluate() on Mac grabs a global lock,
 2372|      0|    // so it may be redundant for us to also lock, but it's easy to synchronize here
 2373|      0|    // anyway.
 2374|      0|    BOOL shouldAllow;
 2375|       |#if GTM_SDK_REQUIRES_SECTRUSTEVALUATEWITHERROR
 2376|       |    CFErrorRef errorRef = NULL;
 2377|       |    @synchronized ([GTMSessionFetcher class]) {
 2378|       |      GTMSessionMonitorSynchronized([GTMSessionFetcher class]);
 2379|       |
 2380|       |      // SecTrustEvaluateWithError handles both the "proceed" and "unspecified" cases,
 2381|       |      // so it is not necessary to check the trust result the evaluation returns true.
 2382|       |      shouldAllow = SecTrustEvaluateWithError(serverTrust, &errorRef);
 2383|       |    }
 2384|       |
 2385|       |    if (errorRef) {
 2386|       |      GTMSESSION_LOG_DEBUG(@"Error %d evaluating trust for %@",
 2387|       |                           (int)CFErrorGetCode(errorRef), request);
 2388|       |      CFRelease(errorRef);
 2389|       |    }
 2390|       |#else
 2391|       |    SecTrustResultType trustEval = kSecTrustResultInvalid;
 2392|      0|    OSStatus trustError;
 2393|      0|    @synchronized([GTMSessionFetcher class]) {
 2394|      0|      GTMSessionMonitorSynchronized([GTMSessionFetcher class]);
 2395|      0|
 2396|      0|      trustError = SecTrustEvaluate(serverTrust, &trustEval);
 2397|      0|    }
 2398|      0|    if (trustError != errSecSuccess) {
 2399|      0|      GTMSESSION_LOG_DEBUG(@"Error %d evaluating trust for %@",
 2400|      0|                           (int)trustError, request);
 2401|      0|      shouldAllow = NO;
 2402|      0|    } else {
 2403|      0|      // Having a trust level "unspecified" by the user is the usual result, described at
 2404|      0|      //   https://developer.apple.com/library/mac/qa/qa1360
 2405|      0|      if (trustEval == kSecTrustResultUnspecified
 2406|      0|          || trustEval == kSecTrustResultProceed) {
 2407|      0|        shouldAllow = YES;
 2408|      0|      } else {
 2409|      0|        shouldAllow = NO;
 2410|      0|        GTMSESSION_LOG_DEBUG(@"Challenge SecTrustResultType %u for %@, properties: %@",
 2411|      0|                             trustEval, request.URL.host,
 2412|      0|                             CFBridgingRelease(SecTrustCopyProperties(serverTrust)));
 2413|      0|      }
 2414|      0|    }
 2415|      0|#endif  // GTM_SDK_REQUIRES_SECTRUSTEVALUATEWITHERROR
 2416|      0|    handler(serverTrust, shouldAllow);
 2417|      0|
 2418|      0|    CFRelease(serverTrust);
 2419|      0|  });
 2420|      0|}
 2421|       |
 2422|      0|- (void)invokeOnCallbackQueueUnlessStopped:(void (^)(void))block {
 2423|      0|  [self invokeOnCallbackQueueAfterUserStopped:NO
 2424|      0|                                        block:block];
 2425|      0|}
 2426|       |
 2427|       |- (void)invokeOnCallbackQueueAfterUserStopped:(BOOL)afterStopped
 2428|      0|                                        block:(void (^)(void))block {
 2429|      0|  GTMSessionCheckSynchronized(self);
 2430|      0|
 2431|      0|  [self invokeOnCallbackUnsynchronizedQueueAfterUserStopped:afterStopped
 2432|      0|                                                      block:block];
 2433|      0|}
 2434|       |
 2435|       |- (void)invokeOnCallbackUnsynchronizedQueueAfterUserStopped:(BOOL)afterStopped
 2436|      0|                                                      block:(void (^)(void))block {
 2437|      0|  // testBlock simulation code may not be synchronizing when this is invoked.
 2438|      0|  [self invokeOnCallbackQueue:_callbackQueue
 2439|      0|             afterUserStopped:afterStopped
 2440|      0|                        block:block];
 2441|      0|}
 2442|       |
 2443|       |- (void)invokeOnCallbackQueue:(dispatch_queue_t)callbackQueue
 2444|       |             afterUserStopped:(BOOL)afterStopped
 2445|      0|                        block:(void (^)(void))block {
 2446|      0|  if (callbackQueue) {
 2447|      0|    dispatch_group_async(_callbackGroup, callbackQueue, ^{
 2448|      0|        if (!afterStopped) {
 2449|      0|          NSDate *serviceStoppedAllDate = [self->_service stoppedAllFetchersDate];
 2450|      0|
 2451|      0|          @synchronized(self) {
 2452|      0|            GTMSessionMonitorSynchronized(self);
 2453|      0|
 2454|      0|            // Avoid a race between stopFetching and the callback.
 2455|      0|            if (self->_userStoppedFetching) {
 2456|      0|              return;
 2457|      0|            }
 2458|      0|
 2459|      0|            // Also avoid calling back if the service has stopped all fetchers
 2460|      0|            // since this one was created. The fetcher may have stopped before
 2461|      0|            // stopAllFetchers was invoked, so _userStoppedFetching wasn't set,
 2462|      0|            // but the app still won't expect the callback to fire after
 2463|      0|            // the service's stopAllFetchers was invoked.
 2464|      0|            if (serviceStoppedAllDate
 2465|      0|                && [self->_initialBeginFetchDate compare:serviceStoppedAllDate] != NSOrderedDescending) {
 2466|      0|              // stopAllFetchers was called after this fetcher began.
 2467|      0|              return;
 2468|      0|            }
 2469|      0|          }  // @synchronized(self)
 2470|      0|        }
 2471|      0|        block();
 2472|      0|    });
 2473|      0|  }
 2474|      0|}
 2475|       |
 2476|       |- (void)invokeFetchCallbacksOnCallbackQueueWithData:(GTM_NULLABLE NSData *)data
 2477|      0|                                              error:(GTM_NULLABLE NSError *)error {
 2478|      0|  // Callbacks will be released in the method stopFetchReleasingCallbacks:
 2479|      0|  GTMSessionFetcherCompletionHandler handler;
 2480|      0|  @synchronized(self) {
 2481|      0|    GTMSessionMonitorSynchronized(self);
 2482|      0|
 2483|      0|    handler = _completionHandler;
 2484|      0|
 2485|      0|    if (handler) {
 2486|      0|      [self invokeOnCallbackQueueUnlessStopped:^{
 2487|      0|        handler(data, error);
 2488|      0|
 2489|      0|        // Post a notification, primarily to allow code to collect responses for
 2490|      0|        // testing.
 2491|      0|        //
 2492|      0|        // The observing code is not likely on the fetcher's callback
 2493|      0|        // queue, so this posts explicitly to the main queue.
 2494|      0|        NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
 2495|      0|        if (data) {
 2496|      0|          userInfo[kGTMSessionFetcherCompletionDataKey] = data;
 2497|      0|        }
 2498|      0|        if (error) {
 2499|      0|          userInfo[kGTMSessionFetcherCompletionErrorKey] = error;
 2500|      0|        }
 2501|      0|        [self postNotificationOnMainThreadWithName:kGTMSessionFetcherCompletionInvokedNotification
 2502|      0|                                          userInfo:userInfo
 2503|      0|                                      requireAsync:NO];
 2504|      0|      }];
 2505|      0|    }
 2506|      0|  }  // @synchronized(self)
 2507|      0|}
 2508|       |
 2509|       |- (void)postNotificationOnMainThreadWithName:(NSString *)noteName
 2510|       |                                    userInfo:(GTM_NULLABLE NSDictionary *)userInfo
 2511|      1|                                requireAsync:(BOOL)requireAsync {
 2512|      1|  dispatch_block_t postBlock = ^{
 2513|      1|    [[NSNotificationCenter defaultCenter] postNotificationName:noteName
 2514|      1|                                                        object:self
 2515|      1|                                                      userInfo:userInfo];
 2516|      1|  };
 2517|      1|
 2518|      1|  if ([NSThread isMainThread] && !requireAsync) {
 2519|      0|    // Post synchronously for compatibility with older code using the fetcher.
 2520|      0|
 2521|      0|    // Avoid calling out to other code from inside a sync block to avoid risk
 2522|      0|    // of a deadlock or of recursive sync.
 2523|      0|    GTMSessionCheckNotSynchronized(self);
 2524|      0|
 2525|      0|    postBlock();
 2526|      1|  } else {
 2527|      1|    dispatch_async(dispatch_get_main_queue(), postBlock);
 2528|      1|  }
 2529|      1|}
 2530|       |
 2531|       |- (void)URLSession:(NSURLSession *)session
 2532|       |              task:(NSURLSessionTask *)uploadTask
 2533|      0| needNewBodyStream:(void (^)(NSInputStream * GTM_NULLABLE_TYPE bodyStream))completionHandler {
 2534|      0|  [self setSessionTask:uploadTask];
 2535|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ needNewBodyStream:",
 2536|      0|                           [self class], self, session, uploadTask);
 2537|      0|  @synchronized(self) {
 2538|      0|    GTMSessionMonitorSynchronized(self);
 2539|      0|
 2540|      0|    GTMSessionFetcherBodyStreamProvider provider = _bodyStreamProvider;
 2541|      0|#if !STRIP_GTM_FETCH_LOGGING
 2542|      0|    if ([self respondsToSelector:@selector(loggedStreamProviderForStreamProvider:)]) {
 2543|      0|      provider = [self performSelector:@selector(loggedStreamProviderForStreamProvider:)
 2544|      0|                            withObject:provider];
 2545|      0|    }
 2546|      0|#endif
 2547|      0|    if (provider) {
 2548|      0|      [self invokeOnCallbackQueueUnlessStopped:^{
 2549|      0|          provider(completionHandler);
 2550|      0|      }];
 2551|      0|    } else {
 2552|      0|      GTMSESSION_ASSERT_DEBUG(NO, @"NSURLSession expects a stream provider");
 2553|      0|
 2554|      0|      completionHandler(nil);
 2555|      0|    }
 2556|      0|  }  // @synchronized(self)
 2557|      0|}
 2558|       |
 2559|       |- (void)URLSession:(NSURLSession *)session
 2560|       |              task:(NSURLSessionTask *)task
 2561|       |   didSendBodyData:(int64_t)bytesSent
 2562|       |    totalBytesSent:(int64_t)totalBytesSent
 2563|      0|totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
 2564|      0|  [self setSessionTask:task];
 2565|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ didSendBodyData:%lld"
 2566|      0|                           @" totalBytesSent:%lld totalBytesExpectedToSend:%lld",
 2567|      0|                           [self class], self, session, task, bytesSent, totalBytesSent,
 2568|      0|                           totalBytesExpectedToSend);
 2569|      0|  @synchronized(self) {
 2570|      0|    GTMSessionMonitorSynchronized(self);
 2571|      0|
 2572|      0|    if (!_sendProgressBlock) {
 2573|      0|      return;
 2574|      0|    }
 2575|      0|    // We won't hold on to send progress block; it's ok to not send it if the upload finishes.
 2576|      0|    [self invokeOnCallbackQueueUnlessStopped:^{
 2577|      0|      GTMSessionFetcherSendProgressBlock progressBlock;
 2578|      0|      @synchronized(self) {
 2579|      0|        GTMSessionMonitorSynchronized(self);
 2580|      0|
 2581|      0|        progressBlock = self->_sendProgressBlock;
 2582|      0|      }
 2583|      0|      if (progressBlock) {
 2584|      0|        progressBlock(bytesSent, totalBytesSent, totalBytesExpectedToSend);
 2585|      0|      }
 2586|      0|    }];
 2587|      0|  }  // @synchronized(self)
 2588|      0|}
 2589|       |
 2590|       |- (void)URLSession:(NSURLSession *)session
 2591|       |          dataTask:(NSURLSessionDataTask *)dataTask
 2592|      0|    didReceiveData:(NSData *)data {
 2593|      0|  [self setSessionTask:dataTask];
 2594|      0|  NSUInteger bufferLength = data.length;
 2595|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ dataTask:%@ didReceiveData:%p (%llu bytes)",
 2596|      0|                           [self class], self, session, dataTask, data,
 2597|      0|                           (unsigned long long)bufferLength);
 2598|      0|  if (bufferLength == 0) {
 2599|      0|    // Observed on completing an out-of-process upload.
 2600|      0|    return;
 2601|      0|  }
 2602|      0|  @synchronized(self) {
 2603|      0|    GTMSessionMonitorSynchronized(self);
 2604|      0|
 2605|      0|    GTMSessionFetcherAccumulateDataBlock accumulateBlock = _accumulateDataBlock;
 2606|      0|    if (accumulateBlock) {
 2607|      0|      // Let the client accumulate the data.
 2608|      0|      _downloadedLength += bufferLength;
 2609|      0|      [self invokeOnCallbackQueueUnlessStopped:^{
 2610|      0|          accumulateBlock(data);
 2611|      0|      }];
 2612|      0|    } else if (!_userStoppedFetching) {
 2613|      0|      // Append to the mutable data buffer unless the fetch has been cancelled.
 2614|      0|
 2615|      0|      // Resumed upload tasks may not yet have a data buffer.
 2616|      0|      if (_downloadedData == nil) {
 2617|      0|        // Using NSClassFromString for iOS 6 compatibility.
 2618|      0|        GTMSESSION_ASSERT_DEBUG(
 2619|      0|            ![dataTask isKindOfClass:NSClassFromString(@"NSURLSessionDownloadTask")],
 2620|      0|            @"Resumed download tasks should not receive data bytes");
 2621|      0|        _downloadedData = [[NSMutableData alloc] init];
 2622|      0|      }
 2623|      0|
 2624|      0|      [_downloadedData appendData:data];
 2625|      0|      _downloadedLength = (int64_t)_downloadedData.length;
 2626|      0|
 2627|      0|      // We won't hold on to receivedProgressBlock here; it's ok to not send
 2628|      0|      // it if the transfer finishes.
 2629|      0|      if (_receivedProgressBlock) {
 2630|      0|        [self invokeOnCallbackQueueUnlessStopped:^{
 2631|      0|            GTMSessionFetcherReceivedProgressBlock progressBlock;
 2632|      0|            @synchronized(self) {
 2633|      0|              GTMSessionMonitorSynchronized(self);
 2634|      0|
 2635|      0|              progressBlock = self->_receivedProgressBlock;
 2636|      0|            }
 2637|      0|            if (progressBlock) {
 2638|      0|              progressBlock((int64_t)bufferLength, self->_downloadedLength);
 2639|      0|            }
 2640|      0|        }];
 2641|      0|      }
 2642|      0|    }
 2643|      0|  }  // @synchronized(self)
 2644|      0|}
 2645|       |
 2646|       |- (void)URLSession:(NSURLSession *)session
 2647|       |          dataTask:(NSURLSessionDataTask *)dataTask
 2648|       | willCacheResponse:(NSCachedURLResponse *)proposedResponse
 2649|      0| completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler {
 2650|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ dataTask:%@ willCacheResponse:%@ %@",
 2651|      0|                           [self class], self, session, dataTask,
 2652|      0|                           proposedResponse, proposedResponse.response);
 2653|      0|  GTMSessionFetcherWillCacheURLResponseBlock callback;
 2654|      0|  @synchronized(self) {
 2655|      0|    GTMSessionMonitorSynchronized(self);
 2656|      0|
 2657|      0|    callback = _willCacheURLResponseBlock;
 2658|      0|
 2659|      0|    if (callback) {
 2660|      0|      [self invokeOnCallbackQueueAfterUserStopped:YES
 2661|      0|                                            block:^{
 2662|      0|          callback(proposedResponse, completionHandler);
 2663|      0|      }];
 2664|      0|    }
 2665|      0|  }  // @synchronized(self)
 2666|      0|  if (!callback) {
 2667|      0|    completionHandler(proposedResponse);
 2668|      0|  }
 2669|      0|}
 2670|       |
 2671|       |
 2672|       |- (void)URLSession:(NSURLSession *)session
 2673|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 2674|       |      didWriteData:(int64_t)bytesWritten
 2675|       | totalBytesWritten:(int64_t)totalBytesWritten
 2676|      0|totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
 2677|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ downloadTask:%@ didWriteData:%lld"
 2678|      0|                           @" bytesWritten:%lld totalBytesExpectedToWrite:%lld",
 2679|      0|                           [self class], self, session, downloadTask, bytesWritten,
 2680|      0|                           totalBytesWritten, totalBytesExpectedToWrite);
 2681|      0|  [self setSessionTask:downloadTask];
 2682|      0|  @synchronized(self) {
 2683|      0|    GTMSessionMonitorSynchronized(self);
 2684|      0|
 2685|      0|    if ((totalBytesExpectedToWrite != NSURLSessionTransferSizeUnknown) &&
 2686|      0|        (totalBytesExpectedToWrite < totalBytesWritten)) {
 2687|      0|      // Have observed cases were bytesWritten == totalBytesExpectedToWrite,
 2688|      0|      // but totalBytesWritten > totalBytesExpectedToWrite, so setting to unkown in these cases.
 2689|      0|      totalBytesExpectedToWrite = NSURLSessionTransferSizeUnknown;
 2690|      0|    }
 2691|      0|
 2692|      0|    GTMSessionFetcherDownloadProgressBlock progressBlock;
 2693|      0|    progressBlock = self->_downloadProgressBlock;
 2694|      0|    if (progressBlock) {
 2695|      0|      [self invokeOnCallbackQueueUnlessStopped:^{
 2696|      0|        progressBlock(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
 2697|      0|      }];
 2698|      0|    }
 2699|      0|  }  // @synchronized(self)
 2700|      0|}
 2701|       |
 2702|       |- (void)URLSession:(NSURLSession *)session
 2703|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 2704|       | didResumeAtOffset:(int64_t)fileOffset
 2705|      0|expectedTotalBytes:(int64_t)expectedTotalBytes {
 2706|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ downloadTask:%@ didResumeAtOffset:%lld"
 2707|      0|                           @" expectedTotalBytes:%lld",
 2708|      0|                           [self class], self, session, downloadTask, fileOffset,
 2709|      0|                           expectedTotalBytes);
 2710|      0|  [self setSessionTask:downloadTask];
 2711|      0|}
 2712|       |
 2713|       |- (void)URLSession:(NSURLSession *)session
 2714|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 2715|      0|didFinishDownloadingToURL:(NSURL *)downloadLocationURL {
 2716|      0|  // Download may have relaunched app, so update _sessionTask.
 2717|      0|  [self setSessionTask:downloadTask];
 2718|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ downloadTask:%@ didFinishDownloadingToURL:%@",
 2719|      0|                           [self class], self, session, downloadTask, downloadLocationURL);
 2720|      0|  NSNumber *fileSizeNum;
 2721|      0|  [downloadLocationURL getResourceValue:&fileSizeNum
 2722|      0|                                 forKey:NSURLFileSizeKey
 2723|      0|                                  error:NULL];
 2724|      0|  @synchronized(self) {
 2725|      0|    GTMSessionMonitorSynchronized(self);
 2726|      0|
 2727|      0|    NSURL *destinationURL = _destinationFileURL;
 2728|      0|
 2729|      0|    _downloadedLength = fileSizeNum.longLongValue;
 2730|      0|
 2731|      0|    // Overwrite any previous file at the destination URL.
 2732|      0|    NSFileManager *fileMgr = [NSFileManager defaultManager];
 2733|      0|    NSError *removeError;
 2734|      0|    if (![fileMgr removeItemAtURL:destinationURL error:&removeError]
 2735|      0|        && removeError.code != NSFileNoSuchFileError) {
 2736|      0|      GTMSESSION_LOG_DEBUG(@"Could not remove previous file at %@ due to %@",
 2737|      0|                           downloadLocationURL.path, removeError);
 2738|      0|    }
 2739|      0|
 2740|      0|    NSInteger statusCode = [self statusCodeUnsynchronized];
 2741|      0|    if (statusCode < 200 || statusCode > 399) {
 2742|      0|      // In OS X 10.11, the response body is written to a file even on a server
 2743|      0|      // status error.  For convenience of the fetcher client, we'll skip saving the
 2744|      0|      // downloaded body to the destination URL so that clients do not need to know
 2745|      0|      // to delete the file following fetch errors.
 2746|      0|      GTMSESSION_LOG_DEBUG(@"Abandoning download due to status %ld, file %@",
 2747|      0|                           (long)statusCode, downloadLocationURL.path);
 2748|      0|
 2749|      0|      // On error code, add the contents of the temporary file to _downloadTaskErrorData
 2750|      0|      // This way fetcher clients have access to error details possibly passed by the server.
 2751|      0|      if (_downloadedLength > 0 && _downloadedLength <= kMaximumDownloadErrorDataLength) {
 2752|      0|        _downloadTaskErrorData = [NSData dataWithContentsOfURL:downloadLocationURL];
 2753|      0|      } else if (_downloadedLength > kMaximumDownloadErrorDataLength) {
 2754|      0|        GTMSESSION_LOG_DEBUG(@"Download error data for file %@ not passed to userInfo due to size "
 2755|      0|                             @"%lld", downloadLocationURL.path, _downloadedLength);
 2756|      0|      }
 2757|      0|    } else {
 2758|      0|      NSError *moveError;
 2759|      0|      NSURL *destinationFolderURL = [destinationURL URLByDeletingLastPathComponent];
 2760|      0|      BOOL didMoveDownload = NO;
 2761|      0|      if ([fileMgr createDirectoryAtURL:destinationFolderURL
 2762|      0|            withIntermediateDirectories:YES
 2763|      0|                             attributes:nil
 2764|      0|                                  error:&moveError]) {
 2765|      0|        didMoveDownload = [fileMgr moveItemAtURL:downloadLocationURL
 2766|      0|                                           toURL:destinationURL
 2767|      0|                                           error:&moveError];
 2768|      0|      }
 2769|      0|      if (!didMoveDownload) {
 2770|      0|        _downloadFinishedError = moveError;
 2771|      0|      }
 2772|      0|      GTM_LOG_BACKGROUND_SESSION(@"%@ %p Moved download from \"%@\" to \"%@\"  %@",
 2773|      0|                                 [self class], self,
 2774|      0|                                 downloadLocationURL.path, destinationURL.path,
 2775|      0|                                 error ? error : @"");
 2776|      0|    }
 2777|      0|  }  // @synchronized(self)
 2778|      0|}
 2779|       |
 2780|       |/* Sent as the last message related to a specific task.  Error may be
 2781|       | * nil, which implies that no error occurred and this task is complete.
 2782|       | */
 2783|       |- (void)URLSession:(NSURLSession *)session
 2784|       |              task:(NSURLSessionTask *)task
 2785|      0|didCompleteWithError:(NSError *)error {
 2786|      0|  [self setSessionTask:task];
 2787|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ task:%@ didCompleteWithError:%@",
 2788|      0|                           [self class], self, session, task, error);
 2789|      0|
 2790|      0|  NSInteger status = self.statusCode;
 2791|      0|  BOOL forceAssumeRetry = NO;
 2792|      0|  BOOL succeeded = NO;
 2793|      0|  @synchronized(self) {
 2794|      0|    GTMSessionMonitorSynchronized(self);
 2795|      0|
 2796|      0|#if !GTM_DISABLE_FETCHER_TEST_BLOCK
 2797|      0|    // The task is never resumed when a testBlock is used. When the session is destroyed,
 2798|      0|    // we should ignore the callback, since the testBlock support code itself invokes
 2799|      0|    // shouldRetryNowForStatus: and finishWithError:shouldRetry:
 2800|      0|    if (_isUsingTestBlock) return;
 2801|      0|#endif
 2802|      0|
 2803|      0|    if (error == nil) {
 2804|      0|      error = _downloadFinishedError;
 2805|      0|    }
 2806|      0|    succeeded = (error == nil && status >= 0 && status < 300);
 2807|      0|    if (succeeded) {
 2808|      0|      // Succeeded.
 2809|      0|      _bodyLength = task.countOfBytesSent;
 2810|      0|    }
 2811|      0|  }  // @synchronized(self)
 2812|      0|
 2813|      0|  if (succeeded) {
 2814|      0|    [self finishWithError:nil shouldRetry:NO];
 2815|      0|    return;
 2816|      0|  }
 2817|      0|  // For background redirects, no delegate method is called, so we cannot restore a stripped
 2818|      0|  // Authorization header, so if a 403 ("Forbidden") was generated due to a missing OAuth 2 header,
 2819|      0|  // set the current request's URL to the redirected URL, so we in effect restore the Authorization
 2820|      0|  // header.
 2821|      0|  if ((status == 403) && self.usingBackgroundSession) {
 2822|      0|    NSURL *redirectURL = self.response.URL;
 2823|      0|    NSURLRequest *request = self.request;
 2824|      0|    if (![request.URL isEqual:redirectURL]) {
 2825|      0|      NSString *authorizationHeader = [request.allHTTPHeaderFields objectForKey:@"Authorization"];
 2826|      0|      if (authorizationHeader != nil) {
 2827|      0|        NSMutableURLRequest *mutableRequest = [request mutableCopy];
 2828|      0|        mutableRequest.URL = redirectURL;
 2829|      0|        [self updateMutableRequest:mutableRequest];
 2830|      0|        // Avoid assuming the session is still valid.
 2831|      0|        self.session = nil;
 2832|      0|        forceAssumeRetry = YES;
 2833|      0|      }
 2834|      0|    }
 2835|      0|  }
 2836|      0|
 2837|      0|  // If invalidating the session was deferred in stopFetchReleasingCallbacks: then do it now.
 2838|      0|  NSURLSession *oldSession = self.sessionNeedingInvalidation;
 2839|      0|  if (oldSession) {
 2840|      0|    [self setSessionNeedingInvalidation:NULL];
 2841|      0|    [oldSession finishTasksAndInvalidate];
 2842|      0|  }
 2843|      0|
 2844|      0|  // Failed.
 2845|      0|  [self shouldRetryNowForStatus:status
 2846|      0|                          error:error
 2847|      0|               forceAssumeRetry:forceAssumeRetry
 2848|      0|                       response:^(BOOL shouldRetry) {
 2849|      0|    [self finishWithError:error shouldRetry:shouldRetry];
 2850|      0|  }];
 2851|      0|}
 2852|       |
 2853|       |#if TARGET_OS_IPHONE
 2854|      0|- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session {
 2855|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSessionDidFinishEventsForBackgroundURLSession:%@",
 2856|      0|                           [self class], self, session);
 2857|      0|  [self removePersistedBackgroundSessionFromDefaults];
 2858|      0|
 2859|      0|  GTMSessionFetcherSystemCompletionHandler handler;
 2860|      0|  @synchronized(self) {
 2861|      0|    GTMSessionMonitorSynchronized(self);
 2862|      0|
 2863|      0|    handler = self.systemCompletionHandler;
 2864|      0|    self.systemCompletionHandler = nil;
 2865|      0|  }  // @synchronized(self)
 2866|      0|  if (handler) {
 2867|      0|    GTM_LOG_BACKGROUND_SESSION(@"%@ %p Calling system completionHandler", [self class], self);
 2868|      0|    handler();
 2869|      0|
 2870|      0|    @synchronized(self) {
 2871|      0|      GTMSessionMonitorSynchronized(self);
 2872|      0|
 2873|      0|      NSURLSession *oldSession = _session;
 2874|      0|      _session = nil;
 2875|      0|      if (_shouldInvalidateSession) {
 2876|      0|        [oldSession finishTasksAndInvalidate];
 2877|      0|      }
 2878|      0|    }  // @synchronized(self)
 2879|      0|  }
 2880|      0|}
 2881|       |#endif
 2882|       |
 2883|      0|- (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(GTM_NULLABLE NSError *)error {
 2884|      0|  // This may happen repeatedly for retries.  On authentication callbacks, the retry
 2885|      0|  // may begin before the prior session sends the didBecomeInvalid delegate message.
 2886|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ didBecomeInvalidWithError:%@",
 2887|      0|                           [self class], self, session, error);
 2888|      0|  if (session == (NSURLSession *)self.session) {
 2889|      0|    GTM_LOG_SESSION_DELEGATE(@"  Unexpected retained invalid session: %@", session);
 2890|      0|    self.session = nil;
 2891|      0|  }
 2892|      0|}
 2893|       |
 2894|      0|- (void)finishWithError:(GTM_NULLABLE NSError *)error shouldRetry:(BOOL)shouldRetry {
 2895|      0|  [self removePersistedBackgroundSessionFromDefaults];
 2896|      0|
 2897|      0|  BOOL shouldStopFetching = YES;
 2898|      0|  NSData *downloadedData = nil;
 2899|      0|#if !STRIP_GTM_FETCH_LOGGING
 2900|      0|  BOOL shouldDeferLogging = NO;
 2901|      0|#endif
 2902|      0|  BOOL shouldBeginRetryTimer = NO;
 2903|      0|  NSInteger status = [self statusCode];
 2904|      0|  NSURL *destinationURL = self.destinationFileURL;
 2905|      0|
 2906|      0|  BOOL fetchSucceeded = (error == nil && status >= 0 && status < 300);
 2907|      0|
 2908|      0|#if !STRIP_GTM_FETCH_LOGGING
 2909|      0|  if (!fetchSucceeded) {
 2910|      0|    if (!shouldDeferLogging && !self.hasLoggedError) {
 2911|      0|      [self logNowWithError:error];
 2912|      0|      self.hasLoggedError = YES;
 2913|      0|    }
 2914|      0|  }
 2915|      0|#endif  // !STRIP_GTM_FETCH_LOGGING
 2916|      0|
 2917|      0|  @synchronized(self) {
 2918|      0|    GTMSessionMonitorSynchronized(self);
 2919|      0|
 2920|      0|#if !STRIP_GTM_FETCH_LOGGING
 2921|      0|    shouldDeferLogging = _deferResponseBodyLogging;
 2922|      0|#endif
 2923|      0|    if (fetchSucceeded) {
 2924|      0|      // Success
 2925|      0|      if ((_downloadedData.length > 0) && (destinationURL != nil)) {
 2926|      0|        // Overwrite any previous file at the destination URL.
 2927|      0|        NSFileManager *fileMgr = [NSFileManager defaultManager];
 2928|      0|        [fileMgr removeItemAtURL:destinationURL
 2929|      0|                           error:NULL];
 2930|      0|        NSURL *destinationFolderURL = [destinationURL URLByDeletingLastPathComponent];
 2931|      0|        BOOL didMoveDownload = NO;
 2932|      0|        if ([fileMgr createDirectoryAtURL:destinationFolderURL
 2933|      0|              withIntermediateDirectories:YES
 2934|      0|                               attributes:nil
 2935|      0|                                    error:&error]) {
 2936|      0|          didMoveDownload = [_downloadedData writeToURL:destinationURL
 2937|      0|                                                options:NSDataWritingAtomic
 2938|      0|                                                  error:&error];
 2939|      0|        }
 2940|      0|        if (didMoveDownload) {
 2941|      0|          _downloadedData = nil;
 2942|      0|        } else {
 2943|      0|          _downloadFinishedError = error;
 2944|      0|        }
 2945|      0|      }
 2946|      0|      downloadedData = _downloadedData;
 2947|      0|    } else {
 2948|      0|      // Unsuccessful with error or status over 300. Retry or notify the delegate of failure
 2949|      0|      if (shouldRetry) {
 2950|      0|        // Retrying.
 2951|      0|        shouldBeginRetryTimer = YES;
 2952|      0|        shouldStopFetching = NO;
 2953|      0|      } else {
 2954|      0|        if (error == nil) {
 2955|      0|          // Create an error.
 2956|      0|          NSDictionary *userInfo = GTMErrorUserInfoForData(
 2957|      0|              _downloadedData.length > 0 ? _downloadedData : _downloadTaskErrorData,
 2958|      0|              [self responseHeadersUnsynchronized]);
 2959|      0|
 2960|      0|          error = [NSError errorWithDomain:kGTMSessionFetcherStatusDomain
 2961|      0|                                      code:status
 2962|      0|                                  userInfo:userInfo];
 2963|      0|        } else {
 2964|      0|          // If the error had resume data, and the client supplied a resume block, pass the
 2965|      0|          // data to the client.
 2966|      0|          void (^resumeBlock)(NSData *) = _resumeDataBlock;
 2967|      0|          _resumeDataBlock = nil;
 2968|      0|          if (resumeBlock) {
 2969|      0|            NSData *resumeData = [error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData];
 2970|      0|            if (resumeData) {
 2971|      0|              [self invokeOnCallbackQueueAfterUserStopped:YES block:^{
 2972|      0|                  resumeBlock(resumeData);
 2973|      0|              }];
 2974|      0|            }
 2975|      0|          }
 2976|      0|        }
 2977|      0|        if (_downloadedData.length > 0) {
 2978|      0|          downloadedData = _downloadedData;
 2979|      0|        }
 2980|      0|        // If the error occurred after retries, report the number and duration of the
 2981|      0|        // retries. This provides a clue to a developer looking at the error description
 2982|      0|        // that the fetcher did retry before failing with this error.
 2983|      0|        if (_retryCount > 0) {
 2984|      0|          NSMutableDictionary *userInfoWithRetries =
 2985|      0|              [NSMutableDictionary dictionaryWithDictionary:(NSDictionary *)error.userInfo];
 2986|      0|          NSTimeInterval timeSinceInitialRequest = -[_initialRequestDate timeIntervalSinceNow];
 2987|      0|          [userInfoWithRetries setObject:@(timeSinceInitialRequest)
 2988|      0|                                  forKey:kGTMSessionFetcherElapsedIntervalWithRetriesKey];
 2989|      0|          [userInfoWithRetries setObject:@(_retryCount)
 2990|      0|                                  forKey:kGTMSessionFetcherNumberOfRetriesDoneKey];
 2991|      0|          error = [NSError errorWithDomain:(NSString *)error.domain
 2992|      0|                                      code:error.code
 2993|      0|                                  userInfo:userInfoWithRetries];
 2994|      0|        }
 2995|      0|      }
 2996|      0|    }
 2997|      0|  }  // @synchronized(self)
 2998|      0|
 2999|      0|  if (shouldBeginRetryTimer) {
 3000|      0|    [self beginRetryTimer];
 3001|      0|  }
 3002|      0|
 3003|      0|  // We want to send the stop notification before calling the delegate's
 3004|      0|  // callback selector, since the callback selector may release all of
 3005|      0|  // the fetcher properties that the client is using to track the fetches.
 3006|      0|  //
 3007|      0|  // We'll also stop now so that, to any observers watching the notifications,
 3008|      0|  // it doesn't look like our wait for a retry (which may be long,
 3009|      0|  // 30 seconds or more) is part of the network activity.
 3010|      0|  [self sendStopNotificationIfNeeded];
 3011|      0|
 3012|      0|  if (shouldStopFetching) {
 3013|      0|    [self invokeFetchCallbacksOnCallbackQueueWithData:downloadedData
 3014|      0|                                                error:error];
 3015|      0|    // The upload subclass doesn't want to release callbacks until upload chunks have completed.
 3016|      0|    BOOL shouldRelease = [self shouldReleaseCallbacksUponCompletion];
 3017|      0|    [self stopFetchReleasingCallbacks:shouldRelease];
 3018|      0|  }
 3019|      0|
 3020|      0|#if !STRIP_GTM_FETCH_LOGGING
 3021|      0|  // _hasLoggedError is only set by this method
 3022|      0|  if (!shouldDeferLogging && !_hasLoggedError) {
 3023|      0|    [self logNowWithError:error];
 3024|      0|  }
 3025|      0|#endif
 3026|      0|}
 3027|       |
 3028|      0|- (BOOL)shouldReleaseCallbacksUponCompletion {
 3029|      0|  // A subclass can override this to keep callbacks around after the
 3030|      0|  // connection has finished successfully
 3031|      0|  return YES;
 3032|      0|}
 3033|       |
 3034|      0|- (void)logNowWithError:(GTM_NULLABLE NSError *)error {
 3035|      0|  GTMSessionCheckNotSynchronized(self);
 3036|      0|
 3037|      0|  // If the logging category is available, then log the current request,
 3038|      0|  // response, data, and error
 3039|      0|  if ([self respondsToSelector:@selector(logFetchWithError:)]) {
 3040|      0|    [self performSelector:@selector(logFetchWithError:) withObject:error];
 3041|      0|  }
 3042|      0|}
 3043|       |
 3044|       |#pragma mark Retries
 3045|       |
 3046|      0|- (BOOL)isRetryError:(NSError *)error {
 3047|      0|  struct RetryRecord {
 3048|      0|    __unsafe_unretained NSString *const domain;
 3049|      0|    NSInteger code;
 3050|      0|  };
 3051|      0|
 3052|      0|  struct RetryRecord retries[] = {
 3053|      0|    { kGTMSessionFetcherStatusDomain, 408 }, // request timeout
 3054|      0|    { kGTMSessionFetcherStatusDomain, 502 }, // failure gatewaying to another server
 3055|      0|    { kGTMSessionFetcherStatusDomain, 503 }, // service unavailable
 3056|      0|    { kGTMSessionFetcherStatusDomain, 504 }, // request timeout
 3057|      0|    { NSURLErrorDomain, NSURLErrorTimedOut },
 3058|      0|    { NSURLErrorDomain, NSURLErrorNetworkConnectionLost },
 3059|      0|    { nil, 0 }
 3060|      0|  };
 3061|      0|
 3062|      0|  // NSError's isEqual always returns false for equal but distinct instances
 3063|      0|  // of NSError, so we have to compare the domain and code values explicitly
 3064|      0|  NSString *domain = error.domain;
 3065|      0|  NSInteger code = error.code;
 3066|      0|  for (int idx = 0; retries[idx].domain != nil; idx++) {
 3067|      0|    if (code == retries[idx].code && [domain isEqual:retries[idx].domain]) {
 3068|      0|      return YES;
 3069|      0|    }
 3070|      0|  }
 3071|      0|  return NO;
 3072|      0|}
 3073|       |
 3074|       |// shouldRetryNowForStatus:error: responds with YES if the user has enabled retries
 3075|       |// and the status or error is one that is suitable for retrying.  "Suitable"
 3076|       |// means either the isRetryError:'s list contains the status or error, or the
 3077|       |// user's retry block is present and returns YES when called, or the
 3078|       |// authorizer may be able to fix.
 3079|       |- (void)shouldRetryNowForStatus:(NSInteger)status
 3080|       |                          error:(NSError *)error
 3081|       |               forceAssumeRetry:(BOOL)forceAssumeRetry
 3082|      0|                       response:(GTMSessionFetcherRetryResponse)response {
 3083|      0|  // Determine if a refreshed authorizer may avoid an authorization error
 3084|      0|  BOOL willRetry = NO;
 3085|      0|
 3086|      0|  // We assume _authorizer is immutable after beginFetch, and _hasAttemptedAuthRefresh is modified
 3087|      0|  // only in this method, and this method is invoked on the serial delegate queue.
 3088|      0|  //
 3089|      0|  // We want to avoid calling the authorizer from inside a sync block.
 3090|      0|  BOOL isFirstAuthError = (_authorizer != nil
 3091|      0|                           && !_hasAttemptedAuthRefresh
 3092|      0|                           && status == GTMSessionFetcherStatusUnauthorized); // 401
 3093|      0|
 3094|      0|  BOOL hasPrimed = NO;
 3095|      0|  if (isFirstAuthError) {
 3096|      0|    if ([_authorizer respondsToSelector:@selector(primeForRefresh)]) {
 3097|      0|      hasPrimed = [_authorizer primeForRefresh];
 3098|      0|    }
 3099|      0|  }
 3100|      0|
 3101|      0|  BOOL shouldRetryForAuthRefresh = NO;
 3102|      0|  if (hasPrimed) {
 3103|      0|    shouldRetryForAuthRefresh = YES;
 3104|      0|    _hasAttemptedAuthRefresh = YES;
 3105|      0|    [self updateRequestValue:nil forHTTPHeaderField:@"Authorization"];
 3106|      0|  }
 3107|      0|
 3108|      0|  @synchronized(self) {
 3109|      0|    GTMSessionMonitorSynchronized(self);
 3110|      0|
 3111|      0|    BOOL shouldDoRetry = [self isRetryEnabledUnsynchronized];
 3112|      0|    if (shouldDoRetry && ![self hasRetryAfterInterval]) {
 3113|      0|
 3114|      0|      // Determine if we're doing exponential backoff retries
 3115|      0|      shouldDoRetry = [self nextRetryIntervalUnsynchronized] < _maxRetryInterval;
 3116|      0|
 3117|      0|      if (shouldDoRetry) {
 3118|      0|        // If an explicit max retry interval was set, we expect repeated backoffs to take
 3119|      0|        // up to roughly twice that for repeated fast failures.  If the initial attempt is
 3120|      0|        // already more than 3 times the max retry interval, then failures have taken a long time
 3121|      0|        // (such as from network timeouts) so don't retry again to avoid the app becoming
 3122|      0|        // unexpectedly unresponsive.
 3123|      0|        if (_maxRetryInterval > 0) {
 3124|      0|          NSTimeInterval maxAllowedIntervalBeforeRetry = _maxRetryInterval * 3;
 3125|      0|          NSTimeInterval timeSinceInitialRequest = -[_initialRequestDate timeIntervalSinceNow];
 3126|      0|          if (timeSinceInitialRequest > maxAllowedIntervalBeforeRetry) {
 3127|      0|            shouldDoRetry = NO;
 3128|      0|          }
 3129|      0|        }
 3130|      0|      }
 3131|      0|    }
 3132|      0|    BOOL canRetry = shouldRetryForAuthRefresh || forceAssumeRetry || shouldDoRetry;
 3133|      0|    if (canRetry) {
 3134|      0|      NSDictionary *userInfo =
 3135|      0|          GTMErrorUserInfoForData(_downloadedData, [self responseHeadersUnsynchronized]);
 3136|      0|      NSError *statusError = [NSError errorWithDomain:kGTMSessionFetcherStatusDomain
 3137|      0|                                                 code:status
 3138|      0|                                             userInfo:userInfo];
 3139|      0|      if (error == nil) {
 3140|      0|        error = statusError;
 3141|      0|      }
 3142|      0|      willRetry = shouldRetryForAuthRefresh ||
 3143|      0|                  forceAssumeRetry ||
 3144|      0|                  [self isRetryError:error] ||
 3145|      0|                  ((error != statusError) && [self isRetryError:statusError]);
 3146|      0|
 3147|      0|      // If the user has installed a retry callback, consult that.
 3148|      0|      GTMSessionFetcherRetryBlock retryBlock = _retryBlock;
 3149|      0|      if (retryBlock) {
 3150|      0|        [self invokeOnCallbackQueueUnlessStopped:^{
 3151|      0|            retryBlock(willRetry, error, response);
 3152|      0|        }];
 3153|      0|        return;
 3154|      0|      }
 3155|      0|    }
 3156|      0|  }  // @synchronized(self)
 3157|      0|  response(willRetry);
 3158|      0|}
 3159|       |
 3160|      0|- (BOOL)hasRetryAfterInterval {
 3161|      0|  GTMSessionCheckSynchronized(self);
 3162|      0|
 3163|      0|  NSDictionary *responseHeaders = [self responseHeadersUnsynchronized];
 3164|      0|  NSString *retryAfterValue = [responseHeaders valueForKey:@"Retry-After"];
 3165|      0|  return (retryAfterValue != nil);
 3166|      0|}
 3167|       |
 3168|      0|- (NSTimeInterval)retryAfterInterval {
 3169|      0|  GTMSessionCheckSynchronized(self);
 3170|      0|
 3171|      0|  NSDictionary *responseHeaders = [self responseHeadersUnsynchronized];
 3172|      0|  NSString *retryAfterValue = [responseHeaders valueForKey:@"Retry-After"];
 3173|      0|  if (retryAfterValue == nil) {
 3174|      0|    return 0;
 3175|      0|  }
 3176|      0|  // Retry-After formatted as HTTP-date | delta-seconds
 3177|      0|  // Reference: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
 3178|      0|  NSDateFormatter *rfc1123DateFormatter = [[NSDateFormatter alloc] init];
 3179|      0|  rfc1123DateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US"];
 3180|      0|  rfc1123DateFormatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@"GMT"];
 3181|      0|  rfc1123DateFormatter.dateFormat = @"EEE',' dd MMM yyyy HH':'mm':'ss z";
 3182|      0|  NSDate *retryAfterDate = [rfc1123DateFormatter dateFromString:retryAfterValue];
 3183|      0|  NSTimeInterval retryAfterInterval = (retryAfterDate != nil) ?
 3184|      0|      retryAfterDate.timeIntervalSinceNow : retryAfterValue.intValue;
 3185|      0|  retryAfterInterval = MAX(0, retryAfterInterval);
 3186|      0|  return retryAfterInterval;
 3187|      0|}
 3188|       |
 3189|      0|- (void)beginRetryTimer {
 3190|      0|  if (![NSThread isMainThread]) {
 3191|      0|    // Defer creating and starting the timer until we're on the main thread to ensure it has
 3192|      0|    // a run loop.
 3193|      0|    dispatch_group_async(_callbackGroup, dispatch_get_main_queue(), ^{
 3194|      0|        [self beginRetryTimer];
 3195|      0|    });
 3196|      0|    return;
 3197|      0|  }
 3198|      0|
 3199|      0|  [self destroyRetryTimer];
 3200|      0|  
 3201|      0|#if GTM_BACKGROUND_TASK_FETCHING
 3202|      0|  // Don't keep a background task active while awaiting retry, which can lead to the
 3203|      0|  // app exceeding the allotted time for keeping the background task open, causing the
 3204|      0|  // system to terminate the app. When the retry starts, a new background task will
 3205|      0|  // be created.
 3206|      0|  [self endBackgroundTask];
 3207|      0|#endif  // GTM_BACKGROUND_TASK_FETCHING
 3208|      0|
 3209|      0|  @synchronized(self) {
 3210|      0|    GTMSessionMonitorSynchronized(self);
 3211|      0|
 3212|      0|    NSTimeInterval nextInterval = [self nextRetryIntervalUnsynchronized];
 3213|      0|    NSTimeInterval maxInterval = _maxRetryInterval;
 3214|      0|    NSTimeInterval newInterval = MIN(nextInterval, (maxInterval > 0 ? maxInterval : DBL_MAX));
 3215|      0|    NSTimeInterval newIntervalTolerance = (newInterval / 10) > 1.0 ?: 1.0;
 3216|      0|
 3217|      0|    _lastRetryInterval = newInterval;
 3218|      0|
 3219|      0|    _retryTimer = [NSTimer timerWithTimeInterval:newInterval
 3220|      0|                                          target:self
 3221|      0|                                        selector:@selector(retryTimerFired:)
 3222|      0|                                        userInfo:nil
 3223|      0|                                         repeats:NO];
 3224|      0|    _retryTimer.tolerance = newIntervalTolerance;
 3225|      0|    [[NSRunLoop mainRunLoop] addTimer:_retryTimer
 3226|      0|                              forMode:NSDefaultRunLoopMode];
 3227|      0|  }  // @synchronized(self)
 3228|      0|
 3229|      0|  [self postNotificationOnMainThreadWithName:kGTMSessionFetcherRetryDelayStartedNotification
 3230|      0|                                    userInfo:nil
 3231|      0|                                requireAsync:NO];
 3232|      0|}
 3233|       |
 3234|      0|- (void)retryTimerFired:(NSTimer *)timer {
 3235|      0|  [self destroyRetryTimer];
 3236|      0|
 3237|      0|  @synchronized(self) {
 3238|      0|    GTMSessionMonitorSynchronized(self);
 3239|      0|
 3240|      0|    _retryCount++;
 3241|      0|  }  // @synchronized(self)
 3242|      0|
 3243|      0|  NSOperationQueue *queue = self.sessionDelegateQueue;
 3244|      0|  [queue addOperationWithBlock:^{
 3245|      0|    [self retryFetch];
 3246|      0|  }];
 3247|      0|}
 3248|       |
 3249|      0|- (void)destroyRetryTimer {
 3250|      0|  BOOL shouldNotify = NO;
 3251|      0|
 3252|      0|  @synchronized(self) {
 3253|      0|    GTMSessionMonitorSynchronized(self);
 3254|      0|
 3255|      0|    if (_retryTimer) {
 3256|      0|      [_retryTimer invalidate];
 3257|      0|      _retryTimer = nil;
 3258|      0|      shouldNotify = YES;
 3259|      0|    }
 3260|      0|  }
 3261|      0|
 3262|      0|  if (shouldNotify) {
 3263|      0|    [self postNotificationOnMainThreadWithName:kGTMSessionFetcherRetryDelayStoppedNotification
 3264|      0|                                      userInfo:nil
 3265|      0|                                  requireAsync:NO];
 3266|      0|  }
 3267|      0|}
 3268|       |
 3269|      0|- (NSUInteger)retryCount {
 3270|      0|  @synchronized(self) {
 3271|      0|    GTMSessionMonitorSynchronized(self);
 3272|      0|
 3273|      0|    return _retryCount;
 3274|      0|  }  // @synchronized(self)
 3275|      0|}
 3276|       |
 3277|      0|- (NSTimeInterval)nextRetryInterval {
 3278|      0|  @synchronized(self) {
 3279|      0|    GTMSessionMonitorSynchronized(self);
 3280|      0|
 3281|      0|    NSTimeInterval interval = [self nextRetryIntervalUnsynchronized];
 3282|      0|    return interval;
 3283|      0|  }  // @synchronized(self)
 3284|      0|}
 3285|       |
 3286|      0|- (NSTimeInterval)nextRetryIntervalUnsynchronized {
 3287|      0|  GTMSessionCheckSynchronized(self);
 3288|      0|
 3289|      0|  NSInteger statusCode = [self statusCodeUnsynchronized];
 3290|      0|  if ((statusCode == 503) && [self hasRetryAfterInterval]) {
 3291|      0|    NSTimeInterval secs = [self retryAfterInterval];
 3292|      0|    return secs;
 3293|      0|  }
 3294|      0|  // The next wait interval is the factor (2.0) times the last interval,
 3295|      0|  // but never less than the minimum interval.
 3296|      0|  NSTimeInterval secs = _lastRetryInterval * _retryFactor;
 3297|      0|  if (_maxRetryInterval > 0) {
 3298|      0|    secs = MIN(secs, _maxRetryInterval);
 3299|      0|  }
 3300|      0|  secs = MAX(secs, _minRetryInterval);
 3301|      0|
 3302|      0|  return secs;
 3303|      0|}
 3304|       |
 3305|      0|- (NSTimer *)retryTimer {
 3306|      0|  @synchronized(self) {
 3307|      0|    GTMSessionMonitorSynchronized(self);
 3308|      0|
 3309|      0|    return _retryTimer;
 3310|      0|  }  // @synchronized(self)
 3311|      0|}
 3312|       |
 3313|      1|- (BOOL)isRetryEnabled {
 3314|      1|  @synchronized(self) {
 3315|      1|    GTMSessionMonitorSynchronized(self);
 3316|      1|
 3317|      1|    return _isRetryEnabled;
 3318|      1|  }  // @synchronized(self)
 3319|      1|}
 3320|       |
 3321|      0|- (BOOL)isRetryEnabledUnsynchronized {
 3322|      0|  GTMSessionCheckSynchronized(self);
 3323|      0|
 3324|      0|  return _isRetryEnabled;
 3325|      0|}
 3326|       |
 3327|      1|- (void)setRetryEnabled:(BOOL)flag {
 3328|      1|
 3329|      1|  @synchronized(self) {
 3330|      1|    GTMSessionMonitorSynchronized(self);
 3331|      1|
 3332|      1|    if (flag && !_isRetryEnabled) {
 3333|      0|      // We defer initializing these until the user calls setRetryEnabled
 3334|      0|      // to avoid using the random number generator if it's not needed.
 3335|      0|      // However, this means min and max intervals for this fetcher are reset
 3336|      0|      // as a side effect of calling setRetryEnabled.
 3337|      0|      //
 3338|      0|      // Make an initial retry interval random between 1.0 and 2.0 seconds
 3339|      0|      _minRetryInterval = InitialMinRetryInterval();
 3340|      0|      _maxRetryInterval = kUnsetMaxRetryInterval;
 3341|      0|      _retryFactor = 2.0;
 3342|      0|      _lastRetryInterval = 0.0;
 3343|      0|    }
 3344|      1|    _isRetryEnabled = flag;
 3345|      1|  }  // @synchronized(self)
 3346|      1|};
 3347|       |
 3348|      0|- (NSTimeInterval)maxRetryInterval {
 3349|      0|  @synchronized(self) {
 3350|      0|    GTMSessionMonitorSynchronized(self);
 3351|      0|
 3352|      0|    return _maxRetryInterval;
 3353|      0|  }  // @synchronized(self)
 3354|      0|}
 3355|       |
 3356|      1|- (void)setMaxRetryInterval:(NSTimeInterval)secs {
 3357|      1|  @synchronized(self) {
 3358|      1|    GTMSessionMonitorSynchronized(self);
 3359|      1|
 3360|      1|    if (secs > 0) {
 3361|      0|      _maxRetryInterval = secs;
 3362|      1|    } else {
 3363|      1|      _maxRetryInterval = kUnsetMaxRetryInterval;
 3364|      1|    }
 3365|      1|  }  // @synchronized(self)
 3366|      1|}
 3367|       |
 3368|      0|- (double)minRetryInterval {
 3369|      0|  @synchronized(self) {
 3370|      0|    GTMSessionMonitorSynchronized(self);
 3371|      0|
 3372|      0|    return _minRetryInterval;
 3373|      0|  }  // @synchronized(self)
 3374|      0|}
 3375|       |
 3376|      1|- (void)setMinRetryInterval:(NSTimeInterval)secs {
 3377|      1|  @synchronized(self) {
 3378|      1|    GTMSessionMonitorSynchronized(self);
 3379|      1|
 3380|      1|    if (secs > 0) {
 3381|      0|      _minRetryInterval = secs;
 3382|      1|    } else {
 3383|      1|      // Set min interval to a random value between 1.0 and 2.0 seconds
 3384|      1|      // so that if multiple clients start retrying at the same time, they'll
 3385|      1|      // repeat at different times and avoid overloading the server
 3386|      1|      _minRetryInterval = InitialMinRetryInterval();
 3387|      1|    }
 3388|      1|  }  // @synchronized(self)
 3389|      1|
 3390|      1|}
 3391|       |
 3392|       |#pragma mark iOS System Completion Handlers
 3393|       |
 3394|       |#if TARGET_OS_IPHONE
 3395|       |static NSMutableDictionary *gSystemCompletionHandlers = nil;
 3396|       |
 3397|      0|- (GTM_NULLABLE GTMSessionFetcherSystemCompletionHandler)systemCompletionHandler {
 3398|      0|  return [[self class] systemCompletionHandlerForSessionIdentifier:_sessionIdentifier];
 3399|      0|}
 3400|       |
 3401|      0|- (void)setSystemCompletionHandler:(GTM_NULLABLE GTMSessionFetcherSystemCompletionHandler)systemCompletionHandler {
 3402|      0|  [[self class] setSystemCompletionHandler:systemCompletionHandler
 3403|      0|                      forSessionIdentifier:_sessionIdentifier];
 3404|      0|}
 3405|       |
 3406|       |+ (void)setSystemCompletionHandler:(GTM_NULLABLE GTMSessionFetcherSystemCompletionHandler)systemCompletionHandler
 3407|      0|              forSessionIdentifier:(NSString *)sessionIdentifier {
 3408|      0|  if (!sessionIdentifier) {
 3409|      0|    NSLog(@"%s with nil identifier", __PRETTY_FUNCTION__);
 3410|      0|    return;
 3411|      0|  }
 3412|      0|
 3413|      0|  @synchronized([GTMSessionFetcher class]) {
 3414|      0|    if (gSystemCompletionHandlers == nil && systemCompletionHandler != nil) {
 3415|      0|      gSystemCompletionHandlers = [[NSMutableDictionary alloc] init];
 3416|      0|    }
 3417|      0|    // Use setValue: to remove the object if completionHandler is nil.
 3418|      0|    [gSystemCompletionHandlers setValue:systemCompletionHandler
 3419|      0|                                 forKey:sessionIdentifier];
 3420|      0|  }
 3421|      0|}
 3422|       |
 3423|      0|+ (GTM_NULLABLE GTMSessionFetcherSystemCompletionHandler)systemCompletionHandlerForSessionIdentifier:(NSString *)sessionIdentifier {
 3424|      0|  if (!sessionIdentifier) {
 3425|      0|    return nil;
 3426|      0|  }
 3427|      0|  @synchronized([GTMSessionFetcher class]) {
 3428|      0|    return [gSystemCompletionHandlers objectForKey:sessionIdentifier];
 3429|      0|  }
 3430|      0|}
 3431|       |#endif  // TARGET_OS_IPHONE
 3432|       |
 3433|       |#pragma mark Getters and Setters
 3434|       |
 3435|       |@synthesize downloadResumeData = _downloadResumeData,
 3436|       |            configuration = _configuration,
 3437|       |            configurationBlock = _configurationBlock,
 3438|       |            sessionTask = _sessionTask,
 3439|       |            wasCreatedFromBackgroundSession = _wasCreatedFromBackgroundSession,
 3440|       |            sessionUserInfo = _sessionUserInfo,
 3441|       |            taskDescription = _taskDescription,
 3442|       |            taskPriority = _taskPriority,
 3443|       |            usingBackgroundSession = _usingBackgroundSession,
 3444|       |            canShareSession = _canShareSession,
 3445|       |            completionHandler = _completionHandler,
 3446|       |            credential = _credential,
 3447|       |            proxyCredential = _proxyCredential,
 3448|       |            bodyData = _bodyData,
 3449|       |            bodyLength = _bodyLength,
 3450|       |            service = _service,
 3451|       |            serviceHost = _serviceHost,
 3452|       |            accumulateDataBlock = _accumulateDataBlock,
 3453|       |            receivedProgressBlock = _receivedProgressBlock,
 3454|       |            downloadProgressBlock = _downloadProgressBlock,
 3455|       |            resumeDataBlock = _resumeDataBlock,
 3456|       |            didReceiveResponseBlock = _didReceiveResponseBlock,
 3457|       |            challengeBlock = _challengeBlock,
 3458|       |            willRedirectBlock = _willRedirectBlock,
 3459|       |            sendProgressBlock = _sendProgressBlock,
 3460|       |            willCacheURLResponseBlock = _willCacheURLResponseBlock,
 3461|       |            retryBlock = _retryBlock,
 3462|       |            retryFactor = _retryFactor,
 3463|       |            allowedInsecureSchemes = _allowedInsecureSchemes,
 3464|       |            allowLocalhostRequest = _allowLocalhostRequest,
 3465|       |            allowInvalidServerCertificates = _allowInvalidServerCertificates,
 3466|       |            cookieStorage = _cookieStorage,
 3467|       |            callbackQueue = _callbackQueue,
 3468|       |            initialBeginFetchDate = _initialBeginFetchDate,
 3469|       |            testBlock = _testBlock,
 3470|       |            testBlockAccumulateDataChunkCount = _testBlockAccumulateDataChunkCount,
 3471|       |            comment = _comment,
 3472|       |            log = _log;
 3473|       |
 3474|       |#if !STRIP_GTM_FETCH_LOGGING
 3475|       |@synthesize redirectedFromURL = _redirectedFromURL,
 3476|       |            logRequestBody = _logRequestBody,
 3477|       |            logResponseBody = _logResponseBody,
 3478|       |            hasLoggedError = _hasLoggedError;
 3479|       |#endif
 3480|       |
 3481|       |#if GTM_BACKGROUND_TASK_FETCHING
 3482|       |@synthesize backgroundTaskIdentifier = _backgroundTaskIdentifier,
 3483|       |            skipBackgroundTask = _skipBackgroundTask;
 3484|       |#endif
 3485|       |
 3486|      1|- (GTM_NULLABLE NSURLRequest *)request {
 3487|      1|  @synchronized(self) {
 3488|      1|    GTMSessionMonitorSynchronized(self);
 3489|      1|
 3490|      1|    return [_request copy];
 3491|      1|  }  // @synchronized(self)
 3492|      1|}
 3493|       |
 3494|      0|- (void)setRequest:(GTM_NULLABLE NSURLRequest *)request {
 3495|      0|  @synchronized(self) {
 3496|      0|    GTMSessionMonitorSynchronized(self);
 3497|      0|
 3498|      0|    if (![self isFetchingUnsynchronized]) {
 3499|      0|      _request = [request mutableCopy];
 3500|      0|    } else {
 3501|      0|      GTMSESSION_ASSERT_DEBUG(0, @"request may not be set after beginFetch has been invoked");
 3502|      0|    }
 3503|      0|  }  // @synchronized(self)
 3504|      0|}
 3505|       |
 3506|      0|- (GTM_NULLABLE NSMutableURLRequest *)mutableRequestForTesting {
 3507|      0|  // Allow tests only to modify the request, useful during retries.
 3508|      0|  return _request;
 3509|      0|}
 3510|       |
 3511|       |// Internal method for updating the request property such as on redirects.
 3512|      0|- (void)updateMutableRequest:(GTM_NULLABLE NSMutableURLRequest *)request {
 3513|      0|  @synchronized(self) {
 3514|      0|    GTMSessionMonitorSynchronized(self);
 3515|      0|
 3516|      0|    _request = request;
 3517|      0|  }  // @synchronized(self)
 3518|      0|}
 3519|       |
 3520|       |// Set a header field value on the request. Header field value changes will not
 3521|       |// affect a fetch after the fetch has begun.
 3522|      1|- (void)setRequestValue:(GTM_NULLABLE NSString *)value forHTTPHeaderField:(NSString *)field {
 3523|      1|  if (![self isFetching]) {
 3524|      1|    [self updateRequestValue:value forHTTPHeaderField:field];
 3525|      1|  } else {
 3526|      0|    GTMSESSION_ASSERT_DEBUG(0, @"request may not be set after beginFetch has been invoked");
 3527|      0|  }
 3528|      1|}
 3529|       |
 3530|       |// Internal method for updating request headers.
 3531|      1|- (void)updateRequestValue:(GTM_NULLABLE NSString *)value forHTTPHeaderField:(NSString *)field {
 3532|      1|  @synchronized(self) {
 3533|      1|    GTMSessionMonitorSynchronized(self);
 3534|      1|
 3535|      1|    [_request setValue:value forHTTPHeaderField:field];
 3536|      1|  }  // @synchronized(self)
 3537|      1|}
 3538|       |
 3539|      0|- (void)setResponse:(GTM_NULLABLE NSURLResponse *)response {
 3540|      0|  @synchronized(self) {
 3541|      0|    GTMSessionMonitorSynchronized(self);
 3542|      0|
 3543|      0|    _response = response;
 3544|      0|  }  // @synchronized(self)
 3545|      0|}
 3546|       |
 3547|      0|- (int64_t)bodyLength {
 3548|      0|  @synchronized(self) {
 3549|      0|    GTMSessionMonitorSynchronized(self);
 3550|      0|
 3551|      0|    if (_bodyLength == NSURLSessionTransferSizeUnknown) {
 3552|      0|      if (_bodyData) {
 3553|      0|        _bodyLength = (int64_t)_bodyData.length;
 3554|      0|      } else if (_bodyFileURL) {
 3555|      0|        NSNumber *fileSizeNum = nil;
 3556|      0|        NSError *fileSizeError = nil;
 3557|      0|        if ([_bodyFileURL getResourceValue:&fileSizeNum
 3558|      0|                                    forKey:NSURLFileSizeKey
 3559|      0|                                     error:&fileSizeError]) {
 3560|      0|          _bodyLength = [fileSizeNum longLongValue];
 3561|      0|        }
 3562|      0|      }
 3563|      0|    }
 3564|      0|    return _bodyLength;
 3565|      0|  }  // @synchronized(self)
 3566|      0|}
 3567|       |
 3568|      1|- (BOOL)useUploadTask {
 3569|      1|  @synchronized(self) {
 3570|      1|    GTMSessionMonitorSynchronized(self);
 3571|      1|
 3572|      1|    return _useUploadTask;
 3573|      1|  }  // @synchronized(self)
 3574|      1|}
 3575|       |
 3576|      0|- (void)setUseUploadTask:(BOOL)flag {
 3577|      0|  @synchronized(self) {
 3578|      0|    GTMSessionMonitorSynchronized(self);
 3579|      0|
 3580|      0|    if (flag != _useUploadTask) {
 3581|      0|      GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3582|      0|                              @"useUploadTask should not change after beginFetch has been invoked");
 3583|      0|      _useUploadTask = flag;
 3584|      0|    }
 3585|      0|  }  // @synchronized(self)
 3586|      0|}
 3587|       |
 3588|      2|- (GTM_NULLABLE NSURL *)bodyFileURL {
 3589|      2|  @synchronized(self) {
 3590|      2|    GTMSessionMonitorSynchronized(self);
 3591|      2|
 3592|      2|    return _bodyFileURL;
 3593|      2|  }  // @synchronized(self)
 3594|      2|}
 3595|       |
 3596|      0|- (void)setBodyFileURL:(GTM_NULLABLE NSURL *)fileURL {
 3597|      0|  @synchronized(self) {
 3598|      0|    GTMSessionMonitorSynchronized(self);
 3599|      0|
 3600|      0|    // The comparison here is a trivial optimization and forgiveness for any client that
 3601|      0|    // repeatedly sets the property, so it just uses pointer comparison rather than isEqual:.
 3602|      0|    if (fileURL != _bodyFileURL) {
 3603|      0|      GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3604|      0|                              @"fileURL should not change after beginFetch has been invoked");
 3605|      0|
 3606|      0|      _bodyFileURL = fileURL;
 3607|      0|    }
 3608|      0|  }  // @synchronized(self)
 3609|      0|}
 3610|       |
 3611|      1|- (GTM_NULLABLE GTMSessionFetcherBodyStreamProvider)bodyStreamProvider {
 3612|      1|  @synchronized(self) {
 3613|      1|    GTMSessionMonitorSynchronized(self);
 3614|      1|
 3615|      1|    return _bodyStreamProvider;
 3616|      1|  }  // @synchronized(self)
 3617|      1|}
 3618|       |
 3619|      0|- (void)setBodyStreamProvider:(GTM_NULLABLE GTMSessionFetcherBodyStreamProvider)block {
 3620|      0|  @synchronized(self) {
 3621|      0|    GTMSessionMonitorSynchronized(self);
 3622|      0|
 3623|      0|    GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3624|      0|                            @"stream provider should not change after beginFetch has been invoked");
 3625|      0|
 3626|      0|    _bodyStreamProvider = [block copy];
 3627|      0|  }  // @synchronized(self)
 3628|      0|}
 3629|       |
 3630|      0|- (GTM_NULLABLE id<GTMFetcherAuthorizationProtocol>)authorizer {
 3631|      0|  @synchronized(self) {
 3632|      0|    GTMSessionMonitorSynchronized(self);
 3633|      0|
 3634|      0|    return _authorizer;
 3635|      0|  }  // @synchronized(self)
 3636|      0|}
 3637|       |
 3638|      1|- (void)setAuthorizer:(GTM_NULLABLE id<GTMFetcherAuthorizationProtocol>)authorizer {
 3639|      1|  @synchronized(self) {
 3640|      1|    GTMSessionMonitorSynchronized(self);
 3641|      1|
 3642|      1|    if (authorizer != _authorizer) {
 3643|      0|      if ([self isFetchingUnsynchronized]) {
 3644|      0|        GTMSESSION_ASSERT_DEBUG(0, @"authorizer should not change after beginFetch has been invoked");
 3645|      0|      } else {
 3646|      0|        _authorizer = authorizer;
 3647|      0|      }
 3648|      0|    }
 3649|      1|  }  // @synchronized(self)
 3650|      1|}
 3651|       |
 3652|      0|- (GTM_NULLABLE NSData *)downloadedData {
 3653|      0|  @synchronized(self) {
 3654|      0|    GTMSessionMonitorSynchronized(self);
 3655|      0|
 3656|      0|    return _downloadedData;
 3657|      0|  }  // @synchronized(self)
 3658|      0|}
 3659|       |
 3660|      2|- (void)setDownloadedData:(GTM_NULLABLE NSData *)data {
 3661|      2|  @synchronized(self) {
 3662|      2|    GTMSessionMonitorSynchronized(self);
 3663|      2|
 3664|      2|    _downloadedData = [data mutableCopy];
 3665|      2|  }  // @synchronized(self)
 3666|      2|}
 3667|       |
 3668|      0|- (int64_t)downloadedLength {
 3669|      0|  @synchronized(self) {
 3670|      0|    GTMSessionMonitorSynchronized(self);
 3671|      0|
 3672|      0|    return _downloadedLength;
 3673|      0|  }  // @synchronized(self)
 3674|      0|}
 3675|       |
 3676|      1|- (void)setDownloadedLength:(int64_t)length {
 3677|      1|  @synchronized(self) {
 3678|      1|    GTMSessionMonitorSynchronized(self);
 3679|      1|
 3680|      1|    _downloadedLength = length;
 3681|      1|  }  // @synchronized(self)
 3682|      1|}
 3683|       |
 3684|      0|- (dispatch_queue_t GTM_NONNULL_TYPE)callbackQueue {
 3685|      0|  @synchronized(self) {
 3686|      0|    GTMSessionMonitorSynchronized(self);
 3687|      0|
 3688|      0|    return _callbackQueue;
 3689|      0|  }  // @synchronized(self)
 3690|      0|}
 3691|       |
 3692|      1|- (void)setCallbackQueue:(dispatch_queue_t GTM_NULLABLE_TYPE)queue {
 3693|      1|  @synchronized(self) {
 3694|      1|    GTMSessionMonitorSynchronized(self);
 3695|      1|
 3696|      1|    _callbackQueue = queue ?: dispatch_get_main_queue();
 3697|      1|  }  // @synchronized(self)
 3698|      1|}
 3699|       |
 3700|      8|- (GTM_NULLABLE NSURLSession *)session {
 3701|      8|  @synchronized(self) {
 3702|      8|    GTMSessionMonitorSynchronized(self);
 3703|      8|
 3704|      8|    return _session;
 3705|      8|  }  // @synchronized(self)
 3706|      8|}
 3707|       |
 3708|      0|- (NSInteger)servicePriority {
 3709|      0|  @synchronized(self) {
 3710|      0|    GTMSessionMonitorSynchronized(self);
 3711|      0|
 3712|      0|    return _servicePriority;
 3713|      0|  }  // @synchronized(self)
 3714|      0|}
 3715|       |
 3716|      0|- (void)setServicePriority:(NSInteger)value {
 3717|      0|  @synchronized(self) {
 3718|      0|    GTMSessionMonitorSynchronized(self);
 3719|      0|
 3720|      0|    if (value != _servicePriority) {
 3721|      0|      GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3722|      0|        @"servicePriority should not change after beginFetch has been invoked");
 3723|      0|
 3724|      0|      _servicePriority = value;
 3725|      0|    }
 3726|      0|  }  // @synchronized(self)
 3727|      0|}
 3728|       |
 3729|       |
 3730|      2|- (void)setSession:(GTM_NULLABLE NSURLSession *)session {
 3731|      2|  @synchronized(self) {
 3732|      2|    GTMSessionMonitorSynchronized(self);
 3733|      2|
 3734|      2|    _session = session;
 3735|      2|  }  // @synchronized(self)
 3736|      2|}
 3737|       |
 3738|      2|- (BOOL)canShareSession {
 3739|      2|  @synchronized(self) {
 3740|      2|    GTMSessionMonitorSynchronized(self);
 3741|      2|
 3742|      2|    return _canShareSession;
 3743|      2|  }  // @synchronized(self)
 3744|      2|}
 3745|       |
 3746|      1|- (void)setCanShareSession:(BOOL)flag {
 3747|      1|  @synchronized(self) {
 3748|      1|    GTMSessionMonitorSynchronized(self);
 3749|      1|
 3750|      1|    _canShareSession = flag;
 3751|      1|  }  // @synchronized(self)
 3752|      1|}
 3753|       |
 3754|      2|- (BOOL)useBackgroundSession {
 3755|      2|  // This reflects if the user requested a background session, not necessarily
 3756|      2|  // if one was created. That is tracked with _usingBackgroundSession.
 3757|      2|  @synchronized(self) {
 3758|      2|    GTMSessionMonitorSynchronized(self);
 3759|      2|
 3760|      2|    return _userRequestedBackgroundSession;
 3761|      2|  }  // @synchronized(self)
 3762|      2|}
 3763|       |
 3764|      0|- (void)setUseBackgroundSession:(BOOL)flag {
 3765|      0|  @synchronized(self) {
 3766|      0|    GTMSessionMonitorSynchronized(self);
 3767|      0|
 3768|      0|    if (flag != _userRequestedBackgroundSession) {
 3769|      0|      GTMSESSION_ASSERT_DEBUG(![self isFetchingUnsynchronized],
 3770|      0|          @"useBackgroundSession should not change after beginFetch has been invoked");
 3771|      0|
 3772|      0|      _userRequestedBackgroundSession = flag;
 3773|      0|    }
 3774|      0|  }  // @synchronized(self)
 3775|      0|}
 3776|       |
 3777|      3|- (BOOL)isUsingBackgroundSession {
 3778|      3|  @synchronized(self) {
 3779|      3|    GTMSessionMonitorSynchronized(self);
 3780|      3|
 3781|      3|    return _usingBackgroundSession;
 3782|      3|  }  // @synchronized(self)
 3783|      3|}
 3784|       |
 3785|      1|- (void)setUsingBackgroundSession:(BOOL)flag {
 3786|      1|  @synchronized(self) {
 3787|      1|    GTMSessionMonitorSynchronized(self);
 3788|      1|
 3789|      1|    _usingBackgroundSession = flag;
 3790|      1|  }  // @synchronized(self)
 3791|      1|}
 3792|       |
 3793|      0|- (GTM_NULLABLE NSURLSession *)sessionNeedingInvalidation {
 3794|      0|  @synchronized(self) {
 3795|      0|    GTMSessionMonitorSynchronized(self);
 3796|      0|
 3797|      0|    return _sessionNeedingInvalidation;
 3798|      0|  }  // @synchronized(self)
 3799|      0|}
 3800|       |
 3801|      0|- (void)setSessionNeedingInvalidation:(GTM_NULLABLE NSURLSession *)session {
 3802|      0|  @synchronized(self) {
 3803|      0|    GTMSessionMonitorSynchronized(self);
 3804|      0|
 3805|      0|    _sessionNeedingInvalidation = session;
 3806|      0|  }  // @synchronized(self)
 3807|      0|}
 3808|       |
 3809|      1|- (NSOperationQueue * GTM_NONNULL_TYPE)sessionDelegateQueue {
 3810|      1|  @synchronized(self) {
 3811|      1|    GTMSessionMonitorSynchronized(self);
 3812|      1|
 3813|      1|    return _delegateQueue;
 3814|      1|  }  // @synchronized(self)
 3815|      1|}
 3816|       |
 3817|      1|- (void)setSessionDelegateQueue:(NSOperationQueue * GTM_NULLABLE_TYPE)queue {
 3818|      1|  @synchronized(self) {
 3819|      1|    GTMSessionMonitorSynchronized(self);
 3820|      1|
 3821|      1|    if (queue != _delegateQueue) {
 3822|      1|      if ([self isFetchingUnsynchronized]) {
 3823|      0|        GTMSESSION_ASSERT_DEBUG(0, @"sessionDelegateQueue should not change after fetch begins");
 3824|      1|      } else {
 3825|      1|        _delegateQueue = queue ?: [NSOperationQueue mainQueue];
 3826|      1|      }
 3827|      1|    }
 3828|      1|  }  // @synchronized(self)
 3829|      1|}
 3830|       |
 3831|      0|- (BOOL)userStoppedFetching {
 3832|      0|  @synchronized(self) {
 3833|      0|    GTMSessionMonitorSynchronized(self);
 3834|      0|
 3835|      0|    return _userStoppedFetching;
 3836|      0|  }  // @synchronized(self)
 3837|      0|}
 3838|       |
 3839|      0|- (GTM_NULLABLE id)userData {
 3840|      0|  @synchronized(self) {
 3841|      0|    GTMSessionMonitorSynchronized(self);
 3842|      0|
 3843|      0|    return _userData;
 3844|      0|  }  // @synchronized(self)
 3845|      0|}
 3846|       |
 3847|      0|- (void)setUserData:(GTM_NULLABLE id)theObj {
 3848|      0|  @synchronized(self) {
 3849|      0|    GTMSessionMonitorSynchronized(self);
 3850|      0|
 3851|      0|    _userData = theObj;
 3852|      0|  }  // @synchronized(self)
 3853|      0|}
 3854|       |
 3855|      0|- (GTM_NULLABLE NSURL *)destinationFileURL {
 3856|      0|  @synchronized(self) {
 3857|      0|    GTMSessionMonitorSynchronized(self);
 3858|      0|
 3859|      0|    return _destinationFileURL;
 3860|      0|  }  // @synchronized(self)
 3861|      0|}
 3862|       |
 3863|      0|- (void)setDestinationFileURL:(GTM_NULLABLE NSURL *)destinationFileURL {
 3864|      0|  @synchronized(self) {
 3865|      0|    GTMSessionMonitorSynchronized(self);
 3866|      0|
 3867|      0|    if (((_destinationFileURL == nil) && (destinationFileURL == nil)) ||
 3868|      0|        [_destinationFileURL isEqual:destinationFileURL]) {
 3869|      0|      return;
 3870|      0|    }
 3871|      0|    if (_sessionIdentifier) {
 3872|      0|      // This is something we don't expect to happen in production.
 3873|      0|      // However if it ever happen, leave a system log.
 3874|      0|      NSLog(@"%@: Destination File URL changed from (%@) to (%@) after session identifier has "
 3875|      0|            @"been created.",
 3876|      0|            [self class], _destinationFileURL, destinationFileURL);
 3877|      0|#if DEBUG
 3878|      0|      // On both the simulator and devices, the path can change to the download file, but the name
 3879|      0|      // shouldn't change. Technically, this isn't supported in the fetcher, but the change of
 3880|      0|      // URL is expected to happen only across development runs through Xcode.
 3881|      0|      NSString *oldFilename = [_destinationFileURL lastPathComponent];
 3882|      0|      NSString *newFilename = [destinationFileURL lastPathComponent];
 3883|      0|      #pragma unused(oldFilename)
 3884|      0|      #pragma unused(newFilename)
 3885|      0|      GTMSESSION_ASSERT_DEBUG([oldFilename isEqualToString:newFilename],
 3886|      0|          @"Destination File URL cannot be changed after session identifier has been created");
 3887|      0|#endif
 3888|      0|    }
 3889|      0|    _destinationFileURL = destinationFileURL;
 3890|      0|  }  // @synchronized(self)
 3891|      0|}
 3892|       |
 3893|      1|- (void)setProperties:(GTM_NULLABLE NSDictionary *)dict {
 3894|      1|  @synchronized(self) {
 3895|      1|    GTMSessionMonitorSynchronized(self);
 3896|      1|
 3897|      1|    _properties = [dict mutableCopy];
 3898|      1|  }  // @synchronized(self)
 3899|      1|}
 3900|       |
 3901|      0|- (GTM_NULLABLE NSDictionary *)properties {
 3902|      0|  @synchronized(self) {
 3903|      0|    GTMSessionMonitorSynchronized(self);
 3904|      0|
 3905|      0|    return _properties;
 3906|      0|  }  // @synchronized(self)
 3907|      0|}
 3908|       |
 3909|      0|- (void)setProperty:(GTM_NULLABLE id)obj forKey:(NSString *)key {
 3910|      0|  @synchronized(self) {
 3911|      0|    GTMSessionMonitorSynchronized(self);
 3912|      0|
 3913|      0|    if (_properties == nil && obj != nil) {
 3914|      0|      _properties = [[NSMutableDictionary alloc] init];
 3915|      0|    }
 3916|      0|    [_properties setValue:obj forKey:key];
 3917|      0|  }  // @synchronized(self)
 3918|      0|}
 3919|       |
 3920|      0|- (GTM_NULLABLE id)propertyForKey:(NSString *)key {
 3921|      0|  @synchronized(self) {
 3922|      0|    GTMSessionMonitorSynchronized(self);
 3923|      0|
 3924|      0|    return [_properties objectForKey:key];
 3925|      0|  }  // @synchronized(self)
 3926|      0|}
 3927|       |
 3928|      0|- (void)addPropertiesFromDictionary:(NSDictionary *)dict {
 3929|      0|  @synchronized(self) {
 3930|      0|    GTMSessionMonitorSynchronized(self);
 3931|      0|
 3932|      0|    if (_properties == nil && dict != nil) {
 3933|      0|      [self setProperties:[dict mutableCopy]];
 3934|      0|    } else {
 3935|      0|      [_properties addEntriesFromDictionary:dict];
 3936|      0|    }
 3937|      0|  }  // @synchronized(self)
 3938|      0|}
 3939|       |
 3940|      0|- (void)setCommentWithFormat:(id)format, ... {
 3941|      0|#if !STRIP_GTM_FETCH_LOGGING
 3942|      0|  NSString *result = format;
 3943|      0|  if (format) {
 3944|      0|    va_list argList;
 3945|      0|    va_start(argList, format);
 3946|      0|
 3947|      0|    result = [[NSString alloc] initWithFormat:format
 3948|      0|                                    arguments:argList];
 3949|      0|    va_end(argList);
 3950|      0|  }
 3951|      0|  [self setComment:result];
 3952|      0|#endif
 3953|      0|}
 3954|       |
 3955|       |#if !STRIP_GTM_FETCH_LOGGING
 3956|      0|- (NSData *)loggedStreamData {
 3957|      0|  return _loggedStreamData;
 3958|      0|}
 3959|       |
 3960|      0|- (void)appendLoggedStreamData:dataToAdd {
 3961|      0|  if (!_loggedStreamData) {
 3962|      0|    _loggedStreamData = [NSMutableData data];
 3963|      0|  }
 3964|      0|  [_loggedStreamData appendData:dataToAdd];
 3965|      0|}
 3966|       |
 3967|      0|- (void)clearLoggedStreamData {
 3968|      0|  _loggedStreamData = nil;
 3969|      0|}
 3970|       |
 3971|      0|- (void)setDeferResponseBodyLogging:(BOOL)deferResponseBodyLogging {
 3972|      0|  @synchronized(self) {
 3973|      0|    GTMSessionMonitorSynchronized(self);
 3974|      0|
 3975|      0|    if (deferResponseBodyLogging != _deferResponseBodyLogging) {
 3976|      0|      _deferResponseBodyLogging = deferResponseBodyLogging;
 3977|      0|      if (!deferResponseBodyLogging && !self.hasLoggedError) {
 3978|      0|        [_delegateQueue addOperationWithBlock:^{
 3979|      0|          [self logNowWithError:nil];
 3980|      0|        }];
 3981|      0|      }
 3982|      0|    }
 3983|      0|  }  // @synchronized(self)
 3984|      0|}
 3985|       |
 3986|      0|- (BOOL)deferResponseBodyLogging {
 3987|      0|  @synchronized(self) {
 3988|      0|    GTMSessionMonitorSynchronized(self);
 3989|      0|
 3990|      0|    return _deferResponseBodyLogging;
 3991|      0|  }  // @synchronized(self)
 3992|      0|}
 3993|       |
 3994|       |#else
 3995|       |+ (void)setLoggingEnabled:(BOOL)flag {
 3996|       |}
 3997|       |
 3998|       |+ (BOOL)isLoggingEnabled {
 3999|       |  return NO;
 4000|       |}
 4001|       |#endif // STRIP_GTM_FETCH_LOGGING
 4002|       |
 4003|       |@end
 4004|       |
 4005|       |@implementation GTMSessionFetcher (BackwardsCompatibilityOnly)
 4006|       |
 4007|      0|- (void)setCookieStorageMethod:(NSInteger)method {
 4008|      0|  // For backwards compatibility with the old fetcher, we'll support the old constants.
 4009|      0|  //
 4010|      0|  // Clients using the GTMSessionFetcher class should set the cookie storage explicitly
 4011|      0|  // themselves.
 4012|      0|  NSHTTPCookieStorage *storage = nil;
 4013|      0|  switch(method) {
 4014|      0|    case 0:  // kGTMHTTPFetcherCookieStorageMethodStatic
 4015|      0|             // nil storage will use [[self class] staticCookieStorage] when the fetch begins.
 4016|      0|      break;
 4017|      0|    case 1:  // kGTMHTTPFetcherCookieStorageMethodFetchHistory
 4018|      0|             // Do nothing; use whatever was set by the fetcher service.
 4019|      0|      return;
 4020|      0|    case 2:  // kGTMHTTPFetcherCookieStorageMethodSystemDefault
 4021|      0|      storage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
 4022|      0|      break;
 4023|      0|    case 3:  // kGTMHTTPFetcherCookieStorageMethodNone
 4024|      0|             // Create temporary storage for this fetcher only.
 4025|      0|      storage = [[GTMSessionCookieStorage alloc] init];
 4026|      0|      break;
 4027|      0|    default:
 4028|      0|      GTMSESSION_ASSERT_DEBUG(0, @"Invalid cookie storage method: %d", (int)method);
 4029|      0|  }
 4030|      0|  self.cookieStorage = storage;
 4031|      0|}
 4032|       |
 4033|       |@end
 4034|       |
 4035|       |@implementation GTMSessionCookieStorage {
 4036|       |  NSMutableArray *_cookies;
 4037|       |  NSHTTPCookieAcceptPolicy _policy;
 4038|       |}
 4039|       |
 4040|      1|- (id)init {
 4041|      1|  self = [super init];
 4042|      1|  if (self != nil) {
 4043|      1|    _cookies = [[NSMutableArray alloc] init];
 4044|      1|  }
 4045|      1|  return self;
 4046|      1|}
 4047|       |
 4048|      0|- (GTM_NULLABLE NSArray *)cookies {
 4049|      0|  @synchronized(self) {
 4050|      0|    GTMSessionMonitorSynchronized(self);
 4051|      0|
 4052|      0|    return [_cookies copy];
 4053|      0|  }  // @synchronized(self)
 4054|      0|}
 4055|       |
 4056|      0|- (void)setCookie:(NSHTTPCookie *)cookie {
 4057|      0|  if (!cookie) return;
 4058|      0|  if (_policy == NSHTTPCookieAcceptPolicyNever) return;
 4059|      0|
 4060|      0|  @synchronized(self) {
 4061|      0|    GTMSessionMonitorSynchronized(self);
 4062|      0|
 4063|      0|    [self internalSetCookie:cookie];
 4064|      0|  }  // @synchronized(self)
 4065|      0|}
 4066|       |
 4067|       |// Note: this should only be called from inside a @synchronized(self) block.
 4068|      0|- (void)internalSetCookie:(NSHTTPCookie *)newCookie {
 4069|      0|  GTMSessionCheckSynchronized(self);
 4070|      0|
 4071|      0|  if (_policy == NSHTTPCookieAcceptPolicyNever) return;
 4072|      0|
 4073|      0|  BOOL isValidCookie = (newCookie.name.length > 0
 4074|      0|                        && newCookie.domain.length > 0
 4075|      0|                        && newCookie.path.length > 0);
 4076|      0|  GTMSESSION_ASSERT_DEBUG(isValidCookie, @"invalid cookie: %@", newCookie);
 4077|      0|
 4078|      0|  if (isValidCookie) {
 4079|      0|    // Remove the cookie if it's currently in the array.
 4080|      0|    NSHTTPCookie *oldCookie = [self cookieMatchingCookie:newCookie];
 4081|      0|    if (oldCookie) {
 4082|      0|      [_cookies removeObjectIdenticalTo:oldCookie];
 4083|      0|    }
 4084|      0|
 4085|      0|    if (![[self class] hasCookieExpired:newCookie]) {
 4086|      0|      [_cookies addObject:newCookie];
 4087|      0|    }
 4088|      0|  }
 4089|      0|}
 4090|       |
 4091|       |// Add all cookies in the new cookie array to the storage,
 4092|       |// replacing stored cookies as appropriate.
 4093|       |//
 4094|       |// Side effect: removes expired cookies from the storage array.
 4095|      0|- (void)setCookies:(GTM_NULLABLE NSArray *)newCookies {
 4096|      0|  @synchronized(self) {
 4097|      0|    GTMSessionMonitorSynchronized(self);
 4098|      0|
 4099|      0|    [self removeExpiredCookies];
 4100|      0|
 4101|      0|    for (NSHTTPCookie *newCookie in newCookies) {
 4102|      0|      [self internalSetCookie:newCookie];
 4103|      0|    }
 4104|      0|  }  // @synchronized(self)
 4105|      0|}
 4106|       |
 4107|      0|- (void)setCookies:(NSArray *)cookies forURL:(GTM_NULLABLE NSURL *)URL mainDocumentURL:(GTM_NULLABLE NSURL *)mainDocumentURL {
 4108|      0|  @synchronized(self) {
 4109|      0|    GTMSessionMonitorSynchronized(self);
 4110|      0|
 4111|      0|    if (_policy == NSHTTPCookieAcceptPolicyNever) {
 4112|      0|      return;
 4113|      0|    }
 4114|      0|
 4115|      0|    if (_policy == NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain) {
 4116|      0|      NSString *mainHost = mainDocumentURL.host;
 4117|      0|      NSString *associatedHost = URL.host;
 4118|      0|      if (!mainHost || ![associatedHost hasSuffix:mainHost]) {
 4119|      0|        return;
 4120|      0|      }
 4121|      0|    }
 4122|      0|  }  // @synchronized(self)
 4123|      0|  [self setCookies:cookies];
 4124|      0|}
 4125|       |
 4126|      0|- (void)deleteCookie:(NSHTTPCookie *)cookie {
 4127|      0|  if (!cookie) return;
 4128|      0|
 4129|      0|  @synchronized(self) {
 4130|      0|    GTMSessionMonitorSynchronized(self);
 4131|      0|
 4132|      0|    NSHTTPCookie *foundCookie = [self cookieMatchingCookie:cookie];
 4133|      0|    if (foundCookie) {
 4134|      0|      [_cookies removeObjectIdenticalTo:foundCookie];
 4135|      0|    }
 4136|      0|  }  // @synchronized(self)
 4137|      0|}
 4138|       |
 4139|       |// Retrieve all cookies appropriate for the given URL, considering
 4140|       |// domain, path, cookie name, expiration, security setting.
 4141|       |// Side effect: removed expired cookies from the storage array.
 4142|      1|- (GTM_NULLABLE NSArray *)cookiesForURL:(NSURL *)theURL {
 4143|      1|  NSMutableArray *foundCookies = nil;
 4144|      1|
 4145|      1|  @synchronized(self) {
 4146|      1|    GTMSessionMonitorSynchronized(self);
 4147|      1|
 4148|      1|    [self removeExpiredCookies];
 4149|      1|
 4150|      1|    // We'll prepend "." to the desired domain, since we want the
 4151|      1|    // actual domain "nytimes.com" to still match the cookie domain
 4152|      1|    // ".nytimes.com" when we check it below with hasSuffix.
 4153|      1|    NSString *host = theURL.host.lowercaseString;
 4154|      1|    NSString *path = theURL.path;
 4155|      1|    NSString *scheme = [theURL scheme];
 4156|      1|
 4157|      1|    NSString *requestingDomain = nil;
 4158|      1|    BOOL isLocalhostRetrieval = NO;
 4159|      1|
 4160|      1|    if (IsLocalhost(host)) {
 4161|      0|      isLocalhostRetrieval = YES;
 4162|      1|    } else {
 4163|      1|      if (host.length > 0) {
 4164|      1|        requestingDomain = [@"." stringByAppendingString:host];
 4165|      1|      }
 4166|      1|    }
 4167|      1|
 4168|      1|    for (NSHTTPCookie *storedCookie in _cookies) {
 4169|      0|      NSString *cookieDomain = storedCookie.domain.lowercaseString;
 4170|      0|      NSString *cookiePath = storedCookie.path;
 4171|      0|      BOOL cookieIsSecure = [storedCookie isSecure];
 4172|      0|
 4173|      0|      BOOL isDomainOK;
 4174|      0|
 4175|      0|      if (isLocalhostRetrieval) {
 4176|      0|        // Prior to 10.5.6, the domain stored into NSHTTPCookies for localhost
 4177|      0|        // is "localhost.local"
 4178|      0|        isDomainOK = (IsLocalhost(cookieDomain)
 4179|      0|                      || [cookieDomain isEqual:@"localhost.local"]);
 4180|      0|      } else {
 4181|      0|        // Ensure we're matching exact domain names. We prepended a dot to the
 4182|      0|        // requesting domain, so we can also prepend one here if needed before
 4183|      0|        // checking if the request contains the cookie domain.
 4184|      0|        if (![cookieDomain hasPrefix:@"."]) {
 4185|      0|          cookieDomain = [@"." stringByAppendingString:cookieDomain];
 4186|      0|        }
 4187|      0|        isDomainOK = [requestingDomain hasSuffix:cookieDomain];
 4188|      0|      }
 4189|      0|
 4190|      0|      BOOL isPathOK = [cookiePath isEqual:@"/"] || [path hasPrefix:cookiePath];
 4191|      0|      BOOL isSecureOK = (!cookieIsSecure
 4192|      0|                         || [scheme caseInsensitiveCompare:@"https"] == NSOrderedSame);
 4193|      0|
 4194|      0|      if (isDomainOK && isPathOK && isSecureOK) {
 4195|      0|        if (foundCookies == nil) {
 4196|      0|          foundCookies = [NSMutableArray array];
 4197|      0|        }
 4198|      0|        [foundCookies addObject:storedCookie];
 4199|      0|      }
 4200|      0|    }
 4201|      1|  }  // @synchronized(self)
 4202|      1|  return foundCookies;
 4203|      1|}
 4204|       |
 4205|       |// Override methods from the NSHTTPCookieStorage (NSURLSessionTaskAdditions) category.
 4206|      0|- (void)storeCookies:(NSArray *)cookies forTask:(NSURLSessionTask *)task {
 4207|      0|  NSURLRequest *currentRequest = task.currentRequest;
 4208|      0|  [self setCookies:cookies forURL:currentRequest.URL mainDocumentURL:nil];
 4209|      0|}
 4210|       |
 4211|       |- (void)getCookiesForTask:(NSURLSessionTask *)task
 4212|      1|        completionHandler:(void (^)(GTM_NSArrayOf(NSHTTPCookie *) *))completionHandler {
 4213|      1|  if (completionHandler) {
 4214|      1|    NSURLRequest *currentRequest = task.currentRequest;
 4215|      1|    NSURL *currentRequestURL = currentRequest.URL;
 4216|      1|    NSArray *cookies = [self cookiesForURL:currentRequestURL];
 4217|      1|    completionHandler(cookies);
 4218|      1|  }
 4219|      1|}
 4220|       |
 4221|       |// Return a cookie from the array with the same name, domain, and path as the
 4222|       |// given cookie, or else return nil if none found.
 4223|       |//
 4224|       |// Both the cookie being tested and all cookies in the storage array should
 4225|       |// be valid (non-nil name, domains, paths).
 4226|       |//
 4227|       |// Note: this should only be called from inside a @synchronized(self) block
 4228|      0|- (GTM_NULLABLE NSHTTPCookie *)cookieMatchingCookie:(NSHTTPCookie *)cookie {
 4229|      0|  GTMSessionCheckSynchronized(self);
 4230|      0|
 4231|      0|  NSString *name = cookie.name;
 4232|      0|  NSString *domain = cookie.domain;
 4233|      0|  NSString *path = cookie.path;
 4234|      0|
 4235|      0|  GTMSESSION_ASSERT_DEBUG(name && domain && path,
 4236|      0|                          @"Invalid stored cookie (name:%@ domain:%@ path:%@)", name, domain, path);
 4237|      0|
 4238|      0|  for (NSHTTPCookie *storedCookie in _cookies) {
 4239|      0|    if ([storedCookie.name isEqual:name]
 4240|      0|        && [storedCookie.domain isEqual:domain]
 4241|      0|        && [storedCookie.path isEqual:path]) {
 4242|      0|      return storedCookie;
 4243|      0|    }
 4244|      0|  }
 4245|      0|  return nil;
 4246|      0|}
 4247|       |
 4248|       |// Internal routine to remove any expired cookies from the array, excluding
 4249|       |// cookies with nil expirations.
 4250|       |//
 4251|       |// Note: this should only be called from inside a @synchronized(self) block
 4252|      1|- (void)removeExpiredCookies {
 4253|      1|  GTMSessionCheckSynchronized(self);
 4254|      1|
 4255|      1|  // Count backwards since we're deleting items from the array
 4256|      1|  for (NSInteger idx = (NSInteger)_cookies.count - 1; idx >= 0; idx--) {
 4257|      0|    NSHTTPCookie *storedCookie = [_cookies objectAtIndex:(NSUInteger)idx];
 4258|      0|    if ([[self class] hasCookieExpired:storedCookie]) {
 4259|      0|      [_cookies removeObjectAtIndex:(NSUInteger)idx];
 4260|      0|    }
 4261|      0|  }
 4262|      1|}
 4263|       |
 4264|      0|+ (BOOL)hasCookieExpired:(NSHTTPCookie *)cookie {
 4265|      0|  NSDate *expiresDate = [cookie expiresDate];
 4266|      0|  if (expiresDate == nil) {
 4267|      0|    // Cookies seem to have a Expires property even when the expiresDate method returns nil.
 4268|      0|    id expiresVal = [[cookie properties] objectForKey:NSHTTPCookieExpires];
 4269|      0|    if ([expiresVal isKindOfClass:[NSDate class]]) {
 4270|      0|      expiresDate = expiresVal;
 4271|      0|    }
 4272|      0|  }
 4273|      0|  BOOL hasExpired = (expiresDate != nil && [expiresDate timeIntervalSinceNow] < 0);
 4274|      0|  return hasExpired;
 4275|      0|}
 4276|       |
 4277|      0|- (void)removeAllCookies {
 4278|      0|  @synchronized(self) {
 4279|      0|    GTMSessionMonitorSynchronized(self);
 4280|      0|
 4281|      0|    [_cookies removeAllObjects];
 4282|      0|  }  // @synchronized(self)
 4283|      0|}
 4284|       |
 4285|      0|- (NSHTTPCookieAcceptPolicy)cookieAcceptPolicy {
 4286|      0|  @synchronized(self) {
 4287|      0|    GTMSessionMonitorSynchronized(self);
 4288|      0|
 4289|      0|    return _policy;
 4290|      0|  }  // @synchronized(self)
 4291|      0|}
 4292|       |
 4293|      0|- (void)setCookieAcceptPolicy:(NSHTTPCookieAcceptPolicy)cookieAcceptPolicy {
 4294|      0|  @synchronized(self) {
 4295|      0|    GTMSessionMonitorSynchronized(self);
 4296|      0|
 4297|      0|    _policy = cookieAcceptPolicy;
 4298|      0|  }  // @synchronized(self)
 4299|      0|}
 4300|       |
 4301|       |@end
 4302|       |
 4303|      0|void GTMSessionFetcherAssertValidSelector(id GTM_NULLABLE_TYPE obj, SEL GTM_NULLABLE_TYPE sel, ...) {
 4304|      0|  // Verify that the object's selector is implemented with the proper
 4305|      0|  // number and type of arguments
 4306|      0|#if DEBUG
 4307|      0|  va_list argList;
 4308|      0|  va_start(argList, sel);
 4309|      0|
 4310|      0|  if (obj && sel) {
 4311|      0|    // Check that the selector is implemented
 4312|      0|    if (![obj respondsToSelector:sel]) {
 4313|      0|      NSLog(@"\"%@\" selector \"%@\" is unimplemented or misnamed",
 4314|      0|                             NSStringFromClass([(id)obj class]),
 4315|      0|                             NSStringFromSelector((SEL)sel));
 4316|      0|      NSCAssert(0, @"callback selector unimplemented or misnamed");
 4317|      0|    } else {
 4318|      0|      const char *expectedArgType;
 4319|      0|      unsigned int argCount = 2; // skip self and _cmd
 4320|      0|      NSMethodSignature *sig = [obj methodSignatureForSelector:sel];
 4321|      0|
 4322|      0|      // Check that each expected argument is present and of the correct type
 4323|      0|      while ((expectedArgType = va_arg(argList, const char*)) != 0) {
 4324|      0|
 4325|      0|        if ([sig numberOfArguments] > argCount) {
 4326|      0|          const char *foundArgType = [sig getArgumentTypeAtIndex:argCount];
 4327|      0|
 4328|      0|          if (0 != strncmp(foundArgType, expectedArgType, strlen(expectedArgType))) {
 4329|      0|            NSLog(@"\"%@\" selector \"%@\" argument %d should be type %s",
 4330|      0|                  NSStringFromClass([(id)obj class]),
 4331|      0|                  NSStringFromSelector((SEL)sel), (argCount - 2), expectedArgType);
 4332|      0|            NSCAssert(0, @"callback selector argument type mistake");
 4333|      0|          }
 4334|      0|        }
 4335|      0|        argCount++;
 4336|      0|      }
 4337|      0|
 4338|      0|      // Check that the proper number of arguments are present in the selector
 4339|      0|      if (argCount != [sig numberOfArguments]) {
 4340|      0|        NSLog(@"\"%@\" selector \"%@\" should have %d arguments",
 4341|      0|              NSStringFromClass([(id)obj class]),
 4342|      0|              NSStringFromSelector((SEL)sel), (argCount - 2));
 4343|      0|        NSCAssert(0, @"callback selector arguments incorrect");
 4344|      0|      }
 4345|      0|    }
 4346|      0|  }
 4347|      0|
 4348|      0|  va_end(argList);
 4349|      0|#endif
 4350|      0|}
 4351|       |
 4352|      3|NSString *GTMFetcherCleanedUserAgentString(NSString *str) {
 4353|      3|  // Reference http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html
 4354|      3|  // and http://www-archive.mozilla.org/build/user-agent-strings.html
 4355|      3|
 4356|      3|  if (str == nil) return @"";
 4357|      3|
 4358|      3|  NSMutableString *result = [NSMutableString stringWithString:str];
 4359|      3|
 4360|      3|  // Replace spaces and commas with underscores
 4361|      3|  [result replaceOccurrencesOfString:@" "
 4362|      3|                          withString:@"_"
 4363|      3|                             options:0
 4364|      3|                               range:NSMakeRange(0, result.length)];
 4365|      3|  [result replaceOccurrencesOfString:@","
 4366|      3|                          withString:@"_"
 4367|      3|                             options:0
 4368|      3|                               range:NSMakeRange(0, result.length)];
 4369|      3|
 4370|      3|  // Delete http token separators and remaining whitespace
 4371|      3|  static NSCharacterSet *charsToDelete = nil;
 4372|      3|  if (charsToDelete == nil) {
 4373|      1|    // Make a set of unwanted characters
 4374|      1|    NSString *const kSeparators = @"()<>@;:\\\"/[]?={}";
 4375|      1|
 4376|      1|    NSMutableCharacterSet *mutableChars =
 4377|      1|        [[NSCharacterSet whitespaceAndNewlineCharacterSet] mutableCopy];
 4378|      1|    [mutableChars addCharactersInString:kSeparators];
 4379|      1|    charsToDelete = [mutableChars copy]; // hang on to an immutable copy
 4380|      1|  }
 4381|      3|
 4382|      3|  while (1) {
 4383|      3|    NSRange separatorRange = [result rangeOfCharacterFromSet:charsToDelete];
 4384|      3|    if (separatorRange.location == NSNotFound) break;
 4385|      0|
 4386|      0|    [result deleteCharactersInRange:separatorRange];
 4387|      0|  };
 4388|      3|
 4389|      3|  return result;
 4390|      3|}
 4391|       |
 4392|      2|NSString *GTMFetcherSystemVersionString(void) {
 4393|      2|  static NSString *sSavedSystemString;
 4394|      2|
 4395|      2|  static dispatch_once_t onceToken;
 4396|      2|  dispatch_once(&onceToken, ^{
 4397|      1|    // The Xcode 8 SDKs finally cleaned up this mess by providing TARGET_OS_OSX
 4398|      1|    // and TARGET_OS_IOS, but to build with older SDKs, those don't exist and
 4399|      1|    // instead one has to rely on TARGET_OS_MAC (which is true for iOS, watchOS,
 4400|      1|    // and tvOS) and TARGET_OS_IPHONE (which is true for iOS, watchOS, tvOS). So
 4401|      1|    // one has to order these carefully so you pick off the specific things
 4402|      1|    // first.
 4403|      1|    // If the code can ever assume Xcode 8 or higher (even when building for
 4404|      1|    // older OSes), then
 4405|      1|    //   TARGET_OS_MAC -> TARGET_OS_OSX
 4406|      1|    //   TARGET_OS_IPHONE -> TARGET_OS_IOS
 4407|      1|    //   TARGET_IPHONE_SIMULATOR -> TARGET_OS_SIMULATOR
 4408|       |#if TARGET_OS_WATCH
 4409|       |    // watchOS - WKInterfaceDevice
 4410|       |
 4411|       |    WKInterfaceDevice *currentDevice = [WKInterfaceDevice currentDevice];
 4412|       |
 4413|       |    NSString *rawModel = [currentDevice model];
 4414|       |    NSString *model = GTMFetcherCleanedUserAgentString(rawModel);
 4415|       |
 4416|       |    NSString *systemVersion = [currentDevice systemVersion];
 4417|       |
 4418|       |#if TARGET_OS_SIMULATOR
 4419|       |    NSString *hardwareModel = @"sim";
 4420|       |#else
 4421|       |    NSString *hardwareModel;
 4422|       |    struct utsname unameRecord;
 4423|       |    if (uname(&unameRecord) == 0) {
 4424|       |      NSString *machineName = @(unameRecord.machine);
 4425|       |      hardwareModel = GTMFetcherCleanedUserAgentString(machineName);
 4426|       |    }
 4427|       |    if (hardwareModel.length == 0) {
 4428|       |      hardwareModel = @"unk";
 4429|       |    }
 4430|       |#endif
 4431|       |
 4432|       |    sSavedSystemString = [[NSString alloc] initWithFormat:@"%@/%@ hw/%@",
 4433|       |                          model, systemVersion, hardwareModel];
 4434|       |    // Example:  Apple_Watch/3.0 hw/Watch1_2
 4435|       |#elif TARGET_OS_TV || TARGET_OS_IPHONE
 4436|       |    // iOS and tvOS have UIDevice, use that.
 4437|      1|    UIDevice *currentDevice = [UIDevice currentDevice];
 4438|      1|
 4439|      1|    NSString *rawModel = [currentDevice model];
 4440|      1|    NSString *model = GTMFetcherCleanedUserAgentString(rawModel);
 4441|      1|
 4442|      1|    NSString *systemVersion = [currentDevice systemVersion];
 4443|      1|
 4444|      1|#if TARGET_IPHONE_SIMULATOR || TARGET_OS_SIMULATOR
 4445|      1|    NSString *hardwareModel = @"sim";
 4446|       |#else
 4447|       |    NSString *hardwareModel;
 4448|       |    struct utsname unameRecord;
 4449|       |    if (uname(&unameRecord) == 0) {
 4450|       |      NSString *machineName = @(unameRecord.machine);
 4451|       |      hardwareModel = GTMFetcherCleanedUserAgentString(machineName);
 4452|       |    }
 4453|       |    if (hardwareModel.length == 0) {
 4454|       |      hardwareModel = @"unk";
 4455|       |    }
 4456|       |#endif
 4457|       |
 4458|      1|    sSavedSystemString = [[NSString alloc] initWithFormat:@"%@/%@ hw/%@",
 4459|      1|                          model, systemVersion, hardwareModel];
 4460|      1|    // Example:  iPod_Touch/2.2 hw/iPod1_1
 4461|      1|    // Example:  Apple_TV/9.2 hw/AppleTV5,3
 4462|       |#elif TARGET_OS_MAC
 4463|       |    // Mac build
 4464|       |    NSProcessInfo *procInfo = [NSProcessInfo processInfo];
 4465|       |#if !defined(MAC_OS_X_VERSION_10_10)
 4466|       |    BOOL hasOperatingSystemVersion = NO;
 4467|       |#elif MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_10
 4468|       |    BOOL hasOperatingSystemVersion =
 4469|       |        [procInfo respondsToSelector:@selector(operatingSystemVersion)];
 4470|       |#else
 4471|       |    BOOL hasOperatingSystemVersion = YES;
 4472|       |#endif
 4473|       |    NSString *versString;
 4474|       |    if (hasOperatingSystemVersion) {
 4475|       |#if defined(MAC_OS_X_VERSION_10_10)
 4476|       |      // A reference to NSOperatingSystemVersion requires the 10.10 SDK.
 4477|       |#pragma clang diagnostic push
 4478|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
 4479|       |// Disable unguarded availability warning as we can't use the @availability macro until we require
 4480|       |// all clients to build with Xcode 9 or above.
 4481|       |      NSOperatingSystemVersion version = procInfo.operatingSystemVersion;
 4482|       |#pragma clang diagnostic pop
 4483|       |      versString = [NSString stringWithFormat:@"%ld.%ld.%ld",
 4484|       |                    (long)version.majorVersion, (long)version.minorVersion,
 4485|       |                    (long)version.patchVersion];
 4486|       |#else
 4487|       |#pragma unused(procInfo)
 4488|       |#endif
 4489|       |    } else {
 4490|       |      // With Gestalt inexplicably deprecated in 10.8, we're reduced to reading
 4491|       |      // the system plist file.
 4492|       |      NSString *const kPath = @"/System/Library/CoreServices/SystemVersion.plist";
 4493|       |      NSDictionary *plist = [NSDictionary dictionaryWithContentsOfFile:kPath];
 4494|       |      versString = [plist objectForKey:@"ProductVersion"];
 4495|       |      if (versString.length == 0) {
 4496|       |        versString = @"10.?.?";
 4497|       |      }
 4498|       |    }
 4499|       |
 4500|       |    sSavedSystemString = [[NSString alloc] initWithFormat:@"MacOSX/%@", versString];
 4501|       |#elif defined(_SYS_UTSNAME_H)
 4502|       |    // Foundation-only build
 4503|       |    struct utsname unameRecord;
 4504|       |    uname(&unameRecord);
 4505|       |
 4506|       |    sSavedSystemString = [NSString stringWithFormat:@"%s/%s",
 4507|       |                          unameRecord.sysname, unameRecord.release]; // "Darwin/8.11.1"
 4508|       |#else
 4509|       |#error No branch taken for a default user agent
 4510|       |#endif
 4511|       |  });
 4512|      2|  return sSavedSystemString;
 4513|      2|}
 4514|       |
 4515|      2|NSString *GTMFetcherStandardUserAgentString(NSBundle * GTM_NULLABLE_TYPE bundle) {
 4516|      2|  NSString *result = [NSString stringWithFormat:@"%@ %@",
 4517|      2|                      GTMFetcherApplicationIdentifier(bundle),
 4518|      2|                      GTMFetcherSystemVersionString()];
 4519|      2|  return result;
 4520|      2|}
 4521|       |
 4522|      2|NSString *GTMFetcherApplicationIdentifier(NSBundle * GTM_NULLABLE_TYPE bundle) {
 4523|      2|  @synchronized([GTMSessionFetcher class]) {
 4524|      2|    static NSMutableDictionary *sAppIDMap = nil;
 4525|      2|
 4526|      2|    // If there's a bundle ID, use that; otherwise, use the process name
 4527|      2|    if (bundle == nil) {
 4528|      2|      bundle = [NSBundle mainBundle];
 4529|      2|    }
 4530|      2|    NSString *bundleID = [bundle bundleIdentifier];
 4531|      2|    if (bundleID == nil) {
 4532|      0|      bundleID = @"";
 4533|      0|    }
 4534|      2|
 4535|      2|    NSString *identifier = [sAppIDMap objectForKey:bundleID];
 4536|      2|    if (identifier) return identifier;
 4537|      1|
 4538|      1|    // Apps may add a string to the info.plist to uniquely identify different builds.
 4539|      1|    identifier = [bundle objectForInfoDictionaryKey:@"GTMUserAgentID"];
 4540|      1|    if (identifier.length == 0) {
 4541|      1|      if (bundleID.length > 0) {
 4542|      1|        identifier = bundleID;
 4543|      1|      } else {
 4544|      0|        // Fall back on the procname, prefixed by "proc" to flag that it's
 4545|      0|        // autogenerated and perhaps unreliable
 4546|      0|        NSString *procName = [[NSProcessInfo processInfo] processName];
 4547|      0|        identifier = [NSString stringWithFormat:@"proc_%@", procName];
 4548|      0|      }
 4549|      1|    }
 4550|      1|
 4551|      1|    // Clean up whitespace and special characters
 4552|      1|    identifier = GTMFetcherCleanedUserAgentString(identifier);
 4553|      1|
 4554|      1|    // If there's a version number, append that
 4555|      1|    NSString *version = [bundle objectForInfoDictionaryKey:@"CFBundleShortVersionString"];
 4556|      1|    if (version.length == 0) {
 4557|      0|      version = [bundle objectForInfoDictionaryKey:@"CFBundleVersion"];
 4558|      0|    }
 4559|      1|
 4560|      1|    // Clean up whitespace and special characters
 4561|      1|    version = GTMFetcherCleanedUserAgentString(version);
 4562|      1|
 4563|      1|    // Glue the two together (cleanup done above or else cleanup would strip the
 4564|      1|    // slash)
 4565|      1|    if (version.length > 0) {
 4566|      1|      identifier = [identifier stringByAppendingFormat:@"/%@", version];
 4567|      1|    }
 4568|      1|
 4569|      1|    if (sAppIDMap == nil) {
 4570|      1|      sAppIDMap = [[NSMutableDictionary alloc] init];
 4571|      1|    }
 4572|      1|    [sAppIDMap setObject:identifier forKey:bundleID];
 4573|      1|    return identifier;
 4574|      1|  }
 4575|      1|}
 4576|       |
 4577|       |#if DEBUG && (!defined(NS_BLOCK_ASSERTIONS) || GTMSESSION_ASSERT_AS_LOG)
 4578|       |@implementation GTMSessionSyncMonitorInternal {
 4579|       |  NSValue *_objectKey;        // The synchronize target object.
 4580|       |  const char *_functionName;  // The function containing the monitored sync block.
 4581|       |}
 4582|       |
 4583|       |- (instancetype)initWithSynchronizationObject:(id)object
 4584|       |                               allowRecursive:(BOOL)allowRecursive
 4585|     56|                                 functionName:(const char *)functionName {
 4586|     56|  self = [super init];
 4587|     56|  if (self) {
 4588|     56|    Class threadKey = [GTMSessionSyncMonitorInternal class];
 4589|     56|    _objectKey = [NSValue valueWithNonretainedObject:object];
 4590|     56|    _functionName = functionName;
 4591|     56|
 4592|     56|    NSMutableDictionary *threadDict = [NSThread currentThread].threadDictionary;
 4593|     56|    NSMutableDictionary *counters = threadDict[threadKey];
 4594|     56|    if (counters == nil) {
 4595|      2|      counters = [NSMutableDictionary dictionary];
 4596|      2|      threadDict[(id)threadKey] = counters;
 4597|      2|    }
 4598|     56|    NSCountedSet *functionNamesCounter = counters[_objectKey];
 4599|     56|    NSUInteger numberOfSyncingFunctions = functionNamesCounter.count;
 4600|     56|
 4601|     56|    if (!allowRecursive) {
 4602|     56|      BOOL isTopLevelSyncScope = (numberOfSyncingFunctions == 0);
 4603|     56|      NSArray *stack = [NSThread callStackSymbols];
 4604|     56|      GTMSESSION_ASSERT_DEBUG(isTopLevelSyncScope,
 4605|     56|                              @"*** Recursive sync on %@ at %s; previous sync at %@\n%@",
 4606|     56|                              [object class], functionName, functionNamesCounter.allObjects,
 4607|     56|                              [stack subarrayWithRange:NSMakeRange(1, stack.count - 1)]);
 4608|     56|    }
 4609|     56|
 4610|     56|    if (!functionNamesCounter) {
 4611|     56|      functionNamesCounter = [NSCountedSet set];
 4612|     56|      counters[_objectKey] = functionNamesCounter;
 4613|     56|    }
 4614|     56|    [functionNamesCounter addObject:(id _Nonnull)@(functionName)];
 4615|     56|  }
 4616|     56|  return self;
 4617|     56|}
 4618|       |
 4619|     56|- (void)dealloc {
 4620|     56|  Class threadKey = [GTMSessionSyncMonitorInternal class];
 4621|     56|
 4622|     56|  NSMutableDictionary *threadDict = [NSThread currentThread].threadDictionary;
 4623|     56|  NSMutableDictionary *counters = threadDict[threadKey];
 4624|     56|  NSCountedSet *functionNamesCounter = counters[_objectKey];
 4625|     56|  NSString *functionNameStr = @(_functionName);
 4626|     56|  NSUInteger numberOfSyncsByThisFunction = [functionNamesCounter countForObject:functionNameStr];
 4627|     56|  NSArray *stack = [NSThread callStackSymbols];
 4628|     56|  GTMSESSION_ASSERT_DEBUG(numberOfSyncsByThisFunction > 0, @"Sync not found on %@ at %s\n%@",
 4629|     56|                          [_objectKey.nonretainedObjectValue class], _functionName,
 4630|     56|                          [stack subarrayWithRange:NSMakeRange(1, stack.count - 1)]);
 4631|     56|  [functionNamesCounter removeObject:functionNameStr];
 4632|     56|  if (functionNamesCounter.count == 0) {
 4633|     56|    [counters removeObjectForKey:_objectKey];
 4634|     56|  }
 4635|     56|}
 4636|       |
 4637|     10|+ (NSArray *)functionsHoldingSynchronizationOnObject:(id)object {
 4638|     10|  Class threadKey = [GTMSessionSyncMonitorInternal class];
 4639|     10|  NSValue *localObjectKey = [NSValue valueWithNonretainedObject:object];
 4640|     10|
 4641|     10|  NSMutableDictionary *threadDict = [NSThread currentThread].threadDictionary;
 4642|     10|  NSMutableDictionary *counters = threadDict[threadKey];
 4643|     10|  NSCountedSet *functionNamesCounter = counters[localObjectKey];
 4644|     10|  return functionNamesCounter.count > 0 ? functionNamesCounter.allObjects : nil;
 4645|     10|}
 4646|       |@end
 4647|       |#endif  // DEBUG && (!defined(NS_BLOCK_ASSERTIONS) || GTMSESSION_ASSERT_AS_LOG)
 4648|       |GTM_ASSUME_NONNULL_END

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GTMSessionFetcher/Source/GTMSessionFetcherLogging.m:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |#if !defined(__has_feature) || !__has_feature(objc_arc)
   17|       |#error "This file requires ARC support."
   18|       |#endif
   19|       |
   20|       |#include <sys/stat.h>
   21|       |#include <unistd.h>
   22|       |
   23|       |#import "GTMSessionFetcherLogging.h"
   24|       |
   25|       |#ifndef STRIP_GTM_FETCH_LOGGING
   26|       |  #error GTMSessionFetcher headers should have defaulted this if it wasn't already defined.
   27|       |#endif
   28|       |
   29|       |#if !STRIP_GTM_FETCH_LOGGING
   30|       |
   31|       |// Sensitive credential strings are replaced in logs with _snip_
   32|       |//
   33|       |// Apps that must see the contents of sensitive tokens can set this to 1
   34|       |#ifndef SKIP_GTM_FETCH_LOGGING_SNIPPING
   35|       |#define SKIP_GTM_FETCH_LOGGING_SNIPPING 0
   36|       |#endif
   37|       |
   38|       |// If GTMReadMonitorInputStream is available, it can be used for
   39|       |// capturing uploaded streams of data
   40|       |//
   41|       |// We locally declare methods of GTMReadMonitorInputStream so we
   42|       |// do not need to import the header, as some projects may not have it available
   43|       |#if !GTMSESSION_BUILD_COMBINED_SOURCES
   44|       |@interface GTMReadMonitorInputStream : NSInputStream
   45|       |
   46|       |+ (instancetype)inputStreamWithStream:(NSInputStream *)input;
   47|       |
   48|       |@property (assign) id readDelegate;
   49|       |@property (assign) SEL readSelector;
   50|       |
   51|       |@end
   52|       |#else
   53|       |@class GTMReadMonitorInputStream;
   54|       |#endif  // !GTMSESSION_BUILD_COMBINED_SOURCES
   55|       |
   56|       |@interface GTMSessionFetcher (GTMHTTPFetcherLoggingUtilities)
   57|       |
   58|       |+ (NSString *)headersStringForDictionary:(NSDictionary *)dict;
   59|       |+ (NSString *)snipSubstringOfString:(NSString *)originalStr
   60|       |                 betweenStartString:(NSString *)startStr
   61|       |                          endString:(NSString *)endStr;
   62|       |- (void)inputStream:(GTMReadMonitorInputStream *)stream
   63|       |     readIntoBuffer:(void *)buffer
   64|       |             length:(int64_t)length;
   65|       |
   66|       |@end
   67|       |
   68|       |@implementation GTMSessionFetcher (GTMSessionFetcherLogging)
   69|       |
   70|       |// fetchers come and fetchers go, but statics are forever
   71|       |static BOOL gIsLoggingEnabled = NO;
   72|       |static BOOL gIsLoggingToFile = YES;
   73|       |static NSString *gLoggingDirectoryPath = nil;
   74|       |static NSString *gLogDirectoryForCurrentRun = nil;
   75|       |static NSString *gLoggingDateStamp = nil;
   76|       |static NSString *gLoggingProcessName = nil;
   77|       |
   78|      0|+ (void)setLoggingDirectory:(NSString *)path {
   79|      0|  gLoggingDirectoryPath = [path copy];
   80|      0|}
   81|       |
   82|      0|+ (NSString *)loggingDirectory {
   83|      0|  if (!gLoggingDirectoryPath) {
   84|      0|    NSArray *paths = nil;
   85|      0|#if TARGET_IPHONE_SIMULATOR
   86|      0|    // default to a directory called GTMHTTPDebugLogs into a sandbox-safe
   87|      0|    // directory that a developer can find easily, the application home
   88|      0|    paths = @[ NSHomeDirectory() ];
   89|       |#elif TARGET_OS_IPHONE
   90|       |    // Neither ~/Desktop nor ~/Home is writable on an actual iOS, watchOS, or tvOS device.
   91|       |    // Put it in ~/Documents.
   92|       |    paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
   93|       |#else
   94|       |    // default to a directory called GTMHTTPDebugLogs in the desktop folder
   95|       |    paths = NSSearchPathForDirectoriesInDomains(NSDesktopDirectory, NSUserDomainMask, YES);
   96|       |#endif
   97|       |
   98|      0|    NSString *desktopPath = paths.firstObject;
   99|      0|    if (desktopPath) {
  100|      0|      NSString *const kGTMLogFolderName = @"GTMHTTPDebugLogs";
  101|      0|      NSString *logsFolderPath = [desktopPath stringByAppendingPathComponent:kGTMLogFolderName];
  102|      0|
  103|      0|      NSFileManager *fileMgr = [NSFileManager defaultManager];
  104|      0|      BOOL isDir;
  105|      0|      BOOL doesFolderExist = [fileMgr fileExistsAtPath:logsFolderPath isDirectory:&isDir];
  106|      0|      if (!doesFolderExist) {
  107|      0|        // make the directory
  108|      0|        doesFolderExist = [fileMgr createDirectoryAtPath:logsFolderPath
  109|      0|                             withIntermediateDirectories:YES
  110|      0|                                              attributes:nil
  111|      0|                                                   error:NULL];
  112|      0|        if (doesFolderExist) {
  113|      0|          // The directory has been created. Exclude it from backups.
  114|      0|          NSURL *pathURL = [NSURL fileURLWithPath:logsFolderPath isDirectory:YES];
  115|      0|          [pathURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:NULL];
  116|      0|        }
  117|      0|      }
  118|      0|
  119|      0|      if (doesFolderExist) {
  120|      0|        // it's there; store it in the global
  121|      0|        gLoggingDirectoryPath = [logsFolderPath copy];
  122|      0|      }
  123|      0|    }
  124|      0|  }
  125|      0|  return gLoggingDirectoryPath;
  126|      0|}
  127|       |
  128|      0|+ (void)setLogDirectoryForCurrentRun:(NSString *)logDirectoryForCurrentRun {
  129|      0|  // Set the path for this run's logs.
  130|      0|  gLogDirectoryForCurrentRun = [logDirectoryForCurrentRun copy];
  131|      0|}
  132|       |
  133|      0|+ (NSString *)logDirectoryForCurrentRun {
  134|      0|  // make a directory for this run's logs, like SyncProto_logs_10-16_01-56-58PM
  135|      0|  if (gLogDirectoryForCurrentRun) return gLogDirectoryForCurrentRun;
  136|      0|
  137|      0|  NSString *parentDir = [self loggingDirectory];
  138|      0|  NSString *logNamePrefix = [self processNameLogPrefix];
  139|      0|  NSString *dateStamp = [self loggingDateStamp];
  140|      0|  NSString *dirName = [NSString stringWithFormat:@"%@%@", logNamePrefix, dateStamp];
  141|      0|  NSString *logDirectory = [parentDir stringByAppendingPathComponent:dirName];
  142|      0|
  143|      0|  if (gIsLoggingToFile) {
  144|      0|    NSFileManager *fileMgr = [NSFileManager defaultManager];
  145|      0|    // Be sure that the first time this app runs, it's not writing to a preexisting folder
  146|      0|    static BOOL gShouldReuseFolder = NO;
  147|      0|    if (!gShouldReuseFolder) {
  148|      0|      gShouldReuseFolder = YES;
  149|      0|      NSString *origLogDir = logDirectory;
  150|      0|      for (int ctr = 2; ctr < 20; ++ctr) {
  151|      0|        if (![fileMgr fileExistsAtPath:logDirectory]) break;
  152|      0|
  153|      0|        // append a digit
  154|      0|        logDirectory = [origLogDir stringByAppendingFormat:@"_%d", ctr];
  155|      0|      }
  156|      0|    }
  157|      0|    if (![fileMgr createDirectoryAtPath:logDirectory
  158|      0|            withIntermediateDirectories:YES
  159|      0|                             attributes:nil
  160|      0|                                  error:NULL]) return nil;
  161|      0|  }
  162|      0|  gLogDirectoryForCurrentRun = logDirectory;
  163|      0|
  164|      0|  return gLogDirectoryForCurrentRun;
  165|      0|}
  166|       |
  167|      0|+ (void)setLoggingEnabled:(BOOL)isLoggingEnabled {
  168|      0|  gIsLoggingEnabled = isLoggingEnabled;
  169|      0|}
  170|       |
  171|      0|+ (BOOL)isLoggingEnabled {
  172|      0|  return gIsLoggingEnabled;
  173|      0|}
  174|       |
  175|      0|+ (void)setLoggingToFileEnabled:(BOOL)isLoggingToFileEnabled {
  176|      0|  gIsLoggingToFile = isLoggingToFileEnabled;
  177|      0|}
  178|       |
  179|      0|+ (BOOL)isLoggingToFileEnabled {
  180|      0|  return gIsLoggingToFile;
  181|      0|}
  182|       |
  183|      0|+ (void)setLoggingProcessName:(NSString *)processName {
  184|      0|  gLoggingProcessName = [processName copy];
  185|      0|}
  186|       |
  187|      0|+ (NSString *)loggingProcessName {
  188|      0|  // get the process name (once per run) replacing spaces with underscores
  189|      0|  if (!gLoggingProcessName) {
  190|      0|    NSString *procName = [[NSProcessInfo processInfo] processName];
  191|      0|    gLoggingProcessName = [procName stringByReplacingOccurrencesOfString:@" " withString:@"_"];
  192|      0|  }
  193|      0|  return gLoggingProcessName;
  194|      0|}
  195|       |
  196|      0|+ (void)setLoggingDateStamp:(NSString *)dateStamp {
  197|      0|  gLoggingDateStamp = [dateStamp copy];
  198|      0|}
  199|       |
  200|      0|+ (NSString *)loggingDateStamp {
  201|      0|  // We'll pick one date stamp per run, so a run that starts at a later second
  202|      0|  // will get a unique results html file
  203|      0|  if (!gLoggingDateStamp) {
  204|      0|    // produce a string like 08-21_01-41-23PM
  205|      0|
  206|      0|    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
  207|      0|    [formatter setFormatterBehavior:NSDateFormatterBehavior10_4];
  208|      0|    [formatter setDateFormat:@"M-dd_hh-mm-ssa"];
  209|      0|
  210|      0|    gLoggingDateStamp = [formatter stringFromDate:[NSDate date]];
  211|      0|  }
  212|      0|  return gLoggingDateStamp;
  213|      0|}
  214|       |
  215|      0|+ (NSString *)processNameLogPrefix {
  216|      0|  static NSString *gPrefix = nil;
  217|      0|  if (!gPrefix) {
  218|      0|    NSString *processName = [self loggingProcessName];
  219|      0|    gPrefix = [[NSString alloc] initWithFormat:@"%@_log_", processName];
  220|      0|  }
  221|      0|  return gPrefix;
  222|      0|}
  223|       |
  224|      0|+ (NSString *)symlinkNameSuffix {
  225|      0|  return @"_log_newest.html";
  226|      0|}
  227|       |
  228|      0|+ (NSString *)htmlFileName {
  229|      0|  return @"aperÃ§u_http_log.html";
  230|      0|}
  231|       |
  232|      0|+ (void)deleteLogDirectoriesOlderThanDate:(NSDate *)cutoffDate {
  233|      0|  NSFileManager *fileMgr = [NSFileManager defaultManager];
  234|      0|  NSURL *parentDir = [NSURL fileURLWithPath:[[self class] loggingDirectory]];
  235|      0|  NSURL *logDirectoryForCurrentRun =
  236|      0|      [NSURL fileURLWithPath:[[self class] logDirectoryForCurrentRun]];
  237|      0|  NSError *error;
  238|      0|  NSArray *contents = [fileMgr contentsOfDirectoryAtURL:parentDir
  239|      0|                             includingPropertiesForKeys:@[ NSURLContentModificationDateKey ]
  240|      0|                                                options:0
  241|      0|                                                  error:&error];
  242|      0|  for (NSURL *itemURL in contents) {
  243|      0|    if ([itemURL isEqual:logDirectoryForCurrentRun]) continue;
  244|      0|
  245|      0|    NSDate *modDate;
  246|      0|    if ([itemURL getResourceValue:&modDate
  247|      0|                           forKey:NSURLContentModificationDateKey
  248|      0|                            error:&error]) {
  249|      0|      if ([modDate compare:cutoffDate] == NSOrderedAscending) {
  250|      0|        if (![fileMgr removeItemAtURL:itemURL error:&error]) {
  251|      0|          NSLog(@"deleteLogDirectoriesOlderThanDate failed to delete %@: %@",
  252|      0|                itemURL.path, error);
  253|      0|        }
  254|      0|      }
  255|      0|    } else {
  256|      0|      NSLog(@"deleteLogDirectoriesOlderThanDate failed to get mod date of %@: %@",
  257|      0|            itemURL.path, error);
  258|      0|    }
  259|      0|  }
  260|      0|}
  261|       |
  262|       |// formattedStringFromData returns a prettyprinted string for XML or JSON input,
  263|       |// and a plain string for other input data
  264|       |- (NSString *)formattedStringFromData:(NSData *)inputData
  265|       |                          contentType:(NSString *)contentType
  266|      0|                                 JSON:(NSDictionary **)outJSON {
  267|      0|  if (!inputData) return nil;
  268|      0|
  269|      0|  // if the content type is JSON and we have the parsing class available, use that
  270|      0|  if ([contentType hasPrefix:@"application/json"] && inputData.length > 5) {
  271|      0|    // convert from JSON string to NSObjects and back to a formatted string
  272|      0|    NSMutableDictionary *obj = [NSJSONSerialization JSONObjectWithData:inputData
  273|      0|                                                               options:NSJSONReadingMutableContainers
  274|      0|                                                                 error:NULL];
  275|      0|    if (obj) {
  276|      0|      if (outJSON) *outJSON = obj;
  277|      0|      if ([obj isKindOfClass:[NSMutableDictionary class]]) {
  278|      0|        // for security and privacy, omit OAuth 2 response access and refresh tokens
  279|      0|        if ([obj valueForKey:@"refresh_token"] != nil) {
  280|      0|          [obj setObject:@"_snip_" forKey:@"refresh_token"];
  281|      0|        }
  282|      0|        if ([obj valueForKey:@"access_token"] != nil) {
  283|      0|          [obj setObject:@"_snip_" forKey:@"access_token"];
  284|      0|        }
  285|      0|      }
  286|      0|      NSData *data = [NSJSONSerialization dataWithJSONObject:obj
  287|      0|                                                     options:NSJSONWritingPrettyPrinted
  288|      0|                                                       error:NULL];
  289|      0|      if (data) {
  290|      0|        NSString *jsonStr = [[NSString alloc] initWithData:data
  291|      0|                                                  encoding:NSUTF8StringEncoding];
  292|      0|        return jsonStr;
  293|      0|      }
  294|      0|    }
  295|      0|  }
  296|      0|
  297|       |#if !TARGET_OS_IPHONE && !GTM_SKIP_LOG_XMLFORMAT
  298|       |  // verify that this data starts with the bytes indicating XML
  299|       |
  300|       |  NSString *const kXMLLintPath = @"/usr/bin/xmllint";
  301|       |  static BOOL gHasCheckedAvailability = NO;
  302|       |  static BOOL gIsXMLLintAvailable = NO;
  303|       |
  304|       |  if (!gHasCheckedAvailability) {
  305|       |    gIsXMLLintAvailable = [[NSFileManager defaultManager] fileExistsAtPath:kXMLLintPath];
  306|       |    gHasCheckedAvailability = YES;
  307|       |  }
  308|       |  if (gIsXMLLintAvailable
  309|       |      && inputData.length > 5
  310|       |      && strncmp(inputData.bytes, "<?xml", 5) == 0) {
  311|       |
  312|       |    // call xmllint to format the data
  313|       |    NSTask *task = [[NSTask alloc] init];
  314|       |    [task setLaunchPath:kXMLLintPath];
  315|       |
  316|       |    // use the dash argument to specify stdin as the source file
  317|       |    [task setArguments:@[ @"--format", @"-" ]];
  318|       |    [task setEnvironment:@{}];
  319|       |
  320|       |    NSPipe *inputPipe = [NSPipe pipe];
  321|       |    NSPipe *outputPipe = [NSPipe pipe];
  322|       |    [task setStandardInput:inputPipe];
  323|       |    [task setStandardOutput:outputPipe];
  324|       |
  325|       |    [task launch];
  326|       |
  327|       |    [[inputPipe fileHandleForWriting] writeData:inputData];
  328|       |    [[inputPipe fileHandleForWriting] closeFile];
  329|       |
  330|       |    // drain the stdout before waiting for the task to exit
  331|       |    NSData *formattedData = [[outputPipe fileHandleForReading] readDataToEndOfFile];
  332|       |
  333|       |    [task waitUntilExit];
  334|       |
  335|       |    int status = [task terminationStatus];
  336|       |    if (status == 0 && formattedData.length > 0) {
  337|       |      // success
  338|       |      inputData = formattedData;
  339|       |    }
  340|       |  }
  341|       |#else
  342|       |  // we can't call external tasks on the iPhone; leave the XML unformatted
  343|      0|#endif
  344|      0|
  345|      0|  NSString *dataStr = [[NSString alloc] initWithData:inputData
  346|      0|                                            encoding:NSUTF8StringEncoding];
  347|      0|  return dataStr;
  348|      0|}
  349|       |
  350|       |// stringFromStreamData creates a string given the supplied data
  351|       |//
  352|       |// If NSString can create a UTF-8 string from the data, then that is returned.
  353|       |//
  354|       |// Otherwise, this routine tries to find a MIME boundary at the beginning of the data block, and
  355|       |// uses that to break up the data into parts. Each part will be used to try to make a UTF-8 string.
  356|       |// For parts that fail, a replacement string showing the part header and <<n bytes>> is supplied
  357|       |// in place of the binary data.
  358|       |
  359|       |- (NSString *)stringFromStreamData:(NSData *)data
  360|      0|                       contentType:(NSString *)contentType {
  361|      0|
  362|      0|  if (!data) return nil;
  363|      0|
  364|      0|  // optimistically, see if the whole data block is UTF-8
  365|      0|  NSString *streamDataStr = [self formattedStringFromData:data
  366|      0|                                              contentType:contentType
  367|      0|                                                     JSON:NULL];
  368|      0|  if (streamDataStr) return streamDataStr;
  369|      0|
  370|      0|  // Munge a buffer by replacing non-ASCII bytes with underscores, and turn that munged buffer an
  371|      0|  // NSString.  That gives us a string we can use with NSScanner.
  372|      0|  NSMutableData *mutableData = [NSMutableData dataWithData:data];
  373|      0|  unsigned char *bytes = (unsigned char *)mutableData.mutableBytes;
  374|      0|
  375|      0|  for (unsigned int idx = 0; idx < mutableData.length; ++idx) {
  376|      0|    if (bytes[idx] > 0x7F || bytes[idx] == 0) {
  377|      0|      bytes[idx] = '_';
  378|      0|    }
  379|      0|  }
  380|      0|
  381|      0|  NSString *mungedStr = [[NSString alloc] initWithData:mutableData
  382|      0|                                              encoding:NSUTF8StringEncoding];
  383|      0|  if (mungedStr) {
  384|      0|
  385|      0|    // scan for the boundary string
  386|      0|    NSString *boundary = nil;
  387|      0|    NSScanner *scanner = [NSScanner scannerWithString:mungedStr];
  388|      0|
  389|      0|    if ([scanner scanUpToString:@"\r\n" intoString:&boundary]
  390|      0|        && [boundary hasPrefix:@"--"]) {
  391|      0|
  392|      0|      // we found a boundary string; use it to divide the string into parts
  393|      0|      NSArray *mungedParts = [mungedStr componentsSeparatedByString:boundary];
  394|      0|
  395|      0|      // look at each munged part in the original string, and try to convert those into UTF-8
  396|      0|      NSMutableArray *origParts = [NSMutableArray array];
  397|      0|      NSUInteger offset = 0;
  398|      0|      for (NSString *mungedPart in mungedParts) {
  399|      0|        NSUInteger partSize = mungedPart.length;
  400|      0|        NSData *origPartData = [data subdataWithRange:NSMakeRange(offset, partSize)];
  401|      0|        NSString *origPartStr = [[NSString alloc] initWithData:origPartData
  402|      0|                                                      encoding:NSUTF8StringEncoding];
  403|      0|        if (origPartStr) {
  404|      0|          // we could make this original part into UTF-8; use the string
  405|      0|          [origParts addObject:origPartStr];
  406|      0|        } else {
  407|      0|          // this part can't be made into UTF-8; scan the header, if we can
  408|      0|          NSString *header = nil;
  409|      0|          NSScanner *headerScanner = [NSScanner scannerWithString:mungedPart];
  410|      0|          if (![headerScanner scanUpToString:@"\r\n\r\n" intoString:&header]) {
  411|      0|            // we couldn't find a header
  412|      0|            header = @"";
  413|      0|          }
  414|      0|          // make a part string with the header and <<n bytes>>
  415|      0|          NSString *binStr = [NSString stringWithFormat:@"\r%@\r<<%lu bytes>>\r",
  416|      0|                              header, (long)(partSize - header.length)];
  417|      0|          [origParts addObject:binStr];
  418|      0|        }
  419|      0|        offset += partSize + boundary.length;
  420|      0|      }
  421|      0|      // rejoin the original parts
  422|      0|      streamDataStr = [origParts componentsJoinedByString:boundary];
  423|      0|    }
  424|      0|  }
  425|      0|  if (!streamDataStr) {
  426|      0|    // give up; just make a string showing the uploaded bytes
  427|      0|    streamDataStr = [NSString stringWithFormat:@"<<%u bytes>>", (unsigned int)data.length];
  428|      0|  }
  429|      0|  return streamDataStr;
  430|      0|}
  431|       |
  432|       |// logFetchWithError is called following a successful or failed fetch attempt
  433|       |//
  434|       |// This method does all the work for appending to and creating log files
  435|       |
  436|      0|- (void)logFetchWithError:(NSError *)error {
  437|      0|  if (![[self class] isLoggingEnabled]) return;
  438|      0|  NSString *logDirectory = [[self class] logDirectoryForCurrentRun];
  439|      0|  if (!logDirectory) return;
  440|      0|  NSString *processName = [[self class] loggingProcessName];
  441|      0|
  442|      0|  // TODO: add Javascript to display response data formatted in hex
  443|      0|
  444|      0|  // each response's NSData goes into its own xml or txt file, though all responses for this run of
  445|      0|  // the app share a main html file. This counter tracks all fetch responses for this app run.
  446|      0|  //
  447|      0|  // we'll use a local variable since this routine may be reentered while waiting for XML formatting
  448|      0|  // to be completed by an external task
  449|      0|  static int gResponseCounter = 0;
  450|      0|  int responseCounter = ++gResponseCounter;
  451|      0|
  452|      0|  NSURLResponse *response = [self response];
  453|      0|  NSDictionary *responseHeaders = [self responseHeaders];
  454|      0|  NSString *responseDataStr = nil;
  455|      0|  NSDictionary *responseJSON = nil;
  456|      0|
  457|      0|  // if there's response data, decide what kind of file to put it in based on the first bytes of the
  458|      0|  // file or on the mime type supplied by the server
  459|      0|  NSString *responseMIMEType = [response MIMEType];
  460|      0|  BOOL isResponseImage = NO;
  461|      0|
  462|      0|  // file name for an image data file
  463|      0|  NSString *responseDataFileName = nil;
  464|      0|
  465|      0|  int64_t responseDataLength = self.downloadedLength;
  466|      0|  if (responseDataLength > 0) {
  467|      0|    NSData *downloadedData = self.downloadedData;
  468|      0|    if (downloadedData == nil
  469|      0|        && responseDataLength > 0
  470|      0|        && responseDataLength < 20000
  471|      0|        && self.destinationFileURL) {
  472|      0|      // There's a download file that's not too big, so get the data to display from the downloaded
  473|      0|      // file.
  474|      0|      NSURL *destinationURL = self.destinationFileURL;
  475|      0|      downloadedData = [NSData dataWithContentsOfURL:destinationURL];
  476|      0|    }
  477|      0|    NSString *responseType = [responseHeaders valueForKey:@"Content-Type"];
  478|      0|    responseDataStr = [self formattedStringFromData:downloadedData
  479|      0|                                        contentType:responseType
  480|      0|                                               JSON:&responseJSON];
  481|      0|    NSString *responseDataExtn = nil;
  482|      0|    NSData *dataToWrite = nil;
  483|      0|    if (responseDataStr) {
  484|      0|      // we were able to make a UTF-8 string from the response data
  485|      0|      if ([responseMIMEType isEqual:@"application/atom+xml"]
  486|      0|          || [responseMIMEType hasSuffix:@"/xml"]) {
  487|      0|        responseDataExtn = @"xml";
  488|      0|        dataToWrite = [responseDataStr dataUsingEncoding:NSUTF8StringEncoding];
  489|      0|      }
  490|      0|    } else if ([responseMIMEType isEqual:@"image/jpeg"]) {
  491|      0|      responseDataExtn = @"jpg";
  492|      0|      dataToWrite = downloadedData;
  493|      0|      isResponseImage = YES;
  494|      0|    } else if ([responseMIMEType isEqual:@"image/gif"]) {
  495|      0|      responseDataExtn = @"gif";
  496|      0|      dataToWrite = downloadedData;
  497|      0|      isResponseImage = YES;
  498|      0|    } else if ([responseMIMEType isEqual:@"image/png"]) {
  499|      0|      responseDataExtn = @"png";
  500|      0|      dataToWrite = downloadedData;
  501|      0|      isResponseImage = YES;
  502|      0|    } else {
  503|      0|      // add more non-text types here
  504|      0|    }
  505|      0|    // if we have an extension, save the raw data in a file with that extension
  506|      0|    if (responseDataExtn && dataToWrite) {
  507|      0|      // generate a response file base name like
  508|      0|      NSString *responseBaseName = [NSString stringWithFormat:@"fetch_%d_response", responseCounter];
  509|      0|      responseDataFileName = [responseBaseName stringByAppendingPathExtension:responseDataExtn];
  510|      0|      NSString *responseDataFilePath = [logDirectory stringByAppendingPathComponent:responseDataFileName];
  511|      0|
  512|      0|      NSError *downloadedError = nil;
  513|      0|      if (gIsLoggingToFile && ![dataToWrite writeToFile:responseDataFilePath
  514|      0|                                                options:0
  515|      0|                                                  error:&downloadedError]) {
  516|      0|        NSLog(@"%@ logging write error:%@ (%@)", [self class], downloadedError, responseDataFileName);
  517|      0|      }
  518|      0|    }
  519|      0|  }
  520|      0|  // we'll have one main html file per run of the app
  521|      0|  NSString *htmlName = [[self class] htmlFileName];
  522|      0|  NSString *htmlPath =[logDirectory stringByAppendingPathComponent:htmlName];
  523|      0|
  524|      0|  // if the html file exists (from logging previous fetches) we don't need
  525|      0|  // to re-write the header or the scripts
  526|      0|  NSFileManager *fileMgr = [NSFileManager defaultManager];
  527|      0|  BOOL didFileExist = [fileMgr fileExistsAtPath:htmlPath];
  528|      0|
  529|      0|  NSMutableString* outputHTML = [NSMutableString string];
  530|      0|
  531|      0|  // we need a header to say we'll have UTF-8 text
  532|      0|  if (!didFileExist) {
  533|      0|    [outputHTML appendFormat:@"<html><head><meta http-equiv=\"content-type\" "
  534|      0|        "content=\"text/html; charset=UTF-8\"><title>%@ HTTP fetch log %@</title>",
  535|      0|        processName, [[self class] loggingDateStamp]];
  536|      0|  }
  537|      0|  // now write the visible html elements
  538|      0|  NSString *copyableFileName = [NSString stringWithFormat:@"fetch_%d.txt", responseCounter];
  539|      0|
  540|      0|  NSDate *now = [NSDate date];
  541|      0|  // write the date & time, the comment, and the link to the plain-text (copyable) log
  542|      0|  [outputHTML appendFormat:@"<b>%@ &nbsp;&nbsp;&nbsp;&nbsp; ", now];
  543|      0|
  544|      0|  NSString *comment = [self comment];
  545|      0|  if (comment.length > 0) {
  546|      0|    [outputHTML appendFormat:@"%@ &nbsp;&nbsp;&nbsp;&nbsp; ", comment];
  547|      0|  }
  548|      0|  [outputHTML appendFormat:@"</b><a href='%@'><i>request/response log</i></a><br>", copyableFileName];
  549|      0|  NSTimeInterval elapsed = -self.initialBeginFetchDate.timeIntervalSinceNow;
  550|      0|  [outputHTML appendFormat:@"elapsed: %5.3fsec<br>", elapsed];
  551|      0|
  552|      0|  // write the request URL
  553|      0|  NSURLRequest *request = self.request;
  554|      0|  NSString *requestMethod = request.HTTPMethod;
  555|      0|  NSURL *requestURL = request.URL;
  556|      0|
  557|      0|  // Save the request URL for next time in case this redirects.
  558|      0|  NSString *redirectedFromURLString = [self.redirectedFromURL absoluteString];
  559|      0|  self.redirectedFromURL = [requestURL copy];
  560|      0|  if (redirectedFromURLString) {
  561|      0|    [outputHTML appendFormat:@"<FONT COLOR='#990066'><i>redirected from %@</i></FONT><br>",
  562|      0|                              redirectedFromURLString];
  563|      0|  }
  564|      0|  [outputHTML appendFormat:@"<b>request:</b> %@ <code>%@</code><br>\n", requestMethod, requestURL];
  565|      0|
  566|      0|  // write the request headers
  567|      0|  NSDictionary *requestHeaders = request.allHTTPHeaderFields;
  568|      0|  NSUInteger numberOfRequestHeaders = requestHeaders.count;
  569|      0|  if (numberOfRequestHeaders > 0) {
  570|      0|    // Indicate if the request is authorized; warn if the request is authorized but non-SSL
  571|      0|    NSString *auth = [requestHeaders objectForKey:@"Authorization"];
  572|      0|    NSString *headerDetails = @"";
  573|      0|    if (auth) {
  574|      0|      BOOL isInsecure = [[requestURL scheme] isEqual:@"http"];
  575|      0|      if (isInsecure) {
  576|      0|        // 26A0 = âš 
  577|      0|        headerDetails =
  578|      0|            @"&nbsp;&nbsp;&nbsp;<i>authorized, non-SSL</i><FONT COLOR='#FF00FF'> &#x26A0;</FONT> ";
  579|      0|      } else {
  580|      0|        headerDetails = @"&nbsp;&nbsp;&nbsp;<i>authorized</i>";
  581|      0|      }
  582|      0|    }
  583|      0|    NSString *cookiesHdr = [requestHeaders objectForKey:@"Cookie"];
  584|      0|    if (cookiesHdr) {
  585|      0|      headerDetails = [headerDetails stringByAppendingString:@"&nbsp;&nbsp;&nbsp;<i>cookies</i>"];
  586|      0|    }
  587|      0|    NSString *matchHdr = [requestHeaders objectForKey:@"If-Match"];
  588|      0|    if (matchHdr) {
  589|      0|      headerDetails = [headerDetails stringByAppendingString:@"&nbsp;&nbsp;&nbsp;<i>if-match</i>"];
  590|      0|    }
  591|      0|    matchHdr = [requestHeaders objectForKey:@"If-None-Match"];
  592|      0|    if (matchHdr) {
  593|      0|      headerDetails = [headerDetails stringByAppendingString:@"&nbsp;&nbsp;&nbsp;<i>if-none-match</i>"];
  594|      0|    }
  595|      0|    [outputHTML appendFormat:@"&nbsp;&nbsp; headers: %d  %@<br>",
  596|      0|                              (int)numberOfRequestHeaders, headerDetails];
  597|      0|  } else {
  598|      0|    [outputHTML appendFormat:@"&nbsp;&nbsp; headers: none<br>"];
  599|      0|  }
  600|      0|  // write the request post data
  601|      0|  NSData *bodyData = nil;
  602|      0|  NSData *loggedStreamData = self.loggedStreamData;
  603|      0|  if (loggedStreamData) {
  604|      0|    bodyData = loggedStreamData;
  605|      0|  } else {
  606|      0|    bodyData = self.bodyData;
  607|      0|    if (bodyData == nil) {
  608|      0|      bodyData = self.request.HTTPBody;
  609|      0|    }
  610|      0|  }
  611|      0|  uint64_t bodyDataLength = bodyData.length;
  612|      0|
  613|      0|  if (bodyData.length == 0) {
  614|      0|    // If the data is in a body upload file URL, read that in if it's not huge.
  615|      0|    NSURL *bodyFileURL = self.bodyFileURL;
  616|      0|    if (bodyFileURL) {
  617|      0|      NSNumber *fileSizeNum = nil;
  618|      0|      NSError *fileSizeError = nil;
  619|      0|      if ([bodyFileURL getResourceValue:&fileSizeNum
  620|      0|                                 forKey:NSURLFileSizeKey
  621|      0|                                  error:&fileSizeError]) {
  622|      0|        bodyDataLength = [fileSizeNum unsignedLongLongValue];
  623|      0|        if (bodyDataLength > 0 && bodyDataLength < 50000) {
  624|      0|          bodyData = [NSData dataWithContentsOfURL:bodyFileURL
  625|      0|                                           options:NSDataReadingUncached
  626|      0|                                             error:&fileSizeError];
  627|      0|        }
  628|      0|      }
  629|      0|    }
  630|      0|  }
  631|      0|  NSString *bodyDataStr = nil;
  632|      0|  NSString *postType = [requestHeaders valueForKey:@"Content-Type"];
  633|      0|
  634|      0|  if (bodyDataLength > 0) {
  635|      0|    [outputHTML appendFormat:@"&nbsp;&nbsp; data: %llu bytes, <code>%@</code><br>\n",
  636|      0|                              bodyDataLength, postType ? postType : @"(no type)"];
  637|      0|    NSString *logRequestBody = self.logRequestBody;
  638|      0|    if (logRequestBody) {
  639|      0|      bodyDataStr = [logRequestBody copy];
  640|      0|      self.logRequestBody = nil;
  641|      0|    } else {
  642|      0|      bodyDataStr = [self stringFromStreamData:bodyData
  643|      0|                                   contentType:postType];
  644|      0|      if (bodyDataStr) {
  645|      0|        // remove OAuth 2 client secret and refresh token
  646|      0|        bodyDataStr = [[self class] snipSubstringOfString:bodyDataStr
  647|      0|                                       betweenStartString:@"client_secret="
  648|      0|                                                endString:@"&"];
  649|      0|        bodyDataStr = [[self class] snipSubstringOfString:bodyDataStr
  650|      0|                                       betweenStartString:@"refresh_token="
  651|      0|                                                endString:@"&"];
  652|      0|        // remove ClientLogin password
  653|      0|        bodyDataStr = [[self class] snipSubstringOfString:bodyDataStr
  654|      0|                                       betweenStartString:@"&Passwd="
  655|      0|                                                endString:@"&"];
  656|      0|      }
  657|      0|    }
  658|      0|  } else {
  659|      0|    // no post data
  660|      0|  }
  661|      0|  // write the response status, MIME type, URL
  662|      0|  NSInteger status = [self statusCode];
  663|      0|  if (response) {
  664|      0|    NSString *statusString = @"";
  665|      0|    if (status != 0) {
  666|      0|      if (status == 200 || status == 201) {
  667|      0|        statusString = [NSString stringWithFormat:@"%ld", (long)status];
  668|      0|
  669|      0|        // report any JSON-RPC error
  670|      0|        if ([responseJSON isKindOfClass:[NSDictionary class]]) {
  671|      0|          NSDictionary *jsonError = [responseJSON objectForKey:@"error"];
  672|      0|          if ([jsonError isKindOfClass:[NSDictionary class]]) {
  673|      0|            NSString *jsonCode = [[jsonError valueForKey:@"code"] description];
  674|      0|            NSString *jsonMessage = [jsonError valueForKey:@"message"];
  675|      0|            if (jsonCode || jsonMessage) {
  676|      0|              // 2691 = âš‘
  677|      0|              NSString *const jsonErrFmt =
  678|      0|                  @"&nbsp;&nbsp;&nbsp;<i>JSON error:</i> <FONT COLOR='#FF00FF'>%@ %@ &nbsp;&#x2691;</FONT>";
  679|      0|              statusString = [statusString stringByAppendingFormat:jsonErrFmt,
  680|      0|                              jsonCode ? jsonCode : @"",
  681|      0|                              jsonMessage ? jsonMessage : @""];
  682|      0|            }
  683|      0|          }
  684|      0|        }
  685|      0|      } else {
  686|      0|        // purple for anything other than 200 or 201
  687|      0|        NSString *flag = status >= 400 ? @"&nbsp;&#x2691;" : @""; // 2691 = âš‘
  688|      0|        NSString *explanation = [NSHTTPURLResponse localizedStringForStatusCode:status];
  689|      0|        NSString *const statusFormat = @"<FONT COLOR='#FF00FF'>%ld %@ %@</FONT>";
  690|      0|        statusString = [NSString stringWithFormat:statusFormat, (long)status, explanation, flag];
  691|      0|      }
  692|      0|    }
  693|      0|    // show the response URL only if it's different from the request URL
  694|      0|    NSString *responseURLStr = @"";
  695|      0|    NSURL *responseURL = response.URL;
  696|      0|
  697|      0|    if (responseURL && ![responseURL isEqual:request.URL]) {
  698|      0|      NSString *const responseURLFormat =
  699|      0|          @"<FONT COLOR='#FF00FF'>response URL:</FONT> <code>%@</code><br>\n";
  700|      0|      responseURLStr = [NSString stringWithFormat:responseURLFormat, [responseURL absoluteString]];
  701|      0|    }
  702|      0|    [outputHTML appendFormat:@"<b>response:</b>&nbsp;&nbsp;status %@<br>\n%@",
  703|      0|                              statusString, responseURLStr];
  704|      0|    // Write the response headers
  705|      0|    NSUInteger numberOfResponseHeaders = responseHeaders.count;
  706|      0|    if (numberOfResponseHeaders > 0) {
  707|      0|      // Indicate if the server is setting cookies
  708|      0|      NSString *cookiesSet = [responseHeaders valueForKey:@"Set-Cookie"];
  709|      0|      NSString *cookiesStr =
  710|      0|          cookiesSet ? @"&nbsp;&nbsp;<FONT COLOR='#990066'><i>sets cookies</i></FONT>" : @"";
  711|      0|      // Indicate if the server is redirecting
  712|      0|      NSString *location = [responseHeaders valueForKey:@"Location"];
  713|      0|      BOOL isRedirect = status >= 300 && status <= 399 && location != nil;
  714|      0|      NSString *redirectsStr =
  715|      0|          isRedirect ? @"&nbsp;&nbsp;<FONT COLOR='#990066'><i>redirects</i></FONT>" : @"";
  716|      0|      [outputHTML appendFormat:@"&nbsp;&nbsp; headers: %d  %@ %@<br>\n",
  717|      0|                                (int)numberOfResponseHeaders, cookiesStr, redirectsStr];
  718|      0|    } else {
  719|      0|      [outputHTML appendString:@"&nbsp;&nbsp; headers: none<br>\n"];
  720|      0|    }
  721|      0|  }
  722|      0|  // error
  723|      0|  if (error) {
  724|      0|    [outputHTML appendFormat:@"<b>Error:</b> %@ <br>\n", error.description];
  725|      0|  }
  726|      0|  // Write the response data
  727|      0|  if (responseDataFileName) {
  728|      0|    if (isResponseImage) {
  729|      0|      // Make a small inline image that links to the full image file
  730|      0|      [outputHTML appendFormat:@"&nbsp;&nbsp; data: %lld bytes, <code>%@</code><br>",
  731|      0|                                responseDataLength, responseMIMEType];
  732|      0|      NSString *const fmt =
  733|      0|          @"<a href=\"%@\"><img src='%@' alt='image' style='border:solid thin;max-height:32'></a>\n";
  734|      0|      [outputHTML appendFormat:fmt, responseDataFileName, responseDataFileName];
  735|      0|    } else {
  736|      0|      // The response data was XML; link to the xml file
  737|      0|      NSString *const fmt =
  738|      0|          @"&nbsp;&nbsp; data: %lld bytes, <code>%@</code>&nbsp;&nbsp;&nbsp;<i><a href=\"%@\">%@</a></i>\n";
  739|      0|      [outputHTML appendFormat:fmt, responseDataLength, responseMIMEType,
  740|      0|                               responseDataFileName, [responseDataFileName pathExtension]];
  741|      0|    }
  742|      0|  } else {
  743|      0|    // The response data was not an image; just show the length and MIME type
  744|      0|    [outputHTML appendFormat:@"&nbsp;&nbsp; data: %lld bytes, <code>%@</code>\n",
  745|      0|        responseDataLength, responseMIMEType ? responseMIMEType : @"(no response type)"];
  746|      0|  }
  747|      0|  // Make a single string of the request and response, suitable for copying
  748|      0|  // to the clipboard and pasting into a bug report
  749|      0|  NSMutableString *copyable = [NSMutableString string];
  750|      0|  if (comment) {
  751|      0|    [copyable appendFormat:@"%@\n\n", comment];
  752|      0|  }
  753|      0|  [copyable appendFormat:@"%@  elapsed: %5.3fsec\n", now, elapsed];
  754|      0|  if (redirectedFromURLString) {
  755|      0|    [copyable appendFormat:@"Redirected from %@\n", redirectedFromURLString];
  756|      0|  }
  757|      0|  [copyable appendFormat:@"Request: %@ %@\n", requestMethod, requestURL];
  758|      0|  if (requestHeaders.count > 0) {
  759|      0|    [copyable appendFormat:@"Request headers:\n%@\n",
  760|      0|                            [[self class] headersStringForDictionary:requestHeaders]];
  761|      0|  }
  762|      0|  if (bodyDataLength > 0) {
  763|      0|    [copyable appendFormat:@"Request body: (%llu bytes)\n", bodyDataLength];
  764|      0|    if (bodyDataStr) {
  765|      0|      [copyable appendFormat:@"%@\n", bodyDataStr];
  766|      0|    }
  767|      0|    [copyable appendString:@"\n"];
  768|      0|  }
  769|      0|  if (response) {
  770|      0|    [copyable appendFormat:@"Response: status %d\n", (int) status];
  771|      0|    [copyable appendFormat:@"Response headers:\n%@\n",
  772|      0|                            [[self class] headersStringForDictionary:responseHeaders]];
  773|      0|    [copyable appendFormat:@"Response body: (%lld bytes)\n", responseDataLength];
  774|      0|    if (responseDataLength > 0) {
  775|      0|      NSString *logResponseBody = self.logResponseBody;
  776|      0|      if (logResponseBody) {
  777|      0|        // The user has provided the response body text.
  778|      0|        responseDataStr = [logResponseBody copy];
  779|      0|        self.logResponseBody = nil;
  780|      0|      }
  781|      0|      if (responseDataStr != nil) {
  782|      0|        [copyable appendFormat:@"%@\n", responseDataStr];
  783|      0|      } else {
  784|      0|        // Even though it's redundant, we'll put in text to indicate that all the bytes are binary.
  785|      0|        if (self.destinationFileURL) {
  786|      0|          [copyable appendFormat:@"<<%lld bytes>>  to file %@\n",
  787|      0|           responseDataLength, self.destinationFileURL.path];
  788|      0|        } else {
  789|      0|          [copyable appendFormat:@"<<%lld bytes>>\n", responseDataLength];
  790|      0|        }
  791|      0|      }
  792|      0|    }
  793|      0|  }
  794|      0|  if (error) {
  795|      0|    [copyable appendFormat:@"Error: %@\n", error];
  796|      0|  }
  797|      0|  // Save to log property before adding the separator
  798|      0|  self.log = copyable;
  799|      0|
  800|      0|  [copyable appendString:@"-----------------------------------------------------------\n"];
  801|      0|
  802|      0|  // Write the copyable version to another file (linked to at the top of the html file, above)
  803|      0|  //
  804|      0|  // Ideally, something to just copy this to the clipboard like
  805|      0|  //   <span onCopy='window.event.clipboardData.setData(\"Text\",
  806|      0|  //   \"copyable stuff\");return false;'>Copy here.</span>"
  807|      0|  // would work everywhere, but it only works in Safari as of 8/2010
  808|      0|  if (gIsLoggingToFile) {
  809|      0|    NSString *parentDir = [[self class] loggingDirectory];
  810|      0|    NSString *copyablePath = [logDirectory stringByAppendingPathComponent:copyableFileName];
  811|      0|    NSError *copyableError = nil;
  812|      0|    if (![copyable writeToFile:copyablePath
  813|      0|                    atomically:NO
  814|      0|                      encoding:NSUTF8StringEncoding
  815|      0|                         error:&copyableError]) {
  816|      0|      // Error writing to file
  817|      0|      NSLog(@"%@ logging write error:%@ (%@)", [self class], copyableError, copyablePath);
  818|      0|    }
  819|      0|    [outputHTML appendString:@"<br><hr><p>"];
  820|      0|
  821|      0|    // Append the HTML to the main output file
  822|      0|    const char* htmlBytes = outputHTML.UTF8String;
  823|      0|    NSOutputStream *stream = [NSOutputStream outputStreamToFileAtPath:htmlPath
  824|      0|                                                               append:YES];
  825|      0|    [stream open];
  826|      0|    [stream write:(const uint8_t *) htmlBytes maxLength:strlen(htmlBytes)];
  827|      0|    [stream close];
  828|      0|
  829|      0|    // Make a symlink to the latest html
  830|      0|    NSString *const symlinkNameSuffix = [[self class] symlinkNameSuffix];
  831|      0|    NSString *symlinkName = [processName stringByAppendingString:symlinkNameSuffix];
  832|      0|    NSString *symlinkPath = [parentDir stringByAppendingPathComponent:symlinkName];
  833|      0|
  834|      0|    [fileMgr removeItemAtPath:symlinkPath error:NULL];
  835|      0|    [fileMgr createSymbolicLinkAtPath:symlinkPath
  836|      0|                  withDestinationPath:htmlPath
  837|      0|                                error:NULL];
  838|      0|#if TARGET_OS_IPHONE
  839|      0|    static BOOL gReportedLoggingPath = NO;
  840|      0|    if (!gReportedLoggingPath) {
  841|      0|      gReportedLoggingPath = YES;
  842|      0|      NSLog(@"GTMSessionFetcher logging to \"%@\"", parentDir);
  843|      0|    }
  844|      0|#endif
  845|      0|  }
  846|      0|}
  847|       |
  848|      0|- (NSInputStream *)loggedInputStreamForInputStream:(NSInputStream *)inputStream {
  849|      0|  if (!inputStream) return nil;
  850|      0|  if (![GTMSessionFetcher isLoggingEnabled]) return inputStream;
  851|      0|
  852|      0|  [self clearLoggedStreamData];  // Clear any previous data.
  853|      0|  Class monitorClass = NSClassFromString(@"GTMReadMonitorInputStream");
  854|      0|  if (!monitorClass) {
  855|      0|    NSString const *str = @"<<Uploaded stream log unavailable without GTMReadMonitorInputStream>>";
  856|      0|    NSData *stringData = [str dataUsingEncoding:NSUTF8StringEncoding];
  857|      0|    [self appendLoggedStreamData:stringData];
  858|      0|    return inputStream;
  859|      0|  }
  860|      0|  inputStream = [monitorClass inputStreamWithStream:inputStream];
  861|      0|
  862|      0|  GTMReadMonitorInputStream *readMonitorInputStream = (GTMReadMonitorInputStream *)inputStream;
  863|      0|  [readMonitorInputStream setReadDelegate:self];
  864|      0|  SEL readSel = @selector(inputStream:readIntoBuffer:length:);
  865|      0|  [readMonitorInputStream setReadSelector:readSel];
  866|      0|
  867|      0|  return inputStream;
  868|      0|}
  869|       |
  870|       |- (GTMSessionFetcherBodyStreamProvider)loggedStreamProviderForStreamProvider:
  871|      0|    (GTMSessionFetcherBodyStreamProvider)streamProvider {
  872|      0|  if (!streamProvider) return nil;
  873|      0|  if (![GTMSessionFetcher isLoggingEnabled]) return streamProvider;
  874|      0|
  875|      0|  [self clearLoggedStreamData];  // Clear any previous data.
  876|      0|  Class monitorClass = NSClassFromString(@"GTMReadMonitorInputStream");
  877|      0|  if (!monitorClass) {
  878|      0|    NSString const *str = @"<<Uploaded stream log unavailable without GTMReadMonitorInputStream>>";
  879|      0|    NSData *stringData = [str dataUsingEncoding:NSUTF8StringEncoding];
  880|      0|    [self appendLoggedStreamData:stringData];
  881|      0|    return streamProvider;
  882|      0|  }
  883|      0|  GTMSessionFetcherBodyStreamProvider loggedStreamProvider =
  884|      0|      ^(GTMSessionFetcherBodyStreamProviderResponse response) {
  885|      0|      streamProvider(^(NSInputStream *bodyStream) {
  886|      0|          bodyStream = [self loggedInputStreamForInputStream:bodyStream];
  887|      0|          response(bodyStream);
  888|      0|      });
  889|      0|  };
  890|      0|  return loggedStreamProvider;
  891|      0|}
  892|       |
  893|       |@end
  894|       |
  895|       |@implementation GTMSessionFetcher (GTMSessionFetcherLoggingUtilities)
  896|       |
  897|       |- (void)inputStream:(GTMReadMonitorInputStream *)stream
  898|       |     readIntoBuffer:(void *)buffer
  899|      0|             length:(int64_t)length {
  900|      0|  // append the captured data
  901|      0|  NSData *data = [NSData dataWithBytesNoCopy:buffer
  902|      0|                                      length:(NSUInteger)length
  903|      0|                                freeWhenDone:NO];
  904|      0|  [self appendLoggedStreamData:data];
  905|      0|}
  906|       |
  907|       |#pragma mark Fomatting Utilities
  908|       |
  909|       |+ (NSString *)snipSubstringOfString:(NSString *)originalStr
  910|       |                 betweenStartString:(NSString *)startStr
  911|      0|                          endString:(NSString *)endStr {
  912|       |#if SKIP_GTM_FETCH_LOGGING_SNIPPING
  913|       |  return originalStr;
  914|       |#else
  915|      0|  if (!originalStr) return nil;
  916|      0|
  917|      0|  // Find the start string, and replace everything between it
  918|      0|  // and the end string (or the end of the original string) with "_snip_"
  919|      0|  NSRange startRange = [originalStr rangeOfString:startStr];
  920|      0|  if (startRange.location == NSNotFound) return originalStr;
  921|      0|
  922|      0|  // We found the start string
  923|      0|  NSUInteger originalLength = originalStr.length;
  924|      0|  NSUInteger startOfTarget = NSMaxRange(startRange);
  925|      0|  NSRange targetAndRest = NSMakeRange(startOfTarget, originalLength - startOfTarget);
  926|      0|  NSRange endRange = [originalStr rangeOfString:endStr
  927|      0|                                        options:0
  928|      0|                                          range:targetAndRest];
  929|      0|  NSRange replaceRange;
  930|      0|  if (endRange.location == NSNotFound) {
  931|      0|    // Found no end marker so replace to end of string
  932|      0|    replaceRange = targetAndRest;
  933|      0|  } else {
  934|      0|    // Replace up to the endStr
  935|      0|    replaceRange = NSMakeRange(startOfTarget, endRange.location - startOfTarget);
  936|      0|  }
  937|      0|  NSString *result = [originalStr stringByReplacingCharactersInRange:replaceRange
  938|      0|                                                          withString:@"_snip_"];
  939|      0|  return result;
  940|      0|#endif // SKIP_GTM_FETCH_LOGGING_SNIPPING
  941|      0|}
  942|       |
  943|      0|+ (NSString *)headersStringForDictionary:(NSDictionary *)dict {
  944|      0|  // Format the dictionary in http header style, like
  945|      0|  //   Accept:        application/json
  946|      0|  //   Cache-Control: no-cache
  947|      0|  //   Content-Type:  application/json; charset=utf-8
  948|      0|  //
  949|      0|  // Pad the key names, but not beyond 16 chars, since long custom header
  950|      0|  // keys just create too much whitespace
  951|      0|  NSArray *keys = [dict.allKeys sortedArrayUsingSelector:@selector(compare:)];
  952|      0|
  953|      0|  NSMutableString *str = [NSMutableString string];
  954|      0|  for (NSString *key in keys) {
  955|      0|    NSString *value = [dict valueForKey:key];
  956|      0|    if ([key isEqual:@"Authorization"]) {
  957|      0|      // Remove OAuth 1 token
  958|      0|      value = [[self class] snipSubstringOfString:value
  959|      0|                               betweenStartString:@"oauth_token=\""
  960|      0|                                        endString:@"\""];
  961|      0|
  962|      0|      // Remove OAuth 2 bearer token (draft 16, and older form)
  963|      0|      value = [[self class] snipSubstringOfString:value
  964|      0|                               betweenStartString:@"Bearer "
  965|      0|                                        endString:@"\n"];
  966|      0|      value = [[self class] snipSubstringOfString:value
  967|      0|                               betweenStartString:@"OAuth "
  968|      0|                                        endString:@"\n"];
  969|      0|
  970|      0|      // Remove Google ClientLogin
  971|      0|      value = [[self class] snipSubstringOfString:value
  972|      0|                               betweenStartString:@"GoogleLogin auth="
  973|      0|                                        endString:@"\n"];
  974|      0|    }
  975|      0|    [str appendFormat:@"  %@: %@\n", key, value];
  976|      0|  }
  977|      0|  return str;
  978|      0|}
  979|       |
  980|       |@end
  981|       |
  982|       |#endif // !STRIP_GTM_FETCH_LOGGING

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GTMSessionFetcher/Source/GTMSessionFetcherService.m:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |#if !defined(__has_feature) || !__has_feature(objc_arc)
   17|       |#error "This file requires ARC support."
   18|       |#endif
   19|       |
   20|       |#import "GTMSessionFetcherService.h"
   21|       |
   22|       |NSString *const kGTMSessionFetcherServiceSessionBecameInvalidNotification
   23|       |    = @"kGTMSessionFetcherServiceSessionBecameInvalidNotification";
   24|       |NSString *const kGTMSessionFetcherServiceSessionKey
   25|       |    = @"kGTMSessionFetcherServiceSessionKey";
   26|       |
   27|       |#if !GTMSESSION_BUILD_COMBINED_SOURCES
   28|       |@interface GTMSessionFetcher (ServiceMethods)
   29|       |- (BOOL)beginFetchMayDelay:(BOOL)mayDelay
   30|       |              mayAuthorize:(BOOL)mayAuthorize;
   31|       |@end
   32|       |#endif  // !GTMSESSION_BUILD_COMBINED_SOURCES
   33|       |
   34|       |@interface GTMSessionFetcherService ()
   35|       |
   36|       |@property(atomic, strong, readwrite) NSDictionary *delayedFetchersByHost;
   37|       |@property(atomic, strong, readwrite) NSDictionary *runningFetchersByHost;
   38|       |
   39|       |@end
   40|       |
   41|       |// Since NSURLSession doesn't support a separate delegate per task (!), instances of this
   42|       |// class serve as a session delegate trampoline.
   43|       |//
   44|       |// This class maps a session's tasks to fetchers, and resends delegate messages to the task's
   45|       |// fetcher.
   46|       |@interface GTMSessionFetcherSessionDelegateDispatcher : NSObject<NSURLSessionDelegate>
   47|       |
   48|       |// The session for the tasks in this dispatcher's task-to-fetcher map.
   49|       |@property(atomic) NSURLSession *session;
   50|       |
   51|       |// The timer interval for invalidating a session that has no active tasks.
   52|       |@property(atomic) NSTimeInterval discardInterval;
   53|       |
   54|       |// The current discard timer.
   55|       |@property(atomic, readonly) NSTimer *discardTimer;
   56|       |
   57|       |
   58|       |- (instancetype)initWithParentService:(GTMSessionFetcherService *)parentService
   59|       |               sessionDiscardInterval:(NSTimeInterval)discardInterval;
   60|       |
   61|       |- (void)setFetcher:(GTMSessionFetcher *)fetcher
   62|       |           forTask:(NSURLSessionTask *)task;
   63|       |- (void)removeFetcher:(GTMSessionFetcher *)fetcher;
   64|       |
   65|       |// Before using a session, tells the delegate dispatcher to stop the discard timer.
   66|       |- (void)startSessionUsage;
   67|       |
   68|       |// When abandoning a delegate dispatcher, we want to avoid the session retaining
   69|       |// the delegate after tasks complete.
   70|       |- (void)abandon;
   71|       |
   72|       |@end
   73|       |
   74|       |
   75|       |@implementation GTMSessionFetcherService {
   76|       |  NSMutableDictionary *_delayedFetchersByHost;
   77|       |  NSMutableDictionary *_runningFetchersByHost;
   78|       |  NSUInteger _maxRunningFetchersPerHost;
   79|       |
   80|       |  // When this ivar is nil, the service will not reuse sessions.
   81|       |  GTMSessionFetcherSessionDelegateDispatcher *_delegateDispatcher;
   82|       |
   83|       |  // Fetchers will wait on this if another fetcher is creating the shared NSURLSession.
   84|       |  dispatch_semaphore_t _sessionCreationSemaphore;
   85|       |
   86|       |  dispatch_queue_t _callbackQueue;
   87|       |  NSOperationQueue *_delegateQueue;
   88|       |  NSHTTPCookieStorage *_cookieStorage;
   89|       |  NSString *_userAgent;
   90|       |  NSTimeInterval _timeout;
   91|       |
   92|       |  NSURLCredential *_credential;       // Username & password.
   93|       |  NSURLCredential *_proxyCredential;  // Credential supplied to proxy servers.
   94|       |
   95|       |  NSInteger _cookieStorageMethod;
   96|       |
   97|       |  id<GTMFetcherAuthorizationProtocol> _authorizer;
   98|       |
   99|       |  // For waitForCompletionOfAllFetchersWithTimeout: we need to wait on stopped fetchers since
  100|       |  // they've not yet finished invoking their queued callbacks. This array is nil except when
  101|       |  // waiting on fetchers.
  102|       |  NSMutableArray *_stoppedFetchersToWaitFor;
  103|       |
  104|       |  // For fetchers that enqueued their callbacks before stopAllFetchers was called on the service,
  105|       |  // set a barrier so the callbacks know to bail out.
  106|       |  NSDate *_stoppedAllFetchersDate;
  107|       |}
  108|       |
  109|       |@synthesize maxRunningFetchersPerHost = _maxRunningFetchersPerHost,
  110|       |            configuration = _configuration,
  111|       |            configurationBlock = _configurationBlock,
  112|       |            cookieStorage = _cookieStorage,
  113|       |            userAgent = _userAgent,
  114|       |            challengeBlock = _challengeBlock,
  115|       |            credential = _credential,
  116|       |            proxyCredential = _proxyCredential,
  117|       |            allowedInsecureSchemes = _allowedInsecureSchemes,
  118|       |            allowLocalhostRequest = _allowLocalhostRequest,
  119|       |            allowInvalidServerCertificates = _allowInvalidServerCertificates,
  120|       |            retryEnabled = _retryEnabled,
  121|       |            retryBlock = _retryBlock,
  122|       |            maxRetryInterval = _maxRetryInterval,
  123|       |            minRetryInterval = _minRetryInterval,
  124|       |            properties = _properties,
  125|       |            unusedSessionTimeout = _unusedSessionTimeout,
  126|       |            testBlock = _testBlock;
  127|       |
  128|       |#if GTM_BACKGROUND_TASK_FETCHING
  129|       |@synthesize skipBackgroundTask = _skipBackgroundTask;
  130|       |#endif
  131|       |
  132|      1|- (instancetype)init {
  133|      1|  self = [super init];
  134|      1|  if (self) {
  135|      1|    _delayedFetchersByHost = [[NSMutableDictionary alloc] init];
  136|      1|    _runningFetchersByHost = [[NSMutableDictionary alloc] init];
  137|      1|    _maxRunningFetchersPerHost = 10;
  138|      1|    _cookieStorageMethod = -1;
  139|      1|    _unusedSessionTimeout = 60.0;
  140|      1|    _delegateDispatcher =
  141|      1|        [[GTMSessionFetcherSessionDelegateDispatcher alloc] initWithParentService:self
  142|      1|                                                           sessionDiscardInterval:_unusedSessionTimeout];
  143|      1|    _callbackQueue = dispatch_get_main_queue();
  144|      1|
  145|      1|    _delegateQueue = [[NSOperationQueue alloc] init];
  146|      1|    _delegateQueue.maxConcurrentOperationCount = 1;
  147|      1|    _delegateQueue.name = @"com.google.GTMSessionFetcher.NSURLSessionDelegateQueue";
  148|      1|
  149|      1|    _sessionCreationSemaphore = dispatch_semaphore_create(1);
  150|      1|
  151|      1|    // Starting with the SDKs for OS X 10.11/iOS 9, the service has a default useragent.
  152|      1|    // Apps can remove this and get the default system "CFNetwork" useragent by setting the
  153|      1|    // fetcher service's userAgent property to nil.
  154|      1|#if (!TARGET_OS_IPHONE && defined(MAC_OS_X_VERSION_10_11) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_11) \
  155|      1|    || (TARGET_OS_IPHONE && defined(__IPHONE_9_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_9_0)
  156|      1|    _userAgent = GTMFetcherStandardUserAgentString(nil);
  157|      1|#endif
  158|      1|  }
  159|      1|  return self;
  160|      1|}
  161|       |
  162|      0|- (void)dealloc {
  163|      0|  [self detachAuthorizer];
  164|      0|  [_delegateDispatcher abandon];
  165|      0|}
  166|       |
  167|       |#pragma mark Generate a new fetcher
  168|       |
  169|       |// Clients may override this method. Clients should not override any other library methods.
  170|       |- (id)fetcherWithRequest:(NSURLRequest *)request
  171|      1|            fetcherClass:(Class)fetcherClass {
  172|      1|  GTMSessionFetcher *fetcher = [[fetcherClass alloc] initWithRequest:request
  173|      1|                                                       configuration:self.configuration];
  174|      1|  fetcher.callbackQueue = self.callbackQueue;
  175|      1|  fetcher.sessionDelegateQueue = self.sessionDelegateQueue;
  176|      1|  fetcher.challengeBlock = self.challengeBlock;
  177|      1|  fetcher.credential = self.credential;
  178|      1|  fetcher.proxyCredential = self.proxyCredential;
  179|      1|  fetcher.authorizer = self.authorizer;
  180|      1|  fetcher.cookieStorage = self.cookieStorage;
  181|      1|  fetcher.allowedInsecureSchemes = self.allowedInsecureSchemes;
  182|      1|  fetcher.allowLocalhostRequest = self.allowLocalhostRequest;
  183|      1|  fetcher.allowInvalidServerCertificates = self.allowInvalidServerCertificates;
  184|      1|  fetcher.configurationBlock = self.configurationBlock;
  185|      1|  fetcher.retryEnabled = self.retryEnabled;
  186|      1|  fetcher.retryBlock = self.retryBlock;
  187|      1|  fetcher.maxRetryInterval = self.maxRetryInterval;
  188|      1|  fetcher.minRetryInterval = self.minRetryInterval;
  189|      1|  fetcher.properties = self.properties;
  190|      1|  fetcher.service = self;
  191|      1|  if (self.cookieStorageMethod >= 0) {
  192|      0|    [fetcher setCookieStorageMethod:self.cookieStorageMethod];
  193|      0|  }
  194|      1|
  195|      1|#if GTM_BACKGROUND_TASK_FETCHING
  196|      1|  fetcher.skipBackgroundTask = self.skipBackgroundTask;
  197|      1|#endif
  198|      1|
  199|      1|  NSString *userAgent = self.userAgent;
  200|      1|  if (userAgent.length > 0
  201|      1|      && [request valueForHTTPHeaderField:@"User-Agent"] == nil) {
  202|      1|    [fetcher setRequestValue:userAgent
  203|      1|          forHTTPHeaderField:@"User-Agent"];
  204|      1|  }
  205|      1|  fetcher.testBlock = self.testBlock;
  206|      1|
  207|      1|  return fetcher;
  208|      1|}
  209|       |
  210|      1|- (GTMSessionFetcher *)fetcherWithRequest:(NSURLRequest *)request {
  211|      1|  return [self fetcherWithRequest:request
  212|      1|                     fetcherClass:[GTMSessionFetcher class]];
  213|      1|}
  214|       |
  215|      0|- (GTMSessionFetcher *)fetcherWithURL:(NSURL *)requestURL {
  216|      0|  return [self fetcherWithRequest:[NSURLRequest requestWithURL:requestURL]];
  217|      0|}
  218|       |
  219|      0|- (GTMSessionFetcher *)fetcherWithURLString:(NSString *)requestURLString {
  220|      0|  NSURL *url = [NSURL URLWithString:requestURLString];
  221|      0|  return [self fetcherWithURL:url];
  222|      0|}
  223|       |
  224|       |// Returns a session for the fetcher's host, or nil.
  225|      0|- (NSURLSession *)session {
  226|      0|  @synchronized(self) {
  227|      0|    GTMSessionMonitorSynchronized(self);
  228|      0|
  229|      0|    NSURLSession *session = _delegateDispatcher.session;
  230|      0|    return session;
  231|      0|  }
  232|      0|}
  233|       |
  234|       |// Returns a session for the fetcher's host, or nil.  For shared sessions, this
  235|       |// waits on a semaphore, blocking other fetchers while the caller creates the
  236|       |// session if needed.
  237|      1|- (NSURLSession *)sessionForFetcherCreation {
  238|      1|  @synchronized(self) {
  239|      1|    GTMSessionMonitorSynchronized(self);
  240|      1|    if (!_delegateDispatcher) {
  241|      1|      // This fetcher is creating a non-shared session, so skip the semaphore usage.
  242|      1|      return nil;
  243|      1|    }
  244|      0|  }
  245|      0|
  246|      0|  // Wait if another fetcher is currently creating a session; avoid waiting
  247|      0|  // inside the @synchronized block, as that can deadlock.
  248|      0|  dispatch_semaphore_wait(_sessionCreationSemaphore, DISPATCH_TIME_FOREVER);
  249|      0|
  250|      0|  @synchronized(self) {
  251|      0|    GTMSessionMonitorSynchronized(self);
  252|      0|
  253|      0|    // Before getting the NSURLSession for task creation, it is
  254|      0|    // important to invalidate and nil out the session discard timer; otherwise
  255|      0|    // the session can be invalidated between when it is returned to the
  256|      0|    // fetcher, and when the fetcher attempts to create its NSURLSessionTask.
  257|      0|    [_delegateDispatcher startSessionUsage];
  258|      0|
  259|      0|    NSURLSession *session = _delegateDispatcher.session;
  260|      0|    if (session) {
  261|      0|      // The calling fetcher will receive a preexisting session, so
  262|      0|      // we can allow other fetchers to create a session.
  263|      0|      dispatch_semaphore_signal(_sessionCreationSemaphore);
  264|      0|    } else {
  265|      0|      // No existing session was obtained, so the calling fetcher will create the session;
  266|      0|      // it *must* invoke fetcherDidCreateSession: to signal the dispatcher's semaphore after
  267|      0|      // the session has been created (or fails to be created) to avoid a hang.
  268|      0|    }
  269|      0|    return session;
  270|      0|  }
  271|      0|}
  272|       |
  273|      1|- (id<NSURLSessionDelegate>)sessionDelegate {
  274|      1|  @synchronized(self) {
  275|      1|    GTMSessionMonitorSynchronized(self);
  276|      1|
  277|      1|    return _delegateDispatcher;
  278|      1|  }
  279|      1|}
  280|       |
  281|       |#pragma mark Queue Management
  282|       |
  283|       |- (void)addRunningFetcher:(GTMSessionFetcher *)fetcher
  284|      1|                  forHost:(NSString *)host {
  285|      1|  // Add to the array of running fetchers for this host, creating the array if needed.
  286|      1|  NSMutableArray *runningForHost = [_runningFetchersByHost objectForKey:host];
  287|      1|  if (runningForHost == nil) {
  288|      1|    runningForHost = [NSMutableArray arrayWithObject:fetcher];
  289|      1|    [_runningFetchersByHost setObject:runningForHost forKey:host];
  290|      1|  } else {
  291|      0|    [runningForHost addObject:fetcher];
  292|      0|  }
  293|      1|}
  294|       |
  295|       |- (void)addDelayedFetcher:(GTMSessionFetcher *)fetcher
  296|      0|                  forHost:(NSString *)host {
  297|      0|  // Add to the array of delayed fetchers for this host, creating the array if needed.
  298|      0|  NSMutableArray *delayedForHost = [_delayedFetchersByHost objectForKey:host];
  299|      0|  if (delayedForHost == nil) {
  300|      0|    delayedForHost = [NSMutableArray arrayWithObject:fetcher];
  301|      0|    [_delayedFetchersByHost setObject:delayedForHost forKey:host];
  302|      0|  } else {
  303|      0|    [delayedForHost addObject:fetcher];
  304|      0|  }
  305|      0|}
  306|       |
  307|      0|- (BOOL)isDelayingFetcher:(GTMSessionFetcher *)fetcher {
  308|      0|  @synchronized(self) {
  309|      0|    GTMSessionMonitorSynchronized(self);
  310|      0|
  311|      0|    NSString *host = fetcher.request.URL.host;
  312|      0|    if (host == nil) {
  313|      0|      return NO;
  314|      0|    }
  315|      0|    NSArray *delayedForHost = [_delayedFetchersByHost objectForKey:host];
  316|      0|    NSUInteger idx = [delayedForHost indexOfObjectIdenticalTo:fetcher];
  317|      0|    BOOL isDelayed = (delayedForHost != nil) && (idx != NSNotFound);
  318|      0|    return isDelayed;
  319|      0|  }
  320|      0|}
  321|       |
  322|      1|- (BOOL)fetcherShouldBeginFetching:(GTMSessionFetcher *)fetcher {
  323|      1|  // Entry point from the fetcher
  324|      1|  NSURL *requestURL = fetcher.request.URL;
  325|      1|  NSString *host = requestURL.host;
  326|      1|
  327|      1|  // Addresses "file:///path" case where localhost is the implicit host.
  328|      1|  if (host.length == 0 && [requestURL isFileURL]) {
  329|      0|    host = @"localhost";
  330|      0|  }
  331|      1|
  332|      1|  if (host.length == 0) {
  333|      0|    // Data URIs legitimately have no host, reject other hostless URLs.
  334|      0|    GTMSESSION_ASSERT_DEBUG([[requestURL scheme] isEqual:@"data"], @"%@ lacks host", fetcher);
  335|      0|    return YES;
  336|      0|  }
  337|      1|
  338|      1|  BOOL shouldBeginResult;
  339|      1|
  340|      1|  @synchronized(self) {
  341|      1|    GTMSessionMonitorSynchronized(self);
  342|      1|
  343|      1|    NSMutableArray *runningForHost = [_runningFetchersByHost objectForKey:host];
  344|      1|    if (runningForHost != nil
  345|      1|        && [runningForHost indexOfObjectIdenticalTo:fetcher] != NSNotFound) {
  346|      0|      GTMSESSION_ASSERT_DEBUG(NO, @"%@ was already running", fetcher);
  347|      0|      return YES;
  348|      0|    }
  349|      1|
  350|      1|    BOOL shouldRunNow = (fetcher.usingBackgroundSession
  351|      1|                         || _maxRunningFetchersPerHost == 0
  352|      1|                         || _maxRunningFetchersPerHost >
  353|      1|                         [[self class] numberOfNonBackgroundSessionFetchers:runningForHost]);
  354|      1|    if (shouldRunNow) {
  355|      1|      [self addRunningFetcher:fetcher forHost:host];
  356|      1|      shouldBeginResult = YES;
  357|      1|    } else {
  358|      0|      [self addDelayedFetcher:fetcher forHost:host];
  359|      0|      shouldBeginResult = NO;
  360|      0|    }
  361|      1|  }  // @synchronized(self)
  362|      1|
  363|      1|  // We'll save the host that serves as the key for this fetcher's array
  364|      1|  // to avoid any chance of the underlying request changing, stranding
  365|      1|  // the fetcher in the wrong array
  366|      1|  fetcher.serviceHost = host;
  367|      1|
  368|      1|  return shouldBeginResult;
  369|      1|}
  370|       |
  371|      0|- (void)startFetcher:(GTMSessionFetcher *)fetcher {
  372|      0|  [fetcher beginFetchMayDelay:NO
  373|      0|                 mayAuthorize:YES];
  374|      0|}
  375|       |
  376|       |// Internal utility. Returns a fetcher's delegate if it's a dispatcher, or nil if the fetcher
  377|       |// is its own delegate (possibly via proxy) and has no dispatcher.
  378|      2|- (GTMSessionFetcherSessionDelegateDispatcher *)delegateDispatcherForFetcher:(GTMSessionFetcher *)fetcher {
  379|      2|  GTMSessionCheckNotSynchronized(self);
  380|      2|
  381|      2|  NSURLSession *fetcherSession = fetcher.session;
  382|      2|  if (fetcherSession) {
  383|      2|    id<NSURLSessionDelegate> fetcherDelegate = fetcherSession.delegate;
  384|      2|    // If the delegate is non-nil and claims to be a GTMSessionFetcher, there is no dispatcher;
  385|      2|    // assume the fetcher is the delegate or has been proxied (some third-party frameworks
  386|      2|    // are known to swizzle NSURLSession to proxy its delegate).
  387|      2|    BOOL hasDispatcher = (fetcherDelegate != nil &&
  388|      2|                          ![fetcherDelegate isKindOfClass:[GTMSessionFetcher class]]);
  389|      2|    if (hasDispatcher) {
  390|      0|      GTMSESSION_ASSERT_DEBUG([fetcherDelegate isKindOfClass:[GTMSessionFetcherSessionDelegateDispatcher class]],
  391|      0|                              @"Fetcher delegate class: %@", [fetcherDelegate class]);
  392|      0|      return (GTMSessionFetcherSessionDelegateDispatcher *)fetcherDelegate;
  393|      0|    }
  394|      2|  }
  395|      2|  return nil;
  396|      2|}
  397|       |
  398|      1|- (void)fetcherDidCreateSession:(GTMSessionFetcher *)fetcher {
  399|      1|  if (fetcher.canShareSession) {
  400|      1|    NSURLSession *fetcherSession = fetcher.session;
  401|      1|    GTMSESSION_ASSERT_DEBUG(fetcherSession != nil, @"Fetcher missing its session: %@", fetcher);
  402|      1|
  403|      1|    GTMSessionFetcherSessionDelegateDispatcher *delegateDispatcher =
  404|      1|        [self delegateDispatcherForFetcher:fetcher];
  405|      1|    if (delegateDispatcher) {
  406|      0|      GTMSESSION_ASSERT_DEBUG(delegateDispatcher.session == nil,
  407|      0|                              @"Fetcher made an extra session: %@", fetcher);
  408|      0|
  409|      0|      // Save this fetcher's session.
  410|      0|      delegateDispatcher.session = fetcherSession;
  411|      0|
  412|      0|      // Allow other fetchers to request this session now.
  413|      0|      dispatch_semaphore_signal(_sessionCreationSemaphore);
  414|      0|    }
  415|      1|  }
  416|      1|}
  417|       |
  418|      1|- (void)fetcherDidBeginFetching:(GTMSessionFetcher *)fetcher {
  419|      1|  // If this fetcher has a separate delegate with a shared session, then
  420|      1|  // this fetcher should be added to the delegate's map of tasks to fetchers.
  421|      1|  GTMSessionFetcherSessionDelegateDispatcher *delegateDispatcher =
  422|      1|      [self delegateDispatcherForFetcher:fetcher];
  423|      1|  if (delegateDispatcher) {
  424|      0|    GTMSESSION_ASSERT_DEBUG(fetcher.canShareSession,
  425|      0|                            @"Inappropriate shared session: %@", fetcher);
  426|      0|
  427|      0|    // There should already be a session, from this or a previous fetcher.
  428|      0|    //
  429|      0|    // Sanity check that the fetcher's session is the delegate's shared session.
  430|      0|    NSURLSession *sharedSession = delegateDispatcher.session;
  431|      0|    NSURLSession *fetcherSession = fetcher.session;
  432|      0|    GTMSESSION_ASSERT_DEBUG(sharedSession != nil, @"Missing delegate session: %@", fetcher);
  433|      0|    GTMSESSION_ASSERT_DEBUG(fetcherSession == sharedSession,
  434|      0|                            @"Inconsistent session: %@ %@ (shared: %@)",
  435|      0|                            fetcher, fetcherSession, sharedSession);
  436|      0|
  437|      0|    if (sharedSession != nil && fetcherSession == sharedSession) {
  438|      0|      NSURLSessionTask *task = fetcher.sessionTask;
  439|      0|      GTMSESSION_ASSERT_DEBUG(task != nil, @"Missing session task: %@", fetcher);
  440|      0|
  441|      0|      if (task) {
  442|      0|        [delegateDispatcher setFetcher:fetcher
  443|      0|                               forTask:task];
  444|      0|      }
  445|      0|    }
  446|      0|  }
  447|      1|}
  448|       |
  449|      0|- (void)stopFetcher:(GTMSessionFetcher *)fetcher {
  450|      0|  [fetcher stopFetching];
  451|      0|}
  452|       |
  453|      0|- (void)fetcherDidStop:(GTMSessionFetcher *)fetcher {
  454|      0|  // Entry point from the fetcher
  455|      0|  NSString *host = fetcher.serviceHost;
  456|      0|  if (!host) {
  457|      0|    // fetcher has been stopped previously
  458|      0|    return;
  459|      0|  }
  460|      0|
  461|      0|  // This removeFetcher: invocation is a fallback; typically, fetchers are removed from the task
  462|      0|  // map when the task completes.
  463|      0|  GTMSessionFetcherSessionDelegateDispatcher *delegateDispatcher =
  464|      0|      [self delegateDispatcherForFetcher:fetcher];
  465|      0|  [delegateDispatcher removeFetcher:fetcher];
  466|      0|
  467|      0|  NSMutableArray *fetchersToStart;
  468|      0|
  469|      0|  @synchronized(self) {
  470|      0|    GTMSessionMonitorSynchronized(self);
  471|      0|
  472|      0|    // If a test is waiting for all fetchers to stop, it needs to wait for this one
  473|      0|    // to invoke its callbacks on the callback queue.
  474|      0|    [_stoppedFetchersToWaitFor addObject:fetcher];
  475|      0|
  476|      0|    NSMutableArray *runningForHost = [_runningFetchersByHost objectForKey:host];
  477|      0|    [runningForHost removeObject:fetcher];
  478|      0|
  479|      0|    NSMutableArray *delayedForHost = [_delayedFetchersByHost objectForKey:host];
  480|      0|    [delayedForHost removeObject:fetcher];
  481|      0|
  482|      0|    while (delayedForHost.count > 0
  483|      0|           && [[self class] numberOfNonBackgroundSessionFetchers:runningForHost]
  484|      0|              < _maxRunningFetchersPerHost) {
  485|      0|      // Start another delayed fetcher running, scanning for the minimum
  486|      0|      // priority value, defaulting to FIFO for equal priorities
  487|      0|      GTMSessionFetcher *nextFetcher = nil;
  488|      0|      for (GTMSessionFetcher *delayedFetcher in delayedForHost) {
  489|      0|        if (nextFetcher == nil
  490|      0|            || delayedFetcher.servicePriority < nextFetcher.servicePriority) {
  491|      0|          nextFetcher = delayedFetcher;
  492|      0|        }
  493|      0|      }
  494|      0|
  495|      0|      if (nextFetcher) {
  496|      0|        [self addRunningFetcher:nextFetcher forHost:host];
  497|      0|        runningForHost = [_runningFetchersByHost objectForKey:host];
  498|      0|
  499|      0|        [delayedForHost removeObjectIdenticalTo:nextFetcher];
  500|      0|
  501|      0|        if (!fetchersToStart) {
  502|      0|          fetchersToStart = [NSMutableArray array];
  503|      0|        }
  504|      0|        [fetchersToStart addObject:nextFetcher];
  505|      0|      }
  506|      0|    }
  507|      0|
  508|      0|    if (runningForHost.count == 0) {
  509|      0|      // None left; remove the empty array
  510|      0|      [_runningFetchersByHost removeObjectForKey:host];
  511|      0|    }
  512|      0|
  513|      0|    if (delayedForHost.count == 0) {
  514|      0|      [_delayedFetchersByHost removeObjectForKey:host];
  515|      0|    }
  516|      0|  }  // @synchronized(self)
  517|      0|
  518|      0|  // Start fetchers outside of the synchronized block to avoid a deadlock.
  519|      0|  for (GTMSessionFetcher *nextFetcher in fetchersToStart) {
  520|      0|    [self startFetcher:nextFetcher];
  521|      0|  }
  522|      0|
  523|      0|  // The fetcher is no longer in the running or the delayed array,
  524|      0|  // so remove its host and thread properties
  525|      0|  fetcher.serviceHost = nil;
  526|      0|}
  527|       |
  528|      0|- (NSUInteger)numberOfFetchers {
  529|      0|  NSUInteger running = [self numberOfRunningFetchers];
  530|      0|  NSUInteger delayed = [self numberOfDelayedFetchers];
  531|      0|  return running + delayed;
  532|      0|}
  533|       |
  534|      0|- (NSUInteger)numberOfRunningFetchers {
  535|      0|  @synchronized(self) {
  536|      0|    GTMSessionMonitorSynchronized(self);
  537|      0|
  538|      0|    NSUInteger sum = 0;
  539|      0|    for (NSString *host in _runningFetchersByHost) {
  540|      0|      NSArray *fetchers = [_runningFetchersByHost objectForKey:host];
  541|      0|      sum += fetchers.count;
  542|      0|    }
  543|      0|    return sum;
  544|      0|  }
  545|      0|}
  546|       |
  547|      0|- (NSUInteger)numberOfDelayedFetchers {
  548|      0|  @synchronized(self) {
  549|      0|    GTMSessionMonitorSynchronized(self);
  550|      0|
  551|      0|    NSUInteger sum = 0;
  552|      0|    for (NSString *host in _delayedFetchersByHost) {
  553|      0|      NSArray *fetchers = [_delayedFetchersByHost objectForKey:host];
  554|      0|      sum += fetchers.count;
  555|      0|    }
  556|      0|    return sum;
  557|      0|  }
  558|      0|}
  559|       |
  560|      0|- (NSArray *)issuedFetchers {
  561|      0|  @synchronized(self) {
  562|      0|    GTMSessionMonitorSynchronized(self);
  563|      0|
  564|      0|    NSMutableArray *allFetchers = [NSMutableArray array];
  565|      0|    void (^accumulateFetchers)(id, id, BOOL *) = ^(NSString *host,
  566|      0|                                                   NSArray *fetchersForHost,
  567|      0|                                                   BOOL *stop) {
  568|      0|        [allFetchers addObjectsFromArray:fetchersForHost];
  569|      0|    };
  570|      0|    [_runningFetchersByHost enumerateKeysAndObjectsUsingBlock:accumulateFetchers];
  571|      0|    [_delayedFetchersByHost enumerateKeysAndObjectsUsingBlock:accumulateFetchers];
  572|      0|
  573|      0|    GTMSESSION_ASSERT_DEBUG(allFetchers.count == [NSSet setWithArray:allFetchers].count,
  574|      0|                            @"Fetcher appears multiple times\n running: %@\n delayed: %@",
  575|      0|                            _runningFetchersByHost, _delayedFetchersByHost);
  576|      0|
  577|      0|    return allFetchers.count > 0 ? allFetchers : nil;
  578|      0|  }
  579|      0|}
  580|       |
  581|      0|- (NSArray *)issuedFetchersWithRequestURL:(NSURL *)requestURL {
  582|      0|  NSString *host = requestURL.host;
  583|      0|  if (host.length == 0) return nil;
  584|      0|
  585|      0|  NSURL *targetURL = [requestURL absoluteURL];
  586|      0|
  587|      0|  NSArray *allFetchers = [self issuedFetchers];
  588|      0|  NSIndexSet *indexes = [allFetchers indexesOfObjectsPassingTest:^BOOL(GTMSessionFetcher *fetcher,
  589|      0|                                                                       NSUInteger idx,
  590|      0|                                                                       BOOL *stop) {
  591|      0|      NSURL *fetcherURL = [fetcher.request.URL absoluteURL];
  592|      0|      return [fetcherURL isEqual:targetURL];
  593|      0|  }];
  594|      0|
  595|      0|  NSArray *result = nil;
  596|      0|  if (indexes.count > 0) {
  597|      0|    result = [allFetchers objectsAtIndexes:indexes];
  598|      0|  }
  599|      0|  return result;
  600|      0|}
  601|       |
  602|      0|- (void)stopAllFetchers {
  603|      0|  NSArray *delayedFetchersByHost;
  604|      0|  NSArray *runningFetchersByHost;
  605|      0|
  606|      0|  @synchronized(self) {
  607|      0|    GTMSessionMonitorSynchronized(self);
  608|      0|
  609|      0|    // Set the time barrier so fetchers know not to call back even if
  610|      0|    // the stop calls below occur after the fetchers naturally
  611|      0|    // stopped and so were removed from _runningFetchersByHost,
  612|      0|    // but while the callbacks were already enqueued before stopAllFetchers
  613|      0|    // was invoked.
  614|      0|    _stoppedAllFetchersDate = [[NSDate alloc] init];
  615|      0|
  616|      0|    // Remove fetchers from the delayed list to avoid fetcherDidStop: from
  617|      0|    // starting more fetchers running as a side effect of stopping one
  618|      0|    delayedFetchersByHost = _delayedFetchersByHost.allValues;
  619|      0|    [_delayedFetchersByHost removeAllObjects];
  620|      0|
  621|      0|    runningFetchersByHost = _runningFetchersByHost.allValues;
  622|      0|    [_runningFetchersByHost removeAllObjects];
  623|      0|  }
  624|      0|
  625|      0|  for (NSArray *delayedForHost in delayedFetchersByHost) {
  626|      0|    for (GTMSessionFetcher *fetcher in delayedForHost) {
  627|      0|      [self stopFetcher:fetcher];
  628|      0|    }
  629|      0|  }
  630|      0|
  631|      0|  for (NSArray *runningForHost in runningFetchersByHost) {
  632|      0|    for (GTMSessionFetcher *fetcher in runningForHost) {
  633|      0|      [self stopFetcher:fetcher];
  634|      0|    }
  635|      0|  }
  636|      0|}
  637|       |
  638|      0|- (NSDate *)stoppedAllFetchersDate {
  639|      0|  @synchronized(self) {
  640|      0|    GTMSessionMonitorSynchronized(self);
  641|      0|
  642|      0|    return _stoppedAllFetchersDate;
  643|      0|  }
  644|      0|}
  645|       |
  646|       |#pragma mark Accessors
  647|       |
  648|      0|- (BOOL)reuseSession {
  649|      0|  @synchronized(self) {
  650|      0|    GTMSessionMonitorSynchronized(self);
  651|      0|
  652|      0|    return _delegateDispatcher != nil;
  653|      0|  }
  654|      0|}
  655|       |
  656|      1|- (void)setReuseSession:(BOOL)shouldReuse {
  657|      1|  @synchronized(self) {
  658|      1|    GTMSessionMonitorSynchronized(self);
  659|      1|
  660|      1|    BOOL wasReusing = (_delegateDispatcher != nil);
  661|      1|    if (shouldReuse != wasReusing) {
  662|      1|      [self abandonDispatcher];
  663|      1|      if (shouldReuse) {
  664|      0|        _delegateDispatcher =
  665|      0|            [[GTMSessionFetcherSessionDelegateDispatcher alloc] initWithParentService:self
  666|      0|                                                               sessionDiscardInterval:_unusedSessionTimeout];
  667|      1|      } else {
  668|      1|        _delegateDispatcher = nil;
  669|      1|      }
  670|      1|    }
  671|      1|  }
  672|      1|}
  673|       |
  674|      0|- (void)resetSession {
  675|      0|  GTMSessionCheckNotSynchronized(self);
  676|      0|  dispatch_semaphore_wait(_sessionCreationSemaphore, DISPATCH_TIME_FOREVER);
  677|      0|
  678|      0|  @synchronized(self) {
  679|      0|    GTMSessionMonitorSynchronized(self);
  680|      0|    [self resetSessionInternal];
  681|      0|  }
  682|      0|
  683|      0|  dispatch_semaphore_signal(_sessionCreationSemaphore);
  684|      0|}
  685|       |
  686|      0|- (void)resetSessionInternal {
  687|      0|  GTMSessionCheckSynchronized(self);
  688|      0|
  689|      0|  // The old dispatchers may be retained as delegates of any ongoing sessions by those sessions.
  690|      0|  if (_delegateDispatcher) {
  691|      0|    [self abandonDispatcher];
  692|      0|    _delegateDispatcher =
  693|      0|        [[GTMSessionFetcherSessionDelegateDispatcher alloc] initWithParentService:self
  694|      0|                                                           sessionDiscardInterval:_unusedSessionTimeout];
  695|      0|  }
  696|      0|}
  697|       |
  698|      0|- (void)resetSessionForDispatcherDiscardTimer:(NSTimer *)timer {
  699|      0|  GTMSessionCheckNotSynchronized(self);
  700|      0|
  701|      0|  dispatch_semaphore_wait(_sessionCreationSemaphore, DISPATCH_TIME_FOREVER);
  702|      0|  @synchronized(self) {
  703|      0|    GTMSessionMonitorSynchronized(self);
  704|      0|
  705|      0|    if (_delegateDispatcher.discardTimer == timer) {
  706|      0|      // If the delegate dispatcher's current discardTimer is the same object as the timer
  707|      0|      // that fired, no fetcher has recently attempted to start using the session by calling
  708|      0|      // startSessionUsage, which invalidates and nils out the timer.
  709|      0|      [self resetSessionInternal];
  710|      0|    } else {
  711|      0|      // A fetcher has invalidated the timer between its triggering and now, potentially
  712|      0|      // meaning a fetcher has requested access to the NSURLSession, and may be in the process
  713|      0|      // of starting a new task. The dispatcher should not be abandoned, as this can lead
  714|      0|      // to a race condition between calling -finishTasksAndInvalidate on the NSURLSession
  715|      0|      // and the fetcher attempting to create a new task.
  716|      0|    }
  717|      0|  }
  718|      0|
  719|      0|  dispatch_semaphore_signal(_sessionCreationSemaphore);
  720|      0|}
  721|       |
  722|      0|- (NSTimeInterval)unusedSessionTimeout {
  723|      0|  @synchronized(self) {
  724|      0|    GTMSessionMonitorSynchronized(self);
  725|      0|
  726|      0|    return _unusedSessionTimeout;
  727|      0|  }
  728|      0|}
  729|       |
  730|      0|- (void)setUnusedSessionTimeout:(NSTimeInterval)timeout {
  731|      0|  @synchronized(self) {
  732|      0|    GTMSessionMonitorSynchronized(self);
  733|      0|
  734|      0|    _unusedSessionTimeout = timeout;
  735|      0|    _delegateDispatcher.discardInterval = timeout;
  736|      0|  }
  737|      0|}
  738|       |
  739|       |// This method should be called inside of @synchronized(self)
  740|      1|- (void)abandonDispatcher {
  741|      1|  GTMSessionCheckSynchronized(self);
  742|      1|  [_delegateDispatcher abandon];
  743|      1|}
  744|       |
  745|      0|- (NSDictionary *)runningFetchersByHost {
  746|      0|  @synchronized(self) {
  747|      0|    GTMSessionMonitorSynchronized(self);
  748|      0|
  749|      0|    return [_runningFetchersByHost copy];
  750|      0|  }
  751|      0|}
  752|       |
  753|      0|- (void)setRunningFetchersByHost:(NSDictionary *)dict {
  754|      0|  @synchronized(self) {
  755|      0|    GTMSessionMonitorSynchronized(self);
  756|      0|
  757|      0|    _runningFetchersByHost = [dict mutableCopy];
  758|      0|  }
  759|      0|}
  760|       |
  761|      0|- (NSDictionary *)delayedFetchersByHost {
  762|      0|  @synchronized(self) {
  763|      0|    GTMSessionMonitorSynchronized(self);
  764|      0|
  765|      0|    return [_delayedFetchersByHost copy];
  766|      0|  }
  767|      0|}
  768|       |
  769|      0|- (void)setDelayedFetchersByHost:(NSDictionary *)dict {
  770|      0|  @synchronized(self) {
  771|      0|    GTMSessionMonitorSynchronized(self);
  772|      0|
  773|      0|    _delayedFetchersByHost = [dict mutableCopy];
  774|      0|  }
  775|      0|}
  776|       |
  777|      1|- (id<GTMFetcherAuthorizationProtocol>)authorizer {
  778|      1|  @synchronized(self) {
  779|      1|    GTMSessionMonitorSynchronized(self);
  780|      1|
  781|      1|    return _authorizer;
  782|      1|  }
  783|      1|}
  784|       |
  785|      0|- (void)setAuthorizer:(id<GTMFetcherAuthorizationProtocol>)obj {
  786|      0|  @synchronized(self) {
  787|      0|    GTMSessionMonitorSynchronized(self);
  788|      0|
  789|      0|    if (obj != _authorizer) {
  790|      0|      [self detachAuthorizer];
  791|      0|    }
  792|      0|
  793|      0|    _authorizer = obj;
  794|      0|  }
  795|      0|
  796|      0|  // Use the fetcher service for the authorization fetches if the auth
  797|      0|  // object supports fetcher services
  798|      0|  if ([obj respondsToSelector:@selector(setFetcherService:)]) {
  799|      0|#if GTM_USE_SESSION_FETCHER
  800|      0|    [obj setFetcherService:self];
  801|       |#else
  802|       |    [obj setFetcherService:(id)self];
  803|       |#endif
  804|       |  }
  805|      0|}
  806|       |
  807|       |// This should be called inside a @synchronized(self) block except during dealloc.
  808|      0|- (void)detachAuthorizer {
  809|      0|  // This method is called by the fetcher service's dealloc and setAuthorizer:
  810|      0|  // methods; do not override.
  811|      0|  //
  812|      0|  // The fetcher service retains the authorizer, and the authorizer has a
  813|      0|  // weak pointer to the fetcher service (a non-zeroing pointer for
  814|      0|  // compatibility with iOS 4 and Mac OS X 10.5/10.6.)
  815|      0|  //
  816|      0|  // When this fetcher service no longer uses the authorizer, we want to remove
  817|      0|  // the authorizer's dependence on the fetcher service.  Authorizers can still
  818|      0|  // function without a fetcher service.
  819|      0|  if ([_authorizer respondsToSelector:@selector(fetcherService)]) {
  820|      0|    id authFetcherService = [_authorizer fetcherService];
  821|      0|    if (authFetcherService == self) {
  822|      0|      [_authorizer setFetcherService:nil];
  823|      0|    }
  824|      0|  }
  825|      0|}
  826|       |
  827|      1|- (dispatch_queue_t GTM_NONNULL_TYPE)callbackQueue {
  828|      1|  @synchronized(self) {
  829|      1|    GTMSessionMonitorSynchronized(self);
  830|      1|
  831|      1|    return _callbackQueue;
  832|      1|  }  // @synchronized(self)
  833|      1|}
  834|       |
  835|      1|- (void)setCallbackQueue:(dispatch_queue_t GTM_NULLABLE_TYPE)queue {
  836|      1|  @synchronized(self) {
  837|      1|    GTMSessionMonitorSynchronized(self);
  838|      1|
  839|      1|    _callbackQueue = queue ?: dispatch_get_main_queue();
  840|      1|  }  // @synchronized(self)
  841|      1|}
  842|       |
  843|      1|- (NSOperationQueue * GTM_NONNULL_TYPE)sessionDelegateQueue {
  844|      1|  @synchronized(self) {
  845|      1|    GTMSessionMonitorSynchronized(self);
  846|      1|
  847|      1|    return _delegateQueue;
  848|      1|  }  // @synchronized(self)
  849|      1|}
  850|       |
  851|      0|- (void)setSessionDelegateQueue:(NSOperationQueue * GTM_NULLABLE_TYPE)queue {
  852|      0|  @synchronized(self) {
  853|      0|    GTMSessionMonitorSynchronized(self);
  854|      0|
  855|      0|    _delegateQueue = queue ?: [NSOperationQueue mainQueue];
  856|      0|  }  // @synchronized(self)
  857|      0|}
  858|       |
  859|      0|- (NSOperationQueue *)delegateQueue {
  860|      0|  // Provided for compatibility with the old fetcher service.  The gtm-oauth2 code respects
  861|      0|  // any custom delegate queue for calling the app.
  862|      0|  return nil;
  863|      0|}
  864|       |
  865|      1|+ (NSUInteger)numberOfNonBackgroundSessionFetchers:(NSArray *)fetchers {
  866|      1|  NSUInteger sum = 0;
  867|      1|  for (GTMSessionFetcher *fetcher in fetchers) {
  868|      0|    if (!fetcher.usingBackgroundSession) {
  869|      0|      ++sum;
  870|      0|    }
  871|      0|  }
  872|      1|  return sum;
  873|      1|}
  874|       |
  875|       |@end
  876|       |
  877|       |@implementation GTMSessionFetcherService (TestingSupport)
  878|       |
  879|       |+ (instancetype)mockFetcherServiceWithFakedData:(NSData *)fakedDataOrNil
  880|      0|                                     fakedError:(NSError *)fakedErrorOrNil {
  881|      0|#if !GTM_DISABLE_FETCHER_TEST_BLOCK
  882|      0|  NSURL *url = [NSURL URLWithString:@"http://example.invalid"];
  883|      0|  NSHTTPURLResponse *fakedResponse =
  884|      0|      [[NSHTTPURLResponse alloc] initWithURL:url
  885|      0|                                  statusCode:(fakedErrorOrNil ? 500 : 200)
  886|      0|                                 HTTPVersion:@"HTTP/1.1"
  887|      0|                                headerFields:nil];
  888|      0|  return [self mockFetcherServiceWithFakedData:fakedDataOrNil
  889|      0|                                 fakedResponse:fakedResponse
  890|      0|                                    fakedError:fakedErrorOrNil];
  891|       |#else
  892|       |  GTMSESSION_ASSERT_DEBUG(0, @"Test blocks disabled");
  893|       |  return nil;
  894|       |#endif  // GTM_DISABLE_FETCHER_TEST_BLOCK
  895|       |}
  896|       |
  897|       |+ (instancetype)mockFetcherServiceWithFakedData:(NSData *)fakedDataOrNil
  898|       |                                  fakedResponse:(NSHTTPURLResponse *)fakedResponse
  899|      0|                                     fakedError:(NSError *)fakedErrorOrNil {
  900|      0|#if !GTM_DISABLE_FETCHER_TEST_BLOCK
  901|      0|  GTMSessionFetcherService *service = [[self alloc] init];
  902|      0|  service.allowedInsecureSchemes = @[ @"http" ];
  903|      0|  service.testBlock = ^(GTMSessionFetcher *fetcherToTest,
  904|      0|                        GTMSessionFetcherTestResponse testResponse) {
  905|      0|    testResponse(fakedResponse, fakedDataOrNil, fakedErrorOrNil);
  906|      0|  };
  907|      0|  return service;
  908|       |#else
  909|       |  GTMSESSION_ASSERT_DEBUG(0, @"Test blocks disabled");
  910|       |  return nil;
  911|       |#endif  // GTM_DISABLE_FETCHER_TEST_BLOCK
  912|       |}
  913|       |
  914|       |#pragma mark Synchronous Wait for Unit Testing
  915|       |
  916|      0|- (BOOL)waitForCompletionOfAllFetchersWithTimeout:(NSTimeInterval)timeoutInSeconds {
  917|      0|  NSDate *giveUpDate = [NSDate dateWithTimeIntervalSinceNow:timeoutInSeconds];
  918|      0|  _stoppedFetchersToWaitFor = [NSMutableArray array];
  919|      0|
  920|      0|  BOOL shouldSpinRunLoop = [NSThread isMainThread];
  921|      0|  const NSTimeInterval kSpinInterval = 0.001;
  922|      0|  BOOL didTimeOut = NO;
  923|      0|  while (([self numberOfFetchers] > 0 || _stoppedFetchersToWaitFor.count > 0)) {
  924|      0|    didTimeOut = [giveUpDate timeIntervalSinceNow] < 0;
  925|      0|    if (didTimeOut) break;
  926|      0|
  927|      0|    GTMSessionFetcher *stoppedFetcher = _stoppedFetchersToWaitFor.firstObject;
  928|      0|    if (stoppedFetcher) {
  929|      0|      [_stoppedFetchersToWaitFor removeObject:stoppedFetcher];
  930|      0|      [stoppedFetcher waitForCompletionWithTimeout:10.0 * kSpinInterval];
  931|      0|    }
  932|      0|
  933|      0|    if (shouldSpinRunLoop) {
  934|      0|      NSDate *stopDate = [NSDate dateWithTimeIntervalSinceNow:kSpinInterval];
  935|      0|      [[NSRunLoop currentRunLoop] runUntilDate:stopDate];
  936|      0|    } else {
  937|      0|      [NSThread sleepForTimeInterval:kSpinInterval];
  938|      0|    }
  939|      0|  }
  940|      0|  _stoppedFetchersToWaitFor = nil;
  941|      0|
  942|      0|  return !didTimeOut;
  943|      0|}
  944|       |
  945|       |@end
  946|       |
  947|       |@implementation GTMSessionFetcherService (BackwardsCompatibilityOnly)
  948|       |
  949|      1|- (NSInteger)cookieStorageMethod {
  950|      1|  @synchronized(self) {
  951|      1|    GTMSessionMonitorSynchronized(self);
  952|      1|
  953|      1|    return _cookieStorageMethod;
  954|      1|  }
  955|      1|}
  956|       |
  957|      0|- (void)setCookieStorageMethod:(NSInteger)cookieStorageMethod {
  958|      0|  @synchronized(self) {
  959|      0|    GTMSessionMonitorSynchronized(self);
  960|      0|
  961|      0|    _cookieStorageMethod = cookieStorageMethod;
  962|      0|  }
  963|      0|}
  964|       |
  965|       |@end
  966|       |
  967|       |@implementation GTMSessionFetcherSessionDelegateDispatcher {
  968|       |  __weak GTMSessionFetcherService *_parentService;
  969|       |  NSURLSession *_session;
  970|       |
  971|       |  // The task map maps NSURLSessionTasks to GTMSessionFetchers
  972|       |  NSMutableDictionary *_taskToFetcherMap;
  973|       |  // The discard timer will invalidate sessions after the session's last task completes.
  974|       |  NSTimer *_discardTimer;
  975|       |  NSTimeInterval _discardInterval;
  976|       |}
  977|       |
  978|       |@synthesize discardInterval = _discardInterval,
  979|       |            session = _session;
  980|       |
  981|      0|- (instancetype)init {
  982|      0|  [self doesNotRecognizeSelector:_cmd];
  983|      0|  return nil;
  984|      0|}
  985|       |
  986|       |- (instancetype)initWithParentService:(GTMSessionFetcherService *)parentService
  987|      1|               sessionDiscardInterval:(NSTimeInterval)discardInterval {
  988|      1|  self = [super init];
  989|      1|  if (self) {
  990|      1|    _discardInterval = discardInterval;
  991|      1|    _parentService = parentService;
  992|      1|  }
  993|      1|  return self;
  994|      1|}
  995|       |
  996|      0|- (NSString *)description {
  997|      0|  return [NSString stringWithFormat:@"%@ %p %@ %@",
  998|      0|          [self class], self,
  999|      0|          _session ?: @"<no session>",
 1000|      0|          _taskToFetcherMap.count > 0 ? _taskToFetcherMap : @"<no tasks>"];
 1001|      0|}
 1002|       |
 1003|      0|- (NSTimer *)discardTimer {
 1004|      0|  GTMSessionCheckNotSynchronized(self);
 1005|      0|  @synchronized(self) {
 1006|      0|    return _discardTimer;
 1007|      0|  }
 1008|      0|}
 1009|       |
 1010|       |// This method should be called inside of a @synchronized(self) block.
 1011|      0|- (void)startDiscardTimer {
 1012|      0|  GTMSessionCheckSynchronized(self);
 1013|      0|  [_discardTimer invalidate];
 1014|      0|  _discardTimer = nil;
 1015|      0|  if (_discardInterval > 0) {
 1016|      0|    _discardTimer = [NSTimer timerWithTimeInterval:_discardInterval
 1017|      0|                                            target:self
 1018|      0|                                          selector:@selector(discardTimerFired:)
 1019|      0|                                          userInfo:nil
 1020|      0|                                           repeats:NO];
 1021|      0|    [_discardTimer setTolerance:(_discardInterval / 10)];
 1022|      0|    [[NSRunLoop mainRunLoop] addTimer:_discardTimer forMode:NSRunLoopCommonModes];
 1023|      0|  }
 1024|      0|}
 1025|       |
 1026|       |// This method should be called inside of a @synchronized(self) block.
 1027|      1|- (void)destroyDiscardTimer {
 1028|      1|  GTMSessionCheckSynchronized(self);
 1029|      1|  [_discardTimer invalidate];
 1030|      1|  _discardTimer = nil;
 1031|      1|}
 1032|       |
 1033|      0|- (void)discardTimerFired:(NSTimer *)timer {
 1034|      0|  GTMSessionFetcherService *service;
 1035|      0|  @synchronized(self) {
 1036|      0|    GTMSessionMonitorSynchronized(self);
 1037|      0|
 1038|      0|    NSUInteger numberOfTasks = _taskToFetcherMap.count;
 1039|      0|    if (numberOfTasks == 0) {
 1040|      0|      service = _parentService;
 1041|      0|    }
 1042|      0|  }
 1043|      0|
 1044|      0|  // Inform the service that the discard timer has fired, and should check whether the
 1045|      0|  // service can abandon us. -resetSession cannot be called directly, as there is a
 1046|      0|  // race condition that must be guarded against with the NSURLSession being returned
 1047|      0|  // from sessionForFetcherCreation outside other locks. The service can take steps
 1048|      0|  // to prevent resetting the session if that has occurred.
 1049|      0|  //
 1050|      0|  // The service must be called from outside the @synchronized block.
 1051|      0|  [service resetSessionForDispatcherDiscardTimer:timer];
 1052|      0|}
 1053|       |
 1054|      1|- (void)abandon {
 1055|      1|  @synchronized(self) {
 1056|      1|    GTMSessionMonitorSynchronized(self);
 1057|      1|
 1058|      1|    [self destroySessionAndTimer];
 1059|      1|  }
 1060|      1|}
 1061|       |
 1062|      0|- (void)startSessionUsage {
 1063|      0|  @synchronized(self) {
 1064|      0|    GTMSessionMonitorSynchronized(self);
 1065|      0|
 1066|      0|    [self destroyDiscardTimer];
 1067|      0|  }
 1068|      0|}
 1069|       |
 1070|       |// This method should be called inside of a @synchronized(self) block.
 1071|      1|- (void)destroySessionAndTimer {
 1072|      1|  GTMSessionCheckSynchronized(self);
 1073|      1|  [self destroyDiscardTimer];
 1074|      1|
 1075|      1|  // Break any retain cycle from the session holding the delegate.
 1076|      1|  [_session finishTasksAndInvalidate];
 1077|      1|
 1078|      1|  // Immediately clear the session so no new task may be issued with it.
 1079|      1|  //
 1080|      1|  // The _taskToFetcherMap needs to stay valid until the outstanding tasks finish.
 1081|      1|  _session = nil;
 1082|      1|}
 1083|       |
 1084|      0|- (void)setFetcher:(GTMSessionFetcher *)fetcher forTask:(NSURLSessionTask *)task {
 1085|      0|  GTMSESSION_ASSERT_DEBUG(fetcher != nil, @"missing fetcher");
 1086|      0|
 1087|      0|  @synchronized(self) {
 1088|      0|    GTMSessionMonitorSynchronized(self);
 1089|      0|
 1090|      0|    if (_taskToFetcherMap == nil) {
 1091|      0|      _taskToFetcherMap = [[NSMutableDictionary alloc] init];
 1092|      0|    }
 1093|      0|
 1094|      0|    if (fetcher) {
 1095|      0|      [_taskToFetcherMap setObject:fetcher forKey:task];
 1096|      0|      [self destroyDiscardTimer];
 1097|      0|    }
 1098|      0|  }
 1099|      0|}
 1100|       |
 1101|      0|- (void)removeFetcher:(GTMSessionFetcher *)fetcher {
 1102|      0|  @synchronized(self) {
 1103|      0|    GTMSessionMonitorSynchronized(self);
 1104|      0|
 1105|      0|    // Typically, a fetcher should be removed when its task invokes
 1106|      0|    // URLSession:task:didCompleteWithError:.
 1107|      0|    //
 1108|      0|    // When fetching with a testBlock, though, the task completed delegate
 1109|      0|    // method may not be invoked, requiring cleanup here.
 1110|      0|    NSArray *tasks = [_taskToFetcherMap allKeysForObject:fetcher];
 1111|      0|    GTMSESSION_ASSERT_DEBUG(tasks.count <= 1, @"fetcher task not unmapped: %@", tasks);
 1112|      0|    [_taskToFetcherMap removeObjectsForKeys:tasks];
 1113|      0|
 1114|      0|    if (_taskToFetcherMap.count == 0) {
 1115|      0|      [self startDiscardTimer];
 1116|      0|    }
 1117|      0|  }
 1118|      0|}
 1119|       |
 1120|       |// This helper method provides synchronized access to the task map for the delegate
 1121|       |// methods below.
 1122|      0|- (id)fetcherForTask:(NSURLSessionTask *)task {
 1123|      0|  @synchronized(self) {
 1124|      0|    GTMSessionMonitorSynchronized(self);
 1125|      0|
 1126|      0|    return [_taskToFetcherMap objectForKey:task];
 1127|      0|  }
 1128|      0|}
 1129|       |
 1130|      0|- (void)removeTaskFromMap:(NSURLSessionTask *)task {
 1131|      0|  @synchronized(self) {
 1132|      0|    GTMSessionMonitorSynchronized(self);
 1133|      0|
 1134|      0|    [_taskToFetcherMap removeObjectForKey:task];
 1135|      0|  }
 1136|      0|}
 1137|       |
 1138|      0|- (void)setSession:(NSURLSession *)session {
 1139|      0|  @synchronized(self) {
 1140|      0|    GTMSessionMonitorSynchronized(self);
 1141|      0|
 1142|      0|    _session = session;
 1143|      0|  }
 1144|      0|}
 1145|       |
 1146|      0|- (NSURLSession *)session {
 1147|      0|  @synchronized(self) {
 1148|      0|    GTMSessionMonitorSynchronized(self);
 1149|      0|
 1150|      0|    return _session;
 1151|      0|  }
 1152|      0|}
 1153|       |
 1154|      0|- (NSTimeInterval)discardInterval {
 1155|      0|  @synchronized(self) {
 1156|      0|    GTMSessionMonitorSynchronized(self);
 1157|      0|
 1158|      0|    return _discardInterval;
 1159|      0|  }
 1160|      0|}
 1161|       |
 1162|      0|- (void)setDiscardInterval:(NSTimeInterval)interval {
 1163|      0|  @synchronized(self) {
 1164|      0|    GTMSessionMonitorSynchronized(self);
 1165|      0|
 1166|      0|    _discardInterval = interval;
 1167|      0|  }
 1168|      0|}
 1169|       |
 1170|       |// NSURLSessionDelegate protocol methods.
 1171|       |
 1172|       |// - (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session;
 1173|       |//
 1174|       |// TODO(seh): How do we route this to an appropriate fetcher?
 1175|       |
 1176|       |
 1177|      0|- (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(NSError *)error {
 1178|      0|  GTM_LOG_SESSION_DELEGATE(@"%@ %p URLSession:%@ didBecomeInvalidWithError:%@",
 1179|      0|                           [self class], self, session, error);
 1180|      0|  NSDictionary *localTaskToFetcherMap;
 1181|      0|  @synchronized(self) {
 1182|      0|    GTMSessionMonitorSynchronized(self);
 1183|      0|
 1184|      0|    _session = nil;
 1185|      0|
 1186|      0|    localTaskToFetcherMap = [_taskToFetcherMap copy];
 1187|      0|  }
 1188|      0|
 1189|      0|  // Any "suspended" tasks may not have received callbacks from NSURLSession when the session
 1190|      0|  // completes; we'll call them now.
 1191|      0|  [localTaskToFetcherMap enumerateKeysAndObjectsUsingBlock:^(NSURLSessionTask *task,
 1192|      0|                                                             GTMSessionFetcher *fetcher,
 1193|      0|                                                             BOOL *stop) {
 1194|      0|    if (fetcher.session == session) {
 1195|      0|        // Our delegate method URLSession:task:didCompleteWithError: will rely on
 1196|      0|        // _taskToFetcherMap so that should still contain this fetcher.
 1197|      0|        NSError *canceledError = [NSError errorWithDomain:NSURLErrorDomain
 1198|      0|                                                     code:NSURLErrorCancelled
 1199|      0|                                                 userInfo:nil];
 1200|      0|        [self URLSession:session task:task didCompleteWithError:canceledError];
 1201|      0|      } else {
 1202|      0|        GTMSESSION_ASSERT_DEBUG(0, @"Unexpected session in fetcher: %@ has %@ (expected %@)",
 1203|      0|                                fetcher, fetcher.session, session);
 1204|      0|      }
 1205|      0|  }];
 1206|      0|
 1207|      0|  // Our tests rely on this notification to know the session discard timer fired.
 1208|      0|  NSDictionary *userInfo = @{ kGTMSessionFetcherServiceSessionKey : session };
 1209|      0|  NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
 1210|      0|  [nc postNotificationName:kGTMSessionFetcherServiceSessionBecameInvalidNotification
 1211|      0|                    object:_parentService
 1212|      0|                  userInfo:userInfo];
 1213|      0|}
 1214|       |
 1215|       |
 1216|       |#pragma mark - NSURLSessionTaskDelegate
 1217|       |
 1218|       |// NSURLSessionTaskDelegate protocol methods.
 1219|       |//
 1220|       |// We won't test here if the fetcher responds to these since we only want this
 1221|       |// class to implement the same delegate methods the fetcher does (so NSURLSession's
 1222|       |// tests for respondsToSelector: will have the same result whether the session
 1223|       |// delegate is the fetcher or this dispatcher.)
 1224|       |
 1225|       |- (void)URLSession:(NSURLSession *)session
 1226|       |              task:(NSURLSessionTask *)task
 1227|       |willPerformHTTPRedirection:(NSHTTPURLResponse *)response
 1228|       |        newRequest:(NSURLRequest *)request
 1229|      0| completionHandler:(void (^)(NSURLRequest *))completionHandler {
 1230|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1231|      0|  [fetcher URLSession:session
 1232|      0|                 task:task
 1233|      0|willPerformHTTPRedirection:response
 1234|      0|           newRequest:request
 1235|      0|    completionHandler:completionHandler];
 1236|      0|}
 1237|       |
 1238|       |- (void)URLSession:(NSURLSession *)session
 1239|       |              task:(NSURLSessionTask *)task
 1240|       |didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
 1241|      0| completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *))handler {
 1242|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1243|      0|  [fetcher URLSession:session
 1244|      0|                 task:task
 1245|      0|  didReceiveChallenge:challenge
 1246|      0|    completionHandler:handler];
 1247|      0|}
 1248|       |
 1249|       |- (void)URLSession:(NSURLSession *)session
 1250|       |              task:(NSURLSessionTask *)task
 1251|      0| needNewBodyStream:(void (^)(NSInputStream *bodyStream))handler {
 1252|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1253|      0|  [fetcher URLSession:session
 1254|      0|                 task:task
 1255|      0|    needNewBodyStream:handler];
 1256|      0|}
 1257|       |
 1258|       |- (void)URLSession:(NSURLSession *)session
 1259|       |              task:(NSURLSessionTask *)task
 1260|       |   didSendBodyData:(int64_t)bytesSent
 1261|       |    totalBytesSent:(int64_t)totalBytesSent
 1262|      0|totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
 1263|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1264|      0|  [fetcher URLSession:session
 1265|      0|                 task:task
 1266|      0|      didSendBodyData:bytesSent
 1267|      0|       totalBytesSent:totalBytesSent
 1268|      0|totalBytesExpectedToSend:totalBytesExpectedToSend];
 1269|      0|}
 1270|       |
 1271|       |- (void)URLSession:(NSURLSession *)session
 1272|       |              task:(NSURLSessionTask *)task
 1273|      0|didCompleteWithError:(NSError *)error {
 1274|      0|  id<NSURLSessionTaskDelegate> fetcher = [self fetcherForTask:task];
 1275|      0|
 1276|      0|  // This is the usual way tasks are removed from the task map.
 1277|      0|  [self removeTaskFromMap:task];
 1278|      0|
 1279|      0|  [fetcher URLSession:session
 1280|      0|                 task:task
 1281|      0| didCompleteWithError:error];
 1282|      0|}
 1283|       |
 1284|       |// NSURLSessionDataDelegate protocol methods.
 1285|       |
 1286|       |- (void)URLSession:(NSURLSession *)session
 1287|       |          dataTask:(NSURLSessionDataTask *)dataTask
 1288|       |didReceiveResponse:(NSURLResponse *)response
 1289|      0| completionHandler:(void (^)(NSURLSessionResponseDisposition))handler {
 1290|      0|  id<NSURLSessionDataDelegate> fetcher = [self fetcherForTask:dataTask];
 1291|      0|  [fetcher URLSession:session
 1292|      0|             dataTask:dataTask
 1293|      0|   didReceiveResponse:response
 1294|      0|    completionHandler:handler];
 1295|      0|}
 1296|       |
 1297|       |- (void)URLSession:(NSURLSession *)session
 1298|       |          dataTask:(NSURLSessionDataTask *)dataTask
 1299|      0|didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask {
 1300|      0|  id<NSURLSessionDataDelegate> fetcher = [self fetcherForTask:dataTask];
 1301|      0|  GTMSESSION_ASSERT_DEBUG(fetcher != nil, @"Missing fetcher for %@", dataTask);
 1302|      0|  [self removeTaskFromMap:dataTask];
 1303|      0|  if (fetcher) {
 1304|      0|    GTMSESSION_ASSERT_DEBUG([fetcher isKindOfClass:[GTMSessionFetcher class]],
 1305|      0|                            @"Expecting GTMSessionFetcher");
 1306|      0|    [self setFetcher:(GTMSessionFetcher *)fetcher forTask:downloadTask];
 1307|      0|  }
 1308|      0|
 1309|      0|  [fetcher URLSession:session
 1310|      0|             dataTask:dataTask
 1311|      0|didBecomeDownloadTask:downloadTask];
 1312|      0|}
 1313|       |
 1314|       |- (void)URLSession:(NSURLSession *)session
 1315|       |          dataTask:(NSURLSessionDataTask *)dataTask
 1316|      0|    didReceiveData:(NSData *)data {
 1317|      0|  id<NSURLSessionDataDelegate> fetcher = [self fetcherForTask:dataTask];
 1318|      0|  [fetcher URLSession:session
 1319|      0|             dataTask:dataTask
 1320|      0|       didReceiveData:data];
 1321|      0|}
 1322|       |
 1323|       |- (void)URLSession:(NSURLSession *)session
 1324|       |          dataTask:(NSURLSessionDataTask *)dataTask
 1325|       | willCacheResponse:(NSCachedURLResponse *)proposedResponse
 1326|      0| completionHandler:(void (^)(NSCachedURLResponse *))handler {
 1327|      0|  id<NSURLSessionDataDelegate> fetcher = [self fetcherForTask:dataTask];
 1328|      0|  [fetcher URLSession:session
 1329|      0|             dataTask:dataTask
 1330|      0|    willCacheResponse:proposedResponse
 1331|      0|    completionHandler:handler];
 1332|      0|}
 1333|       |
 1334|       |// NSURLSessionDownloadDelegate protocol methods.
 1335|       |
 1336|       |- (void)URLSession:(NSURLSession *)session
 1337|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 1338|      0|didFinishDownloadingToURL:(NSURL *)location {
 1339|      0|  id<NSURLSessionDownloadDelegate> fetcher = [self fetcherForTask:downloadTask];
 1340|      0|  [fetcher URLSession:session
 1341|      0|         downloadTask:downloadTask
 1342|      0|didFinishDownloadingToURL:location];
 1343|      0|}
 1344|       |
 1345|       |- (void)URLSession:(NSURLSession *)session
 1346|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 1347|       |      didWriteData:(int64_t)bytesWritten
 1348|       | totalBytesWritten:(int64_t)totalWritten
 1349|      0|totalBytesExpectedToWrite:(int64_t)totalExpected {
 1350|      0|  id<NSURLSessionDownloadDelegate> fetcher = [self fetcherForTask:downloadTask];
 1351|      0|  [fetcher URLSession:session
 1352|      0|         downloadTask:downloadTask
 1353|      0|         didWriteData:bytesWritten
 1354|      0|    totalBytesWritten:totalWritten
 1355|      0|totalBytesExpectedToWrite:totalExpected];
 1356|      0|}
 1357|       |
 1358|       |- (void)URLSession:(NSURLSession *)session
 1359|       |      downloadTask:(NSURLSessionDownloadTask *)downloadTask
 1360|       | didResumeAtOffset:(int64_t)fileOffset
 1361|      0|expectedTotalBytes:(int64_t)expectedTotalBytes {
 1362|      0|  id<NSURLSessionDownloadDelegate> fetcher = [self fetcherForTask:downloadTask];
 1363|      0|  [fetcher URLSession:session
 1364|      0|         downloadTask:downloadTask
 1365|      0|    didResumeAtOffset:fileOffset
 1366|      0|   expectedTotalBytes:expectedTotalBytes];
 1367|      0|}
 1368|       |
 1369|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/GTMSessionFetcher/Source/GTMSessionUploadFetcher.m:
    1|       |/* Copyright 2014 Google Inc. All rights reserved.
    2|       | *
    3|       | * Licensed under the Apache License, Version 2.0 (the "License");
    4|       | * you may not use this file except in compliance with the License.
    5|       | * You may obtain a copy of the License at
    6|       | *
    7|       | * http://www.apache.org/licenses/LICENSE-2.0
    8|       | *
    9|       | * Unless required by applicable law or agreed to in writing, software
   10|       | * distributed under the License is distributed on an "AS IS" BASIS,
   11|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       | * See the License for the specific language governing permissions and
   13|       | * limitations under the License.
   14|       | */
   15|       |
   16|       |#if !defined(__has_feature) || !__has_feature(objc_arc)
   17|       |#error "This file requires ARC support."
   18|       |#endif
   19|       |
   20|       |#import "GTMSessionUploadFetcher.h"
   21|       |
   22|       |static NSString *const kGTMSessionIdentifierIsUploadChunkFetcherMetadataKey = @"_upChunk";
   23|       |static NSString *const kGTMSessionIdentifierUploadFileURLMetadataKey        = @"_upFileURL";
   24|       |static NSString *const kGTMSessionIdentifierUploadFileLengthMetadataKey     = @"_upFileLen";
   25|       |static NSString *const kGTMSessionIdentifierUploadLocationURLMetadataKey    = @"_upLocURL";
   26|       |static NSString *const kGTMSessionIdentifierUploadMIMETypeMetadataKey       = @"_uploadMIME";
   27|       |static NSString *const kGTMSessionIdentifierUploadChunkSizeMetadataKey      = @"_upChSize";
   28|       |static NSString *const kGTMSessionIdentifierUploadCurrentOffsetMetadataKey  = @"_upOffset";
   29|       |static NSString *const kGTMSessionIdentifierUploadAllowsCellularAccess      = @"_upAllowsCellularAccess";
   30|       |
   31|       |static NSString *const kGTMSessionHeaderXGoogUploadChunkGranularity = @"X-Goog-Upload-Chunk-Granularity";
   32|       |static NSString *const kGTMSessionHeaderXGoogUploadCommand          = @"X-Goog-Upload-Command";
   33|       |static NSString *const kGTMSessionHeaderXGoogUploadContentLength    = @"X-Goog-Upload-Content-Length";
   34|       |static NSString *const kGTMSessionHeaderXGoogUploadContentType      = @"X-Goog-Upload-Content-Type";
   35|       |static NSString *const kGTMSessionHeaderXGoogUploadOffset           = @"X-Goog-Upload-Offset";
   36|       |static NSString *const kGTMSessionHeaderXGoogUploadProtocol         = @"X-Goog-Upload-Protocol";
   37|       |static NSString *const kGTMSessionXGoogUploadProtocolResumable      = @"resumable";
   38|       |static NSString *const kGTMSessionHeaderXGoogUploadSizeReceived     = @"X-Goog-Upload-Size-Received";
   39|       |static NSString *const kGTMSessionHeaderXGoogUploadStatus           = @"X-Goog-Upload-Status";
   40|       |static NSString *const kGTMSessionHeaderXGoogUploadURL              = @"X-Goog-Upload-URL";
   41|       |
   42|       |// Property of chunk fetchers identifying the parent upload fetcher.  Non-retained NSValue.
   43|       |static NSString *const kGTMSessionUploadFetcherChunkParentKey = @"_uploadFetcherChunkParent";
   44|       |
   45|       |int64_t const kGTMSessionUploadFetcherUnknownFileSize = -1;
   46|       |
   47|       |int64_t const kGTMSessionUploadFetcherStandardChunkSize = (int64_t)LLONG_MAX;
   48|       |
   49|       |#if TARGET_OS_IPHONE
   50|       |int64_t const kGTMSessionUploadFetcherMaximumDemandBufferSize = 10 * 1024 * 1024;  // 10 MB for iOS, watchOS, tvOS
   51|       |#else
   52|       |int64_t const kGTMSessionUploadFetcherMaximumDemandBufferSize = 100 * 1024 * 1024;  // 100 MB for macOS
   53|       |#endif
   54|       |
   55|       |typedef NS_ENUM(NSUInteger, GTMSessionUploadFetcherStatus) {
   56|       |  kStatusUnknown,
   57|       |  kStatusActive,
   58|       |  kStatusFinal,
   59|       |  kStatusCancelled,
   60|       |};
   61|       |
   62|       |NSString *const kGTMSessionFetcherUploadLocationObtainedNotification =
   63|       |    @"kGTMSessionFetcherUploadLocationObtainedNotification";
   64|       |
   65|       |#if !GTMSESSION_BUILD_COMBINED_SOURCES
   66|       |@interface GTMSessionFetcher (ProtectedMethods)
   67|       |
   68|       |// Access to non-public method on the parent fetcher class.
   69|       |- (void)stopFetchReleasingCallbacks:(BOOL)shouldReleaseCallbacks;
   70|       |- (void)createSessionIdentifierWithMetadata:(NSDictionary *)metadata;
   71|       |- (GTMSessionFetcherCompletionHandler)completionHandlerWithTarget:(id)target
   72|       |                                                didFinishSelector:(SEL)finishedSelector;
   73|       |- (void)invokeOnCallbackQueue:(dispatch_queue_t)callbackQueue
   74|       |             afterUserStopped:(BOOL)afterStopped
   75|       |                        block:(void (^)(void))block;
   76|       |- (NSTimer *)retryTimer;
   77|       |- (void)beginFetchForRetry;
   78|       |
   79|       |@property(readwrite, strong) NSData *downloadedData;
   80|       |- (void)releaseCallbacks;
   81|       |
   82|       |- (NSInteger)statusCodeUnsynchronized;
   83|       |
   84|       |- (BOOL)userStoppedFetching;
   85|       |
   86|       |@end
   87|       |#endif  // !GTMSESSION_BUILD_COMBINED_SOURCES
   88|       |
   89|       |@interface GTMSessionUploadFetcher ()
   90|       |
   91|       |// Changing readonly to readwrite.
   92|       |@property(atomic, strong, readwrite) NSURLRequest *lastChunkRequest;
   93|       |@property(atomic, readwrite, assign) int64_t currentOffset;
   94|       |
   95|       |// Internal properties.
   96|       |@property(strong, atomic, GTM_NULLABLE) GTMSessionFetcher *fetcherInFlight;  // Synchronized on self.
   97|       |
   98|       |@property(assign, atomic, getter=isSubdataGenerating) BOOL subdataGenerating;
   99|       |@property(assign, atomic) BOOL shouldInitiateOffsetQuery;
  100|       |@property(assign, atomic) int64_t uploadGranularity;
  101|       |@property(assign, atomic) BOOL allowsCellularAccess;
  102|       |
  103|       |@end
  104|       |
  105|       |@implementation GTMSessionUploadFetcher {
  106|       |  GTMSessionFetcher *_chunkFetcher;
  107|       |
  108|       |  // We'll call through to the delegate's completion handler.
  109|       |  GTMSessionFetcherCompletionHandler _delegateCompletionHandler;
  110|       |  dispatch_queue_t _delegateCallbackQueue;
  111|       |
  112|       |  // The initial fetch's body length and bytes actually sent are
  113|       |  // needed for calculating progress during subsequent chunk uploads
  114|       |  int64_t _initialBodyLength;
  115|       |  int64_t _initialBodySent;
  116|       |
  117|       |  // The upload server address for the chunks of this upload session.
  118|       |  NSURL *_uploadLocationURL;
  119|       |
  120|       |  // _uploadData, _uploadDataProvider, or _uploadFileHandle may be set, but only one.
  121|       |  NSData *_uploadData;
  122|       |  NSFileHandle *_uploadFileHandle;
  123|       |  GTMSessionUploadFetcherDataProvider _uploadDataProvider;
  124|       |  NSURL *_uploadFileURL;
  125|       |  int64_t _uploadFileLength;
  126|       |  NSString *_uploadMIMEType;
  127|       |  int64_t _chunkSize;
  128|       |  int64_t _uploadGranularity;
  129|       |  BOOL _isPaused;
  130|       |  BOOL _isRestartedUpload;
  131|       |  BOOL _shouldInitiateOffsetQuery;
  132|       |
  133|       |  // Tied to useBackgroundSession property, since this property is applicable to chunk fetchers.
  134|       |  BOOL _useBackgroundSessionOnChunkFetchers;
  135|       |
  136|       |  // We keep the latest offset into the upload data just for progress reporting.
  137|       |  int64_t _currentOffset;
  138|       |
  139|       |  NSDictionary *_recentChunkReponseHeaders;
  140|       |  NSInteger _recentChunkStatusCode;
  141|       |
  142|       |  // For waiting, we need to know the fetcher in flight, if any, and if subdata generation
  143|       |  // is in progress.
  144|       |  GTMSessionFetcher *_fetcherInFlight;
  145|       |  BOOL _isSubdataGenerating;
  146|       |  BOOL _isCancelInFlight;
  147|       |
  148|       |  GTMSessionUploadFetcherCancellationHandler _cancellationHandler;
  149|       |}
  150|       |
  151|      1|+ (void)load {
  152|      1|  [self uploadFetchersForBackgroundSessions];
  153|      1|}
  154|       |
  155|       |+ (instancetype)uploadFetcherWithRequest:(NSURLRequest *)request
  156|       |                          uploadMIMEType:(NSString *)uploadMIMEType
  157|       |                               chunkSize:(int64_t)chunkSize
  158|      0|                          fetcherService:(GTMSessionFetcherService *)fetcherService {
  159|      0|  GTMSessionUploadFetcher *fetcher = [self uploadFetcherWithRequest:request
  160|      0|                                                     fetcherService:fetcherService];
  161|      0|  [fetcher setLocationURL:nil
  162|      0|            uploadMIMEType:uploadMIMEType
  163|      0|                 chunkSize:chunkSize
  164|      0|      allowsCellularAccess:request.allowsCellularAccess];
  165|      0|  return fetcher;
  166|      0|}
  167|       |
  168|       |+ (instancetype)uploadFetcherWithLocation:(NSURL *GTM_NULLABLE_TYPE)uploadLocationURL
  169|       |                           uploadMIMEType:(NSString *)uploadMIMEType
  170|       |                                chunkSize:(int64_t)chunkSize
  171|      0|                           fetcherService:(GTM_NULLABLE GTMSessionFetcherService *)fetcherServiceOrNil {
  172|      0|  return [self uploadFetcherWithLocation:uploadLocationURL
  173|      0|                          uploadMIMEType:uploadMIMEType
  174|      0|                               chunkSize:chunkSize
  175|      0|                    allowsCellularAccess:YES
  176|      0|                          fetcherService:fetcherServiceOrNil];
  177|      0|}
  178|       |
  179|       |+ (instancetype)uploadFetcherWithLocation:(NSURL *GTM_NULLABLE_TYPE)uploadLocationURL
  180|       |                           uploadMIMEType:(NSString *)uploadMIMEType
  181|       |                                chunkSize:(int64_t)chunkSize
  182|       |                     allowsCellularAccess:(BOOL)allowsCellularAccess
  183|      0|                           fetcherService:(GTMSessionFetcherService *)fetcherService {
  184|      0|  GTMSessionUploadFetcher *fetcher = [self uploadFetcherWithRequest:nil
  185|      0|                                                     fetcherService:fetcherService];
  186|      0|  [fetcher setLocationURL:uploadLocationURL
  187|      0|            uploadMIMEType:uploadMIMEType
  188|      0|                 chunkSize:chunkSize
  189|      0|      allowsCellularAccess:allowsCellularAccess];
  190|      0|  return fetcher;
  191|      0|}
  192|       |
  193|      0|+ (instancetype)uploadFetcherForSessionIdentifierMetadata:(NSDictionary *)metadata {
  194|      0|  GTMSESSION_ASSERT_DEBUG(
  195|      0|      [metadata[kGTMSessionIdentifierIsUploadChunkFetcherMetadataKey] boolValue],
  196|      0|      @"Session identifier metadata is not for an upload fetcher: %@", metadata);
  197|      0|
  198|      0|  NSNumber *uploadFileLengthNum = metadata[kGTMSessionIdentifierUploadFileLengthMetadataKey];
  199|      0|  GTMSESSION_ASSERT_DEBUG(uploadFileLengthNum != nil,
  200|      0|                          @"Session metadata missing an UploadFileSize");
  201|      0|  if (uploadFileLengthNum == nil) return nil;
  202|      0|
  203|      0|  int64_t uploadFileLength = [uploadFileLengthNum longLongValue];
  204|      0|  GTMSESSION_ASSERT_DEBUG(uploadFileLength >= 0, @"Session metadata UploadFileSize is unknown");
  205|      0|
  206|      0|  NSString *uploadFileURLString = metadata[kGTMSessionIdentifierUploadFileURLMetadataKey];
  207|      0|  GTMSESSION_ASSERT_DEBUG(uploadFileURLString, @"Session metadata missing an UploadFileURL");
  208|      0|  if (uploadFileURLString == nil) return nil;
  209|      0|
  210|      0|  NSURL *uploadFileURL = [NSURL URLWithString:uploadFileURLString];
  211|      0|  // There used to be a call here to NSURL checkResourceIsReachableAndReturnError: to check for the
  212|      0|  // existence of the file (also tried NSFileManager fileExistsAtPath:). We've determined
  213|      0|  // empirically that the check can fail at startup even when the upload file does in fact exist.
  214|      0|  // For now, we'll go ahead and restore the background upload fetcher. If the file doesn't exist,
  215|      0|  // it will fail later.
  216|      0|
  217|      0|  NSString *uploadLocationURLString = metadata[kGTMSessionIdentifierUploadLocationURLMetadataKey];
  218|      0|  NSURL *uploadLocationURL =
  219|      0|      uploadLocationURLString ? [NSURL URLWithString:uploadLocationURLString] : nil;
  220|      0|
  221|      0|  NSString *uploadMIMEType =
  222|      0|      metadata[kGTMSessionIdentifierUploadMIMETypeMetadataKey];
  223|      0|  int64_t uploadChunkSize =
  224|      0|      [metadata[kGTMSessionIdentifierUploadChunkSizeMetadataKey] longLongValue];
  225|      0|  if (uploadChunkSize <= 0) {
  226|      0|    uploadChunkSize = kGTMSessionUploadFetcherStandardChunkSize;
  227|      0|  }
  228|      0|  int64_t currentOffset =
  229|      0|      [metadata[kGTMSessionIdentifierUploadCurrentOffsetMetadataKey] longLongValue];
  230|      0|
  231|      0|  BOOL allowsCellularAccess = YES;
  232|      0|  if (metadata[kGTMSessionIdentifierUploadAllowsCellularAccess]) {
  233|      0|    allowsCellularAccess = [metadata[kGTMSessionIdentifierUploadAllowsCellularAccess] boolValue];
  234|      0|  }
  235|      0|
  236|      0|  GTMSESSION_ASSERT_DEBUG(currentOffset <= uploadFileLength,
  237|      0|                          @"CurrentOffset (%lld) exceeds UploadFileSize (%lld)",
  238|      0|                          currentOffset, uploadFileLength);
  239|      0|  if (currentOffset > uploadFileLength) return nil;
  240|      0|
  241|      0|  GTMSessionUploadFetcher *uploadFetcher = [self uploadFetcherWithLocation:uploadLocationURL
  242|      0|                                                            uploadMIMEType:uploadMIMEType
  243|      0|                                                                 chunkSize:uploadChunkSize
  244|      0|                                                      allowsCellularAccess:allowsCellularAccess
  245|      0|                                                            fetcherService:nil];
  246|      0|  // Set the upload file length before setting the upload file URL tries to determine the length.
  247|      0|  [uploadFetcher setUploadFileLength:uploadFileLength];
  248|      0|
  249|      0|  uploadFetcher.uploadFileURL = uploadFileURL;
  250|      0|  uploadFetcher.sessionUserInfo = metadata;
  251|      0|  uploadFetcher.useBackgroundSession = YES;
  252|      0|  uploadFetcher.currentOffset = currentOffset;
  253|      0|  uploadFetcher.delegateCallbackQueue = uploadFetcher.callbackQueue;
  254|      0|  uploadFetcher.allowedInsecureSchemes = @[ @"http" ];  // Allowed on restored upload fetcher.
  255|      0|  return uploadFetcher;
  256|      0|}
  257|       |
  258|       |+ (instancetype)uploadFetcherWithRequest:(NSURLRequest *)request
  259|      0|                          fetcherService:(GTMSessionFetcherService *)fetcherService {
  260|      0|  // Internal utility method for instantiating fetchers
  261|      0|  GTMSessionUploadFetcher *fetcher;
  262|      0|  if ([fetcherService isKindOfClass:[GTMSessionFetcherService class]]) {
  263|      0|    fetcher = [fetcherService fetcherWithRequest:request
  264|      0|                                    fetcherClass:self];
  265|      0|  } else {
  266|      0|    fetcher = [self fetcherWithRequest:request];
  267|      0|  }
  268|      0|  fetcher.useBackgroundSession = YES;
  269|      0|  return fetcher;
  270|      0|}
  271|       |
  272|      1|+ (NSPointerArray *)uploadFetcherPointerArrayForBackgroundSessions {
  273|      1|  static NSPointerArray *gUploadFetcherPointerArrayForBackgroundSessions = nil;
  274|      1|
  275|      1|  static dispatch_once_t onceToken;
  276|      1|  dispatch_once(&onceToken, ^{
  277|      1|    gUploadFetcherPointerArrayForBackgroundSessions = [NSPointerArray weakObjectsPointerArray];
  278|      1|  });
  279|      1|  return gUploadFetcherPointerArrayForBackgroundSessions;
  280|      1|}
  281|       |
  282|      0|+ (instancetype)uploadFetcherForSessionIdentifier:(NSString *)sessionIdentifier {
  283|      0|  GTMSESSION_ASSERT_DEBUG(sessionIdentifier != nil, @"Invalid session identifier");
  284|      0|  NSArray *uploadFetchersForBackgroundSessions = [self uploadFetchersForBackgroundSessions];
  285|      0|  for (GTMSessionUploadFetcher *uploadFetcher in uploadFetchersForBackgroundSessions) {
  286|      0|    if ([uploadFetcher.chunkFetcher.sessionIdentifier isEqual:sessionIdentifier]) {
  287|      0|      return uploadFetcher;
  288|      0|    }
  289|      0|  }
  290|      0|  return nil;
  291|      0|}
  292|       |
  293|      1|+ (NSArray *)uploadFetchersForBackgroundSessions {
  294|      1|  NSMutableSet *restoredSessionIdentifiers = [[NSMutableSet alloc] init];
  295|      1|  NSMutableArray *uploadFetchers = [[NSMutableArray alloc] init];
  296|      1|  NSPointerArray *uploadFetcherPointerArray = [self uploadFetcherPointerArrayForBackgroundSessions];
  297|      1|
  298|      1|  // Collect the background session upload fetchers that are still in memory.
  299|      1|  @synchronized(uploadFetcherPointerArray) {
  300|      1|    [uploadFetcherPointerArray compact];
  301|      1|    for (GTMSessionUploadFetcher *uploadFetcher in uploadFetcherPointerArray) {
  302|      0|      NSString *sessionIdentifier = uploadFetcher.chunkFetcher.sessionIdentifier;
  303|      0|      if (sessionIdentifier) {
  304|      0|        [restoredSessionIdentifiers addObject:sessionIdentifier];
  305|      0|        [uploadFetchers addObject:uploadFetcher];
  306|      0|      }
  307|      0|    }
  308|      1|  }  // @synchronized(uploadFetcherPointerArray)
  309|      1|
  310|      1|  // The system may have other ongoing background upload sessions. Restore upload fetchers for those
  311|      1|  // too.
  312|      1|  NSArray *fetchers = [GTMSessionFetcher fetchersForBackgroundSessions];
  313|      1|  for (GTMSessionFetcher *fetcher in fetchers) {
  314|      0|    NSString *sessionIdentifier = fetcher.sessionIdentifier;
  315|      0|    if (!sessionIdentifier || [restoredSessionIdentifiers containsObject:sessionIdentifier]) {
  316|      0|      continue;
  317|      0|    }
  318|      0|    NSDictionary *sessionIdentifierMetadata = [fetcher sessionIdentifierMetadata];
  319|      0|    if (sessionIdentifierMetadata == nil) {
  320|      0|      continue;
  321|      0|    }
  322|      0|    if (![sessionIdentifierMetadata[kGTMSessionIdentifierIsUploadChunkFetcherMetadataKey] boolValue]) {
  323|      0|      continue;
  324|      0|    }
  325|      0|    GTMSessionUploadFetcher *uploadFetcher =
  326|      0|        [self uploadFetcherForSessionIdentifierMetadata:sessionIdentifierMetadata];
  327|      0|    if (uploadFetcher == nil) {
  328|      0|      // Something went wrong with this upload fetcher, so kill the restored chunk fetcher.
  329|      0|      [fetcher stopFetching];
  330|      0|      continue;
  331|      0|    }
  332|      0|    [uploadFetchers addObject:uploadFetcher];
  333|      0|    uploadFetcher->_chunkFetcher = fetcher;
  334|      0|    uploadFetcher->_fetcherInFlight = fetcher;
  335|      0|    [uploadFetcher attachSendProgressBlockToChunkFetcher:fetcher];
  336|      0|    fetcher.completionHandler =
  337|      0|        [fetcher completionHandlerWithTarget:uploadFetcher
  338|      0|                           didFinishSelector:@selector(chunkFetcher:finishedWithData:error:)];
  339|      0|
  340|      0|    GTMSESSION_LOG_DEBUG(@"%@ restoring upload fetcher %@ for chunk fetcher %@",
  341|      0|                         [self class], uploadFetcher, fetcher);
  342|      0|  }
  343|      1|  return uploadFetchers;
  344|      1|}
  345|       |
  346|      0|- (void)setUploadData:(NSData *)data {
  347|      0|  BOOL changed = NO;
  348|      0|
  349|      0|  @synchronized(self) {
  350|      0|    GTMSessionMonitorSynchronized(self);
  351|      0|
  352|      0|    if (_uploadData != data) {
  353|      0|      _uploadData = data;
  354|      0|      changed = YES;
  355|      0|    }
  356|      0|  }
  357|      0|  if (changed) {
  358|      0|    [self setupRequestHeaders];
  359|      0|  }
  360|      0|}
  361|       |
  362|      0|- (NSData *)uploadData {
  363|      0|  @synchronized(self) {
  364|      0|    GTMSessionMonitorSynchronized(self);
  365|      0|
  366|      0|    return _uploadData;
  367|      0|  }
  368|      0|}
  369|       |
  370|      0|- (void)setUploadFileHandle:(NSFileHandle *)fh {
  371|      0|  BOOL changed = NO;
  372|      0|
  373|      0|  @synchronized(self) {
  374|      0|    GTMSessionMonitorSynchronized(self);
  375|      0|
  376|      0|    if (_uploadFileHandle != fh) {
  377|      0|      _uploadFileHandle = fh;
  378|      0|      changed = YES;
  379|      0|    }
  380|      0|  }
  381|      0|  if (changed) {
  382|      0|    [self setupRequestHeaders];
  383|      0|  }
  384|      0|}
  385|       |
  386|      0|- (NSFileHandle *)uploadFileHandle {
  387|      0|  @synchronized(self) {
  388|      0|    GTMSessionMonitorSynchronized(self);
  389|      0|
  390|      0|    return _uploadFileHandle;
  391|      0|  }
  392|      0|}
  393|       |
  394|      0|- (void)setUploadFileURL:(NSURL *)uploadURL {
  395|      0|  BOOL changed = NO;
  396|      0|
  397|      0|  @synchronized(self) {
  398|      0|    GTMSessionMonitorSynchronized(self);
  399|      0|
  400|      0|    if (_uploadFileURL != uploadURL) {
  401|      0|      _uploadFileURL = uploadURL;
  402|      0|      changed = YES;
  403|      0|    }
  404|      0|  }
  405|      0|  if (changed) {
  406|      0|    [self setupRequestHeaders];
  407|      0|  }
  408|      0|}
  409|       |
  410|      0|- (NSURL *)uploadFileURL {
  411|      0|  @synchronized(self) {
  412|      0|    GTMSessionMonitorSynchronized(self);
  413|      0|
  414|      0|    return _uploadFileURL;
  415|      0|  }
  416|      0|}
  417|       |
  418|      0|- (void)setUploadFileLength:(int64_t)fullLength {
  419|      0|  @synchronized(self) {
  420|      0|    GTMSessionMonitorSynchronized(self);
  421|      0|
  422|      0|    if (_uploadFileLength == kGTMSessionUploadFetcherUnknownFileSize &&
  423|      0|        fullLength != kGTMSessionUploadFetcherUnknownFileSize) {
  424|      0|      _uploadFileLength = fullLength;
  425|      0|    }
  426|      0|  }
  427|      0|}
  428|       |
  429|       |- (void)setUploadDataLength:(int64_t)fullLength
  430|      0|                   provider:(GTMSessionUploadFetcherDataProvider)block {
  431|      0|  @synchronized(self) {
  432|      0|    GTMSessionMonitorSynchronized(self);
  433|      0|
  434|      0|    _uploadDataProvider = [block copy];
  435|      0|    _uploadFileLength = fullLength;
  436|      0|  }
  437|      0|  [self setupRequestHeaders];
  438|      0|}
  439|       |
  440|      0|- (GTMSessionUploadFetcherDataProvider)uploadDataProvider {
  441|      0|  @synchronized(self) {
  442|      0|    GTMSessionMonitorSynchronized(self);
  443|      0|
  444|      0|    return _uploadDataProvider;
  445|      0|  }
  446|      0|}
  447|       |
  448|       |
  449|      0|- (void)setUploadMIMEType:(NSString *)uploadMIMEType {
  450|      0|  GTMSESSION_ASSERT_DEBUG(0, @"TODO: disallow setUploadMIMEType by making declaration readonly");
  451|      0|  // (and uploadMIMEType, chunksize, currentOffset)
  452|      0|  @synchronized(self) {
  453|      0|    GTMSessionMonitorSynchronized(self);
  454|      0|
  455|      0|    _uploadMIMEType = uploadMIMEType;
  456|      0|  }
  457|      0|}
  458|       |
  459|      0|- (NSString *)uploadMIMEType {
  460|      0|  @synchronized(self) {
  461|      0|    GTMSessionMonitorSynchronized(self);
  462|      0|
  463|      0|    return _uploadMIMEType;
  464|      0|  }
  465|      0|}
  466|       |
  467|      0|- (int64_t)chunkSize {
  468|      0|  @synchronized(self) {
  469|      0|    GTMSessionMonitorSynchronized(self);
  470|      0|
  471|      0|    return _chunkSize;
  472|      0|  }
  473|      0|}
  474|       |
  475|      0|- (void)setupRequestHeaders {
  476|      0|  GTMSessionCheckNotSynchronized(self);
  477|      0|
  478|      0|#if DEBUG
  479|      0|  @synchronized(self) {
  480|      0|    GTMSessionMonitorSynchronized(self);
  481|      0|
  482|      0|    int hasData = (_uploadData != nil) ? 1 : 0;
  483|      0|    int hasFileHandle = (_uploadFileHandle != nil) ? 1 : 0;
  484|      0|    int hasFileURL = (_uploadFileURL != nil) ? 1 : 0;
  485|      0|    int hasUploadDataProvider = (_uploadDataProvider != nil) ? 1 : 0;
  486|      0|    int numberOfSources = hasData + hasFileHandle + hasFileURL + hasUploadDataProvider;
  487|      0|    #pragma unused(numberOfSources)
  488|      0|    GTMSESSION_ASSERT_DEBUG(numberOfSources == 1,
  489|      0|                            @"Need just one upload source (%d)", numberOfSources);
  490|      0|  }  // @synchronized(self)
  491|      0|#endif
  492|      0|
  493|      0|  // Add our custom headers to the initial request indicating the data
  494|      0|  // type and total size to be delivered later in the chunk requests.
  495|      0|  NSMutableURLRequest *mutableRequest = [self.request mutableCopy];
  496|      0|
  497|      0|  GTMSESSION_ASSERT_DEBUG((mutableRequest == nil) != (_uploadLocationURL == nil),
  498|      0|                          @"Request and location are mutually exclusive");
  499|      0|  if (!mutableRequest) return;
  500|      0|
  501|      0|  [mutableRequest setValue:kGTMSessionXGoogUploadProtocolResumable
  502|      0|        forHTTPHeaderField:kGTMSessionHeaderXGoogUploadProtocol];
  503|      0|  [mutableRequest setValue:@"start"
  504|      0|        forHTTPHeaderField:kGTMSessionHeaderXGoogUploadCommand];
  505|      0|  [mutableRequest setValue:_uploadMIMEType
  506|      0|        forHTTPHeaderField:kGTMSessionHeaderXGoogUploadContentType];
  507|      0|  [mutableRequest setValue:@([self fullUploadLength]).stringValue
  508|      0|        forHTTPHeaderField:kGTMSessionHeaderXGoogUploadContentLength];
  509|      0|
  510|      0|  NSString *method = mutableRequest.HTTPMethod;
  511|      0|  if (method == nil || [method caseInsensitiveCompare:@"GET"] == NSOrderedSame) {
  512|      0|    [mutableRequest setHTTPMethod:@"POST"];
  513|      0|  }
  514|      0|
  515|      0|  // Ensure the user agent header identifies this to the upload server as a
  516|      0|  // GTMSessionUploadFetcher client.  The /1 can be incremented in the unlikely circumstance
  517|      0|  // we need to make a bug fix in the client that the server can recognize.
  518|      0|  NSString *const kUserAgentStub = @"(GTMSUF/1)";
  519|      0|  NSString *userAgent = [mutableRequest valueForHTTPHeaderField:@"User-Agent"];
  520|      0|  if (userAgent == nil
  521|      0|      || [userAgent rangeOfString:kUserAgentStub].location == NSNotFound) {
  522|      0|    if (userAgent.length == 0) {
  523|      0|      userAgent = GTMFetcherStandardUserAgentString(nil);
  524|      0|    }
  525|      0|    userAgent = [userAgent stringByAppendingFormat:@" %@", kUserAgentStub];
  526|      0|    [mutableRequest setValue:userAgent forHTTPHeaderField:@"User-Agent"];
  527|      0|  }
  528|      0|  [self setRequest:mutableRequest];
  529|      0|}
  530|       |
  531|       |- (void)setLocationURL:(NSURL *GTM_NULLABLE_TYPE)location
  532|       |          uploadMIMEType:(NSString *)uploadMIMEType
  533|       |               chunkSize:(int64_t)chunkSize
  534|      0|    allowsCellularAccess:(BOOL)allowsCellularAccess {
  535|      0|  @synchronized(self) {
  536|      0|    GTMSessionMonitorSynchronized(self);
  537|      0|
  538|      0|    GTMSESSION_ASSERT_DEBUG(chunkSize > 0, @"chunk size is zero");
  539|      0|
  540|      0|    _allowsCellularAccess = allowsCellularAccess;
  541|      0|
  542|      0|    // When resuming an upload, set the known upload target URL.
  543|      0|    _uploadLocationURL = location;
  544|      0|
  545|      0|    _uploadMIMEType = uploadMIMEType;
  546|      0|    _chunkSize = chunkSize;
  547|      0|
  548|      0|    // Indicate that we've not yet determined the file handle's length
  549|      0|    _uploadFileLength = kGTMSessionUploadFetcherUnknownFileSize;
  550|      0|
  551|      0|    // Indicate that we've not yet determined the upload fetcher status
  552|      0|    _recentChunkStatusCode = -1;
  553|      0|
  554|      0|    // If this is restarting an upload begun by another fetcher,
  555|      0|    // the location is specified but the request is nil
  556|      0|    _isRestartedUpload = (location != nil);
  557|      0|  }  // @synchronized(self)
  558|      0|}
  559|       |
  560|      0|- (int64_t)fullUploadLength {
  561|      0|  int64_t result;
  562|      0|  @synchronized(self) {
  563|      0|    GTMSessionMonitorSynchronized(self);
  564|      0|
  565|      0|    if (_uploadData) {
  566|      0|      result = (int64_t)_uploadData.length;
  567|      0|    } else {
  568|      0|      if (_uploadFileLength == kGTMSessionUploadFetcherUnknownFileSize) {
  569|      0|        if (_uploadFileHandle) {
  570|      0|          // First time through, seek to end to determine file length
  571|      0|          _uploadFileLength = (int64_t)[_uploadFileHandle seekToEndOfFile];
  572|      0|        } else if (_uploadDataProvider) {
  573|      0|          // _uploadFileLength is set when the _uploadDataProvider is set.
  574|      0|          GTMSESSION_ASSERT_DEBUG(_uploadFileLength >= 0, @"No uploadDataProvider length set");
  575|      0|        } else {
  576|      0|          NSNumber *filesizeNum;
  577|      0|          NSError *valueError;
  578|      0|          if ([_uploadFileURL getResourceValue:&filesizeNum
  579|      0|                                        forKey:NSURLFileSizeKey
  580|      0|                                         error:&valueError]) {
  581|      0|            _uploadFileLength = filesizeNum.longLongValue;
  582|      0|          } else {
  583|      0|            GTMSESSION_ASSERT_DEBUG(NO, @"Cannot get file size: %@\n  %@",
  584|      0|                                    valueError, _uploadFileURL.path);
  585|      0|            _uploadFileLength = 0;
  586|      0|          }
  587|      0|        }
  588|      0|      }
  589|      0|      result = _uploadFileLength;
  590|      0|    }
  591|      0|  }  // @synchronized(self)
  592|      0|  return result;
  593|      0|}
  594|       |
  595|       |// Make a subdata of the upload data.
  596|       |- (void)generateChunkSubdataWithOffset:(int64_t)offset
  597|       |                                length:(int64_t)length
  598|      0|                              response:(GTMSessionUploadFetcherDataProviderResponse)response {
  599|      0|  GTMSessionUploadFetcherDataProvider uploadDataProvider = self.uploadDataProvider;
  600|      0|  if (uploadDataProvider) {
  601|      0|    uploadDataProvider(offset, length, response);
  602|      0|    return;
  603|      0|  }
  604|      0|
  605|      0|  NSData *uploadData = self.uploadData;
  606|      0|  if (uploadData) {
  607|      0|    // NSData provided.
  608|      0|    NSData *resultData;
  609|      0|    if (offset == 0 && length == (int64_t)uploadData.length) {
  610|      0|      resultData = uploadData;
  611|      0|    } else {
  612|      0|      int64_t dataLength = (int64_t)uploadData.length;
  613|      0|      // Ensure our range is valid.  b/18007814
  614|      0|      if (offset + length > dataLength) {
  615|      0|        NSString *errorMessage = [NSString stringWithFormat:
  616|      0|                                  @"Range invalid for upload data.  offset: %lld\tlength: %lld\tdataLength: %lld",
  617|      0|                                  offset, length, dataLength];
  618|      0|        GTMSESSION_ASSERT_DEBUG(NO, @"%@", errorMessage);
  619|      0|        response(nil,
  620|      0|                 kGTMSessionUploadFetcherUnknownFileSize,
  621|      0|                 [self uploadChunkUnavailableErrorWithDescription:errorMessage]);
  622|      0|        return;
  623|      0|      }
  624|      0|      NSRange range = NSMakeRange((NSUInteger)offset, (NSUInteger)length);
  625|      0|
  626|      0|      @try {
  627|      0|        resultData = [uploadData subdataWithRange:range];
  628|      0|      }
  629|      0|      @catch (NSException *exception) {
  630|      0|        NSString *errorMessage = exception.description;
  631|      0|        GTMSESSION_ASSERT_DEBUG(NO, @"%@", errorMessage);
  632|      0|        response(nil,
  633|      0|                 kGTMSessionUploadFetcherUnknownFileSize,
  634|      0|                 [self uploadChunkUnavailableErrorWithDescription:errorMessage]);
  635|      0|        return;
  636|      0|      }
  637|      0|    }
  638|      0|    response(resultData, kGTMSessionUploadFetcherUnknownFileSize, nil);
  639|      0|    return;
  640|      0|  }
  641|      0|  NSURL *uploadFileURL = self.uploadFileURL;
  642|      0|  if (uploadFileURL) {
  643|      0|    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
  644|      0|      [self generateChunkSubdataFromFileURL:uploadFileURL
  645|      0|                                     offset:offset
  646|      0|                                     length:length
  647|      0|                                   response:response];
  648|      0|    });
  649|      0|    return;
  650|      0|  }
  651|      0|  GTMSESSION_ASSERT_DEBUG(_uploadFileHandle, @"Unexpectedly missing upload data package");
  652|      0|  NSFileHandle *uploadFileHandle = self.uploadFileHandle;
  653|      0|  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
  654|      0|    [self generateChunkSubdataFromFileHandle:uploadFileHandle
  655|      0|                                      offset:offset
  656|      0|                                      length:length
  657|      0|                                    response:response];
  658|      0|  });
  659|      0|}
  660|       |
  661|       |- (void)generateChunkSubdataFromFileHandle:(NSFileHandle *)fileHandle
  662|       |                                    offset:(int64_t)offset
  663|       |                                    length:(int64_t)length
  664|      0|                                  response:(GTMSessionUploadFetcherDataProviderResponse)response {
  665|      0|  NSData *resultData;
  666|      0|  NSError *error;
  667|      0|  @try {
  668|      0|    [fileHandle seekToFileOffset:(unsigned long long)offset];
  669|      0|    resultData = [fileHandle readDataOfLength:(NSUInteger)length];
  670|      0|  }
  671|      0|  @catch (NSException *exception) {
  672|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"uploadFileHandle failed to read, %@", exception);
  673|      0|    error = [self uploadChunkUnavailableErrorWithDescription:exception.description];
  674|      0|  }
  675|      0|  // The response always re-dispatches to the main thread, so we skip doing that here.
  676|      0|  response(resultData, kGTMSessionUploadFetcherUnknownFileSize, error);
  677|      0|}
  678|       |
  679|       |- (void)generateChunkSubdataFromFileURL:(NSURL *)fileURL
  680|       |                                 offset:(int64_t)offset
  681|       |                                 length:(int64_t)length
  682|      0|                               response:(GTMSessionUploadFetcherDataProviderResponse)response {
  683|      0|  GTMSessionCheckNotSynchronized(self);
  684|      0|
  685|      0|  NSData *resultData;
  686|      0|  NSError *error;
  687|      0|  int64_t fullUploadLength = [self fullUploadLength];
  688|      0|  NSData *mappedData =
  689|      0|      [NSData dataWithContentsOfURL:fileURL
  690|      0|                            options:NSDataReadingMappedAlways + NSDataReadingUncached
  691|      0|                              error:&error];
  692|      0|  if (!mappedData) {
  693|      0|    // We could not create an NSData by memory-mapping the file.
  694|      0|#if TARGET_IPHONE_SIMULATOR
  695|      0|    // NSTemporaryDirectory() can differ in the simulator between app restarts,
  696|      0|    // yet the contents for the new path remains unchanged, so try the latest temp path.
  697|      0|    if ([error.domain isEqual:NSCocoaErrorDomain] && (error.code == NSFileReadNoSuchFileError)) {
  698|      0|      NSString *filename = [fileURL lastPathComponent];
  699|      0|      NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:filename];
  700|      0|      NSURL *newFileURL = [NSURL fileURLWithPath:filePath];
  701|      0|      if (![newFileURL isEqual:fileURL]) {
  702|      0|        [self generateChunkSubdataFromFileURL:newFileURL
  703|      0|                                       offset:offset
  704|      0|                                       length:length
  705|      0|                                     response:response];
  706|      0|        return;
  707|      0|      }
  708|      0|    }
  709|      0|#endif
  710|      0|
  711|      0|    // If the file is just too large to create an NSData for, or if for some other reason we can't
  712|      0|    // map it, create an NSFileHandle instead to read a subset into an NSData.
  713|      0|#if DEBUG
  714|      0|    NSNumber *fileSizeNum;
  715|      0|    BOOL hasFileSize = [fileURL getResourceValue:&fileSizeNum forKey:NSURLFileSizeKey error:NULL];
  716|      0|    GTMSESSION_LOG_DEBUG(@"Note: uploadFileURL is falling back to creating upload chunks by reading"
  717|      0|                         @" an NSFileHandle since uploadFileURL failed to map the upload file,"
  718|      0|                         @" file size %@, %@",
  719|      0|                         hasFileSize ? fileSizeNum : @"unknown", error);
  720|      0|#endif
  721|      0|
  722|      0|    NSFileHandle *fileHandle = [NSFileHandle fileHandleForReadingFromURL:fileURL
  723|      0|                                                                   error:&error];
  724|      0|    if (fileHandle != nil) {
  725|      0|      [self generateChunkSubdataFromFileHandle:fileHandle
  726|      0|                                        offset:offset
  727|      0|                                        length:length
  728|      0|                                      response:response];
  729|      0|      return;
  730|      0|    }
  731|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"uploadFileURL failed to read, %@", error);
  732|      0|    // Fall through with the error.
  733|      0|  } else {
  734|      0|    // Successfully created an NSData by memory-mapping the file.
  735|      0|    if ((NSUInteger)(offset + length) > mappedData.length) {
  736|      0|      NSString *errorMessage = [NSString stringWithFormat:
  737|      0|                                @"Range invalid for upload data.  offset: %lld\tlength: %lld\tdataLength: %lld\texpected UploadLength: %lld",
  738|      0|                                offset, length, (long long)mappedData.length, fullUploadLength];
  739|      0|      GTMSESSION_ASSERT_DEBUG(NO, @"%@", errorMessage);
  740|      0|      response(nil,
  741|      0|               kGTMSessionUploadFetcherUnknownFileSize,
  742|      0|               [self uploadChunkUnavailableErrorWithDescription:errorMessage]);
  743|      0|      return;
  744|      0|    }
  745|      0|    if (offset > 0 || length < fullUploadLength) {
  746|      0|      NSRange range = NSMakeRange((NSUInteger)offset, (NSUInteger)length);
  747|      0|      resultData = [mappedData subdataWithRange:range];
  748|      0|    } else {
  749|      0|      resultData = mappedData;
  750|      0|    }
  751|      0|  }
  752|      0|  // The response always re-dispatches to the main thread, so we skip re-dispatching here.
  753|      0|  response(resultData, kGTMSessionUploadFetcherUnknownFileSize, error);
  754|      0|}
  755|       |
  756|      0|- (NSError *)uploadChunkUnavailableErrorWithDescription:(NSString *)description {
  757|      0|  // The description in the userInfo is intended as a clue to programmers, not
  758|      0|  // for client code to examine or rely on.
  759|      0|  NSDictionary *userInfo = @{ @"description" : description };
  760|      0|  return [NSError errorWithDomain:kGTMSessionFetcherErrorDomain
  761|      0|                             code:GTMSessionFetcherErrorUploadChunkUnavailable
  762|      0|                         userInfo:userInfo];
  763|      0|}
  764|       |
  765|      0|- (NSError *)prematureFailureErrorWithUserInfo:(NSDictionary *)userInfo {
  766|      0|  // An error for if we get an unexpected status from the upload server or
  767|      0|  // otherwise cannot continue.  This is an issue beyond the upload protocol;
  768|      0|  // there's no way the client can do anything useful except give up.
  769|      0|  NSError *error = [NSError errorWithDomain:kGTMSessionFetcherStatusDomain
  770|      0|                                       code:501  // Not implemented
  771|      0|                                   userInfo:userInfo];
  772|      0|  return error;
  773|      0|}
  774|       |
  775|      0|+ (GTMSessionUploadFetcherStatus)uploadStatusFromResponseHeaders:(NSDictionary *)responseHeaders {
  776|      0|  NSString *statusString = [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadStatus];
  777|      0|  if ([statusString isEqual:@"active"]) {
  778|      0|    return kStatusActive;
  779|      0|  }
  780|      0|  if ([statusString isEqual:@"final"]) {
  781|      0|    return kStatusFinal;
  782|      0|  }
  783|      0|  if ([statusString isEqual:@"cancelled"]) {
  784|      0|    return kStatusCancelled;
  785|      0|  }
  786|      0|  return kStatusUnknown;
  787|      0|}
  788|       |
  789|       |#pragma mark Method overrides affecting the initial fetch only
  790|       |
  791|      0|- (void)setCompletionHandler:(GTMSessionFetcherCompletionHandler)handler {
  792|      0|  @synchronized(self) {
  793|      0|    GTMSessionMonitorSynchronized(self);
  794|      0|
  795|      0|    _delegateCompletionHandler = handler;
  796|      0|  }
  797|      0|}
  798|       |
  799|      0|- (void)setDelegateCallbackQueue:(dispatch_queue_t GTM_NULLABLE_TYPE)queue {
  800|      0|  @synchronized(self) {
  801|      0|    GTMSessionMonitorSynchronized(self);
  802|      0|
  803|      0|    _delegateCallbackQueue = queue;
  804|      0|  }
  805|      0|}
  806|       |
  807|      0|- (dispatch_queue_t GTM_NULLABLE_TYPE)delegateCallbackQueue {
  808|      0|  @synchronized(self) {
  809|      0|    GTMSessionMonitorSynchronized(self);
  810|      0|
  811|      0|    return _delegateCallbackQueue;
  812|      0|  }
  813|      0|}
  814|       |
  815|      0|- (BOOL)isRestartedUpload {
  816|      0|  @synchronized(self) {
  817|      0|    GTMSessionMonitorSynchronized(self);
  818|      0|
  819|      0|    return _isRestartedUpload;
  820|      0|  }
  821|      0|}
  822|       |
  823|      0|- (GTMSessionFetcher * GTM_NULLABLE_TYPE)chunkFetcher {
  824|      0|  @synchronized(self) {
  825|      0|    GTMSessionMonitorSynchronized(self);
  826|      0|
  827|      0|    return _chunkFetcher;
  828|      0|  }
  829|      0|}
  830|       |
  831|      0|- (void)setChunkFetcher:(GTMSessionFetcher * GTM_NULLABLE_TYPE)fetcher {
  832|      0|  @synchronized(self) {
  833|      0|    GTMSessionMonitorSynchronized(self);
  834|      0|
  835|      0|    _chunkFetcher = fetcher;
  836|      0|  }
  837|      0|}
  838|       |
  839|      0|- (void)setFetcherInFlight:(GTMSessionFetcher * GTM_NULLABLE_TYPE)fetcher {
  840|      0|  @synchronized(self) {
  841|      0|    GTMSessionMonitorSynchronized(self);
  842|      0|
  843|      0|    _fetcherInFlight = fetcher;
  844|      0|  }
  845|      0|}
  846|       |
  847|      0|- (GTMSessionFetcher * GTM_NULLABLE_TYPE)fetcherInFlight {
  848|      0|  @synchronized(self) {
  849|      0|    GTMSessionMonitorSynchronized(self);
  850|      0|
  851|      0|    return _fetcherInFlight;
  852|      0|  }
  853|      0|}
  854|       |
  855|       |- (void)setCancellationHandler:(GTMSessionUploadFetcherCancellationHandler GTM_NULLABLE_TYPE)
  856|      0|    cancellationHandler {
  857|      0|  @synchronized(self) {
  858|      0|    GTMSessionMonitorSynchronized(self);
  859|      0|
  860|      0|    _cancellationHandler = cancellationHandler;
  861|      0|  }
  862|      0|}
  863|       |
  864|      0|- (GTMSessionUploadFetcherCancellationHandler GTM_NULLABLE_TYPE)cancellationHandler {
  865|      0|  @synchronized(self) {
  866|      0|    GTMSessionMonitorSynchronized(self);
  867|      0|
  868|      0|    return _cancellationHandler;
  869|      0|  }
  870|      0|}
  871|       |
  872|      0|- (void)beginFetchForRetry {
  873|      0|  GTMSessionCheckNotSynchronized(self);
  874|      0|
  875|      0|  // Override the superclass to reset the initial body length and fetcher-in-flight,
  876|      0|  // then call the superclass implementation.
  877|      0|  [self setInitialBodyLength:[self bodyLength]];
  878|      0|
  879|      0|  GTMSESSION_ASSERT_DEBUG(self.fetcherInFlight == nil, @"unexpected fetcher in flight: %@",
  880|      0|                          self.fetcherInFlight);
  881|      0|  self.fetcherInFlight = self;
  882|      0|  [super beginFetchForRetry];
  883|      0|}
  884|       |
  885|      0|- (void)beginFetchWithCompletionHandler:(GTMSessionFetcherCompletionHandler)handler {
  886|      0|  GTMSessionCheckNotSynchronized(self);
  887|      0|
  888|      0|  [self setInitialBodyLength:[self bodyLength]];
  889|      0|
  890|      0|  // We'll hold onto the superclass's callback queue so we can invoke the handler
  891|      0|  // even after the superclass has released the queue and its callback handler, as
  892|      0|  // happens during auth failure.
  893|      0|  [self setDelegateCallbackQueue:self.callbackQueue];
  894|      0|  self.completionHandler = handler;
  895|      0|
  896|      0|  if ([self isRestartedUpload]) {
  897|      0|    // When restarting an upload, we know the destination location for chunk fetches,
  898|      0|    // but we need to query to find the initial offset.
  899|      0|    if (![self isPaused]) {
  900|      0|      [self sendQueryForUploadOffsetWithFetcherProperties:self.properties];
  901|      0|    }
  902|      0|    return;
  903|      0|  }
  904|      0|  // We don't want to call into the client's completion block immediately
  905|      0|  // after the finish of the initial connection (the delegate is called only
  906|      0|  // when uploading finishes), so we substitute our own completion block to be
  907|      0|  // called when the initial connection finishes
  908|      0|  GTMSESSION_ASSERT_DEBUG(self.fetcherInFlight == nil, @"unexpected fetcher in flight: %@",
  909|      0|                          self.fetcherInFlight);
  910|      0|
  911|      0|  self.fetcherInFlight = self;
  912|      0|  [super beginFetchWithCompletionHandler:^(NSData *data, NSError *error) {
  913|      0|    self.fetcherInFlight = nil;
  914|      0|    // callback
  915|      0|
  916|      0|    BOOL hasTestBlock = (self.testBlock != nil);
  917|      0|    if (![self isRestartedUpload] && !hasTestBlock) {
  918|      0|      if (error == nil) {
  919|      0|        [self beginChunkFetches];
  920|      0|      } else {
  921|      0|        if ([self retryTimer] == nil) {
  922|      0|          [self invokeFinalCallbackWithData:nil
  923|      0|                                      error:error
  924|      0|                   shouldInvalidateLocation:YES];
  925|      0|        }
  926|      0|      }
  927|      0|    } else {
  928|      0|      // If there was no initial request, then this fetch is resuming some
  929|      0|      // other uploadFetcher's initial request, and the superclass's connection
  930|      0|      // is never used, so at this point we call the user's actual completion
  931|      0|      // block.
  932|      0|      if (!hasTestBlock) {
  933|      0|        [self invokeFinalCallbackWithData:data
  934|      0|                                    error:error
  935|      0|                 shouldInvalidateLocation:YES];
  936|      0|      } else {
  937|      0|        // There was a test block, so we won't do chunk fetches, but we simulate obtaining
  938|      0|        // the data to be uploaded from the upload data provider block or the file handle,
  939|      0|        // and then call back.
  940|      0|        [self generateChunkSubdataWithOffset:0
  941|      0|                                      length:[self fullUploadLength]
  942|      0|                                    response:^(NSData *generateData, int64_t fullUploadLength, NSError *generateError) {
  943|      0|            [self invokeFinalCallbackWithData:data
  944|      0|                                        error:error
  945|      0|                     shouldInvalidateLocation:YES];
  946|      0|        }];
  947|      0|      }
  948|      0|    }
  949|      0|  }];
  950|      0|}
  951|       |
  952|      0|- (void)beginChunkFetches {
  953|      0|  GTMSessionCheckNotSynchronized(self);
  954|      0|
  955|      0|#if DEBUG
  956|      0|  // The initial response of the resumable upload protocol should have an
  957|      0|  // empty body
  958|      0|  //
  959|      0|  // This assert typically happens because the upload create/edit link URL was
  960|      0|  // not supplied with the request, and the server is thus expecting a non-
  961|      0|  // resumable request/response.
  962|      0|  if (self.downloadedData.length > 0) {
  963|      0|    NSData *downloadedData = self.downloadedData;
  964|      0|    NSString *str = [[NSString alloc] initWithData:downloadedData
  965|      0|                                          encoding:NSUTF8StringEncoding];
  966|      0|    #pragma unused(str)
  967|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"unexpected response data (uploading to the wrong URL?)\n%@", str);
  968|      0|  }
  969|      0|#endif
  970|      0|
  971|      0|  // We need to get the upload URL from the location header to continue.
  972|      0|  NSDictionary *responseHeaders = [self responseHeaders];
  973|      0|
  974|      0|  [self retrieveUploadChunkGranularityFromResponseHeaders:responseHeaders];
  975|      0|
  976|      0|  GTMSessionUploadFetcherStatus uploadStatus =
  977|      0|      [[self class] uploadStatusFromResponseHeaders:responseHeaders];
  978|      0|  GTMSESSION_ASSERT_DEBUG(uploadStatus != kStatusUnknown,
  979|      0|      @"beginChunkFetches has unexpected upload status for headers %@", responseHeaders);
  980|      0|
  981|      0|  BOOL isPrematureStop = (uploadStatus == kStatusFinal) || (uploadStatus == kStatusCancelled);
  982|      0|
  983|      0|  NSString *uploadLocationURLStr = [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadURL];
  984|      0|  BOOL hasUploadLocation = (uploadLocationURLStr.length > 0);
  985|      0|
  986|      0|  if (isPrematureStop || !hasUploadLocation) {
  987|      0|    GTMSESSION_ASSERT_DEBUG(NO, @"Premature failure: upload-status:\"%@\"  location:%@",
  988|      0|        [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadStatus], uploadLocationURLStr);
  989|      0|    // We cannot continue since we do not know the location to use
  990|      0|    // as our upload destination.
  991|      0|    NSDictionary *userInfo = nil;
  992|      0|    NSData *downloadedData = self.downloadedData;
  993|      0|    if (downloadedData.length > 0) {
  994|      0|      userInfo = @{ kGTMSessionFetcherStatusDataKey : downloadedData };
  995|      0|    }
  996|      0|    NSError *failureError = [self prematureFailureErrorWithUserInfo:userInfo];
  997|      0|    [self invokeFinalCallbackWithData:nil
  998|      0|                                error:failureError
  999|      0|             shouldInvalidateLocation:YES];
 1000|      0|    return;
 1001|      0|  }
 1002|      0|
 1003|      0|  self.uploadLocationURL = [NSURL URLWithString:uploadLocationURLStr];
 1004|      0|
 1005|      0|  NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
 1006|      0|  [nc postNotificationName:kGTMSessionFetcherUploadLocationObtainedNotification
 1007|      0|                    object:self];
 1008|      0|
 1009|      0|  // we've now sent all of the initial post body data, so we need to include
 1010|      0|  // its size in future progress indicator callbacks
 1011|      0|  [self setInitialBodySent:[self initialBodyLength]];
 1012|      0|
 1013|      0|  // just in case the user paused us during the initial fetch...
 1014|      0|  if (![self isPaused]) {
 1015|      0|    [self uploadNextChunkWithOffset:0];
 1016|      0|  }
 1017|      0|}
 1018|       |
 1019|       |- (void)URLSession:(NSURLSession *)session
 1020|       |              task:(NSURLSessionTask *)task
 1021|       |   didSendBodyData:(int64_t)bytesSent
 1022|       |    totalBytesSent:(int64_t)totalBytesSent
 1023|      0|    totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
 1024|      0|  // Overrides the superclass.
 1025|      0|  [self invokeDelegateWithDidSendBytes:bytesSent
 1026|      0|                        totalBytesSent:totalBytesSent
 1027|      0|              totalBytesExpectedToSend:totalBytesExpectedToSend + [self fullUploadLength]];
 1028|      0|}
 1029|       |
 1030|      0|- (BOOL)shouldReleaseCallbacksUponCompletion {
 1031|      0|  // Overrides the superclass.
 1032|      0|
 1033|      0|  // We don't want the superclass to release the delegate and callback
 1034|      0|  // blocks once the initial fetch has finished
 1035|      0|  //
 1036|      0|  // This is invoked for only successful completion of the connection;
 1037|      0|  // an error always will invoke and release the callbacks
 1038|      0|  return NO;
 1039|      0|}
 1040|       |
 1041|       |- (void)invokeFinalCallbackWithData:(NSData *)data
 1042|       |                              error:(NSError *)error
 1043|      0|           shouldInvalidateLocation:(BOOL)shouldInvalidateLocation {
 1044|      0|  @synchronized(self) {
 1045|      0|    GTMSessionMonitorSynchronized(self);
 1046|      0|
 1047|      0|    if (shouldInvalidateLocation) {
 1048|      0|      _uploadLocationURL = nil;
 1049|      0|    }
 1050|      0|
 1051|      0|    dispatch_queue_t queue = _delegateCallbackQueue;
 1052|      0|    GTMSessionFetcherCompletionHandler handler = _delegateCompletionHandler;
 1053|      0|    if (queue && handler) {
 1054|      0|      [self invokeOnCallbackQueue:queue
 1055|      0|                 afterUserStopped:NO
 1056|      0|                            block:^{
 1057|      0|          handler(data, error);
 1058|      0|      }];
 1059|      0|    }
 1060|      0|  }  // @synchronized(self)
 1061|      0|
 1062|      0|  [self releaseUploadAndBaseCallbacks:!self.userStoppedFetching];
 1063|      0|}
 1064|       |
 1065|      0|- (void)releaseUploadAndBaseCallbacks:(BOOL)shouldReleaseCancellation {
 1066|      0|  @synchronized(self) {
 1067|      0|    GTMSessionMonitorSynchronized(self);
 1068|      0|
 1069|      0|    _delegateCallbackQueue = nil;
 1070|      0|    _delegateCompletionHandler = nil;
 1071|      0|    _uploadDataProvider = nil;
 1072|      0|    if (shouldReleaseCancellation) {
 1073|      0|      _cancellationHandler = nil;
 1074|      0|    }
 1075|      0|  }
 1076|      0|
 1077|      0|  // Release the base class's callbacks, too, if needed.
 1078|      0|  [self releaseCallbacks];
 1079|      0|}
 1080|       |
 1081|      0|- (void)stopFetchReleasingCallbacks:(BOOL)shouldReleaseCallbacks {
 1082|      0|  GTMSessionCheckNotSynchronized(self);
 1083|      0|
 1084|      0|  // Clear _fetcherInFlight when stopped. Moved from stopFetching, since that's a public method,
 1085|      0|  // where this method does the work. Fixes issue clearing value when retryBlock included.
 1086|      0|  GTMSessionFetcher *fetcherInFlight = self.fetcherInFlight;
 1087|      0|  if (fetcherInFlight == self) {
 1088|      0|    self.fetcherInFlight = nil;
 1089|      0|  }
 1090|      0|
 1091|      0|  [super stopFetchReleasingCallbacks:shouldReleaseCallbacks];
 1092|      0|
 1093|      0|  if (shouldReleaseCallbacks) {
 1094|      0|    [self releaseUploadAndBaseCallbacks:NO];
 1095|      0|  }
 1096|      0|}
 1097|       |
 1098|       |#pragma mark Chunk fetching methods
 1099|       |
 1100|      0|- (void)uploadNextChunkWithOffset:(int64_t)offset {
 1101|      0|  // use the properties in each chunk fetcher
 1102|      0|  NSDictionary *props = [self properties];
 1103|      0|
 1104|      0|  [self uploadNextChunkWithOffset:offset
 1105|      0|                fetcherProperties:props];
 1106|      0|}
 1107|       |
 1108|      0|- (void)sendQueryForUploadOffsetWithFetcherProperties:(NSDictionary *)props {
 1109|      0|  GTMSessionFetcher *queryFetcher = [self uploadFetcherWithProperties:props
 1110|      0|                                                         isQueryFetch:YES];
 1111|      0|  queryFetcher.bodyData = [NSData data];
 1112|      0|
 1113|      0|  NSString *originalComment = self.comment;
 1114|      0|  [queryFetcher setCommentWithFormat:@"%@ (query offset)",
 1115|      0|   originalComment ? originalComment : @"upload"];
 1116|      0|
 1117|      0|  [queryFetcher setRequestValue:@"query" forHTTPHeaderField:kGTMSessionHeaderXGoogUploadCommand];
 1118|      0|
 1119|      0|  self.fetcherInFlight = queryFetcher;
 1120|      0|  [queryFetcher beginFetchWithDelegate:self
 1121|      0|                     didFinishSelector:@selector(queryFetcher:finishedWithData:error:)];
 1122|      0|}
 1123|       |
 1124|       |- (void)queryFetcher:(GTMSessionFetcher *)queryFetcher
 1125|       |    finishedWithData:(NSData *)data
 1126|      0|               error:(NSError *)error {
 1127|      0|  self.fetcherInFlight = nil;
 1128|      0|
 1129|      0|  NSDictionary *responseHeaders = [queryFetcher responseHeaders];
 1130|      0|  NSString *sizeReceivedHeader;
 1131|      0|
 1132|      0|  GTMSessionUploadFetcherStatus uploadStatus =
 1133|      0|      [[self class] uploadStatusFromResponseHeaders:responseHeaders];
 1134|      0|  GTMSESSION_ASSERT_DEBUG(uploadStatus != kStatusUnknown || error != nil,
 1135|      0|      @"query fetcher completion has unexpected upload status for headers %@", responseHeaders);
 1136|      0|
 1137|      0|  if (error == nil) {
 1138|      0|    sizeReceivedHeader = [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadSizeReceived];
 1139|      0|
 1140|      0|    if (uploadStatus == kStatusCancelled ||
 1141|      0|        (uploadStatus == kStatusActive && sizeReceivedHeader == nil)) {
 1142|      0|      NSDictionary *userInfo = nil;
 1143|      0|      if (data.length > 0) {
 1144|      0|        userInfo = @{ kGTMSessionFetcherStatusDataKey : data };
 1145|      0|      }
 1146|      0|      error = [self prematureFailureErrorWithUserInfo:userInfo];
 1147|      0|    }
 1148|      0|  }
 1149|      0|
 1150|      0|  if (error == nil) {
 1151|      0|    int64_t offset = [sizeReceivedHeader longLongValue];
 1152|      0|    int64_t fullUploadLength = [self fullUploadLength];
 1153|      0|    if (uploadStatus == kStatusFinal ||
 1154|      0|        (offset >= fullUploadLength &&
 1155|      0|         fullUploadLength != kGTMSessionUploadFetcherUnknownFileSize)) {
 1156|      0|      // Handle we're done
 1157|      0|      [self chunkFetcher:queryFetcher finishedWithData:data error:nil];
 1158|      0|    } else {
 1159|      0|      [self retrieveUploadChunkGranularityFromResponseHeaders:responseHeaders];
 1160|      0|      [self uploadNextChunkWithOffset:offset];
 1161|      0|    }
 1162|      0|  } else {
 1163|      0|    // Handle query error
 1164|      0|    [self chunkFetcher:queryFetcher finishedWithData:data error:error];
 1165|      0|  }
 1166|      0|}
 1167|       |
 1168|      0|- (void)sendCancelUploadWithFetcherProperties:(NSDictionary *)props {
 1169|      0|  @synchronized(self) {
 1170|      0|    _isCancelInFlight = YES;
 1171|      0|  }
 1172|      0|  GTMSessionFetcher *cancelFetcher = [self uploadFetcherWithProperties:props
 1173|      0|                                                          isQueryFetch:YES];
 1174|      0|  cancelFetcher.bodyData = [NSData data];
 1175|      0|
 1176|      0|  NSString *originalComment = self.comment;
 1177|      0|  [cancelFetcher setCommentWithFormat:@"%@ (cancel)",
 1178|      0|      originalComment ? originalComment : @"upload"];
 1179|      0|
 1180|      0|  [cancelFetcher setRequestValue:@"cancel" forHTTPHeaderField:kGTMSessionHeaderXGoogUploadCommand];
 1181|      0|
 1182|      0|  self.fetcherInFlight = cancelFetcher;
 1183|      0|  [cancelFetcher beginFetchWithCompletionHandler:^(NSData *data, NSError *error) {
 1184|      0|      self.fetcherInFlight = nil;
 1185|      0|      if (![self triggerCancellationHandlerForFetch:cancelFetcher data:data error:error]) {
 1186|      0|        if (error) {
 1187|      0|          GTMSESSION_LOG_DEBUG(@"cancelFetcher %@", error);
 1188|      0|        }
 1189|      0|      }
 1190|      0|      @synchronized(self) {
 1191|      0|        self->_isCancelInFlight = NO;
 1192|      0|      }
 1193|      0|  }];
 1194|      0|}
 1195|       |
 1196|       |- (void)uploadNextChunkWithOffset:(int64_t)offset
 1197|      0|                fetcherProperties:(NSDictionary *)props {
 1198|      0|  GTMSessionCheckNotSynchronized(self);
 1199|      0|
 1200|      0|  // Example chunk headers:
 1201|      0|  //  X-Goog-Upload-Command: upload, finalize
 1202|      0|  //  X-Goog-Upload-Offset: 0
 1203|      0|  //  Content-Length: 2000000
 1204|      0|  //  Content-Type: image/jpeg
 1205|      0|  //
 1206|      0|  //  {bytes 0-1999999}
 1207|      0|
 1208|      0|  // The chunk upload URL requires no authentication header.
 1209|      0|  GTMSessionFetcher *chunkFetcher = [self uploadFetcherWithProperties:props
 1210|      0|                                                         isQueryFetch:NO];
 1211|      0|  [self attachSendProgressBlockToChunkFetcher:chunkFetcher];
 1212|      0|  int64_t chunkSize = [self updateChunkFetcher:chunkFetcher
 1213|      0|                              forChunkAtOffset:offset];
 1214|      0|  BOOL isUploadingFileURL = (self.uploadFileURL != nil);
 1215|      0|  int64_t fullUploadLength = [self fullUploadLength];
 1216|      0|
 1217|      0|  // The chunk size may have changed, so determine again if we're uploading the full file.
 1218|      0|  BOOL isUploadingFullFile = (offset == 0 &&
 1219|      0|                              fullUploadLength != kGTMSessionUploadFetcherUnknownFileSize &&
 1220|      0|                              chunkSize >= fullUploadLength);
 1221|      0|  if (isUploadingFullFile && isUploadingFileURL) {
 1222|      0|    // The data is the full upload file URL.
 1223|      0|    chunkFetcher.bodyFileURL = self.uploadFileURL;
 1224|      0|    [self beginChunkFetcher:chunkFetcher
 1225|      0|                     offset:offset];
 1226|      0|  } else {
 1227|      0|    // Make an NSData for the subset for this upload chunk.
 1228|      0|    self.subdataGenerating = YES;
 1229|      0|    [self generateChunkSubdataWithOffset:offset
 1230|      0|                                  length:chunkSize
 1231|      0|                                response:^(NSData *chunkData, int64_t uploadFileLength, NSError *chunkError) {
 1232|      0|      // The subdata methods may leave us on a background thread.
 1233|      0|      dispatch_async(dispatch_get_main_queue(), ^{
 1234|      0|        self.subdataGenerating = NO;
 1235|      0|
 1236|      0|        // dont allow the updating of fileLength for uploads not using a data provider as they
 1237|      0|        // should know the file length before the upload starts.
 1238|      0|        if (self->_uploadDataProvider != nil && uploadFileLength > 0) {
 1239|      0|          [self setUploadFileLength:uploadFileLength];
 1240|      0|          // Update the command and content-length headers if this is the last chunk to be sent.
 1241|      0|          if (offset + chunkSize >= uploadFileLength) {
 1242|      0|            int64_t updatedChunkSize = [self updateChunkFetcher:chunkFetcher
 1243|      0|                                               forChunkAtOffset:offset];
 1244|      0|            if (updatedChunkSize == 0) {
 1245|      0|              // Calling beginChunkFetcher early when there is no more data to send allows us to
 1246|      0|              // properly handle nil chunkData below without having to account for the case where
 1247|      0|              // we are just finalizing the file.
 1248|      0|              chunkFetcher.bodyData = [[NSData alloc] init];
 1249|      0|              [self beginChunkFetcher:chunkFetcher
 1250|      0|                               offset:offset];
 1251|      0|              return;
 1252|      0|            }
 1253|      0|          }
 1254|      0|        }
 1255|      0|
 1256|      0|        if (chunkData == nil) {
 1257|      0|          NSError *responseError = chunkError;
 1258|      0|          if (!responseError) {
 1259|      0|            responseError = [self uploadChunkUnavailableErrorWithDescription:@"chunkData is nil"];
 1260|      0|          }
 1261|      0|          [self invokeFinalCallbackWithData:nil
 1262|      0|                                      error:responseError
 1263|      0|                   shouldInvalidateLocation:YES];
 1264|      0|          return;
 1265|      0|        }
 1266|      0|
 1267|      0|        BOOL didWriteFile = NO;
 1268|      0|        if (isUploadingFileURL) {
 1269|      0|          // Make a temporary file with the data subset.
 1270|      0|          NSString *tempName =
 1271|      0|              [NSString stringWithFormat:@"GTMUpload_temp_%@", [[NSUUID UUID] UUIDString]];
 1272|      0|          NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:tempName];
 1273|      0|          NSError *writeError;
 1274|      0|          didWriteFile = [chunkData writeToFile:tempPath
 1275|      0|                                        options:NSDataWritingAtomic
 1276|      0|                                          error:&writeError];
 1277|      0|          if (didWriteFile) {
 1278|      0|            chunkFetcher.bodyFileURL = [NSURL fileURLWithPath:tempPath];
 1279|      0|          } else {
 1280|      0|            GTMSESSION_LOG_DEBUG(@"writeToFile failed: %@\n%@", writeError, tempPath);
 1281|      0|          }
 1282|      0|        }
 1283|      0|        if (!didWriteFile) {
 1284|      0|          chunkFetcher.bodyData = [chunkData copy];
 1285|      0|        }
 1286|      0|        [self beginChunkFetcher:chunkFetcher
 1287|      0|                         offset:offset];
 1288|      0|      });
 1289|      0|    }];
 1290|      0|  }
 1291|      0|}
 1292|       |
 1293|       |- (void)beginChunkFetcher:(GTMSessionFetcher *)chunkFetcher
 1294|      0|                   offset:(int64_t)offset {
 1295|      0|
 1296|      0|  // Track the current offset for progress reporting
 1297|      0|  self.currentOffset = offset;
 1298|      0|
 1299|      0|  // Hang on to the fetcher in case we need to cancel it.  We set these before beginning the
 1300|      0|  // chunk fetch so the observers notified of chunk fetches can inspect the upload fetcher to
 1301|      0|  // match to the chunk.
 1302|      0|  self.chunkFetcher = chunkFetcher;
 1303|      0|  self.fetcherInFlight = chunkFetcher;
 1304|      0|
 1305|      0|  // Update the last chunk request, including any request headers.
 1306|      0|  self.lastChunkRequest = chunkFetcher.request;
 1307|      0|
 1308|      0|  [chunkFetcher beginFetchWithDelegate:self
 1309|      0|                     didFinishSelector:@selector(chunkFetcher:finishedWithData:error:)];
 1310|      0|}
 1311|       |
 1312|      0|- (void)attachSendProgressBlockToChunkFetcher:(GTMSessionFetcher *)chunkFetcher {
 1313|      0|  chunkFetcher.sendProgressBlock = ^(int64_t bytesSent, int64_t totalBytesSent,
 1314|      0|                                     int64_t totalBytesExpectedToSend) {
 1315|      0|    // The total bytes expected include the initial body and the full chunked
 1316|      0|    // data, independent of how big this fetcher's chunk is.
 1317|      0|    int64_t initialBodySent = [self bodyLength];  // TODO(grobbins) use [self initialBodySent]
 1318|      0|    int64_t totalSent = initialBodySent + self.currentOffset + totalBytesSent;
 1319|      0|    int64_t totalExpected = initialBodySent + [self fullUploadLength];
 1320|      0|
 1321|      0|    [self invokeDelegateWithDidSendBytes:bytesSent
 1322|      0|                          totalBytesSent:totalSent
 1323|      0|                totalBytesExpectedToSend:totalExpected];
 1324|      0|  };
 1325|      0|}
 1326|       |
 1327|      0|- (NSDictionary *)uploadSessionIdentifierMetadata {
 1328|      0|  NSMutableDictionary *metadata = [NSMutableDictionary dictionary];
 1329|      0|  metadata[kGTMSessionIdentifierIsUploadChunkFetcherMetadataKey] = @YES;
 1330|      0|  GTMSESSION_ASSERT_DEBUG(self.uploadFileURL,
 1331|      0|                          @"Invalid upload fetcher to create session identifier for metadata");
 1332|      0|  metadata[kGTMSessionIdentifierUploadFileURLMetadataKey] = [self.uploadFileURL absoluteString];
 1333|      0|  metadata[kGTMSessionIdentifierUploadFileLengthMetadataKey] = @([self fullUploadLength]);
 1334|      0|
 1335|      0|  if (self.uploadLocationURL) {
 1336|      0|    metadata[kGTMSessionIdentifierUploadLocationURLMetadataKey] =
 1337|      0|        [self.uploadLocationURL absoluteString];
 1338|      0|  }
 1339|      0|  if (self.uploadMIMEType) {
 1340|      0|    metadata[kGTMSessionIdentifierUploadMIMETypeMetadataKey] = self.uploadMIMEType;
 1341|      0|  }
 1342|      0|  metadata[kGTMSessionIdentifierUploadChunkSizeMetadataKey] = @(self.chunkSize);
 1343|      0|  metadata[kGTMSessionIdentifierUploadCurrentOffsetMetadataKey] = @(self.currentOffset);
 1344|      0|  metadata[kGTMSessionIdentifierUploadAllowsCellularAccess] = @(self.request.allowsCellularAccess);
 1345|      0|
 1346|      0|  return metadata;
 1347|      0|}
 1348|       |
 1349|       |- (GTMSessionFetcher *)uploadFetcherWithProperties:(NSDictionary *)properties
 1350|      0|                                      isQueryFetch:(BOOL)isQueryFetch {
 1351|      0|  GTMSessionCheckNotSynchronized(self);
 1352|      0|
 1353|      0|  // Common code to make a request for a query command or for a chunk upload.
 1354|      0|  NSURL *uploadLocationURL = self.uploadLocationURL;
 1355|      0|  NSMutableURLRequest *chunkRequest = [NSMutableURLRequest requestWithURL:uploadLocationURL];
 1356|      0|  [chunkRequest setHTTPMethod:@"PUT"];
 1357|      0|
 1358|      0|  // copy the user-agent from the original connection
 1359|      0|  // n.b. that self.request is nil for upload fetchers created with an existing upload location
 1360|      0|  // URL.
 1361|      0|  NSURLRequest *origRequest = self.request;
 1362|      0|
 1363|      0|  chunkRequest.allowsCellularAccess = origRequest.allowsCellularAccess;
 1364|      0|  if (!origRequest) {
 1365|      0|    chunkRequest.allowsCellularAccess = _allowsCellularAccess;
 1366|      0|  }
 1367|      0|  NSString *userAgent = [origRequest valueForHTTPHeaderField:@"User-Agent"];
 1368|      0|  if (userAgent.length > 0) {
 1369|      0|    [chunkRequest setValue:userAgent forHTTPHeaderField:@"User-Agent"];
 1370|      0|  }
 1371|      0|
 1372|      0|  [chunkRequest setValue:kGTMSessionXGoogUploadProtocolResumable
 1373|      0|      forHTTPHeaderField:kGTMSessionHeaderXGoogUploadProtocol];
 1374|      0|
 1375|      0|  // To avoid timeouts when debugging, copy the timeout of the initial fetcher.
 1376|      0|  NSTimeInterval origTimeout = [origRequest timeoutInterval];
 1377|      0|  [chunkRequest setTimeoutInterval:origTimeout];
 1378|      0|
 1379|      0|  //
 1380|      0|  // Make a new chunk fetcher.
 1381|      0|  //
 1382|      0|  GTMSessionFetcher *chunkFetcher = [GTMSessionFetcher fetcherWithRequest:chunkRequest];
 1383|      0|  chunkFetcher.callbackQueue = self.callbackQueue;
 1384|      0|  chunkFetcher.sessionUserInfo = self.sessionUserInfo;
 1385|      0|  chunkFetcher.configurationBlock = self.configurationBlock;
 1386|      0|  chunkFetcher.allowedInsecureSchemes = self.allowedInsecureSchemes;
 1387|      0|  chunkFetcher.allowLocalhostRequest = self.allowLocalhostRequest;
 1388|      0|  chunkFetcher.allowInvalidServerCertificates = self.allowInvalidServerCertificates;
 1389|      0|  chunkFetcher.useUploadTask = !isQueryFetch;
 1390|      0|
 1391|      0|  if (self.uploadFileURL && !isQueryFetch && self.useBackgroundSession) {
 1392|      0|    [chunkFetcher createSessionIdentifierWithMetadata:[self uploadSessionIdentifierMetadata]];
 1393|      0|  }
 1394|      0|
 1395|      0|  // Give the chunk fetcher the same properties as the previous chunk fetcher
 1396|      0|  chunkFetcher.properties = [properties mutableCopy];
 1397|      0|  [chunkFetcher setProperty:[NSValue valueWithNonretainedObject:self]
 1398|      0|                     forKey:kGTMSessionUploadFetcherChunkParentKey];
 1399|      0|
 1400|      0|  // copy other fetcher settings to the new fetcher
 1401|      0|  chunkFetcher.retryEnabled = self.retryEnabled;
 1402|      0|  chunkFetcher.maxRetryInterval = self.maxRetryInterval;
 1403|      0|
 1404|      0|  if ([self isRetryEnabled]) {
 1405|      0|    // We interpose our own retry method both so we can change the request to ask the server to
 1406|      0|    // tell us where to resume the chunk.
 1407|      0|    chunkFetcher.retryBlock = ^(BOOL suggestedWillRetry, NSError *chunkError,
 1408|      0|                                GTMSessionFetcherRetryResponse response) {
 1409|      0|      void (^finish)(BOOL) = ^(BOOL shouldRetry){
 1410|      0|        // We'll retry by sending an offset query.
 1411|      0|        if (shouldRetry) {
 1412|      0|          self.shouldInitiateOffsetQuery = !isQueryFetch;
 1413|      0|
 1414|      0|          // We don't know what our actual offset is anymore, but the server will tell us.
 1415|      0|          self.currentOffset = 0;
 1416|      0|        }
 1417|      0|        // We don't actually want to retry this specific fetcher.
 1418|      0|        response(NO);
 1419|      0|      };
 1420|      0|
 1421|      0|      GTMSessionFetcherRetryBlock retryBlock = self.retryBlock;
 1422|      0|      if (retryBlock) {
 1423|      0|        // Ask the client, then call the finish block above.
 1424|      0|        retryBlock(suggestedWillRetry, chunkError, finish);
 1425|      0|      } else {
 1426|      0|        finish(suggestedWillRetry);
 1427|      0|      }
 1428|      0|    };
 1429|      0|  }
 1430|      0|
 1431|      0|  return chunkFetcher;
 1432|      0|}
 1433|       |
 1434|       |- (void)chunkFetcher:(GTMSessionFetcher *)chunkFetcher
 1435|       |    finishedWithData:(NSData *)data
 1436|      0|               error:(NSError *)error {
 1437|      0|  BOOL hasDestroyedOldChunkFetcher = NO;
 1438|      0|  self.fetcherInFlight = nil;
 1439|      0|
 1440|      0|  NSDictionary *responseHeaders = [chunkFetcher responseHeaders];
 1441|      0|  GTMSessionUploadFetcherStatus uploadStatus =
 1442|      0|      [[self class] uploadStatusFromResponseHeaders:responseHeaders];
 1443|      0|  GTMSESSION_ASSERT_DEBUG(uploadStatus != kStatusUnknown
 1444|      0|                          || error != nil
 1445|      0|                          || self.wasCreatedFromBackgroundSession,
 1446|      0|      @"chunk fetcher completion has kStatusUnknown upload status for headers %@ fetcher %@",
 1447|      0|      responseHeaders, self);
 1448|      0|  BOOL isUploadStatusStopped = (uploadStatus == kStatusFinal || uploadStatus == kStatusCancelled);
 1449|      0|
 1450|      0|  // Check if the fetcher was actually querying. If it failed, do not retry,
 1451|      0|  // as it would enter an infinite retry loop.
 1452|      0|  NSString *uploadCommand =
 1453|      0|      chunkFetcher.request.allHTTPHeaderFields[kGTMSessionHeaderXGoogUploadCommand];
 1454|      0|  BOOL isQueryFetch = [uploadCommand isEqual:@"query"];
 1455|      0|
 1456|      0|  // TODO
 1457|      0|  // Maybe here we can check to see if the request had x goog content length set. (the file length one).
 1458|      0|  int64_t previousContentLength =
 1459|      0|      [[chunkFetcher.request valueForHTTPHeaderField:@"Content-Length"] longLongValue];
 1460|      0|  // The Content-Length header may not be present if the chunk fetcher was recreated from
 1461|      0|  // a background session.
 1462|      0|  BOOL hasKnownChunkSize = (previousContentLength > 0);
 1463|      0|  BOOL needsQuery = (!hasKnownChunkSize && !isUploadStatusStopped);
 1464|      0|
 1465|      0|  if (error || (needsQuery && !isQueryFetch)) {
 1466|      0|    NSInteger status = error.code;
 1467|      0|
 1468|      0|    // Status 4xx indicates a bad offset in the Google upload protocol. However, do not retry status
 1469|      0|    // 404 per spec, nor if the upload size appears to have been zero (since the server will just
 1470|      0|    // keep asking us to retry.)
 1471|      0|    if (self.shouldInitiateOffsetQuery ||
 1472|      0|        (needsQuery && !isQueryFetch) ||
 1473|      0|        ([error.domain isEqual:kGTMSessionFetcherStatusDomain] &&
 1474|      0|         status >= 400 && status <= 499 &&
 1475|      0|         status != 404 &&
 1476|      0|         uploadStatus == kStatusActive &&
 1477|      0|         previousContentLength > 0)) {
 1478|      0|      self.shouldInitiateOffsetQuery = NO;
 1479|      0|      [self destroyChunkFetcher];
 1480|      0|      hasDestroyedOldChunkFetcher = YES;
 1481|      0|      [self sendQueryForUploadOffsetWithFetcherProperties:chunkFetcher.properties];
 1482|      0|    } else {
 1483|      0|      // Some unexpected status has occurred; handle it as we would a regular
 1484|      0|      // object fetcher failure.
 1485|      0|      [self invokeFinalCallbackWithData:data
 1486|      0|                                  error:error
 1487|      0|               shouldInvalidateLocation:NO];
 1488|      0|    }
 1489|      0|  } else {
 1490|      0|    // The chunk has uploaded successfully.
 1491|      0|    int64_t newOffset = self.currentOffset + previousContentLength;
 1492|      0|#if DEBUG
 1493|      0|    // Verify that if we think all of the uploading data has been sent, the server responded with
 1494|      0|    // the "final" upload status.
 1495|      0|    BOOL hasUploadAllData = (newOffset == [self fullUploadLength]);
 1496|      0|    BOOL isFinalStatus = (uploadStatus == kStatusFinal);
 1497|      0|    #pragma unused(hasUploadAllData,isFinalStatus)
 1498|      0|    GTMSESSION_ASSERT_DEBUG(hasUploadAllData == isFinalStatus || !hasKnownChunkSize,
 1499|      0|                            @"uploadStatus:%@  newOffset:%lld (%lld + %lld)  fullUploadLength:%lld"
 1500|      0|                            @" chunkFetcher:%@ requestHeaders:%@ responseHeaders:%@",
 1501|      0|                            [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadStatus],
 1502|      0|                            newOffset, self.currentOffset, previousContentLength,
 1503|      0|                            [self fullUploadLength],
 1504|      0|                            chunkFetcher, chunkFetcher.request.allHTTPHeaderFields,
 1505|      0|                            responseHeaders);
 1506|      0|#endif
 1507|      0|    if (isUploadStatusStopped || (_currentOffset > _uploadFileLength && _uploadFileLength > 0)) {
 1508|      0|      // This was the last chunk.
 1509|      0|      if (error == nil && uploadStatus == kStatusCancelled) {
 1510|      0|        // Report cancelled status as an error.
 1511|      0|        NSDictionary *userInfo = nil;
 1512|      0|        if (data.length > 0) {
 1513|      0|          userInfo = @{ kGTMSessionFetcherStatusDataKey : data };
 1514|      0|        }
 1515|      0|        data = nil;
 1516|      0|        error = [self prematureFailureErrorWithUserInfo:userInfo];
 1517|      0|      } else {
 1518|      0|        // The upload is in final status.
 1519|      0|        //
 1520|      0|        // Take the chunk fetcher's data as the superclass data.
 1521|      0|        self.downloadedData = data;
 1522|      0|        self.statusCode = chunkFetcher.statusCode;
 1523|      0|      }
 1524|      0|
 1525|      0|      // we're done
 1526|      0|      [self invokeFinalCallbackWithData:data
 1527|      0|                                  error:error
 1528|      0|               shouldInvalidateLocation:YES];
 1529|      0|    } else {
 1530|      0|      // Start the next chunk.
 1531|      0|      self.currentOffset = newOffset;
 1532|      0|
 1533|      0|      // We want to destroy this chunk fetcher before creating the next one, but
 1534|      0|      // we want to pass on its properties
 1535|      0|      NSDictionary *props = [chunkFetcher properties];
 1536|      0|
 1537|      0|      // We no longer need to be able to cancel this chunkFetcher.  Destroy it
 1538|      0|      // before we create a new chunk fetcher.
 1539|      0|      [self destroyChunkFetcher];
 1540|      0|      hasDestroyedOldChunkFetcher = YES;
 1541|      0|
 1542|      0|      [self uploadNextChunkWithOffset:newOffset
 1543|      0|                    fetcherProperties:props];
 1544|      0|    }
 1545|      0|  }
 1546|      0|  if (!hasDestroyedOldChunkFetcher) {
 1547|      0|    [self destroyChunkFetcher];
 1548|      0|  }
 1549|      0|}
 1550|       |
 1551|      0|- (void)destroyChunkFetcher {
 1552|      0|  @synchronized(self) {
 1553|      0|    GTMSessionMonitorSynchronized(self);
 1554|      0|
 1555|      0|    if (_fetcherInFlight == _chunkFetcher) {
 1556|      0|      _fetcherInFlight = nil;
 1557|      0|    }
 1558|      0|
 1559|      0|    [_chunkFetcher stopFetching];
 1560|      0|
 1561|      0|    NSURL *chunkFileURL = _chunkFetcher.bodyFileURL;
 1562|      0|    BOOL wasTemporaryUploadFile = ![chunkFileURL isEqual:_uploadFileURL];
 1563|      0|    if (wasTemporaryUploadFile) {
 1564|      0|      NSError *error;
 1565|      0|      [[NSFileManager defaultManager] removeItemAtURL:chunkFileURL
 1566|      0|                                                error:&error];
 1567|      0|      if (error) {
 1568|      0|        GTMSESSION_LOG_DEBUG(@"removingItemAtURL failed: %@\n%@", error, chunkFileURL);
 1569|      0|      }
 1570|      0|    }
 1571|      0|
 1572|      0|    _recentChunkReponseHeaders = _chunkFetcher.responseHeaders;
 1573|      0|
 1574|      0|    // To avoid retain cycles, remove all properties except the parent identifier.
 1575|      0|    _chunkFetcher.properties =
 1576|      0|        @{ kGTMSessionUploadFetcherChunkParentKey : [NSValue valueWithNonretainedObject:self] };
 1577|      0|
 1578|      0|    _chunkFetcher.retryBlock = nil;
 1579|      0|    _chunkFetcher.sendProgressBlock = nil;
 1580|      0|    _chunkFetcher = nil;
 1581|      0|  }  // @synchronized(self)
 1582|      0|}
 1583|       |
 1584|       |// This method calculates the proper values to pass to the client's send progress block.
 1585|       |//
 1586|       |// The actual total bytes sent include the initial body sent, plus the
 1587|       |// offset into the batched data prior to the current chunk fetcher
 1588|       |
 1589|       |- (void)invokeDelegateWithDidSendBytes:(int64_t)bytesSent
 1590|       |                        totalBytesSent:(int64_t)totalBytesSent
 1591|      0|              totalBytesExpectedToSend:(int64_t)totalBytesExpected {
 1592|      0|  GTMSessionCheckNotSynchronized(self);
 1593|      0|
 1594|      0|  // Ensure the chunk fetcher survives the callback in case the user pauses the upload process.
 1595|      0|  __block GTMSessionFetcher *holdFetcher = self.chunkFetcher;
 1596|      0|
 1597|      0|  [self invokeOnCallbackQueue:self.delegateCallbackQueue
 1598|      0|             afterUserStopped:NO
 1599|      0|                        block:^{
 1600|      0|      GTMSessionFetcherSendProgressBlock sendProgressBlock = self.sendProgressBlock;
 1601|      0|      if (sendProgressBlock) {
 1602|      0|        sendProgressBlock(bytesSent, totalBytesSent, totalBytesExpected);
 1603|      0|      }
 1604|      0|      holdFetcher = nil;
 1605|      0|  }];
 1606|      0|}
 1607|       |
 1608|      0|- (void)retrieveUploadChunkGranularityFromResponseHeaders:(NSDictionary *)responseHeaders {
 1609|      0|  GTMSessionCheckNotSynchronized(self);
 1610|      0|
 1611|      0|  // Standard granularity for Google uploads is 256K.
 1612|      0|  NSString *chunkGranularityHeader =
 1613|      0|      [responseHeaders objectForKey:kGTMSessionHeaderXGoogUploadChunkGranularity];
 1614|      0|  self.uploadGranularity = chunkGranularityHeader.longLongValue;
 1615|      0|}
 1616|       |
 1617|       |#pragma mark -
 1618|       |
 1619|      0|- (BOOL)isPaused {
 1620|      0|  @synchronized(self) {
 1621|      0|    GTMSessionMonitorSynchronized(self);
 1622|      0|
 1623|      0|    return _isPaused;
 1624|      0|  }  // @synchronized(self)
 1625|      0|}
 1626|       |
 1627|      0|- (void)pauseFetching {
 1628|      0|  @synchronized(self) {
 1629|      0|    GTMSessionMonitorSynchronized(self);
 1630|      0|
 1631|      0|    _isPaused = YES;
 1632|      0|  }  // @synchronized(self)
 1633|      0|
 1634|      0|  // Pausing just means stopping the current chunk from uploading;
 1635|      0|  // when we resume, we will send a query request to the server to
 1636|      0|  // figure out what bytes to resume sending.
 1637|      0|  //
 1638|      0|  // We won't try to cancel the initial data upload, but rather will check
 1639|      0|  // for being paused in beginChunkFetches.
 1640|      0|  [self destroyChunkFetcher];
 1641|      0|}
 1642|       |
 1643|      0|- (void)resumeFetching {
 1644|      0|  BOOL wasPaused;
 1645|      0|
 1646|      0|  @synchronized(self) {
 1647|      0|    GTMSessionMonitorSynchronized(self);
 1648|      0|
 1649|      0|    wasPaused = _isPaused;
 1650|      0|    _isPaused = NO;
 1651|      0|  }  // @synchronized(self)
 1652|      0|
 1653|      0|  if (wasPaused) {
 1654|      0|    [self sendQueryForUploadOffsetWithFetcherProperties:self.properties];
 1655|      0|  }
 1656|      0|}
 1657|       |
 1658|      0|- (void)stopFetching {
 1659|      0|  // Overrides the superclass
 1660|      0|  [self destroyChunkFetcher];
 1661|      0|
 1662|      0|  // If we think the server is waiting for more data, then tell it there won't be more.
 1663|      0|  if (self.uploadLocationURL) {
 1664|      0|    [self sendCancelUploadWithFetcherProperties:[self properties]];
 1665|      0|    self.uploadLocationURL = nil;
 1666|      0|  } else {
 1667|      0|    [self invokeOnCallbackQueue:self.callbackQueue
 1668|      0|               afterUserStopped:YES
 1669|      0|                          block:^{
 1670|      0|      // Repeated calls to stopFetching may cause this path to be reached despite having sent a real
 1671|      0|      // cancel request, check here to ensure that the cancellation handler invocation which fires
 1672|      0|      // will definitely be for the real request sent previously.
 1673|      0|      @synchronized(self) {
 1674|      0|        if (self->_isCancelInFlight) {
 1675|      0|          return;
 1676|      0|        }
 1677|      0|      }
 1678|      0|      [self triggerCancellationHandlerForFetch:nil data:nil error:nil];
 1679|      0|    }];
 1680|      0|  }
 1681|      0|
 1682|      0|  [super stopFetching];
 1683|      0|}
 1684|       |
 1685|       |// Fires the cancellation handler, returning whether there was a handler to be fired.
 1686|       |- (BOOL)triggerCancellationHandlerForFetch:(GTMSessionFetcher *)fetcher
 1687|       |                                      data:(NSData *)data
 1688|      0|                                     error:(NSError *)error {
 1689|      0|  GTMSessionUploadFetcherCancellationHandler handler = self.cancellationHandler;
 1690|      0|  if (handler) {
 1691|      0|    handler(fetcher, data, error);
 1692|      0|    self.cancellationHandler = nil;
 1693|      0|    return YES;
 1694|      0|  }
 1695|      0|  return NO;
 1696|      0|}
 1697|       |
 1698|       |#pragma mark -
 1699|       |
 1700|       |- (int64_t)updateChunkFetcher:(GTMSessionFetcher *)chunkFetcher
 1701|      0|             forChunkAtOffset:(int64_t)offset {
 1702|      0|  BOOL isUploadingFileURL = (self.uploadFileURL != nil);
 1703|      0|
 1704|      0|  // Upload another chunk, meeting server-required granularity.
 1705|      0|  int64_t chunkSize = self.chunkSize;
 1706|      0|
 1707|      0|  int64_t fullUploadLength = [self fullUploadLength];
 1708|      0|  BOOL isFileLengthKnown = fullUploadLength >= 0;
 1709|      0|
 1710|      0|  BOOL isUploadingFullFile = (offset == 0 && isFileLengthKnown && chunkSize >= fullUploadLength);
 1711|      0|  if (!isUploadingFileURL || !isUploadingFullFile) {
 1712|      0|    // We're not uploading the entire file and given the file URL.  Since we'll be
 1713|      0|    // allocating a subdata block for a chunk, we need to bound it to something that
 1714|      0|    // won't blow the process's memory.
 1715|      0|    if (chunkSize > kGTMSessionUploadFetcherMaximumDemandBufferSize) {
 1716|      0|      chunkSize = kGTMSessionUploadFetcherMaximumDemandBufferSize;
 1717|      0|    }
 1718|      0|  }
 1719|      0|
 1720|      0|  int64_t granularity = self.uploadGranularity;
 1721|      0|  if (granularity > 0) {
 1722|      0|    if (chunkSize < granularity) {
 1723|      0|      chunkSize = granularity;
 1724|      0|    } else {
 1725|      0|      chunkSize = chunkSize - (chunkSize % granularity);
 1726|      0|    }
 1727|      0|  }
 1728|      0|
 1729|      0|  GTMSESSION_ASSERT_DEBUG(offset < fullUploadLength || fullUploadLength == 0,
 1730|      0|                          @"offset %lld exceeds data length %lld", offset, fullUploadLength);
 1731|      0|
 1732|      0|  if (granularity > 0) {
 1733|      0|    offset = offset - (offset % granularity);
 1734|      0|  }
 1735|      0|
 1736|      0|  // If the chunk size is bigger than the remaining data, or else
 1737|      0|  // it's close enough in size to the remaining data that we'd rather
 1738|      0|  // avoid having a whole extra http fetch for the leftover bit, then make
 1739|      0|  // this chunk size exactly match the remaining data size
 1740|      0|  NSString *command;
 1741|      0|  int64_t thisChunkSize = chunkSize;
 1742|      0|
 1743|      0|  BOOL isChunkTooBig = (thisChunkSize >= (fullUploadLength - offset));
 1744|      0|  BOOL isChunkAlmostBigEnough = (fullUploadLength - offset - 2500 < thisChunkSize);
 1745|      0|  BOOL isFinalChunk = (isChunkTooBig || isChunkAlmostBigEnough) && isFileLengthKnown;
 1746|      0|  if (isFinalChunk) {
 1747|      0|    thisChunkSize = fullUploadLength - offset;
 1748|      0|    if (thisChunkSize > 0) {
 1749|      0|      command = @"upload, finalize";
 1750|      0|    } else {
 1751|      0|      command = @"finalize";
 1752|      0|    }
 1753|      0|  } else {
 1754|      0|    command = @"upload";
 1755|      0|  }
 1756|      0|  NSString *lengthStr = @(thisChunkSize).stringValue;
 1757|      0|  NSString *offsetStr = @(offset).stringValue;
 1758|      0|
 1759|      0|  [chunkFetcher setRequestValue:command forHTTPHeaderField:kGTMSessionHeaderXGoogUploadCommand];
 1760|      0|  [chunkFetcher setRequestValue:lengthStr forHTTPHeaderField:@"Content-Length"];
 1761|      0|  [chunkFetcher setRequestValue:offsetStr forHTTPHeaderField:kGTMSessionHeaderXGoogUploadOffset];
 1762|      0|  if (_uploadFileLength != kGTMSessionUploadFetcherUnknownFileSize) {
 1763|      0|    [chunkFetcher setRequestValue:@([self fullUploadLength]).stringValue
 1764|      0|               forHTTPHeaderField:kGTMSessionHeaderXGoogUploadContentLength];
 1765|      0|  }
 1766|      0|
 1767|      0|  // Append the range of bytes in this chunk to the fetcher comment.
 1768|      0|  NSString *baseComment = self.comment;
 1769|      0|  [chunkFetcher setCommentWithFormat:@"%@ (%lld-%lld)",
 1770|      0|      baseComment ? baseComment : @"upload", offset, MAX(0, offset + thisChunkSize - 1)];
 1771|      0|
 1772|      0|  return thisChunkSize;
 1773|      0|}
 1774|       |
 1775|       |// Public properties.
 1776|       |@synthesize currentOffset = _currentOffset,
 1777|       |            allowsCellularAccess = _allowsCellularAccess,
 1778|       |            delegateCompletionHandler = _delegateCompletionHandler,
 1779|       |            chunkFetcher = _chunkFetcher,
 1780|       |            lastChunkRequest = _lastChunkRequest,
 1781|       |            subdataGenerating = _subdataGenerating,
 1782|       |            shouldInitiateOffsetQuery = _shouldInitiateOffsetQuery,
 1783|       |            uploadGranularity = _uploadGranularity;
 1784|       |
 1785|       |// Internal properties.
 1786|       |@dynamic fetcherInFlight;
 1787|       |@dynamic activeFetcher;
 1788|       |@dynamic statusCode;
 1789|       |@dynamic delegateCallbackQueue;
 1790|       |
 1791|      0|+ (void)removePointer:(void *)pointer fromPointerArray:(NSPointerArray *)pointerArray {
 1792|      0|  for (NSUInteger index = 0, count = pointerArray.count; index < count; ++index) {
 1793|      0|    void *pointerAtIndex = [pointerArray pointerAtIndex:index];
 1794|      0|    if (pointerAtIndex == pointer) {
 1795|      0|      [pointerArray removePointerAtIndex:index];
 1796|      0|      return;
 1797|      0|    }
 1798|      0|  }
 1799|      0|}
 1800|       |
 1801|      0|- (BOOL)useBackgroundSession {
 1802|      0|  @synchronized(self) {
 1803|      0|    GTMSessionMonitorSynchronized(self);
 1804|      0|
 1805|      0|    return _useBackgroundSessionOnChunkFetchers;
 1806|      0|  }  // @synchronized(self
 1807|      0|}
 1808|       |
 1809|      0|- (void)setUseBackgroundSession:(BOOL)useBackgroundSession {
 1810|      0|  @synchronized(self) {
 1811|      0|    GTMSessionMonitorSynchronized(self);
 1812|      0|
 1813|      0|    if (_useBackgroundSessionOnChunkFetchers != useBackgroundSession) {
 1814|      0|      _useBackgroundSessionOnChunkFetchers = useBackgroundSession;
 1815|      0|      NSPointerArray *uploadFetcherPointerArrayForBackgroundSessions =
 1816|      0|          [[self class] uploadFetcherPointerArrayForBackgroundSessions];
 1817|      0|      @synchronized(uploadFetcherPointerArrayForBackgroundSessions) {
 1818|      0|        if (_useBackgroundSessionOnChunkFetchers) {
 1819|      0|          [uploadFetcherPointerArrayForBackgroundSessions addPointer:(__bridge void *)self];
 1820|      0|        } else {
 1821|      0|          [[self class] removePointer:(__bridge void *)self
 1822|      0|                     fromPointerArray:uploadFetcherPointerArrayForBackgroundSessions];
 1823|      0|        }
 1824|      0|      }  // @synchronized(uploadFetcherPointerArrayForBackgroundSessions)
 1825|      0|    }
 1826|      0|  }  // @synchronized(self)
 1827|      0|}
 1828|       |
 1829|      0|- (BOOL)canFetchWithBackgroundSession {
 1830|      0|  // The initial upload fetcher is always a foreground session; the
 1831|      0|  // useBackgroundSession property will apply only to chunk fetchers,
 1832|      0|  // not to queries.
 1833|      0|  return NO;
 1834|      0|}
 1835|       |
 1836|      0|- (NSDictionary *)responseHeaders {
 1837|      0|  GTMSessionCheckNotSynchronized(self);
 1838|      0|  // Overrides the superclass
 1839|      0|
 1840|      0|  // If asked for the fetcher's response, use the most recent chunk fetcher's response,
 1841|      0|  // since the original request's response lacks useful information like the actual
 1842|      0|  // Content-Type.
 1843|      0|  NSDictionary *dict = self.chunkFetcher.responseHeaders;
 1844|      0|  if (dict) {
 1845|      0|    return dict;
 1846|      0|  }
 1847|      0|
 1848|      0|  @synchronized(self) {
 1849|      0|    GTMSessionMonitorSynchronized(self);
 1850|      0|
 1851|      0|    if (_recentChunkReponseHeaders) {
 1852|      0|      return _recentChunkReponseHeaders;
 1853|      0|    }
 1854|      0|  }  // @synchronized(self
 1855|      0|
 1856|      0|  // No chunk fetcher yet completed, so return whatever we have from the initial fetch.
 1857|      0|  return [super responseHeaders];
 1858|      0|}
 1859|       |
 1860|      0|- (NSInteger)statusCodeUnsynchronized {
 1861|      0|  GTMSessionCheckSynchronized(self);
 1862|      0|
 1863|      0|  if (_recentChunkStatusCode != -1) {
 1864|      0|    // Overrides the superclass to indicate status appropriate to the initial
 1865|      0|    // or latest chunk fetch
 1866|      0|    return _recentChunkStatusCode;
 1867|      0|  } else {
 1868|      0|    return [super statusCodeUnsynchronized];
 1869|      0|  }
 1870|      0|}
 1871|       |
 1872|       |
 1873|      0|- (void)setStatusCode:(NSInteger)val {
 1874|      0|  @synchronized(self) {
 1875|      0|    GTMSessionMonitorSynchronized(self);
 1876|      0|
 1877|      0|    _recentChunkStatusCode = val;
 1878|      0|  }
 1879|      0|}
 1880|       |
 1881|      0|- (int64_t)initialBodyLength {
 1882|      0|  @synchronized(self) {
 1883|      0|    GTMSessionMonitorSynchronized(self);
 1884|      0|
 1885|      0|    return _initialBodyLength;
 1886|      0|  }
 1887|      0|}
 1888|       |
 1889|      0|- (void)setInitialBodyLength:(int64_t)length {
 1890|      0|  @synchronized(self) {
 1891|      0|    GTMSessionMonitorSynchronized(self);
 1892|      0|
 1893|      0|    _initialBodyLength = length;
 1894|      0|  }
 1895|      0|}
 1896|       |
 1897|      0|- (int64_t)initialBodySent {
 1898|      0|  @synchronized(self) {
 1899|      0|    GTMSessionMonitorSynchronized(self);
 1900|      0|
 1901|      0|    return _initialBodySent;
 1902|      0|  }
 1903|      0|}
 1904|       |
 1905|      0|- (void)setInitialBodySent:(int64_t)length {
 1906|      0|  @synchronized(self) {
 1907|      0|    GTMSessionMonitorSynchronized(self);
 1908|      0|
 1909|      0|    _initialBodySent = length;
 1910|      0|  }
 1911|      0|}
 1912|       |
 1913|      0|- (NSURL *)uploadLocationURL {
 1914|      0|  @synchronized(self) {
 1915|      0|    GTMSessionMonitorSynchronized(self);
 1916|      0|
 1917|      0|    return _uploadLocationURL;
 1918|      0|  }
 1919|      0|}
 1920|       |
 1921|      0|- (void)setUploadLocationURL:(NSURL *)locationURL {
 1922|      0|  @synchronized(self) {
 1923|      0|    GTMSessionMonitorSynchronized(self);
 1924|      0|
 1925|      0|    _uploadLocationURL = locationURL;
 1926|      0|  }
 1927|      0|}
 1928|       |
 1929|      0|- (GTMSessionFetcher *)activeFetcher {
 1930|      0|  GTMSessionFetcher *result = self.fetcherInFlight;
 1931|      0|  if (result) return result;
 1932|      0|
 1933|      0|  return self;
 1934|      0|}
 1935|       |
 1936|      0|- (BOOL)isFetching {
 1937|      0|  // If there is an active chunk fetcher, then the upload fetcher is considered
 1938|      0|  // to still be fetching.
 1939|      0|  if (self.fetcherInFlight != nil) return YES;
 1940|      0|
 1941|      0|  return [super isFetching];
 1942|      0|}
 1943|       |
 1944|      0|- (BOOL)waitForCompletionWithTimeout:(NSTimeInterval)timeoutInSeconds {
 1945|      0|  NSDate *timeoutDate = [NSDate dateWithTimeIntervalSinceNow:timeoutInSeconds];
 1946|      0|
 1947|      0|  while (self.fetcherInFlight || self.subdataGenerating) {
 1948|      0|    if ([timeoutDate timeIntervalSinceNow] < 0) return NO;
 1949|      0|
 1950|      0|    if (self.subdataGenerating) {
 1951|      0|      // Allow time for subdata generation.
 1952|      0|      NSDate *stopDate = [NSDate dateWithTimeIntervalSinceNow:0.001];
 1953|      0|      [[NSRunLoop currentRunLoop] runUntilDate:stopDate];
 1954|      0|    } else {
 1955|      0|      // Wait for any chunk or query fetchers that still have pending callbacks or
 1956|      0|      // notifications.
 1957|      0|      BOOL timedOut;
 1958|      0|
 1959|      0|      if (self.fetcherInFlight == self) {
 1960|      0|        timedOut = ![super waitForCompletionWithTimeout:timeoutInSeconds];
 1961|      0|      } else {
 1962|      0|        timedOut = ![self.fetcherInFlight waitForCompletionWithTimeout:timeoutInSeconds];
 1963|      0|      }
 1964|      0|      if (timedOut) return NO;
 1965|      0|    }
 1966|      0|  }
 1967|      0|  return YES;
 1968|      0|}
 1969|       |
 1970|       |@end
 1971|       |
 1972|       |@implementation GTMSessionFetcher (GTMSessionUploadFetcherMethods)
 1973|       |
 1974|      0|- (GTMSessionUploadFetcher *)parentUploadFetcher {
 1975|      0|  NSValue *property = [self propertyForKey:kGTMSessionUploadFetcherChunkParentKey];
 1976|      0|  if (!property) return nil;
 1977|      0|
 1978|      0|  GTMSessionUploadFetcher *uploadFetcher = property.nonretainedObjectValue;
 1979|      0|
 1980|      0|  GTMSESSION_ASSERT_DEBUG([uploadFetcher isKindOfClass:[GTMSessionUploadFetcher class]],
 1981|      0|                          @"Unexpected parent upload fetcher class: %@", [uploadFetcher class]);
 1982|      0|  return uploadFetcher;
 1983|      0|}
 1984|       |
 1985|       |@end

