/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/ShelfView/ShelfView/Classes/PlainShelfView.swift:
    1|       |//
    2|       |//  PlainShelfView.swift
    3|       |//  ShelfView
    4|       |//
    5|       |//  Created by Adeyinka Adediji on 11/09/2017.
    6|       |//  Copyright © 2017 Adeyinka Adediji. All rights reserved.
    7|       |//
    8|       |
    9|       |import Kingfisher
   10|       |import UIKit
   11|       |
   12|       |public class PlainShelfView: UIView {
   13|       |    private let indicatorWidth = Double(50)
   14|       |    private let bookCoverMargin = Double(10)
   15|       |    private let spineWidth = CGFloat(8)
   16|       |    private let bookBackgroundMarignTop = Double(23)
   17|       |    
   18|       |    public static let BOOK_SOURCE_DEVICE_DOCUMENTS = 1
   19|       |    public static let BOOK_SOURCE_DEVICE_LIBRARY = 2
   20|       |    public static let BOOK_SOURCE_DEVICE_CACHE = 3
   21|       |    public static let BOOK_SOURCE_URL = 4
   22|       |    public static let BOOK_SOURCE_RAW = 5
   23|       |    
   24|       |    private static let START = "start"
   25|       |    private static let END = "end"
   26|       |    private static let CENTER = "center"
   27|       |    
   28|       |    private var bookModel = [BookModel]()
   29|       |    private var shelfModel = [ShelfModel]()
   30|       |    
   31|       |    private var bookSource = BOOK_SOURCE_URL
   32|       |    
   33|       |    private var numberOfTilesPerRow: Int!
   34|       |    private var shelfHeight: Int!
   35|       |    private var shelfWidth: Int!
   36|       |    private let gridItemWidth = Dimens.gridItemWidth
   37|       |    private let gridItemHeight = Dimens.gridItemHeight
   38|       |    private var shelfView: UICollectionView!
   39|       |    private var trueGridItemWidth: Double!
   40|       |    private let layout = UICollectionViewFlowLayout()
   41|       |    private let utils = Utils()
   42|       |    public weak var delegate: PlainShelfViewDelegate!
   43|       |    private var viewHasBeenInitialized = false
   44|       |    
   45|      0|    public required init?(coder aDecoder: NSCoder) {
   46|      0|        fatalError("init(coder:) has not been implemented")
   47|      0|    }
   48|       |    
   49|      0|    public override init(frame: CGRect) {
   50|      0|        super.init(frame: frame)
   51|      0|        if Int(frame.width) < gridItemWidth {
   52|      0|            fatalError("ShelfView width cannot be less than \(gridItemWidth)")
   53|      0|        }
   54|      0|        initializeShelfView(width: frame.width, height: frame.height)
   55|      0|    }
   56|       |    
   57|      0|    public convenience init(frame: CGRect, bookModel: [BookModel], bookSource: Int) {
   58|      0|        self.init(frame: frame)
   59|      0|        utils.delay(0) {
   60|      0|            self.bookSource = bookSource
   61|      0|            self.bookModel = bookModel
   62|      0|            self.processData()
   63|      0|        }
   64|      0|    }
   65|       |    
   66|      0|    public override func layoutSubviews() {
   67|      0|        super.layoutSubviews()
   68|      0|        if viewHasBeenInitialized {
   69|      0|            let width = frame.width
   70|      0|            let height = frame.height
   71|      0|            shelfView.frame = CGRect(x: 0, y: 0, width: width, height: height)
   72|      0|            shelfWidth = Int(shelfView.frame.width)
   73|      0|            shelfHeight = Int(shelfView.frame.height)
   74|      0|            numberOfTilesPerRow = shelfWidth / gridItemWidth
   75|      0|            trueGridItemWidth = Double(shelfWidth) / Double(numberOfTilesPerRow)
   76|      0|            layout.itemSize = CGSize(width: trueGridItemWidth, height: Double(gridItemHeight))
   77|      0|            shelfView.collectionViewLayout.invalidateLayout()
   78|      0|            reloadBooks(bookModel: bookModel)
   79|      0|        }
   80|      0|    }
   81|       |    
   82|      0|    private func initializeShelfView(width: CGFloat, height: CGFloat) {
   83|      0|        shelfView = UICollectionView(frame: CGRect(x: 0, y: 0, width: width, height: height), collectionViewLayout: layout)
   84|      0|        shelfView.register(ShelfCellView.self, forCellWithReuseIdentifier: ShelfCellView.identifier)
   85|      0|        shelfView.dataSource = self
   86|      0|        shelfView.delegate = self
   87|      0|        shelfView.alwaysBounceVertical = false
   88|      0|        shelfView.bounces = false
   89|      0|        shelfView.showsVerticalScrollIndicator = false
   90|      0|        shelfView.showsHorizontalScrollIndicator = false
   91|      0|        shelfView.backgroundColor = UIColor("#C49E7A")
   92|      0|        addSubview(shelfView)
   93|      0|        
   94|      0|        layout.minimumLineSpacing = 0
   95|      0|        layout.minimumInteritemSpacing = 0
   96|      0|        layout.sectionInset = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0)
   97|      0|        
   98|      0|        shelfWidth = Int(shelfView.frame.width)
   99|      0|        shelfHeight = Int(shelfView.frame.height)
  100|      0|        numberOfTilesPerRow = shelfWidth / gridItemWidth
  101|      0|        trueGridItemWidth = Double(shelfWidth) / Double(numberOfTilesPerRow)
  102|      0|        
  103|      0|        layout.itemSize = CGSize(width: trueGridItemWidth, height: Double(gridItemHeight))
  104|      0|        shelfView.collectionViewLayout.invalidateLayout()
  105|      0|        
  106|      0|        buildShelf(sizeOfModel: 0)
  107|      0|        viewHasBeenInitialized = true
  108|      0|    }
  109|       |    
  110|      0|    private func loadEmptyShelfBlocks(type: String) {
  111|      0|        shelfModel.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: type))
  112|      0|    }
  113|       |    
  114|      0|    private func loadFilledShelfBlocks(bookCoverSource: String, bookId: String, bookTitle: String, type: String) {
  115|      0|        shelfModel.append(ShelfModel(bookCoverSource: bookCoverSource, bookId: bookId, bookTitle: bookTitle, show: true, type: type))
  116|      0|    }
  117|       |    
  118|      0|    public func reloadBooks(bookModel: [BookModel]) {
  119|      0|        self.bookModel = bookModel
  120|      0|        processData()
  121|      0|    }
  122|       |    
  123|      0|    public func addBooks(bookModel: [BookModel]) {
  124|      0|        self.bookModel = self.bookModel + bookModel
  125|      0|        processData()
  126|      0|    }
  127|       |    
  128|      0|    private func processData() {
  129|      0|        shelfModel.removeAll()
  130|      0|        
  131|      0|        for i in 0 ..< bookModel.count {
  132|      0|            let bookCoverSource = bookModel[i].bookCoverSource
  133|      0|            let bookId = bookModel[i].bookId
  134|      0|            let bookTitle = bookModel[i].bookTitle
  135|      0|            
  136|      0|            if (i % numberOfTilesPerRow) == 0 {
  137|      0|                loadFilledShelfBlocks(bookCoverSource: bookCoverSource, bookId: bookId, bookTitle: bookTitle, type: PlainShelfView.START)
  138|      0|            } else if (i % numberOfTilesPerRow) == (numberOfTilesPerRow - 1) {
  139|      0|                loadFilledShelfBlocks(bookCoverSource: bookCoverSource, bookId: bookId, bookTitle: bookTitle, type: PlainShelfView.END)
  140|      0|            } else {
  141|      0|                loadFilledShelfBlocks(bookCoverSource: bookCoverSource, bookId: bookId, bookTitle: bookTitle, type: PlainShelfView.CENTER)
  142|      0|            }
  143|      0|        }
  144|      0|        
  145|      0|        buildShelf(sizeOfModel: bookModel.count)
  146|      0|    }
  147|       |    
  148|      0|    private func buildShelf(sizeOfModel: Int) {
  149|      0|        var numberOfRows = sizeOfModel / numberOfTilesPerRow
  150|      0|        let remainderTiles = sizeOfModel % numberOfTilesPerRow
  151|      0|        
  152|      0|        if remainderTiles > 0 {
  153|      0|            numberOfRows = numberOfRows + 1
  154|      0|            let fillUp = numberOfTilesPerRow - remainderTiles
  155|      0|            for i in 0 ..< fillUp {
  156|      0|                if i == (fillUp - 1) {
  157|      0|                    loadEmptyShelfBlocks(type: PlainShelfView.END)
  158|      0|                } else {
  159|      0|                    loadEmptyShelfBlocks(type: PlainShelfView.CENTER)
  160|      0|                }
  161|      0|            }
  162|      0|        }
  163|      0|        
  164|      0|        if (numberOfRows * gridItemHeight) < shelfHeight {
  165|      0|            let remainderRowHeight = (shelfHeight - (numberOfRows * gridItemHeight)) / gridItemHeight
  166|      0|            
  167|      0|            if remainderRowHeight == 0 {
  168|      0|                for i in 0 ..< numberOfTilesPerRow {
  169|      0|                    if i == 0 {
  170|      0|                        loadEmptyShelfBlocks(type: PlainShelfView.START)
  171|      0|                    } else if i == (numberOfTilesPerRow - 1) {
  172|      0|                        loadEmptyShelfBlocks(type: PlainShelfView.END)
  173|      0|                    } else {
  174|      0|                        loadEmptyShelfBlocks(type: PlainShelfView.CENTER)
  175|      0|                    }
  176|      0|                }
  177|      0|            } else if remainderRowHeight > 0 {
  178|      0|                let fillUp = numberOfTilesPerRow * (remainderRowHeight + 1)
  179|      0|                for i in 0 ..< fillUp {
  180|      0|                    if (i % numberOfTilesPerRow) == 0 {
  181|      0|                        loadEmptyShelfBlocks(type: PlainShelfView.START)
  182|      0|                    } else if (i % numberOfTilesPerRow) == (numberOfTilesPerRow - 1) {
  183|      0|                        loadEmptyShelfBlocks(type: PlainShelfView.END)
  184|      0|                    } else {
  185|      0|                        loadEmptyShelfBlocks(type: PlainShelfView.CENTER)
  186|      0|                    }
  187|      0|                }
  188|      0|            }
  189|      0|        }
  190|      0|        
  191|      0|        shelfView.reloadData()
  192|      0|    }
  193|       |}
  194|       |
  195|       |extension PlainShelfView: UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
  196|      0|    public func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
  197|      0|        let position = indexPath.row
  198|      0|        let shelfItem = shelfModel[position]
  199|      0|        let bookCover = shelfItem.bookCoverSource.trim()
  200|      0|        
  201|      0|        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ShelfCellView.identifier, for: indexPath) as! ShelfCellView
  202|      0|        cell.shelfBackground.frame = CGRect(x: 0, y: 0, width: trueGridItemWidth, height: Double(gridItemHeight))
  203|      0|        cell.shelfBackground.contentMode = .scaleToFill
  204|      0|        
  205|      0|        switch shelfItem.type {
  206|      0|        case PlainShelfView.START:
  207|      0|            cell.shelfBackground.image = utils.loadImage(name: "left")
  208|      0|            break
  209|      0|        case PlainShelfView.END:
  210|      0|            cell.shelfBackground.image = utils.loadImage(name: "right")
  211|      0|            break
  212|      0|        default:
  213|      0|            cell.shelfBackground.image = utils.loadImage(name: "center")
  214|      0|            break
  215|      0|        }
  216|      0|        
  217|      0|        cell.bookCover.kf.indicatorType = .none
  218|      0|        cell.bookBackground.frame = CGRect(x: (trueGridItemWidth - Dimens.bookWidth) / 2, y: bookBackgroundMarignTop, width: Dimens.bookWidth, height: Dimens.bookHeight)
  219|      0|        cell.bookCover.frame = CGRect(x: bookCoverMargin / 2, y: bookCoverMargin, width: Dimens.bookWidth - bookCoverMargin, height: Dimens.bookHeight - bookCoverMargin)
  220|      0|        cell.indicator.frame = CGRect(x: (Dimens.bookWidth - indicatorWidth) / 2, y: (Dimens.bookHeight - indicatorWidth) / 2, width: indicatorWidth, height: indicatorWidth)
  221|      0|        cell.indicator.startAnimating()
  222|      0|        
  223|      0|        switch bookSource {
  224|      0|        case PlainShelfView.BOOK_SOURCE_DEVICE_CACHE:
  225|      0|            if shelfItem.show && bookCover != "" {
  226|      0|                let paths = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true)
  227|      0|                if let dirPath = paths.first {
  228|      0|                    let imageURL = URL(fileURLWithPath: dirPath).appendingPathComponent(bookCover)
  229|      0|                    let image = UIImage(contentsOfFile: imageURL.path)
  230|      0|                    cell.bookCover.image = image
  231|      0|                    cell.indicator.stopAnimating()
  232|      0|                    cell.spine.isHidden = false
  233|      0|                }
  234|      0|            }
  235|      0|            break
  236|      0|        case PlainShelfView.BOOK_SOURCE_DEVICE_LIBRARY:
  237|      0|            if shelfItem.show && bookCover != "" {
  238|      0|                let paths = NSSearchPathForDirectoriesInDomains(.libraryDirectory, .userDomainMask, true)
  239|      0|                if let dirPath = paths.first {
  240|      0|                    let imageURL = URL(fileURLWithPath: dirPath).appendingPathComponent(bookCover)
  241|      0|                    let image = UIImage(contentsOfFile: imageURL.path)
  242|      0|                    cell.bookCover.image = image
  243|      0|                    cell.indicator.stopAnimating()
  244|      0|                    cell.spine.isHidden = false
  245|      0|                }
  246|      0|            }
  247|      0|            break
  248|      0|        case PlainShelfView.BOOK_SOURCE_DEVICE_DOCUMENTS:
  249|      0|            if shelfItem.show && bookCover != "" {
  250|      0|                let paths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)
  251|      0|                if let dirPath = paths.first {
  252|      0|                    let imageURL = URL(fileURLWithPath: dirPath).appendingPathComponent(bookCover)
  253|      0|                    let image = UIImage(contentsOfFile: imageURL.path)
  254|      0|                    cell.bookCover.image = image
  255|      0|                    cell.indicator.stopAnimating()
  256|      0|                    cell.spine.isHidden = false
  257|      0|                }
  258|      0|            }
  259|      0|            break
  260|      0|        case PlainShelfView.BOOK_SOURCE_URL:
  261|      0|            if shelfItem.show && bookCover != "" {
  262|      0|                let url = URL(string: bookCover)!
  263|      0|                cell.bookCover.kf.setImage(with: url) { result in
  264|      0|                    switch result {
  265|      0|                    case .success:
  266|      0|                        cell.indicator.stopAnimating()
  267|      0|                        cell.spine.isHidden = false
  268|      0|                    case .failure(let error):
  269|      0|                        print("Error: \(error)")
  270|      0|                    }
  271|      0|                }
  272|      0|            }
  273|      0|            break
  274|      0|        case PlainShelfView.BOOK_SOURCE_RAW:
  275|      0|            if shelfItem.show && bookCover != "" {
  276|      0|                cell.bookCover.image = UIImage(named: bookCover)
  277|      0|                cell.indicator.stopAnimating()
  278|      0|                cell.spine.isHidden = false
  279|      0|            }
  280|      0|            break
  281|      0|        default:
  282|      0|            if shelfItem.show && bookCover != "" {
  283|      0|                let url = URL(string: "https://www.packtpub.com/sites/default/files/cover_1.png")!
  284|      0|                cell.bookCover.kf.setImage(with: url) { result in
  285|      0|                    switch result {
  286|      0|                    case .success:
  287|      0|                        cell.indicator.stopAnimating()
  288|      0|                        cell.spine.isHidden = false
  289|      0|                    case .failure(let error):
  290|      0|                        print("Error: \(error)")
  291|      0|                    }
  292|      0|                }
  293|      0|            }
  294|      0|            break
  295|      0|        }
  296|      0|        
  297|      0|        cell.bookBackground.isHidden = !shelfItem.show
  298|      0|        cell.spine.frame = CGRect(x: CGFloat(bookCoverMargin) / 2, y: CGFloat(bookCoverMargin), width: spineWidth, height: cell.bookCover.frame.height)
  299|      0|        
  300|      0|        return cell
  301|      0|    }
  302|       |    
  303|      0|    public func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
  304|      0|        return shelfModel.count
  305|      0|    }
  306|       |    
  307|      0|    public func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
  308|      0|        let position = indexPath.row
  309|      0|        if shelfModel[position].show {
  310|      0|            delegate.onBookClicked(self, index: position, bookId: shelfModel[position].bookId, bookTitle: shelfModel[position].bookTitle)
  311|      0|        }
  312|      0|    }
  313|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/ShelfView/ShelfView/Classes/SectionShelfView.swift:
    1|       |//
    2|       |//  SectionShelfView.swift
    3|       |//  ShelfView
    4|       |//
    5|       |//  Created by Adeyinka Adediji on 27/12/2018.
    6|       |//
    7|       |
    8|       |import Kingfisher
    9|       |import UIKit
   10|       |
   11|       |public class SectionShelfView: UIView {
   12|       |    private let indicatorWidth = Double(50)
   13|       |    private let bookCoverMargin = Double(10)
   14|       |    private let spineWidth = CGFloat(8)
   15|       |    private let bookBackgroundMarignTop = Double(23)
   16|       |    private let headerReferenceSizeHeight = CGFloat(50)
   17|       |    
   18|       |    public static let BOOK_SOURCE_DEVICE_DOCUMENTS = 1
   19|       |    public static let BOOK_SOURCE_DEVICE_LIBRARY = 2
   20|       |    public static let BOOK_SOURCE_DEVICE_CACHE = 3
   21|       |    public static let BOOK_SOURCE_URL = 4
   22|       |    public static let BOOK_SOURCE_RAW = 5
   23|       |    
   24|       |    private static let START = "start"
   25|       |    private static let END = "end"
   26|       |    private static let CENTER = "center"
   27|       |    
   28|       |    private var bookModelSection = [BookModelSection]()
   29|       |    private var shelfModelSection = [ShelfModelSection]()
   30|       |    
   31|       |    private var bookSource = BOOK_SOURCE_URL
   32|       |    
   33|       |    private var numberOfTilesPerRow: Int!
   34|       |    private var shelfHeight: Int!
   35|       |    private var shelfWidth: Int!
   36|       |    private let gridItemWidth = Dimens.gridItemWidth
   37|       |    private let gridItemHeight = Dimens.gridItemHeight
   38|       |    private var shelfView: UICollectionView!
   39|       |    private var trueGridItemWidth: Double!
   40|       |    private let layout = UICollectionViewFlowLayout()
   41|       |    private let utils = Utils()
   42|       |    public weak var delegate: SectionShelfViewDelegate!
   43|       |    private var viewHasBeenInitialized = false
   44|       |    
   45|      0|    public required init?(coder aDecoder: NSCoder) {
   46|      0|        fatalError("init(coder:) has not been implemented")
   47|      0|    }
   48|       |    
   49|      0|    public override init(frame: CGRect) {
   50|      0|        super.init(frame: frame)
   51|      0|        if Int(frame.width) < gridItemWidth {
   52|      0|            fatalError("ShelfView width cannot be less than \(gridItemWidth)")
   53|      0|        }
   54|      0|        initializeShelfView(width: frame.width, height: frame.height)
   55|      0|    }
   56|       |    
   57|      0|    public convenience init(frame: CGRect, bookModelSection: [BookModelSection], bookSource: Int) {
   58|      0|        self.init(frame: frame)
   59|      0|        utils.delay(0) {
   60|      0|            self.bookSource = bookSource
   61|      0|            self.bookModelSection = bookModelSection
   62|      0|            self.processData()
   63|      0|        }
   64|      0|    }
   65|       |    
   66|      0|    public override func layoutSubviews() {
   67|      0|        super.layoutSubviews()
   68|      0|        if viewHasBeenInitialized {
   69|      0|            let width = frame.width
   70|      0|            let height = frame.height
   71|      0|            shelfView.frame = CGRect(x: 0, y: 0, width: width, height: height)
   72|      0|            shelfWidth = Int(shelfView.frame.width)
   73|      0|            shelfHeight = Int(shelfView.frame.height)
   74|      0|            numberOfTilesPerRow = shelfWidth / gridItemWidth
   75|      0|            trueGridItemWidth = Double(shelfWidth) / Double(numberOfTilesPerRow)
   76|      0|            layout.itemSize = CGSize(width: trueGridItemWidth, height: Double(gridItemHeight))
   77|      0|            layout.headerReferenceSize = CGSize(width: shelfView.frame.width, height: headerReferenceSizeHeight)
   78|      0|            shelfView.collectionViewLayout.invalidateLayout()
   79|      0|            reloadBooks(bookModelSection: bookModelSection)
   80|      0|        }
   81|      0|    }
   82|       |    
   83|      0|    private func initializeShelfView(width: CGFloat, height: CGFloat) {
   84|      0|        shelfView = UICollectionView(frame: CGRect(x: 0, y: 0, width: width, height: height), collectionViewLayout: layout)
   85|      0|        shelfView.register(ShelfCellView.self, forCellWithReuseIdentifier: ShelfCellView.identifier)
   86|      0|        shelfView.register(ShelfHeaderCellView.self, forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader, withReuseIdentifier: ShelfHeaderCellView.identifier)
   87|      0|        shelfView.dataSource = self
   88|      0|        shelfView.delegate = self
   89|      0|        shelfView.alwaysBounceVertical = false
   90|      0|        shelfView.bounces = false
   91|      0|        shelfView.showsVerticalScrollIndicator = false
   92|      0|        shelfView.showsHorizontalScrollIndicator = false
   93|      0|        shelfView.backgroundColor = UIColor("#C49E7A")
   94|      0|        addSubview(shelfView)
   95|      0|        
   96|      0|        layout.minimumLineSpacing = 0
   97|      0|        layout.minimumInteritemSpacing = 0
   98|      0|        layout.sectionInset = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0)
   99|      0|        
  100|      0|        shelfWidth = Int(shelfView.frame.width)
  101|      0|        shelfHeight = Int(shelfView.frame.height)
  102|      0|        numberOfTilesPerRow = shelfWidth / gridItemWidth
  103|      0|        trueGridItemWidth = Double(shelfWidth) / Double(numberOfTilesPerRow)
  104|      0|        
  105|      0|        layout.itemSize = CGSize(width: trueGridItemWidth, height: Double(gridItemHeight))
  106|      0|        layout.headerReferenceSize = CGSize(width: shelfView.frame.width, height: headerReferenceSizeHeight)
  107|      0|        shelfView.collectionViewLayout.invalidateLayout()
  108|      0|        
  109|      0|        buildSingleSectionShelf(sizeOfModel: 0)
  110|      0|        viewHasBeenInitialized = true
  111|      0|    }
  112|       |    
  113|      0|    public func reloadBooks(bookModelSection: [BookModelSection]) {
  114|      0|        self.bookModelSection = bookModelSection
  115|      0|        processData()
  116|      0|    }
  117|       |    
  118|      0|    public func addBooks(bookModelSection: [BookModelSection]) {
  119|      0|        self.bookModelSection = self.bookModelSection + bookModelSection
  120|      0|        processData()
  121|      0|    }
  122|       |    
  123|      0|    private func processData() {
  124|      0|        shelfModelSection.removeAll()
  125|      0|        var cummulativeShelfHeight = 0
  126|      0|        
  127|      0|        for i in 0 ..< bookModelSection.count {
  128|      0|            let sectionItem = bookModelSection[i]
  129|      0|            let sectionName = sectionItem.sectionName
  130|      0|            let sectionId = sectionItem.sectionId
  131|      0|            let sectionBooks = sectionItem.sectionBooks
  132|      0|            let sectionBooksCount = sectionBooks.count
  133|      0|            var shelfModelArray = [ShelfModel]()
  134|      0|            
  135|      0|            for j in 0 ..< sectionBooksCount {
  136|      0|                let bookCoverSource = sectionBooks[j].bookCoverSource
  137|      0|                let bookId = sectionBooks[j].bookId
  138|      0|                let bookTitle = sectionBooks[j].bookTitle
  139|      0|                
  140|      0|                if (j % numberOfTilesPerRow) == 0 {
  141|      0|                    shelfModelArray.append(ShelfModel(bookCoverSource: bookCoverSource, bookId: bookId, bookTitle: bookTitle, show: true, type: SectionShelfView.START))
  142|      0|                } else if (j % numberOfTilesPerRow) == (numberOfTilesPerRow - 1) {
  143|      0|                    shelfModelArray.append(ShelfModel(bookCoverSource: bookCoverSource, bookId: bookId, bookTitle: bookTitle, show: true, type: SectionShelfView.END))
  144|      0|                } else {
  145|      0|                    shelfModelArray.append(ShelfModel(bookCoverSource: bookCoverSource, bookId: bookId, bookTitle: bookTitle, show: true, type: SectionShelfView.CENTER))
  146|      0|                }
  147|      0|                
  148|      0|                if j == (sectionBooksCount - 1) {
  149|      0|                    var numberOfRows = sectionBooksCount / numberOfTilesPerRow
  150|      0|                    let remainderTiles = sectionBooksCount % numberOfTilesPerRow
  151|      0|                    
  152|      0|                    if remainderTiles > 0 {
  153|      0|                        numberOfRows = numberOfRows + 1
  154|      0|                        let fillUp = numberOfTilesPerRow - remainderTiles
  155|      0|                        for i in 0 ..< fillUp {
  156|      0|                            if i == (fillUp - 1) {
  157|      0|                                shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.END))
  158|      0|                            } else {
  159|      0|                                shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.CENTER))
  160|      0|                            }
  161|      0|                        }
  162|      0|                    }
  163|      0|                    cummulativeShelfHeight += (numberOfRows * gridItemHeight) + Int(headerReferenceSizeHeight)
  164|      0|                }
  165|      0|            }
  166|      0|            
  167|      0|            if i == (bookModelSection.count - 1) {
  168|      0|                if cummulativeShelfHeight < shelfHeight {
  169|      0|                    let remainderRowHeight = (shelfHeight - cummulativeShelfHeight) / gridItemHeight
  170|      0|                    
  171|      0|                    if remainderRowHeight == 0 {
  172|      0|                        for i in 0 ..< numberOfTilesPerRow {
  173|      0|                            if i == 0 {
  174|      0|                                shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.START))
  175|      0|                            } else if i == (numberOfTilesPerRow - 1) {
  176|      0|                                shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.END))
  177|      0|                            } else {
  178|      0|                                shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.CENTER))
  179|      0|                            }
  180|      0|                        }
  181|      0|                    } else if remainderRowHeight > 0 {
  182|      0|                        let fillUp = numberOfTilesPerRow * (remainderRowHeight + 1)
  183|      0|                        for i in 0 ..< fillUp {
  184|      0|                            if (i % numberOfTilesPerRow) == 0 {
  185|      0|                                shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.START))
  186|      0|                            } else if (i % numberOfTilesPerRow) == (numberOfTilesPerRow - 1) {
  187|      0|                                shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.END))
  188|      0|                            } else {
  189|      0|                                shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.CENTER))
  190|      0|                            }
  191|      0|                        }
  192|      0|                    }
  193|      0|                }
  194|      0|            }
  195|      0|            
  196|      0|            shelfModelSection.append(ShelfModelSection(sectionName: sectionName, sectionId: sectionId, sectionShelf: shelfModelArray))
  197|      0|        }
  198|      0|        
  199|      0|        shelfView.reloadData()
  200|      0|    }
  201|       |    
  202|      0|    private func buildSingleSectionShelf(sizeOfModel: Int) {
  203|      0|        var numberOfRows = sizeOfModel / numberOfTilesPerRow
  204|      0|        let remainderTiles = sizeOfModel % numberOfTilesPerRow
  205|      0|        var shelfModelArray = [ShelfModel]()
  206|      0|        
  207|      0|        if remainderTiles > 0 {
  208|      0|            numberOfRows = numberOfRows + 1
  209|      0|            let fillUp = numberOfTilesPerRow - remainderTiles
  210|      0|            for i in 0 ..< fillUp {
  211|      0|                if i == (fillUp - 1) {
  212|      0|                    shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.END))
  213|      0|                } else {
  214|      0|                    shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.CENTER))
  215|      0|                }
  216|      0|            }
  217|      0|        }
  218|      0|        
  219|      0|        if ((numberOfRows * gridItemHeight) + Int(headerReferenceSizeHeight)) < shelfHeight {
  220|      0|            let remainderRowHeight = (shelfHeight - ((numberOfRows * gridItemHeight) + Int(headerReferenceSizeHeight))) / gridItemHeight
  221|      0|            
  222|      0|            if remainderRowHeight == 0 {
  223|      0|                for i in 0 ..< numberOfTilesPerRow {
  224|      0|                    if i == 0 {
  225|      0|                        shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.START))
  226|      0|                    } else if i == (numberOfTilesPerRow - 1) {
  227|      0|                        shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.END))
  228|      0|                    } else {
  229|      0|                        shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.CENTER))
  230|      0|                    }
  231|      0|                }
  232|      0|            } else if remainderRowHeight > 0 {
  233|      0|                let fillUp = numberOfTilesPerRow * (remainderRowHeight + 1)
  234|      0|                for i in 0 ..< fillUp {
  235|      0|                    if (i % numberOfTilesPerRow) == 0 {
  236|      0|                        shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.START))
  237|      0|                    } else if (i % numberOfTilesPerRow) == (numberOfTilesPerRow - 1) {
  238|      0|                        shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.END))
  239|      0|                    } else {
  240|      0|                        shelfModelArray.append(ShelfModel(bookCoverSource: "", bookId: "", bookTitle: "", show: false, type: SectionShelfView.CENTER))
  241|      0|                    }
  242|      0|                }
  243|      0|            }
  244|      0|        }
  245|      0|        
  246|      0|        shelfModelSection.append(ShelfModelSection(sectionName: "", sectionId: "", sectionShelf: shelfModelArray))
  247|      0|        shelfView.reloadData()
  248|      0|    }
  249|       |}
  250|       |
  251|       |extension SectionShelfView: UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
  252|      0|    public func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
  253|      0|        let section = indexPath.section
  254|      0|        let position = indexPath.row
  255|      0|        let shelfItem = shelfModelSection[section].sectionShelf[position]
  256|      0|        let bookCover = shelfItem.bookCoverSource.trim()
  257|      0|        
  258|      0|        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ShelfCellView.identifier, for: indexPath) as! ShelfCellView
  259|      0|        cell.shelfBackground.frame = CGRect(x: 0, y: 0, width: trueGridItemWidth, height: Double(gridItemHeight))
  260|      0|        cell.shelfBackground.contentMode = .scaleToFill
  261|      0|        
  262|      0|        switch shelfItem.type {
  263|      0|        case SectionShelfView.START:
  264|      0|            cell.shelfBackground.image = utils.loadImage(name: "left")
  265|      0|            break
  266|      0|        case SectionShelfView.END:
  267|      0|            cell.shelfBackground.image = utils.loadImage(name: "right")
  268|      0|            break
  269|      0|        default:
  270|      0|            cell.shelfBackground.image = utils.loadImage(name: "center")
  271|      0|            break
  272|      0|        }
  273|      0|        
  274|      0|        cell.bookCover.kf.indicatorType = .none
  275|      0|        cell.bookBackground.frame = CGRect(x: (trueGridItemWidth - Dimens.bookWidth) / 2, y: bookBackgroundMarignTop, width: Dimens.bookWidth, height: Dimens.bookHeight)
  276|      0|        cell.bookCover.frame = CGRect(x: bookCoverMargin / 2, y: bookCoverMargin, width: Dimens.bookWidth - bookCoverMargin, height: Dimens.bookHeight - bookCoverMargin)
  277|      0|        cell.indicator.frame = CGRect(x: (Dimens.bookWidth - indicatorWidth) / 2, y: (Dimens.bookHeight - indicatorWidth) / 2, width: indicatorWidth, height: indicatorWidth)
  278|      0|        cell.indicator.startAnimating()
  279|      0|        
  280|      0|        switch bookSource {
  281|      0|        case SectionShelfView.BOOK_SOURCE_DEVICE_CACHE:
  282|      0|            if shelfItem.show && bookCover != "" {
  283|      0|                let paths = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true)
  284|      0|                if let dirPath = paths.first {
  285|      0|                    let imageURL = URL(fileURLWithPath: dirPath).appendingPathComponent(bookCover)
  286|      0|                    let image = UIImage(contentsOfFile: imageURL.path)
  287|      0|                    cell.bookCover.image = image
  288|      0|                    cell.indicator.stopAnimating()
  289|      0|                    cell.spine.isHidden = false
  290|      0|                }
  291|      0|            }
  292|      0|            break
  293|      0|        case SectionShelfView.BOOK_SOURCE_DEVICE_LIBRARY:
  294|      0|            if shelfItem.show && bookCover != "" {
  295|      0|                let paths = NSSearchPathForDirectoriesInDomains(.libraryDirectory, .userDomainMask, true)
  296|      0|                if let dirPath = paths.first {
  297|      0|                    let imageURL = URL(fileURLWithPath: dirPath).appendingPathComponent(bookCover)
  298|      0|                    let image = UIImage(contentsOfFile: imageURL.path)
  299|      0|                    cell.bookCover.image = image
  300|      0|                    cell.indicator.stopAnimating()
  301|      0|                    cell.spine.isHidden = false
  302|      0|                }
  303|      0|            }
  304|      0|            break
  305|      0|        case SectionShelfView.BOOK_SOURCE_DEVICE_DOCUMENTS:
  306|      0|            if shelfItem.show && bookCover != "" {
  307|      0|                let paths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)
  308|      0|                if let dirPath = paths.first {
  309|      0|                    let imageURL = URL(fileURLWithPath: dirPath).appendingPathComponent(bookCover)
  310|      0|                    let image = UIImage(contentsOfFile: imageURL.path)
  311|      0|                    cell.bookCover.image = image
  312|      0|                    cell.indicator.stopAnimating()
  313|      0|                    cell.spine.isHidden = false
  314|      0|                }
  315|      0|            }
  316|      0|            break
  317|      0|        case SectionShelfView.BOOK_SOURCE_URL:
  318|      0|            if shelfItem.show && bookCover != "" {
  319|      0|                let url = URL(string: bookCover)!
  320|      0|                cell.bookCover.kf.setImage(with: url) { result in
  321|      0|                    switch result {
  322|      0|                    case .success:
  323|      0|                        cell.indicator.stopAnimating()
  324|      0|                        cell.spine.isHidden = false
  325|      0|                    case .failure(let error):
  326|      0|                        print("Error: \(error)")
  327|      0|                    }
  328|      0|                }
  329|      0|            }
  330|      0|            break
  331|      0|        case SectionShelfView.BOOK_SOURCE_RAW:
  332|      0|            if shelfItem.show && bookCover != "" {
  333|      0|                cell.bookCover.image = UIImage(named: bookCover)
  334|      0|                cell.indicator.stopAnimating()
  335|      0|                cell.spine.isHidden = false
  336|      0|            }
  337|      0|            break
  338|      0|        default:
  339|      0|            if shelfItem.show && bookCover != "" {
  340|      0|                let url = URL(string: "https://www.packtpub.com/sites/default/files/cover_1.png")!
  341|      0|                cell.bookCover.kf.setImage(with: url) { result in
  342|      0|                    switch result {
  343|      0|                    case .success:
  344|      0|                        cell.indicator.stopAnimating()
  345|      0|                        cell.spine.isHidden = false
  346|      0|                    case .failure(let error):
  347|      0|                        print("Error: \(error)")
  348|      0|                    }
  349|      0|                }
  350|      0|            }
  351|      0|            break
  352|      0|        }
  353|      0|        
  354|      0|        cell.bookBackground.isHidden = !shelfItem.show
  355|      0|        cell.spine.frame = CGRect(x: CGFloat(bookCoverMargin) / 2, y: CGFloat(bookCoverMargin), width: spineWidth, height: cell.bookCover.frame.height)
  356|      0|        
  357|      0|        return cell
  358|      0|    }
  359|       |    
  360|      0|    public func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {
  361|      0|        if kind == UICollectionView.elementKindSectionHeader {
  362|      0|            let reusableView = collectionView.dequeueReusableSupplementaryView(ofKind: UICollectionView.elementKindSectionHeader, withReuseIdentifier: ShelfHeaderCellView.identifier, for: indexPath) as! ShelfHeaderCellView
  363|      0|            
  364|      0|            reusableView.header.frame = CGRect(x: 0, y: 0, width: reusableView.frame.width, height: reusableView.frame.height)
  365|      0|            reusableView.headerLabel.frame = CGRect(x: 0, y: 0, width: reusableView.frame.width, height: reusableView.frame.height)
  366|      0|            reusableView.headerLabel.text = shelfModelSection[indexPath.section].sectionName
  367|      0|            return reusableView
  368|      0|        }
  369|      0|        return UICollectionReusableView()
  370|      0|    }
  371|       |    
  372|      0|    public func numberOfSections(in collectionView: UICollectionView) -> Int {
  373|      0|        return shelfModelSection.count
  374|      0|    }
  375|       |    
  376|      0|    public func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
  377|      0|        return shelfModelSection[section].sectionShelf.count
  378|      0|    }
  379|       |    
  380|      0|    public func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
  381|      0|        let section = indexPath.section
  382|      0|        let position = indexPath.row
  383|      0|        let sectionItem = shelfModelSection[section]
  384|      0|        let shelfItem = sectionItem.sectionShelf[position]
  385|      0|        if shelfItem.show {
  386|      0|            delegate.onBookClicked(self, section: section, index: position, sectionId: sectionItem.sectionId, sectionTitle: sectionItem.sectionName, bookId: shelfItem.bookId, bookTitle: shelfItem.bookTitle)
  387|      0|        }
  388|      0|    }
  389|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/ShelfView/ShelfView/Classes/ShelfCellView.swift:
    1|       |//
    2|       |//  ShelfCellView.swift
    3|       |//  ShelfView
    4|       |//
    5|       |//  Created by Adeyinka Adediji on 11/09/2017.
    6|       |//  Copyright © 2017 Adeyinka Adediji. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class ShelfCellView: UICollectionViewCell {
   12|       |    let shelfBackground = UIImageView()
   13|       |    let bookBackground = UIView()
   14|       |    var bookCover = UIImageView()
   15|       |    let indicator = UIActivityIndicatorView()
   16|       |    let spine = UIImageView()
   17|       |    
   18|      0|    override init(frame: CGRect) {
   19|      0|        super.init(frame: frame)
   20|      0|        
   21|      0|        addSubview(shelfBackground)
   22|      0|        addSubview(bookBackground)
   23|      0|        
   24|      0|        bookBackground.addSubview(bookCover)
   25|      0|        bookBackground.addSubview(spine)
   26|      0|        bookBackground.addSubview(indicator)
   27|      0|        
   28|      0|        bookCover.layer.shadowColor = UIColor.black.cgColor
   29|      0|        bookCover.layer.shadowRadius = 10
   30|      0|        bookCover.layer.shadowOffset = CGSize(width: 0, height: 0)
   31|      0|        bookCover.layer.shadowOpacity = 0.7
   32|      0|        
   33|      0|        indicator.color = .magenta
   34|      0|        spine.image = Utils().loadImage(name: "spine")
   35|      0|        spine.isHidden = true
   36|      0|        shelfBackground.isUserInteractionEnabled = true
   37|      0|        bookCover.isUserInteractionEnabled = true
   38|      0|    }
   39|       |    
   40|      0|    required init?(coder aDecoder: NSCoder) {
   41|      0|        fatalError("init(coder:) has not been implemented")
   42|      0|    }
   43|       |    
   44|      0|    static var identifier: String {
   45|      0|        return String(describing: self)
   46|      0|    }
   47|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/ShelfView/ShelfView/Classes/ShelfHeaderCellView.swift:
    1|       |//
    2|       |//  ShelfHeaderCellView.swift
    3|       |//  ShelfView
    4|       |//
    5|       |//  Created by Adeyinka Adediji on 28/12/2018.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |class ShelfHeaderCellView: UICollectionReusableView {
   11|       |    let header = UIImageView()
   12|       |    let headerLabel = UILabel()
   13|       |    
   14|      0|    override init(frame: CGRect) {
   15|      0|        super.init(frame: frame)
   16|      0|        header.image = Utils().loadImage(name: "header")?.resizableImage(withCapInsets: UIEdgeInsets(top: 0, left: 5, bottom: 0, right: 5))
   17|      0|        header.contentMode = .scaleToFill
   18|      0|        headerLabel.textAlignment = .center
   19|      0|        headerLabel.shadowColor = .brown
   20|      0|        headerLabel.shadowOffset = CGSize(width: 0.0, height: 1.0)
   21|      0|        addSubview(header)
   22|      0|        addSubview(headerLabel)
   23|      0|    }
   24|       |    
   25|      0|    required init?(coder aDecoder: NSCoder) {
   26|      0|        fatalError("init(coder:) has not been implemented")
   27|      0|    }
   28|       |    
   29|      0|    static var identifier: String {
   30|      0|        return String(describing: self)
   31|      0|    }
   32|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/ShelfView/ShelfView/Classes/ShelfViewModel.swift:
    1|       |//
    2|       |//  BookModel.swift
    3|       |//  ShelfView
    4|       |//
    5|       |//  Created by Adeyinka Adediji on 11/09/2017.
    6|       |//  Copyright © 2017 Adeyinka Adediji. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public struct BookModel {
   12|       |    var bookCoverSource: String
   13|       |    var bookId: String
   14|       |    var bookTitle: String
   15|       |
   16|      0|    public init(bookCoverSource: String, bookId: String, bookTitle: String) {
   17|      0|        self.bookCoverSource = bookCoverSource
   18|      0|        self.bookId = bookId
   19|      0|        self.bookTitle = bookTitle
   20|      0|        if bookCoverSource.isEmpty {
   21|      0|            fatalError("bookCoverSource must not be empty")
   22|      0|        }
   23|      0|        if bookId.isEmpty {
   24|      0|            fatalError("bookId must not be empty")
   25|      0|        }
   26|      0|        if bookTitle.isEmpty {
   27|      0|            fatalError("bookTitle must not be empty")
   28|      0|        }
   29|      0|    }
   30|       |}
   31|       |
   32|       |public struct BookModelSection {
   33|       |    var sectionName: String
   34|       |    var sectionId: String
   35|       |    var sectionBooks: [BookModel]
   36|       |
   37|      0|    public init(sectionName: String, sectionId: String, sectionBooks: [BookModel]) {
   38|      0|        self.sectionName = sectionName
   39|      0|        self.sectionId = sectionId
   40|      0|        self.sectionBooks = sectionBooks
   41|      0|    }
   42|       |}
   43|       |
   44|       |struct ShelfModel {
   45|       |    var bookCoverSource: String
   46|       |    var bookId: String
   47|       |    var bookTitle: String
   48|       |    var show: Bool
   49|       |    var type: String
   50|       |
   51|      0|    public init(bookCoverSource: String, bookId: String, bookTitle: String, show: Bool, type: String) {
   52|      0|        self.bookCoverSource = bookCoverSource
   53|      0|        self.bookId = bookId
   54|      0|        self.bookTitle = bookTitle
   55|      0|        self.show = show
   56|      0|        self.type = type
   57|      0|    }
   58|       |}
   59|       |
   60|       |struct ShelfModelSection {
   61|       |    var sectionName: String
   62|       |    var sectionId: String
   63|       |    var sectionShelf: [ShelfModel]
   64|       |
   65|      0|    public init(sectionName: String, sectionId: String, sectionShelf: [ShelfModel]) {
   66|      0|        self.sectionName = sectionName
   67|      0|        self.sectionId = sectionId
   68|      0|        self.sectionShelf = sectionShelf
   69|      0|    }
   70|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/ShelfView/ShelfView/Classes/Utils.swift:
    1|       |//
    2|       |//  Utils.swift
    3|       |//  ShelfView
    4|       |//
    5|       |//  Created by Adeyinka Adediji on 11/09/2017.
    6|       |//  Copyright © 2017 Adeyinka Adediji. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |extension String {
   12|      0|    func trim() -> String {
   13|      0|        return self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
   14|      0|    }
   15|       |}
   16|       |
   17|       |extension UIColor {
   18|      0|    convenience init(_ hex: String) {
   19|      0|        var cString = hex.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines).uppercased()
   20|      0|
   21|      0|        if cString.hasPrefix("#") {
   22|      0|            cString = String(cString.suffix(from: cString.index(cString.startIndex, offsetBy: 1)))
   23|      0|        }
   24|      0|
   25|      0|        var rgbValue: UInt32 = 0
   26|      0|        Scanner(string: cString).scanHexInt32(&rgbValue)
   27|      0|
   28|      0|        let components = (
   29|      0|            R: CGFloat((rgbValue & 0xFF0000) >> 16) / 255,
   30|      0|            G: CGFloat((rgbValue & 0x00FF00) >> 8) / 255,
   31|      0|            B: CGFloat(rgbValue & 0x0000FF) / 255
   32|      0|        )
   33|      0|        self.init(red: components.R, green: components.G, blue: components.B, alpha: 1)
   34|      0|    }
   35|       |}
   36|       |
   37|       |class Utils {
   38|      0|    func delay(_ delay: Double, closure: @escaping () -> ()) {
   39|      0|        DispatchQueue.main.asyncAfter(
   40|      0|            deadline: DispatchTime.now() + Double(Int64(delay * Double(NSEC_PER_SEC))) / Double(NSEC_PER_SEC),
   41|      0|            execute: closure
   42|      0|        )
   43|      0|    }
   44|       |
   45|      0|    func loadImage(name: String) -> UIImage? {
   46|      0|        let podBundle = Bundle(for: Utils.self)
   47|      0|        if let url = podBundle.url(forResource: "ShelfView", withExtension: "bundle") {
   48|      0|            let bundle = Bundle(url: url)
   49|      0|            return UIImage(named: name, in: bundle, compatibleWith: nil)
   50|      0|        }
   51|      0|        return nil
   52|      0|    }
   53|       |}

