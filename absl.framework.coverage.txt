/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/call_once.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// -----------------------------------------------------------------------------
   16|       |// File: call_once.h
   17|       |// -----------------------------------------------------------------------------
   18|       |//
   19|       |// This header file provides an Abseil version of `std::call_once` for invoking
   20|       |// a given function at most once, across all threads. This Abseil version is
   21|       |// faster than the C++11 version and incorporates the C++17 argument-passing
   22|       |// fix, so that (for example) non-const references may be passed to the invoked
   23|       |// function.
   24|       |
   25|       |#ifndef ABSL_BASE_CALL_ONCE_H_
   26|       |#define ABSL_BASE_CALL_ONCE_H_
   27|       |
   28|       |#include <algorithm>
   29|       |#include <atomic>
   30|       |#include <cstdint>
   31|       |#include <type_traits>
   32|       |#include <utility>
   33|       |
   34|       |#include "absl/base/internal/invoke.h"
   35|       |#include "absl/base/internal/low_level_scheduling.h"
   36|       |#include "absl/base/internal/raw_logging.h"
   37|       |#include "absl/base/internal/scheduling_mode.h"
   38|       |#include "absl/base/internal/spinlock_wait.h"
   39|       |#include "absl/base/macros.h"
   40|       |#include "absl/base/optimization.h"
   41|       |#include "absl/base/port.h"
   42|       |
   43|       |namespace absl {
   44|       |inline namespace lts_2019_08_08 {
   45|       |
   46|       |class once_flag;
   47|       |
   48|       |namespace base_internal {
   49|       |std::atomic<uint32_t>* ControlWord(absl::once_flag* flag);
   50|       |}  // namespace base_internal
   51|       |
   52|       |// call_once()
   53|       |//
   54|       |// For all invocations using a given `once_flag`, invokes a given `fn` exactly
   55|       |// once across all threads. The first call to `call_once()` with a particular
   56|       |// `once_flag` argument (that does not throw an exception) will run the
   57|       |// specified function with the provided `args`; other calls with the same
   58|       |// `once_flag` argument will not run the function, but will wait
   59|       |// for the provided function to finish running (if it is still running).
   60|       |//
   61|       |// This mechanism provides a safe, simple, and fast mechanism for one-time
   62|       |// initialization in a multi-threaded process.
   63|       |//
   64|       |// Example:
   65|       |//
   66|       |// class MyInitClass {
   67|       |//  public:
   68|       |//  ...
   69|       |//  mutable absl::once_flag once_;
   70|       |//
   71|       |//  MyInitClass* init() const {
   72|       |//    absl::call_once(once_, &MyInitClass::Init, this);
   73|       |//    return ptr_;
   74|       |//  }
   75|       |//
   76|       |template <typename Callable, typename... Args>
   77|       |void call_once(absl::once_flag& flag, Callable&& fn, Args&&... args);
   78|       |
   79|       |// once_flag
   80|       |//
   81|       |// Objects of this type are used to distinguish calls to `call_once()` and
   82|       |// ensure the provided function is only invoked once across all threads. This
   83|       |// type is not copyable or movable. However, it has a `constexpr`
   84|       |// constructor, and is safe to use as a namespace-scoped global variable.
   85|       |class once_flag {
   86|       | public:
   87|      0|  constexpr once_flag() : control_(0) {}
   88|       |  once_flag(const once_flag&) = delete;
   89|       |  once_flag& operator=(const once_flag&) = delete;
   90|       |
   91|       | private:
   92|       |  friend std::atomic<uint32_t>* base_internal::ControlWord(once_flag* flag);
   93|       |  std::atomic<uint32_t> control_;
   94|       |};
   95|       |
   96|       |//------------------------------------------------------------------------------
   97|       |// End of public interfaces.
   98|       |// Implementation details follow.
   99|       |//------------------------------------------------------------------------------
  100|       |
  101|       |namespace base_internal {
  102|       |
  103|       |// Like call_once, but uses KERNEL_ONLY scheduling. Intended to be used to
  104|       |// initialize entities used by the scheduler implementation.
  105|       |template <typename Callable, typename... Args>
  106|       |void LowLevelCallOnce(absl::once_flag* flag, Callable&& fn, Args&&... args);
  107|       |
  108|       |// Disables scheduling while on stack when scheduling mode is non-cooperative.
  109|       |// No effect for cooperative scheduling modes.
  110|       |class SchedulingHelper {
  111|       | public:
  112|      0|  explicit SchedulingHelper(base_internal::SchedulingMode mode) : mode_(mode) {
  113|      0|    if (mode_ == base_internal::SCHEDULE_KERNEL_ONLY) {
  114|      0|      guard_result_ = base_internal::SchedulingGuard::DisableRescheduling();
  115|      0|    }
  116|      0|  }
  117|       |
  118|      0|  ~SchedulingHelper() {
  119|      0|    if (mode_ == base_internal::SCHEDULE_KERNEL_ONLY) {
  120|      0|      base_internal::SchedulingGuard::EnableRescheduling(guard_result_);
  121|      0|    }
  122|      0|  }
  123|       |
  124|       | private:
  125|       |  base_internal::SchedulingMode mode_;
  126|       |  bool guard_result_;
  127|       |};
  128|       |
  129|       |// Bit patterns for call_once state machine values.  Internal implementation
  130|       |// detail, not for use by clients.
  131|       |//
  132|       |// The bit patterns are arbitrarily chosen from unlikely values, to aid in
  133|       |// debugging.  However, kOnceInit must be 0, so that a zero-initialized
  134|       |// once_flag will be valid for immediate use.
  135|       |enum {
  136|       |  kOnceInit = 0,
  137|       |  kOnceRunning = 0x65C2937B,
  138|       |  kOnceWaiter = 0x05A308D2,
  139|       |  // A very small constant is chosen for kOnceDone so that it fit in a single
  140|       |  // compare with immediate instruction for most common ISAs.  This is verified
  141|       |  // for x86, POWER and ARM.
  142|       |  kOnceDone = 221,    // Random Number
  143|       |};
  144|       |
  145|       |template <typename Callable, typename... Args>
  146|       |void CallOnceImpl(std::atomic<uint32_t>* control,
  147|       |                  base_internal::SchedulingMode scheduling_mode, Callable&& fn,
  148|      0|                  Args&&... args) {
  149|      0|#ifndef NDEBUG
  150|      0|  {
  151|      0|    uint32_t old_control = control->load(std::memory_order_acquire);
  152|      0|    if (old_control != kOnceInit &&
  153|      0|        old_control != kOnceRunning &&
  154|      0|        old_control != kOnceWaiter &&
  155|      0|        old_control != kOnceDone) {
  156|      0|      ABSL_RAW_LOG(FATAL, "Unexpected value for control word: 0x%lx",
  157|      0|                   static_cast<unsigned long>(old_control));  // NOLINT
  158|      0|    }
  159|      0|  }
  160|      0|#endif  // NDEBUG
  161|      0|  static const base_internal::SpinLockWaitTransition trans[] = {
  162|      0|      {kOnceInit, kOnceRunning, true},
  163|      0|      {kOnceRunning, kOnceWaiter, false},
  164|      0|      {kOnceDone, kOnceDone, true}};
  165|      0|
  166|      0|  // Must do this before potentially modifying control word's state.
  167|      0|  base_internal::SchedulingHelper maybe_disable_scheduling(scheduling_mode);
  168|      0|  // Short circuit the simplest case to avoid procedure call overhead.
  169|      0|  uint32_t old_control = kOnceInit;
  170|      0|  if (control->compare_exchange_strong(old_control, kOnceRunning,
  171|      0|                                       std::memory_order_acquire,
  172|      0|                                       std::memory_order_relaxed) ||
  173|      0|      base_internal::SpinLockWait(control, ABSL_ARRAYSIZE(trans), trans,
  174|      0|                                  scheduling_mode) == kOnceInit) {
  175|      0|    base_internal::Invoke(std::forward<Callable>(fn),
  176|      0|                          std::forward<Args>(args)...);
  177|      0|    old_control = control->load(std::memory_order_relaxed);
  178|      0|    control->store(base_internal::kOnceDone, std::memory_order_release);
  179|      0|    if (old_control == base_internal::kOnceWaiter) {
  180|      0|      base_internal::SpinLockWake(control, true);
  181|      0|    }
  182|      0|  }  // else *control is already kOnceDone
  183|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal12CallOnceImplIRFvvEJEEEvPNSt3__16atomicIjEENS1_14SchedulingModeEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: spinlock.cc:_ZN4absl14lts_2019_08_0813base_internal12CallOnceImplIZNS1_8SpinLock8SpinLoopEvE3$_0JEEEvPNSt3__16atomicIjEENS1_14SchedulingModeEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal12CallOnceImplIRFvPFvPvEEJRS5_EEEvPNSt3__16atomicIjEENS1_14SchedulingModeEOT_DpOT0_
  ------------------
  184|       |
  185|      0|inline std::atomic<uint32_t>* ControlWord(once_flag* flag) {
  186|      0|  return &flag->control_;
  187|      0|}
  188|       |
  189|       |template <typename Callable, typename... Args>
  190|      0|void LowLevelCallOnce(absl::once_flag* flag, Callable&& fn, Args&&... args) {
  191|      0|  std::atomic<uint32_t>* once = base_internal::ControlWord(flag);
  192|      0|  uint32_t s = once->load(std::memory_order_acquire);
  193|      0|  if (ABSL_PREDICT_FALSE(s != base_internal::kOnceDone)) {
  194|      0|    base_internal::CallOnceImpl(once, base_internal::SCHEDULE_KERNEL_ONLY,
  195|      0|                                std::forward<Callable>(fn),
  196|      0|                                std::forward<Args>(args)...);
  197|      0|  }
  198|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal16LowLevelCallOnceIRFvvEJEEEvPNS0_9once_flagEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: spinlock.cc:_ZN4absl14lts_2019_08_0813base_internal16LowLevelCallOnceIZNS1_8SpinLock8SpinLoopEvE3$_0JEEEvPNS0_9once_flagEOT_DpOT0_
  ------------------
  199|       |
  200|       |}  // namespace base_internal
  201|       |
  202|       |template <typename Callable, typename... Args>
  203|      0|void call_once(absl::once_flag& flag, Callable&& fn, Args&&... args) {
  204|      0|  std::atomic<uint32_t>* once = base_internal::ControlWord(&flag);
  205|      0|  uint32_t s = once->load(std::memory_order_acquire);
  206|      0|  if (ABSL_PREDICT_FALSE(s != base_internal::kOnceDone)) {
  207|      0|    base_internal::CallOnceImpl(
  208|      0|        once, base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL,
  209|      0|        std::forward<Callable>(fn), std::forward<Args>(args)...);
  210|      0|  }
  211|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_089call_onceIRFvvEJEEEvRNS0_9once_flagEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_089call_onceIRFvPFvPvEEJRS4_EEEvRNS0_9once_flagEOT_DpOT0_
  ------------------
  212|       |
  213|       |}  // inline namespace lts_2019_08_08
  214|       |}  // namespace absl
  215|       |
  216|       |#endif  // ABSL_BASE_CALL_ONCE_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/casts.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: casts.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This header file defines casting templates to fit use cases not covered by
   21|       |// the standard casts provided in the C++ standard. As with all cast operations,
   22|       |// use these with caution and only if alternatives do not exist.
   23|       |
   24|       |#ifndef ABSL_BASE_CASTS_H_
   25|       |#define ABSL_BASE_CASTS_H_
   26|       |
   27|       |#include <cstring>
   28|       |#include <memory>
   29|       |#include <type_traits>
   30|       |#include <utility>
   31|       |
   32|       |#include "absl/base/internal/identity.h"
   33|       |#include "absl/base/macros.h"
   34|       |#include "absl/meta/type_traits.h"
   35|       |
   36|       |namespace absl {
   37|       |inline namespace lts_2019_08_08 {
   38|       |
   39|       |namespace internal_casts {
   40|       |
   41|       |template <class Dest, class Source>
   42|       |struct is_bitcastable
   43|       |    : std::integral_constant<
   44|       |          bool,
   45|       |          sizeof(Dest) == sizeof(Source) &&
   46|       |              type_traits_internal::is_trivially_copyable<Source>::value &&
   47|       |              type_traits_internal::is_trivially_copyable<Dest>::value &&
   48|       |              std::is_default_constructible<Dest>::value> {};
   49|       |
   50|       |}  // namespace internal_casts
   51|       |
   52|       |// implicit_cast()
   53|       |//
   54|       |// Performs an implicit conversion between types following the language
   55|       |// rules for implicit conversion; if an implicit conversion is otherwise
   56|       |// allowed by the language in the given context, this function performs such an
   57|       |// implicit conversion.
   58|       |//
   59|       |// Example:
   60|       |//
   61|       |//   // If the context allows implicit conversion:
   62|       |//   From from;
   63|       |//   To to = from;
   64|       |//
   65|       |//   // Such code can be replaced by:
   66|       |//   implicit_cast<To>(from);
   67|       |//
   68|       |// An `implicit_cast()` may also be used to annotate numeric type conversions
   69|       |// that, although safe, may produce compiler warnings (such as `long` to `int`).
   70|       |// Additionally, an `implicit_cast()` is also useful within return statements to
   71|       |// indicate a specific implicit conversion is being undertaken.
   72|       |//
   73|       |// Example:
   74|       |//
   75|       |//   return implicit_cast<double>(size_in_bytes) / capacity_;
   76|       |//
   77|       |// Annotating code with `implicit_cast()` allows you to explicitly select
   78|       |// particular overloads and template instantiations, while providing a safer
   79|       |// cast than `reinterpret_cast()` or `static_cast()`.
   80|       |//
   81|       |// Additionally, an `implicit_cast()` can be used to allow upcasting within a
   82|       |// type hierarchy where incorrect use of `static_cast()` could accidentally
   83|       |// allow downcasting.
   84|       |//
   85|       |// Finally, an `implicit_cast()` can be used to perform implicit conversions
   86|       |// from unrelated types that otherwise couldn't be implicitly cast directly;
   87|       |// C++ will normally only implicitly cast "one step" in such conversions.
   88|       |//
   89|       |// That is, if C is a type which can be implicitly converted to B, with B being
   90|       |// a type that can be implicitly converted to A, an `implicit_cast()` can be
   91|       |// used to convert C to B (which the compiler can then implicitly convert to A
   92|       |// using language rules).
   93|       |//
   94|       |// Example:
   95|       |//
   96|       |//   // Assume an object C is convertible to B, which is implicitly convertible
   97|       |//   // to A
   98|       |//   A a = implicit_cast<B>(C);
   99|       |//
  100|       |// Such implicit cast chaining may be useful within template logic.
  101|       |template <typename To>
  102|       |constexpr To implicit_cast(typename absl::internal::identity_t<To> to) {
  103|       |  return to;
  104|       |}
  105|       |
  106|       |// bit_cast()
  107|       |//
  108|       |// Performs a bitwise cast on a type without changing the underlying bit
  109|       |// representation of that type's value. The two types must be of the same size
  110|       |// and both types must be trivially copyable. As with most casts, use with
  111|       |// caution. A `bit_cast()` might be needed when you need to temporarily treat a
  112|       |// type as some other type, such as in the following cases:
  113|       |//
  114|       |//    * Serialization (casting temporarily to `char *` for those purposes is
  115|       |//      always allowed by the C++ standard)
  116|       |//    * Managing the individual bits of a type within mathematical operations
  117|       |//      that are not normally accessible through that type
  118|       |//    * Casting non-pointer types to pointer types (casting the other way is
  119|       |//      allowed by `reinterpret_cast()` but round-trips cannot occur the other
  120|       |//      way).
  121|       |//
  122|       |// Example:
  123|       |//
  124|       |//   float f = 3.14159265358979;
  125|       |//   int i = bit_cast<int32_t>(f);
  126|       |//   // i = 0x40490fdb
  127|       |//
  128|       |// Casting non-pointer types to pointer types and then dereferencing them
  129|       |// traditionally produces undefined behavior.
  130|       |//
  131|       |// Example:
  132|       |//
  133|       |//   // WRONG
  134|       |//   float f = 3.14159265358979;            // WRONG
  135|       |//   int i = * reinterpret_cast<int*>(&f);  // WRONG
  136|       |//
  137|       |// The address-casting method produces undefined behavior according to the ISO
  138|       |// C++ specification section [basic.lval]. Roughly, this section says: if an
  139|       |// object in memory has one type, and a program accesses it with a different
  140|       |// type, the result is undefined behavior for most values of "different type".
  141|       |//
  142|       |// Such casting results in type punning: holding an object in memory of one type
  143|       |// and reading its bits back using a different type. A `bit_cast()` avoids this
  144|       |// issue by implementing its casts using `memcpy()`, which avoids introducing
  145|       |// this undefined behavior.
  146|       |//
  147|       |// NOTE: The requirements here are more strict than the bit_cast of standard
  148|       |// proposal p0476 due to the need for workarounds and lack of intrinsics.
  149|       |// Specifically, this implementation also requires `Dest` to be
  150|       |// default-constructible.
  151|       |template <
  152|       |    typename Dest, typename Source,
  153|       |    typename std::enable_if<internal_casts::is_bitcastable<Dest, Source>::value,
  154|       |                            int>::type = 0>
  155|      0|inline Dest bit_cast(const Source& source) {
  156|      0|  Dest dest;
  157|      0|  memcpy(static_cast<void*>(std::addressof(dest)),
  158|      0|         static_cast<const void*>(std::addressof(source)), sizeof(dest));
  159|      0|  return dest;
  160|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_088bit_castIdyLi0EEET_RKT0_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_088bit_castIfjLi0EEET_RKT0_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_088bit_castIxyLi0EEET_RKT0_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_088bit_castIyxLi0EEET_RKT0_
  ------------------
  161|       |
  162|       |// NOTE: This overload is only picked if the requirements of bit_cast are not
  163|       |// met. It is therefore UB, but is provided temporarily as previous versions of
  164|       |// this function template were unchecked. Do not use this in new code.
  165|       |template <
  166|       |    typename Dest, typename Source,
  167|       |    typename std::enable_if<
  168|       |        !internal_casts::is_bitcastable<Dest, Source>::value, int>::type = 0>
  169|       |ABSL_DEPRECATED(
  170|       |    "absl::bit_cast type requirements were violated. Update the types being "
  171|       |    "used such that they are the same size and are both TriviallyCopyable.")
  172|       |inline Dest bit_cast(const Source& source) {
  173|       |  static_assert(sizeof(Dest) == sizeof(Source),
  174|       |                "Source and destination types should have equal sizes.");
  175|       |
  176|       |  Dest dest;
  177|       |  memcpy(&dest, &source, sizeof(dest));
  178|       |  return dest;
  179|       |}
  180|       |
  181|       |}  // inline namespace lts_2019_08_08
  182|       |}  // namespace absl
  183|       |
  184|       |#endif  // ABSL_BASE_CASTS_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/dynamic_annotations.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include <stdlib.h>
   16|       |#include <string.h>
   17|       |
   18|       |#include "absl/base/dynamic_annotations.h"
   19|       |
   20|       |#ifndef __has_feature
   21|       |#define __has_feature(x) 0
   22|       |#endif
   23|       |
   24|       |/* Compiler-based ThreadSanitizer defines
   25|       |   DYNAMIC_ANNOTATIONS_EXTERNAL_IMPL = 1
   26|       |   and provides its own definitions of the functions. */
   27|       |
   28|       |#ifndef DYNAMIC_ANNOTATIONS_EXTERNAL_IMPL
   29|       |# define DYNAMIC_ANNOTATIONS_EXTERNAL_IMPL 0
   30|       |#endif
   31|       |
   32|       |/* Each function is empty and called (via a macro) only in debug mode.
   33|       |   The arguments are captured by dynamic tools at runtime. */
   34|       |
   35|       |#if DYNAMIC_ANNOTATIONS_EXTERNAL_IMPL == 0 && !defined(__native_client__)
   36|       |
   37|       |#if __has_feature(memory_sanitizer)
   38|       |#include <sanitizer/msan_interface.h>
   39|       |#endif
   40|       |
   41|       |#ifdef __cplusplus
   42|       |extern "C" {
   43|       |#endif
   44|       |
   45|       |void AnnotateRWLockCreate(const char *, int,
   46|      0|                          const volatile void *){}
   47|       |void AnnotateRWLockDestroy(const char *, int,
   48|      0|                           const volatile void *){}
   49|       |void AnnotateRWLockAcquired(const char *, int,
   50|      0|                            const volatile void *, long){}
   51|       |void AnnotateRWLockReleased(const char *, int,
   52|      0|                            const volatile void *, long){}
   53|       |void AnnotateBenignRace(const char *, int,
   54|       |                        const volatile void *,
   55|      0|                        const char *){}
   56|       |void AnnotateBenignRaceSized(const char *, int,
   57|       |                             const volatile void *,
   58|       |                             size_t,
   59|      0|                             const char *) {}
   60|       |void AnnotateThreadName(const char *, int,
   61|      0|                        const char *){}
   62|      0|void AnnotateIgnoreReadsBegin(const char *, int){}
   63|      0|void AnnotateIgnoreReadsEnd(const char *, int){}
   64|      0|void AnnotateIgnoreWritesBegin(const char *, int){}
   65|      0|void AnnotateIgnoreWritesEnd(const char *, int){}
   66|      0|void AnnotateEnableRaceDetection(const char *, int, int){}
   67|       |void AnnotateMemoryIsInitialized(const char *, int,
   68|      0|                                 const volatile void *mem, size_t size) {
   69|       |#if __has_feature(memory_sanitizer)
   70|       |  __msan_unpoison(mem, size);
   71|       |#else
   72|       |  (void)mem;
   73|      0|  (void)size;
   74|      0|#endif
   75|      0|}
   76|       |
   77|       |void AnnotateMemoryIsUninitialized(const char *, int,
   78|      0|                                   const volatile void *mem, size_t size) {
   79|       |#if __has_feature(memory_sanitizer)
   80|       |  __msan_allocated_memory(mem, size);
   81|       |#else
   82|       |  (void)mem;
   83|      0|  (void)size;
   84|      0|#endif
   85|      0|}
   86|       |
   87|      0|static int GetRunningOnValgrind(void) {
   88|       |#ifdef RUNNING_ON_VALGRIND
   89|       |  if (RUNNING_ON_VALGRIND) return 1;
   90|       |#endif
   91|       |  char *running_on_valgrind_str = getenv("RUNNING_ON_VALGRIND");
   92|      0|  if (running_on_valgrind_str) {
   93|      0|    return strcmp(running_on_valgrind_str, "0") != 0;
   94|      0|  }
   95|      0|  return 0;
   96|      0|}
   97|       |
   98|       |/* See the comments in dynamic_annotations.h */
   99|      0|int RunningOnValgrind(void) {
  100|      0|  static volatile int running_on_valgrind = -1;
  101|      0|  int local_running_on_valgrind = running_on_valgrind;
  102|      0|  /* C doesn't have thread-safe initialization of statics, and we
  103|      0|     don't want to depend on pthread_once here, so hack it. */
  104|      0|  ANNOTATE_BENIGN_RACE(&running_on_valgrind, "safe hack");
  105|      0|  if (local_running_on_valgrind == -1)
  106|      0|    running_on_valgrind = local_running_on_valgrind = GetRunningOnValgrind();
  107|      0|  return local_running_on_valgrind;
  108|      0|}
  109|       |
  110|       |/* See the comments in dynamic_annotations.h */
  111|      0|double ValgrindSlowdown(void) {
  112|      0|  /* Same initialization hack as in RunningOnValgrind(). */
  113|      0|  static volatile double slowdown = 0.0;
  114|      0|  double local_slowdown = slowdown;
  115|      0|  ANNOTATE_BENIGN_RACE(&slowdown, "safe hack");
  116|      0|  if (RunningOnValgrind() == 0) {
  117|      0|    return 1.0;
  118|      0|  }
  119|      0|  if (local_slowdown == 0.0) {
  120|      0|    char *env = getenv("VALGRIND_SLOWDOWN");
  121|      0|    slowdown = local_slowdown = env ? atof(env) : 50.0;
  122|      0|  }
  123|      0|  return local_slowdown;
  124|      0|}
  125|       |
  126|       |#ifdef __cplusplus
  127|       |}  // extern "C"
  128|       |#endif
  129|       |#endif  /* DYNAMIC_ANNOTATIONS_EXTERNAL_IMPL == 0 */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/atomic_hook.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |
   16|       |#ifndef ABSL_BASE_INTERNAL_ATOMIC_HOOK_H_
   17|       |#define ABSL_BASE_INTERNAL_ATOMIC_HOOK_H_
   18|       |
   19|       |#include <atomic>
   20|       |#include <cassert>
   21|       |#include <cstdint>
   22|       |#include <utility>
   23|       |
   24|       |#ifdef _MSC_FULL_VER
   25|       |#define ABSL_HAVE_WORKING_ATOMIC_POINTER 0
   26|       |#else
   27|       |#define ABSL_HAVE_WORKING_ATOMIC_POINTER 1
   28|       |#endif
   29|       |
   30|       |namespace absl {
   31|       |inline namespace lts_2019_08_08 {
   32|       |namespace base_internal {
   33|       |
   34|       |template <typename T>
   35|       |class AtomicHook;
   36|       |
   37|       |// AtomicHook is a helper class, templatized on a raw function pointer type, for
   38|       |// implementing Abseil customization hooks.  It is a callable object that
   39|       |// dispatches to the registered hook.
   40|       |//
   41|       |// A default constructed object performs a no-op (and returns a default
   42|       |// constructed object) if no hook has been registered.
   43|       |//
   44|       |// Hooks can be pre-registered via constant initialization, for example,
   45|       |// ABSL_CONST_INIT static AtomicHook<void(*)()> my_hook(DefaultAction);
   46|       |// and then changed at runtime via a call to Store().
   47|       |//
   48|       |// Reads and writes guarantee memory_order_acquire/memory_order_release
   49|       |// semantics.
   50|       |template <typename ReturnType, typename... Args>
   51|       |class AtomicHook<ReturnType (*)(Args...)> {
   52|       | public:
   53|       |  using FnPtr = ReturnType (*)(Args...);
   54|       |
   55|       |  // Constructs an object that by default performs a no-op (and
   56|       |  // returns a default constructed object) when no hook as been registered.
   57|       |  constexpr AtomicHook() : AtomicHook(DummyFunction) {}
   58|       |
   59|       |  // Constructs an object that by default dispatches to/returns the
   60|       |  // pre-registered default_fn when no hook has been registered at runtime.
   61|       |#if ABSL_HAVE_WORKING_ATOMIC_POINTER
   62|       |  explicit constexpr AtomicHook(FnPtr default_fn)
   63|       |      : hook_(default_fn), default_fn_(default_fn) {}
   64|       |#else
   65|       |  explicit constexpr AtomicHook(FnPtr default_fn)
   66|       |      : hook_(kUninitialized), default_fn_(default_fn) {}
   67|       |#endif
   68|       |
   69|       |  // Stores the provided function pointer as the value for this hook.
   70|       |  //
   71|       |  // This is intended to be called once.  Multiple calls are legal only if the
   72|       |  // same function pointer is provided for each call.  The store is implemented
   73|       |  // as a memory_order_release operation, and read accesses are implemented as
   74|       |  // memory_order_acquire.
   75|      0|  void Store(FnPtr fn) {
   76|      0|    bool success = DoStore(fn);
   77|      0|    static_cast<void>(success);
   78|      0|    assert(success);
   79|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal10AtomicHookIPFvNS0_11LogSeverityEPKciRKNSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEE5StoreESG_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal10AtomicHookIPFvPKvxEE5StoreES6_
  ------------------
   80|       |
   81|       |  // Invokes the registered callback.  If no callback has yet been registered, a
   82|       |  // default-constructed object of the appropriate type is returned instead.
   83|       |  template <typename... CallArgs>
   84|      0|  ReturnType operator()(CallArgs&&... args) const {
   85|      0|    return DoLoad()(std::forward<CallArgs>(args)...);
   86|      0|  }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813base_internal10AtomicHookIPFvPKciS4_S4_S4_EEclIJRS4_RiRA3000_cRKS4_PcEEEvDpOT_
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813base_internal10AtomicHookIPFvPKvxEEclIJPNS1_8SpinLockERKyEEEvDpOT_
  ------------------
   87|       |
   88|       |  // Returns the registered callback, or nullptr if none has been registered.
   89|       |  // Useful if client code needs to conditionalize behavior based on whether a
   90|       |  // callback was registered.
   91|       |  //
   92|       |  // Note that atomic_hook.Load()() and atomic_hook() have different semantics:
   93|       |  // operator()() will perform a no-op if no callback was registered, while
   94|       |  // Load()() will dereference a null function pointer.  Prefer operator()() to
   95|       |  // Load()() unless you must conditionalize behavior on whether a hook was
   96|       |  // registered.
   97|      0|  FnPtr Load() const {
   98|      0|    FnPtr ptr = DoLoad();
   99|      0|    return (ptr == DummyFunction) ? nullptr : ptr;
  100|      0|  }
  101|       |
  102|       | private:
  103|      0|  static ReturnType DummyFunction(Args...) {
  104|      0|    return ReturnType();
  105|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal10AtomicHookIPFbNS0_11LogSeverityEPKciPPcPiEE13DummyFunctionES3_S5_iS7_S8_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal10AtomicHookIPFvPKciS4_S4_S4_EE13DummyFunctionES4_iS4_S4_S4_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal10AtomicHookIPFvPKvxEE13DummyFunctionES4_x
  ------------------
  106|       |
  107|       |  // Current versions of MSVC (as of September 2017) have a broken
  108|       |  // implementation of std::atomic<T*>:  Its constructor attempts to do the
  109|       |  // equivalent of a reinterpret_cast in a constexpr context, which is not
  110|       |  // allowed.
  111|       |  //
  112|       |  // This causes an issue when building with LLVM under Windows.  To avoid this,
  113|       |  // we use a less-efficient, intptr_t-based implementation on Windows.
  114|       |#if ABSL_HAVE_WORKING_ATOMIC_POINTER
  115|       |  // Return the stored value, or DummyFunction if no value has been stored.
  116|      0|  FnPtr DoLoad() const { return hook_.load(std::memory_order_acquire); }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813base_internal10AtomicHookIPFbNS0_11LogSeverityEPKciPPcPiEE6DoLoadEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813base_internal10AtomicHookIPFvPKciS4_S4_S4_EE6DoLoadEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813base_internal10AtomicHookIPFvPKvxEE6DoLoadEv
  ------------------
  117|       |
  118|       |  // Store the given value.  Returns false if a different value was already
  119|       |  // stored to this object.
  120|      0|  bool DoStore(FnPtr fn) {
  121|      0|    assert(fn);
  122|      0|    FnPtr expected = default_fn_;
  123|      0|    const bool store_succeeded = hook_.compare_exchange_strong(
  124|      0|        expected, fn, std::memory_order_acq_rel, std::memory_order_acquire);
  125|      0|    const bool same_value_already_stored = (expected == fn);
  126|      0|    return store_succeeded || same_value_already_stored;
  127|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal10AtomicHookIPFvNS0_11LogSeverityEPKciRKNSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEEE7DoStoreESG_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal10AtomicHookIPFvPKvxEE7DoStoreES6_
  ------------------
  128|       |
  129|       |  std::atomic<FnPtr> hook_;
  130|       |#else  // !ABSL_HAVE_WORKING_ATOMIC_POINTER
  131|       |  // Use a sentinel value unlikely to be the address of an actual function.
  132|       |  static constexpr intptr_t kUninitialized = 0;
  133|       |
  134|       |  static_assert(sizeof(intptr_t) >= sizeof(FnPtr),
  135|       |                "intptr_t can't contain a function pointer");
  136|       |
  137|       |  FnPtr DoLoad() const {
  138|       |    const intptr_t value = hook_.load(std::memory_order_acquire);
  139|       |    if (value == kUninitialized) {
  140|       |      return default_fn_;
  141|       |    }
  142|       |    return reinterpret_cast<FnPtr>(value);
  143|       |  }
  144|       |
  145|       |  bool DoStore(FnPtr fn) {
  146|       |    assert(fn);
  147|       |    const auto value = reinterpret_cast<intptr_t>(fn);
  148|       |    intptr_t expected = kUninitialized;
  149|       |    const bool store_succeeded = hook_.compare_exchange_strong(
  150|       |        expected, value, std::memory_order_acq_rel, std::memory_order_acquire);
  151|       |    const bool same_value_already_stored = (expected == value);
  152|       |    return store_succeeded || same_value_already_stored;
  153|       |  }
  154|       |
  155|       |  std::atomic<intptr_t> hook_;
  156|       |#endif
  157|       |
  158|       |  const FnPtr default_fn_;
  159|       |};
  160|       |
  161|       |#undef ABSL_HAVE_WORKING_ATOMIC_POINTER
  162|       |
  163|       |}  // namespace base_internal
  164|       |}  // inline namespace lts_2019_08_08
  165|       |}  // namespace absl
  166|       |
  167|       |#endif  // ABSL_BASE_INTERNAL_ATOMIC_HOOK_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/bits.h:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#ifndef ABSL_BASE_INTERNAL_BITS_H_
   16|       |#define ABSL_BASE_INTERNAL_BITS_H_
   17|       |
   18|       |// This file contains bitwise ops which are implementation details of various
   19|       |// absl libraries.
   20|       |
   21|       |#include <cstdint>
   22|       |
   23|       |// Clang on Windows has __builtin_clzll; otherwise we need to use the
   24|       |// windows intrinsic functions.
   25|       |#if defined(_MSC_VER)
   26|       |#include <intrin.h>
   27|       |#if defined(_M_X64)
   28|       |#pragma intrinsic(_BitScanReverse64)
   29|       |#pragma intrinsic(_BitScanForward64)
   30|       |#endif
   31|       |#pragma intrinsic(_BitScanReverse)
   32|       |#pragma intrinsic(_BitScanForward)
   33|       |#endif
   34|       |
   35|       |#include "absl/base/attributes.h"
   36|       |
   37|       |#if defined(_MSC_VER)
   38|       |// We can achieve something similar to attribute((always_inline)) with MSVC by
   39|       |// using the __forceinline keyword, however this is not perfect. MSVC is
   40|       |// much less aggressive about inlining, and even with the __forceinline keyword.
   41|       |#define ABSL_BASE_INTERNAL_FORCEINLINE __forceinline
   42|       |#else
   43|       |// Use default attribute inline.
   44|       |#define ABSL_BASE_INTERNAL_FORCEINLINE inline ABSL_ATTRIBUTE_ALWAYS_INLINE
   45|       |#endif
   46|       |
   47|       |
   48|       |namespace absl {
   49|       |inline namespace lts_2019_08_08 {
   50|       |namespace base_internal {
   51|       |
   52|      0|ABSL_BASE_INTERNAL_FORCEINLINE int CountLeadingZeros64Slow(uint64_t n) {
   53|      0|  int zeroes = 60;
   54|      0|  if (n >> 32) zeroes -= 32, n >>= 32;
   55|      0|  if (n >> 16) zeroes -= 16, n >>= 16;
   56|      0|  if (n >> 8) zeroes -= 8, n >>= 8;
   57|      0|  if (n >> 4) zeroes -= 4, n >>= 4;
   58|      0|  return "\4\3\2\2\1\1\1\1\0\0\0\0\0\0\0"[n] + zeroes;
   59|      0|}
   60|       |
   61|      0|ABSL_BASE_INTERNAL_FORCEINLINE int CountLeadingZeros64(uint64_t n) {
   62|       |#if defined(_MSC_VER) && defined(_M_X64)
   63|       |  // MSVC does not have __buitin_clzll. Use _BitScanReverse64.
   64|       |  unsigned long result = 0;  // NOLINT(runtime/int)
   65|       |  if (_BitScanReverse64(&result, n)) {
   66|       |    return 63 - result;
   67|       |  }
   68|       |  return 64;
   69|       |#elif defined(_MSC_VER)
   70|       |  // MSVC does not have __buitin_clzll. Compose two calls to _BitScanReverse
   71|       |  unsigned long result = 0;  // NOLINT(runtime/int)
   72|       |  if ((n >> 32) && _BitScanReverse(&result, n >> 32)) {
   73|       |    return 31 - result;
   74|       |  }
   75|       |  if (_BitScanReverse(&result, n)) {
   76|       |    return 63 - result;
   77|       |  }
   78|       |  return 64;
   79|       |#elif defined(__GNUC__)
   80|       |  // Use __builtin_clzll, which uses the following instructions:
   81|      0|  //  x86: bsr
   82|      0|  //  ARM64: clz
   83|      0|  //  PPC: cntlzd
   84|      0|  static_assert(sizeof(unsigned long long) == sizeof(n),  // NOLINT(runtime/int)
   85|      0|                "__builtin_clzll does not take 64-bit arg");
   86|      0|
   87|      0|  // Handle 0 as a special case because __builtin_clzll(0) is undefined.
   88|      0|  if (n == 0) {
   89|      0|    return 64;
   90|      0|  }
   91|      0|  return __builtin_clzll(n);
   92|       |#else
   93|       |  return CountLeadingZeros64Slow(n);
   94|       |#endif
   95|       |}
   96|       |
   97|      0|ABSL_BASE_INTERNAL_FORCEINLINE int CountLeadingZeros32Slow(uint64_t n) {
   98|      0|  int zeroes = 28;
   99|      0|  if (n >> 16) zeroes -= 16, n >>= 16;
  100|      0|  if (n >> 8) zeroes -= 8, n >>= 8;
  101|      0|  if (n >> 4) zeroes -= 4, n >>= 4;
  102|      0|  return "\4\3\2\2\1\1\1\1\0\0\0\0\0\0\0"[n] + zeroes;
  103|      0|}
  104|       |
  105|      0|ABSL_BASE_INTERNAL_FORCEINLINE int CountLeadingZeros32(uint32_t n) {
  106|      0|#if defined(_MSC_VER)
  107|      0|  unsigned long result = 0;  // NOLINT(runtime/int)
  108|      0|  if (_BitScanReverse(&result, n)) {
  109|      0|    return 31 - result;
  110|      0|  }
  111|      0|  return 32;
  112|      0|#elif defined(__GNUC__)
  113|      0|  // Use __builtin_clz, which uses the following instructions:
  114|      0|  //  x86: bsr
  115|      0|  //  ARM64: clz
  116|      0|  //  PPC: cntlzd
  117|      0|  static_assert(sizeof(int) == sizeof(n),
  118|      0|                "__builtin_clz does not take 32-bit arg");
  119|      0|
  120|      0|  // Handle 0 as a special case because __builtin_clz(0) is undefined.
  121|      0|  if (n == 0) {
  122|      0|    return 32;
  123|      0|  }
  124|      0|  return __builtin_clz(n);
  125|      0|#else
  126|      0|  return CountLeadingZeros32Slow(n);
  127|      0|#endif
  128|      0|}
  129|       |
  130|      0|ABSL_BASE_INTERNAL_FORCEINLINE int CountTrailingZerosNonZero64Slow(uint64_t n) {
  131|      0|  int c = 63;
  132|      0|  n &= ~n + 1;
  133|      0|  if (n & 0x00000000FFFFFFFF) c -= 32;
  134|      0|  if (n & 0x0000FFFF0000FFFF) c -= 16;
  135|      0|  if (n & 0x00FF00FF00FF00FF) c -= 8;
  136|      0|  if (n & 0x0F0F0F0F0F0F0F0F) c -= 4;
  137|      0|  if (n & 0x3333333333333333) c -= 2;
  138|      0|  if (n & 0x5555555555555555) c -= 1;
  139|      0|  return c;
  140|      0|}
  141|       |
  142|      0|ABSL_BASE_INTERNAL_FORCEINLINE int CountTrailingZerosNonZero64(uint64_t n) {
  143|      0|#if defined(_MSC_VER) && defined(_M_X64)
  144|      0|  unsigned long result = 0;  // NOLINT(runtime/int)
  145|      0|  _BitScanForward64(&result, n);
  146|      0|  return result;
  147|      0|#elif defined(_MSC_VER)
  148|      0|  unsigned long result = 0;  // NOLINT(runtime/int)
  149|      0|  if (static_cast<uint32_t>(n) == 0) {
  150|      0|    _BitScanForward(&result, n >> 32);
  151|      0|    return result + 32;
  152|      0|  }
  153|      0|  _BitScanForward(&result, n);
  154|      0|  return result;
  155|      0|#elif defined(__GNUC__)
  156|      0|  static_assert(sizeof(unsigned long long) == sizeof(n),  // NOLINT(runtime/int)
  157|      0|                "__builtin_ctzll does not take 64-bit arg");
  158|      0|  return __builtin_ctzll(n);
  159|      0|#else
  160|      0|  return CountTrailingZerosNonZero64Slow(n);
  161|      0|#endif
  162|      0|}
  163|       |
  164|      0|ABSL_BASE_INTERNAL_FORCEINLINE int CountTrailingZerosNonZero32Slow(uint32_t n) {
  165|      0|  int c = 31;
  166|      0|  n &= ~n + 1;
  167|      0|  if (n & 0x0000FFFF) c -= 16;
  168|      0|  if (n & 0x00FF00FF) c -= 8;
  169|      0|  if (n & 0x0F0F0F0F) c -= 4;
  170|      0|  if (n & 0x33333333) c -= 2;
  171|      0|  if (n & 0x55555555) c -= 1;
  172|      0|  return c;
  173|      0|}
  174|       |
  175|      0|ABSL_BASE_INTERNAL_FORCEINLINE int CountTrailingZerosNonZero32(uint32_t n) {
  176|      0|#if defined(_MSC_VER)
  177|      0|  unsigned long result = 0;  // NOLINT(runtime/int)
  178|      0|  _BitScanForward(&result, n);
  179|      0|  return result;
  180|      0|#elif defined(__GNUC__)
  181|      0|  static_assert(sizeof(int) == sizeof(n),
  182|      0|                "__builtin_ctz does not take 32-bit arg");
  183|      0|  return __builtin_ctz(n);
  184|      0|#else
  185|      0|  return CountTrailingZerosNonZero32Slow(n);
  186|      0|#endif
  187|      0|}
  188|       |
  189|       |#undef ABSL_BASE_INTERNAL_FORCEINLINE
  190|       |
  191|       |}  // namespace base_internal
  192|       |}  // inline namespace lts_2019_08_08
  193|       |}  // namespace absl
  194|       |
  195|       |#endif  // ABSL_BASE_INTERNAL_BITS_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/cycleclock.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |// The implementation of CycleClock::Frequency.
   16|       |//
   17|       |// NOTE: only i386 and x86_64 have been well tested.
   18|       |// PPC, sparc, alpha, and ia64 are based on
   19|       |//    http://peter.kuscsik.com/wordpress/?p=14
   20|       |// with modifications by m3b.  See also
   21|       |//    https://setisvn.ssl.berkeley.edu/svn/lib/fftw-3.0.1/kernel/cycle.h
   22|       |
   23|       |#include "absl/base/internal/cycleclock.h"
   24|       |
   25|       |#include <atomic>
   26|       |#include <chrono>  // NOLINT(build/c++11)
   27|       |
   28|       |#include "absl/base/internal/unscaledcycleclock.h"
   29|       |
   30|       |namespace absl {
   31|       |inline namespace lts_2019_08_08 {
   32|       |namespace base_internal {
   33|       |
   34|       |#if ABSL_USE_UNSCALED_CYCLECLOCK
   35|       |
   36|       |namespace {
   37|       |
   38|       |#ifdef NDEBUG
   39|       |#ifdef ABSL_INTERNAL_UNSCALED_CYCLECLOCK_FREQUENCY_IS_CPU_FREQUENCY
   40|       |// Not debug mode and the UnscaledCycleClock frequency is the CPU
   41|       |// frequency.  Scale the CycleClock to prevent overflow if someone
   42|       |// tries to represent the time as cycles since the Unix epoch.
   43|       |static constexpr int32_t kShift = 1;
   44|       |#else
   45|       |// Not debug mode and the UnscaledCycleClock isn't operating at the
   46|       |// raw CPU frequency. There is no need to do any scaling, so don't
   47|       |// needlessly sacrifice precision.
   48|       |static constexpr int32_t kShift = 0;
   49|       |#endif
   50|       |#else
   51|       |// In debug mode use a different shift to discourage depending on a
   52|       |// particular shift value.
   53|       |static constexpr int32_t kShift = 2;
   54|       |#endif
   55|       |
   56|       |static constexpr double kFrequencyScale = 1.0 / (1 << kShift);
   57|       |static std::atomic<CycleClockSourceFunc> cycle_clock_source;
   58|       |
   59|       |CycleClockSourceFunc LoadCycleClockSource() {
   60|       |  // Optimize for the common case (no callback) by first doing a relaxed load;
   61|       |  // this is significantly faster on non-x86 platforms.
   62|       |  if (cycle_clock_source.load(std::memory_order_relaxed) == nullptr) {
   63|       |    return nullptr;
   64|       |  }
   65|       |  // This corresponds to the store(std::memory_order_release) in
   66|       |  // CycleClockSource::Register, and makes sure that any updates made prior to
   67|       |  // registering the callback are visible to this thread before the callback is
   68|       |  // invoked.
   69|       |  return cycle_clock_source.load(std::memory_order_acquire);
   70|       |}
   71|       |
   72|       |}  // namespace
   73|       |
   74|       |int64_t CycleClock::Now() {
   75|       |  auto fn = LoadCycleClockSource();
   76|       |  if (fn == nullptr) {
   77|       |    return base_internal::UnscaledCycleClock::Now() >> kShift;
   78|       |  }
   79|       |  return fn() >> kShift;
   80|       |}
   81|       |
   82|       |double CycleClock::Frequency() {
   83|       |  return kFrequencyScale * base_internal::UnscaledCycleClock::Frequency();
   84|       |}
   85|       |
   86|       |void CycleClockSource::Register(CycleClockSourceFunc source) {
   87|       |  // Corresponds to the load(std::memory_order_acquire) in LoadCycleClockSource.
   88|       |  cycle_clock_source.store(source, std::memory_order_release);
   89|       |}
   90|       |
   91|       |#else
   92|       |
   93|      0|int64_t CycleClock::Now() {
   94|      0|  return std::chrono::duration_cast<std::chrono::nanoseconds>(
   95|      0|             std::chrono::steady_clock::now().time_since_epoch())
   96|      0|      .count();
   97|      0|}
   98|       |
   99|      0|double CycleClock::Frequency() {
  100|      0|  return 1e9;
  101|      0|}
  102|       |
  103|       |#endif
  104|       |
  105|       |}  // namespace base_internal
  106|       |}  // inline namespace lts_2019_08_08
  107|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/direct_mmap.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// Functions for directly invoking mmap() via syscall, avoiding the case where
   16|       |// mmap() has been locally overridden.
   17|       |
   18|       |#ifndef ABSL_BASE_INTERNAL_DIRECT_MMAP_H_
   19|       |#define ABSL_BASE_INTERNAL_DIRECT_MMAP_H_
   20|       |
   21|       |#include "absl/base/config.h"
   22|       |
   23|       |#if ABSL_HAVE_MMAP
   24|       |
   25|       |#include <sys/mman.h>
   26|       |
   27|       |#ifdef __linux__
   28|       |
   29|       |#include <sys/types.h>
   30|       |#ifdef __BIONIC__
   31|       |#include <sys/syscall.h>
   32|       |#else
   33|       |#include <syscall.h>
   34|       |#endif
   35|       |
   36|       |#include <linux/unistd.h>
   37|       |#include <unistd.h>
   38|       |#include <cerrno>
   39|       |#include <cstdarg>
   40|       |#include <cstdint>
   41|       |
   42|       |#ifdef __mips__
   43|       |// Include definitions of the ABI currently in use.
   44|       |#ifdef __BIONIC__
   45|       |// Android doesn't have sgidefs.h, but does have asm/sgidefs.h, which has the
   46|       |// definitions we need.
   47|       |#include <asm/sgidefs.h>
   48|       |#else
   49|       |#include <sgidefs.h>
   50|       |#endif  // __BIONIC__
   51|       |#endif  // __mips__
   52|       |
   53|       |// SYS_mmap and SYS_munmap are not defined in Android.
   54|       |#ifdef __BIONIC__
   55|       |extern "C" void* __mmap2(void*, size_t, int, int, int, size_t);
   56|       |#if defined(__NR_mmap) && !defined(SYS_mmap)
   57|       |#define SYS_mmap __NR_mmap
   58|       |#endif
   59|       |#ifndef SYS_munmap
   60|       |#define SYS_munmap __NR_munmap
   61|       |#endif
   62|       |#endif  // __BIONIC__
   63|       |
   64|       |namespace absl {
   65|       |inline namespace lts_2019_08_08 {
   66|       |namespace base_internal {
   67|       |
   68|       |// Platform specific logic extracted from
   69|       |// https://chromium.googlesource.com/linux-syscall-support/+/master/linux_syscall_support.h
   70|       |inline void* DirectMmap(void* start, size_t length, int prot, int flags, int fd,
   71|       |                        off64_t offset) noexcept {
   72|       |#if defined(__i386__) || defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) || \
   73|       |    (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \
   74|       |    (defined(__PPC__) && !defined(__PPC64__)) ||                             \
   75|       |    (defined(__s390__) && !defined(__s390x__))
   76|       |  // On these architectures, implement mmap with mmap2.
   77|       |  static int pagesize = 0;
   78|       |  if (pagesize == 0) {
   79|       |#if defined(__wasm__) || defined(__asmjs__)
   80|       |    pagesize = getpagesize();
   81|       |#else
   82|       |    pagesize = sysconf(_SC_PAGESIZE);
   83|       |#endif
   84|       |  }
   85|       |  if (offset < 0 || offset % pagesize != 0) {
   86|       |    errno = EINVAL;
   87|       |    return MAP_FAILED;
   88|       |  }
   89|       |#ifdef __BIONIC__
   90|       |  // SYS_mmap2 has problems on Android API level <= 16.
   91|       |  // Workaround by invoking __mmap2() instead.
   92|       |  return __mmap2(start, length, prot, flags, fd, offset / pagesize);
   93|       |#else
   94|       |  return reinterpret_cast<void*>(
   95|       |      syscall(SYS_mmap2, start, length, prot, flags, fd,
   96|       |              static_cast<off_t>(offset / pagesize)));
   97|       |#endif
   98|       |#elif defined(__s390x__)
   99|       |  // On s390x, mmap() arguments are passed in memory.
  100|       |  unsigned long buf[6] = {reinterpret_cast<unsigned long>(start),  // NOLINT
  101|       |                          static_cast<unsigned long>(length),      // NOLINT
  102|       |                          static_cast<unsigned long>(prot),        // NOLINT
  103|       |                          static_cast<unsigned long>(flags),       // NOLINT
  104|       |                          static_cast<unsigned long>(fd),          // NOLINT
  105|       |                          static_cast<unsigned long>(offset)};     // NOLINT
  106|       |  return reinterpret_cast<void*>(syscall(SYS_mmap, buf));
  107|       |#elif defined(__x86_64__)
  108|       |// The x32 ABI has 32 bit longs, but the syscall interface is 64 bit.
  109|       |// We need to explicitly cast to an unsigned 64 bit type to avoid implicit
  110|       |// sign extension.  We can't cast pointers directly because those are
  111|       |// 32 bits, and gcc will dump ugly warnings about casting from a pointer
  112|       |// to an integer of a different size. We also need to make sure __off64_t
  113|       |// isn't truncated to 32-bits under x32.
  114|       |#define MMAP_SYSCALL_ARG(x) ((uint64_t)(uintptr_t)(x))
  115|       |  return reinterpret_cast<void*>(
  116|       |      syscall(SYS_mmap, MMAP_SYSCALL_ARG(start), MMAP_SYSCALL_ARG(length),
  117|       |              MMAP_SYSCALL_ARG(prot), MMAP_SYSCALL_ARG(flags),
  118|       |              MMAP_SYSCALL_ARG(fd), static_cast<uint64_t>(offset)));
  119|       |#undef MMAP_SYSCALL_ARG
  120|       |#else  // Remaining 64-bit aritectures.
  121|       |  static_assert(sizeof(unsigned long) == 8, "Platform is not 64-bit");
  122|       |  return reinterpret_cast<void*>(
  123|       |      syscall(SYS_mmap, start, length, prot, flags, fd, offset));
  124|       |#endif
  125|       |}
  126|       |
  127|       |inline int DirectMunmap(void* start, size_t length) {
  128|       |  return static_cast<int>(syscall(SYS_munmap, start, length));
  129|       |}
  130|       |
  131|       |}  // namespace base_internal
  132|       |}  // inline namespace lts_2019_08_08
  133|       |}  // namespace absl
  134|       |
  135|       |#else  // !__linux__
  136|       |
  137|       |// For non-linux platforms where we have mmap, just dispatch directly to the
  138|       |// actual mmap()/munmap() methods.
  139|       |
  140|       |namespace absl {
  141|       |inline namespace lts_2019_08_08 {
  142|       |namespace base_internal {
  143|       |
  144|       |inline void* DirectMmap(void* start, size_t length, int prot, int flags, int fd,
  145|      0|                        off_t offset) {
  146|      0|  return mmap(start, length, prot, flags, fd, offset);
  147|      0|}
  148|       |
  149|      0|inline int DirectMunmap(void* start, size_t length) {
  150|      0|  return munmap(start, length);
  151|      0|}
  152|       |
  153|       |}  // namespace base_internal
  154|       |}  // inline namespace lts_2019_08_08
  155|       |}  // namespace absl
  156|       |
  157|       |#endif  // __linux__
  158|       |
  159|       |#endif  // ABSL_HAVE_MMAP
  160|       |
  161|       |#endif  // ABSL_BASE_INTERNAL_DIRECT_MMAP_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/endian.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |
   16|       |#ifndef ABSL_BASE_INTERNAL_ENDIAN_H_
   17|       |#define ABSL_BASE_INTERNAL_ENDIAN_H_
   18|       |
   19|       |// The following guarantees declaration of the byte swap functions
   20|       |#ifdef _MSC_VER
   21|       |#include <stdlib.h>  // NOLINT(build/include)
   22|       |#elif defined(__APPLE__)
   23|       |// macOS / Darwin features
   24|       |#include <libkern/OSByteOrder.h>
   25|       |#elif defined(__FreeBSD__)
   26|       |#include <sys/endian.h>
   27|       |#elif defined(__GLIBC__)
   28|       |#include <byteswap.h>  // IWYU pragma: export
   29|       |#endif
   30|       |
   31|       |#include <cstdint>
   32|       |#include "absl/base/config.h"
   33|       |#include "absl/base/internal/unaligned_access.h"
   34|       |#include "absl/base/port.h"
   35|       |
   36|       |namespace absl {
   37|       |inline namespace lts_2019_08_08 {
   38|       |
   39|       |// Use compiler byte-swapping intrinsics if they are available.  32-bit
   40|       |// and 64-bit versions are available in Clang and GCC as of GCC 4.3.0.
   41|       |// The 16-bit version is available in Clang and GCC only as of GCC 4.8.0.
   42|       |// For simplicity, we enable them all only for GCC 4.8.0 or later.
   43|       |#if defined(__clang__) || \
   44|       |    (defined(__GNUC__) && \
   45|       |     ((__GNUC__ == 4 && __GNUC_MINOR__ >= 8) || __GNUC__ >= 5))
   46|       |inline uint64_t gbswap_64(uint64_t host_int) {
   47|       |  return __builtin_bswap64(host_int);
   48|       |}
   49|      0|inline uint32_t gbswap_32(uint32_t host_int) {
   50|      0|  return __builtin_bswap32(host_int);
   51|      0|}
   52|      0|inline uint16_t gbswap_16(uint16_t host_int) {
   53|      0|  return __builtin_bswap16(host_int);
   54|      0|}
   55|       |
   56|       |#elif defined(_MSC_VER)
   57|       |inline uint64_t gbswap_64(uint64_t host_int) {
   58|       |  return _byteswap_uint64(host_int);
   59|       |}
   60|       |inline uint32_t gbswap_32(uint32_t host_int) {
   61|       |  return _byteswap_ulong(host_int);
   62|       |}
   63|       |inline uint16_t gbswap_16(uint16_t host_int) {
   64|       |  return _byteswap_ushort(host_int);
   65|       |}
   66|       |
   67|       |#elif defined(__APPLE__)
   68|       |inline uint64_t gbswap_64(uint64_t host_int) { return OSSwapInt16(host_int); }
   69|       |inline uint32_t gbswap_32(uint32_t host_int) { return OSSwapInt32(host_int); }
   70|       |inline uint16_t gbswap_16(uint16_t host_int) { return OSSwapInt64(host_int); }
   71|       |
   72|       |#else
   73|       |inline uint64_t gbswap_64(uint64_t host_int) {
   74|       |#if defined(__GNUC__) && defined(__x86_64__) && !defined(__APPLE__)
   75|       |  // Adapted from /usr/include/byteswap.h.  Not available on Mac.
   76|       |  if (__builtin_constant_p(host_int)) {
   77|       |    return __bswap_constant_64(host_int);
   78|       |  } else {
   79|       |    uint64_t result;
   80|       |    __asm__("bswap %0" : "=r"(result) : "0"(host_int));
   81|       |    return result;
   82|       |  }
   83|       |#elif defined(__GLIBC__)
   84|       |  return bswap_64(host_int);
   85|       |#else
   86|       |  return (((host_int & uint64_t{0xFF}) << 56) |
   87|       |          ((host_int & uint64_t{0xFF00}) << 40) |
   88|       |          ((host_int & uint64_t{0xFF0000}) << 24) |
   89|       |          ((host_int & uint64_t{0xFF000000}) << 8) |
   90|       |          ((host_int & uint64_t{0xFF00000000}) >> 8) |
   91|       |          ((host_int & uint64_t{0xFF0000000000}) >> 24) |
   92|       |          ((host_int & uint64_t{0xFF000000000000}) >> 40) |
   93|       |          ((host_int & uint64_t{0xFF00000000000000}) >> 56));
   94|       |#endif  // bswap_64
   95|       |}
   96|       |
   97|       |inline uint32_t gbswap_32(uint32_t host_int) {
   98|       |#if defined(__GLIBC__)
   99|       |  return bswap_32(host_int);
  100|       |#else
  101|       |  return (((host_int & uint32_t{0xFF}) << 24) |
  102|       |          ((host_int & uint32_t{0xFF00}) << 8) |
  103|       |          ((host_int & uint32_t{0xFF0000}) >> 8) |
  104|       |          ((host_int & uint32_t{0xFF000000}) >> 24));
  105|       |#endif
  106|       |}
  107|       |
  108|       |inline uint16_t gbswap_16(uint16_t host_int) {
  109|       |#if defined(__GLIBC__)
  110|       |  return bswap_16(host_int);
  111|       |#else
  112|       |  return (((host_int & uint16_t{0xFF}) << 8) |
  113|       |          ((host_int & uint16_t{0xFF00}) >> 8));
  114|       |#endif
  115|       |}
  116|       |
  117|       |#endif  // intrinics available
  118|       |
  119|       |#ifdef ABSL_IS_LITTLE_ENDIAN
  120|       |
  121|       |// Definitions for ntohl etc. that don't require us to include
  122|       |// netinet/in.h. We wrap gbswap_32 and gbswap_16 in functions rather
  123|       |// than just #defining them because in debug mode, gcc doesn't
  124|       |// correctly handle the (rather involved) definitions of bswap_32.
  125|       |// gcc guarantees that inline functions are as fast as macros, so
  126|       |// this isn't a performance hit.
  127|      0|inline uint16_t ghtons(uint16_t x) { return gbswap_16(x); }
  128|      0|inline uint32_t ghtonl(uint32_t x) { return gbswap_32(x); }
  129|       |inline uint64_t ghtonll(uint64_t x) { return gbswap_64(x); }
  130|       |
  131|       |#elif defined ABSL_IS_BIG_ENDIAN
  132|       |
  133|       |// These definitions are simpler on big-endian machines
  134|       |// These are functions instead of macros to avoid self-assignment warnings
  135|       |// on calls such as "i = ghtnol(i);".  This also provides type checking.
  136|       |inline uint16_t ghtons(uint16_t x) { return x; }
  137|       |inline uint32_t ghtonl(uint32_t x) { return x; }
  138|       |inline uint64_t ghtonll(uint64_t x) { return x; }
  139|       |
  140|       |#else
  141|       |#error \
  142|       |    "Unsupported byte order: Either ABSL_IS_BIG_ENDIAN or " \
  143|       |       "ABSL_IS_LITTLE_ENDIAN must be defined"
  144|       |#endif  // byte order
  145|       |
  146|      0|inline uint16_t gntohs(uint16_t x) { return ghtons(x); }
  147|      0|inline uint32_t gntohl(uint32_t x) { return ghtonl(x); }
  148|       |inline uint64_t gntohll(uint64_t x) { return ghtonll(x); }
  149|       |
  150|       |// Utilities to convert numbers between the current hosts's native byte
  151|       |// order and little-endian byte order
  152|       |//
  153|       |// Load/Store methods are alignment safe
  154|       |namespace little_endian {
  155|       |// Conversion functions.
  156|       |#ifdef ABSL_IS_LITTLE_ENDIAN
  157|       |
  158|      0|inline uint16_t FromHost16(uint16_t x) { return x; }
  159|      0|inline uint16_t ToHost16(uint16_t x) { return x; }
  160|       |
  161|      0|inline uint32_t FromHost32(uint32_t x) { return x; }
  162|      0|inline uint32_t ToHost32(uint32_t x) { return x; }
  163|       |
  164|      0|inline uint64_t FromHost64(uint64_t x) { return x; }
  165|      0|inline uint64_t ToHost64(uint64_t x) { return x; }
  166|       |
  167|      0|inline constexpr bool IsLittleEndian() { return true; }
  168|       |
  169|       |#elif defined ABSL_IS_BIG_ENDIAN
  170|       |
  171|       |inline uint16_t FromHost16(uint16_t x) { return gbswap_16(x); }
  172|       |inline uint16_t ToHost16(uint16_t x) { return gbswap_16(x); }
  173|       |
  174|       |inline uint32_t FromHost32(uint32_t x) { return gbswap_32(x); }
  175|       |inline uint32_t ToHost32(uint32_t x) { return gbswap_32(x); }
  176|       |
  177|       |inline uint64_t FromHost64(uint64_t x) { return gbswap_64(x); }
  178|       |inline uint64_t ToHost64(uint64_t x) { return gbswap_64(x); }
  179|       |
  180|       |inline constexpr bool IsLittleEndian() { return false; }
  181|       |
  182|       |#endif /* ENDIAN */
  183|       |
  184|       |// Functions to do unaligned loads and stores in little-endian order.
  185|      0|inline uint16_t Load16(const void *p) {
  186|      0|  return ToHost16(ABSL_INTERNAL_UNALIGNED_LOAD16(p));
  187|      0|}
  188|       |
  189|      0|inline void Store16(void *p, uint16_t v) {
  190|      0|  ABSL_INTERNAL_UNALIGNED_STORE16(p, FromHost16(v));
  191|      0|}
  192|       |
  193|      0|inline uint32_t Load32(const void *p) {
  194|      0|  return ToHost32(ABSL_INTERNAL_UNALIGNED_LOAD32(p));
  195|      0|}
  196|       |
  197|      0|inline void Store32(void *p, uint32_t v) {
  198|      0|  ABSL_INTERNAL_UNALIGNED_STORE32(p, FromHost32(v));
  199|      0|}
  200|       |
  201|      0|inline uint64_t Load64(const void *p) {
  202|      0|  return ToHost64(ABSL_INTERNAL_UNALIGNED_LOAD64(p));
  203|      0|}
  204|       |
  205|      0|inline void Store64(void *p, uint64_t v) {
  206|      0|  ABSL_INTERNAL_UNALIGNED_STORE64(p, FromHost64(v));
  207|      0|}
  208|       |
  209|       |}  // namespace little_endian
  210|       |
  211|       |// Utilities to convert numbers between the current hosts's native byte
  212|       |// order and big-endian byte order (same as network byte order)
  213|       |//
  214|       |// Load/Store methods are alignment safe
  215|       |namespace big_endian {
  216|       |#ifdef ABSL_IS_LITTLE_ENDIAN
  217|       |
  218|      0|inline uint16_t FromHost16(uint16_t x) { return gbswap_16(x); }
  219|      0|inline uint16_t ToHost16(uint16_t x) { return gbswap_16(x); }
  220|       |
  221|      0|inline uint32_t FromHost32(uint32_t x) { return gbswap_32(x); }
  222|      0|inline uint32_t ToHost32(uint32_t x) { return gbswap_32(x); }
  223|       |
  224|      0|inline uint64_t FromHost64(uint64_t x) { return gbswap_64(x); }
  225|      0|inline uint64_t ToHost64(uint64_t x) { return gbswap_64(x); }
  226|       |
  227|      0|inline constexpr bool IsLittleEndian() { return true; }
  228|       |
  229|       |#elif defined ABSL_IS_BIG_ENDIAN
  230|       |
  231|       |inline uint16_t FromHost16(uint16_t x) { return x; }
  232|       |inline uint16_t ToHost16(uint16_t x) { return x; }
  233|       |
  234|       |inline uint32_t FromHost32(uint32_t x) { return x; }
  235|       |inline uint32_t ToHost32(uint32_t x) { return x; }
  236|       |
  237|       |inline uint64_t FromHost64(uint64_t x) { return x; }
  238|       |inline uint64_t ToHost64(uint64_t x) { return x; }
  239|       |
  240|       |inline constexpr bool IsLittleEndian() { return false; }
  241|       |
  242|       |#endif /* ENDIAN */
  243|       |
  244|       |// Functions to do unaligned loads and stores in big-endian order.
  245|      0|inline uint16_t Load16(const void *p) {
  246|      0|  return ToHost16(ABSL_INTERNAL_UNALIGNED_LOAD16(p));
  247|      0|}
  248|       |
  249|      0|inline void Store16(void *p, uint16_t v) {
  250|      0|  ABSL_INTERNAL_UNALIGNED_STORE16(p, FromHost16(v));
  251|      0|}
  252|       |
  253|      0|inline uint32_t Load32(const void *p) {
  254|      0|  return ToHost32(ABSL_INTERNAL_UNALIGNED_LOAD32(p));
  255|      0|}
  256|       |
  257|      0|inline void Store32(void *p, uint32_t v) {
  258|      0|  ABSL_INTERNAL_UNALIGNED_STORE32(p, FromHost32(v));
  259|      0|}
  260|       |
  261|      0|inline uint64_t Load64(const void *p) {
  262|      0|  return ToHost64(ABSL_INTERNAL_UNALIGNED_LOAD64(p));
  263|      0|}
  264|       |
  265|      0|inline void Store64(void *p, uint64_t v) {
  266|      0|  ABSL_INTERNAL_UNALIGNED_STORE64(p, FromHost64(v));
  267|      0|}
  268|       |
  269|       |}  // namespace big_endian
  270|       |
  271|       |}  // inline namespace lts_2019_08_08
  272|       |}  // namespace absl
  273|       |
  274|       |#endif  // ABSL_BASE_INTERNAL_ENDIAN_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/invoke.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// absl::base_internal::Invoke(f, args...) is an implementation of
   16|       |// INVOKE(f, args...) from section [func.require] of the C++ standard.
   17|       |//
   18|       |// [func.require]
   19|       |// Define INVOKE (f, t1, t2, ..., tN) as follows:
   20|       |// 1. (t1.*f)(t2, ..., tN) when f is a pointer to a member function of a class T
   21|       |//    and t1 is an object of type T or a reference to an object of type T or a
   22|       |//    reference to an object of a type derived from T;
   23|       |// 2. ((*t1).*f)(t2, ..., tN) when f is a pointer to a member function of a
   24|       |//    class T and t1 is not one of the types described in the previous item;
   25|       |// 3. t1.*f when N == 1 and f is a pointer to member data of a class T and t1 is
   26|       |//    an object of type T or a reference to an object of type T or a reference
   27|       |//    to an object of a type derived from T;
   28|       |// 4. (*t1).*f when N == 1 and f is a pointer to member data of a class T and t1
   29|       |//    is not one of the types described in the previous item;
   30|       |// 5. f(t1, t2, ..., tN) in all other cases.
   31|       |//
   32|       |// The implementation is SFINAE-friendly: substitution failure within Invoke()
   33|       |// isn't an error.
   34|       |
   35|       |#ifndef ABSL_BASE_INTERNAL_INVOKE_H_
   36|       |#define ABSL_BASE_INTERNAL_INVOKE_H_
   37|       |
   38|       |#include <algorithm>
   39|       |#include <type_traits>
   40|       |#include <utility>
   41|       |
   42|       |#include "absl/meta/type_traits.h"
   43|       |
   44|       |// The following code is internal implementation detail.  See the comment at the
   45|       |// top of this file for the API documentation.
   46|       |
   47|       |namespace absl {
   48|       |inline namespace lts_2019_08_08 {
   49|       |namespace base_internal {
   50|       |
   51|       |// The five classes below each implement one of the clauses from the definition
   52|       |// of INVOKE. The inner class template Accept<F, Args...> checks whether the
   53|       |// clause is applicable; static function template Invoke(f, args...) does the
   54|       |// invocation.
   55|       |//
   56|       |// By separating the clause selection logic from invocation we make sure that
   57|       |// Invoke() does exactly what the standard says.
   58|       |
   59|       |template <typename Derived>
   60|       |struct StrippedAccept {
   61|       |  template <typename... Args>
   62|       |  struct Accept : Derived::template AcceptImpl<typename std::remove_cv<
   63|       |                      typename std::remove_reference<Args>::type>::type...> {};
   64|       |};
   65|       |
   66|       |// (t1.*f)(t2, ..., tN) when f is a pointer to a member function of a class T
   67|       |// and t1 is an object of type T or a reference to an object of type T or a
   68|       |// reference to an object of a type derived from T.
   69|       |struct MemFunAndRef : StrippedAccept<MemFunAndRef> {
   70|       |  template <typename... Args>
   71|       |  struct AcceptImpl : std::false_type {};
   72|       |
   73|       |  template <typename MemFunType, typename C, typename Obj, typename... Args>
   74|       |  struct AcceptImpl<MemFunType C::*, Obj, Args...>
   75|       |      : std::integral_constant<bool, std::is_base_of<C, Obj>::value &&
   76|       |                                         absl::is_function<MemFunType>::value> {
   77|       |  };
   78|       |
   79|       |  template <typename MemFun, typename Obj, typename... Args>
   80|       |  static decltype((std::declval<Obj>().*
   81|       |                   std::declval<MemFun>())(std::declval<Args>()...))
   82|       |  Invoke(MemFun&& mem_fun, Obj&& obj, Args&&... args) {
   83|       |    return (std::forward<Obj>(obj).*
   84|       |            std::forward<MemFun>(mem_fun))(std::forward<Args>(args)...);
   85|       |  }
   86|       |};
   87|       |
   88|       |// ((*t1).*f)(t2, ..., tN) when f is a pointer to a member function of a
   89|       |// class T and t1 is not one of the types described in the previous item.
   90|       |struct MemFunAndPtr : StrippedAccept<MemFunAndPtr> {
   91|       |  template <typename... Args>
   92|       |  struct AcceptImpl : std::false_type {};
   93|       |
   94|       |  template <typename MemFunType, typename C, typename Ptr, typename... Args>
   95|       |  struct AcceptImpl<MemFunType C::*, Ptr, Args...>
   96|       |      : std::integral_constant<bool, !std::is_base_of<C, Ptr>::value &&
   97|       |                                         absl::is_function<MemFunType>::value> {
   98|       |  };
   99|       |
  100|       |  template <typename MemFun, typename Ptr, typename... Args>
  101|       |  static decltype(((*std::declval<Ptr>()).*
  102|       |                   std::declval<MemFun>())(std::declval<Args>()...))
  103|       |  Invoke(MemFun&& mem_fun, Ptr&& ptr, Args&&... args) {
  104|       |    return ((*std::forward<Ptr>(ptr)).*
  105|       |            std::forward<MemFun>(mem_fun))(std::forward<Args>(args)...);
  106|       |  }
  107|       |};
  108|       |
  109|       |// t1.*f when N == 1 and f is a pointer to member data of a class T and t1 is
  110|       |// an object of type T or a reference to an object of type T or a reference
  111|       |// to an object of a type derived from T.
  112|       |struct DataMemAndRef : StrippedAccept<DataMemAndRef> {
  113|       |  template <typename... Args>
  114|       |  struct AcceptImpl : std::false_type {};
  115|       |
  116|       |  template <typename R, typename C, typename Obj>
  117|       |  struct AcceptImpl<R C::*, Obj>
  118|       |      : std::integral_constant<bool, std::is_base_of<C, Obj>::value &&
  119|       |                                         !absl::is_function<R>::value> {};
  120|       |
  121|       |  template <typename DataMem, typename Ref>
  122|       |  static decltype(std::declval<Ref>().*std::declval<DataMem>()) Invoke(
  123|       |      DataMem&& data_mem, Ref&& ref) {
  124|       |    return std::forward<Ref>(ref).*std::forward<DataMem>(data_mem);
  125|       |  }
  126|       |};
  127|       |
  128|       |// (*t1).*f when N == 1 and f is a pointer to member data of a class T and t1
  129|       |// is not one of the types described in the previous item.
  130|       |struct DataMemAndPtr : StrippedAccept<DataMemAndPtr> {
  131|       |  template <typename... Args>
  132|       |  struct AcceptImpl : std::false_type {};
  133|       |
  134|       |  template <typename R, typename C, typename Ptr>
  135|       |  struct AcceptImpl<R C::*, Ptr>
  136|       |      : std::integral_constant<bool, !std::is_base_of<C, Ptr>::value &&
  137|       |                                         !absl::is_function<R>::value> {};
  138|       |
  139|       |  template <typename DataMem, typename Ptr>
  140|       |  static decltype((*std::declval<Ptr>()).*std::declval<DataMem>()) Invoke(
  141|       |      DataMem&& data_mem, Ptr&& ptr) {
  142|       |    return (*std::forward<Ptr>(ptr)).*std::forward<DataMem>(data_mem);
  143|       |  }
  144|       |};
  145|       |
  146|       |// f(t1, t2, ..., tN) in all other cases.
  147|       |struct Callable {
  148|       |  // Callable doesn't have Accept because it's the last clause that gets picked
  149|       |  // when none of the previous clauses are applicable.
  150|       |  template <typename F, typename... Args>
  151|       |  static decltype(std::declval<F>()(std::declval<Args>()...)) Invoke(
  152|      0|      F&& f, Args&&... args) {
  153|      0|    return std::forward<F>(f)(std::forward<Args>(args)...);
  154|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal8Callable6InvokeIRFvvEJEEEDTclclsr3stdE7declvalIT_EEspclsr3stdE7declvalIT0_EEEEOS6_DpOS7_
  ------------------
  | Unexecuted instantiation: spinlock.cc:_ZN4absl14lts_2019_08_0813base_internal8Callable6InvokeIZNS1_8SpinLock8SpinLoopEvE3$_0JEEEDTclclsr3stdE7declvalIT_EEspclsr3stdE7declvalIT0_EEEEOS6_DpOS7_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal8Callable6InvokeIRFvPFvPvEEJRS6_EEEDTclclsr3stdE7declvalIT_EEspclsr3stdE7declvalIT0_EEEEOSA_DpOSB_
  ------------------
  155|       |};
  156|       |
  157|       |// Resolves to the first matching clause.
  158|       |template <typename... Args>
  159|       |struct Invoker {
  160|       |  typedef typename std::conditional<
  161|       |      MemFunAndRef::Accept<Args...>::value, MemFunAndRef,
  162|       |      typename std::conditional<
  163|       |          MemFunAndPtr::Accept<Args...>::value, MemFunAndPtr,
  164|       |          typename std::conditional<
  165|       |              DataMemAndRef::Accept<Args...>::value, DataMemAndRef,
  166|       |              typename std::conditional<DataMemAndPtr::Accept<Args...>::value,
  167|       |                                        DataMemAndPtr, Callable>::type>::type>::
  168|       |          type>::type type;
  169|       |};
  170|       |
  171|       |// The result type of Invoke<F, Args...>.
  172|       |template <typename F, typename... Args>
  173|       |using InvokeT = decltype(Invoker<F, Args...>::type::Invoke(
  174|       |    std::declval<F>(), std::declval<Args>()...));
  175|       |
  176|       |// Invoke(f, args...) is an implementation of INVOKE(f, args...) from section
  177|       |// [func.require] of the C++ standard.
  178|       |template <typename F, typename... Args>
  179|      0|InvokeT<F, Args...> Invoke(F&& f, Args&&... args) {
  180|      0|  return Invoker<F, Args...>::type::Invoke(std::forward<F>(f),
  181|      0|                                           std::forward<Args>(args)...);
  182|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal6InvokeIRFvvEJEEEDTclsr7InvokerIT_DpT0_E4typeE6Invokeclsr3stdE7declvalIS5_EEspclsr3stdE7declvalIS6_EEEEOS5_DpOS6_
  ------------------
  | Unexecuted instantiation: spinlock.cc:_ZN4absl14lts_2019_08_0813base_internal6InvokeIZNS1_8SpinLock8SpinLoopEvE3$_0JEEEDTclsr7InvokerIT_DpT0_E4typeE6Invokeclsr3stdE7declvalIS5_EEspclsr3stdE7declvalIS6_EEEEOS5_DpOS6_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813base_internal6InvokeIRFvPFvPvEEJRS5_EEEDTclsr7InvokerIT_DpT0_E4typeE6Invokeclsr3stdE7declvalIS9_EEspclsr3stdE7declvalISA_EEEEOS9_DpOSA_
  ------------------
  183|       |}  // namespace base_internal
  184|       |}  // inline namespace lts_2019_08_08
  185|       |}  // namespace absl
  186|       |
  187|       |#endif  // ABSL_BASE_INTERNAL_INVOKE_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/low_level_alloc.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |// A low-level allocator that can be used by other low-level
   16|       |// modules without introducing dependency cycles.
   17|       |// This allocator is slow and wasteful of memory;
   18|       |// it should not be used when performance is key.
   19|       |
   20|       |#include "absl/base/internal/low_level_alloc.h"
   21|       |
   22|       |#include <type_traits>
   23|       |
   24|       |#include "absl/base/call_once.h"
   25|       |#include "absl/base/config.h"
   26|       |#include "absl/base/internal/direct_mmap.h"
   27|       |#include "absl/base/internal/scheduling_mode.h"
   28|       |#include "absl/base/macros.h"
   29|       |#include "absl/base/thread_annotations.h"
   30|       |
   31|       |// LowLevelAlloc requires that the platform support low-level
   32|       |// allocation of virtual memory. Platforms lacking this cannot use
   33|       |// LowLevelAlloc.
   34|       |#ifndef ABSL_LOW_LEVEL_ALLOC_MISSING
   35|       |
   36|       |#ifndef _WIN32
   37|       |#include <pthread.h>
   38|       |#include <signal.h>
   39|       |#include <sys/mman.h>
   40|       |#include <unistd.h>
   41|       |#else
   42|       |#include <windows.h>
   43|       |#endif
   44|       |
   45|       |#include <string.h>
   46|       |#include <algorithm>
   47|       |#include <atomic>
   48|       |#include <cerrno>
   49|       |#include <cstddef>
   50|       |#include <new>                   // for placement-new
   51|       |
   52|       |#include "absl/base/dynamic_annotations.h"
   53|       |#include "absl/base/internal/raw_logging.h"
   54|       |#include "absl/base/internal/spinlock.h"
   55|       |
   56|       |// MAP_ANONYMOUS
   57|       |#if defined(__APPLE__)
   58|       |// For mmap, Linux defines both MAP_ANONYMOUS and MAP_ANON and says MAP_ANON is
   59|       |// deprecated. In Darwin, MAP_ANON is all there is.
   60|       |#if !defined MAP_ANONYMOUS
   61|       |#define MAP_ANONYMOUS MAP_ANON
   62|       |#endif  // !MAP_ANONYMOUS
   63|       |#endif  // __APPLE__
   64|       |
   65|       |namespace absl {
   66|       |inline namespace lts_2019_08_08 {
   67|       |namespace base_internal {
   68|       |
   69|       |// A first-fit allocator with amortized logarithmic free() time.
   70|       |
   71|       |// ---------------------------------------------------------------------------
   72|       |static const int kMaxLevel = 30;
   73|       |
   74|       |namespace {
   75|       |// This struct describes one allocated block, or one free block.
   76|       |struct AllocList {
   77|       |  struct Header {
   78|       |    // Size of entire region, including this field. Must be
   79|       |    // first. Valid in both allocated and unallocated blocks.
   80|       |    uintptr_t size;
   81|       |
   82|       |    // kMagicAllocated or kMagicUnallocated xor this.
   83|       |    uintptr_t magic;
   84|       |
   85|       |    // Pointer to parent arena.
   86|       |    LowLevelAlloc::Arena *arena;
   87|       |
   88|       |    // Aligns regions to 0 mod 2*sizeof(void*).
   89|       |    void *dummy_for_alignment;
   90|       |  } header;
   91|       |
   92|       |  // Next two fields: in unallocated blocks: freelist skiplist data
   93|       |  //                  in allocated blocks: overlaps with client data
   94|       |
   95|       |  // Levels in skiplist used.
   96|       |  int levels;
   97|       |
   98|       |  // Actually has levels elements. The AllocList node may not have room
   99|       |  // for all kMaxLevel entries. See max_fit in LLA_SkiplistLevels().
  100|       |  AllocList *next[kMaxLevel];
  101|       |};
  102|       |}  // namespace
  103|       |
  104|       |// ---------------------------------------------------------------------------
  105|       |// A trivial skiplist implementation.  This is used to keep the freelist
  106|       |// in address order while taking only logarithmic time per insert and delete.
  107|       |
  108|       |// An integer approximation of log2(size/base)
  109|       |// Requires size >= base.
  110|      0|static int IntLog2(size_t size, size_t base) {
  111|      0|  int result = 0;
  112|      0|  for (size_t i = size; i > base; i >>= 1) {  // i == floor(size/2**result)
  113|      0|    result++;
  114|      0|  }
  115|      0|  //    floor(size / 2**result) <= base < floor(size / 2**(result-1))
  116|      0|  // =>     log2(size/(base+1)) <= result < 1+log2(size/base)
  117|      0|  // => result ~= log2(size/base)
  118|      0|  return result;
  119|      0|}
  120|       |
  121|       |// Return a random integer n:  p(n)=1/(2**n) if 1 <= n; p(n)=0 if n < 1.
  122|      0|static int Random(uint32_t *state) {
  123|      0|  uint32_t r = *state;
  124|      0|  int result = 1;
  125|      0|  while ((((r = r*1103515245 + 12345) >> 30) & 1) == 0) {
  126|      0|    result++;
  127|      0|  }
  128|      0|  *state = r;
  129|      0|  return result;
  130|      0|}
  131|       |
  132|       |// Return a number of skiplist levels for a node of size bytes, where
  133|       |// base is the minimum node size.  Compute level=log2(size / base)+n
  134|       |// where n is 1 if random is false and otherwise a random number generated with
  135|       |// the standard distribution for a skiplist:  See Random() above.
  136|       |// Bigger nodes tend to have more skiplist levels due to the log2(size / base)
  137|       |// term, so first-fit searches touch fewer nodes.  "level" is clipped so
  138|       |// level<kMaxLevel and next[level-1] will fit in the node.
  139|       |// 0 < LLA_SkiplistLevels(x,y,false) <= LLA_SkiplistLevels(x,y,true) < kMaxLevel
  140|      0|static int LLA_SkiplistLevels(size_t size, size_t base, uint32_t *random) {
  141|      0|  // max_fit is the maximum number of levels that will fit in a node for the
  142|      0|  // given size.   We can't return more than max_fit, no matter what the
  143|      0|  // random number generator says.
  144|      0|  size_t max_fit = (size - offsetof(AllocList, next)) / sizeof(AllocList *);
  145|      0|  int level = IntLog2(size, base) + (random != nullptr ? Random(random) : 1);
  146|      0|  if (static_cast<size_t>(level) > max_fit) level = static_cast<int>(max_fit);
  147|      0|  if (level > kMaxLevel-1) level = kMaxLevel - 1;
  148|      0|  ABSL_RAW_CHECK(level >= 1, "block not big enough for even one level");
  149|      0|  return level;
  150|      0|}
  151|       |
  152|       |// Return "atleast", the first element of AllocList *head s.t. *atleast >= *e.
  153|       |// For 0 <= i < head->levels, set prev[i] to "no_greater", where no_greater
  154|       |// points to the last element at level i in the AllocList less than *e, or is
  155|       |// head if no such element exists.
  156|       |static AllocList *LLA_SkiplistSearch(AllocList *head,
  157|      0|                                     AllocList *e, AllocList **prev) {
  158|      0|  AllocList *p = head;
  159|      0|  for (int level = head->levels - 1; level >= 0; level--) {
  160|      0|    for (AllocList *n; (n = p->next[level]) != nullptr && n < e; p = n) {
  161|      0|    }
  162|      0|    prev[level] = p;
  163|      0|  }
  164|      0|  return (head->levels == 0) ? nullptr : prev[0]->next[0];
  165|      0|}
  166|       |
  167|       |// Insert element *e into AllocList *head.  Set prev[] as LLA_SkiplistSearch.
  168|       |// Requires that e->levels be previously set by the caller (using
  169|       |// LLA_SkiplistLevels())
  170|       |static void LLA_SkiplistInsert(AllocList *head, AllocList *e,
  171|      0|                               AllocList **prev) {
  172|      0|  LLA_SkiplistSearch(head, e, prev);
  173|      0|  for (; head->levels < e->levels; head->levels++) {  // extend prev pointers
  174|      0|    prev[head->levels] = head;                        // to all *e's levels
  175|      0|  }
  176|      0|  for (int i = 0; i != e->levels; i++) {  // add element to list
  177|      0|    e->next[i] = prev[i]->next[i];
  178|      0|    prev[i]->next[i] = e;
  179|      0|  }
  180|      0|}
  181|       |
  182|       |// Remove element *e from AllocList *head.  Set prev[] as LLA_SkiplistSearch().
  183|       |// Requires that e->levels be previous set by the caller (using
  184|       |// LLA_SkiplistLevels())
  185|       |static void LLA_SkiplistDelete(AllocList *head, AllocList *e,
  186|      0|                               AllocList **prev) {
  187|      0|  AllocList *found = LLA_SkiplistSearch(head, e, prev);
  188|      0|  ABSL_RAW_CHECK(e == found, "element not in freelist");
  189|      0|  for (int i = 0; i != e->levels && prev[i]->next[i] == e; i++) {
  190|      0|    prev[i]->next[i] = e->next[i];
  191|      0|  }
  192|      0|  while (head->levels > 0 && head->next[head->levels - 1] == nullptr) {
  193|      0|    head->levels--;   // reduce head->levels if level unused
  194|      0|  }
  195|      0|}
  196|       |
  197|       |// ---------------------------------------------------------------------------
  198|       |// Arena implementation
  199|       |
  200|       |// Metadata for an LowLevelAlloc arena instance.
  201|       |struct LowLevelAlloc::Arena {
  202|       |  // Constructs an arena with the given LowLevelAlloc flags.
  203|       |  explicit Arena(uint32_t flags_value);
  204|       |
  205|       |  base_internal::SpinLock mu;
  206|       |  // Head of free list, sorted by address
  207|       |  AllocList freelist GUARDED_BY(mu);
  208|       |  // Count of allocated blocks
  209|       |  int32_t allocation_count GUARDED_BY(mu);
  210|       |  // flags passed to NewArena
  211|       |  const uint32_t flags;
  212|       |  // Result of sysconf(_SC_PAGESIZE)
  213|       |  const size_t pagesize;
  214|       |  // Lowest power of two >= max(16, sizeof(AllocList))
  215|       |  const size_t roundup;
  216|       |  // Smallest allocation block size
  217|       |  const size_t min_size;
  218|       |  // PRNG state
  219|       |  uint32_t random GUARDED_BY(mu);
  220|       |};
  221|       |
  222|       |namespace {
  223|       |using ArenaStorage = std::aligned_storage<sizeof(LowLevelAlloc::Arena),
  224|       |                                          alignof(LowLevelAlloc::Arena)>::type;
  225|       |
  226|       |// Static storage space for the lazily-constructed, default global arena
  227|       |// instances.  We require this space because the whole point of LowLevelAlloc
  228|       |// is to avoid relying on malloc/new.
  229|       |ArenaStorage default_arena_storage;
  230|       |ArenaStorage unhooked_arena_storage;
  231|       |#ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  232|       |ArenaStorage unhooked_async_sig_safe_arena_storage;
  233|       |#endif
  234|       |
  235|       |// We must use LowLevelCallOnce here to construct the global arenas, rather than
  236|       |// using function-level statics, to avoid recursively invoking the scheduler.
  237|       |absl::once_flag create_globals_once;
  238|       |
  239|      0|void CreateGlobalArenas() {
  240|      0|  new (&default_arena_storage)
  241|      0|      LowLevelAlloc::Arena(LowLevelAlloc::kCallMallocHook);
  242|      0|  new (&unhooked_arena_storage) LowLevelAlloc::Arena(0);
  243|      0|#ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  244|      0|  new (&unhooked_async_sig_safe_arena_storage)
  245|      0|      LowLevelAlloc::Arena(LowLevelAlloc::kAsyncSignalSafe);
  246|      0|#endif
  247|      0|}
  248|       |
  249|       |// Returns a global arena that does not call into hooks.  Used by NewArena()
  250|       |// when kCallMallocHook is not set.
  251|      0|LowLevelAlloc::Arena* UnhookedArena() {
  252|      0|  base_internal::LowLevelCallOnce(&create_globals_once, CreateGlobalArenas);
  253|      0|  return reinterpret_cast<LowLevelAlloc::Arena*>(&unhooked_arena_storage);
  254|      0|}
  255|       |
  256|       |#ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  257|       |// Returns a global arena that is async-signal safe.  Used by NewArena() when
  258|       |// kAsyncSignalSafe is set.
  259|      0|LowLevelAlloc::Arena *UnhookedAsyncSigSafeArena() {
  260|      0|  base_internal::LowLevelCallOnce(&create_globals_once, CreateGlobalArenas);
  261|      0|  return reinterpret_cast<LowLevelAlloc::Arena *>(
  262|      0|      &unhooked_async_sig_safe_arena_storage);
  263|      0|}
  264|       |#endif
  265|       |
  266|       |}  // namespace
  267|       |
  268|       |// Returns the default arena, as used by LowLevelAlloc::Alloc() and friends.
  269|      0|LowLevelAlloc::Arena *LowLevelAlloc::DefaultArena() {
  270|      0|  base_internal::LowLevelCallOnce(&create_globals_once, CreateGlobalArenas);
  271|      0|  return reinterpret_cast<LowLevelAlloc::Arena*>(&default_arena_storage);
  272|      0|}
  273|       |
  274|       |// magic numbers to identify allocated and unallocated blocks
  275|       |static const uintptr_t kMagicAllocated = 0x4c833e95U;
  276|       |static const uintptr_t kMagicUnallocated = ~kMagicAllocated;
  277|       |
  278|       |namespace {
  279|       |class SCOPED_LOCKABLE ArenaLock {
  280|       | public:
  281|       |  explicit ArenaLock(LowLevelAlloc::Arena *arena)
  282|       |      EXCLUSIVE_LOCK_FUNCTION(arena->mu)
  283|      0|      : arena_(arena) {
  284|      0|#ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  285|      0|    if ((arena->flags & LowLevelAlloc::kAsyncSignalSafe) != 0) {
  286|      0|      sigset_t all;
  287|      0|      sigfillset(&all);
  288|      0|      mask_valid_ = pthread_sigmask(SIG_BLOCK, &all, &mask_) == 0;
  289|      0|    }
  290|      0|#endif
  291|      0|    arena_->mu.Lock();
  292|      0|  }
  293|      0|  ~ArenaLock() { ABSL_RAW_CHECK(left_, "haven't left Arena region"); }
  294|      0|  void Leave() UNLOCK_FUNCTION() {
  295|      0|    arena_->mu.Unlock();
  296|      0|#ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  297|      0|    if (mask_valid_) {
  298|      0|      const int err = pthread_sigmask(SIG_SETMASK, &mask_, nullptr);
  299|      0|      if (err != 0) {
  300|      0|        ABSL_RAW_LOG(FATAL, "pthread_sigmask failed: %d", err);
  301|      0|      }
  302|      0|    }
  303|      0|#endif
  304|      0|    left_ = true;
  305|      0|  }
  306|       |
  307|       | private:
  308|       |  bool left_ = false;  // whether left region
  309|       |#ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  310|       |  bool mask_valid_ = false;
  311|       |  sigset_t mask_;  // old mask of blocked signals
  312|       |#endif
  313|       |  LowLevelAlloc::Arena *arena_;
  314|       |  ArenaLock(const ArenaLock &) = delete;
  315|       |  ArenaLock &operator=(const ArenaLock &) = delete;
  316|       |};
  317|       |}  // namespace
  318|       |
  319|       |// create an appropriate magic number for an object at "ptr"
  320|       |// "magic" should be kMagicAllocated or kMagicUnallocated
  321|      0|inline static uintptr_t Magic(uintptr_t magic, AllocList::Header *ptr) {
  322|      0|  return magic ^ reinterpret_cast<uintptr_t>(ptr);
  323|      0|}
  324|       |
  325|       |namespace {
  326|      0|size_t GetPageSize() {
  327|       |#ifdef _WIN32
  328|       |  SYSTEM_INFO system_info;
  329|       |  GetSystemInfo(&system_info);
  330|       |  return std::max(system_info.dwPageSize, system_info.dwAllocationGranularity);
  331|       |#elif defined(__wasm__) || defined(__asmjs__)
  332|       |  return getpagesize();
  333|       |#else
  334|       |  return sysconf(_SC_PAGESIZE);
  335|      0|#endif
  336|      0|}
  337|       |
  338|      0|size_t RoundedUpBlockSize() {
  339|      0|  // Round up block sizes to a power of two close to the header size.
  340|      0|  size_t roundup = 16;
  341|      0|  while (roundup < sizeof(AllocList::Header)) {
  342|      0|    roundup += roundup;
  343|      0|  }
  344|      0|  return roundup;
  345|      0|}
  346|       |
  347|       |}  // namespace
  348|       |
  349|       |LowLevelAlloc::Arena::Arena(uint32_t flags_value)
  350|       |    : mu(base_internal::SCHEDULE_KERNEL_ONLY),
  351|       |      allocation_count(0),
  352|       |      flags(flags_value),
  353|       |      pagesize(GetPageSize()),
  354|       |      roundup(RoundedUpBlockSize()),
  355|       |      min_size(2 * roundup),
  356|      0|      random(0) {
  357|      0|  freelist.header.size = 0;
  358|      0|  freelist.header.magic =
  359|      0|      Magic(kMagicUnallocated, &freelist.header);
  360|      0|  freelist.header.arena = this;
  361|      0|  freelist.levels = 0;
  362|      0|  memset(freelist.next, 0, sizeof(freelist.next));
  363|      0|}
  364|       |
  365|       |// L < meta_data_arena->mu
  366|      0|LowLevelAlloc::Arena *LowLevelAlloc::NewArena(int32_t flags) {
  367|      0|  Arena *meta_data_arena = DefaultArena();
  368|      0|#ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  369|      0|  if ((flags & LowLevelAlloc::kAsyncSignalSafe) != 0) {
  370|      0|    meta_data_arena = UnhookedAsyncSigSafeArena();
  371|      0|  } else  // NOLINT(readability/braces)
  372|      0|#endif
  373|      0|      if ((flags & LowLevelAlloc::kCallMallocHook) == 0) {
  374|      0|    meta_data_arena = UnhookedArena();
  375|      0|  }
  376|      0|  Arena *result =
  377|      0|    new (AllocWithArena(sizeof (*result), meta_data_arena)) Arena(flags);
  378|      0|  return result;
  379|      0|}
  380|       |
  381|       |// L < arena->mu, L < arena->arena->mu
  382|      0|bool LowLevelAlloc::DeleteArena(Arena *arena) {
  383|      0|  ABSL_RAW_CHECK(
  384|      0|      arena != nullptr && arena != DefaultArena() && arena != UnhookedArena(),
  385|      0|      "may not delete default arena");
  386|      0|  ArenaLock section(arena);
  387|      0|  if (arena->allocation_count != 0) {
  388|      0|    section.Leave();
  389|      0|    return false;
  390|      0|  }
  391|      0|  while (arena->freelist.next[0] != nullptr) {
  392|      0|    AllocList *region = arena->freelist.next[0];
  393|      0|    size_t size = region->header.size;
  394|      0|    arena->freelist.next[0] = region->next[0];
  395|      0|    ABSL_RAW_CHECK(
  396|      0|        region->header.magic == Magic(kMagicUnallocated, &region->header),
  397|      0|        "bad magic number in DeleteArena()");
  398|      0|    ABSL_RAW_CHECK(region->header.arena == arena,
  399|      0|                   "bad arena pointer in DeleteArena()");
  400|      0|    ABSL_RAW_CHECK(size % arena->pagesize == 0,
  401|      0|                   "empty arena has non-page-aligned block size");
  402|      0|    ABSL_RAW_CHECK(reinterpret_cast<uintptr_t>(region) % arena->pagesize == 0,
  403|      0|                   "empty arena has non-page-aligned block");
  404|      0|    int munmap_result;
  405|       |#ifdef _WIN32
  406|       |    munmap_result = VirtualFree(region, 0, MEM_RELEASE);
  407|       |    ABSL_RAW_CHECK(munmap_result != 0,
  408|       |                   "LowLevelAlloc::DeleteArena: VitualFree failed");
  409|       |#else
  410|       |#ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  411|      0|    if ((arena->flags & LowLevelAlloc::kAsyncSignalSafe) == 0) {
  412|      0|      munmap_result = munmap(region, size);
  413|      0|    } else {
  414|      0|      munmap_result = base_internal::DirectMunmap(region, size);
  415|      0|    }
  416|       |#else
  417|       |    munmap_result = munmap(region, size);
  418|       |#endif  // ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  419|      0|    if (munmap_result != 0) {
  420|      0|      ABSL_RAW_LOG(FATAL, "LowLevelAlloc::DeleteArena: munmap failed: %d",
  421|      0|                   errno);
  422|      0|    }
  423|      0|#endif  // _WIN32
  424|      0|  }
  425|      0|  section.Leave();
  426|      0|  arena->~Arena();
  427|      0|  Free(arena);
  428|      0|  return true;
  429|      0|}
  430|       |
  431|       |// ---------------------------------------------------------------------------
  432|       |
  433|       |// Addition, checking for overflow.  The intent is to die if an external client
  434|       |// manages to push through a request that would cause arithmetic to fail.
  435|      0|static inline uintptr_t CheckedAdd(uintptr_t a, uintptr_t b) {
  436|      0|  uintptr_t sum = a + b;
  437|      0|  ABSL_RAW_CHECK(sum >= a, "LowLevelAlloc arithmetic overflow");
  438|      0|  return sum;
  439|      0|}
  440|       |
  441|       |// Return value rounded up to next multiple of align.
  442|       |// align must be a power of two.
  443|      0|static inline uintptr_t RoundUp(uintptr_t addr, uintptr_t align) {
  444|      0|  return CheckedAdd(addr, align - 1) & ~(align - 1);
  445|      0|}
  446|       |
  447|       |// Equivalent to "return prev->next[i]" but with sanity checking
  448|       |// that the freelist is in the correct order, that it
  449|       |// consists of regions marked "unallocated", and that no two regions
  450|       |// are adjacent in memory (they should have been coalesced).
  451|       |// L < arena->mu
  452|      0|static AllocList *Next(int i, AllocList *prev, LowLevelAlloc::Arena *arena) {
  453|      0|  ABSL_RAW_CHECK(i < prev->levels, "too few levels in Next()");
  454|      0|  AllocList *next = prev->next[i];
  455|      0|  if (next != nullptr) {
  456|      0|    ABSL_RAW_CHECK(
  457|      0|        next->header.magic == Magic(kMagicUnallocated, &next->header),
  458|      0|        "bad magic number in Next()");
  459|      0|    ABSL_RAW_CHECK(next->header.arena == arena, "bad arena pointer in Next()");
  460|      0|    if (prev != &arena->freelist) {
  461|      0|      ABSL_RAW_CHECK(prev < next, "unordered freelist");
  462|      0|      ABSL_RAW_CHECK(reinterpret_cast<char *>(prev) + prev->header.size <
  463|      0|                         reinterpret_cast<char *>(next),
  464|      0|                     "malformed freelist");
  465|      0|    }
  466|      0|  }
  467|      0|  return next;
  468|      0|}
  469|       |
  470|       |// Coalesce list item "a" with its successor if they are adjacent.
  471|      0|static void Coalesce(AllocList *a) {
  472|      0|  AllocList *n = a->next[0];
  473|      0|  if (n != nullptr && reinterpret_cast<char *>(a) + a->header.size ==
  474|      0|                          reinterpret_cast<char *>(n)) {
  475|      0|    LowLevelAlloc::Arena *arena = a->header.arena;
  476|      0|    a->header.size += n->header.size;
  477|      0|    n->header.magic = 0;
  478|      0|    n->header.arena = nullptr;
  479|      0|    AllocList *prev[kMaxLevel];
  480|      0|    LLA_SkiplistDelete(&arena->freelist, n, prev);
  481|      0|    LLA_SkiplistDelete(&arena->freelist, a, prev);
  482|      0|    a->levels = LLA_SkiplistLevels(a->header.size, arena->min_size,
  483|      0|                                   &arena->random);
  484|      0|    LLA_SkiplistInsert(&arena->freelist, a, prev);
  485|      0|  }
  486|      0|}
  487|       |
  488|       |// Adds block at location "v" to the free list
  489|       |// L >= arena->mu
  490|      0|static void AddToFreelist(void *v, LowLevelAlloc::Arena *arena) {
  491|      0|  AllocList *f = reinterpret_cast<AllocList *>(
  492|      0|                        reinterpret_cast<char *>(v) - sizeof (f->header));
  493|      0|  ABSL_RAW_CHECK(f->header.magic == Magic(kMagicAllocated, &f->header),
  494|      0|                 "bad magic number in AddToFreelist()");
  495|      0|  ABSL_RAW_CHECK(f->header.arena == arena,
  496|      0|                 "bad arena pointer in AddToFreelist()");
  497|      0|  f->levels = LLA_SkiplistLevels(f->header.size, arena->min_size,
  498|      0|                                 &arena->random);
  499|      0|  AllocList *prev[kMaxLevel];
  500|      0|  LLA_SkiplistInsert(&arena->freelist, f, prev);
  501|      0|  f->header.magic = Magic(kMagicUnallocated, &f->header);
  502|      0|  Coalesce(f);                  // maybe coalesce with successor
  503|      0|  Coalesce(prev[0]);            // maybe coalesce with predecessor
  504|      0|}
  505|       |
  506|       |// Frees storage allocated by LowLevelAlloc::Alloc().
  507|       |// L < arena->mu
  508|      0|void LowLevelAlloc::Free(void *v) {
  509|      0|  if (v != nullptr) {
  510|      0|    AllocList *f = reinterpret_cast<AllocList *>(
  511|      0|                        reinterpret_cast<char *>(v) - sizeof (f->header));
  512|      0|    ABSL_RAW_CHECK(f->header.magic == Magic(kMagicAllocated, &f->header),
  513|      0|                   "bad magic number in Free()");
  514|      0|    LowLevelAlloc::Arena *arena = f->header.arena;
  515|      0|    ArenaLock section(arena);
  516|      0|    AddToFreelist(v, arena);
  517|      0|    ABSL_RAW_CHECK(arena->allocation_count > 0, "nothing in arena to free");
  518|      0|    arena->allocation_count--;
  519|      0|    section.Leave();
  520|      0|  }
  521|      0|}
  522|       |
  523|       |// allocates and returns a block of size bytes, to be freed with Free()
  524|       |// L < arena->mu
  525|      0|static void *DoAllocWithArena(size_t request, LowLevelAlloc::Arena *arena) {
  526|      0|  void *result = nullptr;
  527|      0|  if (request != 0) {
  528|      0|    AllocList *s;       // will point to region that satisfies request
  529|      0|    ArenaLock section(arena);
  530|      0|    // round up with header
  531|      0|    size_t req_rnd = RoundUp(CheckedAdd(request, sizeof (s->header)),
  532|      0|                             arena->roundup);
  533|      0|    for (;;) {      // loop until we find a suitable region
  534|      0|      // find the minimum levels that a block of this size must have
  535|      0|      int i = LLA_SkiplistLevels(req_rnd, arena->min_size, nullptr) - 1;
  536|      0|      if (i < arena->freelist.levels) {   // potential blocks exist
  537|      0|        AllocList *before = &arena->freelist;  // predecessor of s
  538|      0|        while ((s = Next(i, before, arena)) != nullptr &&
  539|      0|               s->header.size < req_rnd) {
  540|      0|          before = s;
  541|      0|        }
  542|      0|        if (s != nullptr) {       // we found a region
  543|      0|          break;
  544|      0|        }
  545|      0|      }
  546|      0|      // we unlock before mmap() both because mmap() may call a callback hook,
  547|      0|      // and because it may be slow.
  548|      0|      arena->mu.Unlock();
  549|      0|      // mmap generous 64K chunks to decrease
  550|      0|      // the chances/impact of fragmentation:
  551|      0|      size_t new_pages_size = RoundUp(req_rnd, arena->pagesize * 16);
  552|      0|      void *new_pages;
  553|       |#ifdef _WIN32
  554|       |      new_pages = VirtualAlloc(0, new_pages_size,
  555|       |                               MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
  556|       |      ABSL_RAW_CHECK(new_pages != nullptr, "VirtualAlloc failed");
  557|       |#else
  558|       |#ifndef ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  559|      0|      if ((arena->flags & LowLevelAlloc::kAsyncSignalSafe) != 0) {
  560|      0|        new_pages = base_internal::DirectMmap(nullptr, new_pages_size,
  561|      0|            PROT_WRITE|PROT_READ, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
  562|      0|      } else {
  563|      0|        new_pages = mmap(nullptr, new_pages_size, PROT_WRITE | PROT_READ,
  564|      0|                         MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
  565|      0|      }
  566|       |#else
  567|       |      new_pages = mmap(nullptr, new_pages_size, PROT_WRITE | PROT_READ,
  568|       |                       MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
  569|       |#endif  // ABSL_LOW_LEVEL_ALLOC_ASYNC_SIGNAL_SAFE_MISSING
  570|      0|      if (new_pages == MAP_FAILED) {
  571|      0|        ABSL_RAW_LOG(FATAL, "mmap error: %d", errno);
  572|      0|      }
  573|      0|
  574|      0|#endif  // _WIN32
  575|      0|      arena->mu.Lock();
  576|      0|      s = reinterpret_cast<AllocList *>(new_pages);
  577|      0|      s->header.size = new_pages_size;
  578|      0|      // Pretend the block is allocated; call AddToFreelist() to free it.
  579|      0|      s->header.magic = Magic(kMagicAllocated, &s->header);
  580|      0|      s->header.arena = arena;
  581|      0|      AddToFreelist(&s->levels, arena);  // insert new region into free list
  582|      0|    }
  583|      0|    AllocList *prev[kMaxLevel];
  584|      0|    LLA_SkiplistDelete(&arena->freelist, s, prev);    // remove from free list
  585|      0|    // s points to the first free region that's big enough
  586|      0|    if (CheckedAdd(req_rnd, arena->min_size) <= s->header.size) {
  587|      0|      // big enough to split
  588|      0|      AllocList *n = reinterpret_cast<AllocList *>
  589|      0|                        (req_rnd + reinterpret_cast<char *>(s));
  590|      0|      n->header.size = s->header.size - req_rnd;
  591|      0|      n->header.magic = Magic(kMagicAllocated, &n->header);
  592|      0|      n->header.arena = arena;
  593|      0|      s->header.size = req_rnd;
  594|      0|      AddToFreelist(&n->levels, arena);
  595|      0|    }
  596|      0|    s->header.magic = Magic(kMagicAllocated, &s->header);
  597|      0|    ABSL_RAW_CHECK(s->header.arena == arena, "");
  598|      0|    arena->allocation_count++;
  599|      0|    section.Leave();
  600|      0|    result = &s->levels;
  601|      0|  }
  602|      0|  ANNOTATE_MEMORY_IS_UNINITIALIZED(result, request);
  603|      0|  return result;
  604|      0|}
  605|       |
  606|      0|void *LowLevelAlloc::Alloc(size_t request) {
  607|      0|  void *result = DoAllocWithArena(request, DefaultArena());
  608|      0|  return result;
  609|      0|}
  610|       |
  611|      0|void *LowLevelAlloc::AllocWithArena(size_t request, Arena *arena) {
  612|      0|  ABSL_RAW_CHECK(arena != nullptr, "must pass a valid arena");
  613|      0|  void *result = DoAllocWithArena(request, arena);
  614|      0|  return result;
  615|      0|}
  616|       |
  617|       |}  // namespace base_internal
  618|       |}  // inline namespace lts_2019_08_08
  619|       |}  // namespace absl
  620|       |
  621|       |#endif  // ABSL_LOW_LEVEL_ALLOC_MISSING

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/low_level_scheduling.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// Core interfaces and definitions used by by low-level interfaces such as
   16|       |// SpinLock.
   17|       |
   18|       |#ifndef ABSL_BASE_INTERNAL_LOW_LEVEL_SCHEDULING_H_
   19|       |#define ABSL_BASE_INTERNAL_LOW_LEVEL_SCHEDULING_H_
   20|       |
   21|       |#include "absl/base/internal/scheduling_mode.h"
   22|       |#include "absl/base/macros.h"
   23|       |
   24|       |// The following two declarations exist so SchedulingGuard may friend them with
   25|       |// the appropriate language linkage.  These callbacks allow libc internals, such
   26|       |// as function level statics, to schedule cooperatively when locking.
   27|       |extern "C" bool __google_disable_rescheduling(void);
   28|       |extern "C" void __google_enable_rescheduling(bool disable_result);
   29|       |
   30|       |namespace absl {
   31|       |inline namespace lts_2019_08_08 {
   32|       |namespace base_internal {
   33|       |
   34|       |class SchedulingHelper;  // To allow use of SchedulingGuard.
   35|       |class SpinLock;          // To allow use of SchedulingGuard.
   36|       |
   37|       |// SchedulingGuard
   38|       |// Provides guard semantics that may be used to disable cooperative rescheduling
   39|       |// of the calling thread within specific program blocks.  This is used to
   40|       |// protect resources (e.g. low-level SpinLocks or Domain code) that cooperative
   41|       |// scheduling depends on.
   42|       |//
   43|       |// Domain implementations capable of rescheduling in reaction to involuntary
   44|       |// kernel thread actions (e.g blocking due to a pagefault or syscall) must
   45|       |// guarantee that an annotated thread is not allowed to (cooperatively)
   46|       |// reschedule until the annotated region is complete.
   47|       |//
   48|       |// It is an error to attempt to use a cooperatively scheduled resource (e.g.
   49|       |// Mutex) within a rescheduling-disabled region.
   50|       |//
   51|       |// All methods are async-signal safe.
   52|       |class SchedulingGuard {
   53|       | public:
   54|       |  // Returns true iff the calling thread may be cooperatively rescheduled.
   55|       |  static bool ReschedulingIsAllowed();
   56|       |
   57|       | private:
   58|       |  // Disable cooperative rescheduling of the calling thread.  It may still
   59|       |  // initiate scheduling operations (e.g. wake-ups), however, it may not itself
   60|       |  // reschedule.  Nestable.  The returned result is opaque, clients should not
   61|       |  // attempt to interpret it.
   62|       |  // REQUIRES: Result must be passed to a pairing EnableScheduling().
   63|       |  static bool DisableRescheduling();
   64|       |
   65|       |  // Marks the end of a rescheduling disabled region, previously started by
   66|       |  // DisableRescheduling().
   67|       |  // REQUIRES: Pairs with innermost call (and result) of DisableRescheduling().
   68|       |  static void EnableRescheduling(bool disable_result);
   69|       |
   70|       |  // A scoped helper for {Disable, Enable}Rescheduling().
   71|       |  // REQUIRES: destructor must run in same thread as constructor.
   72|       |  struct ScopedDisable {
   73|      0|    ScopedDisable() { disabled = SchedulingGuard::DisableRescheduling(); }
   74|      0|    ~ScopedDisable() { SchedulingGuard::EnableRescheduling(disabled); }
   75|       |
   76|       |    bool disabled;
   77|       |  };
   78|       |
   79|       |  // Access to SchedulingGuard is explicitly white-listed.
   80|       |  friend class SchedulingHelper;
   81|       |  friend class SpinLock;
   82|       |
   83|       |  SchedulingGuard(const SchedulingGuard&) = delete;
   84|       |  SchedulingGuard& operator=(const SchedulingGuard&) = delete;
   85|       |};
   86|       |
   87|       |//------------------------------------------------------------------------------
   88|       |// End of public interfaces.
   89|       |//------------------------------------------------------------------------------
   90|       |
   91|      0|inline bool SchedulingGuard::ReschedulingIsAllowed() {
   92|      0|  return false;
   93|      0|}
   94|       |
   95|      0|inline bool SchedulingGuard::DisableRescheduling() {
   96|      0|  return false;
   97|      0|}
   98|       |
   99|      0|inline void SchedulingGuard::EnableRescheduling(bool /* disable_result */) {
  100|      0|  return;
  101|      0|}
  102|       |
  103|       |}  // namespace base_internal
  104|       |}  // inline namespace lts_2019_08_08
  105|       |}  // namespace absl
  106|       |
  107|       |#endif  // ABSL_BASE_INTERNAL_LOW_LEVEL_SCHEDULING_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/raw_logging.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/base/internal/raw_logging.h"
   16|       |
   17|       |#include <stddef.h>
   18|       |#include <cstdarg>
   19|       |#include <cstdio>
   20|       |#include <cstdlib>
   21|       |#include <cstring>
   22|       |
   23|       |#include "absl/base/attributes.h"
   24|       |#include "absl/base/config.h"
   25|       |#include "absl/base/internal/atomic_hook.h"
   26|       |#include "absl/base/log_severity.h"
   27|       |
   28|       |// We know how to perform low-level writes to stderr in POSIX and Windows.  For
   29|       |// these platforms, we define the token ABSL_LOW_LEVEL_WRITE_SUPPORTED.
   30|       |// Much of raw_logging.cc becomes a no-op when we can't output messages,
   31|       |// although a FATAL ABSL_RAW_LOG message will still abort the process.
   32|       |
   33|       |// ABSL_HAVE_POSIX_WRITE is defined when the platform provides posix write()
   34|       |// (as from unistd.h)
   35|       |//
   36|       |// This preprocessor token is also defined in raw_io.cc.  If you need to copy
   37|       |// this, consider moving both to config.h instead.
   38|       |#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || \
   39|       |    defined(__Fuchsia__) || defined(__native_client__) || \
   40|       |    defined(__EMSCRIPTEN__)
   41|       |#include <unistd.h>
   42|       |
   43|       |
   44|       |#define ABSL_HAVE_POSIX_WRITE 1
   45|       |#define ABSL_LOW_LEVEL_WRITE_SUPPORTED 1
   46|       |#else
   47|       |#undef ABSL_HAVE_POSIX_WRITE
   48|       |#endif
   49|       |
   50|       |// ABSL_HAVE_SYSCALL_WRITE is defined when the platform provides the syscall
   51|       |//   syscall(SYS_write, /*int*/ fd, /*char* */ buf, /*size_t*/ len);
   52|       |// for low level operations that want to avoid libc.
   53|       |#if (defined(__linux__) || defined(__FreeBSD__)) && !defined(__ANDROID__)
   54|       |#include <sys/syscall.h>
   55|       |#define ABSL_HAVE_SYSCALL_WRITE 1
   56|       |#define ABSL_LOW_LEVEL_WRITE_SUPPORTED 1
   57|       |#else
   58|       |#undef ABSL_HAVE_SYSCALL_WRITE
   59|       |#endif
   60|       |
   61|       |#ifdef _WIN32
   62|       |#include <io.h>
   63|       |
   64|       |#define ABSL_HAVE_RAW_IO 1
   65|       |#define ABSL_LOW_LEVEL_WRITE_SUPPORTED 1
   66|       |#else
   67|       |#undef ABSL_HAVE_RAW_IO
   68|       |#endif
   69|       |
   70|       |// TODO(gfalcon): We want raw-logging to work on as many platforms as possible.
   71|       |// Explicitly #error out when not ABSL_LOW_LEVEL_WRITE_SUPPORTED, except for a
   72|       |// whitelisted set of platforms for which we expect not to be able to raw log.
   73|       |
   74|       |ABSL_CONST_INIT static absl::base_internal::AtomicHook<
   75|       |    absl::raw_logging_internal::LogPrefixHook> log_prefix_hook;
   76|       |ABSL_CONST_INIT static absl::base_internal::AtomicHook<
   77|       |    absl::raw_logging_internal::AbortHook> abort_hook;
   78|       |
   79|       |#ifdef ABSL_LOW_LEVEL_WRITE_SUPPORTED
   80|       |static const char kTruncated[] = " ... (message truncated)\n";
   81|       |
   82|       |// sprintf the format to the buffer, adjusting *buf and *size to reflect the
   83|       |// consumed bytes, and return whether the message fit without truncation.  If
   84|       |// truncation occurred, if possible leave room in the buffer for the message
   85|       |// kTruncated[].
   86|       |inline static bool VADoRawLog(char** buf, int* size, const char* format,
   87|       |                              va_list ap) ABSL_PRINTF_ATTRIBUTE(3, 0);
   88|       |inline static bool VADoRawLog(char** buf, int* size,
   89|      0|                              const char* format, va_list ap) {
   90|      0|  int n = vsnprintf(*buf, *size, format, ap);
   91|      0|  bool result = true;
   92|      0|  if (n < 0 || n > *size) {
   93|      0|    result = false;
   94|      0|    if (static_cast<size_t>(*size) > sizeof(kTruncated)) {
   95|      0|      n = *size - sizeof(kTruncated);  // room for truncation message
   96|      0|    } else {
   97|      0|      n = 0;                           // no room for truncation message
   98|      0|    }
   99|      0|  }
  100|      0|  *size -= n;
  101|      0|  *buf += n;
  102|      0|  return result;
  103|      0|}
  104|       |#endif  // ABSL_LOW_LEVEL_WRITE_SUPPORTED
  105|       |
  106|       |static constexpr int kLogBufSize = 3000;
  107|       |
  108|       |namespace {
  109|       |
  110|       |// CAVEAT: vsnprintf called from *DoRawLog below has some (exotic) code paths
  111|       |// that invoke malloc() and getenv() that might acquire some locks.
  112|       |
  113|       |// Helper for RawLog below.
  114|       |// *DoRawLog writes to *buf of *size and move them past the written portion.
  115|       |// It returns true iff there was no overflow or error.
  116|       |bool DoRawLog(char** buf, int* size, const char* format, ...)
  117|       |    ABSL_PRINTF_ATTRIBUTE(3, 4);
  118|      0|bool DoRawLog(char** buf, int* size, const char* format, ...) {
  119|      0|  va_list ap;
  120|      0|  va_start(ap, format);
  121|      0|  int n = vsnprintf(*buf, *size, format, ap);
  122|      0|  va_end(ap);
  123|      0|  if (n < 0 || n > *size) return false;
  124|      0|  *size -= n;
  125|      0|  *buf += n;
  126|      0|  return true;
  127|      0|}
  128|       |
  129|       |void RawLogVA(absl::LogSeverity severity, const char* file, int line,
  130|       |              const char* format, va_list ap) ABSL_PRINTF_ATTRIBUTE(4, 0);
  131|       |void RawLogVA(absl::LogSeverity severity, const char* file, int line,
  132|      0|              const char* format, va_list ap) {
  133|      0|  char buffer[kLogBufSize];
  134|      0|  char* buf = buffer;
  135|      0|  int size = sizeof(buffer);
  136|      0|#ifdef ABSL_LOW_LEVEL_WRITE_SUPPORTED
  137|      0|  bool enabled = true;
  138|       |#else
  139|       |  bool enabled = false;
  140|       |#endif
  141|       |
  142|       |#ifdef ABSL_MIN_LOG_LEVEL
  143|       |  if (severity < static_cast<absl::LogSeverity>(ABSL_MIN_LOG_LEVEL) &&
  144|       |      severity < absl::LogSeverity::kFatal) {
  145|       |    enabled = false;
  146|       |  }
  147|       |#endif
  148|       |
  149|      0|  auto log_prefix_hook_ptr = log_prefix_hook.Load();
  150|      0|  if (log_prefix_hook_ptr) {
  151|      0|    enabled = log_prefix_hook_ptr(severity, file, line, &buf, &size);
  152|      0|  } else {
  153|      0|    if (enabled) {
  154|      0|      DoRawLog(&buf, &size, "[%s : %d] RAW: ", file, line);
  155|      0|    }
  156|      0|  }
  157|      0|  const char* const prefix_end = buf;
  158|      0|
  159|      0|#ifdef ABSL_LOW_LEVEL_WRITE_SUPPORTED
  160|      0|  if (enabled) {
  161|      0|    bool no_chop = VADoRawLog(&buf, &size, format, ap);
  162|      0|    if (no_chop) {
  163|      0|      DoRawLog(&buf, &size, "\n");
  164|      0|    } else {
  165|      0|      DoRawLog(&buf, &size, "%s", kTruncated);
  166|      0|    }
  167|      0|    absl::raw_logging_internal::SafeWriteToStderr(buffer, strlen(buffer));
  168|      0|  }
  169|       |#else
  170|       |  static_cast<void>(format);
  171|       |  static_cast<void>(ap);
  172|       |#endif
  173|       |
  174|      0|  // Abort the process after logging a FATAL message, even if the output itself
  175|      0|  // was suppressed.
  176|      0|  if (severity == absl::LogSeverity::kFatal) {
  177|      0|    abort_hook(file, line, buffer, prefix_end, buffer + kLogBufSize);
  178|      0|    abort();
  179|      0|  }
  180|      0|}
  181|       |
  182|       |}  // namespace
  183|       |
  184|       |namespace absl {
  185|       |inline namespace lts_2019_08_08 {
  186|       |namespace raw_logging_internal {
  187|      0|void SafeWriteToStderr(const char *s, size_t len) {
  188|       |#if defined(ABSL_HAVE_SYSCALL_WRITE)
  189|       |  syscall(SYS_write, STDERR_FILENO, s, len);
  190|       |#elif defined(ABSL_HAVE_POSIX_WRITE)
  191|       |  write(STDERR_FILENO, s, len);
  192|       |#elif defined(ABSL_HAVE_RAW_IO)
  193|       |  _write(/* stderr */ 2, s, len);
  194|       |#else
  195|       |  // stderr logging unsupported on this platform
  196|       |  (void) s;
  197|       |  (void) len;
  198|       |#endif
  199|       |}
  200|       |
  201|       |void RawLog(absl::LogSeverity severity, const char* file, int line,
  202|       |            const char* format, ...) ABSL_PRINTF_ATTRIBUTE(4, 5);
  203|       |void RawLog(absl::LogSeverity severity, const char* file, int line,
  204|      0|            const char* format, ...) {
  205|      0|  va_list ap;
  206|      0|  va_start(ap, format);
  207|      0|  RawLogVA(severity, file, line, format, ap);
  208|      0|  va_end(ap);
  209|      0|}
  210|       |
  211|       |// Non-formatting version of RawLog().
  212|       |//
  213|       |// TODO(gfalcon): When string_view no longer depends on base, change this
  214|       |// interface to take its message as a string_view instead.
  215|       |static void DefaultInternalLog(absl::LogSeverity severity, const char* file,
  216|      0|                               int line, const std::string& message) {
  217|      0|  RawLog(severity, file, line, "%s", message.c_str());
  218|      0|}
  219|       |
  220|      0|bool RawLoggingFullySupported() {
  221|      0|#ifdef ABSL_LOW_LEVEL_WRITE_SUPPORTED
  222|      0|  return true;
  223|       |#else  // !ABSL_LOW_LEVEL_WRITE_SUPPORTED
  224|       |  return false;
  225|       |#endif  // !ABSL_LOW_LEVEL_WRITE_SUPPORTED
  226|       |}
  227|       |
  228|       |ABSL_CONST_INIT absl::base_internal::AtomicHook<InternalLogFunction>
  229|       |    internal_log_function(DefaultInternalLog);
  230|       |
  231|      0|void RegisterInternalLogFunction(InternalLogFunction func) {
  232|      0|  internal_log_function.Store(func);
  233|      0|}
  234|       |
  235|       |}  // namespace raw_logging_internal
  236|       |}  // inline namespace lts_2019_08_08
  237|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/raw_logging.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// Thread-safe logging routines that do not allocate any memory or
   16|       |// acquire any locks, and can therefore be used by low-level memory
   17|       |// allocation, synchronization, and signal-handling code.
   18|       |
   19|       |#ifndef ABSL_BASE_INTERNAL_RAW_LOGGING_H_
   20|       |#define ABSL_BASE_INTERNAL_RAW_LOGGING_H_
   21|       |
   22|       |#include <string>
   23|       |
   24|       |#include "absl/base/attributes.h"
   25|       |#include "absl/base/internal/atomic_hook.h"
   26|       |#include "absl/base/log_severity.h"
   27|       |#include "absl/base/macros.h"
   28|       |#include "absl/base/port.h"
   29|       |
   30|       |// This is similar to LOG(severity) << format..., but
   31|       |// * it is to be used ONLY by low-level modules that can't use normal LOG()
   32|       |// * it is designed to be a low-level logger that does not allocate any
   33|       |//   memory and does not need any locks, hence:
   34|       |// * it logs straight and ONLY to STDERR w/o buffering
   35|       |// * it uses an explicit printf-format and arguments list
   36|       |// * it will silently chop off really long message strings
   37|       |// Usage example:
   38|       |//   ABSL_RAW_LOG(ERROR, "Failed foo with %i: %s", status, error);
   39|       |// This will print an almost standard log line like this to stderr only:
   40|       |//   E0821 211317 file.cc:123] RAW: Failed foo with 22: bad_file
   41|       |
   42|       |#define ABSL_RAW_LOG(severity, ...)                                            \
   43|      0|  do {                                                                         \
   44|      0|    constexpr const char* absl_raw_logging_internal_basename =                 \
   45|      0|        ::absl::raw_logging_internal::Basename(__FILE__,                       \
   46|      0|                                               sizeof(__FILE__) - 1);          \
   47|      0|    ::absl::raw_logging_internal::RawLog(ABSL_RAW_LOGGING_INTERNAL_##severity, \
   48|      0|                                         absl_raw_logging_internal_basename,   \
   49|      0|                                         __LINE__, __VA_ARGS__);               \
   50|      0|  } while (0)
   51|       |
   52|       |// Similar to CHECK(condition) << message, but for low-level modules:
   53|       |// we use only ABSL_RAW_LOG that does not allocate memory.
   54|       |// We do not want to provide args list here to encourage this usage:
   55|       |//   if (!cond)  ABSL_RAW_LOG(FATAL, "foo ...", hard_to_compute_args);
   56|       |// so that the args are not computed when not needed.
   57|       |#define ABSL_RAW_CHECK(condition, message)                             \
   58|      0|  do {                                                                 \
   59|      0|    if (ABSL_PREDICT_FALSE(!(condition))) {                            \
   60|      0|      ABSL_RAW_LOG(FATAL, "Check %s failed: %s", #condition, message); \
   61|      0|    }                                                                  \
   62|      0|  } while (0)
   63|       |
   64|       |// ABSL_INTERNAL_LOG and ABSL_INTERNAL_CHECK work like the RAW variants above,
   65|       |// except that if the richer log library is linked into the binary, we dispatch
   66|       |// to that instead.  This is potentially useful for internal logging and
   67|       |// assertions, where we are using RAW_LOG neither for its async-signal-safety
   68|       |// nor for its non-allocating nature, but rather because raw logging has very
   69|       |// few other dependencies.
   70|       |//
   71|       |// The API is a subset of the above: each macro only takes two arguments.  Use
   72|       |// StrCat if you need to build a richer message.
   73|       |#define ABSL_INTERNAL_LOG(severity, message)                          \
   74|       |  do {                                                                \
   75|       |    constexpr const char* absl_raw_logging_internal_basename =        \
   76|       |        ::absl::raw_logging_internal::Basename(__FILE__,              \
   77|       |                                               sizeof(__FILE__) - 1); \
   78|       |    ::absl::raw_logging_internal::internal_log_function(              \
   79|       |        ABSL_RAW_LOGGING_INTERNAL_##severity,                         \
   80|       |        absl_raw_logging_internal_basename, __LINE__, message);       \
   81|       |  } while (0)
   82|       |
   83|       |#define ABSL_INTERNAL_CHECK(condition, message)                    \
   84|       |  do {                                                             \
   85|       |    if (ABSL_PREDICT_FALSE(!(condition))) {                        \
   86|       |      std::string death_message = "Check " #condition " failed: "; \
   87|       |      death_message += std::string(message);                       \
   88|       |      ABSL_INTERNAL_LOG(FATAL, death_message);                     \
   89|       |    }                                                              \
   90|       |  } while (0)
   91|       |
   92|       |#define ABSL_RAW_LOGGING_INTERNAL_INFO ::absl::LogSeverity::kInfo
   93|       |#define ABSL_RAW_LOGGING_INTERNAL_WARNING ::absl::LogSeverity::kWarning
   94|       |#define ABSL_RAW_LOGGING_INTERNAL_ERROR ::absl::LogSeverity::kError
   95|      0|#define ABSL_RAW_LOGGING_INTERNAL_FATAL ::absl::LogSeverity::kFatal
   96|       |#define ABSL_RAW_LOGGING_INTERNAL_LEVEL(severity) \
   97|       |  ::absl::NormalizeLogSeverity(severity)
   98|       |
   99|       |namespace absl {
  100|       |inline namespace lts_2019_08_08 {
  101|       |namespace raw_logging_internal {
  102|       |
  103|       |// Helper function to implement ABSL_RAW_LOG
  104|       |// Logs format... at "severity" level, reporting it
  105|       |// as called from file:line.
  106|       |// This does not allocate memory or acquire locks.
  107|       |void RawLog(absl::LogSeverity severity, const char* file, int line,
  108|       |            const char* format, ...) ABSL_PRINTF_ATTRIBUTE(4, 5);
  109|       |
  110|       |// Writes the provided buffer directly to stderr, in a safe, low-level manner.
  111|       |//
  112|       |// In POSIX this means calling write(), which is async-signal safe and does
  113|       |// not malloc.  If the platform supports the SYS_write syscall, we invoke that
  114|       |// directly to side-step any libc interception.
  115|       |void SafeWriteToStderr(const char *s, size_t len);
  116|       |
  117|       |// compile-time function to get the "base" filename, that is, the part of
  118|       |// a filename after the last "/" or "\" path separator.  The search starts at
  119|       |// the end of the string; the second parameter is the length of the string.
  120|      0|constexpr const char* Basename(const char* fname, int offset) {
  121|      0|  return offset == 0 || fname[offset - 1] == '/' || fname[offset - 1] == '\\'
  122|      0|             ? fname + offset
  123|      0|             : Basename(fname, offset - 1);
  124|      0|}
  125|       |
  126|       |// For testing only.
  127|       |// Returns true if raw logging is fully supported. When it is not
  128|       |// fully supported, no messages will be emitted, but a log at FATAL
  129|       |// severity will cause an abort.
  130|       |//
  131|       |// TODO(gfalcon): Come up with a better name for this method.
  132|       |bool RawLoggingFullySupported();
  133|       |
  134|       |// Function type for a raw_logging customization hook for suppressing messages
  135|       |// by severity, and for writing custom prefixes on non-suppressed messages.
  136|       |//
  137|       |// The installed hook is called for every raw log invocation.  The message will
  138|       |// be logged to stderr only if the hook returns true.  FATAL errors will cause
  139|       |// the process to abort, even if writing to stderr is suppressed.  The hook is
  140|       |// also provided with an output buffer, where it can write a custom log message
  141|       |// prefix.
  142|       |//
  143|       |// The raw_logging system does not allocate memory or grab locks.  User-provided
  144|       |// hooks must avoid these operations, and must not throw exceptions.
  145|       |//
  146|       |// 'severity' is the severity level of the message being written.
  147|       |// 'file' and 'line' are the file and line number where the ABSL_RAW_LOG macro
  148|       |// was located.
  149|       |// 'buffer' and 'buf_size' are pointers to the buffer and buffer size.  If the
  150|       |// hook writes a prefix, it must increment *buffer and decrement *buf_size
  151|       |// accordingly.
  152|       |using LogPrefixHook = bool (*)(absl::LogSeverity severity, const char* file,
  153|       |                               int line, char** buffer, int* buf_size);
  154|       |
  155|       |// Function type for a raw_logging customization hook called to abort a process
  156|       |// when a FATAL message is logged.  If the provided AbortHook() returns, the
  157|       |// logging system will call abort().
  158|       |//
  159|       |// 'file' and 'line' are the file and line number where the ABSL_RAW_LOG macro
  160|       |// was located.
  161|       |// The null-terminated logged message lives in the buffer between 'buf_start'
  162|       |// and 'buf_end'.  'prefix_end' points to the first non-prefix character of the
  163|       |// buffer (as written by the LogPrefixHook.)
  164|       |using AbortHook = void (*)(const char* file, int line, const char* buf_start,
  165|       |                           const char* prefix_end, const char* buf_end);
  166|       |
  167|       |// Internal logging function for ABSL_INTERNAL_LOG to dispatch to.
  168|       |//
  169|       |// TODO(gfalcon): When string_view no longer depends on base, change this
  170|       |// interface to take its message as a string_view instead.
  171|       |using InternalLogFunction = void (*)(absl::LogSeverity severity,
  172|       |                                     const char* file, int line,
  173|       |                                     const std::string& message);
  174|       |
  175|       |extern base_internal::AtomicHook<InternalLogFunction> internal_log_function;
  176|       |
  177|       |void RegisterInternalLogFunction(InternalLogFunction func);
  178|       |
  179|       |}  // namespace raw_logging_internal
  180|       |}  // inline namespace lts_2019_08_08
  181|       |}  // namespace absl
  182|       |
  183|       |#endif  // ABSL_BASE_INTERNAL_RAW_LOGGING_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/spinlock.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/base/internal/spinlock.h"
   16|       |
   17|       |#include <algorithm>
   18|       |#include <atomic>
   19|       |#include <limits>
   20|       |
   21|       |#include "absl/base/attributes.h"
   22|       |#include "absl/base/internal/atomic_hook.h"
   23|       |#include "absl/base/internal/cycleclock.h"
   24|       |#include "absl/base/internal/spinlock_wait.h"
   25|       |#include "absl/base/internal/sysinfo.h" /* For NumCPUs() */
   26|       |#include "absl/base/call_once.h"
   27|       |
   28|       |// Description of lock-word:
   29|       |//  31..00: [............................3][2][1][0]
   30|       |//
   31|       |//     [0]: kSpinLockHeld
   32|       |//     [1]: kSpinLockCooperative
   33|       |//     [2]: kSpinLockDisabledScheduling
   34|       |// [31..3]: ONLY kSpinLockSleeper OR
   35|       |//          Wait time in cycles >> PROFILE_TIMESTAMP_SHIFT
   36|       |//
   37|       |// Detailed descriptions:
   38|       |//
   39|       |// Bit [0]: The lock is considered held iff kSpinLockHeld is set.
   40|       |//
   41|       |// Bit [1]: Eligible waiters (e.g. Fibers) may co-operatively reschedule when
   42|       |//          contended iff kSpinLockCooperative is set.
   43|       |//
   44|       |// Bit [2]: This bit is exclusive from bit [1].  It is used only by a
   45|       |//          non-cooperative lock.  When set, indicates that scheduling was
   46|       |//          successfully disabled when the lock was acquired.  May be unset,
   47|       |//          even if non-cooperative, if a ThreadIdentity did not yet exist at
   48|       |//          time of acquisition.
   49|       |//
   50|       |// Bit [3]: If this is the only upper bit ([31..3]) set then this lock was
   51|       |//          acquired without contention, however, at least one waiter exists.
   52|       |//
   53|       |//          Otherwise, bits [31..3] represent the time spent by the current lock
   54|       |//          holder to acquire the lock.  There may be outstanding waiter(s).
   55|       |
   56|       |namespace absl {
   57|       |inline namespace lts_2019_08_08 {
   58|       |namespace base_internal {
   59|       |
   60|       |ABSL_CONST_INIT static base_internal::AtomicHook<void (*)(const void *lock,
   61|       |                                                          int64_t wait_cycles)>
   62|       |    submit_profile_data;
   63|       |
   64|       |void RegisterSpinLockProfiler(void (*fn)(const void *contendedlock,
   65|      0|                                         int64_t wait_cycles)) {
   66|      0|  submit_profile_data.Store(fn);
   67|      0|}
   68|       |
   69|       |// Uncommon constructors.
   70|       |SpinLock::SpinLock(base_internal::SchedulingMode mode)
   71|      0|    : lockword_(IsCooperative(mode) ? kSpinLockCooperative : 0) {
   72|      0|  ABSL_TSAN_MUTEX_CREATE(this, __tsan_mutex_not_static);
   73|      0|}
   74|       |
   75|       |SpinLock::SpinLock(base_internal::LinkerInitialized,
   76|      0|                   base_internal::SchedulingMode mode) {
   77|      0|  ABSL_TSAN_MUTEX_CREATE(this, 0);
   78|      0|  if (IsCooperative(mode)) {
   79|      0|    InitLinkerInitializedAndCooperative();
   80|      0|  }
   81|      0|  // Otherwise, lockword_ is already initialized.
   82|      0|}
   83|       |
   84|       |// Static (linker initialized) spinlocks always start life as functional
   85|       |// non-cooperative locks.  When their static constructor does run, it will call
   86|       |// this initializer to augment the lockword with the cooperative bit.  By
   87|       |// actually taking the lock when we do this we avoid the need for an atomic
   88|       |// operation in the regular unlock path.
   89|       |//
   90|       |// SlowLock() must be careful to re-test for this bit so that any outstanding
   91|       |// waiters may be upgraded to cooperative status.
   92|      0|void SpinLock::InitLinkerInitializedAndCooperative() {
   93|      0|  Lock();
   94|      0|  lockword_.fetch_or(kSpinLockCooperative, std::memory_order_relaxed);
   95|      0|  Unlock();
   96|      0|}
   97|       |
   98|       |// Monitor the lock to see if its value changes within some time period
   99|       |// (adaptive_spin_count loop iterations). The last value read from the lock
  100|       |// is returned from the method.
  101|      0|uint32_t SpinLock::SpinLoop() {
  102|      0|  // We are already in the slow path of SpinLock, initialize the
  103|      0|  // adaptive_spin_count here.
  104|      0|  ABSL_CONST_INIT static absl::once_flag init_adaptive_spin_count;
  105|      0|  ABSL_CONST_INIT static int adaptive_spin_count = 0;
  106|      0|  base_internal::LowLevelCallOnce(&init_adaptive_spin_count, []() {
  107|      0|    adaptive_spin_count = base_internal::NumCPUs() > 1 ? 1000 : 1;
  108|      0|  });
  109|      0|
  110|      0|  int c = adaptive_spin_count;
  111|      0|  uint32_t lock_value;
  112|      0|  do {
  113|      0|    lock_value = lockword_.load(std::memory_order_relaxed);
  114|      0|  } while ((lock_value & kSpinLockHeld) != 0 && --c > 0);
  115|      0|  return lock_value;
  116|      0|}
  117|       |
  118|      0|void SpinLock::SlowLock() {
  119|      0|  uint32_t lock_value = SpinLoop();
  120|      0|  lock_value = TryLockInternal(lock_value, 0);
  121|      0|  if ((lock_value & kSpinLockHeld) == 0) {
  122|      0|    return;
  123|      0|  }
  124|      0|  // The lock was not obtained initially, so this thread needs to wait for
  125|      0|  // it.  Record the current timestamp in the local variable wait_start_time
  126|      0|  // so the total wait time can be stored in the lockword once this thread
  127|      0|  // obtains the lock.
  128|      0|  int64_t wait_start_time = CycleClock::Now();
  129|      0|  uint32_t wait_cycles = 0;
  130|      0|  int lock_wait_call_count = 0;
  131|      0|  while ((lock_value & kSpinLockHeld) != 0) {
  132|      0|    // If the lock is currently held, but not marked as having a sleeper, mark
  133|      0|    // it as having a sleeper.
  134|      0|    if ((lock_value & kWaitTimeMask) == 0) {
  135|      0|      // Here, just "mark" that the thread is going to sleep.  Don't store the
  136|      0|      // lock wait time in the lock as that will cause the current lock
  137|      0|      // owner to think it experienced contention.
  138|      0|      if (lockword_.compare_exchange_strong(
  139|      0|              lock_value, lock_value | kSpinLockSleeper,
  140|      0|              std::memory_order_relaxed, std::memory_order_relaxed)) {
  141|      0|        // Successfully transitioned to kSpinLockSleeper.  Pass
  142|      0|        // kSpinLockSleeper to the SpinLockWait routine to properly indicate
  143|      0|        // the last lock_value observed.
  144|      0|        lock_value |= kSpinLockSleeper;
  145|      0|      } else if ((lock_value & kSpinLockHeld) == 0) {
  146|      0|        // Lock is free again, so try and acquire it before sleeping.  The
  147|      0|        // new lock state will be the number of cycles this thread waited if
  148|      0|        // this thread obtains the lock.
  149|      0|        lock_value = TryLockInternal(lock_value, wait_cycles);
  150|      0|        continue;   // Skip the delay at the end of the loop.
  151|      0|      }
  152|      0|    }
  153|      0|
  154|      0|    base_internal::SchedulingMode scheduling_mode;
  155|      0|    if ((lock_value & kSpinLockCooperative) != 0) {
  156|      0|      scheduling_mode = base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL;
  157|      0|    } else {
  158|      0|      scheduling_mode = base_internal::SCHEDULE_KERNEL_ONLY;
  159|      0|    }
  160|      0|    // SpinLockDelay() calls into fiber scheduler, we need to see
  161|      0|    // synchronization there to avoid false positives.
  162|      0|    ABSL_TSAN_MUTEX_PRE_DIVERT(this, 0);
  163|      0|    // Wait for an OS specific delay.
  164|      0|    base_internal::SpinLockDelay(&lockword_, lock_value, ++lock_wait_call_count,
  165|      0|                                 scheduling_mode);
  166|      0|    ABSL_TSAN_MUTEX_POST_DIVERT(this, 0);
  167|      0|    // Spin again after returning from the wait routine to give this thread
  168|      0|    // some chance of obtaining the lock.
  169|      0|    lock_value = SpinLoop();
  170|      0|    wait_cycles = EncodeWaitCycles(wait_start_time, CycleClock::Now());
  171|      0|    lock_value = TryLockInternal(lock_value, wait_cycles);
  172|      0|  }
  173|      0|}
  174|       |
  175|      0|void SpinLock::SlowUnlock(uint32_t lock_value) {
  176|      0|  base_internal::SpinLockWake(&lockword_,
  177|      0|                              false);  // wake waiter if necessary
  178|      0|
  179|      0|  // If our acquisition was contended, collect contentionz profile info.  We
  180|      0|  // reserve a unitary wait time to represent that a waiter exists without our
  181|      0|  // own acquisition having been contended.
  182|      0|  if ((lock_value & kWaitTimeMask) != kSpinLockSleeper) {
  183|      0|    const uint64_t wait_cycles = DecodeWaitCycles(lock_value);
  184|      0|    ABSL_TSAN_MUTEX_PRE_DIVERT(this, 0);
  185|      0|    submit_profile_data(this, wait_cycles);
  186|      0|    ABSL_TSAN_MUTEX_POST_DIVERT(this, 0);
  187|      0|  }
  188|      0|}
  189|       |
  190|       |// We use the upper 29 bits of the lock word to store the time spent waiting to
  191|       |// acquire this lock.  This is reported by contentionz profiling.  Since the
  192|       |// lower bits of the cycle counter wrap very quickly on high-frequency
  193|       |// processors we divide to reduce the granularity to 2^PROFILE_TIMESTAMP_SHIFT
  194|       |// sized units.  On a 4Ghz machine this will lose track of wait times greater
  195|       |// than (2^29/4 Ghz)*128 =~ 17.2 seconds.  Such waits should be extremely rare.
  196|       |enum { PROFILE_TIMESTAMP_SHIFT = 7 };
  197|       |enum { LOCKWORD_RESERVED_SHIFT = 3 };  // We currently reserve the lower 3 bits.
  198|       |
  199|       |uint32_t SpinLock::EncodeWaitCycles(int64_t wait_start_time,
  200|      0|                                    int64_t wait_end_time) {
  201|      0|  static const int64_t kMaxWaitTime =
  202|      0|      std::numeric_limits<uint32_t>::max() >> LOCKWORD_RESERVED_SHIFT;
  203|      0|  int64_t scaled_wait_time =
  204|      0|      (wait_end_time - wait_start_time) >> PROFILE_TIMESTAMP_SHIFT;
  205|      0|
  206|      0|  // Return a representation of the time spent waiting that can be stored in
  207|      0|  // the lock word's upper bits.
  208|      0|  uint32_t clamped = static_cast<uint32_t>(
  209|      0|      std::min(scaled_wait_time, kMaxWaitTime) << LOCKWORD_RESERVED_SHIFT);
  210|      0|
  211|      0|  if (clamped == 0) {
  212|      0|    return kSpinLockSleeper;  // Just wake waiters, but don't record contention.
  213|      0|  }
  214|      0|  // Bump up value if necessary to avoid returning kSpinLockSleeper.
  215|      0|  const uint32_t kMinWaitTime =
  216|      0|      kSpinLockSleeper + (1 << LOCKWORD_RESERVED_SHIFT);
  217|      0|  if (clamped == kSpinLockSleeper) {
  218|      0|    return kMinWaitTime;
  219|      0|  }
  220|      0|  return clamped;
  221|      0|}
  222|       |
  223|      0|uint64_t SpinLock::DecodeWaitCycles(uint32_t lock_value) {
  224|      0|  // Cast to uint32_t first to ensure bits [63:32] are cleared.
  225|      0|  const uint64_t scaled_wait_time =
  226|      0|      static_cast<uint32_t>(lock_value & kWaitTimeMask);
  227|      0|  return scaled_wait_time
  228|      0|      << (PROFILE_TIMESTAMP_SHIFT - LOCKWORD_RESERVED_SHIFT);
  229|      0|}
  230|       |
  231|       |}  // namespace base_internal
  232|       |}  // inline namespace lts_2019_08_08
  233|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/spinlock.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |
   17|       |//  Most users requiring mutual exclusion should use Mutex.
   18|       |//  SpinLock is provided for use in three situations:
   19|       |//   - for use in code that Mutex itself depends on
   20|       |//   - to get a faster fast-path release under low contention (without an
   21|       |//     atomic read-modify-write) In return, SpinLock has worse behaviour under
   22|       |//     contention, which is why Mutex is preferred in most situations.
   23|       |//   - for async signal safety (see below)
   24|       |
   25|       |// SpinLock is async signal safe.  If a spinlock is used within a signal
   26|       |// handler, all code that acquires the lock must ensure that the signal cannot
   27|       |// arrive while they are holding the lock.  Typically, this is done by blocking
   28|       |// the signal.
   29|       |
   30|       |#ifndef ABSL_BASE_INTERNAL_SPINLOCK_H_
   31|       |#define ABSL_BASE_INTERNAL_SPINLOCK_H_
   32|       |
   33|       |#include <stdint.h>
   34|       |#include <sys/types.h>
   35|       |
   36|       |#include <atomic>
   37|       |
   38|       |#include "absl/base/attributes.h"
   39|       |#include "absl/base/dynamic_annotations.h"
   40|       |#include "absl/base/internal/low_level_scheduling.h"
   41|       |#include "absl/base/internal/raw_logging.h"
   42|       |#include "absl/base/internal/scheduling_mode.h"
   43|       |#include "absl/base/internal/tsan_mutex_interface.h"
   44|       |#include "absl/base/macros.h"
   45|       |#include "absl/base/port.h"
   46|       |#include "absl/base/thread_annotations.h"
   47|       |
   48|       |namespace absl {
   49|       |inline namespace lts_2019_08_08 {
   50|       |namespace base_internal {
   51|       |
   52|       |class LOCKABLE SpinLock {
   53|       | public:
   54|      0|  SpinLock() : lockword_(kSpinLockCooperative) {
   55|      0|    ABSL_TSAN_MUTEX_CREATE(this, __tsan_mutex_not_static);
   56|      0|  }
   57|       |
   58|       |  // Special constructor for use with static SpinLock objects.  E.g.,
   59|       |  //
   60|       |  //    static SpinLock lock(base_internal::kLinkerInitialized);
   61|       |  //
   62|       |  // When initialized using this constructor, we depend on the fact
   63|       |  // that the linker has already initialized the memory appropriately. The lock
   64|       |  // is initialized in non-cooperative mode.
   65|       |  //
   66|       |  // A SpinLock constructed like this can be freely used from global
   67|       |  // initializers without worrying about the order in which global
   68|       |  // initializers run.
   69|      1|  explicit SpinLock(base_internal::LinkerInitialized) {
   70|      1|    // Does nothing; lockword_ is already initialized
   71|      1|    ABSL_TSAN_MUTEX_CREATE(this, 0);
   72|      1|  }
   73|       |
   74|       |  // Constructors that allow non-cooperative spinlocks to be created for use
   75|       |  // inside thread schedulers.  Normal clients should not use these.
   76|       |  explicit SpinLock(base_internal::SchedulingMode mode);
   77|       |  SpinLock(base_internal::LinkerInitialized,
   78|       |           base_internal::SchedulingMode mode);
   79|       |
   80|      1|  ~SpinLock() { ABSL_TSAN_MUTEX_DESTROY(this, __tsan_mutex_not_static); }
   81|       |
   82|       |  // Acquire this SpinLock.
   83|      0|  inline void Lock() EXCLUSIVE_LOCK_FUNCTION() {
   84|      0|    ABSL_TSAN_MUTEX_PRE_LOCK(this, 0);
   85|      0|    if (!TryLockImpl()) {
   86|      0|      SlowLock();
   87|      0|    }
   88|      0|    ABSL_TSAN_MUTEX_POST_LOCK(this, 0, 0);
   89|      0|  }
   90|       |
   91|       |  // Try to acquire this SpinLock without blocking and return true if the
   92|       |  // acquisition was successful.  If the lock was not acquired, false is
   93|       |  // returned.  If this SpinLock is free at the time of the call, TryLock
   94|       |  // will return true with high probability.
   95|      0|  inline bool TryLock() EXCLUSIVE_TRYLOCK_FUNCTION(true) {
   96|      0|    ABSL_TSAN_MUTEX_PRE_LOCK(this, __tsan_mutex_try_lock);
   97|      0|    bool res = TryLockImpl();
   98|      0|    ABSL_TSAN_MUTEX_POST_LOCK(
   99|      0|        this, __tsan_mutex_try_lock | (res ? 0 : __tsan_mutex_try_lock_failed),
  100|      0|        0);
  101|      0|    return res;
  102|      0|  }
  103|       |
  104|       |  // Release this SpinLock, which must be held by the calling thread.
  105|      0|  inline void Unlock() UNLOCK_FUNCTION() {
  106|      0|    ABSL_TSAN_MUTEX_PRE_UNLOCK(this, 0);
  107|      0|    uint32_t lock_value = lockword_.load(std::memory_order_relaxed);
  108|      0|    lock_value = lockword_.exchange(lock_value & kSpinLockCooperative,
  109|      0|                                    std::memory_order_release);
  110|      0|
  111|      0|    if ((lock_value & kSpinLockDisabledScheduling) != 0) {
  112|      0|      base_internal::SchedulingGuard::EnableRescheduling(true);
  113|      0|    }
  114|      0|    if ((lock_value & kWaitTimeMask) != 0) {
  115|      0|      // Collect contentionz profile info, and speed the wakeup of any waiter.
  116|      0|      // The wait_cycles value indicates how long this thread spent waiting
  117|      0|      // for the lock.
  118|      0|      SlowUnlock(lock_value);
  119|      0|    }
  120|      0|    ABSL_TSAN_MUTEX_POST_UNLOCK(this, 0);
  121|      0|  }
  122|       |
  123|       |  // Determine if the lock is held.  When the lock is held by the invoking
  124|       |  // thread, true will always be returned. Intended to be used as
  125|       |  // CHECK(lock.IsHeld()).
  126|      0|  inline bool IsHeld() const {
  127|      0|    return (lockword_.load(std::memory_order_relaxed) & kSpinLockHeld) != 0;
  128|      0|  }
  129|       |
  130|       | protected:
  131|       |  // These should not be exported except for testing.
  132|       |
  133|       |  // Store number of cycles between wait_start_time and wait_end_time in a
  134|       |  // lock value.
  135|       |  static uint32_t EncodeWaitCycles(int64_t wait_start_time,
  136|       |                                   int64_t wait_end_time);
  137|       |
  138|       |  // Extract number of wait cycles in a lock value.
  139|       |  static uint64_t DecodeWaitCycles(uint32_t lock_value);
  140|       |
  141|       |  // Provide access to protected method above.  Use for testing only.
  142|       |  friend struct SpinLockTest;
  143|       |
  144|       | private:
  145|       |  // lockword_ is used to store the following:
  146|       |  //
  147|       |  // bit[0] encodes whether a lock is being held.
  148|       |  // bit[1] encodes whether a lock uses cooperative scheduling.
  149|       |  // bit[2] encodes whether a lock disables scheduling.
  150|       |  // bit[3:31] encodes time a lock spent on waiting as a 29-bit unsigned int.
  151|       |  enum { kSpinLockHeld = 1 };
  152|       |  enum { kSpinLockCooperative = 2 };
  153|       |  enum { kSpinLockDisabledScheduling = 4 };
  154|       |  enum { kSpinLockSleeper = 8 };
  155|       |  enum { kWaitTimeMask =                      // Includes kSpinLockSleeper.
  156|       |    ~(kSpinLockHeld | kSpinLockCooperative | kSpinLockDisabledScheduling) };
  157|       |
  158|       |  // Returns true if the provided scheduling mode is cooperative.
  159|       |  static constexpr bool IsCooperative(
  160|      0|      base_internal::SchedulingMode scheduling_mode) {
  161|      0|    return scheduling_mode == base_internal::SCHEDULE_COOPERATIVE_AND_KERNEL;
  162|      0|  }
  163|       |
  164|       |  uint32_t TryLockInternal(uint32_t lock_value, uint32_t wait_cycles);
  165|       |  void InitLinkerInitializedAndCooperative();
  166|       |  void SlowLock() ABSL_ATTRIBUTE_COLD;
  167|       |  void SlowUnlock(uint32_t lock_value) ABSL_ATTRIBUTE_COLD;
  168|       |  uint32_t SpinLoop();
  169|       |
  170|      0|  inline bool TryLockImpl() {
  171|      0|    uint32_t lock_value = lockword_.load(std::memory_order_relaxed);
  172|      0|    return (TryLockInternal(lock_value, 0) & kSpinLockHeld) == 0;
  173|      0|  }
  174|       |
  175|       |  std::atomic<uint32_t> lockword_;
  176|       |
  177|       |  SpinLock(const SpinLock&) = delete;
  178|       |  SpinLock& operator=(const SpinLock&) = delete;
  179|       |};
  180|       |
  181|       |// Corresponding locker object that arranges to acquire a spinlock for
  182|       |// the duration of a C++ scope.
  183|       |class SCOPED_LOCKABLE SpinLockHolder {
  184|       | public:
  185|       |  inline explicit SpinLockHolder(SpinLock* l) EXCLUSIVE_LOCK_FUNCTION(l)
  186|      0|      : lock_(l) {
  187|      0|    l->Lock();
  188|      0|  }
  189|      0|  inline ~SpinLockHolder() UNLOCK_FUNCTION() { lock_->Unlock(); }
  190|       |
  191|       |  SpinLockHolder(const SpinLockHolder&) = delete;
  192|       |  SpinLockHolder& operator=(const SpinLockHolder&) = delete;
  193|       |
  194|       | private:
  195|       |  SpinLock* lock_;
  196|       |};
  197|       |
  198|       |// Register a hook for profiling support.
  199|       |//
  200|       |// The function pointer registered here will be called whenever a spinlock is
  201|       |// contended.  The callback is given an opaque handle to the contended spinlock
  202|       |// and the number of wait cycles.  This is thread-safe, but only a single
  203|       |// profiler can be registered.  It is an error to call this function multiple
  204|       |// times with different arguments.
  205|       |void RegisterSpinLockProfiler(void (*fn)(const void* lock,
  206|       |                                         int64_t wait_cycles));
  207|       |
  208|       |//------------------------------------------------------------------------------
  209|       |// Public interface ends here.
  210|       |//------------------------------------------------------------------------------
  211|       |
  212|       |// If (result & kSpinLockHeld) == 0, then *this was successfully locked.
  213|       |// Otherwise, returns last observed value for lockword_.
  214|       |inline uint32_t SpinLock::TryLockInternal(uint32_t lock_value,
  215|      0|                                          uint32_t wait_cycles) {
  216|      0|  if ((lock_value & kSpinLockHeld) != 0) {
  217|      0|    return lock_value;
  218|      0|  }
  219|      0|
  220|      0|  uint32_t sched_disabled_bit = 0;
  221|      0|  if ((lock_value & kSpinLockCooperative) == 0) {
  222|      0|    // For non-cooperative locks we must make sure we mark ourselves as
  223|      0|    // non-reschedulable before we attempt to CompareAndSwap.
  224|      0|    if (base_internal::SchedulingGuard::DisableRescheduling()) {
  225|      0|      sched_disabled_bit = kSpinLockDisabledScheduling;
  226|      0|    }
  227|      0|  }
  228|      0|
  229|      0|  if (lockword_.compare_exchange_strong(
  230|      0|          lock_value,
  231|      0|          kSpinLockHeld | lock_value | wait_cycles | sched_disabled_bit,
  232|      0|          std::memory_order_acquire, std::memory_order_relaxed)) {
  233|      0|  } else {
  234|      0|    base_internal::SchedulingGuard::EnableRescheduling(sched_disabled_bit != 0);
  235|      0|  }
  236|      0|
  237|      0|  return lock_value;
  238|      0|}
  239|       |
  240|       |}  // namespace base_internal
  241|       |}  // inline namespace lts_2019_08_08
  242|       |}  // namespace absl
  243|       |
  244|       |#endif  // ABSL_BASE_INTERNAL_SPINLOCK_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/spinlock_posix.inc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// This file is a Posix-specific part of spinlock_wait.cc
   16|       |
   17|       |#include <sched.h>
   18|       |#include <atomic>
   19|       |#include <ctime>
   20|       |#include <cerrno>
   21|       |
   22|       |#include "absl/base/internal/scheduling_mode.h"
   23|       |#include "absl/base/port.h"
   24|       |
   25|       |extern "C" {
   26|       |
   27|       |ABSL_ATTRIBUTE_WEAK void AbslInternalSpinLockDelay(
   28|       |    std::atomic<uint32_t>* /* lock_word */, uint32_t /* value */, int loop,
   29|      0|    absl::base_internal::SchedulingMode /* mode */) {
   30|      0|  int save_errno = errno;
   31|      0|  if (loop == 0) {
   32|      0|  } else if (loop == 1) {
   33|      0|    sched_yield();
   34|      0|  } else {
   35|      0|    struct timespec tm;
   36|      0|    tm.tv_sec = 0;
   37|      0|    tm.tv_nsec = absl::base_internal::SpinLockSuggestedDelayNS(loop);
   38|      0|    nanosleep(&tm, nullptr);
   39|      0|  }
   40|      0|  errno = save_errno;
   41|      0|}
   42|       |
   43|       |ABSL_ATTRIBUTE_WEAK void AbslInternalSpinLockWake(
   44|      0|    std::atomic<uint32_t>* /* lock_word */, bool /* all */) {}
   45|       |
   46|       |}  // extern "C"

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/spinlock_wait.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |// The OS-specific header included below must provide two calls:
   16|       |// AbslInternalSpinLockDelay() and AbslInternalSpinLockWake().
   17|       |// See spinlock_wait.h for the specs.
   18|       |
   19|       |#include <atomic>
   20|       |#include <cstdint>
   21|       |
   22|       |#include "absl/base/internal/spinlock_wait.h"
   23|       |
   24|       |#if defined(_WIN32)
   25|       |#include "absl/base/internal/spinlock_win32.inc"
   26|       |#elif defined(__linux__)
   27|       |#include "absl/base/internal/spinlock_linux.inc"
   28|       |#elif defined(__akaros__)
   29|       |#include "absl/base/internal/spinlock_akaros.inc"
   30|       |#else
   31|       |#include "absl/base/internal/spinlock_posix.inc"
   32|       |#endif
   33|       |
   34|       |namespace absl {
   35|       |inline namespace lts_2019_08_08 {
   36|       |namespace base_internal {
   37|       |
   38|       |// See spinlock_wait.h for spec.
   39|       |uint32_t SpinLockWait(std::atomic<uint32_t> *w, int n,
   40|       |                      const SpinLockWaitTransition trans[],
   41|      0|                      base_internal::SchedulingMode scheduling_mode) {
   42|      0|  int loop = 0;
   43|      0|  for (;;) {
   44|      0|    uint32_t v = w->load(std::memory_order_acquire);
   45|      0|    int i;
   46|      0|    for (i = 0; i != n && v != trans[i].from; i++) {
   47|      0|    }
   48|      0|    if (i == n) {
   49|      0|      SpinLockDelay(w, v, ++loop, scheduling_mode);  // no matching transition
   50|      0|    } else if (trans[i].to == v ||                   // null transition
   51|      0|               w->compare_exchange_strong(v, trans[i].to,
   52|      0|                                          std::memory_order_acquire,
   53|      0|                                          std::memory_order_relaxed)) {
   54|      0|      if (trans[i].done) return v;
   55|      0|    }
   56|      0|  }
   57|      0|}
   58|       |
   59|       |static std::atomic<uint64_t> delay_rand;
   60|       |
   61|       |// Return a suggested delay in nanoseconds for iteration number "loop"
   62|      0|int SpinLockSuggestedDelayNS(int loop) {
   63|      0|  // Weak pseudo-random number generator to get some spread between threads
   64|      0|  // when many are spinning.
   65|      0|  uint64_t r = delay_rand.load(std::memory_order_relaxed);
   66|      0|  r = 0x5deece66dLL * r + 0xb;   // numbers from nrand48()
   67|      0|  delay_rand.store(r, std::memory_order_relaxed);
   68|      0|
   69|      0|  if (loop < 0 || loop > 32) {   // limit loop to 0..32
   70|      0|    loop = 32;
   71|      0|  }
   72|      0|  const int kMinDelay = 128 << 10;  // 128us
   73|      0|  // Double delay every 8 iterations, up to 16x (2ms).
   74|      0|  int delay = kMinDelay << (loop / 8);
   75|      0|  // Randomize in delay..2*delay range, for resulting 128us..4ms range.
   76|      0|  return delay | ((delay - 1) & static_cast<int>(r));
   77|      0|}
   78|       |
   79|       |}  // namespace base_internal
   80|       |}  // inline namespace lts_2019_08_08
   81|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/spinlock_wait.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#ifndef ABSL_BASE_INTERNAL_SPINLOCK_WAIT_H_
   16|       |#define ABSL_BASE_INTERNAL_SPINLOCK_WAIT_H_
   17|       |
   18|       |// Operations to make atomic transitions on a word, and to allow
   19|       |// waiting for those transitions to become possible.
   20|       |
   21|       |#include <stdint.h>
   22|       |#include <atomic>
   23|       |
   24|       |#include "absl/base/internal/scheduling_mode.h"
   25|       |
   26|       |namespace absl {
   27|       |inline namespace lts_2019_08_08 {
   28|       |namespace base_internal {
   29|       |
   30|       |// SpinLockWait() waits until it can perform one of several transitions from
   31|       |// "from" to "to".  It returns when it performs a transition where done==true.
   32|       |struct SpinLockWaitTransition {
   33|       |  uint32_t from;
   34|       |  uint32_t to;
   35|       |  bool done;
   36|       |};
   37|       |
   38|       |// Wait until *w can transition from trans[i].from to trans[i].to for some i
   39|       |// satisfying 0<=i<n && trans[i].done, atomically make the transition,
   40|       |// then return the old value of *w.   Make any other atomic transitions
   41|       |// where !trans[i].done, but continue waiting.
   42|       |uint32_t SpinLockWait(std::atomic<uint32_t> *w, int n,
   43|       |                      const SpinLockWaitTransition trans[],
   44|       |                      SchedulingMode scheduling_mode);
   45|       |
   46|       |// If possible, wake some thread that has called SpinLockDelay(w, ...). If
   47|       |// "all" is true, wake all such threads.  This call is a hint, and on some
   48|       |// systems it may be a no-op; threads calling SpinLockDelay() will always wake
   49|       |// eventually even if SpinLockWake() is never called.
   50|       |void SpinLockWake(std::atomic<uint32_t> *w, bool all);
   51|       |
   52|       |// Wait for an appropriate spin delay on iteration "loop" of a
   53|       |// spin loop on location *w, whose previously observed value was "value".
   54|       |// SpinLockDelay() may do nothing, may yield the CPU, may sleep a clock tick,
   55|       |// or may wait for a delay that can be truncated by a call to SpinLockWake(w).
   56|       |// In all cases, it must return in bounded time even if SpinLockWake() is not
   57|       |// called.
   58|       |void SpinLockDelay(std::atomic<uint32_t> *w, uint32_t value, int loop,
   59|       |                   base_internal::SchedulingMode scheduling_mode);
   60|       |
   61|       |// Helper used by AbslInternalSpinLockDelay.
   62|       |// Returns a suggested delay in nanoseconds for iteration number "loop".
   63|       |int SpinLockSuggestedDelayNS(int loop);
   64|       |
   65|       |}  // namespace base_internal
   66|       |}  // inline namespace lts_2019_08_08
   67|       |}  // namespace absl
   68|       |
   69|       |// In some build configurations we pass --detect-odr-violations to the
   70|       |// gold linker.  This causes it to flag weak symbol overrides as ODR
   71|       |// violations.  Because ODR only applies to C++ and not C,
   72|       |// --detect-odr-violations ignores symbols not mangled with C++ names.
   73|       |// By changing our extension points to be extern "C", we dodge this
   74|       |// check.
   75|       |extern "C" {
   76|       |void AbslInternalSpinLockWake(std::atomic<uint32_t> *w, bool all);
   77|       |void AbslInternalSpinLockDelay(
   78|       |    std::atomic<uint32_t> *w, uint32_t value, int loop,
   79|       |    absl::base_internal::SchedulingMode scheduling_mode);
   80|       |}
   81|       |
   82|       |inline void absl::base_internal::SpinLockWake(std::atomic<uint32_t> *w,
   83|      0|                                              bool all) {
   84|      0|  AbslInternalSpinLockWake(w, all);
   85|      0|}
   86|       |
   87|       |inline void absl::base_internal::SpinLockDelay(
   88|       |    std::atomic<uint32_t> *w, uint32_t value, int loop,
   89|      0|    absl::base_internal::SchedulingMode scheduling_mode) {
   90|      0|  AbslInternalSpinLockDelay(w, value, loop, scheduling_mode);
   91|      0|}
   92|       |
   93|       |#endif  // ABSL_BASE_INTERNAL_SPINLOCK_WAIT_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/sysinfo.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/base/internal/sysinfo.h"
   16|       |
   17|       |#include "absl/base/attributes.h"
   18|       |
   19|       |#ifdef _WIN32
   20|       |#include <shlwapi.h>
   21|       |#include <windows.h>
   22|       |#else
   23|       |#include <fcntl.h>
   24|       |#include <pthread.h>
   25|       |#include <sys/stat.h>
   26|       |#include <sys/types.h>
   27|       |#include <unistd.h>
   28|       |#endif
   29|       |
   30|       |#ifdef __linux__
   31|       |#include <sys/syscall.h>
   32|       |#endif
   33|       |
   34|       |#if defined(__APPLE__) || defined(__FreeBSD__)
   35|       |#include <sys/sysctl.h>
   36|       |#endif
   37|       |
   38|       |#if defined(__myriad2__)
   39|       |#include <rtems.h>
   40|       |#endif
   41|       |
   42|       |#include <string.h>
   43|       |#include <cassert>
   44|       |#include <cstdint>
   45|       |#include <cstdio>
   46|       |#include <cstdlib>
   47|       |#include <ctime>
   48|       |#include <limits>
   49|       |#include <thread>  // NOLINT(build/c++11)
   50|       |#include <utility>
   51|       |#include <vector>
   52|       |
   53|       |#include "absl/base/call_once.h"
   54|       |#include "absl/base/internal/raw_logging.h"
   55|       |#include "absl/base/internal/spinlock.h"
   56|       |#include "absl/base/internal/unscaledcycleclock.h"
   57|       |
   58|       |namespace absl {
   59|       |inline namespace lts_2019_08_08 {
   60|       |namespace base_internal {
   61|       |
   62|       |static once_flag init_system_info_once;
   63|       |static int num_cpus = 0;
   64|       |static double nominal_cpu_frequency = 1.0;  // 0.0 might be dangerous.
   65|       |
   66|      0|static int GetNumCPUs() {
   67|       |#if defined(__myriad2__)
   68|       |  return 1;
   69|       |#else
   70|       |  // Other possibilities:
   71|      0|  //  - Read /sys/devices/system/cpu/online and use cpumask_parse()
   72|      0|  //  - sysconf(_SC_NPROCESSORS_ONLN)
   73|      0|  return std::thread::hardware_concurrency();
   74|      0|#endif
   75|      0|}
   76|       |
   77|       |#if defined(_WIN32)
   78|       |
   79|       |static double GetNominalCPUFrequency() {
   80|       |  DWORD data;
   81|       |  DWORD data_size = sizeof(data);
   82|       |  #pragma comment(lib, "shlwapi.lib")  // For SHGetValue().
   83|       |  if (SUCCEEDED(
   84|       |          SHGetValueA(HKEY_LOCAL_MACHINE,
   85|       |                      "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0",
   86|       |                      "~MHz", nullptr, &data, &data_size))) {
   87|       |    return data * 1e6;  // Value is MHz.
   88|       |  }
   89|       |  return 1.0;
   90|       |}
   91|       |
   92|       |#elif defined(CTL_HW) && defined(HW_CPU_FREQ)
   93|       |
   94|      0|static double GetNominalCPUFrequency() {
   95|      0|  unsigned freq;
   96|      0|  size_t size = sizeof(freq);
   97|      0|  int mib[2] = {CTL_HW, HW_CPU_FREQ};
   98|      0|  if (sysctl(mib, 2, &freq, &size, nullptr, 0) == 0) {
   99|      0|    return static_cast<double>(freq);
  100|      0|  }
  101|      0|  return 1.0;
  102|      0|}
  103|       |
  104|       |#else
  105|       |
  106|       |// Helper function for reading a long from a file. Returns true if successful
  107|       |// and the memory location pointed to by value is set to the value read.
  108|       |static bool ReadLongFromFile(const char *file, long *value) {
  109|       |  bool ret = false;
  110|       |  int fd = open(file, O_RDONLY);
  111|       |  if (fd != -1) {
  112|       |    char line[1024];
  113|       |    char *err;
  114|       |    memset(line, '\0', sizeof(line));
  115|       |    int len = read(fd, line, sizeof(line) - 1);
  116|       |    if (len <= 0) {
  117|       |      ret = false;
  118|       |    } else {
  119|       |      const long temp_value = strtol(line, &err, 10);
  120|       |      if (line[0] != '\0' && (*err == '\n' || *err == '\0')) {
  121|       |        *value = temp_value;
  122|       |        ret = true;
  123|       |      }
  124|       |    }
  125|       |    close(fd);
  126|       |  }
  127|       |  return ret;
  128|       |}
  129|       |
  130|       |#if defined(ABSL_INTERNAL_UNSCALED_CYCLECLOCK_FREQUENCY_IS_CPU_FREQUENCY)
  131|       |
  132|       |// Reads a monotonic time source and returns a value in
  133|       |// nanoseconds. The returned value uses an arbitrary epoch, not the
  134|       |// Unix epoch.
  135|       |static int64_t ReadMonotonicClockNanos() {
  136|       |  struct timespec t;
  137|       |#ifdef CLOCK_MONOTONIC_RAW
  138|       |  int rc = clock_gettime(CLOCK_MONOTONIC_RAW, &t);
  139|       |#else
  140|       |  int rc = clock_gettime(CLOCK_MONOTONIC, &t);
  141|       |#endif
  142|       |  if (rc != 0) {
  143|       |    perror("clock_gettime() failed");
  144|       |    abort();
  145|       |  }
  146|       |  return int64_t{t.tv_sec} * 1000000000 + t.tv_nsec;
  147|       |}
  148|       |
  149|       |class UnscaledCycleClockWrapperForInitializeFrequency {
  150|       | public:
  151|       |  static int64_t Now() { return base_internal::UnscaledCycleClock::Now(); }
  152|       |};
  153|       |
  154|       |struct TimeTscPair {
  155|       |  int64_t time;  // From ReadMonotonicClockNanos().
  156|       |  int64_t tsc;   // From UnscaledCycleClock::Now().
  157|       |};
  158|       |
  159|       |// Returns a pair of values (monotonic kernel time, TSC ticks) that
  160|       |// approximately correspond to each other.  This is accomplished by
  161|       |// doing several reads and picking the reading with the lowest
  162|       |// latency.  This approach is used to minimize the probability that
  163|       |// our thread was preempted between clock reads.
  164|       |static TimeTscPair GetTimeTscPair() {
  165|       |  int64_t best_latency = std::numeric_limits<int64_t>::max();
  166|       |  TimeTscPair best;
  167|       |  for (int i = 0; i < 10; ++i) {
  168|       |    int64_t t0 = ReadMonotonicClockNanos();
  169|       |    int64_t tsc = UnscaledCycleClockWrapperForInitializeFrequency::Now();
  170|       |    int64_t t1 = ReadMonotonicClockNanos();
  171|       |    int64_t latency = t1 - t0;
  172|       |    if (latency < best_latency) {
  173|       |      best_latency = latency;
  174|       |      best.time = t0;
  175|       |      best.tsc = tsc;
  176|       |    }
  177|       |  }
  178|       |  return best;
  179|       |}
  180|       |
  181|       |// Measures and returns the TSC frequency by taking a pair of
  182|       |// measurements approximately `sleep_nanoseconds` apart.
  183|       |static double MeasureTscFrequencyWithSleep(int sleep_nanoseconds) {
  184|       |  auto t0 = GetTimeTscPair();
  185|       |  struct timespec ts;
  186|       |  ts.tv_sec = 0;
  187|       |  ts.tv_nsec = sleep_nanoseconds;
  188|       |  while (nanosleep(&ts, &ts) != 0 && errno == EINTR) {}
  189|       |  auto t1 = GetTimeTscPair();
  190|       |  double elapsed_ticks = t1.tsc - t0.tsc;
  191|       |  double elapsed_time = (t1.time - t0.time) * 1e-9;
  192|       |  return elapsed_ticks / elapsed_time;
  193|       |}
  194|       |
  195|       |// Measures and returns the TSC frequency by calling
  196|       |// MeasureTscFrequencyWithSleep(), doubling the sleep interval until the
  197|       |// frequency measurement stabilizes.
  198|       |static double MeasureTscFrequency() {
  199|       |  double last_measurement = -1.0;
  200|       |  int sleep_nanoseconds = 1000000;  // 1 millisecond.
  201|       |  for (int i = 0; i < 8; ++i) {
  202|       |    double measurement = MeasureTscFrequencyWithSleep(sleep_nanoseconds);
  203|       |    if (measurement * 0.99 < last_measurement &&
  204|       |        last_measurement < measurement * 1.01) {
  205|       |      // Use the current measurement if it is within 1% of the
  206|       |      // previous measurement.
  207|       |      return measurement;
  208|       |    }
  209|       |    last_measurement = measurement;
  210|       |    sleep_nanoseconds *= 2;
  211|       |  }
  212|       |  return last_measurement;
  213|       |}
  214|       |
  215|       |#endif  // ABSL_INTERNAL_UNSCALED_CYCLECLOCK_FREQUENCY_IS_CPU_FREQUENCY
  216|       |
  217|       |static double GetNominalCPUFrequency() {
  218|       |  long freq = 0;
  219|       |
  220|       |  // Google's production kernel has a patch to export the TSC
  221|       |  // frequency through sysfs. If the kernel is exporting the TSC
  222|       |  // frequency use that. There are issues where cpuinfo_max_freq
  223|       |  // cannot be relied on because the BIOS may be exporting an invalid
  224|       |  // p-state (on x86) or p-states may be used to put the processor in
  225|       |  // a new mode (turbo mode). Essentially, those frequencies cannot
  226|       |  // always be relied upon. The same reasons apply to /proc/cpuinfo as
  227|       |  // well.
  228|       |  if (ReadLongFromFile("/sys/devices/system/cpu/cpu0/tsc_freq_khz", &freq)) {
  229|       |    return freq * 1e3;  // Value is kHz.
  230|       |  }
  231|       |
  232|       |#if defined(ABSL_INTERNAL_UNSCALED_CYCLECLOCK_FREQUENCY_IS_CPU_FREQUENCY)
  233|       |  // On these platforms, the TSC frequency is the nominal CPU
  234|       |  // frequency.  But without having the kernel export it directly
  235|       |  // though /sys/devices/system/cpu/cpu0/tsc_freq_khz, there is no
  236|       |  // other way to reliably get the TSC frequency, so we have to
  237|       |  // measure it ourselves.  Some CPUs abuse cpuinfo_max_freq by
  238|       |  // exporting "fake" frequencies for implementing new features. For
  239|       |  // example, Intel's turbo mode is enabled by exposing a p-state
  240|       |  // value with a higher frequency than that of the real TSC
  241|       |  // rate. Because of this, we prefer to measure the TSC rate
  242|       |  // ourselves on i386 and x86-64.
  243|       |  return MeasureTscFrequency();
  244|       |#else
  245|       |
  246|       |  // If CPU scaling is in effect, we want to use the *maximum*
  247|       |  // frequency, not whatever CPU speed some random processor happens
  248|       |  // to be using now.
  249|       |  if (ReadLongFromFile("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq",
  250|       |                       &freq)) {
  251|       |    return freq * 1e3;  // Value is kHz.
  252|       |  }
  253|       |
  254|       |  return 1.0;
  255|       |#endif  // !ABSL_INTERNAL_UNSCALED_CYCLECLOCK_FREQUENCY_IS_CPU_FREQUENCY
  256|       |}
  257|       |
  258|       |#endif
  259|       |
  260|       |// InitializeSystemInfo() may be called before main() and before
  261|       |// malloc is properly initialized, therefore this must not allocate
  262|       |// memory.
  263|      0|static void InitializeSystemInfo() {
  264|      0|  num_cpus = GetNumCPUs();
  265|      0|  nominal_cpu_frequency = GetNominalCPUFrequency();
  266|      0|}
  267|       |
  268|      0|int NumCPUs() {
  269|      0|  base_internal::LowLevelCallOnce(&init_system_info_once, InitializeSystemInfo);
  270|      0|  return num_cpus;
  271|      0|}
  272|       |
  273|      0|double NominalCPUFrequency() {
  274|      0|  base_internal::LowLevelCallOnce(&init_system_info_once, InitializeSystemInfo);
  275|      0|  return nominal_cpu_frequency;
  276|      0|}
  277|       |
  278|       |#if defined(_WIN32)
  279|       |
  280|       |pid_t GetTID() {
  281|       |  return GetCurrentThreadId();
  282|       |}
  283|       |
  284|       |#elif defined(__linux__)
  285|       |
  286|       |#ifndef SYS_gettid
  287|       |#define SYS_gettid __NR_gettid
  288|       |#endif
  289|       |
  290|       |pid_t GetTID() {
  291|       |  return syscall(SYS_gettid);
  292|       |}
  293|       |
  294|       |#elif defined(__akaros__)
  295|       |
  296|       |pid_t GetTID() {
  297|       |  // Akaros has a concept of "vcore context", which is the state the program
  298|       |  // is forced into when we need to make a user-level scheduling decision, or
  299|       |  // run a signal handler.  This is analogous to the interrupt context that a
  300|       |  // CPU might enter if it encounters some kind of exception.
  301|       |  //
  302|       |  // There is no current thread context in vcore context, but we need to give
  303|       |  // a reasonable answer if asked for a thread ID (e.g., in a signal handler).
  304|       |  // Thread 0 always exists, so if we are in vcore context, we return that.
  305|       |  //
  306|       |  // Otherwise, we know (since we are using pthreads) that the uthread struct
  307|       |  // current_uthread is pointing to is the first element of a
  308|       |  // struct pthread_tcb, so we extract and return the thread ID from that.
  309|       |  //
  310|       |  // TODO(dcross): Akaros anticipates moving the thread ID to the uthread
  311|       |  // structure at some point. We should modify this code to remove the cast
  312|       |  // when that happens.
  313|       |  if (in_vcore_context())
  314|       |    return 0;
  315|       |  return reinterpret_cast<struct pthread_tcb *>(current_uthread)->id;
  316|       |}
  317|       |
  318|       |#elif defined(__myriad2__)
  319|       |
  320|       |pid_t GetTID() {
  321|       |  uint32_t tid;
  322|       |  rtems_task_ident(RTEMS_SELF, 0, &tid);
  323|       |  return tid;
  324|       |}
  325|       |
  326|       |#else
  327|       |
  328|       |// Fallback implementation of GetTID using pthread_getspecific.
  329|       |static once_flag tid_once;
  330|       |static pthread_key_t tid_key;
  331|       |static absl::base_internal::SpinLock tid_lock(
  332|       |    absl::base_internal::kLinkerInitialized);
  333|       |
  334|       |// We set a bit per thread in this array to indicate that an ID is in
  335|       |// use. ID 0 is unused because it is the default value returned by
  336|       |// pthread_getspecific().
  337|       |static std::vector<uint32_t>* tid_array GUARDED_BY(tid_lock) = nullptr;
  338|       |static constexpr int kBitsPerWord = 32;  // tid_array is uint32_t.
  339|       |
  340|       |// Returns the TID to tid_array.
  341|      0|static void FreeTID(void *v) {
  342|      0|  intptr_t tid = reinterpret_cast<intptr_t>(v);
  343|      0|  int word = tid / kBitsPerWord;
  344|      0|  uint32_t mask = ~(1u << (tid % kBitsPerWord));
  345|      0|  absl::base_internal::SpinLockHolder lock(&tid_lock);
  346|      0|  assert(0 <= word && static_cast<size_t>(word) < tid_array->size());
  347|      0|  (*tid_array)[word] &= mask;
  348|      0|}
  349|       |
  350|      0|static void InitGetTID() {
  351|      0|  if (pthread_key_create(&tid_key, FreeTID) != 0) {
  352|      0|    // The logging system calls GetTID() so it can't be used here.
  353|      0|    perror("pthread_key_create failed");
  354|      0|    abort();
  355|      0|  }
  356|      0|
  357|      0|  // Initialize tid_array.
  358|      0|  absl::base_internal::SpinLockHolder lock(&tid_lock);
  359|      0|  tid_array = new std::vector<uint32_t>(1);
  360|      0|  (*tid_array)[0] = 1;  // ID 0 is never-allocated.
  361|      0|}
  362|       |
  363|       |// Return a per-thread small integer ID from pthread's thread-specific data.
  364|      0|pid_t GetTID() {
  365|      0|  absl::call_once(tid_once, InitGetTID);
  366|      0|
  367|      0|  intptr_t tid = reinterpret_cast<intptr_t>(pthread_getspecific(tid_key));
  368|      0|  if (tid != 0) {
  369|      0|    return tid;
  370|      0|  }
  371|      0|
  372|      0|  int bit;  // tid_array[word] = 1u << bit;
  373|      0|  size_t word;
  374|      0|  {
  375|      0|    // Search for the first unused ID.
  376|      0|    absl::base_internal::SpinLockHolder lock(&tid_lock);
  377|      0|    // First search for a word in the array that is not all ones.
  378|      0|    word = 0;
  379|      0|    while (word < tid_array->size() && ~(*tid_array)[word] == 0) {
  380|      0|      ++word;
  381|      0|    }
  382|      0|    if (word == tid_array->size()) {
  383|      0|      tid_array->push_back(0);  // No space left, add kBitsPerWord more IDs.
  384|      0|    }
  385|      0|    // Search for a zero bit in the word.
  386|      0|    bit = 0;
  387|      0|    while (bit < kBitsPerWord && (((*tid_array)[word] >> bit) & 1) != 0) {
  388|      0|      ++bit;
  389|      0|    }
  390|      0|    tid = (word * kBitsPerWord) + bit;
  391|      0|    (*tid_array)[word] |= 1u << bit;  // Mark the TID as allocated.
  392|      0|  }
  393|      0|
  394|      0|  if (pthread_setspecific(tid_key, reinterpret_cast<void *>(tid)) != 0) {
  395|      0|    perror("pthread_setspecific failed");
  396|      0|    abort();
  397|      0|  }
  398|      0|
  399|      0|  return static_cast<pid_t>(tid);
  400|      0|}
  401|       |
  402|       |#endif
  403|       |
  404|       |}  // namespace base_internal
  405|       |}  // inline namespace lts_2019_08_08
  406|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/thread_identity.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/base/internal/thread_identity.h"
   16|       |
   17|       |#ifndef _WIN32
   18|       |#include <pthread.h>
   19|       |#include <signal.h>
   20|       |#endif
   21|       |
   22|       |#include <atomic>
   23|       |#include <cassert>
   24|       |#include <memory>
   25|       |
   26|       |#include "absl/base/call_once.h"
   27|       |#include "absl/base/internal/raw_logging.h"
   28|       |#include "absl/base/internal/spinlock.h"
   29|       |
   30|       |namespace absl {
   31|       |inline namespace lts_2019_08_08 {
   32|       |namespace base_internal {
   33|       |
   34|       |#if ABSL_THREAD_IDENTITY_MODE != ABSL_THREAD_IDENTITY_MODE_USE_CPP11
   35|       |namespace {
   36|       |// Used to co-ordinate one-time creation of our pthread_key
   37|       |absl::once_flag init_thread_identity_key_once;
   38|       |pthread_key_t thread_identity_pthread_key;
   39|       |std::atomic<bool> pthread_key_initialized(false);
   40|       |
   41|      0|void AllocateThreadIdentityKey(ThreadIdentityReclaimerFunction reclaimer) {
   42|      0|  pthread_key_create(&thread_identity_pthread_key, reclaimer);
   43|      0|  pthread_key_initialized.store(true, std::memory_order_release);
   44|      0|}
   45|       |}  // namespace
   46|       |#endif
   47|       |
   48|       |#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_TLS || \
   49|       |    ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_CPP11
   50|       |// The actual TLS storage for a thread's currently associated ThreadIdentity.
   51|       |// This is referenced by inline accessors in the header.
   52|       |// "protected" visibility ensures that if multiple instances of Abseil code
   53|       |// exist within a process (via dlopen() or similar), references to
   54|       |// thread_identity_ptr from each instance of the code will refer to
   55|       |// *different* instances of this ptr.
   56|       |#ifdef __GNUC__
   57|       |__attribute__((visibility("protected")))
   58|       |#endif  // __GNUC__
   59|       |  ABSL_PER_THREAD_TLS_KEYWORD ThreadIdentity* thread_identity_ptr;
   60|       |#endif  // TLS or CPP11
   61|       |
   62|       |void SetCurrentThreadIdentity(
   63|      0|    ThreadIdentity* identity, ThreadIdentityReclaimerFunction reclaimer) {
   64|      0|  assert(CurrentThreadIdentityIfPresent() == nullptr);
   65|      0|  // Associate our destructor.
   66|      0|  // NOTE: This call to pthread_setspecific is currently the only immovable
   67|      0|  // barrier to CurrentThreadIdentity() always being async signal safe.
   68|      0|#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC
   69|      0|  // NOTE: Not async-safe.  But can be open-coded.
   70|      0|  absl::call_once(init_thread_identity_key_once, AllocateThreadIdentityKey,
   71|      0|                  reclaimer);
   72|      0|
   73|       |#ifdef __EMSCRIPTEN__
   74|       |  // Emscripten PThread implementation does not support signals.
   75|       |  // See https://kripken.github.io/emscripten-site/docs/porting/pthreads.html
   76|       |  // for more information.
   77|       |  pthread_setspecific(thread_identity_pthread_key,
   78|       |                      reinterpret_cast<void*>(identity));
   79|       |#else
   80|       |  // We must mask signals around the call to setspecific as with current glibc,
   81|      0|  // a concurrent getspecific (needed for GetCurrentThreadIdentityIfPresent())
   82|      0|  // may zero our value.
   83|      0|  //
   84|      0|  // While not officially async-signal safe, getspecific within a signal handler
   85|      0|  // is otherwise OK.
   86|      0|  sigset_t all_signals;
   87|      0|  sigset_t curr_signals;
   88|      0|  sigfillset(&all_signals);
   89|      0|  pthread_sigmask(SIG_SETMASK, &all_signals, &curr_signals);
   90|      0|  pthread_setspecific(thread_identity_pthread_key,
   91|      0|                      reinterpret_cast<void*>(identity));
   92|      0|  pthread_sigmask(SIG_SETMASK, &curr_signals, nullptr);
   93|      0|#endif  // !__EMSCRIPTEN__
   94|      0|
   95|       |#elif ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_TLS
   96|       |  // NOTE: Not async-safe.  But can be open-coded.
   97|       |  absl::call_once(init_thread_identity_key_once, AllocateThreadIdentityKey,
   98|       |                  reclaimer);
   99|       |  pthread_setspecific(thread_identity_pthread_key,
  100|       |                      reinterpret_cast<void*>(identity));
  101|       |  thread_identity_ptr = identity;
  102|       |#elif ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_CPP11
  103|       |  thread_local std::unique_ptr<ThreadIdentity, ThreadIdentityReclaimerFunction>
  104|       |      holder(identity, reclaimer);
  105|       |  thread_identity_ptr = identity;
  106|       |#else
  107|       |#error Unimplemented ABSL_THREAD_IDENTITY_MODE
  108|       |#endif
  109|       |}
  110|       |
  111|      0|void ClearCurrentThreadIdentity() {
  112|       |#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_TLS || \
  113|       |    ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_CPP11
  114|       |  thread_identity_ptr = nullptr;
  115|       |#elif ABSL_THREAD_IDENTITY_MODE == \
  116|       |      ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC
  117|       |  // pthread_setspecific expected to clear value on destruction
  118|      0|  assert(CurrentThreadIdentityIfPresent() == nullptr);
  119|      0|#endif
  120|      0|}
  121|       |
  122|       |#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC
  123|      0|ThreadIdentity* CurrentThreadIdentityIfPresent() {
  124|      0|  bool initialized = pthread_key_initialized.load(std::memory_order_acquire);
  125|      0|  if (!initialized) {
  126|      0|    return nullptr;
  127|      0|  }
  128|      0|  return reinterpret_cast<ThreadIdentity*>(
  129|      0|      pthread_getspecific(thread_identity_pthread_key));
  130|      0|}
  131|       |#endif
  132|       |
  133|       |}  // namespace base_internal
  134|       |}  // inline namespace lts_2019_08_08
  135|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/thread_identity.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// Each active thread has an ThreadIdentity that may represent the thread in
   16|       |// various level interfaces.  ThreadIdentity objects are never deallocated.
   17|       |// When a thread terminates, its ThreadIdentity object may be reused for a
   18|       |// thread created later.
   19|       |
   20|       |#ifndef ABSL_BASE_INTERNAL_THREAD_IDENTITY_H_
   21|       |#define ABSL_BASE_INTERNAL_THREAD_IDENTITY_H_
   22|       |
   23|       |#ifndef _WIN32
   24|       |#include <pthread.h>
   25|       |// Defines __GOOGLE_GRTE_VERSION__ (via glibc-specific features.h) when
   26|       |// supported.
   27|       |#include <unistd.h>
   28|       |#endif
   29|       |
   30|       |#include <atomic>
   31|       |#include <cstdint>
   32|       |
   33|       |#include "absl/base/internal/per_thread_tls.h"
   34|       |
   35|       |namespace absl {
   36|       |inline namespace lts_2019_08_08 {
   37|       |
   38|       |struct SynchLocksHeld;
   39|       |struct SynchWaitParams;
   40|       |
   41|       |namespace base_internal {
   42|       |
   43|       |class SpinLock;
   44|       |struct ThreadIdentity;
   45|       |
   46|       |// Used by the implementation of absl::Mutex and absl::CondVar.
   47|       |struct PerThreadSynch {
   48|       |  // The internal representation of absl::Mutex and absl::CondVar rely
   49|       |  // on the alignment of PerThreadSynch. Both store the address of the
   50|       |  // PerThreadSynch in the high-order bits of their internal state,
   51|       |  // which means the low kLowZeroBits of the address of PerThreadSynch
   52|       |  // must be zero.
   53|       |  static constexpr int kLowZeroBits = 8;
   54|       |  static constexpr int kAlignment = 1 << kLowZeroBits;
   55|       |
   56|       |  // Returns the associated ThreadIdentity.
   57|       |  // This can be implemented as a cast because we guarantee
   58|       |  // PerThreadSynch is the first element of ThreadIdentity.
   59|      0|  ThreadIdentity* thread_identity() {
   60|      0|    return reinterpret_cast<ThreadIdentity*>(this);
   61|      0|  }
   62|       |
   63|       |  PerThreadSynch *next;  // Circular waiter queue; initialized to 0.
   64|       |  PerThreadSynch *skip;  // If non-zero, all entries in Mutex queue
   65|       |                         // up to and including "skip" have same
   66|       |                         // condition as this, and will be woken later
   67|       |  bool may_skip;         // if false while on mutex queue, a mutex unlocker
   68|       |                         // is using this PerThreadSynch as a terminator.  Its
   69|       |                         // skip field must not be filled in because the loop
   70|       |                         // might then skip over the terminator.
   71|       |
   72|       |  // The wait parameters of the current wait.  waitp is null if the
   73|       |  // thread is not waiting. Transitions from null to non-null must
   74|       |  // occur before the enqueue commit point (state = kQueued in
   75|       |  // Enqueue() and CondVarEnqueue()). Transitions from non-null to
   76|       |  // null must occur after the wait is finished (state = kAvailable in
   77|       |  // Mutex::Block() and CondVar::WaitCommon()). This field may be
   78|       |  // changed only by the thread that describes this PerThreadSynch.  A
   79|       |  // special case is Fer(), which calls Enqueue() on another thread,
   80|       |  // but with an identical SynchWaitParams pointer, thus leaving the
   81|       |  // pointer unchanged.
   82|       |  SynchWaitParams *waitp;
   83|       |
   84|       |  bool suppress_fatal_errors;  // If true, try to proceed even in the face of
   85|       |                               // broken invariants.  This is used within fatal
   86|       |                               // signal handlers to improve the chances of
   87|       |                               // debug logging information being output
   88|       |                               // successfully.
   89|       |
   90|       |  intptr_t readers;     // Number of readers in mutex.
   91|       |  int priority;         // Priority of thread (updated every so often).
   92|       |
   93|       |  // When priority will next be read (cycles).
   94|       |  int64_t next_priority_read_cycles;
   95|       |
   96|       |  // State values:
   97|       |  //   kAvailable: This PerThreadSynch is available.
   98|       |  //   kQueued: This PerThreadSynch is unavailable, it's currently queued on a
   99|       |  //            Mutex or CondVar waistlist.
  100|       |  //
  101|       |  // Transitions from kQueued to kAvailable require a release
  102|       |  // barrier. This is needed as a waiter may use "state" to
  103|       |  // independently observe that it's no longer queued.
  104|       |  //
  105|       |  // Transitions from kAvailable to kQueued require no barrier, they
  106|       |  // are externally ordered by the Mutex.
  107|       |  enum State {
  108|       |    kAvailable,
  109|       |    kQueued
  110|       |  };
  111|       |  std::atomic<State> state;
  112|       |
  113|       |  bool maybe_unlocking;  // Valid at head of Mutex waiter queue;
  114|       |                         // true if UnlockSlow could be searching
  115|       |                         // for a waiter to wake.  Used for an optimization
  116|       |                         // in Enqueue().  true is always a valid value.
  117|       |                         // Can be reset to false when the unlocker or any
  118|       |                         // writer releases the lock, or a reader fully releases
  119|       |                         // the lock.  It may not be set to false by a reader
  120|       |                         // that decrements the count to non-zero.
  121|       |                         // protected by mutex spinlock
  122|       |
  123|       |  bool wake;  // This thread is to be woken from a Mutex.
  124|       |
  125|       |  // If "x" is on a waiter list for a mutex, "x->cond_waiter" is true iff the
  126|       |  // waiter is waiting on the mutex as part of a CV Wait or Mutex Await.
  127|       |  //
  128|       |  // The value of "x->cond_waiter" is meaningless if "x" is not on a
  129|       |  // Mutex waiter list.
  130|       |  bool cond_waiter;
  131|       |
  132|       |  // Locks held; used during deadlock detection.
  133|       |  // Allocated in Synch_GetAllLocks() and freed in ReclaimThreadIdentity().
  134|       |  SynchLocksHeld *all_locks;
  135|       |};
  136|       |
  137|       |struct ThreadIdentity {
  138|       |  // Must be the first member.  The Mutex implementation requires that
  139|       |  // the PerThreadSynch object associated with each thread is
  140|       |  // PerThreadSynch::kAlignment aligned.  We provide this alignment on
  141|       |  // ThreadIdentity itself.
  142|       |  PerThreadSynch per_thread_synch;
  143|       |
  144|       |  // Private: Reserved for absl::synchronization_internal::Waiter.
  145|       |  struct WaiterState {
  146|       |    char data[128];
  147|       |  } waiter_state;
  148|       |
  149|       |  // Used by PerThreadSem::{Get,Set}ThreadBlockedCounter().
  150|       |  std::atomic<int>* blocked_count_ptr;
  151|       |
  152|       |  // The following variables are mostly read/written just by the
  153|       |  // thread itself.  The only exception is that these are read by
  154|       |  // a ticker thread as a hint.
  155|       |  std::atomic<int> ticker;      // Tick counter, incremented once per second.
  156|       |  std::atomic<int> wait_start;  // Ticker value when thread started waiting.
  157|       |  std::atomic<bool> is_idle;    // Has thread become idle yet?
  158|       |
  159|       |  ThreadIdentity* next;
  160|       |};
  161|       |
  162|       |// Returns the ThreadIdentity object representing the calling thread; guaranteed
  163|       |// to be unique for its lifetime.  The returned object will remain valid for the
  164|       |// program's lifetime; although it may be re-assigned to a subsequent thread.
  165|       |// If one does not exist, return nullptr instead.
  166|       |//
  167|       |// Does not malloc(*), and is async-signal safe.
  168|       |// [*] Technically pthread_setspecific() does malloc on first use; however this
  169|       |// is handled internally within tcmalloc's initialization already.
  170|       |//
  171|       |// New ThreadIdentity objects can be constructed and associated with a thread
  172|       |// by calling GetOrCreateCurrentThreadIdentity() in per-thread-sem.h.
  173|       |ThreadIdentity* CurrentThreadIdentityIfPresent();
  174|       |
  175|       |using ThreadIdentityReclaimerFunction = void (*)(void*);
  176|       |
  177|       |// Sets the current thread identity to the given value.  'reclaimer' is a
  178|       |// pointer to the global function for cleaning up instances on thread
  179|       |// destruction.
  180|       |void SetCurrentThreadIdentity(ThreadIdentity* identity,
  181|       |                              ThreadIdentityReclaimerFunction reclaimer);
  182|       |
  183|       |// Removes the currently associated ThreadIdentity from the running thread.
  184|       |// This must be called from inside the ThreadIdentityReclaimerFunction, and only
  185|       |// from that function.
  186|       |void ClearCurrentThreadIdentity();
  187|       |
  188|       |// May be chosen at compile time via: -DABSL_FORCE_THREAD_IDENTITY_MODE=<mode
  189|       |// index>
  190|       |#ifdef ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC
  191|       |#error ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC cannot be direcly set
  192|       |#else
  193|       |#define ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC 0
  194|       |#endif
  195|       |
  196|       |#ifdef ABSL_THREAD_IDENTITY_MODE_USE_TLS
  197|       |#error ABSL_THREAD_IDENTITY_MODE_USE_TLS cannot be direcly set
  198|       |#else
  199|       |#define ABSL_THREAD_IDENTITY_MODE_USE_TLS 1
  200|       |#endif
  201|       |
  202|       |#ifdef ABSL_THREAD_IDENTITY_MODE_USE_CPP11
  203|       |#error ABSL_THREAD_IDENTITY_MODE_USE_CPP11 cannot be direcly set
  204|       |#else
  205|       |#define ABSL_THREAD_IDENTITY_MODE_USE_CPP11 2
  206|       |#endif
  207|       |
  208|       |#ifdef ABSL_THREAD_IDENTITY_MODE
  209|       |#error ABSL_THREAD_IDENTITY_MODE cannot be direcly set
  210|       |#elif defined(ABSL_FORCE_THREAD_IDENTITY_MODE)
  211|       |#define ABSL_THREAD_IDENTITY_MODE ABSL_FORCE_THREAD_IDENTITY_MODE
  212|       |#elif defined(_WIN32)
  213|       |#define ABSL_THREAD_IDENTITY_MODE ABSL_THREAD_IDENTITY_MODE_USE_CPP11
  214|       |#elif ABSL_PER_THREAD_TLS && defined(__GOOGLE_GRTE_VERSION__) && \
  215|       |    (__GOOGLE_GRTE_VERSION__ >= 20140228L)
  216|       |// Support for async-safe TLS was specifically added in GRTEv4.  It's not
  217|       |// present in the upstream eglibc.
  218|       |// Note:  Current default for production systems.
  219|       |#define ABSL_THREAD_IDENTITY_MODE ABSL_THREAD_IDENTITY_MODE_USE_TLS
  220|       |#else
  221|       |#define ABSL_THREAD_IDENTITY_MODE \
  222|       |  ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC
  223|       |#endif
  224|       |
  225|       |#if ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_TLS || \
  226|       |    ABSL_THREAD_IDENTITY_MODE == ABSL_THREAD_IDENTITY_MODE_USE_CPP11
  227|       |
  228|       |extern ABSL_PER_THREAD_TLS_KEYWORD ThreadIdentity* thread_identity_ptr;
  229|       |
  230|       |inline ThreadIdentity* CurrentThreadIdentityIfPresent() {
  231|       |  return thread_identity_ptr;
  232|       |}
  233|       |
  234|       |#elif ABSL_THREAD_IDENTITY_MODE != \
  235|       |    ABSL_THREAD_IDENTITY_MODE_USE_POSIX_SETSPECIFIC
  236|       |#error Unknown ABSL_THREAD_IDENTITY_MODE
  237|       |#endif
  238|       |
  239|       |}  // namespace base_internal
  240|       |}  // inline namespace lts_2019_08_08
  241|       |}  // namespace absl
  242|       |
  243|       |#endif  // ABSL_BASE_INTERNAL_THREAD_IDENTITY_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/throw_delegate.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/base/internal/throw_delegate.h"
   16|       |
   17|       |#include <cstdlib>
   18|       |#include <functional>
   19|       |#include <new>
   20|       |#include <stdexcept>
   21|       |#include "absl/base/config.h"
   22|       |#include "absl/base/internal/raw_logging.h"
   23|       |
   24|       |namespace absl {
   25|       |inline namespace lts_2019_08_08 {
   26|       |namespace base_internal {
   27|       |
   28|       |namespace {
   29|       |template <typename T>
   30|      0|[[noreturn]] void Throw(const T& error) {
   31|      0|#ifdef ABSL_HAVE_EXCEPTIONS
   32|      0|  throw error;
   33|       |#else
   34|       |  ABSL_RAW_LOG(FATAL, "%s", error.what());
   35|       |  std::abort();
   36|       |#endif
   37|       |}
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt11logic_errorEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt16invalid_argumentEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt12domain_errorEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt12length_errorEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt12out_of_rangeEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt13runtime_errorEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt11range_errorEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt14overflow_errorEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt15underflow_errorEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowINSt3__117bad_function_callEEEvRKT_
  ------------------
  | Unexecuted instantiation: throw_delegate.cc:_ZN4absl14lts_2019_08_0813base_internal12_GLOBAL__N_15ThrowISt9bad_allocEEvRKT_
  ------------------
   38|       |}  // namespace
   39|       |
   40|      0|void ThrowStdLogicError(const std::string& what_arg) {
   41|      0|  Throw(std::logic_error(what_arg));
   42|      0|}
   43|      0|void ThrowStdLogicError(const char* what_arg) {
   44|      0|  Throw(std::logic_error(what_arg));
   45|      0|}
   46|      0|void ThrowStdInvalidArgument(const std::string& what_arg) {
   47|      0|  Throw(std::invalid_argument(what_arg));
   48|      0|}
   49|      0|void ThrowStdInvalidArgument(const char* what_arg) {
   50|      0|  Throw(std::invalid_argument(what_arg));
   51|      0|}
   52|       |
   53|      0|void ThrowStdDomainError(const std::string& what_arg) {
   54|      0|  Throw(std::domain_error(what_arg));
   55|      0|}
   56|      0|void ThrowStdDomainError(const char* what_arg) {
   57|      0|  Throw(std::domain_error(what_arg));
   58|      0|}
   59|       |
   60|      0|void ThrowStdLengthError(const std::string& what_arg) {
   61|      0|  Throw(std::length_error(what_arg));
   62|      0|}
   63|      0|void ThrowStdLengthError(const char* what_arg) {
   64|      0|  Throw(std::length_error(what_arg));
   65|      0|}
   66|       |
   67|      0|void ThrowStdOutOfRange(const std::string& what_arg) {
   68|      0|  Throw(std::out_of_range(what_arg));
   69|      0|}
   70|      0|void ThrowStdOutOfRange(const char* what_arg) {
   71|      0|  Throw(std::out_of_range(what_arg));
   72|      0|}
   73|       |
   74|      0|void ThrowStdRuntimeError(const std::string& what_arg) {
   75|      0|  Throw(std::runtime_error(what_arg));
   76|      0|}
   77|      0|void ThrowStdRuntimeError(const char* what_arg) {
   78|      0|  Throw(std::runtime_error(what_arg));
   79|      0|}
   80|       |
   81|      0|void ThrowStdRangeError(const std::string& what_arg) {
   82|      0|  Throw(std::range_error(what_arg));
   83|      0|}
   84|      0|void ThrowStdRangeError(const char* what_arg) {
   85|      0|  Throw(std::range_error(what_arg));
   86|      0|}
   87|       |
   88|      0|void ThrowStdOverflowError(const std::string& what_arg) {
   89|      0|  Throw(std::overflow_error(what_arg));
   90|      0|}
   91|      0|void ThrowStdOverflowError(const char* what_arg) {
   92|      0|  Throw(std::overflow_error(what_arg));
   93|      0|}
   94|       |
   95|      0|void ThrowStdUnderflowError(const std::string& what_arg) {
   96|      0|  Throw(std::underflow_error(what_arg));
   97|      0|}
   98|      0|void ThrowStdUnderflowError(const char* what_arg) {
   99|      0|  Throw(std::underflow_error(what_arg));
  100|      0|}
  101|       |
  102|      0|void ThrowStdBadFunctionCall() { Throw(std::bad_function_call()); }
  103|       |
  104|      0|void ThrowStdBadAlloc() { Throw(std::bad_alloc()); }
  105|       |
  106|       |}  // namespace base_internal
  107|       |}  // inline namespace lts_2019_08_08
  108|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/internal/unaligned_access.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |
   17|       |#ifndef ABSL_BASE_INTERNAL_UNALIGNED_ACCESS_H_
   18|       |#define ABSL_BASE_INTERNAL_UNALIGNED_ACCESS_H_
   19|       |
   20|       |#include <string.h>
   21|       |#include <cstdint>
   22|       |
   23|       |#include "absl/base/attributes.h"
   24|       |
   25|       |// unaligned APIs
   26|       |
   27|       |// Portable handling of unaligned loads, stores, and copies.
   28|       |
   29|       |// The unaligned API is C++ only.  The declarations use C++ features
   30|       |// (namespaces, inline) which are absent or incompatible in C.
   31|       |#if defined(__cplusplus)
   32|       |
   33|       |#if defined(ADDRESS_SANITIZER) || defined(THREAD_SANITIZER) ||\
   34|       |    defined(MEMORY_SANITIZER)
   35|       |// Consider we have an unaligned load/store of 4 bytes from address 0x...05.
   36|       |// AddressSanitizer will treat it as a 3-byte access to the range 05:07 and
   37|       |// will miss a bug if 08 is the first unaddressable byte.
   38|       |// ThreadSanitizer will also treat this as a 3-byte access to 05:07 and will
   39|       |// miss a race between this access and some other accesses to 08.
   40|       |// MemorySanitizer will correctly propagate the shadow on unaligned stores
   41|       |// and correctly report bugs on unaligned loads, but it may not properly
   42|       |// update and report the origin of the uninitialized memory.
   43|       |// For all three tools, replacing an unaligned access with a tool-specific
   44|       |// callback solves the problem.
   45|       |
   46|       |// Make sure uint16_t/uint32_t/uint64_t are defined.
   47|       |#include <stdint.h>
   48|       |
   49|       |extern "C" {
   50|       |uint16_t __sanitizer_unaligned_load16(const void *p);
   51|       |uint32_t __sanitizer_unaligned_load32(const void *p);
   52|       |uint64_t __sanitizer_unaligned_load64(const void *p);
   53|       |void __sanitizer_unaligned_store16(void *p, uint16_t v);
   54|       |void __sanitizer_unaligned_store32(void *p, uint32_t v);
   55|       |void __sanitizer_unaligned_store64(void *p, uint64_t v);
   56|       |}  // extern "C"
   57|       |
   58|       |namespace absl {
   59|       |inline namespace lts_2019_08_08 {
   60|       |namespace base_internal {
   61|       |
   62|       |inline uint16_t UnalignedLoad16(const void *p) {
   63|       |  return __sanitizer_unaligned_load16(p);
   64|       |}
   65|       |
   66|       |inline uint32_t UnalignedLoad32(const void *p) {
   67|       |  return __sanitizer_unaligned_load32(p);
   68|       |}
   69|       |
   70|       |inline uint64_t UnalignedLoad64(const void *p) {
   71|       |  return __sanitizer_unaligned_load64(p);
   72|       |}
   73|       |
   74|       |inline void UnalignedStore16(void *p, uint16_t v) {
   75|       |  __sanitizer_unaligned_store16(p, v);
   76|       |}
   77|       |
   78|       |inline void UnalignedStore32(void *p, uint32_t v) {
   79|       |  __sanitizer_unaligned_store32(p, v);
   80|       |}
   81|       |
   82|       |inline void UnalignedStore64(void *p, uint64_t v) {
   83|       |  __sanitizer_unaligned_store64(p, v);
   84|       |}
   85|       |
   86|       |}  // namespace base_internal
   87|       |}  // inline namespace lts_2019_08_08
   88|       |}  // namespace absl
   89|       |
   90|       |#define ABSL_INTERNAL_UNALIGNED_LOAD16(_p) \
   91|       |  (absl::base_internal::UnalignedLoad16(_p))
   92|       |#define ABSL_INTERNAL_UNALIGNED_LOAD32(_p) \
   93|       |  (absl::base_internal::UnalignedLoad32(_p))
   94|       |#define ABSL_INTERNAL_UNALIGNED_LOAD64(_p) \
   95|       |  (absl::base_internal::UnalignedLoad64(_p))
   96|       |
   97|       |#define ABSL_INTERNAL_UNALIGNED_STORE16(_p, _val) \
   98|       |  (absl::base_internal::UnalignedStore16(_p, _val))
   99|       |#define ABSL_INTERNAL_UNALIGNED_STORE32(_p, _val) \
  100|       |  (absl::base_internal::UnalignedStore32(_p, _val))
  101|       |#define ABSL_INTERNAL_UNALIGNED_STORE64(_p, _val) \
  102|       |  (absl::base_internal::UnalignedStore64(_p, _val))
  103|       |
  104|       |#else
  105|       |
  106|       |namespace absl {
  107|       |inline namespace lts_2019_08_08 {
  108|       |namespace base_internal {
  109|       |
  110|      0|inline uint16_t UnalignedLoad16(const void *p) {
  111|      0|  uint16_t t;
  112|      0|  memcpy(&t, p, sizeof t);
  113|      0|  return t;
  114|      0|}
  115|       |
  116|      0|inline uint32_t UnalignedLoad32(const void *p) {
  117|      0|  uint32_t t;
  118|      0|  memcpy(&t, p, sizeof t);
  119|      0|  return t;
  120|      0|}
  121|       |
  122|       |inline uint64_t UnalignedLoad64(const void *p) {
  123|       |  uint64_t t;
  124|       |  memcpy(&t, p, sizeof t);
  125|       |  return t;
  126|       |}
  127|       |
  128|      0|inline void UnalignedStore16(void *p, uint16_t v) { memcpy(p, &v, sizeof v); }
  129|       |
  130|      0|inline void UnalignedStore32(void *p, uint32_t v) { memcpy(p, &v, sizeof v); }
  131|       |
  132|      0|inline void UnalignedStore64(void *p, uint64_t v) { memcpy(p, &v, sizeof v); }
  133|       |
  134|       |}  // namespace base_internal
  135|       |}  // inline namespace lts_2019_08_08
  136|       |}  // namespace absl
  137|       |
  138|       |#define ABSL_INTERNAL_UNALIGNED_LOAD16(_p) \
  139|      0|  (absl::base_internal::UnalignedLoad16(_p))
  140|       |#define ABSL_INTERNAL_UNALIGNED_LOAD32(_p) \
  141|      0|  (absl::base_internal::UnalignedLoad32(_p))
  142|       |#define ABSL_INTERNAL_UNALIGNED_LOAD64(_p) \
  143|       |  (absl::base_internal::UnalignedLoad64(_p))
  144|       |
  145|       |#define ABSL_INTERNAL_UNALIGNED_STORE16(_p, _val) \
  146|       |  (absl::base_internal::UnalignedStore16(_p, _val))
  147|       |#define ABSL_INTERNAL_UNALIGNED_STORE32(_p, _val) \
  148|       |  (absl::base_internal::UnalignedStore32(_p, _val))
  149|       |#define ABSL_INTERNAL_UNALIGNED_STORE64(_p, _val) \
  150|       |  (absl::base_internal::UnalignedStore64(_p, _val))
  151|       |
  152|       |#endif
  153|       |
  154|       |#endif  // defined(__cplusplus), end of unaligned API
  155|       |
  156|       |#endif  // ABSL_BASE_INTERNAL_UNALIGNED_ACCESS_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/log_severity.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/base/log_severity.h"
   16|       |
   17|       |#include <ostream>
   18|       |
   19|       |namespace absl {
   20|       |inline namespace lts_2019_08_08 {
   21|       |
   22|      0|std::ostream& operator<<(std::ostream& os, absl::LogSeverity s) {
   23|      0|  if (s == absl::NormalizeLogSeverity(s)) return os << absl::LogSeverityName(s);
   24|      0|  return os << "absl::LogSeverity(" << static_cast<int>(s) << ")";
   25|      0|}
   26|       |}  // inline namespace lts_2019_08_08
   27|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/log_severity.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#ifndef ABSL_BASE_INTERNAL_LOG_SEVERITY_H_
   16|       |#define ABSL_BASE_INTERNAL_LOG_SEVERITY_H_
   17|       |
   18|       |#include <array>
   19|       |#include <ostream>
   20|       |
   21|       |#include "absl/base/attributes.h"
   22|       |
   23|       |namespace absl {
   24|       |inline namespace lts_2019_08_08 {
   25|       |
   26|       |// Four severity levels are defined.  Logging APIs should terminate the program
   27|       |// when a message is logged at severity `kFatal`; the other levels have no
   28|       |// special semantics.
   29|       |enum class LogSeverity : int {
   30|       |  kInfo = 0,
   31|       |  kWarning = 1,
   32|       |  kError = 2,
   33|       |  kFatal = 3,
   34|       |};
   35|       |
   36|       |// Returns an iterable of all standard `absl::LogSeverity` values, ordered from
   37|       |// least to most severe.
   38|      0|constexpr std::array<absl::LogSeverity, 4> LogSeverities() {
   39|      0|  return {{absl::LogSeverity::kInfo, absl::LogSeverity::kWarning,
   40|      0|           absl::LogSeverity::kError, absl::LogSeverity::kFatal}};
   41|      0|}
   42|       |
   43|       |// Returns the all-caps string representation (e.g. "INFO") of the specified
   44|       |// severity level if it is one of the normal levels and "UNKNOWN" otherwise.
   45|      0|constexpr const char* LogSeverityName(absl::LogSeverity s) {
   46|      0|  return s == absl::LogSeverity::kInfo
   47|      0|             ? "INFO"
   48|      0|             : s == absl::LogSeverity::kWarning
   49|      0|                   ? "WARNING"
   50|      0|                   : s == absl::LogSeverity::kError
   51|      0|                         ? "ERROR"
   52|      0|                         : s == absl::LogSeverity::kFatal ? "FATAL" : "UNKNOWN";
   53|      0|}
   54|       |
   55|       |// Values less than `kInfo` normalize to `kInfo`; values greater than `kFatal`
   56|       |// normalize to `kError` (**NOT** `kFatal`).
   57|      0|constexpr absl::LogSeverity NormalizeLogSeverity(absl::LogSeverity s) {
   58|      0|  return s < absl::LogSeverity::kInfo
   59|      0|             ? absl::LogSeverity::kInfo
   60|      0|             : s > absl::LogSeverity::kFatal ? absl::LogSeverity::kError : s;
   61|      0|}
   62|      0|constexpr absl::LogSeverity NormalizeLogSeverity(int s) {
   63|      0|  return NormalizeLogSeverity(static_cast<absl::LogSeverity>(s));
   64|      0|}
   65|       |
   66|       |// The exact representation of a streamed `absl::LogSeverity` is deliberately
   67|       |// unspecified; do not rely on it.
   68|       |std::ostream& operator<<(std::ostream& os, absl::LogSeverity s);
   69|       |
   70|       |}  // inline namespace lts_2019_08_08
   71|       |}  // namespace absl
   72|       |
   73|       |#endif  // ABSL_BASE_INTERNAL_LOG_SEVERITY_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/macros.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: macros.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This header file defines the set of language macros used within Abseil code.
   21|       |// For the set of macros used to determine supported compilers and platforms,
   22|       |// see absl/base/config.h instead.
   23|       |//
   24|       |// This code is compiled directly on many platforms, including client
   25|       |// platforms like Windows, Mac, and embedded systems.  Before making
   26|       |// any changes here, make sure that you're not breaking any platforms.
   27|       |
   28|       |#ifndef ABSL_BASE_MACROS_H_
   29|       |#define ABSL_BASE_MACROS_H_
   30|       |
   31|       |#include <cassert>
   32|       |#include <cstddef>
   33|       |
   34|       |#include "absl/base/optimization.h"
   35|       |#include "absl/base/port.h"
   36|       |
   37|       |// ABSL_ARRAYSIZE()
   38|       |//
   39|       |// Returns the number of elements in an array as a compile-time constant, which
   40|       |// can be used in defining new arrays. If you use this macro on a pointer by
   41|       |// mistake, you will get a compile-time error.
   42|       |#define ABSL_ARRAYSIZE(array) \
   43|      0|  (sizeof(::absl::macros_internal::ArraySizeHelper(array)))
   44|       |
   45|       |namespace absl {
   46|       |inline namespace lts_2019_08_08 {
   47|       |namespace macros_internal {
   48|       |// Note: this internal template function declaration is used by ABSL_ARRAYSIZE.
   49|       |// The function doesn't need a definition, as we only use its type.
   50|       |template <typename T, size_t N>
   51|       |auto ArraySizeHelper(const T (&array)[N]) -> char (&)[N];
   52|       |}  // namespace macros_internal
   53|       |}  // inline namespace lts_2019_08_08
   54|       |}  // namespace absl
   55|       |
   56|       |// kLinkerInitialized
   57|       |//
   58|       |// An enum used only as a constructor argument to indicate that a variable has
   59|       |// static storage duration, and that the constructor should do nothing to its
   60|       |// state. Use of this macro indicates to the reader that it is legal to
   61|       |// declare a static instance of the class, provided the constructor is given
   62|       |// the absl::base_internal::kLinkerInitialized argument.
   63|       |//
   64|       |// Normally, it is unsafe to declare a static variable that has a constructor or
   65|       |// a destructor because invocation order is undefined. However, if the type can
   66|       |// be zero-initialized (which the loader does for static variables) into a valid
   67|       |// state and the type's destructor does not affect storage, then a constructor
   68|       |// for static initialization can be declared.
   69|       |//
   70|       |// Example:
   71|       |//       // Declaration
   72|       |//       explicit MyClass(absl::base_internal:LinkerInitialized x) {}
   73|       |//
   74|       |//       // Invocation
   75|       |//       static MyClass my_global(absl::base_internal::kLinkerInitialized);
   76|       |namespace absl {
   77|       |inline namespace lts_2019_08_08 {
   78|       |namespace base_internal {
   79|       |enum LinkerInitialized {
   80|       |  kLinkerInitialized = 0,
   81|       |};
   82|       |}  // namespace base_internal
   83|       |}  // inline namespace lts_2019_08_08
   84|       |}  // namespace absl
   85|       |
   86|       |// ABSL_FALLTHROUGH_INTENDED
   87|       |//
   88|       |// Annotates implicit fall-through between switch labels, allowing a case to
   89|       |// indicate intentional fallthrough and turn off warnings about any lack of a
   90|       |// `break` statement. The ABSL_FALLTHROUGH_INTENDED macro should be followed by
   91|       |// a semicolon and can be used in most places where `break` can, provided that
   92|       |// no statements exist between it and the next switch label.
   93|       |//
   94|       |// Example:
   95|       |//
   96|       |//  switch (x) {
   97|       |//    case 40:
   98|       |//    case 41:
   99|       |//      if (truth_is_out_there) {
  100|       |//        ++x;
  101|       |//        ABSL_FALLTHROUGH_INTENDED;  // Use instead of/along with annotations
  102|       |//                                    // in comments
  103|       |//      } else {
  104|       |//        return x;
  105|       |//      }
  106|       |//    case 42:
  107|       |//      ...
  108|       |//
  109|       |// Notes: when compiled with clang in C++11 mode, the ABSL_FALLTHROUGH_INTENDED
  110|       |// macro is expanded to the [[clang::fallthrough]] attribute, which is analysed
  111|       |// when  performing switch labels fall-through diagnostic
  112|       |// (`-Wimplicit-fallthrough`). See clang documentation on language extensions
  113|       |// for details:
  114|       |// http://clang.llvm.org/docs/AttributeReference.html#fallthrough-clang-fallthrough
  115|       |//
  116|       |// When used with unsupported compilers, the ABSL_FALLTHROUGH_INTENDED macro
  117|       |// has no effect on diagnostics. In any case this macro has no effect on runtime
  118|       |// behavior and performance of code.
  119|       |#ifdef ABSL_FALLTHROUGH_INTENDED
  120|       |#error "ABSL_FALLTHROUGH_INTENDED should not be defined."
  121|       |#endif
  122|       |
  123|       |// TODO(zhangxy): Use c++17 standard [[fallthrough]] macro, when supported.
  124|       |#if defined(__clang__) && defined(__has_warning)
  125|       |#if __has_feature(cxx_attributes) && __has_warning("-Wimplicit-fallthrough")
  126|      0|#define ABSL_FALLTHROUGH_INTENDED [[clang::fallthrough]]
  127|       |#endif
  128|       |#elif defined(__GNUC__) && __GNUC__ >= 7
  129|       |#define ABSL_FALLTHROUGH_INTENDED [[gnu::fallthrough]]
  130|       |#endif
  131|       |
  132|       |#ifndef ABSL_FALLTHROUGH_INTENDED
  133|       |#define ABSL_FALLTHROUGH_INTENDED \
  134|       |  do {                            \
  135|       |  } while (0)
  136|       |#endif
  137|       |
  138|       |// ABSL_DEPRECATED()
  139|       |//
  140|       |// Marks a deprecated class, struct, enum, function, method and variable
  141|       |// declarations. The macro argument is used as a custom diagnostic message (e.g.
  142|       |// suggestion of a better alternative).
  143|       |//
  144|       |// Example:
  145|       |//
  146|       |//   class ABSL_DEPRECATED("Use Bar instead") Foo {...};
  147|       |//   ABSL_DEPRECATED("Use Baz instead") void Bar() {...}
  148|       |//
  149|       |// Every usage of a deprecated entity will trigger a warning when compiled with
  150|       |// clang's `-Wdeprecated-declarations` option. This option is turned off by
  151|       |// default, but the warnings will be reported by clang-tidy.
  152|       |#if defined(__clang__) && __cplusplus >= 201103L
  153|       |#define ABSL_DEPRECATED(message) __attribute__((deprecated(message)))
  154|       |#endif
  155|       |
  156|       |#ifndef ABSL_DEPRECATED
  157|       |#define ABSL_DEPRECATED(message)
  158|       |#endif
  159|       |
  160|       |// ABSL_BAD_CALL_IF()
  161|       |//
  162|       |// Used on a function overload to trap bad calls: any call that matches the
  163|       |// overload will cause a compile-time error. This macro uses a clang-specific
  164|       |// "enable_if" attribute, as described at
  165|       |// http://clang.llvm.org/docs/AttributeReference.html#enable-if
  166|       |//
  167|       |// Overloads which use this macro should be bracketed by
  168|       |// `#ifdef ABSL_BAD_CALL_IF`.
  169|       |//
  170|       |// Example:
  171|       |//
  172|       |//   int isdigit(int c);
  173|       |//   #ifdef ABSL_BAD_CALL_IF
  174|       |//   int isdigit(int c)
  175|       |//     ABSL_BAD_CALL_IF(c <= -1 || c > 255,
  176|       |//                       "'c' must have the value of an unsigned char or EOF");
  177|       |//   #endif // ABSL_BAD_CALL_IF
  178|       |
  179|       |#if defined(__clang__)
  180|       |# if __has_attribute(enable_if)
  181|       |#  define ABSL_BAD_CALL_IF(expr, msg) \
  182|       |    __attribute__((enable_if(expr, "Bad call trap"), unavailable(msg)))
  183|       |# endif
  184|       |#endif
  185|       |
  186|       |// ABSL_ASSERT()
  187|       |//
  188|       |// In C++11, `assert` can't be used portably within constexpr functions.
  189|       |// ABSL_ASSERT functions as a runtime assert but works in C++11 constexpr
  190|       |// functions.  Example:
  191|       |//
  192|       |// constexpr double Divide(double a, double b) {
  193|       |//   return ABSL_ASSERT(b != 0), a / b;
  194|       |// }
  195|       |//
  196|       |// This macro is inspired by
  197|       |// https://akrzemi1.wordpress.com/2017/05/18/asserts-in-constexpr-functions/
  198|       |#if defined(NDEBUG)
  199|       |#define ABSL_ASSERT(expr) \
  200|       |  (false ? static_cast<void>(expr) : static_cast<void>(0))
  201|       |#else
  202|       |#define ABSL_ASSERT(expr)                           \
  203|      0|  (ABSL_PREDICT_TRUE((expr)) ? static_cast<void>(0) \
  204|      0|                             : [] { assert(false && #expr); }())  // NOLINT
  205|       |#endif
  206|       |
  207|       |#ifdef ABSL_HAVE_EXCEPTIONS
  208|       |#define ABSL_INTERNAL_TRY try
  209|       |#define ABSL_INTERNAL_CATCH_ANY catch (...)
  210|       |#define ABSL_INTERNAL_RETHROW do { throw; } while (false)
  211|       |#else  // ABSL_HAVE_EXCEPTIONS
  212|       |#define ABSL_INTERNAL_TRY if (true)
  213|       |#define ABSL_INTERNAL_CATCH_ANY else if (false)
  214|       |#define ABSL_INTERNAL_RETHROW do {} while (false)
  215|       |#endif  // ABSL_HAVE_EXCEPTIONS
  216|       |
  217|       |#endif  // ABSL_BASE_MACROS_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/base/optimization.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: optimization.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This header file defines portable macros for performance optimization.
   21|       |
   22|       |#ifndef ABSL_BASE_OPTIMIZATION_H_
   23|       |#define ABSL_BASE_OPTIMIZATION_H_
   24|       |
   25|       |#include "absl/base/config.h"
   26|       |
   27|       |// ABSL_BLOCK_TAIL_CALL_OPTIMIZATION
   28|       |//
   29|       |// Instructs the compiler to avoid optimizing tail-call recursion. Use of this
   30|       |// macro is useful when you wish to preserve the existing function order within
   31|       |// a stack trace for logging, debugging, or profiling purposes.
   32|       |//
   33|       |// Example:
   34|       |//
   35|       |//   int f() {
   36|       |//     int result = g();
   37|       |//     ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
   38|       |//     return result;
   39|       |//   }
   40|       |#if defined(__pnacl__)
   41|       |#define ABSL_BLOCK_TAIL_CALL_OPTIMIZATION() if (volatile int x = 0) { (void)x; }
   42|       |#elif defined(__clang__)
   43|       |// Clang will not tail call given inline volatile assembly.
   44|       |#define ABSL_BLOCK_TAIL_CALL_OPTIMIZATION() __asm__ __volatile__("")
   45|       |#elif defined(__GNUC__)
   46|       |// GCC will not tail call given inline volatile assembly.
   47|       |#define ABSL_BLOCK_TAIL_CALL_OPTIMIZATION() __asm__ __volatile__("")
   48|       |#elif defined(_MSC_VER)
   49|       |#include <intrin.h>
   50|       |// The __nop() intrinsic blocks the optimisation.
   51|       |#define ABSL_BLOCK_TAIL_CALL_OPTIMIZATION() __nop()
   52|       |#else
   53|       |#define ABSL_BLOCK_TAIL_CALL_OPTIMIZATION() if (volatile int x = 0) { (void)x; }
   54|       |#endif
   55|       |
   56|       |// ABSL_CACHELINE_SIZE
   57|       |//
   58|       |// Explicitly defines the size of the L1 cache for purposes of alignment.
   59|       |// Setting the cacheline size allows you to specify that certain objects be
   60|       |// aligned on a cacheline boundary with `ABSL_CACHELINE_ALIGNED` declarations.
   61|       |// (See below.)
   62|       |//
   63|       |// NOTE: this macro should be replaced with the following C++17 features, when
   64|       |// those are generally available:
   65|       |//
   66|       |//   * `std::hardware_constructive_interference_size`
   67|       |//   * `std::hardware_destructive_interference_size`
   68|       |//
   69|       |// See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0154r1.html
   70|       |// for more information.
   71|       |#if defined(__GNUC__)
   72|       |// Cache line alignment
   73|       |#if defined(__i386__) || defined(__x86_64__)
   74|       |#define ABSL_CACHELINE_SIZE 64
   75|       |#elif defined(__powerpc64__)
   76|       |#define ABSL_CACHELINE_SIZE 128
   77|       |#elif defined(__aarch64__)
   78|       |// We would need to read special register ctr_el0 to find out L1 dcache size.
   79|       |// This value is a good estimate based on a real aarch64 machine.
   80|       |#define ABSL_CACHELINE_SIZE 64
   81|       |#elif defined(__arm__)
   82|       |// Cache line sizes for ARM: These values are not strictly correct since
   83|       |// cache line sizes depend on implementations, not architectures.  There
   84|       |// are even implementations with cache line sizes configurable at boot
   85|       |// time.
   86|       |#if defined(__ARM_ARCH_5T__)
   87|       |#define ABSL_CACHELINE_SIZE 32
   88|       |#elif defined(__ARM_ARCH_7A__)
   89|       |#define ABSL_CACHELINE_SIZE 64
   90|       |#endif
   91|       |#endif
   92|       |
   93|       |#ifndef ABSL_CACHELINE_SIZE
   94|       |// A reasonable default guess.  Note that overestimates tend to waste more
   95|       |// space, while underestimates tend to waste more time.
   96|       |#define ABSL_CACHELINE_SIZE 64
   97|       |#endif
   98|       |
   99|       |// ABSL_CACHELINE_ALIGNED
  100|       |//
  101|       |// Indicates that the declared object be cache aligned using
  102|       |// `ABSL_CACHELINE_SIZE` (see above). Cacheline aligning objects allows you to
  103|       |// load a set of related objects in the L1 cache for performance improvements.
  104|       |// Cacheline aligning objects properly allows constructive memory sharing and
  105|       |// prevents destructive (or "false") memory sharing.
  106|       |//
  107|       |// NOTE: this macro should be replaced with usage of `alignas()` using
  108|       |// `std::hardware_constructive_interference_size` and/or
  109|       |// `std::hardware_destructive_interference_size` when available within C++17.
  110|       |//
  111|       |// See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0154r1.html
  112|       |// for more information.
  113|       |//
  114|       |// On some compilers, `ABSL_CACHELINE_ALIGNED` expands to an `__attribute__`
  115|       |// or `__declspec` attribute. For compilers where this is not known to work,
  116|       |// the macro expands to nothing.
  117|       |//
  118|       |// No further guarantees are made here. The result of applying the macro
  119|       |// to variables and types is always implementation-defined.
  120|       |//
  121|       |// WARNING: It is easy to use this attribute incorrectly, even to the point
  122|       |// of causing bugs that are difficult to diagnose, crash, etc. It does not
  123|       |// of itself guarantee that objects are aligned to a cache line.
  124|       |//
  125|       |// NOTE: Some compilers are picky about the locations of annotations such as
  126|       |// this attribute, so prefer to put it at the beginning of your declaration.
  127|       |// For example,
  128|       |//
  129|       |//   ABSL_CACHELINE_ALIGNED static Foo* foo = ...
  130|       |//
  131|       |//   class ABSL_CACHELINE_ALIGNED Bar { ...
  132|       |//
  133|       |// Recommendations:
  134|       |//
  135|       |// 1) Consult compiler documentation; this comment is not kept in sync as
  136|       |//    toolchains evolve.
  137|       |// 2) Verify your use has the intended effect. This often requires inspecting
  138|       |//    the generated machine code.
  139|       |// 3) Prefer applying this attribute to individual variables. Avoid
  140|       |//    applying it to types. This tends to localize the effect.
  141|       |#define ABSL_CACHELINE_ALIGNED __attribute__((aligned(ABSL_CACHELINE_SIZE)))
  142|       |#elif defined(_MSC_VER)
  143|       |#define ABSL_CACHELINE_SIZE 64
  144|       |#define ABSL_CACHELINE_ALIGNED __declspec(align(ABSL_CACHELINE_SIZE))
  145|       |#else
  146|       |#define ABSL_CACHELINE_SIZE 64
  147|       |#define ABSL_CACHELINE_ALIGNED
  148|       |#endif
  149|       |
  150|       |// ABSL_PREDICT_TRUE, ABSL_PREDICT_FALSE
  151|       |//
  152|       |// Enables the compiler to prioritize compilation using static analysis for
  153|       |// likely paths within a boolean branch.
  154|       |//
  155|       |// Example:
  156|       |//
  157|       |//   if (ABSL_PREDICT_TRUE(expression)) {
  158|       |//     return result;                        // Faster if more likely
  159|       |//   } else {
  160|       |//     return 0;
  161|       |//   }
  162|       |//
  163|       |// Compilers can use the information that a certain branch is not likely to be
  164|       |// taken (for instance, a CHECK failure) to optimize for the common case in
  165|       |// the absence of better information (ie. compiling gcc with `-fprofile-arcs`).
  166|       |//
  167|       |// Recommendation: Modern CPUs dynamically predict branch execution paths,
  168|       |// typically with accuracy greater than 97%. As a result, annotating every
  169|       |// branch in a codebase is likely counterproductive; however, annotating
  170|       |// specific branches that are both hot and consistently mispredicted is likely
  171|       |// to yield performance improvements.
  172|       |#if ABSL_HAVE_BUILTIN(__builtin_expect) || \
  173|       |    (defined(__GNUC__) && !defined(__clang__))
  174|      0|#define ABSL_PREDICT_FALSE(x) (__builtin_expect(x, 0))
  175|      0|#define ABSL_PREDICT_TRUE(x) (__builtin_expect(!!(x), 1))
  176|       |#else
  177|       |#define ABSL_PREDICT_FALSE(x) (x)
  178|       |#define ABSL_PREDICT_TRUE(x) (x)
  179|       |#endif
  180|       |
  181|       |#endif  // ABSL_BASE_OPTIMIZATION_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/meta/type_traits.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// type_traits.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This file contains C++11-compatible versions of standard <type_traits> API
   21|       |// functions for determining the characteristics of types. Such traits can
   22|       |// support type inference, classification, and transformation, as well as
   23|       |// make it easier to write templates based on generic type behavior.
   24|       |//
   25|       |// See https://en.cppreference.com/w/cpp/header/type_traits
   26|       |//
   27|       |// WARNING: use of many of the constructs in this header will count as "complex
   28|       |// template metaprogramming", so before proceeding, please carefully consider
   29|       |// https://google.github.io/styleguide/cppguide.html#Template_metaprogramming
   30|       |//
   31|       |// WARNING: using template metaprogramming to detect or depend on API
   32|       |// features is brittle and not guaranteed. Neither the standard library nor
   33|       |// Abseil provides any guarantee that APIs are stable in the face of template
   34|       |// metaprogramming. Use with caution.
   35|       |#ifndef ABSL_META_TYPE_TRAITS_H_
   36|       |#define ABSL_META_TYPE_TRAITS_H_
   37|       |
   38|       |#include <stddef.h>
   39|       |#include <functional>
   40|       |#include <type_traits>
   41|       |
   42|       |#include "absl/base/config.h"
   43|       |
   44|       |namespace absl {
   45|       |inline namespace lts_2019_08_08 {
   46|       |
   47|       |// Defined and documented later on in this file.
   48|       |template <typename T>
   49|       |struct is_trivially_move_assignable;
   50|       |
   51|       |namespace type_traits_internal {
   52|       |
   53|       |// Silence MSVC warnings about the destructor being defined as deleted.
   54|       |#if defined(_MSC_VER) && !defined(__GNUC__)
   55|       |#pragma warning(push)
   56|       |#pragma warning(disable : 4624)
   57|       |#endif  // defined(_MSC_VER) && !defined(__GNUC__)
   58|       |
   59|       |template <class T>
   60|       |union SingleMemberUnion {
   61|       |  T t;
   62|       |};
   63|       |
   64|       |// Restore the state of the destructor warning that was silenced above.
   65|       |#if defined(_MSC_VER) && !defined(__GNUC__)
   66|       |#pragma warning(pop)
   67|       |#endif  // defined(_MSC_VER) && !defined(__GNUC__)
   68|       |
   69|       |template <class T>
   70|       |struct IsTriviallyMoveAssignableReference : std::false_type {};
   71|       |
   72|       |template <class T>
   73|       |struct IsTriviallyMoveAssignableReference<T&>
   74|       |    : absl::is_trivially_move_assignable<T>::type {};
   75|       |
   76|       |template <class T>
   77|       |struct IsTriviallyMoveAssignableReference<T&&>
   78|       |    : absl::is_trivially_move_assignable<T>::type {};
   79|       |
   80|       |template <typename... Ts>
   81|       |struct VoidTImpl {
   82|       |  using type = void;
   83|       |};
   84|       |
   85|       |// This trick to retrieve a default alignment is necessary for our
   86|       |// implementation of aligned_storage_t to be consistent with any implementation
   87|       |// of std::aligned_storage.
   88|       |template <size_t Len, typename T = std::aligned_storage<Len>>
   89|       |struct default_alignment_of_aligned_storage;
   90|       |
   91|       |template <size_t Len, size_t Align>
   92|       |struct default_alignment_of_aligned_storage<Len,
   93|       |                                            std::aligned_storage<Len, Align>> {
   94|       |  static constexpr size_t value = Align;
   95|       |};
   96|       |
   97|       |////////////////////////////////
   98|       |// Library Fundamentals V2 TS //
   99|       |////////////////////////////////
  100|       |
  101|       |// NOTE: The `is_detected` family of templates here differ from the library
  102|       |// fundamentals specification in that for library fundamentals, `Op<Args...>` is
  103|       |// evaluated as soon as the type `is_detected<Op, Args...>` undergoes
  104|       |// substitution, regardless of whether or not the `::value` is accessed. That
  105|       |// is inconsistent with all other standard traits and prevents lazy evaluation
  106|       |// in larger contexts (such as if the `is_detected` check is a trailing argument
  107|       |// of a `conjunction`. This implementation opts to instead be lazy in the same
  108|       |// way that the standard traits are (this "defect" of the detection idiom
  109|       |// specifications has been reported).
  110|       |
  111|       |template <class Enabler, template <class...> class Op, class... Args>
  112|       |struct is_detected_impl {
  113|       |  using type = std::false_type;
  114|       |};
  115|       |
  116|       |template <template <class...> class Op, class... Args>
  117|       |struct is_detected_impl<typename VoidTImpl<Op<Args...>>::type, Op, Args...> {
  118|       |  using type = std::true_type;
  119|       |};
  120|       |
  121|       |template <template <class...> class Op, class... Args>
  122|       |struct is_detected : is_detected_impl<void, Op, Args...>::type {};
  123|       |
  124|       |template <class Enabler, class To, template <class...> class Op, class... Args>
  125|       |struct is_detected_convertible_impl {
  126|       |  using type = std::false_type;
  127|       |};
  128|       |
  129|       |template <class To, template <class...> class Op, class... Args>
  130|       |struct is_detected_convertible_impl<
  131|       |    typename std::enable_if<std::is_convertible<Op<Args...>, To>::value>::type,
  132|       |    To, Op, Args...> {
  133|       |  using type = std::true_type;
  134|       |};
  135|       |
  136|       |template <class To, template <class...> class Op, class... Args>
  137|       |struct is_detected_convertible
  138|       |    : is_detected_convertible_impl<void, To, Op, Args...>::type {};
  139|       |
  140|       |template <typename T>
  141|       |using IsCopyAssignableImpl =
  142|       |    decltype(std::declval<T&>() = std::declval<const T&>());
  143|       |
  144|       |template <typename T>
  145|       |using IsMoveAssignableImpl = decltype(std::declval<T&>() = std::declval<T&&>());
  146|       |
  147|       |}  // namespace type_traits_internal
  148|       |
  149|       |template <typename T>
  150|       |struct is_copy_assignable : type_traits_internal::is_detected<
  151|       |                                type_traits_internal::IsCopyAssignableImpl, T> {
  152|       |};
  153|       |
  154|       |template <typename T>
  155|       |struct is_move_assignable : type_traits_internal::is_detected<
  156|       |                                type_traits_internal::IsMoveAssignableImpl, T> {
  157|       |};
  158|       |
  159|       |// void_t()
  160|       |//
  161|       |// Ignores the type of any its arguments and returns `void`. In general, this
  162|       |// metafunction allows you to create a general case that maps to `void` while
  163|       |// allowing specializations that map to specific types.
  164|       |//
  165|       |// This metafunction is designed to be a drop-in replacement for the C++17
  166|       |// `std::void_t` metafunction.
  167|       |//
  168|       |// NOTE: `absl::void_t` does not use the standard-specified implementation so
  169|       |// that it can remain compatible with gcc < 5.1. This can introduce slightly
  170|       |// different behavior, such as when ordering partial specializations.
  171|       |template <typename... Ts>
  172|       |using void_t = typename type_traits_internal::VoidTImpl<Ts...>::type;
  173|       |
  174|       |// conjunction
  175|       |//
  176|       |// Performs a compile-time logical AND operation on the passed types (which
  177|       |// must have  `::value` members convertible to `bool`. Short-circuits if it
  178|       |// encounters any `false` members (and does not compare the `::value` members
  179|       |// of any remaining arguments).
  180|       |//
  181|       |// This metafunction is designed to be a drop-in replacement for the C++17
  182|       |// `std::conjunction` metafunction.
  183|       |template <typename... Ts>
  184|       |struct conjunction;
  185|       |
  186|       |template <typename T, typename... Ts>
  187|       |struct conjunction<T, Ts...>
  188|       |    : std::conditional<T::value, conjunction<Ts...>, T>::type {};
  189|       |
  190|       |template <typename T>
  191|       |struct conjunction<T> : T {};
  192|       |
  193|       |template <>
  194|       |struct conjunction<> : std::true_type {};
  195|       |
  196|       |// disjunction
  197|       |//
  198|       |// Performs a compile-time logical OR operation on the passed types (which
  199|       |// must have  `::value` members convertible to `bool`. Short-circuits if it
  200|       |// encounters any `true` members (and does not compare the `::value` members
  201|       |// of any remaining arguments).
  202|       |//
  203|       |// This metafunction is designed to be a drop-in replacement for the C++17
  204|       |// `std::disjunction` metafunction.
  205|       |template <typename... Ts>
  206|       |struct disjunction;
  207|       |
  208|       |template <typename T, typename... Ts>
  209|       |struct disjunction<T, Ts...> :
  210|       |      std::conditional<T::value, T, disjunction<Ts...>>::type {};
  211|       |
  212|       |template <typename T>
  213|       |struct disjunction<T> : T {};
  214|       |
  215|       |template <>
  216|       |struct disjunction<> : std::false_type {};
  217|       |
  218|       |// negation
  219|       |//
  220|       |// Performs a compile-time logical NOT operation on the passed type (which
  221|       |// must have  `::value` members convertible to `bool`.
  222|       |//
  223|       |// This metafunction is designed to be a drop-in replacement for the C++17
  224|       |// `std::negation` metafunction.
  225|       |template <typename T>
  226|       |struct negation : std::integral_constant<bool, !T::value> {};
  227|       |
  228|       |// is_function()
  229|       |//
  230|       |// Determines whether the passed type `T` is a function type.
  231|       |//
  232|       |// This metafunction is designed to be a drop-in replacement for the C++11
  233|       |// `std::is_function()` metafunction for platforms that have incomplete C++11
  234|       |// support (such as libstdc++ 4.x).
  235|       |//
  236|       |// This metafunction works because appending `const` to a type does nothing to
  237|       |// function types and reference types (and forms a const-qualified type
  238|       |// otherwise).
  239|       |template <typename T>
  240|       |struct is_function
  241|       |    : std::integral_constant<
  242|       |          bool, !(std::is_reference<T>::value ||
  243|       |                  std::is_const<typename std::add_const<T>::type>::value)> {};
  244|       |
  245|       |// is_trivially_destructible()
  246|       |//
  247|       |// Determines whether the passed type `T` is trivially destructable.
  248|       |//
  249|       |// This metafunction is designed to be a drop-in replacement for the C++11
  250|       |// `std::is_trivially_destructible()` metafunction for platforms that have
  251|       |// incomplete C++11 support (such as libstdc++ 4.x). On any platforms that do
  252|       |// fully support C++11, we check whether this yields the same result as the std
  253|       |// implementation.
  254|       |//
  255|       |// NOTE: the extensions (__has_trivial_xxx) are implemented in gcc (version >=
  256|       |// 4.3) and clang. Since we are supporting libstdc++ > 4.7, they should always
  257|       |// be present. These  extensions are documented at
  258|       |// https://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html#Type-Traits.
  259|       |template <typename T>
  260|       |struct is_trivially_destructible
  261|       |    : std::integral_constant<bool, __has_trivial_destructor(T) &&
  262|       |                                   std::is_destructible<T>::value> {
  263|       |#ifdef ABSL_HAVE_STD_IS_TRIVIALLY_DESTRUCTIBLE
  264|       | private:
  265|       |  static constexpr bool compliant = std::is_trivially_destructible<T>::value ==
  266|       |                                    is_trivially_destructible::value;
  267|       |  static_assert(compliant || std::is_trivially_destructible<T>::value,
  268|       |                "Not compliant with std::is_trivially_destructible; "
  269|       |                "Standard: false, Implementation: true");
  270|       |  static_assert(compliant || !std::is_trivially_destructible<T>::value,
  271|       |                "Not compliant with std::is_trivially_destructible; "
  272|       |                "Standard: true, Implementation: false");
  273|       |#endif  // ABSL_HAVE_STD_IS_TRIVIALLY_DESTRUCTIBLE
  274|       |};
  275|       |
  276|       |// is_trivially_default_constructible()
  277|       |//
  278|       |// Determines whether the passed type `T` is trivially default constructible.
  279|       |//
  280|       |// This metafunction is designed to be a drop-in replacement for the C++11
  281|       |// `std::is_trivially_default_constructible()` metafunction for platforms that
  282|       |// have incomplete C++11 support (such as libstdc++ 4.x). On any platforms that
  283|       |// do fully support C++11, we check whether this yields the same result as the
  284|       |// std implementation.
  285|       |//
  286|       |// NOTE: according to the C++ standard, Section: 20.15.4.3 [meta.unary.prop]
  287|       |// "The predicate condition for a template specialization is_constructible<T,
  288|       |// Args...> shall be satisfied if and only if the following variable
  289|       |// definition would be well-formed for some invented variable t:
  290|       |//
  291|       |// T t(declval<Args>()...);
  292|       |//
  293|       |// is_trivially_constructible<T, Args...> additionally requires that the
  294|       |// variable definition does not call any operation that is not trivial.
  295|       |// For the purposes of this check, the call to std::declval is considered
  296|       |// trivial."
  297|       |//
  298|       |// Notes from https://en.cppreference.com/w/cpp/types/is_constructible:
  299|       |// In many implementations, is_nothrow_constructible also checks if the
  300|       |// destructor throws because it is effectively noexcept(T(arg)). Same
  301|       |// applies to is_trivially_constructible, which, in these implementations, also
  302|       |// requires that the destructor is trivial.
  303|       |// GCC bug 51452: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452
  304|       |// LWG issue 2116: http://cplusplus.github.io/LWG/lwg-active.html#2116.
  305|       |//
  306|       |// "T obj();" need to be well-formed and not call any nontrivial operation.
  307|       |// Nontrivially destructible types will cause the expression to be nontrivial.
  308|       |template <typename T>
  309|       |struct is_trivially_default_constructible
  310|       |    : std::integral_constant<bool, __has_trivial_constructor(T) &&
  311|       |                                   std::is_default_constructible<T>::value &&
  312|       |                                   is_trivially_destructible<T>::value> {
  313|       |#ifdef ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
  314|       | private:
  315|       |  static constexpr bool compliant =
  316|       |      std::is_trivially_default_constructible<T>::value ==
  317|       |      is_trivially_default_constructible::value;
  318|       |  static_assert(compliant || std::is_trivially_default_constructible<T>::value,
  319|       |                "Not compliant with std::is_trivially_default_constructible; "
  320|       |                "Standard: false, Implementation: true");
  321|       |  static_assert(compliant || !std::is_trivially_default_constructible<T>::value,
  322|       |                "Not compliant with std::is_trivially_default_constructible; "
  323|       |                "Standard: true, Implementation: false");
  324|       |#endif  // ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
  325|       |};
  326|       |
  327|       |// is_trivially_move_constructible()
  328|       |//
  329|       |// Determines whether the passed type `T` is trivially move constructible.
  330|       |//
  331|       |// This metafunction is designed to be a drop-in replacement for the C++11
  332|       |// `std::is_trivially_move_constructible()` metafunction for platforms that have
  333|       |// incomplete C++11 support (such as libstdc++ 4.x). On any platforms that do
  334|       |// fully support C++11, we check whether this yields the same result as the std
  335|       |// implementation.
  336|       |//
  337|       |// NOTE: `T obj(declval<T>());` needs to be well-formed and not call any
  338|       |// nontrivial operation.  Nontrivially destructible types will cause the
  339|       |// expression to be nontrivial.
  340|       |template <typename T>
  341|       |struct is_trivially_move_constructible
  342|       |    : std::conditional<
  343|       |          std::is_object<T>::value && !std::is_array<T>::value,
  344|       |          std::is_move_constructible<
  345|       |              type_traits_internal::SingleMemberUnion<T>>,
  346|       |          std::is_reference<T>>::type::type {
  347|       |#ifdef ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
  348|       | private:
  349|       |  static constexpr bool compliant =
  350|       |      std::is_trivially_move_constructible<T>::value ==
  351|       |      is_trivially_move_constructible::value;
  352|       |  static_assert(compliant || std::is_trivially_move_constructible<T>::value,
  353|       |                "Not compliant with std::is_trivially_move_constructible; "
  354|       |                "Standard: false, Implementation: true");
  355|       |  static_assert(compliant || !std::is_trivially_move_constructible<T>::value,
  356|       |                "Not compliant with std::is_trivially_move_constructible; "
  357|       |                "Standard: true, Implementation: false");
  358|       |#endif  // ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
  359|       |};
  360|       |
  361|       |// is_trivially_copy_constructible()
  362|       |//
  363|       |// Determines whether the passed type `T` is trivially copy constructible.
  364|       |//
  365|       |// This metafunction is designed to be a drop-in replacement for the C++11
  366|       |// `std::is_trivially_copy_constructible()` metafunction for platforms that have
  367|       |// incomplete C++11 support (such as libstdc++ 4.x). On any platforms that do
  368|       |// fully support C++11, we check whether this yields the same result as the std
  369|       |// implementation.
  370|       |//
  371|       |// NOTE: `T obj(declval<const T&>());` needs to be well-formed and not call any
  372|       |// nontrivial operation.  Nontrivially destructible types will cause the
  373|       |// expression to be nontrivial.
  374|       |template <typename T>
  375|       |struct is_trivially_copy_constructible
  376|       |    : std::conditional<
  377|       |          std::is_object<T>::value && !std::is_array<T>::value,
  378|       |          std::is_copy_constructible<
  379|       |              type_traits_internal::SingleMemberUnion<T>>,
  380|       |          std::is_lvalue_reference<T>>::type::type {
  381|       |#ifdef ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
  382|       | private:
  383|       |  static constexpr bool compliant =
  384|       |      std::is_trivially_copy_constructible<T>::value ==
  385|       |      is_trivially_copy_constructible::value;
  386|       |  static_assert(compliant || std::is_trivially_copy_constructible<T>::value,
  387|       |                "Not compliant with std::is_trivially_copy_constructible; "
  388|       |                "Standard: false, Implementation: true");
  389|       |  static_assert(compliant || !std::is_trivially_copy_constructible<T>::value,
  390|       |                "Not compliant with std::is_trivially_copy_constructible; "
  391|       |                "Standard: true, Implementation: false");
  392|       |#endif  // ABSL_HAVE_STD_IS_TRIVIALLY_CONSTRUCTIBLE
  393|       |};
  394|       |
  395|       |// is_trivially_move_assignable()
  396|       |//
  397|       |// Determines whether the passed type `T` is trivially move assignable.
  398|       |//
  399|       |// This metafunction is designed to be a drop-in replacement for the C++11
  400|       |// `std::is_trivially_move_assignable()` metafunction for platforms that have
  401|       |// incomplete C++11 support (such as libstdc++ 4.x). On any platforms that do
  402|       |// fully support C++11, we check whether this yields the same result as the std
  403|       |// implementation.
  404|       |//
  405|       |// NOTE: `is_assignable<T, U>::value` is `true` if the expression
  406|       |// `declval<T>() = declval<U>()` is well-formed when treated as an unevaluated
  407|       |// operand. `is_trivially_assignable<T, U>` requires the assignment to call no
  408|       |// operation that is not trivial. `is_trivially_copy_assignable<T>` is simply
  409|       |// `is_trivially_assignable<T&, T>`.
  410|       |template <typename T>
  411|       |struct is_trivially_move_assignable
  412|       |    : std::conditional<
  413|       |          std::is_object<T>::value && !std::is_array<T>::value,
  414|       |          std::is_move_assignable<type_traits_internal::SingleMemberUnion<T>>,
  415|       |          type_traits_internal::IsTriviallyMoveAssignableReference<T>>::type::
  416|       |          type {
  417|       |#ifdef ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE
  418|       | private:
  419|       |  static constexpr bool compliant =
  420|       |      std::is_trivially_move_assignable<T>::value ==
  421|       |      is_trivially_move_assignable::value;
  422|       |  static_assert(compliant || std::is_trivially_move_assignable<T>::value,
  423|       |                "Not compliant with std::is_trivially_move_assignable; "
  424|       |                "Standard: false, Implementation: true");
  425|       |  static_assert(compliant || !std::is_trivially_move_assignable<T>::value,
  426|       |                "Not compliant with std::is_trivially_move_assignable; "
  427|       |                "Standard: true, Implementation: false");
  428|       |#endif  // ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE
  429|       |};
  430|       |
  431|       |// is_trivially_copy_assignable()
  432|       |//
  433|       |// Determines whether the passed type `T` is trivially copy assignable.
  434|       |//
  435|       |// This metafunction is designed to be a drop-in replacement for the C++11
  436|       |// `std::is_trivially_copy_assignable()` metafunction for platforms that have
  437|       |// incomplete C++11 support (such as libstdc++ 4.x). On any platforms that do
  438|       |// fully support C++11, we check whether this yields the same result as the std
  439|       |// implementation.
  440|       |//
  441|       |// NOTE: `is_assignable<T, U>::value` is `true` if the expression
  442|       |// `declval<T>() = declval<U>()` is well-formed when treated as an unevaluated
  443|       |// operand. `is_trivially_assignable<T, U>` requires the assignment to call no
  444|       |// operation that is not trivial. `is_trivially_copy_assignable<T>` is simply
  445|       |// `is_trivially_assignable<T&, const T&>`.
  446|       |template <typename T>
  447|       |struct is_trivially_copy_assignable
  448|       |    : std::integral_constant<
  449|       |          bool, __has_trivial_assign(typename std::remove_reference<T>::type) &&
  450|       |                    absl::is_copy_assignable<T>::value> {
  451|       |#ifdef ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE
  452|       | private:
  453|       |  static constexpr bool compliant =
  454|       |      std::is_trivially_copy_assignable<T>::value ==
  455|       |      is_trivially_copy_assignable::value;
  456|       |  static_assert(compliant || std::is_trivially_copy_assignable<T>::value,
  457|       |                "Not compliant with std::is_trivially_copy_assignable; "
  458|       |                "Standard: false, Implementation: true");
  459|       |  static_assert(compliant || !std::is_trivially_copy_assignable<T>::value,
  460|       |                "Not compliant with std::is_trivially_copy_assignable; "
  461|       |                "Standard: true, Implementation: false");
  462|       |#endif  // ABSL_HAVE_STD_IS_TRIVIALLY_ASSIGNABLE
  463|       |};
  464|       |
  465|       |namespace type_traits_internal {
  466|       |// is_trivially_copyable()
  467|       |//
  468|       |// Determines whether the passed type `T` is trivially copyable.
  469|       |//
  470|       |// This metafunction is designed to be a drop-in replacement for the C++11
  471|       |// `std::is_trivially_copyable()` metafunction for platforms that have
  472|       |// incomplete C++11 support (such as libstdc++ 4.x). We use the C++17 definition
  473|       |// of TriviallyCopyable.
  474|       |//
  475|       |// NOTE: `is_trivially_copyable<T>::value` is `true` if all of T's copy/move
  476|       |// constructors/assignment operators are trivial or deleted, T has at least
  477|       |// one non-deleted copy/move constructor/assignment operator, and T is trivially
  478|       |// destructible. Arrays of trivially copyable types are trivially copyable.
  479|       |//
  480|       |// We expose this metafunction only for internal use within absl.
  481|       |template <typename T>
  482|       |class is_trivially_copyable_impl {
  483|       |  using ExtentsRemoved = typename std::remove_all_extents<T>::type;
  484|       |  static constexpr bool kIsCopyOrMoveConstructible =
  485|       |      std::is_copy_constructible<ExtentsRemoved>::value ||
  486|       |      std::is_move_constructible<ExtentsRemoved>::value;
  487|       |  static constexpr bool kIsCopyOrMoveAssignable =
  488|       |      absl::is_copy_assignable<ExtentsRemoved>::value ||
  489|       |      absl::is_move_assignable<ExtentsRemoved>::value;
  490|       |
  491|       | public:
  492|       |  static constexpr bool kValue =
  493|       |      (__has_trivial_copy(ExtentsRemoved) || !kIsCopyOrMoveConstructible) &&
  494|       |      (__has_trivial_assign(ExtentsRemoved) || !kIsCopyOrMoveAssignable) &&
  495|       |      (kIsCopyOrMoveConstructible || kIsCopyOrMoveAssignable) &&
  496|       |      is_trivially_destructible<ExtentsRemoved>::value &&
  497|       |      // We need to check for this explicitly because otherwise we'll say
  498|       |      // references are trivial copyable when compiled by MSVC.
  499|       |      !std::is_reference<ExtentsRemoved>::value;
  500|       |};
  501|       |
  502|       |template <typename T>
  503|       |struct is_trivially_copyable
  504|       |    : std::integral_constant<
  505|       |          bool, type_traits_internal::is_trivially_copyable_impl<T>::kValue> {};
  506|       |}  // namespace type_traits_internal
  507|       |
  508|       |// -----------------------------------------------------------------------------
  509|       |// C++14 "_t" trait aliases
  510|       |// -----------------------------------------------------------------------------
  511|       |
  512|       |template <typename T>
  513|       |using remove_cv_t = typename std::remove_cv<T>::type;
  514|       |
  515|       |template <typename T>
  516|       |using remove_const_t = typename std::remove_const<T>::type;
  517|       |
  518|       |template <typename T>
  519|       |using remove_volatile_t = typename std::remove_volatile<T>::type;
  520|       |
  521|       |template <typename T>
  522|       |using add_cv_t = typename std::add_cv<T>::type;
  523|       |
  524|       |template <typename T>
  525|       |using add_const_t = typename std::add_const<T>::type;
  526|       |
  527|       |template <typename T>
  528|       |using add_volatile_t = typename std::add_volatile<T>::type;
  529|       |
  530|       |template <typename T>
  531|       |using remove_reference_t = typename std::remove_reference<T>::type;
  532|       |
  533|       |template <typename T>
  534|       |using add_lvalue_reference_t = typename std::add_lvalue_reference<T>::type;
  535|       |
  536|       |template <typename T>
  537|       |using add_rvalue_reference_t = typename std::add_rvalue_reference<T>::type;
  538|       |
  539|       |template <typename T>
  540|       |using remove_pointer_t = typename std::remove_pointer<T>::type;
  541|       |
  542|       |template <typename T>
  543|       |using add_pointer_t = typename std::add_pointer<T>::type;
  544|       |
  545|       |template <typename T>
  546|       |using make_signed_t = typename std::make_signed<T>::type;
  547|       |
  548|       |template <typename T>
  549|       |using make_unsigned_t = typename std::make_unsigned<T>::type;
  550|       |
  551|       |template <typename T>
  552|       |using remove_extent_t = typename std::remove_extent<T>::type;
  553|       |
  554|       |template <typename T>
  555|       |using remove_all_extents_t = typename std::remove_all_extents<T>::type;
  556|       |
  557|       |template <size_t Len, size_t Align = type_traits_internal::
  558|       |                          default_alignment_of_aligned_storage<Len>::value>
  559|       |using aligned_storage_t = typename std::aligned_storage<Len, Align>::type;
  560|       |
  561|       |template <typename T>
  562|       |using decay_t = typename std::decay<T>::type;
  563|       |
  564|       |template <bool B, typename T = void>
  565|       |using enable_if_t = typename std::enable_if<B, T>::type;
  566|       |
  567|       |template <bool B, typename T, typename F>
  568|       |using conditional_t = typename std::conditional<B, T, F>::type;
  569|       |
  570|       |template <typename... T>
  571|       |using common_type_t = typename std::common_type<T...>::type;
  572|       |
  573|       |template <typename T>
  574|       |using underlying_type_t = typename std::underlying_type<T>::type;
  575|       |
  576|       |template <typename T>
  577|       |using result_of_t = typename std::result_of<T>::type;
  578|       |
  579|       |namespace type_traits_internal {
  580|       |// In MSVC we can't probe std::hash or stdext::hash because it triggers a
  581|       |// static_assert instead of failing substitution. Libc++ prior to 4.0
  582|       |// also used a static_assert.
  583|       |//
  584|       |#if defined(_MSC_VER) || (defined(_LIBCPP_VERSION) && \
  585|       |                          _LIBCPP_VERSION < 4000 && _LIBCPP_STD_VER > 11)
  586|       |#define ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_ 0
  587|       |#else
  588|       |#define ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_ 1
  589|       |#endif
  590|       |
  591|       |#if !ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
  592|       |template <typename Key, typename = size_t>
  593|       |struct IsHashable : std::true_type {};
  594|       |#else   // ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
  595|       |template <typename Key, typename = void>
  596|       |struct IsHashable : std::false_type {};
  597|       |
  598|       |template <typename Key>
  599|       |struct IsHashable<
  600|       |    Key,
  601|       |    absl::enable_if_t<std::is_convertible<
  602|       |        decltype(std::declval<std::hash<Key>&>()(std::declval<Key const&>())),
  603|       |        std::size_t>::value>> : std::true_type {};
  604|       |#endif  // !ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
  605|       |
  606|       |struct AssertHashEnabledHelper {
  607|       | private:
  608|      0|  static void Sink(...) {}
  609|       |  struct NAT {};
  610|       |
  611|       |  template <class Key>
  612|       |  static auto GetReturnType(int)
  613|       |      -> decltype(std::declval<std::hash<Key>>()(std::declval<Key const&>()));
  614|       |  template <class Key>
  615|       |  static NAT GetReturnType(...);
  616|       |
  617|       |  template <class Key>
  618|       |  static std::nullptr_t DoIt() {
  619|       |    static_assert(IsHashable<Key>::value,
  620|       |                  "std::hash<Key> does not provide a call operator");
  621|       |    static_assert(
  622|       |        std::is_default_constructible<std::hash<Key>>::value,
  623|       |        "std::hash<Key> must be default constructible when it is enabled");
  624|       |    static_assert(
  625|       |        std::is_copy_constructible<std::hash<Key>>::value,
  626|       |        "std::hash<Key> must be copy constructible when it is enabled");
  627|       |    static_assert(absl::is_copy_assignable<std::hash<Key>>::value,
  628|       |                  "std::hash<Key> must be copy assignable when it is enabled");
  629|       |    // is_destructible is unchecked as it's implied by each of the
  630|       |    // is_constructible checks.
  631|       |    using ReturnType = decltype(GetReturnType<Key>(0));
  632|       |    static_assert(std::is_same<ReturnType, NAT>::value ||
  633|       |                      std::is_same<ReturnType, size_t>::value,
  634|       |                  "std::hash<Key> must return size_t");
  635|       |    return nullptr;
  636|       |  }
  637|       |
  638|       |  template <class... Ts>
  639|       |  friend void AssertHashEnabled();
  640|       |};
  641|       |
  642|       |template <class... Ts>
  643|       |inline void AssertHashEnabled() {
  644|       |  using Helper = AssertHashEnabledHelper;
  645|       |  Helper::Sink(Helper::DoIt<Ts>()...);
  646|       |}
  647|       |
  648|       |}  // namespace type_traits_internal
  649|       |
  650|       |// An internal namespace that is required to implement the C++17 swap traits.
  651|       |// It is not further nested in type_traits_internal to avoid long symbol names.
  652|       |namespace swap_internal {
  653|       |
  654|       |// Necessary for the traits.
  655|       |using std::swap;
  656|       |
  657|       |// This declaration prevents global `swap` and `absl::swap` overloads from being
  658|       |// considered unless ADL picks them up.
  659|       |void swap();
  660|       |
  661|       |template <class T>
  662|       |using IsSwappableImpl = decltype(swap(std::declval<T&>(), std::declval<T&>()));
  663|       |
  664|       |// NOTE: This dance with the default template parameter is for MSVC.
  665|       |template <class T,
  666|       |          class IsNoexcept = std::integral_constant<
  667|       |              bool, noexcept(swap(std::declval<T&>(), std::declval<T&>()))>>
  668|       |using IsNothrowSwappableImpl = typename std::enable_if<IsNoexcept::value>::type;
  669|       |
  670|       |// IsSwappable
  671|       |//
  672|       |// Determines whether the standard swap idiom is a valid expression for
  673|       |// arguments of type `T`.
  674|       |template <class T>
  675|       |struct IsSwappable
  676|       |    : absl::type_traits_internal::is_detected<IsSwappableImpl, T> {};
  677|       |
  678|       |// IsNothrowSwappable
  679|       |//
  680|       |// Determines whether the standard swap idiom is a valid expression for
  681|       |// arguments of type `T` and is noexcept.
  682|       |template <class T>
  683|       |struct IsNothrowSwappable
  684|       |    : absl::type_traits_internal::is_detected<IsNothrowSwappableImpl, T> {};
  685|       |
  686|       |// Swap()
  687|       |//
  688|       |// Performs the swap idiom from a namespace where valid candidates may only be
  689|       |// found in `std` or via ADL.
  690|       |template <class T, absl::enable_if_t<IsSwappable<T>::value, int> = 0>
  691|       |void Swap(T& lhs, T& rhs) noexcept(IsNothrowSwappable<T>::value) {
  692|       |  swap(lhs, rhs);
  693|       |}
  694|       |
  695|       |// StdSwapIsUnconstrained
  696|       |//
  697|       |// Some standard library implementations are broken in that they do not
  698|       |// constrain `std::swap`. This will effectively tell us if we are dealing with
  699|       |// one of those implementations.
  700|       |using StdSwapIsUnconstrained = IsSwappable<void()>;
  701|       |
  702|       |}  // namespace swap_internal
  703|       |
  704|       |namespace type_traits_internal {
  705|       |
  706|       |// Make the swap-related traits/function accessible from this namespace.
  707|       |using swap_internal::IsNothrowSwappable;
  708|       |using swap_internal::IsSwappable;
  709|       |using swap_internal::Swap;
  710|       |using swap_internal::StdSwapIsUnconstrained;
  711|       |
  712|       |}  // namespace type_traits_internal
  713|       |}  // inline namespace lts_2019_08_08
  714|       |}  // namespace absl
  715|       |
  716|       |#endif  // ABSL_META_TYPE_TRAITS_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/numeric/int128.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/numeric/int128.h"
   16|       |
   17|       |#include <stddef.h>
   18|       |#include <cassert>
   19|       |#include <iomanip>
   20|       |#include <ostream>  // NOLINT(readability/streams)
   21|       |#include <sstream>
   22|       |#include <string>
   23|       |#include <type_traits>
   24|       |
   25|       |namespace absl {
   26|       |inline namespace lts_2019_08_08 {
   27|       |
   28|       |const uint128 kuint128max = MakeUint128(std::numeric_limits<uint64_t>::max(),
   29|       |                                        std::numeric_limits<uint64_t>::max());
   30|       |
   31|       |namespace {
   32|       |
   33|       |// Returns the 0-based position of the last set bit (i.e., most significant bit)
   34|       |// in the given uint64_t. The argument may not be 0.
   35|       |//
   36|       |// For example:
   37|       |//   Given: 5 (decimal) == 101 (binary)
   38|       |//   Returns: 2
   39|       |#define STEP(T, n, pos, sh)                   \
   40|      0|  do {                                        \
   41|      0|    if ((n) >= (static_cast<T>(1) << (sh))) { \
   42|      0|      (n) = (n) >> (sh);                      \
   43|      0|      (pos) |= (sh);                          \
   44|      0|    }                                         \
   45|      0|  } while (0)
   46|      0|static inline int Fls64(uint64_t n) {
   47|      0|  assert(n != 0);
   48|      0|  int pos = 0;
   49|      0|  STEP(uint64_t, n, pos, 0x20);
   50|      0|  uint32_t n32 = static_cast<uint32_t>(n);
   51|      0|  STEP(uint32_t, n32, pos, 0x10);
   52|      0|  STEP(uint32_t, n32, pos, 0x08);
   53|      0|  STEP(uint32_t, n32, pos, 0x04);
   54|      0|  return pos + ((uint64_t{0x3333333322221100} >> (n32 << 2)) & 0x3);
   55|      0|}
   56|       |#undef STEP
   57|       |
   58|       |// Like Fls64() above, but returns the 0-based position of the last set bit
   59|       |// (i.e., most significant bit) in the given uint128. The argument may not be 0.
   60|      0|static inline int Fls128(uint128 n) {
   61|      0|  if (uint64_t hi = Uint128High64(n)) {
   62|      0|    return Fls64(hi) + 64;
   63|      0|  }
   64|      0|  return Fls64(Uint128Low64(n));
   65|      0|}
   66|       |
   67|       |// Long division/modulo for uint128 implemented using the shift-subtract
   68|       |// division algorithm adapted from:
   69|       |// https://stackoverflow.com/questions/5386377/division-without-using
   70|       |void DivModImpl(uint128 dividend, uint128 divisor, uint128* quotient_ret,
   71|      0|                uint128* remainder_ret) {
   72|      0|  assert(divisor != 0);
   73|      0|
   74|      0|  if (divisor > dividend) {
   75|      0|    *quotient_ret = 0;
   76|      0|    *remainder_ret = dividend;
   77|      0|    return;
   78|      0|  }
   79|      0|
   80|      0|  if (divisor == dividend) {
   81|      0|    *quotient_ret = 1;
   82|      0|    *remainder_ret = 0;
   83|      0|    return;
   84|      0|  }
   85|      0|
   86|      0|  uint128 denominator = divisor;
   87|      0|  uint128 quotient = 0;
   88|      0|
   89|      0|  // Left aligns the MSB of the denominator and the dividend.
   90|      0|  const int shift = Fls128(dividend) - Fls128(denominator);
   91|      0|  denominator <<= shift;
   92|      0|
   93|      0|  // Uses shift-subtract algorithm to divide dividend by denominator. The
   94|      0|  // remainder will be left in dividend.
   95|      0|  for (int i = 0; i <= shift; ++i) {
   96|      0|    quotient <<= 1;
   97|      0|    if (dividend >= denominator) {
   98|      0|      dividend -= denominator;
   99|      0|      quotient |= 1;
  100|      0|    }
  101|      0|    denominator >>= 1;
  102|      0|  }
  103|      0|
  104|      0|  *quotient_ret = quotient;
  105|      0|  *remainder_ret = dividend;
  106|      0|}
  107|       |
  108|       |template <typename T>
  109|      0|uint128 MakeUint128FromFloat(T v) {
  110|      0|  static_assert(std::is_floating_point<T>::value, "");
  111|      0|
  112|      0|  // Rounding behavior is towards zero, same as for built-in types.
  113|      0|
  114|      0|  // Undefined behavior if v is NaN or cannot fit into uint128.
  115|      0|  assert(std::isfinite(v) && v > -1 &&
  116|      0|         (std::numeric_limits<T>::max_exponent <= 128 ||
  117|      0|          v < std::ldexp(static_cast<T>(1), 128)));
  118|      0|
  119|      0|  if (v >= std::ldexp(static_cast<T>(1), 64)) {
  120|      0|    uint64_t hi = static_cast<uint64_t>(std::ldexp(v, -64));
  121|      0|    uint64_t lo = static_cast<uint64_t>(v - std::ldexp(static_cast<T>(hi), 64));
  122|      0|    return MakeUint128(hi, lo);
  123|      0|  }
  124|      0|
  125|      0|  return MakeUint128(0, static_cast<uint64_t>(v));
  126|      0|}
  ------------------
  | Unexecuted instantiation: int128.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_120MakeUint128FromFloatIfEENS0_7uint128ET_
  ------------------
  | Unexecuted instantiation: int128.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_120MakeUint128FromFloatIdEENS0_7uint128ET_
  ------------------
  | Unexecuted instantiation: int128.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_120MakeUint128FromFloatIeEENS0_7uint128ET_
  ------------------
  127|       |
  128|       |#if defined(__clang__) && !defined(__SSE3__)
  129|       |// Workaround for clang bug: https://bugs.llvm.org/show_bug.cgi?id=38289
  130|       |// Casting from long double to uint64_t is miscompiled and drops bits.
  131|       |// It is more work, so only use when we need the workaround.
  132|       |uint128 MakeUint128FromFloat(long double v) {
  133|       |  // Go 50 bits at a time, that fits in a double
  134|       |  static_assert(std::numeric_limits<double>::digits >= 50, "");
  135|       |  static_assert(std::numeric_limits<long double>::digits <= 150, "");
  136|       |  // Undefined behavior if v is not finite or cannot fit into uint128.
  137|       |  assert(std::isfinite(v) && v > -1 && v < std::ldexp(1.0L, 128));
  138|       |
  139|       |  v = std::ldexp(v, -100);
  140|       |  uint64_t w0 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));
  141|       |  v = std::ldexp(v - static_cast<double>(w0), 50);
  142|       |  uint64_t w1 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));
  143|       |  v = std::ldexp(v - static_cast<double>(w1), 50);
  144|       |  uint64_t w2 = static_cast<uint64_t>(static_cast<double>(std::trunc(v)));
  145|       |  return (static_cast<uint128>(w0) << 100) | (static_cast<uint128>(w1) << 50) |
  146|       |         static_cast<uint128>(w2);
  147|       |}
  148|       |#endif  // __clang__ && !__SSE3__
  149|       |}  // namespace
  150|       |
  151|      0|uint128::uint128(float v) : uint128(MakeUint128FromFloat(v)) {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_087uint128C2Ef
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_087uint128C1Ef
  ------------------
  152|      0|uint128::uint128(double v) : uint128(MakeUint128FromFloat(v)) {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_087uint128C2Ed
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_087uint128C1Ed
  ------------------
  153|      0|uint128::uint128(long double v) : uint128(MakeUint128FromFloat(v)) {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_087uint128C2Ee
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_087uint128C1Ee
  ------------------
  154|       |
  155|      0|uint128 operator/(uint128 lhs, uint128 rhs) {
  156|      0|#if defined(ABSL_HAVE_INTRINSIC_INT128)
  157|      0|  return static_cast<unsigned __int128>(lhs) /
  158|      0|         static_cast<unsigned __int128>(rhs);
  159|       |#else  // ABSL_HAVE_INTRINSIC_INT128
  160|       |  uint128 quotient = 0;
  161|       |  uint128 remainder = 0;
  162|       |  DivModImpl(lhs, rhs, &quotient, &remainder);
  163|       |  return quotient;
  164|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  165|       |}
  166|      0|uint128 operator%(uint128 lhs, uint128 rhs) {
  167|      0|#if defined(ABSL_HAVE_INTRINSIC_INT128)
  168|      0|  return static_cast<unsigned __int128>(lhs) %
  169|      0|         static_cast<unsigned __int128>(rhs);
  170|       |#else  // ABSL_HAVE_INTRINSIC_INT128
  171|       |  uint128 quotient = 0;
  172|       |  uint128 remainder = 0;
  173|       |  DivModImpl(lhs, rhs, &quotient, &remainder);
  174|       |  return remainder;
  175|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  176|       |}
  177|       |
  178|       |namespace {
  179|       |
  180|      0|std::string Uint128ToFormattedString(uint128 v, std::ios_base::fmtflags flags) {
  181|      0|  // Select a divisor which is the largest power of the base < 2^64.
  182|      0|  uint128 div;
  183|      0|  int div_base_log;
  184|      0|  switch (flags & std::ios::basefield) {
  185|      0|    case std::ios::hex:
  186|      0|      div = 0x1000000000000000;  // 16^15
  187|      0|      div_base_log = 15;
  188|      0|      break;
  189|      0|    case std::ios::oct:
  190|      0|      div = 01000000000000000000000;  // 8^21
  191|      0|      div_base_log = 21;
  192|      0|      break;
  193|      0|    default:  // std::ios::dec
  194|      0|      div = 10000000000000000000u;  // 10^19
  195|      0|      div_base_log = 19;
  196|      0|      break;
  197|      0|  }
  198|      0|
  199|      0|  // Now piece together the uint128 representation from three chunks of the
  200|      0|  // original value, each less than "div" and therefore representable as a
  201|      0|  // uint64_t.
  202|      0|  std::ostringstream os;
  203|      0|  std::ios_base::fmtflags copy_mask =
  204|      0|      std::ios::basefield | std::ios::showbase | std::ios::uppercase;
  205|      0|  os.setf(flags & copy_mask, copy_mask);
  206|      0|  uint128 high = v;
  207|      0|  uint128 low;
  208|      0|  DivModImpl(high, div, &high, &low);
  209|      0|  uint128 mid;
  210|      0|  DivModImpl(high, div, &high, &mid);
  211|      0|  if (Uint128Low64(high) != 0) {
  212|      0|    os << Uint128Low64(high);
  213|      0|    os << std::noshowbase << std::setfill('0') << std::setw(div_base_log);
  214|      0|    os << Uint128Low64(mid);
  215|      0|    os << std::setw(div_base_log);
  216|      0|  } else if (Uint128Low64(mid) != 0) {
  217|      0|    os << Uint128Low64(mid);
  218|      0|    os << std::noshowbase << std::setfill('0') << std::setw(div_base_log);
  219|      0|  }
  220|      0|  os << Uint128Low64(low);
  221|      0|  return os.str();
  222|      0|}
  223|       |
  224|       |}  // namespace
  225|       |
  226|      0|std::ostream& operator<<(std::ostream& os, uint128 v) {
  227|      0|  std::ios_base::fmtflags flags = os.flags();
  228|      0|  std::string rep = Uint128ToFormattedString(v, flags);
  229|      0|
  230|      0|  // Add the requisite padding.
  231|      0|  std::streamsize width = os.width(0);
  232|      0|  if (static_cast<size_t>(width) > rep.size()) {
  233|      0|    std::ios::fmtflags adjustfield = flags & std::ios::adjustfield;
  234|      0|    if (adjustfield == std::ios::left) {
  235|      0|      rep.append(width - rep.size(), os.fill());
  236|      0|    } else if (adjustfield == std::ios::internal &&
  237|      0|               (flags & std::ios::showbase) &&
  238|      0|               (flags & std::ios::basefield) == std::ios::hex && v != 0) {
  239|      0|      rep.insert(2, width - rep.size(), os.fill());
  240|      0|    } else {
  241|      0|      rep.insert(0, width - rep.size(), os.fill());
  242|      0|    }
  243|      0|  }
  244|      0|
  245|      0|  return os << rep;
  246|      0|}
  247|       |
  248|       |}  // inline namespace lts_2019_08_08
  249|       |}  // namespace absl
  250|       |
  251|       |namespace std {
  252|       |constexpr bool numeric_limits<absl::uint128>::is_specialized;
  253|       |constexpr bool numeric_limits<absl::uint128>::is_signed;
  254|       |constexpr bool numeric_limits<absl::uint128>::is_integer;
  255|       |constexpr bool numeric_limits<absl::uint128>::is_exact;
  256|       |constexpr bool numeric_limits<absl::uint128>::has_infinity;
  257|       |constexpr bool numeric_limits<absl::uint128>::has_quiet_NaN;
  258|       |constexpr bool numeric_limits<absl::uint128>::has_signaling_NaN;
  259|       |constexpr float_denorm_style numeric_limits<absl::uint128>::has_denorm;
  260|       |constexpr bool numeric_limits<absl::uint128>::has_denorm_loss;
  261|       |constexpr float_round_style numeric_limits<absl::uint128>::round_style;
  262|       |constexpr bool numeric_limits<absl::uint128>::is_iec559;
  263|       |constexpr bool numeric_limits<absl::uint128>::is_bounded;
  264|       |constexpr bool numeric_limits<absl::uint128>::is_modulo;
  265|       |constexpr int numeric_limits<absl::uint128>::digits;
  266|       |constexpr int numeric_limits<absl::uint128>::digits10;
  267|       |constexpr int numeric_limits<absl::uint128>::max_digits10;
  268|       |constexpr int numeric_limits<absl::uint128>::radix;
  269|       |constexpr int numeric_limits<absl::uint128>::min_exponent;
  270|       |constexpr int numeric_limits<absl::uint128>::min_exponent10;
  271|       |constexpr int numeric_limits<absl::uint128>::max_exponent;
  272|       |constexpr int numeric_limits<absl::uint128>::max_exponent10;
  273|       |constexpr bool numeric_limits<absl::uint128>::traps;
  274|       |constexpr bool numeric_limits<absl::uint128>::tinyness_before;
  275|       |}  // namespace std

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/numeric/int128.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: int128.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This header file defines 128-bit integer types.
   21|       |//
   22|       |// Currently, this file defines `uint128`, an unsigned 128-bit integer;
   23|       |// a signed 128-bit integer is forthcoming.
   24|       |
   25|       |#ifndef ABSL_NUMERIC_INT128_H_
   26|       |#define ABSL_NUMERIC_INT128_H_
   27|       |
   28|       |#include <cassert>
   29|       |#include <cmath>
   30|       |#include <cstdint>
   31|       |#include <cstring>
   32|       |#include <iosfwd>
   33|       |#include <limits>
   34|       |#include <utility>
   35|       |
   36|       |#include "absl/base/config.h"
   37|       |#include "absl/base/macros.h"
   38|       |#include "absl/base/port.h"
   39|       |
   40|       |#if defined(_MSC_VER)
   41|       |// In very old versions of MSVC and when the /Zc:wchar_t flag is off, wchar_t is
   42|       |// a typedef for unsigned short.  Otherwise wchar_t is mapped to the __wchar_t
   43|       |// builtin type.  We need to make sure not to define operator wchar_t()
   44|       |// alongside operator unsigned short() in these instances.
   45|       |#define ABSL_INTERNAL_WCHAR_T __wchar_t
   46|       |#if defined(_M_X64)
   47|       |#include <intrin.h>
   48|       |#pragma intrinsic(_umul128)
   49|       |#endif  // defined(_M_X64)
   50|       |#else   // defined(_MSC_VER)
   51|       |#define ABSL_INTERNAL_WCHAR_T wchar_t
   52|       |#endif  // defined(_MSC_VER)
   53|       |
   54|       |namespace absl {
   55|       |inline namespace lts_2019_08_08 {
   56|       |
   57|       |// uint128
   58|       |//
   59|       |// An unsigned 128-bit integer type. The API is meant to mimic an intrinsic type
   60|       |// as closely as is practical, including exhibiting undefined behavior in
   61|       |// analogous cases (e.g. division by zero). This type is intended to be a
   62|       |// drop-in replacement once C++ supports an intrinsic `uint128_t` type; when
   63|       |// that occurs, existing well-behaved uses of `uint128` will continue to work
   64|       |// using that new type.
   65|       |//
   66|       |// Note: code written with this type will continue to compile once `uint128_t`
   67|       |// is introduced, provided the replacement helper functions
   68|       |// `Uint128(Low|High)64()` and `MakeUint128()` are made.
   69|       |//
   70|       |// A `uint128` supports the following:
   71|       |//
   72|       |//   * Implicit construction from integral types
   73|       |//   * Explicit conversion to integral types
   74|       |//
   75|       |// Additionally, if your compiler supports `__int128`, `uint128` is
   76|       |// interoperable with that type. (Abseil checks for this compatibility through
   77|       |// the `ABSL_HAVE_INTRINSIC_INT128` macro.)
   78|       |//
   79|       |// However, a `uint128` differs from intrinsic integral types in the following
   80|       |// ways:
   81|       |//
   82|       |//   * Errors on implicit conversions that do not preserve value (such as
   83|       |//     loss of precision when converting to float values).
   84|       |//   * Requires explicit construction from and conversion to floating point
   85|       |//     types.
   86|       |//   * Conversion to integral types requires an explicit static_cast() to
   87|       |//     mimic use of the `-Wnarrowing` compiler flag.
   88|       |//   * The alignment requirement of `uint128` may differ from that of an
   89|       |//     intrinsic 128-bit integer type depending on platform and build
   90|       |//     configuration.
   91|       |//
   92|       |// Example:
   93|       |//
   94|       |//     float y = absl::Uint128Max();  // Error. uint128 cannot be implicitly
   95|       |//                                    // converted to float.
   96|       |//
   97|       |//     absl::uint128 v;
   98|       |//     uint64_t i = v;                         // Error
   99|       |//     uint64_t i = static_cast<uint64_t>(v);  // OK
  100|       |//
  101|       |class
  102|       |#if defined(ABSL_HAVE_INTRINSIC_INT128)
  103|       |    alignas(unsigned __int128)
  104|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  105|       |        uint128 {
  106|       | public:
  107|       |  uint128() = default;
  108|       |
  109|       |  // Constructors from arithmetic types
  110|       |  constexpr uint128(int v);                 // NOLINT(runtime/explicit)
  111|       |  constexpr uint128(unsigned int v);        // NOLINT(runtime/explicit)
  112|       |  constexpr uint128(long v);                // NOLINT(runtime/int)
  113|       |  constexpr uint128(unsigned long v);       // NOLINT(runtime/int)
  114|       |  constexpr uint128(long long v);           // NOLINT(runtime/int)
  115|       |  constexpr uint128(unsigned long long v);  // NOLINT(runtime/int)
  116|       |#ifdef ABSL_HAVE_INTRINSIC_INT128
  117|       |  constexpr uint128(__int128 v);           // NOLINT(runtime/explicit)
  118|       |  constexpr uint128(unsigned __int128 v);  // NOLINT(runtime/explicit)
  119|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  120|       |  explicit uint128(float v);
  121|       |  explicit uint128(double v);
  122|       |  explicit uint128(long double v);
  123|       |
  124|       |  // Assignment operators from arithmetic types
  125|       |  uint128& operator=(int v);
  126|       |  uint128& operator=(unsigned int v);
  127|       |  uint128& operator=(long v);                // NOLINT(runtime/int)
  128|       |  uint128& operator=(unsigned long v);       // NOLINT(runtime/int)
  129|       |  uint128& operator=(long long v);           // NOLINT(runtime/int)
  130|       |  uint128& operator=(unsigned long long v);  // NOLINT(runtime/int)
  131|       |#ifdef ABSL_HAVE_INTRINSIC_INT128
  132|       |  uint128& operator=(__int128 v);
  133|       |  uint128& operator=(unsigned __int128 v);
  134|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  135|       |
  136|       |  // Conversion operators to other arithmetic types
  137|       |  constexpr explicit operator bool() const;
  138|       |  constexpr explicit operator char() const;
  139|       |  constexpr explicit operator signed char() const;
  140|       |  constexpr explicit operator unsigned char() const;
  141|       |  constexpr explicit operator char16_t() const;
  142|       |  constexpr explicit operator char32_t() const;
  143|       |  constexpr explicit operator ABSL_INTERNAL_WCHAR_T() const;
  144|       |  constexpr explicit operator short() const;  // NOLINT(runtime/int)
  145|       |  // NOLINTNEXTLINE(runtime/int)
  146|       |  constexpr explicit operator unsigned short() const;
  147|       |  constexpr explicit operator int() const;
  148|       |  constexpr explicit operator unsigned int() const;
  149|       |  constexpr explicit operator long() const;  // NOLINT(runtime/int)
  150|       |  // NOLINTNEXTLINE(runtime/int)
  151|       |  constexpr explicit operator unsigned long() const;
  152|       |  // NOLINTNEXTLINE(runtime/int)
  153|       |  constexpr explicit operator long long() const;
  154|       |  // NOLINTNEXTLINE(runtime/int)
  155|       |  constexpr explicit operator unsigned long long() const;
  156|       |#ifdef ABSL_HAVE_INTRINSIC_INT128
  157|       |  constexpr explicit operator __int128() const;
  158|       |  constexpr explicit operator unsigned __int128() const;
  159|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  160|       |  explicit operator float() const;
  161|       |  explicit operator double() const;
  162|       |  explicit operator long double() const;
  163|       |
  164|       |  // Trivial copy constructor, assignment operator and destructor.
  165|       |
  166|       |  // Arithmetic operators.
  167|       |  uint128& operator+=(uint128 other);
  168|       |  uint128& operator-=(uint128 other);
  169|       |  uint128& operator*=(uint128 other);
  170|       |  // Long division/modulo for uint128.
  171|       |  uint128& operator/=(uint128 other);
  172|       |  uint128& operator%=(uint128 other);
  173|       |  uint128 operator++(int);
  174|       |  uint128 operator--(int);
  175|       |  uint128& operator<<=(int);
  176|       |  uint128& operator>>=(int);
  177|       |  uint128& operator&=(uint128 other);
  178|       |  uint128& operator|=(uint128 other);
  179|       |  uint128& operator^=(uint128 other);
  180|       |  uint128& operator++();
  181|       |  uint128& operator--();
  182|       |
  183|       |  // Uint128Low64()
  184|       |  //
  185|       |  // Returns the lower 64-bit value of a `uint128` value.
  186|       |  friend constexpr uint64_t Uint128Low64(uint128 v);
  187|       |
  188|       |  // Uint128High64()
  189|       |  //
  190|       |  // Returns the higher 64-bit value of a `uint128` value.
  191|       |  friend constexpr uint64_t Uint128High64(uint128 v);
  192|       |
  193|       |  // MakeUInt128()
  194|       |  //
  195|       |  // Constructs a `uint128` numeric value from two 64-bit unsigned integers.
  196|       |  // Note that this factory function is the only way to construct a `uint128`
  197|       |  // from integer values greater than 2^64.
  198|       |  //
  199|       |  // Example:
  200|       |  //
  201|       |  //   absl::uint128 big = absl::MakeUint128(1, 0);
  202|       |  friend constexpr uint128 MakeUint128(uint64_t high, uint64_t low);
  203|       |
  204|       |  // Uint128Max()
  205|       |  //
  206|       |  // Returns the highest value for a 128-bit unsigned integer.
  207|       |  friend constexpr uint128 Uint128Max();
  208|       |
  209|       |  // Support for absl::Hash.
  210|       |  template <typename H>
  211|       |  friend H AbslHashValue(H h, uint128 v) {
  212|       |    return H::combine(std::move(h), Uint128High64(v), Uint128Low64(v));
  213|       |  }
  214|       |
  215|       | private:
  216|       |  constexpr uint128(uint64_t high, uint64_t low);
  217|       |
  218|       |  // TODO(strel) Update implementation to use __int128 once all users of
  219|       |  // uint128 are fixed to not depend on alignof(uint128) == 8. Also add
  220|       |  // alignas(16) to class definition to keep alignment consistent across
  221|       |  // platforms.
  222|       |#if defined(ABSL_IS_LITTLE_ENDIAN)
  223|       |  uint64_t lo_;
  224|       |  uint64_t hi_;
  225|       |#elif defined(ABSL_IS_BIG_ENDIAN)
  226|       |  uint64_t hi_;
  227|       |  uint64_t lo_;
  228|       |#else  // byte order
  229|       |#error "Unsupported byte order: must be little-endian or big-endian."
  230|       |#endif  // byte order
  231|       |};
  232|       |
  233|       |// Prefer to use the constexpr `Uint128Max()`.
  234|       |//
  235|       |// TODO(absl-team) deprecate kuint128max once migration tool is released.
  236|       |extern const uint128 kuint128max;
  237|       |
  238|       |// allow uint128 to be logged
  239|       |std::ostream& operator<<(std::ostream& os, uint128 v);
  240|       |
  241|       |// TODO(strel) add operator>>(std::istream&, uint128)
  242|       |
  243|      0|constexpr uint128 Uint128Max() {
  244|      0|  return uint128((std::numeric_limits<uint64_t>::max)(),
  245|      0|                 (std::numeric_limits<uint64_t>::max)());
  246|      0|}
  247|       |
  248|       |}  // inline namespace lts_2019_08_08
  249|       |}  // namespace absl
  250|       |
  251|       |// Specialized numeric_limits for uint128.
  252|       |namespace std {
  253|       |template <>
  254|       |class numeric_limits<absl::uint128> {
  255|       | public:
  256|       |  static constexpr bool is_specialized = true;
  257|       |  static constexpr bool is_signed = false;
  258|       |  static constexpr bool is_integer = true;
  259|       |  static constexpr bool is_exact = true;
  260|       |  static constexpr bool has_infinity = false;
  261|       |  static constexpr bool has_quiet_NaN = false;
  262|       |  static constexpr bool has_signaling_NaN = false;
  263|       |  static constexpr float_denorm_style has_denorm = denorm_absent;
  264|       |  static constexpr bool has_denorm_loss = false;
  265|       |  static constexpr float_round_style round_style = round_toward_zero;
  266|       |  static constexpr bool is_iec559 = false;
  267|       |  static constexpr bool is_bounded = true;
  268|       |  static constexpr bool is_modulo = true;
  269|       |  static constexpr int digits = 128;
  270|       |  static constexpr int digits10 = 38;
  271|       |  static constexpr int max_digits10 = 0;
  272|       |  static constexpr int radix = 2;
  273|       |  static constexpr int min_exponent = 0;
  274|       |  static constexpr int min_exponent10 = 0;
  275|       |  static constexpr int max_exponent = 0;
  276|       |  static constexpr int max_exponent10 = 0;
  277|       |#ifdef ABSL_HAVE_INTRINSIC_INT128
  278|       |  static constexpr bool traps = numeric_limits<unsigned __int128>::traps;
  279|       |#else   // ABSL_HAVE_INTRINSIC_INT128
  280|       |  static constexpr bool traps = numeric_limits<uint64_t>::traps;
  281|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  282|       |  static constexpr bool tinyness_before = false;
  283|       |
  284|      0|  static constexpr absl::uint128 (min)() { return 0; }
  285|      0|  static constexpr absl::uint128 lowest() { return 0; }
  286|      0|  static constexpr absl::uint128 (max)() { return absl::Uint128Max(); }
  287|      0|  static constexpr absl::uint128 epsilon() { return 0; }
  288|      0|  static constexpr absl::uint128 round_error() { return 0; }
  289|      0|  static constexpr absl::uint128 infinity() { return 0; }
  290|      0|  static constexpr absl::uint128 quiet_NaN() { return 0; }
  291|      0|  static constexpr absl::uint128 signaling_NaN() { return 0; }
  292|      0|  static constexpr absl::uint128 denorm_min() { return 0; }
  293|       |};
  294|       |}  // namespace std
  295|       |
  296|       |// TODO(absl-team): Implement signed 128-bit type
  297|       |
  298|       |// --------------------------------------------------------------------------
  299|       |//                      Implementation details follow
  300|       |// --------------------------------------------------------------------------
  301|       |namespace absl {
  302|       |inline namespace lts_2019_08_08 {
  303|       |
  304|      0|constexpr uint128 MakeUint128(uint64_t high, uint64_t low) {
  305|      0|  return uint128(high, low);
  306|      0|}
  307|       |
  308|       |// Assignment from integer types.
  309|       |
  310|      0|inline uint128& uint128::operator=(int v) { return *this = uint128(v); }
  311|       |
  312|      0|inline uint128& uint128::operator=(unsigned int v) {
  313|      0|  return *this = uint128(v);
  314|      0|}
  315|       |
  316|      0|inline uint128& uint128::operator=(long v) {  // NOLINT(runtime/int)
  317|      0|  return *this = uint128(v);
  318|      0|}
  319|       |
  320|       |// NOLINTNEXTLINE(runtime/int)
  321|      0|inline uint128& uint128::operator=(unsigned long v) {
  322|      0|  return *this = uint128(v);
  323|      0|}
  324|       |
  325|       |// NOLINTNEXTLINE(runtime/int)
  326|      0|inline uint128& uint128::operator=(long long v) {
  327|      0|  return *this = uint128(v);
  328|      0|}
  329|       |
  330|       |// NOLINTNEXTLINE(runtime/int)
  331|      0|inline uint128& uint128::operator=(unsigned long long v) {
  332|      0|  return *this = uint128(v);
  333|      0|}
  334|       |
  335|       |#ifdef ABSL_HAVE_INTRINSIC_INT128
  336|      0|inline uint128& uint128::operator=(__int128 v) {
  337|      0|  return *this = uint128(v);
  338|      0|}
  339|       |
  340|      0|inline uint128& uint128::operator=(unsigned __int128 v) {
  341|      0|  return *this = uint128(v);
  342|      0|}
  343|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  344|       |
  345|       |// Arithmetic operators.
  346|       |
  347|       |uint128 operator<<(uint128 lhs, int amount);
  348|       |uint128 operator>>(uint128 lhs, int amount);
  349|       |uint128 operator+(uint128 lhs, uint128 rhs);
  350|       |uint128 operator-(uint128 lhs, uint128 rhs);
  351|       |uint128 operator*(uint128 lhs, uint128 rhs);
  352|       |uint128 operator/(uint128 lhs, uint128 rhs);
  353|       |uint128 operator%(uint128 lhs, uint128 rhs);
  354|       |
  355|      0|inline uint128& uint128::operator<<=(int amount) {
  356|      0|  *this = *this << amount;
  357|      0|  return *this;
  358|      0|}
  359|       |
  360|      0|inline uint128& uint128::operator>>=(int amount) {
  361|      0|  *this = *this >> amount;
  362|      0|  return *this;
  363|      0|}
  364|       |
  365|      0|inline uint128& uint128::operator+=(uint128 other) {
  366|      0|  *this = *this + other;
  367|      0|  return *this;
  368|      0|}
  369|       |
  370|      0|inline uint128& uint128::operator-=(uint128 other) {
  371|      0|  *this = *this - other;
  372|      0|  return *this;
  373|      0|}
  374|       |
  375|      0|inline uint128& uint128::operator*=(uint128 other) {
  376|      0|  *this = *this * other;
  377|      0|  return *this;
  378|      0|}
  379|       |
  380|      0|inline uint128& uint128::operator/=(uint128 other) {
  381|      0|  *this = *this / other;
  382|      0|  return *this;
  383|      0|}
  384|       |
  385|      0|inline uint128& uint128::operator%=(uint128 other) {
  386|      0|  *this = *this % other;
  387|      0|  return *this;
  388|      0|}
  389|       |
  390|      0|constexpr uint64_t Uint128Low64(uint128 v) { return v.lo_; }
  391|       |
  392|      0|constexpr uint64_t Uint128High64(uint128 v) { return v.hi_; }
  393|       |
  394|       |// Constructors from integer types.
  395|       |
  396|       |#if defined(ABSL_IS_LITTLE_ENDIAN)
  397|       |
  398|       |constexpr uint128::uint128(uint64_t high, uint64_t low)
  399|      0|    : lo_{low}, hi_{high} {}
  400|       |
  401|       |constexpr uint128::uint128(int v)
  402|       |    : lo_{static_cast<uint64_t>(v)},
  403|      0|      hi_{v < 0 ? (std::numeric_limits<uint64_t>::max)() : 0} {}
  404|       |constexpr uint128::uint128(long v)  // NOLINT(runtime/int)
  405|       |    : lo_{static_cast<uint64_t>(v)},
  406|      0|      hi_{v < 0 ? (std::numeric_limits<uint64_t>::max)() : 0} {}
  407|       |constexpr uint128::uint128(long long v)  // NOLINT(runtime/int)
  408|       |    : lo_{static_cast<uint64_t>(v)},
  409|       |      hi_{v < 0 ? (std::numeric_limits<uint64_t>::max)() : 0} {}
  410|       |
  411|      0|constexpr uint128::uint128(unsigned int v) : lo_{v}, hi_{0} {}
  412|       |// NOLINTNEXTLINE(runtime/int)
  413|      0|constexpr uint128::uint128(unsigned long v) : lo_{v}, hi_{0} {}
  414|       |// NOLINTNEXTLINE(runtime/int)
  415|      0|constexpr uint128::uint128(unsigned long long v) : lo_{v}, hi_{0} {}
  416|       |
  417|       |#ifdef ABSL_HAVE_INTRINSIC_INT128
  418|       |constexpr uint128::uint128(__int128 v)
  419|       |    : lo_{static_cast<uint64_t>(v & ~uint64_t{0})},
  420|       |      hi_{static_cast<uint64_t>(static_cast<unsigned __int128>(v) >> 64)} {}
  421|       |constexpr uint128::uint128(unsigned __int128 v)
  422|       |    : lo_{static_cast<uint64_t>(v & ~uint64_t{0})},
  423|      0|      hi_{static_cast<uint64_t>(v >> 64)} {}
  424|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  425|       |
  426|       |#elif defined(ABSL_IS_BIG_ENDIAN)
  427|       |
  428|       |constexpr uint128::uint128(uint64_t high, uint64_t low)
  429|       |    : hi_{high}, lo_{low} {}
  430|       |
  431|       |constexpr uint128::uint128(int v)
  432|       |    : hi_{v < 0 ? (std::numeric_limits<uint64_t>::max)() : 0},
  433|       |      lo_{static_cast<uint64_t>(v)} {}
  434|       |constexpr uint128::uint128(long v)  // NOLINT(runtime/int)
  435|       |    : hi_{v < 0 ? (std::numeric_limits<uint64_t>::max)() : 0},
  436|       |      lo_{static_cast<uint64_t>(v)} {}
  437|       |constexpr uint128::uint128(long long v)  // NOLINT(runtime/int)
  438|       |    : hi_{v < 0 ? (std::numeric_limits<uint64_t>::max)() : 0},
  439|       |      lo_{static_cast<uint64_t>(v)} {}
  440|       |
  441|       |constexpr uint128::uint128(unsigned int v) : hi_{0}, lo_{v} {}
  442|       |// NOLINTNEXTLINE(runtime/int)
  443|       |constexpr uint128::uint128(unsigned long v) : hi_{0}, lo_{v} {}
  444|       |// NOLINTNEXTLINE(runtime/int)
  445|       |constexpr uint128::uint128(unsigned long long v) : hi_{0}, lo_{v} {}
  446|       |
  447|       |#ifdef ABSL_HAVE_INTRINSIC_INT128
  448|       |constexpr uint128::uint128(__int128 v)
  449|       |    : hi_{static_cast<uint64_t>(static_cast<unsigned __int128>(v) >> 64)},
  450|       |      lo_{static_cast<uint64_t>(v & ~uint64_t{0})} {}
  451|       |constexpr uint128::uint128(unsigned __int128 v)
  452|       |    : hi_{static_cast<uint64_t>(v >> 64)},
  453|       |      lo_{static_cast<uint64_t>(v & ~uint64_t{0})} {}
  454|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  455|       |
  456|       |#else  // byte order
  457|       |#error "Unsupported byte order: must be little-endian or big-endian."
  458|       |#endif  // byte order
  459|       |
  460|       |// Conversion operators to integer types.
  461|       |
  462|      0|constexpr uint128::operator bool() const { return lo_ || hi_; }
  463|       |
  464|      0|constexpr uint128::operator char() const { return static_cast<char>(lo_); }
  465|       |
  466|      0|constexpr uint128::operator signed char() const {
  467|      0|  return static_cast<signed char>(lo_);
  468|      0|}
  469|       |
  470|      0|constexpr uint128::operator unsigned char() const {
  471|      0|  return static_cast<unsigned char>(lo_);
  472|      0|}
  473|       |
  474|      0|constexpr uint128::operator char16_t() const {
  475|      0|  return static_cast<char16_t>(lo_);
  476|      0|}
  477|       |
  478|      0|constexpr uint128::operator char32_t() const {
  479|      0|  return static_cast<char32_t>(lo_);
  480|      0|}
  481|       |
  482|      0|constexpr uint128::operator ABSL_INTERNAL_WCHAR_T() const {
  483|      0|  return static_cast<ABSL_INTERNAL_WCHAR_T>(lo_);
  484|      0|}
  485|       |
  486|       |// NOLINTNEXTLINE(runtime/int)
  487|      0|constexpr uint128::operator short() const { return static_cast<short>(lo_); }
  488|       |
  489|      0|constexpr uint128::operator unsigned short() const {  // NOLINT(runtime/int)
  490|      0|  return static_cast<unsigned short>(lo_);            // NOLINT(runtime/int)
  491|      0|}
  492|       |
  493|      0|constexpr uint128::operator int() const { return static_cast<int>(lo_); }
  494|       |
  495|      0|constexpr uint128::operator unsigned int() const {
  496|      0|  return static_cast<unsigned int>(lo_);
  497|      0|}
  498|       |
  499|       |// NOLINTNEXTLINE(runtime/int)
  500|      0|constexpr uint128::operator long() const { return static_cast<long>(lo_); }
  501|       |
  502|      0|constexpr uint128::operator unsigned long() const {  // NOLINT(runtime/int)
  503|      0|  return static_cast<unsigned long>(lo_);            // NOLINT(runtime/int)
  504|      0|}
  505|       |
  506|      0|constexpr uint128::operator long long() const {  // NOLINT(runtime/int)
  507|      0|  return static_cast<long long>(lo_);            // NOLINT(runtime/int)
  508|      0|}
  509|       |
  510|      0|constexpr uint128::operator unsigned long long() const {  // NOLINT(runtime/int)
  511|      0|  return static_cast<unsigned long long>(lo_);            // NOLINT(runtime/int)
  512|      0|}
  513|       |
  514|       |#ifdef ABSL_HAVE_INTRINSIC_INT128
  515|      0|constexpr uint128::operator __int128() const {
  516|      0|  return (static_cast<__int128>(hi_) << 64) + lo_;
  517|      0|}
  518|       |
  519|      0|constexpr uint128::operator unsigned __int128() const {
  520|      0|  return (static_cast<unsigned __int128>(hi_) << 64) + lo_;
  521|      0|}
  522|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  523|       |
  524|       |// Conversion operators to floating point types.
  525|       |
  526|      0|inline uint128::operator float() const {
  527|      0|  return static_cast<float>(lo_) + std::ldexp(static_cast<float>(hi_), 64);
  528|      0|}
  529|       |
  530|      0|inline uint128::operator double() const {
  531|      0|  return static_cast<double>(lo_) + std::ldexp(static_cast<double>(hi_), 64);
  532|      0|}
  533|       |
  534|      0|inline uint128::operator long double() const {
  535|      0|  return static_cast<long double>(lo_) +
  536|      0|         std::ldexp(static_cast<long double>(hi_), 64);
  537|      0|}
  538|       |
  539|       |// Comparison operators.
  540|       |
  541|      0|inline bool operator==(uint128 lhs, uint128 rhs) {
  542|      0|  return (Uint128Low64(lhs) == Uint128Low64(rhs) &&
  543|      0|          Uint128High64(lhs) == Uint128High64(rhs));
  544|      0|}
  545|       |
  546|      0|inline bool operator!=(uint128 lhs, uint128 rhs) {
  547|      0|  return !(lhs == rhs);
  548|      0|}
  549|       |
  550|      0|inline bool operator<(uint128 lhs, uint128 rhs) {
  551|      0|  return (Uint128High64(lhs) == Uint128High64(rhs))
  552|      0|             ? (Uint128Low64(lhs) < Uint128Low64(rhs))
  553|      0|             : (Uint128High64(lhs) < Uint128High64(rhs));
  554|      0|}
  555|       |
  556|      0|inline bool operator>(uint128 lhs, uint128 rhs) {
  557|      0|  return (Uint128High64(lhs) == Uint128High64(rhs))
  558|      0|             ? (Uint128Low64(lhs) > Uint128Low64(rhs))
  559|      0|             : (Uint128High64(lhs) > Uint128High64(rhs));
  560|      0|}
  561|       |
  562|      0|inline bool operator<=(uint128 lhs, uint128 rhs) {
  563|      0|  return (Uint128High64(lhs) == Uint128High64(rhs))
  564|      0|             ? (Uint128Low64(lhs) <= Uint128Low64(rhs))
  565|      0|             : (Uint128High64(lhs) <= Uint128High64(rhs));
  566|      0|}
  567|       |
  568|      0|inline bool operator>=(uint128 lhs, uint128 rhs) {
  569|      0|  return (Uint128High64(lhs) == Uint128High64(rhs))
  570|      0|             ? (Uint128Low64(lhs) >= Uint128Low64(rhs))
  571|      0|             : (Uint128High64(lhs) >= Uint128High64(rhs));
  572|      0|}
  573|       |
  574|       |// Unary operators.
  575|       |
  576|      0|inline uint128 operator-(uint128 val) {
  577|      0|  uint64_t hi = ~Uint128High64(val);
  578|      0|  uint64_t lo = ~Uint128Low64(val) + 1;
  579|      0|  if (lo == 0) ++hi;  // carry
  580|      0|  return MakeUint128(hi, lo);
  581|      0|}
  582|       |
  583|      0|inline bool operator!(uint128 val) {
  584|      0|  return !Uint128High64(val) && !Uint128Low64(val);
  585|      0|}
  586|       |
  587|       |// Logical operators.
  588|       |
  589|      0|inline uint128 operator~(uint128 val) {
  590|      0|  return MakeUint128(~Uint128High64(val), ~Uint128Low64(val));
  591|      0|}
  592|       |
  593|      0|inline uint128 operator|(uint128 lhs, uint128 rhs) {
  594|      0|  return MakeUint128(Uint128High64(lhs) | Uint128High64(rhs),
  595|      0|                           Uint128Low64(lhs) | Uint128Low64(rhs));
  596|      0|}
  597|       |
  598|      0|inline uint128 operator&(uint128 lhs, uint128 rhs) {
  599|      0|  return MakeUint128(Uint128High64(lhs) & Uint128High64(rhs),
  600|      0|                           Uint128Low64(lhs) & Uint128Low64(rhs));
  601|      0|}
  602|       |
  603|      0|inline uint128 operator^(uint128 lhs, uint128 rhs) {
  604|      0|  return MakeUint128(Uint128High64(lhs) ^ Uint128High64(rhs),
  605|      0|                           Uint128Low64(lhs) ^ Uint128Low64(rhs));
  606|      0|}
  607|       |
  608|      0|inline uint128& uint128::operator|=(uint128 other) {
  609|      0|  hi_ |= other.hi_;
  610|      0|  lo_ |= other.lo_;
  611|      0|  return *this;
  612|      0|}
  613|       |
  614|      0|inline uint128& uint128::operator&=(uint128 other) {
  615|      0|  hi_ &= other.hi_;
  616|      0|  lo_ &= other.lo_;
  617|      0|  return *this;
  618|      0|}
  619|       |
  620|      0|inline uint128& uint128::operator^=(uint128 other) {
  621|      0|  hi_ ^= other.hi_;
  622|      0|  lo_ ^= other.lo_;
  623|      0|  return *this;
  624|      0|}
  625|       |
  626|       |// Arithmetic operators.
  627|       |
  628|      0|inline uint128 operator<<(uint128 lhs, int amount) {
  629|      0|  // uint64_t shifts of >= 64 are undefined, so we will need some
  630|      0|  // special-casing.
  631|      0|  if (amount < 64) {
  632|      0|    if (amount != 0) {
  633|      0|      return MakeUint128(
  634|      0|          (Uint128High64(lhs) << amount) | (Uint128Low64(lhs) >> (64 - amount)),
  635|      0|          Uint128Low64(lhs) << amount);
  636|      0|    }
  637|      0|    return lhs;
  638|      0|  }
  639|      0|  return MakeUint128(Uint128Low64(lhs) << (amount - 64), 0);
  640|      0|}
  641|       |
  642|      0|inline uint128 operator>>(uint128 lhs, int amount) {
  643|      0|  // uint64_t shifts of >= 64 are undefined, so we will need some
  644|      0|  // special-casing.
  645|      0|  if (amount < 64) {
  646|      0|    if (amount != 0) {
  647|      0|      return MakeUint128(Uint128High64(lhs) >> amount,
  648|      0|                         (Uint128Low64(lhs) >> amount) |
  649|      0|                             (Uint128High64(lhs) << (64 - amount)));
  650|      0|    }
  651|      0|    return lhs;
  652|      0|  }
  653|      0|  return MakeUint128(0, Uint128High64(lhs) >> (amount - 64));
  654|      0|}
  655|       |
  656|      0|inline uint128 operator+(uint128 lhs, uint128 rhs) {
  657|      0|  uint128 result = MakeUint128(Uint128High64(lhs) + Uint128High64(rhs),
  658|      0|                               Uint128Low64(lhs) + Uint128Low64(rhs));
  659|      0|  if (Uint128Low64(result) < Uint128Low64(lhs)) {  // check for carry
  660|      0|    return MakeUint128(Uint128High64(result) + 1, Uint128Low64(result));
  661|      0|  }
  662|      0|  return result;
  663|      0|}
  664|       |
  665|      0|inline uint128 operator-(uint128 lhs, uint128 rhs) {
  666|      0|  uint128 result = MakeUint128(Uint128High64(lhs) - Uint128High64(rhs),
  667|      0|                               Uint128Low64(lhs) - Uint128Low64(rhs));
  668|      0|  if (Uint128Low64(lhs) < Uint128Low64(rhs)) {  // check for carry
  669|      0|    return MakeUint128(Uint128High64(result) - 1, Uint128Low64(result));
  670|      0|  }
  671|      0|  return result;
  672|      0|}
  673|       |
  674|      0|inline uint128 operator*(uint128 lhs, uint128 rhs) {
  675|      0|#if defined(ABSL_HAVE_INTRINSIC_INT128)
  676|      0|  // TODO(strel) Remove once alignment issues are resolved and unsigned __int128
  677|      0|  // can be used for uint128 storage.
  678|      0|  return static_cast<unsigned __int128>(lhs) *
  679|      0|         static_cast<unsigned __int128>(rhs);
  680|       |#elif defined(_MSC_VER) && defined(_M_X64)
  681|       |  uint64_t carry;
  682|       |  uint64_t low = _umul128(Uint128Low64(lhs), Uint128Low64(rhs), &carry);
  683|       |  return MakeUint128(Uint128Low64(lhs) * Uint128High64(rhs) +
  684|       |                         Uint128High64(lhs) * Uint128Low64(rhs) + carry,
  685|       |                     low);
  686|       |#else   // ABSL_HAVE_INTRINSIC128
  687|       |  uint64_t a32 = Uint128Low64(lhs) >> 32;
  688|       |  uint64_t a00 = Uint128Low64(lhs) & 0xffffffff;
  689|       |  uint64_t b32 = Uint128Low64(rhs) >> 32;
  690|       |  uint64_t b00 = Uint128Low64(rhs) & 0xffffffff;
  691|       |  uint128 result =
  692|       |      MakeUint128(Uint128High64(lhs) * Uint128Low64(rhs) +
  693|       |                      Uint128Low64(lhs) * Uint128High64(rhs) + a32 * b32,
  694|       |                  a00 * b00);
  695|       |  result += uint128(a32 * b00) << 32;
  696|       |  result += uint128(a00 * b32) << 32;
  697|       |  return result;
  698|       |#endif  // ABSL_HAVE_INTRINSIC128
  699|       |}
  700|       |
  701|       |// Increment/decrement operators.
  702|       |
  703|      0|inline uint128 uint128::operator++(int) {
  704|      0|  uint128 tmp(*this);
  705|      0|  *this += 1;
  706|      0|  return tmp;
  707|      0|}
  708|       |
  709|      0|inline uint128 uint128::operator--(int) {
  710|      0|  uint128 tmp(*this);
  711|      0|  *this -= 1;
  712|      0|  return tmp;
  713|      0|}
  714|       |
  715|      0|inline uint128& uint128::operator++() {
  716|      0|  *this += 1;
  717|      0|  return *this;
  718|      0|}
  719|       |
  720|      0|inline uint128& uint128::operator--() {
  721|      0|  *this -= 1;
  722|      0|  return *this;
  723|      0|}
  724|       |
  725|       |#if defined(ABSL_HAVE_INTRINSIC_INT128)
  726|       |#include "absl/numeric/int128_have_intrinsic.inc"
  727|       |#else  // ABSL_HAVE_INTRINSIC_INT128
  728|       |#include "absl/numeric/int128_no_intrinsic.inc"
  729|       |#endif  // ABSL_HAVE_INTRINSIC_INT128
  730|       |
  731|       |}  // inline namespace lts_2019_08_08
  732|       |}  // namespace absl
  733|       |
  734|       |#undef ABSL_INTERNAL_WCHAR_T
  735|       |
  736|       |#endif  // ABSL_NUMERIC_INT128_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/ascii.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/ascii.h"
   16|       |
   17|       |namespace absl {
   18|       |inline namespace lts_2019_08_08 {
   19|       |namespace ascii_internal {
   20|       |
   21|       |// # Table generated by this Python code (bit 0x02 is currently unused):
   22|       |// TODO(mbar) Move Python code for generation of table to BUILD and link here.
   23|       |
   24|       |// NOTE: The kAsciiPropertyBits table used within this code was generated by
   25|       |// Python code of the following form. (Bit 0x02 is currently unused and
   26|       |// available.)
   27|       |//
   28|       |// def Hex2(n):
   29|       |//   return '0x' + hex(n/16)[2:] + hex(n%16)[2:]
   30|       |// def IsPunct(ch):
   31|       |//   return (ord(ch) >= 32 and ord(ch) < 127 and
   32|       |//           not ch.isspace() and not ch.isalnum())
   33|       |// def IsBlank(ch):
   34|       |//   return ch in ' \t'
   35|       |// def IsCntrl(ch):
   36|       |//   return ord(ch) < 32 or ord(ch) == 127
   37|       |// def IsXDigit(ch):
   38|       |//   return ch.isdigit() or ch.lower() in 'abcdef'
   39|       |// for i in range(128):
   40|       |//   ch = chr(i)
   41|       |//   mask = ((ch.isalpha() and 0x01 or 0) |
   42|       |//           (ch.isalnum() and 0x04 or 0) |
   43|       |//           (ch.isspace() and 0x08 or 0) |
   44|       |//           (IsPunct(ch) and 0x10 or 0) |
   45|       |//           (IsBlank(ch) and 0x20 or 0) |
   46|       |//           (IsCntrl(ch) and 0x40 or 0) |
   47|       |//           (IsXDigit(ch) and 0x80 or 0))
   48|       |//   print Hex2(mask) + ',',
   49|       |//   if i % 16 == 7:
   50|       |//     print ' //', Hex2(i & 0x78)
   51|       |//   elif i % 16 == 15:
   52|       |//     print
   53|       |
   54|       |// clang-format off
   55|       |// Array of bitfields holding character information. Each bit value corresponds
   56|       |// to a particular character feature. For readability, and because the value
   57|       |// of these bits is tightly coupled to this implementation, the individual bits
   58|       |// are not named. Note that bitfields for all characters above ASCII 127 are
   59|       |// zero-initialized.
   60|       |const unsigned char kPropertyBits[256] = {
   61|       |    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  // 0x00
   62|       |    0x40, 0x68, 0x48, 0x48, 0x48, 0x48, 0x40, 0x40,
   63|       |    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  // 0x10
   64|       |    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
   65|       |    0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  // 0x20
   66|       |    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
   67|       |    0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,  // 0x30
   68|       |    0x84, 0x84, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
   69|       |    0x10, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x05,  // 0x40
   70|       |    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   71|       |    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,  // 0x50
   72|       |    0x05, 0x05, 0x05, 0x10, 0x10, 0x10, 0x10, 0x10,
   73|       |    0x10, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x05,  // 0x60
   74|       |    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   75|       |    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,  // 0x70
   76|       |    0x05, 0x05, 0x05, 0x10, 0x10, 0x10, 0x10, 0x40,
   77|       |};
   78|       |
   79|       |// Array of characters for the ascii_tolower() function. For values 'A'
   80|       |// through 'Z', return the lower-case character; otherwise, return the
   81|       |// identity of the passed character.
   82|       |const char kToLower[256] = {
   83|       |  '\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07',
   84|       |  '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e', '\x0f',
   85|       |  '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
   86|       |  '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f',
   87|       |  '\x20', '\x21', '\x22', '\x23', '\x24', '\x25', '\x26', '\x27',
   88|       |  '\x28', '\x29', '\x2a', '\x2b', '\x2c', '\x2d', '\x2e', '\x2f',
   89|       |  '\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36', '\x37',
   90|       |  '\x38', '\x39', '\x3a', '\x3b', '\x3c', '\x3d', '\x3e', '\x3f',
   91|       |  '\x40',    'a',    'b',    'c',    'd',    'e',    'f',    'g',
   92|       |     'h',    'i',    'j',    'k',    'l',    'm',    'n',    'o',
   93|       |     'p',    'q',    'r',    's',    't',    'u',    'v',    'w',
   94|       |     'x',    'y',    'z', '\x5b', '\x5c', '\x5d', '\x5e', '\x5f',
   95|       |  '\x60', '\x61', '\x62', '\x63', '\x64', '\x65', '\x66', '\x67',
   96|       |  '\x68', '\x69', '\x6a', '\x6b', '\x6c', '\x6d', '\x6e', '\x6f',
   97|       |  '\x70', '\x71', '\x72', '\x73', '\x74', '\x75', '\x76', '\x77',
   98|       |  '\x78', '\x79', '\x7a', '\x7b', '\x7c', '\x7d', '\x7e', '\x7f',
   99|       |  '\x80', '\x81', '\x82', '\x83', '\x84', '\x85', '\x86', '\x87',
  100|       |  '\x88', '\x89', '\x8a', '\x8b', '\x8c', '\x8d', '\x8e', '\x8f',
  101|       |  '\x90', '\x91', '\x92', '\x93', '\x94', '\x95', '\x96', '\x97',
  102|       |  '\x98', '\x99', '\x9a', '\x9b', '\x9c', '\x9d', '\x9e', '\x9f',
  103|       |  '\xa0', '\xa1', '\xa2', '\xa3', '\xa4', '\xa5', '\xa6', '\xa7',
  104|       |  '\xa8', '\xa9', '\xaa', '\xab', '\xac', '\xad', '\xae', '\xaf',
  105|       |  '\xb0', '\xb1', '\xb2', '\xb3', '\xb4', '\xb5', '\xb6', '\xb7',
  106|       |  '\xb8', '\xb9', '\xba', '\xbb', '\xbc', '\xbd', '\xbe', '\xbf',
  107|       |  '\xc0', '\xc1', '\xc2', '\xc3', '\xc4', '\xc5', '\xc6', '\xc7',
  108|       |  '\xc8', '\xc9', '\xca', '\xcb', '\xcc', '\xcd', '\xce', '\xcf',
  109|       |  '\xd0', '\xd1', '\xd2', '\xd3', '\xd4', '\xd5', '\xd6', '\xd7',
  110|       |  '\xd8', '\xd9', '\xda', '\xdb', '\xdc', '\xdd', '\xde', '\xdf',
  111|       |  '\xe0', '\xe1', '\xe2', '\xe3', '\xe4', '\xe5', '\xe6', '\xe7',
  112|       |  '\xe8', '\xe9', '\xea', '\xeb', '\xec', '\xed', '\xee', '\xef',
  113|       |  '\xf0', '\xf1', '\xf2', '\xf3', '\xf4', '\xf5', '\xf6', '\xf7',
  114|       |  '\xf8', '\xf9', '\xfa', '\xfb', '\xfc', '\xfd', '\xfe', '\xff',
  115|       |};
  116|       |
  117|       |// Array of characters for the ascii_toupper() function. For values 'a'
  118|       |// through 'z', return the upper-case character; otherwise, return the
  119|       |// identity of the passed character.
  120|       |const char kToUpper[256] = {
  121|       |  '\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07',
  122|       |  '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e', '\x0f',
  123|       |  '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
  124|       |  '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f',
  125|       |  '\x20', '\x21', '\x22', '\x23', '\x24', '\x25', '\x26', '\x27',
  126|       |  '\x28', '\x29', '\x2a', '\x2b', '\x2c', '\x2d', '\x2e', '\x2f',
  127|       |  '\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36', '\x37',
  128|       |  '\x38', '\x39', '\x3a', '\x3b', '\x3c', '\x3d', '\x3e', '\x3f',
  129|       |  '\x40', '\x41', '\x42', '\x43', '\x44', '\x45', '\x46', '\x47',
  130|       |  '\x48', '\x49', '\x4a', '\x4b', '\x4c', '\x4d', '\x4e', '\x4f',
  131|       |  '\x50', '\x51', '\x52', '\x53', '\x54', '\x55', '\x56', '\x57',
  132|       |  '\x58', '\x59', '\x5a', '\x5b', '\x5c', '\x5d', '\x5e', '\x5f',
  133|       |  '\x60',    'A',    'B',    'C',    'D',    'E',    'F',    'G',
  134|       |     'H',    'I',    'J',    'K',    'L',    'M',    'N',    'O',
  135|       |     'P',    'Q',    'R',    'S',    'T',    'U',    'V',    'W',
  136|       |     'X',    'Y',    'Z', '\x7b', '\x7c', '\x7d', '\x7e', '\x7f',
  137|       |  '\x80', '\x81', '\x82', '\x83', '\x84', '\x85', '\x86', '\x87',
  138|       |  '\x88', '\x89', '\x8a', '\x8b', '\x8c', '\x8d', '\x8e', '\x8f',
  139|       |  '\x90', '\x91', '\x92', '\x93', '\x94', '\x95', '\x96', '\x97',
  140|       |  '\x98', '\x99', '\x9a', '\x9b', '\x9c', '\x9d', '\x9e', '\x9f',
  141|       |  '\xa0', '\xa1', '\xa2', '\xa3', '\xa4', '\xa5', '\xa6', '\xa7',
  142|       |  '\xa8', '\xa9', '\xaa', '\xab', '\xac', '\xad', '\xae', '\xaf',
  143|       |  '\xb0', '\xb1', '\xb2', '\xb3', '\xb4', '\xb5', '\xb6', '\xb7',
  144|       |  '\xb8', '\xb9', '\xba', '\xbb', '\xbc', '\xbd', '\xbe', '\xbf',
  145|       |  '\xc0', '\xc1', '\xc2', '\xc3', '\xc4', '\xc5', '\xc6', '\xc7',
  146|       |  '\xc8', '\xc9', '\xca', '\xcb', '\xcc', '\xcd', '\xce', '\xcf',
  147|       |  '\xd0', '\xd1', '\xd2', '\xd3', '\xd4', '\xd5', '\xd6', '\xd7',
  148|       |  '\xd8', '\xd9', '\xda', '\xdb', '\xdc', '\xdd', '\xde', '\xdf',
  149|       |  '\xe0', '\xe1', '\xe2', '\xe3', '\xe4', '\xe5', '\xe6', '\xe7',
  150|       |  '\xe8', '\xe9', '\xea', '\xeb', '\xec', '\xed', '\xee', '\xef',
  151|       |  '\xf0', '\xf1', '\xf2', '\xf3', '\xf4', '\xf5', '\xf6', '\xf7',
  152|       |  '\xf8', '\xf9', '\xfa', '\xfb', '\xfc', '\xfd', '\xfe', '\xff',
  153|       |};
  154|       |// clang-format on
  155|       |
  156|       |}  // namespace ascii_internal
  157|       |
  158|      0|void AsciiStrToLower(std::string* s) {
  159|      0|  for (auto& ch : *s) {
  160|      0|    ch = absl::ascii_tolower(ch);
  161|      0|  }
  162|      0|}
  163|       |
  164|      0|void AsciiStrToUpper(std::string* s) {
  165|      0|  for (auto& ch : *s) {
  166|      0|    ch = absl::ascii_toupper(ch);
  167|      0|  }
  168|      0|}
  169|       |
  170|      0|void RemoveExtraAsciiWhitespace(std::string* str) {
  171|      0|  auto stripped = StripAsciiWhitespace(*str);
  172|      0|
  173|      0|  if (stripped.empty()) {
  174|      0|    str->clear();
  175|      0|    return;
  176|      0|  }
  177|      0|
  178|      0|  auto input_it = stripped.begin();
  179|      0|  auto input_end = stripped.end();
  180|      0|  auto output_it = &(*str)[0];
  181|      0|  bool is_ws = false;
  182|      0|
  183|      0|  for (; input_it < input_end; ++input_it) {
  184|      0|    if (is_ws) {
  185|      0|      // Consecutive whitespace?  Keep only the last.
  186|      0|      is_ws = absl::ascii_isspace(*input_it);
  187|      0|      if (is_ws) --output_it;
  188|      0|    } else {
  189|      0|      is_ws = absl::ascii_isspace(*input_it);
  190|      0|    }
  191|      0|
  192|      0|    *output_it = *input_it;
  193|      0|    ++output_it;
  194|      0|  }
  195|      0|
  196|      0|  str->erase(output_it - &(*str)[0]);
  197|      0|}
  198|       |
  199|       |}  // inline namespace lts_2019_08_08
  200|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/ascii.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: ascii.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This package contains functions operating on characters and strings
   21|       |// restricted to standard ASCII. These include character classification
   22|       |// functions analogous to those found in the ANSI C Standard Library <ctype.h>
   23|       |// header file.
   24|       |//
   25|       |// C++ implementations provide <ctype.h> functionality based on their
   26|       |// C environment locale. In general, reliance on such a locale is not ideal, as
   27|       |// the locale standard is problematic (and may not return invariant information
   28|       |// for the same character set, for example). These `ascii_*()` functions are
   29|       |// hard-wired for standard ASCII, much faster, and guaranteed to behave
   30|       |// consistently.  They will never be overloaded, nor will their function
   31|       |// signature change.
   32|       |//
   33|       |// `ascii_isalnum()`, `ascii_isalpha()`, `ascii_isascii()`, `ascii_isblank()`,
   34|       |// `ascii_iscntrl()`, `ascii_isdigit()`, `ascii_isgraph()`, `ascii_islower()`,
   35|       |// `ascii_isprint()`, `ascii_ispunct()`, `ascii_isspace()`, `ascii_isupper()`,
   36|       |// `ascii_isxdigit()`
   37|       |//   Analogous to the <ctype.h> functions with similar names, these
   38|       |//   functions take an unsigned char and return a bool, based on whether the
   39|       |//   character matches the condition specified.
   40|       |//
   41|       |//   If the input character has a numerical value greater than 127, these
   42|       |//   functions return `false`.
   43|       |//
   44|       |// `ascii_tolower()`, `ascii_toupper()`
   45|       |//   Analogous to the <ctype.h> functions with similar names, these functions
   46|       |//   take an unsigned char and return a char.
   47|       |//
   48|       |//   If the input character is not an ASCII {lower,upper}-case letter (including
   49|       |//   numerical values greater than 127) then the functions return the same value
   50|       |//   as the input character.
   51|       |
   52|       |#ifndef ABSL_STRINGS_ASCII_H_
   53|       |#define ABSL_STRINGS_ASCII_H_
   54|       |
   55|       |#include <algorithm>
   56|       |#include <string>
   57|       |
   58|       |#include "absl/base/attributes.h"
   59|       |#include "absl/strings/string_view.h"
   60|       |
   61|       |namespace absl {
   62|       |inline namespace lts_2019_08_08 {
   63|       |namespace ascii_internal {
   64|       |
   65|       |// Declaration for an array of bitfields holding character information.
   66|       |extern const unsigned char kPropertyBits[256];
   67|       |
   68|       |// Declaration for the array of characters to upper-case characters.
   69|       |extern const char kToUpper[256];
   70|       |
   71|       |// Declaration for the array of characters to lower-case characters.
   72|       |extern const char kToLower[256];
   73|       |
   74|       |}  // namespace ascii_internal
   75|       |
   76|       |// ascii_isalpha()
   77|       |//
   78|       |// Determines whether the given character is an alphabetic character.
   79|      0|inline bool ascii_isalpha(unsigned char c) {
   80|      0|  return (ascii_internal::kPropertyBits[c] & 0x01) != 0;
   81|      0|}
   82|       |
   83|       |// ascii_isalnum()
   84|       |//
   85|       |// Determines whether the given character is an alphanumeric character.
   86|      0|inline bool ascii_isalnum(unsigned char c) {
   87|      0|  return (ascii_internal::kPropertyBits[c] & 0x04) != 0;
   88|      0|}
   89|       |
   90|       |// ascii_isspace()
   91|       |//
   92|       |// Determines whether the given character is a whitespace character (space,
   93|       |// tab, vertical tab, formfeed, linefeed, or carriage return).
   94|      0|inline bool ascii_isspace(unsigned char c) {
   95|      0|  return (ascii_internal::kPropertyBits[c] & 0x08) != 0;
   96|      0|}
   97|       |
   98|       |// ascii_ispunct()
   99|       |//
  100|       |// Determines whether the given character is a punctuation character.
  101|      0|inline bool ascii_ispunct(unsigned char c) {
  102|      0|  return (ascii_internal::kPropertyBits[c] & 0x10) != 0;
  103|      0|}
  104|       |
  105|       |// ascii_isblank()
  106|       |//
  107|       |// Determines whether the given character is a blank character (tab or space).
  108|      0|inline bool ascii_isblank(unsigned char c) {
  109|      0|  return (ascii_internal::kPropertyBits[c] & 0x20) != 0;
  110|      0|}
  111|       |
  112|       |// ascii_iscntrl()
  113|       |//
  114|       |// Determines whether the given character is a control character.
  115|      0|inline bool ascii_iscntrl(unsigned char c) {
  116|      0|  return (ascii_internal::kPropertyBits[c] & 0x40) != 0;
  117|      0|}
  118|       |
  119|       |// ascii_isxdigit()
  120|       |//
  121|       |// Determines whether the given character can be represented as a hexadecimal
  122|       |// digit character (i.e. {0-9} or {A-F}).
  123|      0|inline bool ascii_isxdigit(unsigned char c) {
  124|      0|  return (ascii_internal::kPropertyBits[c] & 0x80) != 0;
  125|      0|}
  126|       |
  127|       |// ascii_isdigit()
  128|       |//
  129|       |// Determines whether the given character can be represented as a decimal
  130|       |// digit character (i.e. {0-9}).
  131|      0|inline bool ascii_isdigit(unsigned char c) { return c >= '0' && c <= '9'; }
  132|       |
  133|       |// ascii_isprint()
  134|       |//
  135|       |// Determines whether the given character is printable, including whitespace.
  136|      0|inline bool ascii_isprint(unsigned char c) { return c >= 32 && c < 127; }
  137|       |
  138|       |// ascii_isgraph()
  139|       |//
  140|       |// Determines whether the given character has a graphical representation.
  141|      0|inline bool ascii_isgraph(unsigned char c) { return c > 32 && c < 127; }
  142|       |
  143|       |// ascii_isupper()
  144|       |//
  145|       |// Determines whether the given character is uppercase.
  146|      0|inline bool ascii_isupper(unsigned char c) { return c >= 'A' && c <= 'Z'; }
  147|       |
  148|       |// ascii_islower()
  149|       |//
  150|       |// Determines whether the given character is lowercase.
  151|      0|inline bool ascii_islower(unsigned char c) { return c >= 'a' && c <= 'z'; }
  152|       |
  153|       |// ascii_isascii()
  154|       |//
  155|       |// Determines whether the given character is ASCII.
  156|      0|inline bool ascii_isascii(unsigned char c) { return c < 128; }
  157|       |
  158|       |// ascii_tolower()
  159|       |//
  160|       |// Returns an ASCII character, converting to lowercase if uppercase is
  161|       |// passed. Note that character values > 127 are simply returned.
  162|      0|inline char ascii_tolower(unsigned char c) {
  163|      0|  return ascii_internal::kToLower[c];
  164|      0|}
  165|       |
  166|       |// Converts the characters in `s` to lowercase, changing the contents of `s`.
  167|       |void AsciiStrToLower(std::string* s);
  168|       |
  169|       |// Creates a lowercase string from a given absl::string_view.
  170|      0|ABSL_MUST_USE_RESULT inline std::string AsciiStrToLower(absl::string_view s) {
  171|      0|  std::string result(s);
  172|      0|  absl::AsciiStrToLower(&result);
  173|      0|  return result;
  174|      0|}
  175|       |
  176|       |// ascii_toupper()
  177|       |//
  178|       |// Returns the ASCII character, converting to upper-case if lower-case is
  179|       |// passed. Note that characters values > 127 are simply returned.
  180|      0|inline char ascii_toupper(unsigned char c) {
  181|      0|  return ascii_internal::kToUpper[c];
  182|      0|}
  183|       |
  184|       |// Converts the characters in `s` to uppercase, changing the contents of `s`.
  185|       |void AsciiStrToUpper(std::string* s);
  186|       |
  187|       |// Creates an uppercase string from a given absl::string_view.
  188|      0|ABSL_MUST_USE_RESULT inline std::string AsciiStrToUpper(absl::string_view s) {
  189|      0|  std::string result(s);
  190|      0|  absl::AsciiStrToUpper(&result);
  191|      0|  return result;
  192|      0|}
  193|       |
  194|       |// Returns absl::string_view with whitespace stripped from the beginning of the
  195|       |// given string_view.
  196|       |ABSL_MUST_USE_RESULT inline absl::string_view StripLeadingAsciiWhitespace(
  197|      0|    absl::string_view str) {
  198|      0|  auto it = std::find_if_not(str.begin(), str.end(), absl::ascii_isspace);
  199|      0|  return str.substr(it - str.begin());
  200|      0|}
  201|       |
  202|       |// Strips in place whitespace from the beginning of the given string.
  203|      0|inline void StripLeadingAsciiWhitespace(std::string* str) {
  204|      0|  auto it = std::find_if_not(str->begin(), str->end(), absl::ascii_isspace);
  205|      0|  str->erase(str->begin(), it);
  206|      0|}
  207|       |
  208|       |// Returns absl::string_view with whitespace stripped from the end of the given
  209|       |// string_view.
  210|       |ABSL_MUST_USE_RESULT inline absl::string_view StripTrailingAsciiWhitespace(
  211|      0|    absl::string_view str) {
  212|      0|  auto it = std::find_if_not(str.rbegin(), str.rend(), absl::ascii_isspace);
  213|      0|  return str.substr(0, str.rend() - it);
  214|      0|}
  215|       |
  216|       |// Strips in place whitespace from the end of the given string
  217|      0|inline void StripTrailingAsciiWhitespace(std::string* str) {
  218|      0|  auto it = std::find_if_not(str->rbegin(), str->rend(), absl::ascii_isspace);
  219|      0|  str->erase(str->rend() - it);
  220|      0|}
  221|       |
  222|       |// Returns absl::string_view with whitespace stripped from both ends of the
  223|       |// given string_view.
  224|       |ABSL_MUST_USE_RESULT inline absl::string_view StripAsciiWhitespace(
  225|      0|    absl::string_view str) {
  226|      0|  return StripTrailingAsciiWhitespace(StripLeadingAsciiWhitespace(str));
  227|      0|}
  228|       |
  229|       |// Strips in place whitespace from both ends of the given string
  230|      0|inline void StripAsciiWhitespace(std::string* str) {
  231|      0|  StripTrailingAsciiWhitespace(str);
  232|      0|  StripLeadingAsciiWhitespace(str);
  233|      0|}
  234|       |
  235|       |// Removes leading, trailing, and consecutive internal whitespace.
  236|       |void RemoveExtraAsciiWhitespace(std::string*);
  237|       |
  238|       |}  // inline namespace lts_2019_08_08
  239|       |}  // namespace absl
  240|       |
  241|       |#endif  // ABSL_STRINGS_ASCII_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/charconv.cc:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/charconv.h"
   16|       |
   17|       |#include <algorithm>
   18|       |#include <cassert>
   19|       |#include <cmath>
   20|       |#include <cstring>
   21|       |
   22|       |#include "absl/base/casts.h"
   23|       |#include "absl/base/internal/bits.h"
   24|       |#include "absl/numeric/int128.h"
   25|       |#include "absl/strings/internal/charconv_bigint.h"
   26|       |#include "absl/strings/internal/charconv_parse.h"
   27|       |
   28|       |// The macro ABSL_BIT_PACK_FLOATS is defined on x86-64, where IEEE floating
   29|       |// point numbers have the same endianness in memory as a bitfield struct
   30|       |// containing the corresponding parts.
   31|       |//
   32|       |// When set, we replace calls to ldexp() with manual bit packing, which is
   33|       |// faster and is unaffected by floating point environment.
   34|       |#ifdef ABSL_BIT_PACK_FLOATS
   35|       |#error ABSL_BIT_PACK_FLOATS cannot be directly set
   36|       |#elif defined(__x86_64__) || defined(_M_X64)
   37|       |#define ABSL_BIT_PACK_FLOATS 1
   38|       |#endif
   39|       |
   40|       |// A note about subnormals:
   41|       |//
   42|       |// The code below talks about "normals" and "subnormals".  A normal IEEE float
   43|       |// has a fixed-width mantissa and power of two exponent.  For example, a normal
   44|       |// `double` has a 53-bit mantissa.  Because the high bit is always 1, it is not
   45|       |// stored in the representation.  The implicit bit buys an extra bit of
   46|       |// resolution in the datatype.
   47|       |//
   48|       |// The downside of this scheme is that there is a large gap between DBL_MIN and
   49|       |// zero.  (Large, at least, relative to the different between DBL_MIN and the
   50|       |// next representable number).  This gap is softened by the "subnormal" numbers,
   51|       |// which have the same power-of-two exponent as DBL_MIN, but no implicit 53rd
   52|       |// bit.  An all-bits-zero exponent in the encoding represents subnormals.  (Zero
   53|       |// is represented as a subnormal with an all-bits-zero mantissa.)
   54|       |//
   55|       |// The code below, in calculations, represents the mantissa as a uint64_t.  The
   56|       |// end result normally has the 53rd bit set.  It represents subnormals by using
   57|       |// narrower mantissas.
   58|       |
   59|       |namespace absl {
   60|       |inline namespace lts_2019_08_08 {
   61|       |namespace {
   62|       |
   63|       |template <typename FloatType>
   64|       |struct FloatTraits;
   65|       |
   66|       |template <>
   67|       |struct FloatTraits<double> {
   68|       |  // The number of mantissa bits in the given float type.  This includes the
   69|       |  // implied high bit.
   70|       |  static constexpr int kTargetMantissaBits = 53;
   71|       |
   72|       |  // The largest supported IEEE exponent, in our integral mantissa
   73|       |  // representation.
   74|       |  //
   75|       |  // If `m` is the largest possible int kTargetMantissaBits bits wide, then
   76|       |  // m * 2**kMaxExponent is exactly equal to DBL_MAX.
   77|       |  static constexpr int kMaxExponent = 971;
   78|       |
   79|       |  // The smallest supported IEEE normal exponent, in our integral mantissa
   80|       |  // representation.
   81|       |  //
   82|       |  // If `m` is the smallest possible int kTargetMantissaBits bits wide, then
   83|       |  // m * 2**kMinNormalExponent is exactly equal to DBL_MIN.
   84|       |  static constexpr int kMinNormalExponent = -1074;
   85|       |
   86|      0|  static double MakeNan(const char* tagp) {
   87|      0|    // Support nan no matter which namespace it's in.  Some platforms
   88|      0|    // incorrectly don't put it in namespace std.
   89|      0|    using namespace std;  // NOLINT
   90|      0|    return nan(tagp);
   91|      0|  }
   92|       |
   93|       |  // Builds a nonzero floating point number out of the provided parts.
   94|       |  //
   95|       |  // This is intended to do the same operation as ldexp(mantissa, exponent),
   96|       |  // but using purely integer math, to avoid -ffastmath and floating
   97|       |  // point environment issues.  Using type punning is also faster. We fall back
   98|       |  // to ldexp on a per-platform basis for portability.
   99|       |  //
  100|       |  // `exponent` must be between kMinNormalExponent and kMaxExponent.
  101|       |  //
  102|       |  // `mantissa` must either be exactly kTargetMantissaBits wide, in which case
  103|       |  // a normal value is made, or it must be less narrow than that, in which case
  104|       |  // `exponent` must be exactly kMinNormalExponent, and a subnormal value is
  105|       |  // made.
  106|      0|  static double Make(uint64_t mantissa, int exponent, bool sign) {
  107|       |#ifndef ABSL_BIT_PACK_FLOATS
  108|       |    // Support ldexp no matter which namespace it's in.  Some platforms
  109|       |    // incorrectly don't put it in namespace std.
  110|       |    using namespace std;  // NOLINT
  111|       |    return sign ? -ldexp(mantissa, exponent) : ldexp(mantissa, exponent);
  112|       |#else
  113|       |    constexpr uint64_t kMantissaMask =
  114|      0|        (uint64_t(1) << (kTargetMantissaBits - 1)) - 1;
  115|      0|    uint64_t dbl = static_cast<uint64_t>(sign) << 63;
  116|      0|    if (mantissa > kMantissaMask) {
  117|      0|      // Normal value.
  118|      0|      // Adjust by 1023 for the exponent representation bias, and an additional
  119|      0|      // 52 due to the implied decimal point in the IEEE mantissa represenation.
  120|      0|      dbl += uint64_t{exponent + 1023u + kTargetMantissaBits - 1} << 52;
  121|      0|      mantissa &= kMantissaMask;
  122|      0|    } else {
  123|      0|      // subnormal value
  124|      0|      assert(exponent == kMinNormalExponent);
  125|      0|    }
  126|      0|    dbl += mantissa;
  127|      0|    return absl::bit_cast<double>(dbl);
  128|      0|#endif  // ABSL_BIT_PACK_FLOATS
  129|      0|  }
  130|       |};
  131|       |
  132|       |// Specialization of floating point traits for the `float` type.  See the
  133|       |// FloatTraits<double> specialization above for meaning of each of the following
  134|       |// members and methods.
  135|       |template <>
  136|       |struct FloatTraits<float> {
  137|       |  static constexpr int kTargetMantissaBits = 24;
  138|       |  static constexpr int kMaxExponent = 104;
  139|       |  static constexpr int kMinNormalExponent = -149;
  140|      0|  static float MakeNan(const char* tagp) {
  141|      0|    // Support nanf no matter which namespace it's in.  Some platforms
  142|      0|    // incorrectly don't put it in namespace std.
  143|      0|    using namespace std;  // NOLINT
  144|      0|    return nanf(tagp);
  145|      0|  }
  146|      0|  static float Make(uint32_t mantissa, int exponent, bool sign) {
  147|       |#ifndef ABSL_BIT_PACK_FLOATS
  148|       |    // Support ldexpf no matter which namespace it's in.  Some platforms
  149|       |    // incorrectly don't put it in namespace std.
  150|       |    using namespace std;  // NOLINT
  151|       |    return sign ? -ldexpf(mantissa, exponent) : ldexpf(mantissa, exponent);
  152|       |#else
  153|       |    constexpr uint32_t kMantissaMask =
  154|      0|        (uint32_t(1) << (kTargetMantissaBits - 1)) - 1;
  155|      0|    uint32_t flt = static_cast<uint32_t>(sign) << 31;
  156|      0|    if (mantissa > kMantissaMask) {
  157|      0|      // Normal value.
  158|      0|      // Adjust by 127 for the exponent representation bias, and an additional
  159|      0|      // 23 due to the implied decimal point in the IEEE mantissa represenation.
  160|      0|      flt += uint32_t{exponent + 127u + kTargetMantissaBits - 1} << 23;
  161|      0|      mantissa &= kMantissaMask;
  162|      0|    } else {
  163|      0|      // subnormal value
  164|      0|      assert(exponent == kMinNormalExponent);
  165|      0|    }
  166|      0|    flt += mantissa;
  167|      0|    return absl::bit_cast<float>(flt);
  168|      0|#endif  // ABSL_BIT_PACK_FLOATS
  169|      0|  }
  170|       |};
  171|       |
  172|       |// Decimal-to-binary conversions require coercing powers of 10 into a mantissa
  173|       |// and a power of 2.  The two helper functions Power10Mantissa(n) and
  174|       |// Power10Exponent(n) perform this task.  Together, these represent a hand-
  175|       |// rolled floating point value which is equal to or just less than 10**n.
  176|       |//
  177|       |// The return values satisfy two range guarantees:
  178|       |//
  179|       |//   Power10Mantissa(n) * 2**Power10Exponent(n) <= 10**n
  180|       |//     < (Power10Mantissa(n) + 1) * 2**Power10Exponent(n)
  181|       |//
  182|       |//   2**63 <= Power10Mantissa(n) < 2**64.
  183|       |//
  184|       |// Lookups into the power-of-10 table must first check the Power10Overflow() and
  185|       |// Power10Underflow() functions, to avoid out-of-bounds table access.
  186|       |//
  187|       |// Indexes into these tables are biased by -kPower10TableMin, and the table has
  188|       |// values in the range [kPower10TableMin, kPower10TableMax].
  189|       |extern const uint64_t kPower10MantissaTable[];
  190|       |extern const int16_t kPower10ExponentTable[];
  191|       |
  192|       |// The smallest allowed value for use with the Power10Mantissa() and
  193|       |// Power10Exponent() functions below.  (If a smaller exponent is needed in
  194|       |// calculations, the end result is guaranteed to underflow.)
  195|       |constexpr int kPower10TableMin = -342;
  196|       |
  197|       |// The largest allowed value for use with the Power10Mantissa() and
  198|       |// Power10Exponent() functions below.  (If a smaller exponent is needed in
  199|       |// calculations, the end result is guaranteed to overflow.)
  200|       |constexpr int kPower10TableMax = 308;
  201|       |
  202|      0|uint64_t Power10Mantissa(int n) {
  203|      0|  return kPower10MantissaTable[n - kPower10TableMin];
  204|      0|}
  205|       |
  206|      0|int Power10Exponent(int n) {
  207|      0|  return kPower10ExponentTable[n - kPower10TableMin];
  208|      0|}
  209|       |
  210|       |// Returns true if n is large enough that 10**n always results in an IEEE
  211|       |// overflow.
  212|      0|bool Power10Overflow(int n) { return n > kPower10TableMax; }
  213|       |
  214|       |// Returns true if n is small enough that 10**n times a ParsedFloat mantissa
  215|       |// always results in an IEEE underflow.
  216|      0|bool Power10Underflow(int n) { return n < kPower10TableMin; }
  217|       |
  218|       |// Returns true if Power10Mantissa(n) * 2**Power10Exponent(n) is exactly equal
  219|       |// to 10**n numerically.  Put another way, this returns true if there is no
  220|       |// truncation error in Power10Mantissa(n).
  221|      0|bool Power10Exact(int n) { return n >= 0 && n <= 27; }
  222|       |
  223|       |// Sentinel exponent values for representing numbers too large or too close to
  224|       |// zero to represent in a double.
  225|       |constexpr int kOverflow = 99999;
  226|       |constexpr int kUnderflow = -99999;
  227|       |
  228|       |// Struct representing the calculated conversion result of a positive (nonzero)
  229|       |// floating point number.
  230|       |//
  231|       |// The calculated number is mantissa * 2**exponent (mantissa is treated as an
  232|       |// integer.)  `mantissa` is chosen to be the correct width for the IEEE float
  233|       |// representation being calculated.  (`mantissa` will always have the same bit
  234|       |// width for normal values, and narrower bit widths for subnormals.)
  235|       |//
  236|       |// If the result of conversion was an underflow or overflow, exponent is set
  237|       |// to kUnderflow or kOverflow.
  238|       |struct CalculatedFloat {
  239|       |  uint64_t mantissa = 0;
  240|       |  int exponent = 0;
  241|       |};
  242|       |
  243|       |// Returns the bit width of the given uint128.  (Equivalently, returns 128
  244|       |// minus the number of leading zero bits.)
  245|      0|int BitWidth(uint128 value) {
  246|      0|  if (Uint128High64(value) == 0) {
  247|      0|    return 64 - base_internal::CountLeadingZeros64(Uint128Low64(value));
  248|      0|  }
  249|      0|  return 128 - base_internal::CountLeadingZeros64(Uint128High64(value));
  250|      0|}
  251|       |
  252|       |// Calculates how far to the right a mantissa needs to be shifted to create a
  253|       |// properly adjusted mantissa for an IEEE floating point number.
  254|       |//
  255|       |// `mantissa_width` is the bit width of the mantissa to be shifted, and
  256|       |// `binary_exponent` is the exponent of the number before the shift.
  257|       |//
  258|       |// This accounts for subnormal values, and will return a larger-than-normal
  259|       |// shift if binary_exponent would otherwise be too low.
  260|       |template <typename FloatType>
  261|      0|int NormalizedShiftSize(int mantissa_width, int binary_exponent) {
  262|      0|  const int normal_shift =
  263|      0|      mantissa_width - FloatTraits<FloatType>::kTargetMantissaBits;
  264|      0|  const int minimum_shift =
  265|      0|      FloatTraits<FloatType>::kMinNormalExponent - binary_exponent;
  266|      0|  return std::max(normal_shift, minimum_shift);
  267|      0|}
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_119NormalizedShiftSizeIdEEiii
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_119NormalizedShiftSizeIfEEiii
  ------------------
  268|       |
  269|       |// Right shifts a uint128 so that it has the requested bit width.  (The
  270|       |// resulting value will have 128 - bit_width leading zeroes.)  The initial
  271|       |// `value` must be wider than the requested bit width.
  272|       |//
  273|       |// Returns the number of bits shifted.
  274|      0|int TruncateToBitWidth(int bit_width, uint128* value) {
  275|      0|  const int current_bit_width = BitWidth(*value);
  276|      0|  const int shift = current_bit_width - bit_width;
  277|      0|  *value >>= shift;
  278|      0|  return shift;
  279|      0|}
  280|       |
  281|       |// Checks if the given ParsedFloat represents one of the edge cases that are
  282|       |// not dependent on number base: zero, infinity, or NaN.  If so, sets *value
  283|       |// the appropriate double, and returns true.
  284|       |template <typename FloatType>
  285|       |bool HandleEdgeCase(const strings_internal::ParsedFloat& input, bool negative,
  286|      0|                    FloatType* value) {
  287|      0|  if (input.type == strings_internal::FloatType::kNan) {
  288|      0|    // A bug in both clang and gcc would cause the compiler to optimize away the
  289|      0|    // buffer we are building below.  Declaring the buffer volatile avoids the
  290|      0|    // issue, and has no measurable performance impact in microbenchmarks.
  291|      0|    //
  292|      0|    // https://bugs.llvm.org/show_bug.cgi?id=37778
  293|      0|    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86113
  294|      0|    constexpr ptrdiff_t kNanBufferSize = 128;
  295|      0|    volatile char n_char_sequence[kNanBufferSize];
  296|      0|    if (input.subrange_begin == nullptr) {
  297|      0|      n_char_sequence[0] = '\0';
  298|      0|    } else {
  299|      0|      ptrdiff_t nan_size = input.subrange_end - input.subrange_begin;
  300|      0|      nan_size = std::min(nan_size, kNanBufferSize - 1);
  301|      0|      std::copy_n(input.subrange_begin, nan_size, n_char_sequence);
  302|      0|      n_char_sequence[nan_size] = '\0';
  303|      0|    }
  304|      0|    char* nan_argument = const_cast<char*>(n_char_sequence);
  305|      0|    *value = negative ? -FloatTraits<FloatType>::MakeNan(nan_argument)
  306|      0|                      : FloatTraits<FloatType>::MakeNan(nan_argument);
  307|      0|    return true;
  308|      0|  }
  309|      0|  if (input.type == strings_internal::FloatType::kInfinity) {
  310|      0|    *value = negative ? -std::numeric_limits<FloatType>::infinity()
  311|      0|                      : std::numeric_limits<FloatType>::infinity();
  312|      0|    return true;
  313|      0|  }
  314|      0|  if (input.mantissa == 0) {
  315|      0|    *value = negative ? -0.0 : 0.0;
  316|      0|    return true;
  317|      0|  }
  318|      0|  return false;
  319|      0|}
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_114HandleEdgeCaseIdEEbRKNS0_16strings_internal11ParsedFloatEbPT_
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_114HandleEdgeCaseIfEEbRKNS0_16strings_internal11ParsedFloatEbPT_
  ------------------
  320|       |
  321|       |// Given a CalculatedFloat result of a from_chars conversion, generate the
  322|       |// correct output values.
  323|       |//
  324|       |// CalculatedFloat can represent an underflow or overflow, in which case the
  325|       |// error code in *result is set.  Otherwise, the calculated floating point
  326|       |// number is stored in *value.
  327|       |template <typename FloatType>
  328|       |void EncodeResult(const CalculatedFloat& calculated, bool negative,
  329|      0|                  absl::from_chars_result* result, FloatType* value) {
  330|      0|  if (calculated.exponent == kOverflow) {
  331|      0|    result->ec = std::errc::result_out_of_range;
  332|      0|    *value = negative ? -std::numeric_limits<FloatType>::max()
  333|      0|                      : std::numeric_limits<FloatType>::max();
  334|      0|    return;
  335|      0|  } else if (calculated.mantissa == 0 || calculated.exponent == kUnderflow) {
  336|      0|    result->ec = std::errc::result_out_of_range;
  337|      0|    *value = negative ? -0.0 : 0.0;
  338|      0|    return;
  339|      0|  }
  340|      0|  *value = FloatTraits<FloatType>::Make(calculated.mantissa,
  341|      0|                                        calculated.exponent, negative);
  342|      0|}
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_112EncodeResultIdEEvRKNS1_15CalculatedFloatEbPNS0_17from_chars_resultEPT_
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_112EncodeResultIfEEvRKNS1_15CalculatedFloatEbPNS0_17from_chars_resultEPT_
  ------------------
  343|       |
  344|       |// Returns the given uint128 shifted to the right by `shift` bits, and rounds
  345|       |// the remaining bits using round_to_nearest logic.  The value is returned as a
  346|       |// uint64_t, since this is the type used by this library for storing calculated
  347|       |// floating point mantissas.
  348|       |//
  349|       |// It is expected that the width of the input value shifted by `shift` will
  350|       |// be the correct bit-width for the target mantissa, which is strictly narrower
  351|       |// than a uint64_t.
  352|       |//
  353|       |// If `input_exact` is false, then a nonzero error epsilon is assumed.  For
  354|       |// rounding purposes, the true value being rounded is strictly greater than the
  355|       |// input value.  The error may represent a single lost carry bit.
  356|       |//
  357|       |// When input_exact, shifted bits of the form 1000000... represent a tie, which
  358|       |// is broken by rounding to even -- the rounding direction is chosen so the low
  359|       |// bit of the returned value is 0.
  360|       |//
  361|       |// When !input_exact, shifted bits of the form 10000000... represent a value
  362|       |// strictly greater than one half (due to the error epsilon), and so ties are
  363|       |// always broken by rounding up.
  364|       |//
  365|       |// When !input_exact, shifted bits of the form 01111111... are uncertain;
  366|       |// the true value may or may not be greater than 10000000..., due to the
  367|       |// possible lost carry bit.  The correct rounding direction is unknown.  In this
  368|       |// case, the result is rounded down, and `output_exact` is set to false.
  369|       |//
  370|       |// Zero and negative values of `shift` are accepted, in which case the word is
  371|       |// shifted left, as necessary.
  372|       |uint64_t ShiftRightAndRound(uint128 value, int shift, bool input_exact,
  373|      0|                            bool* output_exact) {
  374|      0|  if (shift <= 0) {
  375|      0|    *output_exact = input_exact;
  376|      0|    return static_cast<uint64_t>(value << -shift);
  377|      0|  }
  378|      0|  if (shift >= 128) {
  379|      0|    // Exponent is so small that we are shifting away all significant bits.
  380|      0|    // Answer will not be representable, even as a subnormal, so return a zero
  381|      0|    // mantissa (which represents underflow).
  382|      0|    *output_exact = true;
  383|      0|    return 0;
  384|      0|  }
  385|      0|
  386|      0|  *output_exact = true;
  387|      0|  const uint128 shift_mask = (uint128(1) << shift) - 1;
  388|      0|  const uint128 halfway_point = uint128(1) << (shift - 1);
  389|      0|
  390|      0|  const uint128 shifted_bits = value & shift_mask;
  391|      0|  value >>= shift;
  392|      0|  if (shifted_bits > halfway_point) {
  393|      0|    // Shifted bits greater than 10000... require rounding up.
  394|      0|    return static_cast<uint64_t>(value + 1);
  395|      0|  }
  396|      0|  if (shifted_bits == halfway_point) {
  397|      0|    // In exact mode, shifted bits of 10000... mean we're exactly halfway
  398|      0|    // between two numbers, and we must round to even.  So only round up if
  399|      0|    // the low bit of `value` is set.
  400|      0|    //
  401|      0|    // In inexact mode, the nonzero error means the actual value is greater
  402|      0|    // than the halfway point and we must alway round up.
  403|      0|    if ((value & 1) == 1 || !input_exact) {
  404|      0|      ++value;
  405|      0|    }
  406|      0|    return static_cast<uint64_t>(value);
  407|      0|  }
  408|      0|  if (!input_exact && shifted_bits == halfway_point - 1) {
  409|      0|    // Rounding direction is unclear, due to error.
  410|      0|    *output_exact = false;
  411|      0|  }
  412|      0|  // Otherwise, round down.
  413|      0|  return static_cast<uint64_t>(value);
  414|      0|}
  415|       |
  416|       |// Checks if a floating point guess needs to be rounded up, using high precision
  417|       |// math.
  418|       |//
  419|       |// `guess_mantissa` and `guess_exponent` represent a candidate guess for the
  420|       |// number represented by `parsed_decimal`.
  421|       |//
  422|       |// The exact number represented by `parsed_decimal` must lie between the two
  423|       |// numbers:
  424|       |//   A = `guess_mantissa * 2**guess_exponent`
  425|       |//   B = `(guess_mantissa + 1) * 2**guess_exponent`
  426|       |//
  427|       |// This function returns false if `A` is the better guess, and true if `B` is
  428|       |// the better guess, with rounding ties broken by rounding to even.
  429|       |bool MustRoundUp(uint64_t guess_mantissa, int guess_exponent,
  430|      0|                 const strings_internal::ParsedFloat& parsed_decimal) {
  431|      0|  // 768 is the number of digits needed in the worst case.  We could determine a
  432|      0|  // better limit dynamically based on the value of parsed_decimal.exponent.
  433|      0|  // This would optimize pathological input cases only.  (Sane inputs won't have
  434|      0|  // hundreds of digits of mantissa.)
  435|      0|  absl::strings_internal::BigUnsigned<84> exact_mantissa;
  436|      0|  int exact_exponent = exact_mantissa.ReadFloatMantissa(parsed_decimal, 768);
  437|      0|
  438|      0|  // Adjust the `guess` arguments to be halfway between A and B.
  439|      0|  guess_mantissa = guess_mantissa * 2 + 1;
  440|      0|  guess_exponent -= 1;
  441|      0|
  442|      0|  // In our comparison:
  443|      0|  // lhs = exact = exact_mantissa * 10**exact_exponent
  444|      0|  //             = exact_mantissa * 5**exact_exponent * 2**exact_exponent
  445|      0|  // rhs = guess = guess_mantissa * 2**guess_exponent
  446|      0|  //
  447|      0|  // Because we are doing integer math, we can't directly deal with negative
  448|      0|  // exponents.  We instead move these to the other side of the inequality.
  449|      0|  absl::strings_internal::BigUnsigned<84>& lhs = exact_mantissa;
  450|      0|  int comparison;
  451|      0|  if (exact_exponent >= 0) {
  452|      0|    lhs.MultiplyByFiveToTheNth(exact_exponent);
  453|      0|    absl::strings_internal::BigUnsigned<84> rhs(guess_mantissa);
  454|      0|    // There are powers of 2 on both sides of the inequality; reduce this to
  455|      0|    // a single bit-shift.
  456|      0|    if (exact_exponent > guess_exponent) {
  457|      0|      lhs.ShiftLeft(exact_exponent - guess_exponent);
  458|      0|    } else {
  459|      0|      rhs.ShiftLeft(guess_exponent - exact_exponent);
  460|      0|    }
  461|      0|    comparison = Compare(lhs, rhs);
  462|      0|  } else {
  463|      0|    // Move the power of 5 to the other side of the equation, giving us:
  464|      0|    // lhs = exact_mantissa * 2**exact_exponent
  465|      0|    // rhs = guess_mantissa * 5**(-exact_exponent) * 2**guess_exponent
  466|      0|    absl::strings_internal::BigUnsigned<84> rhs =
  467|      0|        absl::strings_internal::BigUnsigned<84>::FiveToTheNth(-exact_exponent);
  468|      0|    rhs.MultiplyBy(guess_mantissa);
  469|      0|    if (exact_exponent > guess_exponent) {
  470|      0|      lhs.ShiftLeft(exact_exponent - guess_exponent);
  471|      0|    } else {
  472|      0|      rhs.ShiftLeft(guess_exponent - exact_exponent);
  473|      0|    }
  474|      0|    comparison = Compare(lhs, rhs);
  475|      0|  }
  476|      0|  if (comparison < 0) {
  477|      0|    return false;
  478|      0|  } else if (comparison > 0) {
  479|      0|    return true;
  480|      0|  } else {
  481|      0|    // When lhs == rhs, the decimal input is exactly between A and B.
  482|      0|    // Round towards even -- round up only if the low bit of the initial
  483|      0|    // `guess_mantissa` was a 1.  We shifted guess_mantissa left 1 bit at
  484|      0|    // the beginning of this function, so test the 2nd bit here.
  485|      0|    return (guess_mantissa & 2) == 2;
  486|      0|  }
  487|      0|}
  488|       |
  489|       |// Constructs a CalculatedFloat from a given mantissa and exponent, but
  490|       |// with the following normalizations applied:
  491|       |//
  492|       |// If rounding has caused mantissa to increase just past the allowed bit
  493|       |// width, shift and adjust exponent.
  494|       |//
  495|       |// If exponent is too high, sets kOverflow.
  496|       |//
  497|       |// If mantissa is zero (representing a non-zero value not representable, even
  498|       |// as a subnormal), sets kUnderflow.
  499|       |template <typename FloatType>
  500|      0|CalculatedFloat CalculatedFloatFromRawValues(uint64_t mantissa, int exponent) {
  501|      0|  CalculatedFloat result;
  502|      0|  if (mantissa == uint64_t(1) << FloatTraits<FloatType>::kTargetMantissaBits) {
  503|      0|    mantissa >>= 1;
  504|      0|    exponent += 1;
  505|      0|  }
  506|      0|  if (exponent > FloatTraits<FloatType>::kMaxExponent) {
  507|      0|    result.exponent = kOverflow;
  508|      0|  } else if (mantissa == 0) {
  509|      0|    result.exponent = kUnderflow;
  510|      0|  } else {
  511|      0|    result.exponent = exponent;
  512|      0|    result.mantissa = mantissa;
  513|      0|  }
  514|      0|  return result;
  515|      0|}
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_128CalculatedFloatFromRawValuesIdEENS1_15CalculatedFloatEyi
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_128CalculatedFloatFromRawValuesIfEENS1_15CalculatedFloatEyi
  ------------------
  516|       |
  517|       |template <typename FloatType>
  518|       |CalculatedFloat CalculateFromParsedHexadecimal(
  519|      0|    const strings_internal::ParsedFloat& parsed_hex) {
  520|      0|  uint64_t mantissa = parsed_hex.mantissa;
  521|      0|  int exponent = parsed_hex.exponent;
  522|      0|  int mantissa_width = 64 - base_internal::CountLeadingZeros64(mantissa);
  523|      0|  const int shift = NormalizedShiftSize<FloatType>(mantissa_width, exponent);
  524|      0|  bool result_exact;
  525|      0|  exponent += shift;
  526|      0|  mantissa = ShiftRightAndRound(mantissa, shift,
  527|      0|                                /* input exact= */ true, &result_exact);
  528|      0|  // ParseFloat handles rounding in the hexadecimal case, so we don't have to
  529|      0|  // check `result_exact` here.
  530|      0|  return CalculatedFloatFromRawValues<FloatType>(mantissa, exponent);
  531|      0|}
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_130CalculateFromParsedHexadecimalIdEENS1_15CalculatedFloatERKNS0_16strings_internal11ParsedFloatE
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_130CalculateFromParsedHexadecimalIfEENS1_15CalculatedFloatERKNS0_16strings_internal11ParsedFloatE
  ------------------
  532|       |
  533|       |template <typename FloatType>
  534|       |CalculatedFloat CalculateFromParsedDecimal(
  535|      0|    const strings_internal::ParsedFloat& parsed_decimal) {
  536|      0|  CalculatedFloat result;
  537|      0|
  538|      0|  // Large or small enough decimal exponents will always result in overflow
  539|      0|  // or underflow.
  540|      0|  if (Power10Underflow(parsed_decimal.exponent)) {
  541|      0|    result.exponent = kUnderflow;
  542|      0|    return result;
  543|      0|  } else if (Power10Overflow(parsed_decimal.exponent)) {
  544|      0|    result.exponent = kOverflow;
  545|      0|    return result;
  546|      0|  }
  547|      0|
  548|      0|  // Otherwise convert our power of 10 into a power of 2 times an integer
  549|      0|  // mantissa, and multiply this by our parsed decimal mantissa.
  550|      0|  uint128 wide_binary_mantissa = parsed_decimal.mantissa;
  551|      0|  wide_binary_mantissa *= Power10Mantissa(parsed_decimal.exponent);
  552|      0|  int binary_exponent = Power10Exponent(parsed_decimal.exponent);
  553|      0|
  554|      0|  // Discard bits that are inaccurate due to truncation error.  The magic
  555|      0|  // `mantissa_width` constants below are justified in
  556|      0|  // https://abseil.io/about/design/charconv. They represent the number of bits
  557|      0|  // in `wide_binary_mantissa` that are guaranteed to be unaffected by error
  558|      0|  // propagation.
  559|      0|  bool mantissa_exact;
  560|      0|  int mantissa_width;
  561|      0|  if (parsed_decimal.subrange_begin) {
  562|      0|    // Truncated mantissa
  563|      0|    mantissa_width = 58;
  564|      0|    mantissa_exact = false;
  565|      0|    binary_exponent +=
  566|      0|        TruncateToBitWidth(mantissa_width, &wide_binary_mantissa);
  567|      0|  } else if (!Power10Exact(parsed_decimal.exponent)) {
  568|      0|    // Exact mantissa, truncated power of ten
  569|      0|    mantissa_width = 63;
  570|      0|    mantissa_exact = false;
  571|      0|    binary_exponent +=
  572|      0|        TruncateToBitWidth(mantissa_width, &wide_binary_mantissa);
  573|      0|  } else {
  574|      0|    // Product is exact
  575|      0|    mantissa_width = BitWidth(wide_binary_mantissa);
  576|      0|    mantissa_exact = true;
  577|      0|  }
  578|      0|
  579|      0|  // Shift into an FloatType-sized mantissa, and round to nearest.
  580|      0|  const int shift =
  581|      0|      NormalizedShiftSize<FloatType>(mantissa_width, binary_exponent);
  582|      0|  bool result_exact;
  583|      0|  binary_exponent += shift;
  584|      0|  uint64_t binary_mantissa = ShiftRightAndRound(wide_binary_mantissa, shift,
  585|      0|                                                mantissa_exact, &result_exact);
  586|      0|  if (!result_exact) {
  587|      0|    // We could not determine the rounding direction using int128 math.  Use
  588|      0|    // full resolution math instead.
  589|      0|    if (MustRoundUp(binary_mantissa, binary_exponent, parsed_decimal)) {
  590|      0|      binary_mantissa += 1;
  591|      0|    }
  592|      0|  }
  593|      0|
  594|      0|  return CalculatedFloatFromRawValues<FloatType>(binary_mantissa,
  595|      0|                                                 binary_exponent);
  596|      0|}
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_126CalculateFromParsedDecimalIdEENS1_15CalculatedFloatERKNS0_16strings_internal11ParsedFloatE
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_126CalculateFromParsedDecimalIfEENS1_15CalculatedFloatERKNS0_16strings_internal11ParsedFloatE
  ------------------
  597|       |
  598|       |template <typename FloatType>
  599|       |from_chars_result FromCharsImpl(const char* first, const char* last,
  600|      0|                                FloatType& value, chars_format fmt_flags) {
  601|      0|  from_chars_result result;
  602|      0|  result.ptr = first;  // overwritten on successful parse
  603|      0|  result.ec = std::errc();
  604|      0|
  605|      0|  bool negative = false;
  606|      0|  if (first != last && *first == '-') {
  607|      0|    ++first;
  608|      0|    negative = true;
  609|      0|  }
  610|      0|  // If the `hex` flag is *not* set, then we will accept a 0x prefix and try
  611|      0|  // to parse a hexadecimal float.
  612|      0|  if ((fmt_flags & chars_format::hex) == chars_format{} && last - first >= 2 &&
  613|      0|      *first == '0' && (first[1] == 'x' || first[1] == 'X')) {
  614|      0|    const char* hex_first = first + 2;
  615|      0|    strings_internal::ParsedFloat hex_parse =
  616|      0|        strings_internal::ParseFloat<16>(hex_first, last, fmt_flags);
  617|      0|    if (hex_parse.end == nullptr ||
  618|      0|        hex_parse.type != strings_internal::FloatType::kNumber) {
  619|      0|      // Either we failed to parse a hex float after the "0x", or we read
  620|      0|      // "0xinf" or "0xnan" which we don't want to match.
  621|      0|      //
  622|      0|      // However, a std::string that begins with "0x" also begins with "0", which
  623|      0|      // is normally a valid match for the number zero.  So we want these
  624|      0|      // strings to match zero unless fmt_flags is `scientific`.  (This flag
  625|      0|      // means an exponent is required, which the std::string "0" does not have.)
  626|      0|      if (fmt_flags == chars_format::scientific) {
  627|      0|        result.ec = std::errc::invalid_argument;
  628|      0|      } else {
  629|      0|        result.ptr = first + 1;
  630|      0|        value = negative ? -0.0 : 0.0;
  631|      0|      }
  632|      0|      return result;
  633|      0|    }
  634|      0|    // We matched a value.
  635|      0|    result.ptr = hex_parse.end;
  636|      0|    if (HandleEdgeCase(hex_parse, negative, &value)) {
  637|      0|      return result;
  638|      0|    }
  639|      0|    CalculatedFloat calculated =
  640|      0|        CalculateFromParsedHexadecimal<FloatType>(hex_parse);
  641|      0|    EncodeResult(calculated, negative, &result, &value);
  642|      0|    return result;
  643|      0|  }
  644|      0|  // Otherwise, we choose the number base based on the flags.
  645|      0|  if ((fmt_flags & chars_format::hex) == chars_format::hex) {
  646|      0|    strings_internal::ParsedFloat hex_parse =
  647|      0|        strings_internal::ParseFloat<16>(first, last, fmt_flags);
  648|      0|    if (hex_parse.end == nullptr) {
  649|      0|      result.ec = std::errc::invalid_argument;
  650|      0|      return result;
  651|      0|    }
  652|      0|    result.ptr = hex_parse.end;
  653|      0|    if (HandleEdgeCase(hex_parse, negative, &value)) {
  654|      0|      return result;
  655|      0|    }
  656|      0|    CalculatedFloat calculated =
  657|      0|        CalculateFromParsedHexadecimal<FloatType>(hex_parse);
  658|      0|    EncodeResult(calculated, negative, &result, &value);
  659|      0|    return result;
  660|      0|  } else {
  661|      0|    strings_internal::ParsedFloat decimal_parse =
  662|      0|        strings_internal::ParseFloat<10>(first, last, fmt_flags);
  663|      0|    if (decimal_parse.end == nullptr) {
  664|      0|      result.ec = std::errc::invalid_argument;
  665|      0|      return result;
  666|      0|    }
  667|      0|    result.ptr = decimal_parse.end;
  668|      0|    if (HandleEdgeCase(decimal_parse, negative, &value)) {
  669|      0|      return result;
  670|      0|    }
  671|      0|    CalculatedFloat calculated =
  672|      0|        CalculateFromParsedDecimal<FloatType>(decimal_parse);
  673|      0|    EncodeResult(calculated, negative, &result, &value);
  674|      0|    return result;
  675|      0|  }
  676|      0|  return result;
  677|      0|}
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_113FromCharsImplIdEENS0_17from_chars_resultEPKcS5_RT_NS0_12chars_formatE
  ------------------
  | Unexecuted instantiation: charconv.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_113FromCharsImplIfEENS0_17from_chars_resultEPKcS5_RT_NS0_12chars_formatE
  ------------------
  678|       |}  // namespace
  679|       |
  680|       |from_chars_result from_chars(const char* first, const char* last, double& value,
  681|      0|                             chars_format fmt) {
  682|      0|  return FromCharsImpl(first, last, value, fmt);
  683|      0|}
  684|       |
  685|       |from_chars_result from_chars(const char* first, const char* last, float& value,
  686|      0|                             chars_format fmt) {
  687|      0|  return FromCharsImpl(first, last, value, fmt);
  688|      0|}
  689|       |
  690|       |namespace {
  691|       |
  692|       |// Table of powers of 10, from kPower10TableMin to kPower10TableMax.
  693|       |//
  694|       |// kPower10MantissaTable[i - kPower10TableMin] stores the 64-bit mantissa (high
  695|       |// bit always on), and kPower10ExponentTable[i - kPower10TableMin] stores the
  696|       |// power-of-two exponent.  For a given number i, this gives the unique mantissa
  697|       |// and exponent such that mantissa * 2**exponent <= 10**i < (mantissa + 1) *
  698|       |// 2**exponent.
  699|       |
  700|       |const uint64_t kPower10MantissaTable[] = {
  701|       |    0xeef453d6923bd65aU, 0x9558b4661b6565f8U, 0xbaaee17fa23ebf76U,
  702|       |    0xe95a99df8ace6f53U, 0x91d8a02bb6c10594U, 0xb64ec836a47146f9U,
  703|       |    0xe3e27a444d8d98b7U, 0x8e6d8c6ab0787f72U, 0xb208ef855c969f4fU,
  704|       |    0xde8b2b66b3bc4723U, 0x8b16fb203055ac76U, 0xaddcb9e83c6b1793U,
  705|       |    0xd953e8624b85dd78U, 0x87d4713d6f33aa6bU, 0xa9c98d8ccb009506U,
  706|       |    0xd43bf0effdc0ba48U, 0x84a57695fe98746dU, 0xa5ced43b7e3e9188U,
  707|       |    0xcf42894a5dce35eaU, 0x818995ce7aa0e1b2U, 0xa1ebfb4219491a1fU,
  708|       |    0xca66fa129f9b60a6U, 0xfd00b897478238d0U, 0x9e20735e8cb16382U,
  709|       |    0xc5a890362fddbc62U, 0xf712b443bbd52b7bU, 0x9a6bb0aa55653b2dU,
  710|       |    0xc1069cd4eabe89f8U, 0xf148440a256e2c76U, 0x96cd2a865764dbcaU,
  711|       |    0xbc807527ed3e12bcU, 0xeba09271e88d976bU, 0x93445b8731587ea3U,
  712|       |    0xb8157268fdae9e4cU, 0xe61acf033d1a45dfU, 0x8fd0c16206306babU,
  713|       |    0xb3c4f1ba87bc8696U, 0xe0b62e2929aba83cU, 0x8c71dcd9ba0b4925U,
  714|       |    0xaf8e5410288e1b6fU, 0xdb71e91432b1a24aU, 0x892731ac9faf056eU,
  715|       |    0xab70fe17c79ac6caU, 0xd64d3d9db981787dU, 0x85f0468293f0eb4eU,
  716|       |    0xa76c582338ed2621U, 0xd1476e2c07286faaU, 0x82cca4db847945caU,
  717|       |    0xa37fce126597973cU, 0xcc5fc196fefd7d0cU, 0xff77b1fcbebcdc4fU,
  718|       |    0x9faacf3df73609b1U, 0xc795830d75038c1dU, 0xf97ae3d0d2446f25U,
  719|       |    0x9becce62836ac577U, 0xc2e801fb244576d5U, 0xf3a20279ed56d48aU,
  720|       |    0x9845418c345644d6U, 0xbe5691ef416bd60cU, 0xedec366b11c6cb8fU,
  721|       |    0x94b3a202eb1c3f39U, 0xb9e08a83a5e34f07U, 0xe858ad248f5c22c9U,
  722|       |    0x91376c36d99995beU, 0xb58547448ffffb2dU, 0xe2e69915b3fff9f9U,
  723|       |    0x8dd01fad907ffc3bU, 0xb1442798f49ffb4aU, 0xdd95317f31c7fa1dU,
  724|       |    0x8a7d3eef7f1cfc52U, 0xad1c8eab5ee43b66U, 0xd863b256369d4a40U,
  725|       |    0x873e4f75e2224e68U, 0xa90de3535aaae202U, 0xd3515c2831559a83U,
  726|       |    0x8412d9991ed58091U, 0xa5178fff668ae0b6U, 0xce5d73ff402d98e3U,
  727|       |    0x80fa687f881c7f8eU, 0xa139029f6a239f72U, 0xc987434744ac874eU,
  728|       |    0xfbe9141915d7a922U, 0x9d71ac8fada6c9b5U, 0xc4ce17b399107c22U,
  729|       |    0xf6019da07f549b2bU, 0x99c102844f94e0fbU, 0xc0314325637a1939U,
  730|       |    0xf03d93eebc589f88U, 0x96267c7535b763b5U, 0xbbb01b9283253ca2U,
  731|       |    0xea9c227723ee8bcbU, 0x92a1958a7675175fU, 0xb749faed14125d36U,
  732|       |    0xe51c79a85916f484U, 0x8f31cc0937ae58d2U, 0xb2fe3f0b8599ef07U,
  733|       |    0xdfbdcece67006ac9U, 0x8bd6a141006042bdU, 0xaecc49914078536dU,
  734|       |    0xda7f5bf590966848U, 0x888f99797a5e012dU, 0xaab37fd7d8f58178U,
  735|       |    0xd5605fcdcf32e1d6U, 0x855c3be0a17fcd26U, 0xa6b34ad8c9dfc06fU,
  736|       |    0xd0601d8efc57b08bU, 0x823c12795db6ce57U, 0xa2cb1717b52481edU,
  737|       |    0xcb7ddcdda26da268U, 0xfe5d54150b090b02U, 0x9efa548d26e5a6e1U,
  738|       |    0xc6b8e9b0709f109aU, 0xf867241c8cc6d4c0U, 0x9b407691d7fc44f8U,
  739|       |    0xc21094364dfb5636U, 0xf294b943e17a2bc4U, 0x979cf3ca6cec5b5aU,
  740|       |    0xbd8430bd08277231U, 0xece53cec4a314ebdU, 0x940f4613ae5ed136U,
  741|       |    0xb913179899f68584U, 0xe757dd7ec07426e5U, 0x9096ea6f3848984fU,
  742|       |    0xb4bca50b065abe63U, 0xe1ebce4dc7f16dfbU, 0x8d3360f09cf6e4bdU,
  743|       |    0xb080392cc4349decU, 0xdca04777f541c567U, 0x89e42caaf9491b60U,
  744|       |    0xac5d37d5b79b6239U, 0xd77485cb25823ac7U, 0x86a8d39ef77164bcU,
  745|       |    0xa8530886b54dbdebU, 0xd267caa862a12d66U, 0x8380dea93da4bc60U,
  746|       |    0xa46116538d0deb78U, 0xcd795be870516656U, 0x806bd9714632dff6U,
  747|       |    0xa086cfcd97bf97f3U, 0xc8a883c0fdaf7df0U, 0xfad2a4b13d1b5d6cU,
  748|       |    0x9cc3a6eec6311a63U, 0xc3f490aa77bd60fcU, 0xf4f1b4d515acb93bU,
  749|       |    0x991711052d8bf3c5U, 0xbf5cd54678eef0b6U, 0xef340a98172aace4U,
  750|       |    0x9580869f0e7aac0eU, 0xbae0a846d2195712U, 0xe998d258869facd7U,
  751|       |    0x91ff83775423cc06U, 0xb67f6455292cbf08U, 0xe41f3d6a7377eecaU,
  752|       |    0x8e938662882af53eU, 0xb23867fb2a35b28dU, 0xdec681f9f4c31f31U,
  753|       |    0x8b3c113c38f9f37eU, 0xae0b158b4738705eU, 0xd98ddaee19068c76U,
  754|       |    0x87f8a8d4cfa417c9U, 0xa9f6d30a038d1dbcU, 0xd47487cc8470652bU,
  755|       |    0x84c8d4dfd2c63f3bU, 0xa5fb0a17c777cf09U, 0xcf79cc9db955c2ccU,
  756|       |    0x81ac1fe293d599bfU, 0xa21727db38cb002fU, 0xca9cf1d206fdc03bU,
  757|       |    0xfd442e4688bd304aU, 0x9e4a9cec15763e2eU, 0xc5dd44271ad3cdbaU,
  758|       |    0xf7549530e188c128U, 0x9a94dd3e8cf578b9U, 0xc13a148e3032d6e7U,
  759|       |    0xf18899b1bc3f8ca1U, 0x96f5600f15a7b7e5U, 0xbcb2b812db11a5deU,
  760|       |    0xebdf661791d60f56U, 0x936b9fcebb25c995U, 0xb84687c269ef3bfbU,
  761|       |    0xe65829b3046b0afaU, 0x8ff71a0fe2c2e6dcU, 0xb3f4e093db73a093U,
  762|       |    0xe0f218b8d25088b8U, 0x8c974f7383725573U, 0xafbd2350644eeacfU,
  763|       |    0xdbac6c247d62a583U, 0x894bc396ce5da772U, 0xab9eb47c81f5114fU,
  764|       |    0xd686619ba27255a2U, 0x8613fd0145877585U, 0xa798fc4196e952e7U,
  765|       |    0xd17f3b51fca3a7a0U, 0x82ef85133de648c4U, 0xa3ab66580d5fdaf5U,
  766|       |    0xcc963fee10b7d1b3U, 0xffbbcfe994e5c61fU, 0x9fd561f1fd0f9bd3U,
  767|       |    0xc7caba6e7c5382c8U, 0xf9bd690a1b68637bU, 0x9c1661a651213e2dU,
  768|       |    0xc31bfa0fe5698db8U, 0xf3e2f893dec3f126U, 0x986ddb5c6b3a76b7U,
  769|       |    0xbe89523386091465U, 0xee2ba6c0678b597fU, 0x94db483840b717efU,
  770|       |    0xba121a4650e4ddebU, 0xe896a0d7e51e1566U, 0x915e2486ef32cd60U,
  771|       |    0xb5b5ada8aaff80b8U, 0xe3231912d5bf60e6U, 0x8df5efabc5979c8fU,
  772|       |    0xb1736b96b6fd83b3U, 0xddd0467c64bce4a0U, 0x8aa22c0dbef60ee4U,
  773|       |    0xad4ab7112eb3929dU, 0xd89d64d57a607744U, 0x87625f056c7c4a8bU,
  774|       |    0xa93af6c6c79b5d2dU, 0xd389b47879823479U, 0x843610cb4bf160cbU,
  775|       |    0xa54394fe1eedb8feU, 0xce947a3da6a9273eU, 0x811ccc668829b887U,
  776|       |    0xa163ff802a3426a8U, 0xc9bcff6034c13052U, 0xfc2c3f3841f17c67U,
  777|       |    0x9d9ba7832936edc0U, 0xc5029163f384a931U, 0xf64335bcf065d37dU,
  778|       |    0x99ea0196163fa42eU, 0xc06481fb9bcf8d39U, 0xf07da27a82c37088U,
  779|       |    0x964e858c91ba2655U, 0xbbe226efb628afeaU, 0xeadab0aba3b2dbe5U,
  780|       |    0x92c8ae6b464fc96fU, 0xb77ada0617e3bbcbU, 0xe55990879ddcaabdU,
  781|       |    0x8f57fa54c2a9eab6U, 0xb32df8e9f3546564U, 0xdff9772470297ebdU,
  782|       |    0x8bfbea76c619ef36U, 0xaefae51477a06b03U, 0xdab99e59958885c4U,
  783|       |    0x88b402f7fd75539bU, 0xaae103b5fcd2a881U, 0xd59944a37c0752a2U,
  784|       |    0x857fcae62d8493a5U, 0xa6dfbd9fb8e5b88eU, 0xd097ad07a71f26b2U,
  785|       |    0x825ecc24c873782fU, 0xa2f67f2dfa90563bU, 0xcbb41ef979346bcaU,
  786|       |    0xfea126b7d78186bcU, 0x9f24b832e6b0f436U, 0xc6ede63fa05d3143U,
  787|       |    0xf8a95fcf88747d94U, 0x9b69dbe1b548ce7cU, 0xc24452da229b021bU,
  788|       |    0xf2d56790ab41c2a2U, 0x97c560ba6b0919a5U, 0xbdb6b8e905cb600fU,
  789|       |    0xed246723473e3813U, 0x9436c0760c86e30bU, 0xb94470938fa89bceU,
  790|       |    0xe7958cb87392c2c2U, 0x90bd77f3483bb9b9U, 0xb4ecd5f01a4aa828U,
  791|       |    0xe2280b6c20dd5232U, 0x8d590723948a535fU, 0xb0af48ec79ace837U,
  792|       |    0xdcdb1b2798182244U, 0x8a08f0f8bf0f156bU, 0xac8b2d36eed2dac5U,
  793|       |    0xd7adf884aa879177U, 0x86ccbb52ea94baeaU, 0xa87fea27a539e9a5U,
  794|       |    0xd29fe4b18e88640eU, 0x83a3eeeef9153e89U, 0xa48ceaaab75a8e2bU,
  795|       |    0xcdb02555653131b6U, 0x808e17555f3ebf11U, 0xa0b19d2ab70e6ed6U,
  796|       |    0xc8de047564d20a8bU, 0xfb158592be068d2eU, 0x9ced737bb6c4183dU,
  797|       |    0xc428d05aa4751e4cU, 0xf53304714d9265dfU, 0x993fe2c6d07b7fabU,
  798|       |    0xbf8fdb78849a5f96U, 0xef73d256a5c0f77cU, 0x95a8637627989aadU,
  799|       |    0xbb127c53b17ec159U, 0xe9d71b689dde71afU, 0x9226712162ab070dU,
  800|       |    0xb6b00d69bb55c8d1U, 0xe45c10c42a2b3b05U, 0x8eb98a7a9a5b04e3U,
  801|       |    0xb267ed1940f1c61cU, 0xdf01e85f912e37a3U, 0x8b61313bbabce2c6U,
  802|       |    0xae397d8aa96c1b77U, 0xd9c7dced53c72255U, 0x881cea14545c7575U,
  803|       |    0xaa242499697392d2U, 0xd4ad2dbfc3d07787U, 0x84ec3c97da624ab4U,
  804|       |    0xa6274bbdd0fadd61U, 0xcfb11ead453994baU, 0x81ceb32c4b43fcf4U,
  805|       |    0xa2425ff75e14fc31U, 0xcad2f7f5359a3b3eU, 0xfd87b5f28300ca0dU,
  806|       |    0x9e74d1b791e07e48U, 0xc612062576589ddaU, 0xf79687aed3eec551U,
  807|       |    0x9abe14cd44753b52U, 0xc16d9a0095928a27U, 0xf1c90080baf72cb1U,
  808|       |    0x971da05074da7beeU, 0xbce5086492111aeaU, 0xec1e4a7db69561a5U,
  809|       |    0x9392ee8e921d5d07U, 0xb877aa3236a4b449U, 0xe69594bec44de15bU,
  810|       |    0x901d7cf73ab0acd9U, 0xb424dc35095cd80fU, 0xe12e13424bb40e13U,
  811|       |    0x8cbccc096f5088cbU, 0xafebff0bcb24aafeU, 0xdbe6fecebdedd5beU,
  812|       |    0x89705f4136b4a597U, 0xabcc77118461cefcU, 0xd6bf94d5e57a42bcU,
  813|       |    0x8637bd05af6c69b5U, 0xa7c5ac471b478423U, 0xd1b71758e219652bU,
  814|       |    0x83126e978d4fdf3bU, 0xa3d70a3d70a3d70aU, 0xccccccccccccccccU,
  815|       |    0x8000000000000000U, 0xa000000000000000U, 0xc800000000000000U,
  816|       |    0xfa00000000000000U, 0x9c40000000000000U, 0xc350000000000000U,
  817|       |    0xf424000000000000U, 0x9896800000000000U, 0xbebc200000000000U,
  818|       |    0xee6b280000000000U, 0x9502f90000000000U, 0xba43b74000000000U,
  819|       |    0xe8d4a51000000000U, 0x9184e72a00000000U, 0xb5e620f480000000U,
  820|       |    0xe35fa931a0000000U, 0x8e1bc9bf04000000U, 0xb1a2bc2ec5000000U,
  821|       |    0xde0b6b3a76400000U, 0x8ac7230489e80000U, 0xad78ebc5ac620000U,
  822|       |    0xd8d726b7177a8000U, 0x878678326eac9000U, 0xa968163f0a57b400U,
  823|       |    0xd3c21bcecceda100U, 0x84595161401484a0U, 0xa56fa5b99019a5c8U,
  824|       |    0xcecb8f27f4200f3aU, 0x813f3978f8940984U, 0xa18f07d736b90be5U,
  825|       |    0xc9f2c9cd04674edeU, 0xfc6f7c4045812296U, 0x9dc5ada82b70b59dU,
  826|       |    0xc5371912364ce305U, 0xf684df56c3e01bc6U, 0x9a130b963a6c115cU,
  827|       |    0xc097ce7bc90715b3U, 0xf0bdc21abb48db20U, 0x96769950b50d88f4U,
  828|       |    0xbc143fa4e250eb31U, 0xeb194f8e1ae525fdU, 0x92efd1b8d0cf37beU,
  829|       |    0xb7abc627050305adU, 0xe596b7b0c643c719U, 0x8f7e32ce7bea5c6fU,
  830|       |    0xb35dbf821ae4f38bU, 0xe0352f62a19e306eU, 0x8c213d9da502de45U,
  831|       |    0xaf298d050e4395d6U, 0xdaf3f04651d47b4cU, 0x88d8762bf324cd0fU,
  832|       |    0xab0e93b6efee0053U, 0xd5d238a4abe98068U, 0x85a36366eb71f041U,
  833|       |    0xa70c3c40a64e6c51U, 0xd0cf4b50cfe20765U, 0x82818f1281ed449fU,
  834|       |    0xa321f2d7226895c7U, 0xcbea6f8ceb02bb39U, 0xfee50b7025c36a08U,
  835|       |    0x9f4f2726179a2245U, 0xc722f0ef9d80aad6U, 0xf8ebad2b84e0d58bU,
  836|       |    0x9b934c3b330c8577U, 0xc2781f49ffcfa6d5U, 0xf316271c7fc3908aU,
  837|       |    0x97edd871cfda3a56U, 0xbde94e8e43d0c8ecU, 0xed63a231d4c4fb27U,
  838|       |    0x945e455f24fb1cf8U, 0xb975d6b6ee39e436U, 0xe7d34c64a9c85d44U,
  839|       |    0x90e40fbeea1d3a4aU, 0xb51d13aea4a488ddU, 0xe264589a4dcdab14U,
  840|       |    0x8d7eb76070a08aecU, 0xb0de65388cc8ada8U, 0xdd15fe86affad912U,
  841|       |    0x8a2dbf142dfcc7abU, 0xacb92ed9397bf996U, 0xd7e77a8f87daf7fbU,
  842|       |    0x86f0ac99b4e8dafdU, 0xa8acd7c0222311bcU, 0xd2d80db02aabd62bU,
  843|       |    0x83c7088e1aab65dbU, 0xa4b8cab1a1563f52U, 0xcde6fd5e09abcf26U,
  844|       |    0x80b05e5ac60b6178U, 0xa0dc75f1778e39d6U, 0xc913936dd571c84cU,
  845|       |    0xfb5878494ace3a5fU, 0x9d174b2dcec0e47bU, 0xc45d1df942711d9aU,
  846|       |    0xf5746577930d6500U, 0x9968bf6abbe85f20U, 0xbfc2ef456ae276e8U,
  847|       |    0xefb3ab16c59b14a2U, 0x95d04aee3b80ece5U, 0xbb445da9ca61281fU,
  848|       |    0xea1575143cf97226U, 0x924d692ca61be758U, 0xb6e0c377cfa2e12eU,
  849|       |    0xe498f455c38b997aU, 0x8edf98b59a373fecU, 0xb2977ee300c50fe7U,
  850|       |    0xdf3d5e9bc0f653e1U, 0x8b865b215899f46cU, 0xae67f1e9aec07187U,
  851|       |    0xda01ee641a708de9U, 0x884134fe908658b2U, 0xaa51823e34a7eedeU,
  852|       |    0xd4e5e2cdc1d1ea96U, 0x850fadc09923329eU, 0xa6539930bf6bff45U,
  853|       |    0xcfe87f7cef46ff16U, 0x81f14fae158c5f6eU, 0xa26da3999aef7749U,
  854|       |    0xcb090c8001ab551cU, 0xfdcb4fa002162a63U, 0x9e9f11c4014dda7eU,
  855|       |    0xc646d63501a1511dU, 0xf7d88bc24209a565U, 0x9ae757596946075fU,
  856|       |    0xc1a12d2fc3978937U, 0xf209787bb47d6b84U, 0x9745eb4d50ce6332U,
  857|       |    0xbd176620a501fbffU, 0xec5d3fa8ce427affU, 0x93ba47c980e98cdfU,
  858|       |    0xb8a8d9bbe123f017U, 0xe6d3102ad96cec1dU, 0x9043ea1ac7e41392U,
  859|       |    0xb454e4a179dd1877U, 0xe16a1dc9d8545e94U, 0x8ce2529e2734bb1dU,
  860|       |    0xb01ae745b101e9e4U, 0xdc21a1171d42645dU, 0x899504ae72497ebaU,
  861|       |    0xabfa45da0edbde69U, 0xd6f8d7509292d603U, 0x865b86925b9bc5c2U,
  862|       |    0xa7f26836f282b732U, 0xd1ef0244af2364ffU, 0x8335616aed761f1fU,
  863|       |    0xa402b9c5a8d3a6e7U, 0xcd036837130890a1U, 0x802221226be55a64U,
  864|       |    0xa02aa96b06deb0fdU, 0xc83553c5c8965d3dU, 0xfa42a8b73abbf48cU,
  865|       |    0x9c69a97284b578d7U, 0xc38413cf25e2d70dU, 0xf46518c2ef5b8cd1U,
  866|       |    0x98bf2f79d5993802U, 0xbeeefb584aff8603U, 0xeeaaba2e5dbf6784U,
  867|       |    0x952ab45cfa97a0b2U, 0xba756174393d88dfU, 0xe912b9d1478ceb17U,
  868|       |    0x91abb422ccb812eeU, 0xb616a12b7fe617aaU, 0xe39c49765fdf9d94U,
  869|       |    0x8e41ade9fbebc27dU, 0xb1d219647ae6b31cU, 0xde469fbd99a05fe3U,
  870|       |    0x8aec23d680043beeU, 0xada72ccc20054ae9U, 0xd910f7ff28069da4U,
  871|       |    0x87aa9aff79042286U, 0xa99541bf57452b28U, 0xd3fa922f2d1675f2U,
  872|       |    0x847c9b5d7c2e09b7U, 0xa59bc234db398c25U, 0xcf02b2c21207ef2eU,
  873|       |    0x8161afb94b44f57dU, 0xa1ba1ba79e1632dcU, 0xca28a291859bbf93U,
  874|       |    0xfcb2cb35e702af78U, 0x9defbf01b061adabU, 0xc56baec21c7a1916U,
  875|       |    0xf6c69a72a3989f5bU, 0x9a3c2087a63f6399U, 0xc0cb28a98fcf3c7fU,
  876|       |    0xf0fdf2d3f3c30b9fU, 0x969eb7c47859e743U, 0xbc4665b596706114U,
  877|       |    0xeb57ff22fc0c7959U, 0x9316ff75dd87cbd8U, 0xb7dcbf5354e9beceU,
  878|       |    0xe5d3ef282a242e81U, 0x8fa475791a569d10U, 0xb38d92d760ec4455U,
  879|       |    0xe070f78d3927556aU, 0x8c469ab843b89562U, 0xaf58416654a6babbU,
  880|       |    0xdb2e51bfe9d0696aU, 0x88fcf317f22241e2U, 0xab3c2fddeeaad25aU,
  881|       |    0xd60b3bd56a5586f1U, 0x85c7056562757456U, 0xa738c6bebb12d16cU,
  882|       |    0xd106f86e69d785c7U, 0x82a45b450226b39cU, 0xa34d721642b06084U,
  883|       |    0xcc20ce9bd35c78a5U, 0xff290242c83396ceU, 0x9f79a169bd203e41U,
  884|       |    0xc75809c42c684dd1U, 0xf92e0c3537826145U, 0x9bbcc7a142b17ccbU,
  885|       |    0xc2abf989935ddbfeU, 0xf356f7ebf83552feU, 0x98165af37b2153deU,
  886|       |    0xbe1bf1b059e9a8d6U, 0xeda2ee1c7064130cU, 0x9485d4d1c63e8be7U,
  887|       |    0xb9a74a0637ce2ee1U, 0xe8111c87c5c1ba99U, 0x910ab1d4db9914a0U,
  888|       |    0xb54d5e4a127f59c8U, 0xe2a0b5dc971f303aU, 0x8da471a9de737e24U,
  889|       |    0xb10d8e1456105dadU, 0xdd50f1996b947518U, 0x8a5296ffe33cc92fU,
  890|       |    0xace73cbfdc0bfb7bU, 0xd8210befd30efa5aU, 0x8714a775e3e95c78U,
  891|       |    0xa8d9d1535ce3b396U, 0xd31045a8341ca07cU, 0x83ea2b892091e44dU,
  892|       |    0xa4e4b66b68b65d60U, 0xce1de40642e3f4b9U, 0x80d2ae83e9ce78f3U,
  893|       |    0xa1075a24e4421730U, 0xc94930ae1d529cfcU, 0xfb9b7cd9a4a7443cU,
  894|       |    0x9d412e0806e88aa5U, 0xc491798a08a2ad4eU, 0xf5b5d7ec8acb58a2U,
  895|       |    0x9991a6f3d6bf1765U, 0xbff610b0cc6edd3fU, 0xeff394dcff8a948eU,
  896|       |    0x95f83d0a1fb69cd9U, 0xbb764c4ca7a4440fU, 0xea53df5fd18d5513U,
  897|       |    0x92746b9be2f8552cU, 0xb7118682dbb66a77U, 0xe4d5e82392a40515U,
  898|       |    0x8f05b1163ba6832dU, 0xb2c71d5bca9023f8U, 0xdf78e4b2bd342cf6U,
  899|       |    0x8bab8eefb6409c1aU, 0xae9672aba3d0c320U, 0xda3c0f568cc4f3e8U,
  900|       |    0x8865899617fb1871U, 0xaa7eebfb9df9de8dU, 0xd51ea6fa85785631U,
  901|       |    0x8533285c936b35deU, 0xa67ff273b8460356U, 0xd01fef10a657842cU,
  902|       |    0x8213f56a67f6b29bU, 0xa298f2c501f45f42U, 0xcb3f2f7642717713U,
  903|       |    0xfe0efb53d30dd4d7U, 0x9ec95d1463e8a506U, 0xc67bb4597ce2ce48U,
  904|       |    0xf81aa16fdc1b81daU, 0x9b10a4e5e9913128U, 0xc1d4ce1f63f57d72U,
  905|       |    0xf24a01a73cf2dccfU, 0x976e41088617ca01U, 0xbd49d14aa79dbc82U,
  906|       |    0xec9c459d51852ba2U, 0x93e1ab8252f33b45U, 0xb8da1662e7b00a17U,
  907|       |    0xe7109bfba19c0c9dU, 0x906a617d450187e2U, 0xb484f9dc9641e9daU,
  908|       |    0xe1a63853bbd26451U, 0x8d07e33455637eb2U, 0xb049dc016abc5e5fU,
  909|       |    0xdc5c5301c56b75f7U, 0x89b9b3e11b6329baU, 0xac2820d9623bf429U,
  910|       |    0xd732290fbacaf133U, 0x867f59a9d4bed6c0U, 0xa81f301449ee8c70U,
  911|       |    0xd226fc195c6a2f8cU, 0x83585d8fd9c25db7U, 0xa42e74f3d032f525U,
  912|       |    0xcd3a1230c43fb26fU, 0x80444b5e7aa7cf85U, 0xa0555e361951c366U,
  913|       |    0xc86ab5c39fa63440U, 0xfa856334878fc150U, 0x9c935e00d4b9d8d2U,
  914|       |    0xc3b8358109e84f07U, 0xf4a642e14c6262c8U, 0x98e7e9cccfbd7dbdU,
  915|       |    0xbf21e44003acdd2cU, 0xeeea5d5004981478U, 0x95527a5202df0ccbU,
  916|       |    0xbaa718e68396cffdU, 0xe950df20247c83fdU, 0x91d28b7416cdd27eU,
  917|       |    0xb6472e511c81471dU, 0xe3d8f9e563a198e5U, 0x8e679c2f5e44ff8fU,
  918|       |};
  919|       |
  920|       |const int16_t kPower10ExponentTable[] = {
  921|       |    -1200, -1196, -1193, -1190, -1186, -1183, -1180, -1176, -1173, -1170, -1166,
  922|       |    -1163, -1160, -1156, -1153, -1150, -1146, -1143, -1140, -1136, -1133, -1130,
  923|       |    -1127, -1123, -1120, -1117, -1113, -1110, -1107, -1103, -1100, -1097, -1093,
  924|       |    -1090, -1087, -1083, -1080, -1077, -1073, -1070, -1067, -1063, -1060, -1057,
  925|       |    -1053, -1050, -1047, -1043, -1040, -1037, -1034, -1030, -1027, -1024, -1020,
  926|       |    -1017, -1014, -1010, -1007, -1004, -1000, -997,  -994,  -990,  -987,  -984,
  927|       |    -980,  -977,  -974,  -970,  -967,  -964,  -960,  -957,  -954,  -950,  -947,
  928|       |    -944,  -940,  -937,  -934,  -931,  -927,  -924,  -921,  -917,  -914,  -911,
  929|       |    -907,  -904,  -901,  -897,  -894,  -891,  -887,  -884,  -881,  -877,  -874,
  930|       |    -871,  -867,  -864,  -861,  -857,  -854,  -851,  -847,  -844,  -841,  -838,
  931|       |    -834,  -831,  -828,  -824,  -821,  -818,  -814,  -811,  -808,  -804,  -801,
  932|       |    -798,  -794,  -791,  -788,  -784,  -781,  -778,  -774,  -771,  -768,  -764,
  933|       |    -761,  -758,  -754,  -751,  -748,  -744,  -741,  -738,  -735,  -731,  -728,
  934|       |    -725,  -721,  -718,  -715,  -711,  -708,  -705,  -701,  -698,  -695,  -691,
  935|       |    -688,  -685,  -681,  -678,  -675,  -671,  -668,  -665,  -661,  -658,  -655,
  936|       |    -651,  -648,  -645,  -642,  -638,  -635,  -632,  -628,  -625,  -622,  -618,
  937|       |    -615,  -612,  -608,  -605,  -602,  -598,  -595,  -592,  -588,  -585,  -582,
  938|       |    -578,  -575,  -572,  -568,  -565,  -562,  -558,  -555,  -552,  -549,  -545,
  939|       |    -542,  -539,  -535,  -532,  -529,  -525,  -522,  -519,  -515,  -512,  -509,
  940|       |    -505,  -502,  -499,  -495,  -492,  -489,  -485,  -482,  -479,  -475,  -472,
  941|       |    -469,  -465,  -462,  -459,  -455,  -452,  -449,  -446,  -442,  -439,  -436,
  942|       |    -432,  -429,  -426,  -422,  -419,  -416,  -412,  -409,  -406,  -402,  -399,
  943|       |    -396,  -392,  -389,  -386,  -382,  -379,  -376,  -372,  -369,  -366,  -362,
  944|       |    -359,  -356,  -353,  -349,  -346,  -343,  -339,  -336,  -333,  -329,  -326,
  945|       |    -323,  -319,  -316,  -313,  -309,  -306,  -303,  -299,  -296,  -293,  -289,
  946|       |    -286,  -283,  -279,  -276,  -273,  -269,  -266,  -263,  -259,  -256,  -253,
  947|       |    -250,  -246,  -243,  -240,  -236,  -233,  -230,  -226,  -223,  -220,  -216,
  948|       |    -213,  -210,  -206,  -203,  -200,  -196,  -193,  -190,  -186,  -183,  -180,
  949|       |    -176,  -173,  -170,  -166,  -163,  -160,  -157,  -153,  -150,  -147,  -143,
  950|       |    -140,  -137,  -133,  -130,  -127,  -123,  -120,  -117,  -113,  -110,  -107,
  951|       |    -103,  -100,  -97,   -93,   -90,   -87,   -83,   -80,   -77,   -73,   -70,
  952|       |    -67,   -63,   -60,   -57,   -54,   -50,   -47,   -44,   -40,   -37,   -34,
  953|       |    -30,   -27,   -24,   -20,   -17,   -14,   -10,   -7,    -4,    0,     3,
  954|       |    6,     10,    13,    16,    20,    23,    26,    30,    33,    36,    39,
  955|       |    43,    46,    49,    53,    56,    59,    63,    66,    69,    73,    76,
  956|       |    79,    83,    86,    89,    93,    96,    99,    103,   106,   109,   113,
  957|       |    116,   119,   123,   126,   129,   132,   136,   139,   142,   146,   149,
  958|       |    152,   156,   159,   162,   166,   169,   172,   176,   179,   182,   186,
  959|       |    189,   192,   196,   199,   202,   206,   209,   212,   216,   219,   222,
  960|       |    226,   229,   232,   235,   239,   242,   245,   249,   252,   255,   259,
  961|       |    262,   265,   269,   272,   275,   279,   282,   285,   289,   292,   295,
  962|       |    299,   302,   305,   309,   312,   315,   319,   322,   325,   328,   332,
  963|       |    335,   338,   342,   345,   348,   352,   355,   358,   362,   365,   368,
  964|       |    372,   375,   378,   382,   385,   388,   392,   395,   398,   402,   405,
  965|       |    408,   412,   415,   418,   422,   425,   428,   431,   435,   438,   441,
  966|       |    445,   448,   451,   455,   458,   461,   465,   468,   471,   475,   478,
  967|       |    481,   485,   488,   491,   495,   498,   501,   505,   508,   511,   515,
  968|       |    518,   521,   524,   528,   531,   534,   538,   541,   544,   548,   551,
  969|       |    554,   558,   561,   564,   568,   571,   574,   578,   581,   584,   588,
  970|       |    591,   594,   598,   601,   604,   608,   611,   614,   617,   621,   624,
  971|       |    627,   631,   634,   637,   641,   644,   647,   651,   654,   657,   661,
  972|       |    664,   667,   671,   674,   677,   681,   684,   687,   691,   694,   697,
  973|       |    701,   704,   707,   711,   714,   717,   720,   724,   727,   730,   734,
  974|       |    737,   740,   744,   747,   750,   754,   757,   760,   764,   767,   770,
  975|       |    774,   777,   780,   784,   787,   790,   794,   797,   800,   804,   807,
  976|       |    810,   813,   817,   820,   823,   827,   830,   833,   837,   840,   843,
  977|       |    847,   850,   853,   857,   860,   863,   867,   870,   873,   877,   880,
  978|       |    883,   887,   890,   893,   897,   900,   903,   907,   910,   913,   916,
  979|       |    920,   923,   926,   930,   933,   936,   940,   943,   946,   950,   953,
  980|       |    956,   960,
  981|       |};
  982|       |
  983|       |}  // namespace
  984|       |}  // inline namespace lts_2019_08_08
  985|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/charconv.h:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#ifndef ABSL_STRINGS_CHARCONV_H_
   16|       |#define ABSL_STRINGS_CHARCONV_H_
   17|       |
   18|       |#include <system_error>  // NOLINT(build/c++11)
   19|       |
   20|       |namespace absl {
   21|       |inline namespace lts_2019_08_08 {
   22|       |
   23|       |// Workalike compatibilty version of std::chars_format from C++17.
   24|       |//
   25|       |// This is an bitfield enumerator which can be passed to absl::from_chars to
   26|       |// configure the string-to-float conversion.
   27|       |enum class chars_format {
   28|       |  scientific = 1,
   29|       |  fixed = 2,
   30|       |  hex = 4,
   31|       |  general = fixed | scientific,
   32|       |};
   33|       |
   34|       |// The return result of a string-to-number conversion.
   35|       |//
   36|       |// `ec` will be set to `invalid_argument` if a well-formed number was not found
   37|       |// at the start of the input range, `result_out_of_range` if a well-formed
   38|       |// number was found, but it was out of the representable range of the requested
   39|       |// type, or to std::errc() otherwise.
   40|       |//
   41|       |// If a well-formed number was found, `ptr` is set to one past the sequence of
   42|       |// characters that were successfully parsed.  If none was found, `ptr` is set
   43|       |// to the `first` argument to from_chars.
   44|       |struct from_chars_result {
   45|       |  const char* ptr;
   46|       |  std::errc ec;
   47|       |};
   48|       |
   49|       |// Workalike compatibilty version of std::from_chars from C++17.  Currently
   50|       |// this only supports the `double` and `float` types.
   51|       |//
   52|       |// This interface incorporates the proposed resolutions for library issues
   53|       |// DR 3080 and DR 3081.  If these are adopted with different wording,
   54|       |// Abseil's behavior will change to match the standard.  (The behavior most
   55|       |// likely to change is for DR 3081, which says what `value` will be set to in
   56|       |// the case of overflow and underflow.  Code that wants to avoid possible
   57|       |// breaking changes in this area should not depend on `value` when the returned
   58|       |// from_chars_result indicates a range error.)
   59|       |//
   60|       |// Searches the range [first, last) for the longest matching pattern beginning
   61|       |// at `first` that represents a floating point number.  If one is found, store
   62|       |// the result in `value`.
   63|       |//
   64|       |// The matching pattern format is almost the same as that of strtod(), except
   65|       |// that C locale is not respected, and an initial '+' character in the input
   66|       |// range will never be matched.
   67|       |//
   68|       |// If `fmt` is set, it must be one of the enumerator values of the chars_format.
   69|       |// (This is despite the fact that chars_format is a bitmask type.)  If set to
   70|       |// `scientific`, a matching number must contain an exponent.  If set to `fixed`,
   71|       |// then an exponent will never match.  (For example, the string "1e5" will be
   72|       |// parsed as "1".)  If set to `hex`, then a hexadecimal float is parsed in the
   73|       |// format that strtod() accepts, except that a "0x" prefix is NOT matched.
   74|       |// (In particular, in `hex` mode, the input "0xff" results in the largest
   75|       |// matching pattern "0".)
   76|       |absl::from_chars_result from_chars(const char* first, const char* last,
   77|       |                                   double& value,  // NOLINT
   78|       |                                   chars_format fmt = chars_format::general);
   79|       |
   80|       |absl::from_chars_result from_chars(const char* first, const char* last,
   81|       |                                   float& value,  // NOLINT
   82|       |                                   chars_format fmt = chars_format::general);
   83|       |
   84|       |// std::chars_format is specified as a bitmask type, which means the following
   85|       |// operations must be provided:
   86|      0|inline constexpr chars_format operator&(chars_format lhs, chars_format rhs) {
   87|      0|  return static_cast<chars_format>(static_cast<int>(lhs) &
   88|      0|                                   static_cast<int>(rhs));
   89|      0|}
   90|      0|inline constexpr chars_format operator|(chars_format lhs, chars_format rhs) {
   91|      0|  return static_cast<chars_format>(static_cast<int>(lhs) |
   92|      0|                                   static_cast<int>(rhs));
   93|      0|}
   94|      0|inline constexpr chars_format operator^(chars_format lhs, chars_format rhs) {
   95|      0|  return static_cast<chars_format>(static_cast<int>(lhs) ^
   96|      0|                                   static_cast<int>(rhs));
   97|      0|}
   98|      0|inline constexpr chars_format operator~(chars_format arg) {
   99|      0|  return static_cast<chars_format>(~static_cast<int>(arg));
  100|      0|}
  101|      0|inline chars_format& operator&=(chars_format& lhs, chars_format rhs) {
  102|      0|  lhs = lhs & rhs;
  103|      0|  return lhs;
  104|      0|}
  105|      0|inline chars_format& operator|=(chars_format& lhs, chars_format rhs) {
  106|      0|  lhs = lhs | rhs;
  107|      0|  return lhs;
  108|      0|}
  109|      0|inline chars_format& operator^=(chars_format& lhs, chars_format rhs) {
  110|      0|  lhs = lhs ^ rhs;
  111|      0|  return lhs;
  112|      0|}
  113|       |
  114|       |}  // inline namespace lts_2019_08_08
  115|       |}  // namespace absl
  116|       |
  117|       |#endif  // ABSL_STRINGS_CHARCONV_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/escaping.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/escaping.h"
   16|       |
   17|       |#include <algorithm>
   18|       |#include <cassert>
   19|       |#include <cstdint>
   20|       |#include <cstring>
   21|       |#include <iterator>
   22|       |#include <limits>
   23|       |#include <string>
   24|       |
   25|       |#include "absl/base/internal/endian.h"
   26|       |#include "absl/base/internal/raw_logging.h"
   27|       |#include "absl/base/internal/unaligned_access.h"
   28|       |#include "absl/strings/internal/char_map.h"
   29|       |#include "absl/strings/internal/resize_uninitialized.h"
   30|       |#include "absl/strings/internal/utf8.h"
   31|       |#include "absl/strings/str_cat.h"
   32|       |#include "absl/strings/str_join.h"
   33|       |#include "absl/strings/string_view.h"
   34|       |
   35|       |namespace absl {
   36|       |inline namespace lts_2019_08_08 {
   37|       |namespace {
   38|       |
   39|       |// Digit conversion.
   40|       |constexpr char kHexChar[] = "0123456789abcdef";
   41|       |
   42|       |constexpr char kHexTable[513] =
   43|       |    "000102030405060708090a0b0c0d0e0f"
   44|       |    "101112131415161718191a1b1c1d1e1f"
   45|       |    "202122232425262728292a2b2c2d2e2f"
   46|       |    "303132333435363738393a3b3c3d3e3f"
   47|       |    "404142434445464748494a4b4c4d4e4f"
   48|       |    "505152535455565758595a5b5c5d5e5f"
   49|       |    "606162636465666768696a6b6c6d6e6f"
   50|       |    "707172737475767778797a7b7c7d7e7f"
   51|       |    "808182838485868788898a8b8c8d8e8f"
   52|       |    "909192939495969798999a9b9c9d9e9f"
   53|       |    "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
   54|       |    "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
   55|       |    "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
   56|       |    "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
   57|       |    "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
   58|       |    "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
   59|       |
   60|       |// These are used for the leave_nulls_escaped argument to CUnescapeInternal().
   61|       |constexpr bool kUnescapeNulls = false;
   62|       |
   63|      0|inline bool is_octal_digit(char c) { return ('0' <= c) && (c <= '7'); }
   64|       |
   65|      0|inline int hex_digit_to_int(char c) {
   66|      0|  static_assert('0' == 0x30 && 'A' == 0x41 && 'a' == 0x61,
   67|      0|                "Character set must be ASCII.");
   68|      0|  assert(absl::ascii_isxdigit(c));
   69|      0|  int x = static_cast<unsigned char>(c);
   70|      0|  if (x > '9') {
   71|      0|    x += 9;
   72|      0|  }
   73|      0|  return x & 0xf;
   74|      0|}
   75|       |
   76|      0|inline bool IsSurrogate(char32_t c, absl::string_view src, std::string* error) {
   77|      0|  if (c >= 0xD800 && c <= 0xDFFF) {
   78|      0|    if (error) {
   79|      0|      *error = absl::StrCat("invalid surrogate character (0xD800-DFFF): \\",
   80|      0|                            src);
   81|      0|    }
   82|      0|    return true;
   83|      0|  }
   84|      0|  return false;
   85|      0|}
   86|       |
   87|       |// ----------------------------------------------------------------------
   88|       |// CUnescapeInternal()
   89|       |//    Implements both CUnescape() and CUnescapeForNullTerminatedString().
   90|       |//
   91|       |//    Unescapes C escape sequences and is the reverse of CEscape().
   92|       |//
   93|       |//    If 'source' is valid, stores the unescaped string and its size in
   94|       |//    'dest' and 'dest_len' respectively, and returns true. Otherwise
   95|       |//    returns false and optionally stores the error description in
   96|       |//    'error'. Set 'error' to nullptr to disable error reporting.
   97|       |//
   98|       |//    'dest' should point to a buffer that is at least as big as 'source'.
   99|       |//    'source' and 'dest' may be the same.
  100|       |//
  101|       |//     NOTE: any changes to this function must also be reflected in the older
  102|       |//     UnescapeCEscapeSequences().
  103|       |// ----------------------------------------------------------------------
  104|       |bool CUnescapeInternal(absl::string_view source, bool leave_nulls_escaped,
  105|      0|                       char* dest, ptrdiff_t* dest_len, std::string* error) {
  106|      0|  char* d = dest;
  107|      0|  const char* p = source.data();
  108|      0|  const char* end = p + source.size();
  109|      0|  const char* last_byte = end - 1;
  110|      0|
  111|      0|  // Small optimization for case where source = dest and there's no escaping
  112|      0|  while (p == d && p < end && *p != '\\') p++, d++;
  113|      0|
  114|      0|  while (p < end) {
  115|      0|    if (*p != '\\') {
  116|      0|      *d++ = *p++;
  117|      0|    } else {
  118|      0|      if (++p > last_byte) {  // skip past the '\\'
  119|      0|        if (error) *error = "String cannot end with \\";
  120|      0|        return false;
  121|      0|      }
  122|      0|      switch (*p) {
  123|      0|        case 'a':  *d++ = '\a';  break;
  124|      0|        case 'b':  *d++ = '\b';  break;
  125|      0|        case 'f':  *d++ = '\f';  break;
  126|      0|        case 'n':  *d++ = '\n';  break;
  127|      0|        case 'r':  *d++ = '\r';  break;
  128|      0|        case 't':  *d++ = '\t';  break;
  129|      0|        case 'v':  *d++ = '\v';  break;
  130|      0|        case '\\': *d++ = '\\';  break;
  131|      0|        case '?':  *d++ = '\?';  break;    // \?  Who knew?
  132|      0|        case '\'': *d++ = '\'';  break;
  133|      0|        case '"':  *d++ = '\"';  break;
  134|      0|        case '0':
  135|      0|        case '1':
  136|      0|        case '2':
  137|      0|        case '3':
  138|      0|        case '4':
  139|      0|        case '5':
  140|      0|        case '6':
  141|      0|        case '7': {
  142|      0|          // octal digit: 1 to 3 digits
  143|      0|          const char* octal_start = p;
  144|      0|          unsigned int ch = *p - '0';
  145|      0|          if (p < last_byte && is_octal_digit(p[1])) ch = ch * 8 + *++p - '0';
  146|      0|          if (p < last_byte && is_octal_digit(p[1]))
  147|      0|            ch = ch * 8 + *++p - '0';      // now points at last digit
  148|      0|          if (ch > 0xff) {
  149|      0|            if (error) {
  150|      0|              *error = "Value of \\" +
  151|      0|                       std::string(octal_start, p + 1 - octal_start) +
  152|      0|                       " exceeds 0xff";
  153|      0|            }
  154|      0|            return false;
  155|      0|          }
  156|      0|          if ((ch == 0) && leave_nulls_escaped) {
  157|      0|            // Copy the escape sequence for the null character
  158|      0|            const ptrdiff_t octal_size = p + 1 - octal_start;
  159|      0|            *d++ = '\\';
  160|      0|            memcpy(d, octal_start, octal_size);
  161|      0|            d += octal_size;
  162|      0|            break;
  163|      0|          }
  164|      0|          *d++ = ch;
  165|      0|          break;
  166|      0|        }
  167|      0|        case 'x':
  168|      0|        case 'X': {
  169|      0|          if (p >= last_byte) {
  170|      0|            if (error) *error = "String cannot end with \\x";
  171|      0|            return false;
  172|      0|          } else if (!absl::ascii_isxdigit(p[1])) {
  173|      0|            if (error) *error = "\\x cannot be followed by a non-hex digit";
  174|      0|            return false;
  175|      0|          }
  176|      0|          unsigned int ch = 0;
  177|      0|          const char* hex_start = p;
  178|      0|          while (p < last_byte && absl::ascii_isxdigit(p[1]))
  179|      0|            // Arbitrarily many hex digits
  180|      0|            ch = (ch << 4) + hex_digit_to_int(*++p);
  181|      0|          if (ch > 0xFF) {
  182|      0|            if (error) {
  183|      0|              *error = "Value of \\" +
  184|      0|                       std::string(hex_start, p + 1 - hex_start) +
  185|      0|                       " exceeds 0xff";
  186|      0|            }
  187|      0|            return false;
  188|      0|          }
  189|      0|          if ((ch == 0) && leave_nulls_escaped) {
  190|      0|            // Copy the escape sequence for the null character
  191|      0|            const ptrdiff_t hex_size = p + 1 - hex_start;
  192|      0|            *d++ = '\\';
  193|      0|            memcpy(d, hex_start, hex_size);
  194|      0|            d += hex_size;
  195|      0|            break;
  196|      0|          }
  197|      0|          *d++ = ch;
  198|      0|          break;
  199|      0|        }
  200|      0|        case 'u': {
  201|      0|          // \uhhhh => convert 4 hex digits to UTF-8
  202|      0|          char32_t rune = 0;
  203|      0|          const char* hex_start = p;
  204|      0|          if (p + 4 >= end) {
  205|      0|            if (error) {
  206|      0|              *error = "\\u must be followed by 4 hex digits: \\" +
  207|      0|                       std::string(hex_start, p + 1 - hex_start);
  208|      0|            }
  209|      0|            return false;
  210|      0|          }
  211|      0|          for (int i = 0; i < 4; ++i) {
  212|      0|            // Look one char ahead.
  213|      0|            if (absl::ascii_isxdigit(p[1])) {
  214|      0|              rune = (rune << 4) + hex_digit_to_int(*++p);  // Advance p.
  215|      0|            } else {
  216|      0|              if (error) {
  217|      0|                *error = "\\u must be followed by 4 hex digits: \\" +
  218|      0|                         std::string(hex_start, p + 1 - hex_start);
  219|      0|              }
  220|      0|              return false;
  221|      0|            }
  222|      0|          }
  223|      0|          if ((rune == 0) && leave_nulls_escaped) {
  224|      0|            // Copy the escape sequence for the null character
  225|      0|            *d++ = '\\';
  226|      0|            memcpy(d, hex_start, 5);  // u0000
  227|      0|            d += 5;
  228|      0|            break;
  229|      0|          }
  230|      0|          if (IsSurrogate(rune, absl::string_view(hex_start, 5), error)) {
  231|      0|            return false;
  232|      0|          }
  233|      0|          d += strings_internal::EncodeUTF8Char(d, rune);
  234|      0|          break;
  235|      0|        }
  236|      0|        case 'U': {
  237|      0|          // \Uhhhhhhhh => convert 8 hex digits to UTF-8
  238|      0|          char32_t rune = 0;
  239|      0|          const char* hex_start = p;
  240|      0|          if (p + 8 >= end) {
  241|      0|            if (error) {
  242|      0|              *error = "\\U must be followed by 8 hex digits: \\" +
  243|      0|                       std::string(hex_start, p + 1 - hex_start);
  244|      0|            }
  245|      0|            return false;
  246|      0|          }
  247|      0|          for (int i = 0; i < 8; ++i) {
  248|      0|            // Look one char ahead.
  249|      0|            if (absl::ascii_isxdigit(p[1])) {
  250|      0|              // Don't change rune until we're sure this
  251|      0|              // is within the Unicode limit, but do advance p.
  252|      0|              uint32_t newrune = (rune << 4) + hex_digit_to_int(*++p);
  253|      0|              if (newrune > 0x10FFFF) {
  254|      0|                if (error) {
  255|      0|                  *error = "Value of \\" +
  256|      0|                           std::string(hex_start, p + 1 - hex_start) +
  257|      0|                           " exceeds Unicode limit (0x10FFFF)";
  258|      0|                }
  259|      0|                return false;
  260|      0|              } else {
  261|      0|                rune = newrune;
  262|      0|              }
  263|      0|            } else {
  264|      0|              if (error) {
  265|      0|                *error = "\\U must be followed by 8 hex digits: \\" +
  266|      0|                         std::string(hex_start, p + 1 - hex_start);
  267|      0|              }
  268|      0|              return false;
  269|      0|            }
  270|      0|          }
  271|      0|          if ((rune == 0) && leave_nulls_escaped) {
  272|      0|            // Copy the escape sequence for the null character
  273|      0|            *d++ = '\\';
  274|      0|            memcpy(d, hex_start, 9);  // U00000000
  275|      0|            d += 9;
  276|      0|            break;
  277|      0|          }
  278|      0|          if (IsSurrogate(rune, absl::string_view(hex_start, 9), error)) {
  279|      0|            return false;
  280|      0|          }
  281|      0|          d += strings_internal::EncodeUTF8Char(d, rune);
  282|      0|          break;
  283|      0|        }
  284|      0|        default: {
  285|      0|          if (error) *error = std::string("Unknown escape sequence: \\") + *p;
  286|      0|          return false;
  287|      0|        }
  288|      0|      }
  289|      0|      p++;                                 // read past letter we escaped
  290|      0|    }
  291|      0|  }
  292|      0|  *dest_len = d - dest;
  293|      0|  return true;
  294|      0|}
  295|       |
  296|       |// ----------------------------------------------------------------------
  297|       |// CUnescapeInternal()
  298|       |//
  299|       |//    Same as above but uses a std::string for output. 'source' and 'dest'
  300|       |//    may be the same.
  301|       |// ----------------------------------------------------------------------
  302|       |bool CUnescapeInternal(absl::string_view source, bool leave_nulls_escaped,
  303|      0|                       std::string* dest, std::string* error) {
  304|      0|  strings_internal::STLStringResizeUninitialized(dest, source.size());
  305|      0|
  306|      0|  ptrdiff_t dest_size;
  307|      0|  if (!CUnescapeInternal(source,
  308|      0|                         leave_nulls_escaped,
  309|      0|                         &(*dest)[0],
  310|      0|                         &dest_size,
  311|      0|                         error)) {
  312|      0|    return false;
  313|      0|  }
  314|      0|  dest->erase(dest_size);
  315|      0|  return true;
  316|      0|}
  317|       |
  318|       |// ----------------------------------------------------------------------
  319|       |// CEscape()
  320|       |// CHexEscape()
  321|       |// Utf8SafeCEscape()
  322|       |// Utf8SafeCHexEscape()
  323|       |//    Escapes 'src' using C-style escape sequences.  This is useful for
  324|       |//    preparing query flags.  The 'Hex' version uses hexadecimal rather than
  325|       |//    octal sequences.  The 'Utf8Safe' version does not touch UTF-8 bytes.
  326|       |//
  327|       |//    Escaped chars: \n, \r, \t, ", ', \, and !absl::ascii_isprint().
  328|       |// ----------------------------------------------------------------------
  329|       |std::string CEscapeInternal(absl::string_view src, bool use_hex,
  330|      0|                            bool utf8_safe) {
  331|      0|  std::string dest;
  332|      0|  bool last_hex_escape = false;  // true if last output char was \xNN.
  333|      0|
  334|      0|  for (unsigned char c : src) {
  335|      0|    bool is_hex_escape = false;
  336|      0|    switch (c) {
  337|      0|      case '\n': dest.append("\\" "n"); break;
  338|      0|      case '\r': dest.append("\\" "r"); break;
  339|      0|      case '\t': dest.append("\\" "t"); break;
  340|      0|      case '\"': dest.append("\\" "\""); break;
  341|      0|      case '\'': dest.append("\\" "'"); break;
  342|      0|      case '\\': dest.append("\\" "\\"); break;
  343|      0|      default:
  344|      0|        // Note that if we emit \xNN and the src character after that is a hex
  345|      0|        // digit then that digit must be escaped too to prevent it being
  346|      0|        // interpreted as part of the character code by C.
  347|      0|        if ((!utf8_safe || c < 0x80) &&
  348|      0|            (!absl::ascii_isprint(c) ||
  349|      0|             (last_hex_escape && absl::ascii_isxdigit(c)))) {
  350|      0|          if (use_hex) {
  351|      0|            dest.append("\\" "x");
  352|      0|            dest.push_back(kHexChar[c / 16]);
  353|      0|            dest.push_back(kHexChar[c % 16]);
  354|      0|            is_hex_escape = true;
  355|      0|          } else {
  356|      0|            dest.append("\\");
  357|      0|            dest.push_back(kHexChar[c / 64]);
  358|      0|            dest.push_back(kHexChar[(c % 64) / 8]);
  359|      0|            dest.push_back(kHexChar[c % 8]);
  360|      0|          }
  361|      0|        } else {
  362|      0|          dest.push_back(c);
  363|      0|          break;
  364|      0|        }
  365|      0|    }
  366|      0|    last_hex_escape = is_hex_escape;
  367|      0|  }
  368|      0|
  369|      0|  return dest;
  370|      0|}
  371|       |
  372|       |/* clang-format off */
  373|       |constexpr char c_escaped_len[256] = {
  374|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 4, 4, 2, 4, 4,  // \t, \n, \r
  375|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  376|       |    1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1,  // ", '
  377|       |    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // '0'..'9'
  378|       |    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 'A'..'O'
  379|       |    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,  // 'P'..'Z', '\'
  380|       |    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 'a'..'o'
  381|       |    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4,  // 'p'..'z', DEL
  382|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  383|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  384|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  385|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  386|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  387|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  388|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  389|       |    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  390|       |};
  391|       |/* clang-format on */
  392|       |
  393|       |// Calculates the length of the C-style escaped version of 'src'.
  394|       |// Assumes that non-printable characters are escaped using octal sequences, and
  395|       |// that UTF-8 bytes are not handled specially.
  396|      0|inline size_t CEscapedLength(absl::string_view src) {
  397|      0|  size_t escaped_len = 0;
  398|      0|  for (unsigned char c : src) escaped_len += c_escaped_len[c];
  399|      0|  return escaped_len;
  400|      0|}
  401|       |
  402|      0|void CEscapeAndAppendInternal(absl::string_view src, std::string* dest) {
  403|      0|  size_t escaped_len = CEscapedLength(src);
  404|      0|  if (escaped_len == src.size()) {
  405|      0|    dest->append(src.data(), src.size());
  406|      0|    return;
  407|      0|  }
  408|      0|
  409|      0|  size_t cur_dest_len = dest->size();
  410|      0|  strings_internal::STLStringResizeUninitialized(dest,
  411|      0|                                                 cur_dest_len + escaped_len);
  412|      0|  char* append_ptr = &(*dest)[cur_dest_len];
  413|      0|
  414|      0|  for (unsigned char c : src) {
  415|      0|    int char_len = c_escaped_len[c];
  416|      0|    if (char_len == 1) {
  417|      0|      *append_ptr++ = c;
  418|      0|    } else if (char_len == 2) {
  419|      0|      switch (c) {
  420|      0|        case '\n':
  421|      0|          *append_ptr++ = '\\';
  422|      0|          *append_ptr++ = 'n';
  423|      0|          break;
  424|      0|        case '\r':
  425|      0|          *append_ptr++ = '\\';
  426|      0|          *append_ptr++ = 'r';
  427|      0|          break;
  428|      0|        case '\t':
  429|      0|          *append_ptr++ = '\\';
  430|      0|          *append_ptr++ = 't';
  431|      0|          break;
  432|      0|        case '\"':
  433|      0|          *append_ptr++ = '\\';
  434|      0|          *append_ptr++ = '\"';
  435|      0|          break;
  436|      0|        case '\'':
  437|      0|          *append_ptr++ = '\\';
  438|      0|          *append_ptr++ = '\'';
  439|      0|          break;
  440|      0|        case '\\':
  441|      0|          *append_ptr++ = '\\';
  442|      0|          *append_ptr++ = '\\';
  443|      0|          break;
  444|      0|      }
  445|      0|    } else {
  446|      0|      *append_ptr++ = '\\';
  447|      0|      *append_ptr++ = '0' + c / 64;
  448|      0|      *append_ptr++ = '0' + (c % 64) / 8;
  449|      0|      *append_ptr++ = '0' + c % 8;
  450|      0|    }
  451|      0|  }
  452|      0|}
  453|       |
  454|       |bool Base64UnescapeInternal(const char* src_param, size_t szsrc, char* dest,
  455|       |                            size_t szdest, const signed char* unbase64,
  456|      0|                            size_t* len) {
  457|      0|  static const char kPad64Equals = '=';
  458|      0|  static const char kPad64Dot = '.';
  459|      0|
  460|      0|  size_t destidx = 0;
  461|      0|  int decode = 0;
  462|      0|  int state = 0;
  463|      0|  unsigned int ch = 0;
  464|      0|  unsigned int temp = 0;
  465|      0|
  466|      0|  // If "char" is signed by default, using *src as an array index results in
  467|      0|  // accessing negative array elements. Treat the input as a pointer to
  468|      0|  // unsigned char to avoid this.
  469|      0|  const unsigned char* src = reinterpret_cast<const unsigned char*>(src_param);
  470|      0|
  471|      0|  // The GET_INPUT macro gets the next input character, skipping
  472|      0|  // over any whitespace, and stopping when we reach the end of the
  473|      0|  // std::string or when we read any non-data character.  The arguments are
  474|      0|  // an arbitrary identifier (used as a label for goto) and the number
  475|      0|  // of data bytes that must remain in the input to avoid aborting the
  476|      0|  // loop.
  477|      0|#define GET_INPUT(label, remain)                                \
  478|      0|  label:                                                        \
  479|      0|  --szsrc;                                                      \
  480|      0|  ch = *src++;                                                  \
  481|      0|  decode = unbase64[ch];                                        \
  482|      0|  if (decode < 0) {                                             \
  483|      0|    if (absl::ascii_isspace(ch) && szsrc >= remain) goto label; \
  484|      0|    state = 4 - remain;                                         \
  485|      0|    break;                                                      \
  486|      0|  }
  487|      0|
  488|      0|  // if dest is null, we're just checking to see if it's legal input
  489|      0|  // rather than producing output.  (I suspect this could just be done
  490|      0|  // with a regexp...).  We duplicate the loop so this test can be
  491|      0|  // outside it instead of in every iteration.
  492|      0|
  493|      0|  if (dest) {
  494|      0|    // This loop consumes 4 input bytes and produces 3 output bytes
  495|      0|    // per iteration.  We can't know at the start that there is enough
  496|      0|    // data left in the std::string for a full iteration, so the loop may
  497|      0|    // break out in the middle; if so 'state' will be set to the
  498|      0|    // number of input bytes read.
  499|      0|
  500|      0|    while (szsrc >= 4) {
  501|      0|      // We'll start by optimistically assuming that the next four
  502|      0|      // bytes of the std::string (src[0..3]) are four good data bytes
  503|      0|      // (that is, no nulls, whitespace, padding chars, or illegal
  504|      0|      // chars).  We need to test src[0..2] for nulls individually
  505|      0|      // before constructing temp to preserve the property that we
  506|      0|      // never read past a null in the std::string (no matter how long
  507|      0|      // szsrc claims the std::string is).
  508|      0|
  509|      0|      if (!src[0] || !src[1] || !src[2] ||
  510|      0|          ((temp = ((unsigned(unbase64[src[0]]) << 18) |
  511|      0|                    (unsigned(unbase64[src[1]]) << 12) |
  512|      0|                    (unsigned(unbase64[src[2]]) << 6) |
  513|      0|                    (unsigned(unbase64[src[3]])))) &
  514|      0|           0x80000000)) {
  515|      0|        // Iff any of those four characters was bad (null, illegal,
  516|      0|        // whitespace, padding), then temp's high bit will be set
  517|      0|        // (because unbase64[] is -1 for all bad characters).
  518|      0|        //
  519|      0|        // We'll back up and resort to the slower decoder, which knows
  520|      0|        // how to handle those cases.
  521|      0|
  522|      0|        GET_INPUT(first, 4);
  523|      0|        temp = decode;
  524|      0|        GET_INPUT(second, 3);
  525|      0|        temp = (temp << 6) | decode;
  526|      0|        GET_INPUT(third, 2);
  527|      0|        temp = (temp << 6) | decode;
  528|      0|        GET_INPUT(fourth, 1);
  529|      0|        temp = (temp << 6) | decode;
  530|      0|      } else {
  531|      0|        // We really did have four good data bytes, so advance four
  532|      0|        // characters in the std::string.
  533|      0|
  534|      0|        szsrc -= 4;
  535|      0|        src += 4;
  536|      0|      }
  537|      0|
  538|      0|      // temp has 24 bits of input, so write that out as three bytes.
  539|      0|
  540|      0|      if (destidx + 3 > szdest) return false;
  541|      0|      dest[destidx + 2] = temp;
  542|      0|      temp >>= 8;
  543|      0|      dest[destidx + 1] = temp;
  544|      0|      temp >>= 8;
  545|      0|      dest[destidx] = temp;
  546|      0|      destidx += 3;
  547|      0|    }
  548|      0|  } else {
  549|      0|    while (szsrc >= 4) {
  550|      0|      if (!src[0] || !src[1] || !src[2] ||
  551|      0|          ((temp = ((unsigned(unbase64[src[0]]) << 18) |
  552|      0|                    (unsigned(unbase64[src[1]]) << 12) |
  553|      0|                    (unsigned(unbase64[src[2]]) << 6) |
  554|      0|                    (unsigned(unbase64[src[3]])))) &
  555|      0|           0x80000000)) {
  556|      0|        GET_INPUT(first_no_dest, 4);
  557|      0|        GET_INPUT(second_no_dest, 3);
  558|      0|        GET_INPUT(third_no_dest, 2);
  559|      0|        GET_INPUT(fourth_no_dest, 1);
  560|      0|      } else {
  561|      0|        szsrc -= 4;
  562|      0|        src += 4;
  563|      0|      }
  564|      0|      destidx += 3;
  565|      0|    }
  566|      0|  }
  567|      0|
  568|      0|#undef GET_INPUT
  569|      0|
  570|      0|  // if the loop terminated because we read a bad character, return
  571|      0|  // now.
  572|      0|  if (decode < 0 && ch != kPad64Equals && ch != kPad64Dot &&
  573|      0|      !absl::ascii_isspace(ch))
  574|      0|    return false;
  575|      0|
  576|      0|  if (ch == kPad64Equals || ch == kPad64Dot) {
  577|      0|    // if we stopped by hitting an '=' or '.', un-read that character -- we'll
  578|      0|    // look at it again when we count to check for the proper number of
  579|      0|    // equals signs at the end.
  580|      0|    ++szsrc;
  581|      0|    --src;
  582|      0|  } else {
  583|      0|    // This loop consumes 1 input byte per iteration.  It's used to
  584|      0|    // clean up the 0-3 input bytes remaining when the first, faster
  585|      0|    // loop finishes.  'temp' contains the data from 'state' input
  586|      0|    // characters read by the first loop.
  587|      0|    while (szsrc > 0) {
  588|      0|      --szsrc;
  589|      0|      ch = *src++;
  590|      0|      decode = unbase64[ch];
  591|      0|      if (decode < 0) {
  592|      0|        if (absl::ascii_isspace(ch)) {
  593|      0|          continue;
  594|      0|        } else if (ch == kPad64Equals || ch == kPad64Dot) {
  595|      0|          // back up one character; we'll read it again when we check
  596|      0|          // for the correct number of pad characters at the end.
  597|      0|          ++szsrc;
  598|      0|          --src;
  599|      0|          break;
  600|      0|        } else {
  601|      0|          return false;
  602|      0|        }
  603|      0|      }
  604|      0|
  605|      0|      // Each input character gives us six bits of output.
  606|      0|      temp = (temp << 6) | decode;
  607|      0|      ++state;
  608|      0|      if (state == 4) {
  609|      0|        // If we've accumulated 24 bits of output, write that out as
  610|      0|        // three bytes.
  611|      0|        if (dest) {
  612|      0|          if (destidx + 3 > szdest) return false;
  613|      0|          dest[destidx + 2] = temp;
  614|      0|          temp >>= 8;
  615|      0|          dest[destidx + 1] = temp;
  616|      0|          temp >>= 8;
  617|      0|          dest[destidx] = temp;
  618|      0|        }
  619|      0|        destidx += 3;
  620|      0|        state = 0;
  621|      0|        temp = 0;
  622|      0|      }
  623|      0|    }
  624|      0|  }
  625|      0|
  626|      0|  // Process the leftover data contained in 'temp' at the end of the input.
  627|      0|  int expected_equals = 0;
  628|      0|  switch (state) {
  629|      0|    case 0:
  630|      0|      // Nothing left over; output is a multiple of 3 bytes.
  631|      0|      break;
  632|      0|
  633|      0|    case 1:
  634|      0|      // Bad input; we have 6 bits left over.
  635|      0|      return false;
  636|      0|
  637|      0|    case 2:
  638|      0|      // Produce one more output byte from the 12 input bits we have left.
  639|      0|      if (dest) {
  640|      0|        if (destidx + 1 > szdest) return false;
  641|      0|        temp >>= 4;
  642|      0|        dest[destidx] = temp;
  643|      0|      }
  644|      0|      ++destidx;
  645|      0|      expected_equals = 2;
  646|      0|      break;
  647|      0|
  648|      0|    case 3:
  649|      0|      // Produce two more output bytes from the 18 input bits we have left.
  650|      0|      if (dest) {
  651|      0|        if (destidx + 2 > szdest) return false;
  652|      0|        temp >>= 2;
  653|      0|        dest[destidx + 1] = temp;
  654|      0|        temp >>= 8;
  655|      0|        dest[destidx] = temp;
  656|      0|      }
  657|      0|      destidx += 2;
  658|      0|      expected_equals = 1;
  659|      0|      break;
  660|      0|
  661|      0|    default:
  662|      0|      // state should have no other values at this point.
  663|      0|      ABSL_RAW_LOG(FATAL, "This can't happen; base64 decoder state = %d",
  664|      0|                   state);
  665|      0|  }
  666|      0|
  667|      0|  // The remainder of the std::string should be all whitespace, mixed with
  668|      0|  // exactly 0 equals signs, or exactly 'expected_equals' equals
  669|      0|  // signs.  (Always accepting 0 equals signs is an Abseil extension
  670|      0|  // not covered in the RFC, as is accepting dot as the pad character.)
  671|      0|
  672|      0|  int equals = 0;
  673|      0|  while (szsrc > 0) {
  674|      0|    if (*src == kPad64Equals || *src == kPad64Dot)
  675|      0|      ++equals;
  676|      0|    else if (!absl::ascii_isspace(*src))
  677|      0|      return false;
  678|      0|    --szsrc;
  679|      0|    ++src;
  680|      0|  }
  681|      0|
  682|      0|  const bool ok = (equals == 0 || equals == expected_equals);
  683|      0|  if (ok) *len = destidx;
  684|      0|  return ok;
  685|      0|}
  686|       |
  687|       |// The arrays below were generated by the following code
  688|       |// #include <sys/time.h>
  689|       |// #include <stdlib.h>
  690|       |// #include <string.h>
  691|       |// main()
  692|       |// {
  693|       |//   static const char Base64[] =
  694|       |//     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  695|       |//   char* pos;
  696|       |//   int idx, i, j;
  697|       |//   printf("    ");
  698|       |//   for (i = 0; i < 255; i += 8) {
  699|       |//     for (j = i; j < i + 8; j++) {
  700|       |//       pos = strchr(Base64, j);
  701|       |//       if ((pos == nullptr) || (j == 0))
  702|       |//         idx = -1;
  703|       |//       else
  704|       |//         idx = pos - Base64;
  705|       |//       if (idx == -1)
  706|       |//         printf(" %2d,     ", idx);
  707|       |//       else
  708|       |//         printf(" %2d/*%c*/,", idx, j);
  709|       |//     }
  710|       |//     printf("\n    ");
  711|       |//   }
  712|       |// }
  713|       |//
  714|       |// where the value of "Base64[]" was replaced by one of the base-64 conversion
  715|       |// tables from the functions below.
  716|       |/* clang-format off */
  717|       |constexpr signed char kUnBase64[] = {
  718|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  719|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  720|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  721|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  722|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  723|       |    -1,      -1,      -1,      62/*+*/, -1,      -1,      -1,      63/*/ */,
  724|       |    52/*0*/, 53/*1*/, 54/*2*/, 55/*3*/, 56/*4*/, 57/*5*/, 58/*6*/, 59/*7*/,
  725|       |    60/*8*/, 61/*9*/, -1,      -1,      -1,      -1,      -1,      -1,
  726|       |    -1,       0/*A*/,  1/*B*/,  2/*C*/,  3/*D*/,  4/*E*/,  5/*F*/,  6/*G*/,
  727|       |    07/*H*/,  8/*I*/,  9/*J*/, 10/*K*/, 11/*L*/, 12/*M*/, 13/*N*/, 14/*O*/,
  728|       |    15/*P*/, 16/*Q*/, 17/*R*/, 18/*S*/, 19/*T*/, 20/*U*/, 21/*V*/, 22/*W*/,
  729|       |    23/*X*/, 24/*Y*/, 25/*Z*/, -1,      -1,      -1,      -1,      -1,
  730|       |    -1,      26/*a*/, 27/*b*/, 28/*c*/, 29/*d*/, 30/*e*/, 31/*f*/, 32/*g*/,
  731|       |    33/*h*/, 34/*i*/, 35/*j*/, 36/*k*/, 37/*l*/, 38/*m*/, 39/*n*/, 40/*o*/,
  732|       |    41/*p*/, 42/*q*/, 43/*r*/, 44/*s*/, 45/*t*/, 46/*u*/, 47/*v*/, 48/*w*/,
  733|       |    49/*x*/, 50/*y*/, 51/*z*/, -1,      -1,      -1,      -1,      -1,
  734|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  735|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  736|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  737|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  738|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  739|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  740|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  741|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  742|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  743|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  744|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  745|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  746|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  747|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  748|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  749|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1
  750|       |};
  751|       |
  752|       |constexpr signed char kUnWebSafeBase64[] = {
  753|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  754|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  755|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  756|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  757|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  758|       |    -1,      -1,      -1,      -1,      -1,      62/*-*/, -1,      -1,
  759|       |    52/*0*/, 53/*1*/, 54/*2*/, 55/*3*/, 56/*4*/, 57/*5*/, 58/*6*/, 59/*7*/,
  760|       |    60/*8*/, 61/*9*/, -1,      -1,      -1,      -1,      -1,      -1,
  761|       |    -1,       0/*A*/,  1/*B*/,  2/*C*/,  3/*D*/,  4/*E*/,  5/*F*/,  6/*G*/,
  762|       |    07/*H*/,  8/*I*/,  9/*J*/, 10/*K*/, 11/*L*/, 12/*M*/, 13/*N*/, 14/*O*/,
  763|       |    15/*P*/, 16/*Q*/, 17/*R*/, 18/*S*/, 19/*T*/, 20/*U*/, 21/*V*/, 22/*W*/,
  764|       |    23/*X*/, 24/*Y*/, 25/*Z*/, -1,      -1,      -1,      -1,      63/*_*/,
  765|       |    -1,      26/*a*/, 27/*b*/, 28/*c*/, 29/*d*/, 30/*e*/, 31/*f*/, 32/*g*/,
  766|       |    33/*h*/, 34/*i*/, 35/*j*/, 36/*k*/, 37/*l*/, 38/*m*/, 39/*n*/, 40/*o*/,
  767|       |    41/*p*/, 42/*q*/, 43/*r*/, 44/*s*/, 45/*t*/, 46/*u*/, 47/*v*/, 48/*w*/,
  768|       |    49/*x*/, 50/*y*/, 51/*z*/, -1,      -1,      -1,      -1,      -1,
  769|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  770|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  771|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  772|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  773|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  774|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  775|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  776|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  777|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  778|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  779|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  780|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  781|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  782|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  783|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1,
  784|       |    -1,      -1,      -1,      -1,      -1,      -1,      -1,      -1
  785|       |};
  786|       |/* clang-format on */
  787|       |
  788|      0|size_t CalculateBase64EscapedLenInternal(size_t input_len, bool do_padding) {
  789|      0|  // Base64 encodes three bytes of input at a time. If the input is not
  790|      0|  // divisible by three, we pad as appropriate.
  791|      0|  //
  792|      0|  // (from https://tools.ietf.org/html/rfc3548)
  793|      0|  // Special processing is performed if fewer than 24 bits are available
  794|      0|  // at the end of the data being encoded.  A full encoding quantum is
  795|      0|  // always completed at the end of a quantity.  When fewer than 24 input
  796|      0|  // bits are available in an input group, zero bits are added (on the
  797|      0|  // right) to form an integral number of 6-bit groups.  Padding at the
  798|      0|  // end of the data is performed using the '=' character.  Since all base
  799|      0|  // 64 input is an integral number of octets, only the following cases
  800|      0|  // can arise:
  801|      0|
  802|      0|  // Base64 encodes each three bytes of input into four bytes of output.
  803|      0|  size_t len = (input_len / 3) * 4;
  804|      0|
  805|      0|  if (input_len % 3 == 0) {
  806|      0|    // (from https://tools.ietf.org/html/rfc3548)
  807|      0|    // (1) the final quantum of encoding input is an integral multiple of 24
  808|      0|    // bits; here, the final unit of encoded output will be an integral
  809|      0|    // multiple of 4 characters with no "=" padding,
  810|      0|  } else if (input_len % 3 == 1) {
  811|      0|    // (from https://tools.ietf.org/html/rfc3548)
  812|      0|    // (2) the final quantum of encoding input is exactly 8 bits; here, the
  813|      0|    // final unit of encoded output will be two characters followed by two
  814|      0|    // "=" padding characters, or
  815|      0|    len += 2;
  816|      0|    if (do_padding) {
  817|      0|      len += 2;
  818|      0|    }
  819|      0|  } else {  // (input_len % 3 == 2)
  820|      0|    // (from https://tools.ietf.org/html/rfc3548)
  821|      0|    // (3) the final quantum of encoding input is exactly 16 bits; here, the
  822|      0|    // final unit of encoded output will be three characters followed by one
  823|      0|    // "=" padding character.
  824|      0|    len += 3;
  825|      0|    if (do_padding) {
  826|      0|      len += 1;
  827|      0|    }
  828|      0|  }
  829|      0|
  830|      0|  assert(len >= input_len);  // make sure we didn't overflow
  831|      0|  return len;
  832|      0|}
  833|       |
  834|       |size_t Base64EscapeInternal(const unsigned char* src, size_t szsrc, char* dest,
  835|       |                            size_t szdest, const char* base64,
  836|      0|                            bool do_padding) {
  837|      0|  static const char kPad64 = '=';
  838|      0|
  839|      0|  if (szsrc * 4 > szdest * 3) return 0;
  840|      0|
  841|      0|  char* cur_dest = dest;
  842|      0|  const unsigned char* cur_src = src;
  843|      0|
  844|      0|  char* const limit_dest = dest + szdest;
  845|      0|  const unsigned char* const limit_src = src + szsrc;
  846|      0|
  847|      0|  // Three bytes of data encodes to four characters of cyphertext.
  848|      0|  // So we can pump through three-byte chunks atomically.
  849|      0|  if (szsrc >= 3) {  // "limit_src - 3" is UB if szsrc < 3.
  850|      0|    while (cur_src < limit_src - 3) {  // While we have >= 32 bits.
  851|      0|      uint32_t in = absl::big_endian::Load32(cur_src) >> 8;
  852|      0|
  853|      0|      cur_dest[0] = base64[in >> 18];
  854|      0|      in &= 0x3FFFF;
  855|      0|      cur_dest[1] = base64[in >> 12];
  856|      0|      in &= 0xFFF;
  857|      0|      cur_dest[2] = base64[in >> 6];
  858|      0|      in &= 0x3F;
  859|      0|      cur_dest[3] = base64[in];
  860|      0|
  861|      0|      cur_dest += 4;
  862|      0|      cur_src += 3;
  863|      0|    }
  864|      0|  }
  865|      0|  // To save time, we didn't update szdest or szsrc in the loop.  So do it now.
  866|      0|  szdest = limit_dest - cur_dest;
  867|      0|  szsrc = limit_src - cur_src;
  868|      0|
  869|      0|  /* now deal with the tail (<=3 bytes) */
  870|      0|  switch (szsrc) {
  871|      0|    case 0:
  872|      0|      // Nothing left; nothing more to do.
  873|      0|      break;
  874|      0|    case 1: {
  875|      0|      // One byte left: this encodes to two characters, and (optionally)
  876|      0|      // two pad characters to round out the four-character cypherblock.
  877|      0|      if (szdest < 2) return 0;
  878|      0|      uint32_t in = cur_src[0];
  879|      0|      cur_dest[0] = base64[in >> 2];
  880|      0|      in &= 0x3;
  881|      0|      cur_dest[1] = base64[in << 4];
  882|      0|      cur_dest += 2;
  883|      0|      szdest -= 2;
  884|      0|      if (do_padding) {
  885|      0|        if (szdest < 2) return 0;
  886|      0|        cur_dest[0] = kPad64;
  887|      0|        cur_dest[1] = kPad64;
  888|      0|        cur_dest += 2;
  889|      0|        szdest -= 2;
  890|      0|      }
  891|      0|      break;
  892|      0|    }
  893|      0|    case 2: {
  894|      0|      // Two bytes left: this encodes to three characters, and (optionally)
  895|      0|      // one pad character to round out the four-character cypherblock.
  896|      0|      if (szdest < 3) return 0;
  897|      0|      uint32_t in = absl::big_endian::Load16(cur_src);
  898|      0|      cur_dest[0] = base64[in >> 10];
  899|      0|      in &= 0x3FF;
  900|      0|      cur_dest[1] = base64[in >> 4];
  901|      0|      in &= 0x00F;
  902|      0|      cur_dest[2] = base64[in << 2];
  903|      0|      cur_dest += 3;
  904|      0|      szdest -= 3;
  905|      0|      if (do_padding) {
  906|      0|        if (szdest < 1) return 0;
  907|      0|        cur_dest[0] = kPad64;
  908|      0|        cur_dest += 1;
  909|      0|        szdest -= 1;
  910|      0|      }
  911|      0|      break;
  912|      0|    }
  913|      0|    case 3: {
  914|      0|      // Three bytes left: same as in the big loop above.  We can't do this in
  915|      0|      // the loop because the loop above always reads 4 bytes, and the fourth
  916|      0|      // byte is past the end of the input.
  917|      0|      if (szdest < 4) return 0;
  918|      0|      uint32_t in = (cur_src[0] << 16) + absl::big_endian::Load16(cur_src + 1);
  919|      0|      cur_dest[0] = base64[in >> 18];
  920|      0|      in &= 0x3FFFF;
  921|      0|      cur_dest[1] = base64[in >> 12];
  922|      0|      in &= 0xFFF;
  923|      0|      cur_dest[2] = base64[in >> 6];
  924|      0|      in &= 0x3F;
  925|      0|      cur_dest[3] = base64[in];
  926|      0|      cur_dest += 4;
  927|      0|      szdest -= 4;
  928|      0|      break;
  929|      0|    }
  930|      0|    default:
  931|      0|      // Should not be reached: blocks of 4 bytes are handled
  932|      0|      // in the while loop before this switch statement.
  933|      0|      ABSL_RAW_LOG(FATAL, "Logic problem? szsrc = %zu", szsrc);
  934|      0|      break;
  935|      0|  }
  936|      0|  return (cur_dest - dest);
  937|      0|}
  938|       |
  939|       |constexpr char kBase64Chars[] =
  940|       |    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  941|       |
  942|       |constexpr char kWebSafeBase64Chars[] =
  943|       |    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  944|       |
  945|       |template <typename String>
  946|       |void Base64EscapeInternal(const unsigned char* src, size_t szsrc, String* dest,
  947|      0|                          bool do_padding, const char* base64_chars) {
  948|      0|  const size_t calc_escaped_size =
  949|      0|      CalculateBase64EscapedLenInternal(szsrc, do_padding);
  950|      0|  strings_internal::STLStringResizeUninitialized(dest, calc_escaped_size);
  951|      0|
  952|      0|  const size_t escaped_len = Base64EscapeInternal(
  953|      0|      src, szsrc, &(*dest)[0], dest->size(), base64_chars, do_padding);
  954|      0|  assert(calc_escaped_size == escaped_len);
  955|      0|  dest->erase(escaped_len);
  956|      0|}
  957|       |
  958|       |template <typename String>
  959|       |bool Base64UnescapeInternal(const char* src, size_t slen, String* dest,
  960|      0|                            const signed char* unbase64) {
  961|      0|  // Determine the size of the output std::string.  Base64 encodes every 3 bytes into
  962|      0|  // 4 characters.  any leftover chars are added directly for good measure.
  963|      0|  // This is documented in the base64 RFC: http://tools.ietf.org/html/rfc3548
  964|      0|  const size_t dest_len = 3 * (slen / 4) + (slen % 4);
  965|      0|
  966|      0|  strings_internal::STLStringResizeUninitialized(dest, dest_len);
  967|      0|
  968|      0|  // We are getting the destination buffer by getting the beginning of the
  969|      0|  // std::string and converting it into a char *.
  970|      0|  size_t len;
  971|      0|  const bool ok =
  972|      0|      Base64UnescapeInternal(src, slen, &(*dest)[0], dest_len, unbase64, &len);
  973|      0|  if (!ok) {
  974|      0|    dest->clear();
  975|      0|    return false;
  976|      0|  }
  977|      0|
  978|      0|  // could be shorter if there was padding
  979|      0|  assert(len <= dest_len);
  980|      0|  dest->erase(len);
  981|      0|
  982|      0|  return true;
  983|      0|}
  984|       |
  985|       |/* clang-format off */
  986|       |constexpr char kHexValue[256] = {
  987|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  988|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  989|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  990|       |    0,  1,  2,  3,  4,  5,  6, 7, 8, 9, 0, 0, 0, 0, 0, 0,  // '0'..'9'
  991|       |    0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 'A'..'F'
  992|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  993|       |    0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 'a'..'f'
  994|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  995|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  996|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  997|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  998|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  999|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1000|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1001|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 1002|       |    0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 1003|       |};
 1004|       |/* clang-format on */
 1005|       |
 1006|       |// This is a templated function so that T can be either a char*
 1007|       |// or a string.  This works because we use the [] operator to access
 1008|       |// individual characters at a time.
 1009|       |template <typename T>
 1010|      0|void HexStringToBytesInternal(const char* from, T to, ptrdiff_t num) {
 1011|      0|  for (int i = 0; i < num; i++) {
 1012|      0|    to[i] = (kHexValue[from[i * 2] & 0xFF] << 4) +
 1013|      0|            (kHexValue[from[i * 2 + 1] & 0xFF]);
 1014|      0|  }
 1015|      0|}
 1016|       |
 1017|       |// This is a templated function so that T can be either a char* or a
 1018|       |// std::string.
 1019|       |template <typename T>
 1020|      0|void BytesToHexStringInternal(const unsigned char* src, T dest, ptrdiff_t num) {
 1021|      0|  auto dest_ptr = &dest[0];
 1022|      0|  for (auto src_ptr = src; src_ptr != (src + num); ++src_ptr, dest_ptr += 2) {
 1023|      0|    const char* hex_p = &kHexTable[*src_ptr * 2];
 1024|      0|    std::copy(hex_p, hex_p + 2, dest_ptr);
 1025|      0|  }
 1026|      0|}
 1027|       |
 1028|       |}  // namespace
 1029|       |
 1030|       |// ----------------------------------------------------------------------
 1031|       |// CUnescape()
 1032|       |//
 1033|       |// See CUnescapeInternal() for implementation details.
 1034|       |// ----------------------------------------------------------------------
 1035|       |bool CUnescape(absl::string_view source, std::string* dest,
 1036|      0|               std::string* error) {
 1037|      0|  return CUnescapeInternal(source, kUnescapeNulls, dest, error);
 1038|      0|}
 1039|       |
 1040|      0|std::string CEscape(absl::string_view src) {
 1041|      0|  std::string dest;
 1042|      0|  CEscapeAndAppendInternal(src, &dest);
 1043|      0|  return dest;
 1044|      0|}
 1045|       |
 1046|      0|std::string CHexEscape(absl::string_view src) {
 1047|      0|  return CEscapeInternal(src, true, false);
 1048|      0|}
 1049|       |
 1050|      0|std::string Utf8SafeCEscape(absl::string_view src) {
 1051|      0|  return CEscapeInternal(src, false, true);
 1052|      0|}
 1053|       |
 1054|      0|std::string Utf8SafeCHexEscape(absl::string_view src) {
 1055|      0|  return CEscapeInternal(src, true, true);
 1056|      0|}
 1057|       |
 1058|       |// ----------------------------------------------------------------------
 1059|       |// Base64Unescape() - base64 decoder
 1060|       |// Base64Escape() - base64 encoder
 1061|       |// WebSafeBase64Unescape() - Google's variation of base64 decoder
 1062|       |// WebSafeBase64Escape() - Google's variation of base64 encoder
 1063|       |//
 1064|       |// Check out
 1065|       |// http://tools.ietf.org/html/rfc2045 for formal description, but what we
 1066|       |// care about is that...
 1067|       |//   Take the encoded stuff in groups of 4 characters and turn each
 1068|       |//   character into a code 0 to 63 thus:
 1069|       |//           A-Z map to 0 to 25
 1070|       |//           a-z map to 26 to 51
 1071|       |//           0-9 map to 52 to 61
 1072|       |//           +(- for WebSafe) maps to 62
 1073|       |//           /(_ for WebSafe) maps to 63
 1074|       |//   There will be four numbers, all less than 64 which can be represented
 1075|       |//   by a 6 digit binary number (aaaaaa, bbbbbb, cccccc, dddddd respectively).
 1076|       |//   Arrange the 6 digit binary numbers into three bytes as such:
 1077|       |//   aaaaaabb bbbbcccc ccdddddd
 1078|       |//   Equals signs (one or two) are used at the end of the encoded block to
 1079|       |//   indicate that the text was not an integer multiple of three bytes long.
 1080|       |// ----------------------------------------------------------------------
 1081|       |
 1082|      0|bool Base64Unescape(absl::string_view src, std::string* dest) {
 1083|      0|  return Base64UnescapeInternal(src.data(), src.size(), dest, kUnBase64);
 1084|      0|}
 1085|       |
 1086|      0|bool WebSafeBase64Unescape(absl::string_view src, std::string* dest) {
 1087|      0|  return Base64UnescapeInternal(src.data(), src.size(), dest, kUnWebSafeBase64);
 1088|      0|}
 1089|       |
 1090|      0|void Base64Escape(absl::string_view src, std::string* dest) {
 1091|      0|  Base64EscapeInternal(reinterpret_cast<const unsigned char*>(src.data()),
 1092|      0|                       src.size(), dest, true, kBase64Chars);
 1093|      0|}
 1094|       |
 1095|      0|void WebSafeBase64Escape(absl::string_view src, std::string* dest) {
 1096|      0|  Base64EscapeInternal(reinterpret_cast<const unsigned char*>(src.data()),
 1097|      0|                       src.size(), dest, false, kWebSafeBase64Chars);
 1098|      0|}
 1099|       |
 1100|      0|std::string Base64Escape(absl::string_view src) {
 1101|      0|  std::string dest;
 1102|      0|  Base64EscapeInternal(reinterpret_cast<const unsigned char*>(src.data()),
 1103|      0|                       src.size(), &dest, true, kBase64Chars);
 1104|      0|  return dest;
 1105|      0|}
 1106|       |
 1107|      0|std::string WebSafeBase64Escape(absl::string_view src) {
 1108|      0|  std::string dest;
 1109|      0|  Base64EscapeInternal(reinterpret_cast<const unsigned char*>(src.data()),
 1110|      0|                       src.size(), &dest, false, kWebSafeBase64Chars);
 1111|      0|  return dest;
 1112|      0|}
 1113|       |
 1114|      0|std::string HexStringToBytes(absl::string_view from) {
 1115|      0|  std::string result;
 1116|      0|  const auto num = from.size() / 2;
 1117|      0|  strings_internal::STLStringResizeUninitialized(&result, num);
 1118|      0|  absl::HexStringToBytesInternal<std::string&>(from.data(), result, num);
 1119|      0|  return result;
 1120|      0|}
 1121|       |
 1122|      0|std::string BytesToHexString(absl::string_view from) {
 1123|      0|  std::string result;
 1124|      0|  strings_internal::STLStringResizeUninitialized(&result, 2 * from.size());
 1125|      0|  absl::BytesToHexStringInternal<std::string&>(
 1126|      0|      reinterpret_cast<const unsigned char*>(from.data()), result, from.size());
 1127|      0|  return result;
 1128|      0|}
 1129|       |
 1130|       |}  // inline namespace lts_2019_08_08
 1131|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/escaping.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: escaping.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This header file contains string utilities involved in escaping and
   21|       |// unescaping strings in various ways.
   22|       |
   23|       |#ifndef ABSL_STRINGS_ESCAPING_H_
   24|       |#define ABSL_STRINGS_ESCAPING_H_
   25|       |
   26|       |#include <cstddef>
   27|       |#include <string>
   28|       |#include <vector>
   29|       |
   30|       |#include "absl/base/macros.h"
   31|       |#include "absl/strings/ascii.h"
   32|       |#include "absl/strings/str_join.h"
   33|       |#include "absl/strings/string_view.h"
   34|       |
   35|       |namespace absl {
   36|       |inline namespace lts_2019_08_08 {
   37|       |
   38|       |// CUnescape()
   39|       |//
   40|       |// Unescapes a `source` string and copies it into `dest`, rewriting C-style
   41|       |// escape sequences (https://en.cppreference.com/w/cpp/language/escape) into
   42|       |// their proper code point equivalents, returning `true` if successful.
   43|       |//
   44|       |// The following unescape sequences can be handled:
   45|       |//
   46|       |//   * ASCII escape sequences ('\n','\r','\\', etc.) to their ASCII equivalents
   47|       |//   * Octal escape sequences ('\nnn') to byte nnn. The unescaped value must
   48|       |//     resolve to a single byte or an error will occur. E.g. values greater than
   49|       |//     0xff will produce an error.
   50|       |//   * Hexadecimal escape sequences ('\xnn') to byte nn. While an arbitrary
   51|       |//     number of following digits are allowed, the unescaped value must resolve
   52|       |//     to a single byte or an error will occur. E.g. '\x0045' is equivalent to
   53|       |//     '\x45', but '\x1234' will produce an error.
   54|       |//   * Unicode escape sequences ('\unnnn' for exactly four hex digits or
   55|       |//     '\Unnnnnnnn' for exactly eight hex digits, which will be encoded in
   56|       |//     UTF-8. (E.g., `\u2019` unescapes to the three bytes 0xE2, 0x80, and
   57|       |//     0x99).
   58|       |//
   59|       |// If any errors are encountered, this function returns `false`, leaving the
   60|       |// `dest` output parameter in an unspecified state, and stores the first
   61|       |// encountered error in `error`. To disable error reporting, set `error` to
   62|       |// `nullptr` or use the overload with no error reporting below.
   63|       |//
   64|       |// Example:
   65|       |//
   66|       |//   std::string s = "foo\\rbar\\nbaz\\t";
   67|       |//   std::string unescaped_s;
   68|       |//   if (!absl::CUnescape(s, &unescaped_s) {
   69|       |//     ...
   70|       |//   }
   71|       |//   EXPECT_EQ(unescaped_s, "foo\rbar\nbaz\t");
   72|       |bool CUnescape(absl::string_view source, std::string* dest, std::string* error);
   73|       |
   74|       |// Overload of `CUnescape()` with no error reporting.
   75|      0|inline bool CUnescape(absl::string_view source, std::string* dest) {
   76|      0|  return CUnescape(source, dest, nullptr);
   77|      0|}
   78|       |
   79|       |// CEscape()
   80|       |//
   81|       |// Escapes a 'src' string using C-style escapes sequences
   82|       |// (https://en.cppreference.com/w/cpp/language/escape), escaping other
   83|       |// non-printable/non-whitespace bytes as octal sequences (e.g. "\377").
   84|       |//
   85|       |// Example:
   86|       |//
   87|       |//   std::string s = "foo\rbar\tbaz\010\011\012\013\014\x0d\n";
   88|       |//   std::string escaped_s = absl::CEscape(s);
   89|       |//   EXPECT_EQ(escaped_s, "foo\\rbar\\tbaz\\010\\t\\n\\013\\014\\r\\n");
   90|       |std::string CEscape(absl::string_view src);
   91|       |
   92|       |// CHexEscape()
   93|       |//
   94|       |// Escapes a 'src' string using C-style escape sequences, escaping
   95|       |// other non-printable/non-whitespace bytes as hexadecimal sequences (e.g.
   96|       |// "\xFF").
   97|       |//
   98|       |// Example:
   99|       |//
  100|       |//   std::string s = "foo\rbar\tbaz\010\011\012\013\014\x0d\n";
  101|       |//   std::string escaped_s = absl::CHexEscape(s);
  102|       |//   EXPECT_EQ(escaped_s, "foo\\rbar\\tbaz\\x08\\t\\n\\x0b\\x0c\\r\\n");
  103|       |std::string CHexEscape(absl::string_view src);
  104|       |
  105|       |// Utf8SafeCEscape()
  106|       |//
  107|       |// Escapes a 'src' string using C-style escape sequences, escaping bytes as
  108|       |// octal sequences, and passing through UTF-8 characters without conversion.
  109|       |// I.e., when encountering any bytes with their high bit set, this function
  110|       |// will not escape those values, whether or not they are valid UTF-8.
  111|       |std::string Utf8SafeCEscape(absl::string_view src);
  112|       |
  113|       |// Utf8SafeCHexEscape()
  114|       |//
  115|       |// Escapes a 'src' string using C-style escape sequences, escaping bytes as
  116|       |// hexadecimal sequences, and passing through UTF-8 characters without
  117|       |// conversion.
  118|       |std::string Utf8SafeCHexEscape(absl::string_view src);
  119|       |
  120|       |// Base64Unescape()
  121|       |//
  122|       |// Converts a `src` string encoded in Base64 to its binary equivalent, writing
  123|       |// it to a `dest` buffer, returning `true` on success. If `src` contains invalid
  124|       |// characters, `dest` is cleared and returns `false`.
  125|       |bool Base64Unescape(absl::string_view src, std::string* dest);
  126|       |
  127|       |// WebSafeBase64Unescape()
  128|       |//
  129|       |// Converts a `src` string encoded in Base64 to its binary equivalent, writing
  130|       |// it to a `dest` buffer, but using '-' instead of '+', and '_' instead of '/'.
  131|       |// If `src` contains invalid characters, `dest` is cleared and returns `false`.
  132|       |bool WebSafeBase64Unescape(absl::string_view src, std::string* dest);
  133|       |
  134|       |// Base64Escape()
  135|       |//
  136|       |// Encodes a `src` string into a base64-encoded string, with padding characters.
  137|       |// This function conforms with RFC 4648 section 4 (base64).
  138|       |void Base64Escape(absl::string_view src, std::string* dest);
  139|       |std::string Base64Escape(absl::string_view src);
  140|       |
  141|       |// WebSafeBase64Escape()
  142|       |//
  143|       |// Encodes a `src` string into a base64-like string, using '-' instead of '+'
  144|       |// and '_' instead of '/', and without padding. This function conforms with RFC
  145|       |// 4648 section 5 (base64url).
  146|       |void WebSafeBase64Escape(absl::string_view src, std::string* dest);
  147|       |std::string WebSafeBase64Escape(absl::string_view src);
  148|       |
  149|       |// HexStringToBytes()
  150|       |//
  151|       |// Converts an ASCII hex string into bytes, returning binary data of length
  152|       |// `from.size()/2`.
  153|       |std::string HexStringToBytes(absl::string_view from);
  154|       |
  155|       |// BytesToHexString()
  156|       |//
  157|       |// Converts binary data into an ASCII text string, returning a string of size
  158|       |// `2*from.size()`.
  159|       |std::string BytesToHexString(absl::string_view from);
  160|       |
  161|       |}  // inline namespace lts_2019_08_08
  162|       |}  // namespace absl
  163|       |
  164|       |#endif  // ABSL_STRINGS_ESCAPING_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/char_map.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// Character Map Class
   16|       |//
   17|       |// A fast, bit-vector map for 8-bit unsigned characters.
   18|       |// This class is useful for non-character purposes as well.
   19|       |
   20|       |#ifndef ABSL_STRINGS_INTERNAL_CHAR_MAP_H_
   21|       |#define ABSL_STRINGS_INTERNAL_CHAR_MAP_H_
   22|       |
   23|       |#include <cstddef>
   24|       |#include <cstdint>
   25|       |#include <cstring>
   26|       |
   27|       |#include "absl/base/macros.h"
   28|       |#include "absl/base/port.h"
   29|       |
   30|       |namespace absl {
   31|       |inline namespace lts_2019_08_08 {
   32|       |namespace strings_internal {
   33|       |
   34|       |class Charmap {
   35|       | public:
   36|      0|  constexpr Charmap() : m_() {}
   37|       |
   38|       |  // Initializes with a given char*.  Note that NUL is not treated as
   39|       |  // a terminator, but rather a char to be flicked.
   40|      0|  Charmap(const char* str, int len) : m_() {
   41|      0|    while (len--) SetChar(*str++);
   42|      0|  }
   43|       |
   44|       |  // Initializes with a given char*.  NUL is treated as a terminator
   45|       |  // and will not be in the charmap.
   46|      0|  explicit Charmap(const char* str) : m_() {
   47|      0|    while (*str) SetChar(*str++);
   48|      0|  }
   49|       |
   50|      0|  constexpr bool contains(unsigned char c) const {
   51|      0|    return (m_[c / 64] >> (c % 64)) & 0x1;
   52|      0|  }
   53|       |
   54|       |  // Returns true if and only if a character exists in both maps.
   55|      0|  bool IntersectsWith(const Charmap& c) const {
   56|      0|    for (size_t i = 0; i < ABSL_ARRAYSIZE(m_); ++i) {
   57|      0|      if ((m_[i] & c.m_[i]) != 0) return true;
   58|      0|    }
   59|      0|    return false;
   60|      0|  }
   61|       |
   62|      0|  bool IsZero() const {
   63|      0|    for (uint64_t c : m_) {
   64|      0|      if (c != 0) return false;
   65|      0|    }
   66|      0|    return true;
   67|      0|  }
   68|       |
   69|       |  // Containing only a single specified char.
   70|      0|  static constexpr Charmap Char(char x) {
   71|      0|    return Charmap(CharMaskForWord(x, 0), CharMaskForWord(x, 1),
   72|      0|                   CharMaskForWord(x, 2), CharMaskForWord(x, 3));
   73|      0|  }
   74|       |
   75|       |  // Containing all the chars in the C-std::string 's'.
   76|       |  // Note that this is expensively recursive because of the C++11 constexpr
   77|       |  // formulation. Use only in constexpr initializers.
   78|      0|  static constexpr Charmap FromString(const char* s) {
   79|      0|    return *s == 0 ? Charmap() : (Char(*s) | FromString(s + 1));
   80|      0|  }
   81|       |
   82|       |  // Containing all the chars in the closed interval [lo,hi].
   83|      0|  static constexpr Charmap Range(char lo, char hi) {
   84|      0|    return Charmap(RangeForWord(lo, hi, 0), RangeForWord(lo, hi, 1),
   85|      0|                   RangeForWord(lo, hi, 2), RangeForWord(lo, hi, 3));
   86|      0|  }
   87|       |
   88|      0|  friend constexpr Charmap operator&(const Charmap& a, const Charmap& b) {
   89|      0|    return Charmap(a.m_[0] & b.m_[0], a.m_[1] & b.m_[1], a.m_[2] & b.m_[2],
   90|      0|                   a.m_[3] & b.m_[3]);
   91|      0|  }
   92|       |
   93|      0|  friend constexpr Charmap operator|(const Charmap& a, const Charmap& b) {
   94|      0|    return Charmap(a.m_[0] | b.m_[0], a.m_[1] | b.m_[1], a.m_[2] | b.m_[2],
   95|      0|                   a.m_[3] | b.m_[3]);
   96|      0|  }
   97|       |
   98|      0|  friend constexpr Charmap operator~(const Charmap& a) {
   99|      0|    return Charmap(~a.m_[0], ~a.m_[1], ~a.m_[2], ~a.m_[3]);
  100|      0|  }
  101|       |
  102|       | private:
  103|       |  constexpr Charmap(uint64_t b0, uint64_t b1, uint64_t b2, uint64_t b3)
  104|      0|      : m_{b0, b1, b2, b3} {}
  105|       |
  106|       |  static constexpr uint64_t RangeForWord(unsigned char lo, unsigned char hi,
  107|      0|                                         uint64_t word) {
  108|      0|    return OpenRangeFromZeroForWord(hi + 1, word) &
  109|      0|           ~OpenRangeFromZeroForWord(lo, word);
  110|      0|  }
  111|       |
  112|       |  // All the chars in the specified word of the range [0, upper).
  113|       |  static constexpr uint64_t OpenRangeFromZeroForWord(uint64_t upper,
  114|      0|                                                     uint64_t word) {
  115|      0|    return (upper <= 64 * word)
  116|      0|               ? 0
  117|      0|               : (upper >= 64 * (word + 1))
  118|      0|                     ? ~static_cast<uint64_t>(0)
  119|      0|                     : (~static_cast<uint64_t>(0) >> (64 - upper % 64));
  120|      0|  }
  121|       |
  122|      0|  static constexpr uint64_t CharMaskForWord(unsigned char x, uint64_t word) {
  123|      0|    return (x / 64 == word) ? (static_cast<uint64_t>(1) << (x % 64)) : 0;
  124|      0|  }
  125|       |
  126|       | private:
  127|      0|  void SetChar(unsigned char c) {
  128|      0|    m_[c / 64] |= static_cast<uint64_t>(1) << (c % 64);
  129|      0|  }
  130|       |
  131|       |  uint64_t m_[4];
  132|       |};
  133|       |
  134|       |// Mirror the char-classifying predicates in <cctype>
  135|      0|constexpr Charmap UpperCharmap() { return Charmap::Range('A', 'Z'); }
  136|      0|constexpr Charmap LowerCharmap() { return Charmap::Range('a', 'z'); }
  137|      0|constexpr Charmap DigitCharmap() { return Charmap::Range('0', '9'); }
  138|      0|constexpr Charmap AlphaCharmap() { return LowerCharmap() | UpperCharmap(); }
  139|      0|constexpr Charmap AlnumCharmap() { return DigitCharmap() | AlphaCharmap(); }
  140|      0|constexpr Charmap XDigitCharmap() {
  141|      0|  return DigitCharmap() | Charmap::Range('A', 'F') | Charmap::Range('a', 'f');
  142|      0|}
  143|      0|constexpr Charmap PrintCharmap() { return Charmap::Range(0x20, 0x7e); }
  144|      0|constexpr Charmap SpaceCharmap() { return Charmap::FromString("\t\n\v\f\r "); }
  145|      0|constexpr Charmap CntrlCharmap() {
  146|      0|  return Charmap::Range(0, 0x7f) & ~PrintCharmap();
  147|      0|}
  148|      0|constexpr Charmap BlankCharmap() { return Charmap::FromString("\t "); }
  149|      0|constexpr Charmap GraphCharmap() { return PrintCharmap() & ~SpaceCharmap(); }
  150|      0|constexpr Charmap PunctCharmap() { return GraphCharmap() & ~AlnumCharmap(); }
  151|       |
  152|       |}  // namespace strings_internal
  153|       |}  // inline namespace lts_2019_08_08
  154|       |}  // namespace absl
  155|       |
  156|       |#endif  // ABSL_STRINGS_INTERNAL_CHAR_MAP_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/charconv_bigint.cc:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/internal/charconv_bigint.h"
   16|       |
   17|       |#include <algorithm>
   18|       |#include <cassert>
   19|       |#include <string>
   20|       |
   21|       |namespace absl {
   22|       |inline namespace lts_2019_08_08 {
   23|       |namespace strings_internal {
   24|       |
   25|       |namespace {
   26|       |
   27|       |// Table containing some large powers of 5, for fast computation.
   28|       |
   29|       |// Constant step size for entries in the kLargePowersOfFive table.  Each entry
   30|       |// is larger than the previous entry by a factor of 5**kLargePowerOfFiveStep
   31|       |// (or 5**27).
   32|       |//
   33|       |// In other words, the Nth entry in the table is 5**(27*N).
   34|       |//
   35|       |// 5**27 is the largest power of 5 that fits in 64 bits.
   36|       |constexpr int kLargePowerOfFiveStep = 27;
   37|       |
   38|       |// The largest legal index into the kLargePowersOfFive table.
   39|       |//
   40|       |// In other words, the largest precomputed power of 5 is 5**(27*20).
   41|       |constexpr int kLargestPowerOfFiveIndex = 20;
   42|       |
   43|       |// Table of powers of (5**27), up to (5**27)**20 == 5**540.
   44|       |//
   45|       |// Used to generate large powers of 5 while limiting the number of repeated
   46|       |// multiplications required.
   47|       |//
   48|       |// clang-format off
   49|       |const uint32_t kLargePowersOfFive[] = {
   50|       |// 5**27 (i=1), start=0, end=2
   51|       |  0xfa10079dU, 0x6765c793U,
   52|       |// 5**54 (i=2), start=2, end=6
   53|       |  0x97d9f649U, 0x6664242dU, 0x29939b14U, 0x29c30f10U,
   54|       |// 5**81 (i=3), start=6, end=12
   55|       |  0xc4f809c5U, 0x7bf3f22aU, 0x67bdae34U, 0xad340517U, 0x369d1b5fU, 0x10de1593U,
   56|       |// 5**108 (i=4), start=12, end=20
   57|       |  0x92b260d1U, 0x9efff7c7U, 0x81de0ec6U, 0xaeba5d56U, 0x410664a4U, 0x4f40737aU,
   58|       |  0x20d3846fU, 0x06d00f73U,
   59|       |// 5**135 (i=5), start=20, end=30
   60|       |  0xff1b172dU, 0x13a1d71cU, 0xefa07617U, 0x7f682d3dU, 0xff8c90c0U, 0x3f0131e7U,
   61|       |  0x3fdcb9feU, 0x917b0177U, 0x16c407a7U, 0x02c06b9dU,
   62|       |// 5**162 (i=6), start=30, end=42
   63|       |  0x960f7199U, 0x056667ecU, 0xe07aefd8U, 0x80f2b9ccU, 0x8273f5e3U, 0xeb9a214aU,
   64|       |  0x40b38005U, 0x0e477ad4U, 0x277d08e6U, 0xfa28b11eU, 0xd3f7d784U, 0x011c835bU,
   65|       |// 5**189 (i=7), start=42, end=56
   66|       |  0xf723d9d5U, 0x3282d3f3U, 0xe00857d1U, 0x69659d25U, 0x2cf117cfU, 0x24da6d07U,
   67|       |  0x954d1417U, 0x3e5d8cedU, 0x7a8bb766U, 0xfd785ae6U, 0x645436d2U, 0x40c78b34U,
   68|       |  0x94151217U, 0x0072e9f7U,
   69|       |// 5**216 (i=8), start=56, end=72
   70|       |  0x2b416aa1U, 0x7893c5a7U, 0xe37dc6d4U, 0x2bad2beaU, 0xf0fc846cU, 0x7575ae4bU,
   71|       |  0x62587b14U, 0x83b67a34U, 0x02110cdbU, 0xf7992f55U, 0x00deb022U, 0xa4a23becU,
   72|       |  0x8af5c5cdU, 0xb85b654fU, 0x818df38bU, 0x002e69d2U,
   73|       |// 5**243 (i=9), start=72, end=90
   74|       |  0x3518cbbdU, 0x20b0c15fU, 0x38756c2fU, 0xfb5dc3ddU, 0x22ad2d94U, 0xbf35a952U,
   75|       |  0xa699192aU, 0x9a613326U, 0xad2a9cedU, 0xd7f48968U, 0xe87dfb54U, 0xc8f05db6U,
   76|       |  0x5ef67531U, 0x31c1ab49U, 0xe202ac9fU, 0x9b2957b5U, 0xa143f6d3U, 0x0012bf07U,
   77|       |// 5**270 (i=10), start=90, end=110
   78|       |  0x8b971de9U, 0x21aba2e1U, 0x63944362U, 0x57172336U, 0xd9544225U, 0xfb534166U,
   79|       |  0x08c563eeU, 0x14640ee2U, 0x24e40d31U, 0x02b06537U, 0x03887f14U, 0x0285e533U,
   80|       |  0xb744ef26U, 0x8be3a6c4U, 0x266979b4U, 0x6761ece2U, 0xd9cb39e4U, 0xe67de319U,
   81|       |  0x0d39e796U, 0x00079250U,
   82|       |// 5**297 (i=11), start=110, end=132
   83|       |  0x260eb6e5U, 0xf414a796U, 0xee1a7491U, 0xdb9368ebU, 0xf50c105bU, 0x59157750U,
   84|       |  0x9ed2fb5cU, 0xf6e56d8bU, 0xeaee8d23U, 0x0f319f75U, 0x2aa134d6U, 0xac2908e9U,
   85|       |  0xd4413298U, 0x02f02a55U, 0x989d5a7aU, 0x70dde184U, 0xba8040a7U, 0x03200981U,
   86|       |  0xbe03b11cU, 0x3c1c2a18U, 0xd60427a1U, 0x00030ee0U,
   87|       |// 5**324 (i=12), start=132, end=156
   88|       |  0xce566d71U, 0xf1c4aa25U, 0x4e93ca53U, 0xa72283d0U, 0x551a73eaU, 0x3d0538e2U,
   89|       |  0x8da4303fU, 0x6a58de60U, 0x0e660221U, 0x49cf61a6U, 0x8d058fc1U, 0xb9d1a14cU,
   90|       |  0x4bab157dU, 0xc85c6932U, 0x518c8b9eU, 0x9b92b8d0U, 0x0d8a0e21U, 0xbd855df9U,
   91|       |  0xb3ea59a1U, 0x8da29289U, 0x4584d506U, 0x3752d80fU, 0xb72569c6U, 0x00013c33U,
   92|       |// 5**351 (i=13), start=156, end=182
   93|       |  0x190f354dU, 0x83695cfeU, 0xe5a4d0c7U, 0xb60fb7e8U, 0xee5bbcc4U, 0xb922054cU,
   94|       |  0xbb4f0d85U, 0x48394028U, 0x1d8957dbU, 0x0d7edb14U, 0x4ecc7587U, 0x505e9e02U,
   95|       |  0x4c87f36bU, 0x99e66bd6U, 0x44b9ed35U, 0x753037d4U, 0xe5fe5f27U, 0x2742c203U,
   96|       |  0x13b2ed2bU, 0xdc525d2cU, 0xe6fde59aU, 0x77ffb18fU, 0x13c5752cU, 0x08a84bccU,
   97|       |  0x859a4940U, 0x00007fb6U,
   98|       |// 5**378 (i=14), start=182, end=210
   99|       |  0x4f98cb39U, 0xa60edbbcU, 0x83b5872eU, 0xa501acffU, 0x9cc76f78U, 0xbadd4c73U,
  100|       |  0x43e989faU, 0xca7acf80U, 0x2e0c824fU, 0xb19f4ffcU, 0x092fd81cU, 0xe4eb645bU,
  101|       |  0xa1ff84c2U, 0x8a5a83baU, 0xa8a1fae9U, 0x1db43609U, 0xb0fed50bU, 0x0dd7d2bdU,
  102|       |  0x7d7accd8U, 0x91fa640fU, 0x37dcc6c5U, 0x1c417fd5U, 0xe4d462adU, 0xe8a43399U,
  103|       |  0x131bf9a5U, 0x8df54d29U, 0x36547dc1U, 0x00003395U,
  104|       |// 5**405 (i=15), start=210, end=240
  105|       |  0x5bd330f5U, 0x77d21967U, 0x1ac481b7U, 0x6be2f7ceU, 0x7f4792a9U, 0xe84c2c52U,
  106|       |  0x84592228U, 0x9dcaf829U, 0xdab44ce1U, 0x3d0c311bU, 0x532e297dU, 0x4704e8b4U,
  107|       |  0x9cdc32beU, 0x41e64d9dU, 0x7717bea1U, 0xa824c00dU, 0x08f50b27U, 0x0f198d77U,
  108|       |  0x49bbfdf0U, 0x025c6c69U, 0xd4e55cd3U, 0xf083602bU, 0xb9f0fecdU, 0xc0864aeaU,
  109|       |  0x9cb98681U, 0xaaf620e9U, 0xacb6df30U, 0x4faafe66U, 0x8af13c3bU, 0x000014d5U,
  110|       |// 5**432 (i=16), start=240, end=272
  111|       |  0x682bb941U, 0x89a9f297U, 0xcba75d7bU, 0x404217b1U, 0xb4e519e9U, 0xa1bc162bU,
  112|       |  0xf7f5910aU, 0x98715af5U, 0x2ff53e57U, 0xe3ef118cU, 0x490c4543U, 0xbc9b1734U,
  113|       |  0x2affbe4dU, 0x4cedcb4cU, 0xfb14e99eU, 0x35e34212U, 0xece39c24U, 0x07673ab3U,
  114|       |  0xe73115ddU, 0xd15d38e7U, 0x093eed3bU, 0xf8e7eac5U, 0x78a8cc80U, 0x25227aacU,
  115|       |  0x3f590551U, 0x413da1cbU, 0xdf643a55U, 0xab65ad44U, 0xd70b23d7U, 0xc672cd76U,
  116|       |  0x3364ea62U, 0x0000086aU,
  117|       |// 5**459 (i=17), start=272, end=306
  118|       |  0x22f163ddU, 0x23cf07acU, 0xbe2af6c2U, 0xf412f6f6U, 0xc3ff541eU, 0x6eeaf7deU,
  119|       |  0xa47047e0U, 0x408cda92U, 0x0f0eeb08U, 0x56deba9dU, 0xcfc6b090U, 0x8bbbdf04U,
  120|       |  0x3933cdb3U, 0x9e7bb67dU, 0x9f297035U, 0x38946244U, 0xee1d37bbU, 0xde898174U,
  121|       |  0x63f3559dU, 0x705b72fbU, 0x138d27d9U, 0xf8603a78U, 0x735eec44U, 0xe30987d5U,
  122|       |  0xc6d38070U, 0x9cfe548eU, 0x9ff01422U, 0x7c564aa8U, 0x91cc60baU, 0xcbc3565dU,
  123|       |  0x7550a50bU, 0x6909aeadU, 0x13234c45U, 0x00000366U,
  124|       |// 5**486 (i=18), start=306, end=342
  125|       |  0x17954989U, 0x3a7d7709U, 0x98042de5U, 0xa9011443U, 0x45e723c2U, 0x269ffd6fU,
  126|       |  0x58852a46U, 0xaaa1042aU, 0x2eee8153U, 0xb2b6c39eU, 0xaf845b65U, 0xf6c365d7U,
  127|       |  0xe4cffb2bU, 0xc840e90cU, 0xabea8abbU, 0x5c58f8d2U, 0x5c19fa3aU, 0x4670910aU,
  128|       |  0x4449f21cU, 0xefa645b3U, 0xcc427decU, 0x083c3d73U, 0x467cb413U, 0x6fe10ae4U,
  129|       |  0x3caffc72U, 0x9f8da55eU, 0x5e5c8ea7U, 0x490594bbU, 0xf0871b0bU, 0xdd89816cU,
  130|       |  0x8e931df8U, 0xe85ce1c9U, 0xcca090a5U, 0x575fa16bU, 0x6b9f106cU, 0x0000015fU,
  131|       |// 5**513 (i=19), start=342, end=380
  132|       |  0xee20d805U, 0x57bc3c07U, 0xcdea624eU, 0xd3f0f52dU, 0x9924b4f4U, 0xcf968640U,
  133|       |  0x61d41962U, 0xe87fb464U, 0xeaaf51c7U, 0x564c8b60U, 0xccda4028U, 0x529428bbU,
  134|       |  0x313a1fa8U, 0x96bd0f94U, 0x7a82ebaaU, 0xad99e7e9U, 0xf2668cd4U, 0xbe33a45eU,
  135|       |  0xfd0db669U, 0x87ee369fU, 0xd3ec20edU, 0x9c4d7db7U, 0xdedcf0d8U, 0x7cd2ca64U,
  136|       |  0xe25a6577U, 0x61003fd4U, 0xe56f54ccU, 0x10b7c748U, 0x40526e5eU, 0x7300ae87U,
  137|       |  0x5c439261U, 0x2c0ff469U, 0xbf723f12U, 0xb2379b61U, 0xbf59b4f5U, 0xc91b1c3fU,
  138|       |  0xf0046d27U, 0x0000008dU,
  139|       |// 5**540 (i=20), start=380, end=420
  140|       |  0x525c9e11U, 0xf4e0eb41U, 0xebb2895dU, 0x5da512f9U, 0x7d9b29d4U, 0x452f4edcU,
  141|       |  0x0b90bc37U, 0x341777cbU, 0x63d269afU, 0x1da77929U, 0x0a5c1826U, 0x77991898U,
  142|       |  0x5aeddf86U, 0xf853a877U, 0x538c31ccU, 0xe84896daU, 0xb7a0010bU, 0x17ef4de5U,
  143|       |  0xa52a2adeU, 0x029fd81cU, 0x987ce701U, 0x27fefd77U, 0xdb46c66fU, 0x5d301900U,
  144|       |  0x496998c0U, 0xbb6598b9U, 0x5eebb607U, 0xe547354aU, 0xdf4a2f7eU, 0xf06c4955U,
  145|       |  0x96242ffaU, 0x1775fb27U, 0xbecc58ceU, 0xebf2a53bU, 0x3eaad82aU, 0xf41137baU,
  146|       |  0x573e6fbaU, 0xfb4866b8U, 0x54002148U, 0x00000039U,
  147|       |};
  148|       |// clang-format on
  149|       |
  150|       |// Returns a pointer to the big integer data for (5**27)**i.  i must be
  151|       |// between 1 and 20, inclusive.
  152|      0|const uint32_t* LargePowerOfFiveData(int i) {
  153|      0|  return kLargePowersOfFive + i * (i - 1);
  154|      0|}
  155|       |
  156|       |// Returns the size of the big integer data for (5**27)**i, in words.  i must be
  157|       |// between 1 and 20, inclusive.
  158|      0|int LargePowerOfFiveSize(int i) { return 2 * i; }
  159|       |}  // namespace
  160|       |
  161|       |const uint32_t kFiveToNth[14] = {
  162|       |    1,     5,      25,      125,     625,      3125,      15625,
  163|       |    78125, 390625, 1953125, 9765625, 48828125, 244140625, 1220703125,
  164|       |};
  165|       |
  166|       |const uint32_t kTenToNth[10] = {
  167|       |    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000,
  168|       |};
  169|       |
  170|       |template <int max_words>
  171|       |int BigUnsigned<max_words>::ReadFloatMantissa(const ParsedFloat& fp,
  172|      0|                                              int significant_digits) {
  173|      0|  SetToZero();
  174|      0|  assert(fp.type == FloatType::kNumber);
  175|      0|
  176|      0|  if (fp.subrange_begin == nullptr) {
  177|      0|    // We already exactly parsed the mantissa, so no more work is necessary.
  178|      0|    words_[0] = fp.mantissa & 0xffffffffu;
  179|      0|    words_[1] = fp.mantissa >> 32;
  180|      0|    if (words_[1]) {
  181|      0|      size_ = 2;
  182|      0|    } else if (words_[0]) {
  183|      0|      size_ = 1;
  184|      0|    }
  185|      0|    return fp.exponent;
  186|      0|  }
  187|      0|  int exponent_adjust =
  188|      0|      ReadDigits(fp.subrange_begin, fp.subrange_end, significant_digits);
  189|      0|  return fp.literal_exponent + exponent_adjust;
  190|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE17ReadFloatMantissaERKNS1_11ParsedFloatEi
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE17ReadFloatMantissaERKNS1_11ParsedFloatEi
  ------------------
  191|       |
  192|       |template <int max_words>
  193|       |int BigUnsigned<max_words>::ReadDigits(const char* begin, const char* end,
  194|      0|                                       int significant_digits) {
  195|      0|  assert(significant_digits <= Digits10() + 1);
  196|      0|  SetToZero();
  197|      0|
  198|      0|  bool after_decimal_point = false;
  199|      0|  // Discard any leading zeroes before the decimal point
  200|      0|  while (begin < end && *begin == '0') {
  201|      0|    ++begin;
  202|      0|  }
  203|      0|  int dropped_digits = 0;
  204|      0|  // Discard any trailing zeroes.  These may or may not be after the decimal
  205|      0|  // point.
  206|      0|  while (begin < end && *std::prev(end) == '0') {
  207|      0|    --end;
  208|      0|    ++dropped_digits;
  209|      0|  }
  210|      0|  if (begin < end && *std::prev(end) == '.') {
  211|      0|    // If the std::string ends in '.', either before or after dropping zeroes, then
  212|      0|    // drop the decimal point and look for more digits to drop.
  213|      0|    dropped_digits = 0;
  214|      0|    --end;
  215|      0|    while (begin < end && *std::prev(end) == '0') {
  216|      0|      --end;
  217|      0|      ++dropped_digits;
  218|      0|    }
  219|      0|  } else if (dropped_digits) {
  220|      0|    // We dropped digits, and aren't sure if they're before or after the decimal
  221|      0|    // point.  Figure that out now.
  222|      0|    const char* dp = std::find(begin, end, '.');
  223|      0|    if (dp != end) {
  224|      0|      // The dropped trailing digits were after the decimal point, so don't
  225|      0|      // count them.
  226|      0|      dropped_digits = 0;
  227|      0|    }
  228|      0|  }
  229|      0|  // Any non-fraction digits we dropped need to be accounted for in our exponent
  230|      0|  // adjustment.
  231|      0|  int exponent_adjust = dropped_digits;
  232|      0|
  233|      0|  uint32_t queued = 0;
  234|      0|  int digits_queued = 0;
  235|      0|  for (; begin != end && significant_digits > 0; ++begin) {
  236|      0|    if (*begin == '.') {
  237|      0|      after_decimal_point = true;
  238|      0|      continue;
  239|      0|    }
  240|      0|    if (after_decimal_point) {
  241|      0|      // For each fractional digit we emit in our parsed integer, adjust our
  242|      0|      // decimal exponent to compensate.
  243|      0|      --exponent_adjust;
  244|      0|    }
  245|      0|    int digit = (*begin - '0');
  246|      0|    --significant_digits;
  247|      0|    if (significant_digits == 0 && std::next(begin) != end &&
  248|      0|        (digit == 0 || digit == 5)) {
  249|      0|      // If this is the very last significant digit, but insignificant digits
  250|      0|      // remain, we know that the last of those remaining significant digits is
  251|      0|      // nonzero.  (If it wasn't, we would have stripped it before we got here.)
  252|      0|      // So if this final digit is a 0 or 5, adjust it upward by 1.
  253|      0|      //
  254|      0|      // This adjustment is what allows incredibly large mantissas ending in
  255|      0|      // 500000...000000000001 to correctly round up, rather than to nearest.
  256|      0|      ++digit;
  257|      0|    }
  258|      0|    queued = 10 * queued + digit;
  259|      0|    ++digits_queued;
  260|      0|    if (digits_queued == kMaxSmallPowerOfTen) {
  261|      0|      MultiplyBy(kTenToNth[kMaxSmallPowerOfTen]);
  262|      0|      AddWithCarry(0, queued);
  263|      0|      queued = digits_queued = 0;
  264|      0|    }
  265|      0|  }
  266|      0|  // Encode any remaining digits.
  267|      0|  if (digits_queued) {
  268|      0|    MultiplyBy(kTenToNth[digits_queued]);
  269|      0|    AddWithCarry(0, queued);
  270|      0|  }
  271|      0|
  272|      0|  // If any insignificant digits remain, we will drop them.  But if we have not
  273|      0|  // yet read the decimal point, then we have to adjust the exponent to account
  274|      0|  // for the dropped digits.
  275|      0|  if (begin < end && !after_decimal_point) {
  276|      0|    // This call to std::find will result in a pointer either to the decimal
  277|      0|    // point, or to the end of our buffer if there was none.
  278|      0|    //
  279|      0|    // Either way, [begin, decimal_point) will contain the set of dropped digits
  280|      0|    // that require an exponent adjustment.
  281|      0|    const char* decimal_point = std::find(begin, end, '.');
  282|      0|    exponent_adjust += (decimal_point - begin);
  283|      0|  }
  284|      0|  return exponent_adjust;
  285|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE10ReadDigitsEPKcS5_i
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE10ReadDigitsEPKcS5_i
  ------------------
  286|       |
  287|       |template <int max_words>
  288|       |/* static */ BigUnsigned<max_words> BigUnsigned<max_words>::FiveToTheNth(
  289|      0|    int n) {
  290|      0|  BigUnsigned answer(1u);
  291|      0|
  292|      0|  // Seed from the table of large powers, if possible.
  293|      0|  bool first_pass = true;
  294|      0|  while (n >= kLargePowerOfFiveStep) {
  295|      0|    int big_power =
  296|      0|        std::min(n / kLargePowerOfFiveStep, kLargestPowerOfFiveIndex);
  297|      0|    if (first_pass) {
  298|      0|      // just copy, rather than multiplying by 1
  299|      0|      std::copy(
  300|      0|          LargePowerOfFiveData(big_power),
  301|      0|          LargePowerOfFiveData(big_power) + LargePowerOfFiveSize(big_power),
  302|      0|          answer.words_);
  303|      0|      answer.size_ = LargePowerOfFiveSize(big_power);
  304|      0|      first_pass = false;
  305|      0|    } else {
  306|      0|      answer.MultiplyBy(LargePowerOfFiveSize(big_power),
  307|      0|                        LargePowerOfFiveData(big_power));
  308|      0|    }
  309|      0|    n -= kLargePowerOfFiveStep * big_power;
  310|      0|  }
  311|      0|  answer.MultiplyByFiveToTheNth(n);
  312|      0|  return answer;
  313|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE12FiveToTheNthEi
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE12FiveToTheNthEi
  ------------------
  314|       |
  315|       |template <int max_words>
  316|       |void BigUnsigned<max_words>::MultiplyStep(int original_size,
  317|       |                                          const uint32_t* other_words,
  318|      0|                                          int other_size, int step) {
  319|      0|  int this_i = std::min(original_size - 1, step);
  320|      0|  int other_i = step - this_i;
  321|      0|
  322|      0|  uint64_t this_word = 0;
  323|      0|  uint64_t carry = 0;
  324|      0|  for (; this_i >= 0 && other_i < other_size; --this_i, ++other_i) {
  325|      0|    uint64_t product = words_[this_i];
  326|      0|    product *= other_words[other_i];
  327|      0|    this_word += product;
  328|      0|    carry += (this_word >> 32);
  329|      0|    this_word &= 0xffffffff;
  330|      0|  }
  331|      0|  AddWithCarry(step + 1, carry);
  332|      0|  words_[step] = this_word & 0xffffffff;
  333|      0|  if (this_word > 0 && size_ <= step) {
  334|      0|    size_ = step + 1;
  335|      0|  }
  336|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE12MultiplyStepEiPKjii
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE12MultiplyStepEiPKjii
  ------------------
  337|       |
  338|       |template <int max_words>
  339|      0|std::string BigUnsigned<max_words>::ToString() const {
  340|      0|  BigUnsigned<max_words> copy = *this;
  341|      0|  std::string result;
  342|      0|  // Build result in reverse order
  343|      0|  while (copy.size() > 0) {
  344|      0|    int next_digit = copy.DivMod<10>();
  345|      0|    result.push_back('0' + next_digit);
  346|      0|  }
  347|      0|  if (result.empty()) {
  348|      0|    result.push_back('0');
  349|      0|  }
  350|      0|  std::reverse(result.begin(), result.end());
  351|      0|  return result;
  352|      0|}
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE8ToStringEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE8ToStringEv
  ------------------
  353|       |
  354|       |template class BigUnsigned<4>;
  355|       |template class BigUnsigned<84>;
  356|       |
  357|       |}  // namespace strings_internal
  358|       |}  // inline namespace lts_2019_08_08
  359|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/charconv_bigint.h:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#ifndef ABSL_STRINGS_INTERNAL_CHARCONV_BIGINT_H_
   16|       |#define ABSL_STRINGS_INTERNAL_CHARCONV_BIGINT_H_
   17|       |
   18|       |#include <algorithm>
   19|       |#include <cstdint>
   20|       |#include <iostream>
   21|       |#include <string>
   22|       |
   23|       |#include "absl/strings/ascii.h"
   24|       |#include "absl/strings/internal/charconv_parse.h"
   25|       |#include "absl/strings/string_view.h"
   26|       |
   27|       |namespace absl {
   28|       |inline namespace lts_2019_08_08 {
   29|       |namespace strings_internal {
   30|       |
   31|       |// The largest power that 5 that can be raised to, and still fit in a uint32_t.
   32|       |constexpr int kMaxSmallPowerOfFive = 13;
   33|       |// The largest power that 10 that can be raised to, and still fit in a uint32_t.
   34|       |constexpr int kMaxSmallPowerOfTen = 9;
   35|       |
   36|       |extern const uint32_t kFiveToNth[kMaxSmallPowerOfFive + 1];
   37|       |extern const uint32_t kTenToNth[kMaxSmallPowerOfTen + 1];
   38|       |
   39|       |// Large, fixed-width unsigned integer.
   40|       |//
   41|       |// Exact rounding for decimal-to-binary floating point conversion requires very
   42|       |// large integer math, but a design goal of absl::from_chars is to avoid
   43|       |// allocating memory.  The integer precision needed for decimal-to-binary
   44|       |// conversions is large but bounded, so a huge fixed-width integer class
   45|       |// suffices.
   46|       |//
   47|       |// This is an intentionally limited big integer class.  Only needed operations
   48|       |// are implemented.  All storage lives in an array data member, and all
   49|       |// arithmetic is done in-place, to avoid requiring separate storage for operand
   50|       |// and result.
   51|       |//
   52|       |// This is an internal class.  Some methods live in the .cc file, and are
   53|       |// instantiated only for the values of max_words we need.
   54|       |template <int max_words>
   55|       |class BigUnsigned {
   56|       | public:
   57|       |  static_assert(max_words == 4 || max_words == 84,
   58|       |                "unsupported max_words value");
   59|       |
   60|      0|  BigUnsigned() : size_(0), words_{} {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EEC2Ev
  ------------------
   61|       |  explicit constexpr BigUnsigned(uint64_t v)
   62|       |      : size_((v >> 32) ? 2 : v ? 1 : 0),
   63|       |        words_{static_cast<uint32_t>(v & 0xffffffffu),
   64|      0|               static_cast<uint32_t>(v >> 32)} {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EEC2Ey
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EEC2Ey
  ------------------
   65|       |
   66|       |  // Constructs a BigUnsigned from the given string_view containing a decimal
   67|       |  // value.  If the input std::string is not a decimal integer, constructs a 0
   68|       |  // instead.
   69|      0|  explicit BigUnsigned(absl::string_view sv) : size_(0), words_{} {
   70|      0|    // Check for valid input, returning a 0 otherwise.  This is reasonable
   71|      0|    // behavior only because this constructor is for unit tests.
   72|      0|    if (std::find_if_not(sv.begin(), sv.end(), ascii_isdigit) != sv.end() ||
   73|      0|        sv.empty()) {
   74|      0|      return;
   75|      0|    }
   76|      0|    int exponent_adjust =
   77|      0|        ReadDigits(sv.data(), sv.data() + sv.size(), Digits10() + 1);
   78|      0|    if (exponent_adjust > 0) {
   79|      0|      MultiplyByTenToTheNth(exponent_adjust);
   80|      0|    }
   81|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EEC2ENS0_11string_viewE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EEC2ENS0_11string_viewE
  ------------------
   82|       |
   83|       |  // Loads the mantissa value of a previously-parsed float.
   84|       |  //
   85|       |  // Returns the associated decimal exponent.  The value of the parsed float is
   86|       |  // exactly *this * 10**exponent.
   87|       |  int ReadFloatMantissa(const ParsedFloat& fp, int significant_digits);
   88|       |
   89|       |  // Returns the number of decimal digits of precision this type provides.  All
   90|       |  // numbers with this many decimal digits or fewer are representable by this
   91|       |  // type.
   92|       |  //
   93|       |  // Analagous to std::numeric_limits<BigUnsigned>::digits10.
   94|      0|  static constexpr int Digits10() {
   95|      0|    // 9975007/1035508 is very slightly less than log10(2**32).
   96|      0|    return static_cast<uint64_t>(max_words) * 9975007 / 1035508;
   97|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE8Digits10Ev
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE8Digits10Ev
  ------------------
   98|       |
   99|       |  // Shifts left by the given number of bits.
  100|      0|  void ShiftLeft(int count) {
  101|      0|    if (count > 0) {
  102|      0|      const int word_shift = count / 32;
  103|      0|      if (word_shift >= max_words) {
  104|      0|        SetToZero();
  105|      0|        return;
  106|      0|      }
  107|      0|      size_ = (std::min)(size_ + word_shift, max_words);
  108|      0|      count %= 32;
  109|      0|      if (count == 0) {
  110|      0|        std::copy_backward(words_, words_ + size_ - word_shift, words_ + size_);
  111|      0|      } else {
  112|      0|        for (int i = (std::min)(size_, max_words - 1); i > word_shift; --i) {
  113|      0|          words_[i] = (words_[i - word_shift] << count) |
  114|      0|                      (words_[i - word_shift - 1] >> (32 - count));
  115|      0|        }
  116|      0|        words_[word_shift] = words_[0] << count;
  117|      0|        // Grow size_ if necessary.
  118|      0|        if (size_ < max_words && words_[size_]) {
  119|      0|          ++size_;
  120|      0|        }
  121|      0|      }
  122|      0|      std::fill(words_, words_ + word_shift, 0u);
  123|      0|    }
  124|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE9ShiftLeftEi
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE9ShiftLeftEi
  ------------------
  125|       |
  126|       |
  127|       |  // Multiplies by v in-place.
  128|      0|  void MultiplyBy(uint32_t v) {
  129|      0|    if (size_ == 0 || v == 1) {
  130|      0|      return;
  131|      0|    }
  132|      0|    if (v == 0) {
  133|      0|      SetToZero();
  134|      0|      return;
  135|      0|    }
  136|      0|    const uint64_t factor = v;
  137|      0|    uint64_t window = 0;
  138|      0|    for (int i = 0; i < size_; ++i) {
  139|      0|      window += factor * words_[i];
  140|      0|      words_[i] = window & 0xffffffff;
  141|      0|      window >>= 32;
  142|      0|    }
  143|      0|    // If carry bits remain and there's space for them, grow size_.
  144|      0|    if (window && size_ < max_words) {
  145|      0|      words_[size_] = window & 0xffffffff;
  146|      0|      ++size_;
  147|      0|    }
  148|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE10MultiplyByEj
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE10MultiplyByEj
  ------------------
  149|       |
  150|      0|  void MultiplyBy(uint64_t v) {
  151|      0|    uint32_t words[2];
  152|      0|    words[0] = static_cast<uint32_t>(v);
  153|      0|    words[1] = static_cast<uint32_t>(v >> 32);
  154|      0|    if (words[1] == 0) {
  155|      0|      MultiplyBy(words[0]);
  156|      0|    } else {
  157|      0|      MultiplyBy(2, words);
  158|      0|    }
  159|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE10MultiplyByEy
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE10MultiplyByEy
  ------------------
  160|       |
  161|       |  // Multiplies in place by 5 to the power of n.  n must be non-negative.
  162|      0|  void MultiplyByFiveToTheNth(int n) {
  163|      0|    while (n >= kMaxSmallPowerOfFive) {
  164|      0|      MultiplyBy(kFiveToNth[kMaxSmallPowerOfFive]);
  165|      0|      n -= kMaxSmallPowerOfFive;
  166|      0|    }
  167|      0|    if (n > 0) {
  168|      0|      MultiplyBy(kFiveToNth[n]);
  169|      0|    }
  170|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE22MultiplyByFiveToTheNthEi
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE22MultiplyByFiveToTheNthEi
  ------------------
  171|       |
  172|       |  // Multiplies in place by 10 to the power of n.  n must be non-negative.
  173|      0|  void MultiplyByTenToTheNth(int n) {
  174|      0|    if (n > kMaxSmallPowerOfTen) {
  175|      0|      // For large n, raise to a power of 5, then shift left by the same amount.
  176|      0|      // (10**n == 5**n * 2**n.)  This requires fewer multiplications overall.
  177|      0|      MultiplyByFiveToTheNth(n);
  178|      0|      ShiftLeft(n);
  179|      0|    } else if (n > 0) {
  180|      0|      // We can do this more quickly for very small N by using a single
  181|      0|      // multiplication.
  182|      0|      MultiplyBy(kTenToNth[n]);
  183|      0|    }
  184|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE21MultiplyByTenToTheNthEi
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE21MultiplyByTenToTheNthEi
  ------------------
  185|       |
  186|       |  // Returns the value of 5**n, for non-negative n.  This implementation uses
  187|       |  // a lookup table, and is faster then seeding a BigUnsigned with 1 and calling
  188|       |  // MultiplyByFiveToTheNth().
  189|       |  static BigUnsigned FiveToTheNth(int n);
  190|       |
  191|       |  // Multiplies by another BigUnsigned, in-place.
  192|       |  template <int M>
  193|       |  void MultiplyBy(const BigUnsigned<M>& other) {
  194|       |    MultiplyBy(other.size(), other.words());
  195|       |  }
  196|       |
  197|      0|  void SetToZero() {
  198|      0|    std::fill(words_, words_ + size_, 0u);
  199|      0|    size_ = 0;
  200|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE9SetToZeroEv
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE9SetToZeroEv
  ------------------
  201|       |
  202|       |  // Returns the value of the nth word of this BigUnsigned.  This is
  203|       |  // range-checked, and returns 0 on out-of-bounds accesses.
  204|      0|  uint32_t GetWord(int index) const {
  205|      0|    if (index < 0 || index >= size_) {
  206|      0|      return 0;
  207|      0|    }
  208|      0|    return words_[index];
  209|      0|  }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE7GetWordEi
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE7GetWordEi
  ------------------
  210|       |
  211|       |  // Returns this integer as a decimal std::string.  This is not used in the decimal-
  212|       |  // to-binary conversion; it is intended to aid in testing.
  213|       |  std::string ToString() const;
  214|       |
  215|      0|  int size() const { return size_; }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE4sizeEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE4sizeEv
  ------------------
  216|      0|  const uint32_t* words() const { return words_; }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE5wordsEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE5wordsEv
  ------------------
  217|       |
  218|       | private:
  219|       |  // Reads the number between [begin, end), possibly containing a decimal point,
  220|       |  // into this BigUnsigned.
  221|       |  //
  222|       |  // Callers are required to ensure [begin, end) contains a valid number, with
  223|       |  // one or more decimal digits and at most one decimal point.  This routine
  224|       |  // will behave unpredictably if these preconditions are not met.
  225|       |  //
  226|       |  // Only the first `significant_digits` digits are read.  Digits beyond this
  227|       |  // limit are "sticky": If the final significant digit is 0 or 5, and if any
  228|       |  // dropped digit is nonzero, then that final significant digit is adjusted up
  229|       |  // to 1 or 6.  This adjustment allows for precise rounding.
  230|       |  //
  231|       |  // Returns `exponent_adjustment`, a power-of-ten exponent adjustment to
  232|       |  // account for the decimal point and for dropped significant digits.  After
  233|       |  // this function returns,
  234|       |  //   actual_value_of_parsed_string ~= *this * 10**exponent_adjustment.
  235|       |  int ReadDigits(const char* begin, const char* end, int significant_digits);
  236|       |
  237|       |  // Performs a step of big integer multiplication.  This computes the full
  238|       |  // (64-bit-wide) values that should be added at the given index (step), and
  239|       |  // adds to that location in-place.
  240|       |  //
  241|       |  // Because our math all occurs in place, we must multiply starting from the
  242|       |  // highest word working downward.  (This is a bit more expensive due to the
  243|       |  // extra carries involved.)
  244|       |  //
  245|       |  // This must be called in steps, for each word to be calculated, starting from
  246|       |  // the high end and working down to 0.  The first value of `step` should be
  247|       |  //   `std::min(original_size + other.size_ - 2, max_words - 1)`.
  248|       |  // The reason for this expression is that multiplying the i'th word from one
  249|       |  // multiplicand and the j'th word of another multiplicand creates a
  250|       |  // two-word-wide value to be stored at the (i+j)'th element.  The highest
  251|       |  // word indices we will access are `original_size - 1` from this object, and
  252|       |  // `other.size_ - 1` from our operand.  Therefore,
  253|       |  // `original_size + other.size_ - 2` is the first step we should calculate,
  254|       |  // but limited on an upper bound by max_words.
  255|       |
  256|       |  // Working from high-to-low ensures that we do not overwrite the portions of
  257|       |  // the initial value of *this which are still needed for later steps.
  258|       |  //
  259|       |  // Once called with step == 0, *this contains the result of the
  260|       |  // multiplication.
  261|       |  //
  262|       |  // `original_size` is the size_ of *this before the first call to
  263|       |  // MultiplyStep().  `other_words` and `other_size` are the contents of our
  264|       |  // operand.  `step` is the step to perform, as described above.
  265|       |  void MultiplyStep(int original_size, const uint32_t* other_words,
  266|       |                    int other_size, int step);
  267|       |
  268|      0|  void MultiplyBy(int other_size, const uint32_t* other_words) {
  269|      0|    const int original_size = size_;
  270|      0|    const int first_step =
  271|      0|        (std::min)(original_size + other_size - 2, max_words - 1);
  272|      0|    for (int step = first_step; step >= 0; --step) {
  273|      0|      MultiplyStep(original_size, other_words, other_size, step);
  274|      0|    }
  275|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE10MultiplyByEiPKj
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE10MultiplyByEiPKj
  ------------------
  276|       |
  277|       |  // Adds a 32-bit value to the index'th word, with carry.
  278|      0|  void AddWithCarry(int index, uint32_t value) {
  279|      0|    if (value) {
  280|      0|      while (index < max_words && value > 0) {
  281|      0|        words_[index] += value;
  282|      0|        // carry if we overflowed in this word:
  283|      0|        if (value > words_[index]) {
  284|      0|          value = 1;
  285|      0|          ++index;
  286|      0|        } else {
  287|      0|          value = 0;
  288|      0|        }
  289|      0|      }
  290|      0|      size_ = (std::min)(max_words, (std::max)(index + 1, size_));
  291|      0|    }
  292|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE12AddWithCarryEij
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE12AddWithCarryEij
  ------------------
  293|       |
  294|      0|  void AddWithCarry(int index, uint64_t value) {
  295|      0|    if (value && index < max_words) {
  296|      0|      uint32_t high = value >> 32;
  297|      0|      uint32_t low = value & 0xffffffff;
  298|      0|      words_[index] += low;
  299|      0|      if (words_[index] < low) {
  300|      0|        ++high;
  301|      0|        if (high == 0) {
  302|      0|          // Carry from the low word caused our high word to overflow.
  303|      0|          // Short circuit here to do the right thing.
  304|      0|          AddWithCarry(index + 2, static_cast<uint32_t>(1));
  305|      0|          return;
  306|      0|        }
  307|      0|      }
  308|      0|      if (high > 0) {
  309|      0|        AddWithCarry(index + 1, high);
  310|      0|      } else {
  311|      0|        // Normally 32-bit AddWithCarry() sets size_, but since we don't call
  312|      0|        // it when `high` is 0, do it ourselves here.
  313|      0|        size_ = (std::min)(max_words, (std::max)(index + 1, size_));
  314|      0|      }
  315|      0|    }
  316|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE12AddWithCarryEiy
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE12AddWithCarryEiy
  ------------------
  317|       |
  318|       |  // Divide this in place by a constant divisor.  Returns the remainder of the
  319|       |  // division.
  320|       |  template <uint32_t divisor>
  321|      0|  uint32_t DivMod() {
  322|      0|    uint64_t accumulator = 0;
  323|      0|    for (int i = size_ - 1; i >= 0; --i) {
  324|      0|      accumulator <<= 32;
  325|      0|      accumulator += words_[i];
  326|      0|      // accumulator / divisor will never overflow an int32_t in this loop
  327|      0|      words_[i] = static_cast<uint32_t>(accumulator / divisor);
  328|      0|      accumulator = accumulator % divisor;
  329|      0|    }
  330|      0|    while (size_ > 0 && words_[size_ - 1] == 0) {
  331|      0|      --size_;
  332|      0|    }
  333|      0|    return static_cast<uint32_t>(accumulator);
  334|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi4EE6DivModILj10EEEjv
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal11BigUnsignedILi84EE6DivModILj10EEEjv
  ------------------
  335|       |
  336|       |  // The number of elements in words_ that may carry significant values.
  337|       |  // All elements beyond this point are 0.
  338|       |  //
  339|       |  // When size_ is 0, this BigUnsigned stores the value 0.
  340|       |  // When size_ is nonzero, is *not* guaranteed that words_[size_ - 1] is
  341|       |  // nonzero.  This can occur due to overflow truncation.
  342|       |  // In particular, x.size_ != y.size_ does *not* imply x != y.
  343|       |  int size_;
  344|       |  uint32_t words_[max_words];
  345|       |};
  346|       |
  347|       |// Compares two big integer instances.
  348|       |//
  349|       |// Returns -1 if lhs < rhs, 0 if lhs == rhs, and 1 if lhs > rhs.
  350|       |template <int N, int M>
  351|      0|int Compare(const BigUnsigned<N>& lhs, const BigUnsigned<M>& rhs) {
  352|      0|  int limit = (std::max)(lhs.size(), rhs.size());
  353|      0|  for (int i = limit - 1; i >= 0; --i) {
  354|      0|    const uint32_t lhs_word = lhs.GetWord(i);
  355|      0|    const uint32_t rhs_word = rhs.GetWord(i);
  356|      0|    if (lhs_word < rhs_word) {
  357|      0|      return -1;
  358|      0|    } else if (lhs_word > rhs_word) {
  359|      0|      return 1;
  360|      0|    }
  361|      0|  }
  362|      0|  return 0;
  363|      0|}
  364|       |
  365|       |template <int N, int M>
  366|       |bool operator==(const BigUnsigned<N>& lhs, const BigUnsigned<M>& rhs) {
  367|       |  int limit = (std::max)(lhs.size(), rhs.size());
  368|       |  for (int i = 0; i < limit; ++i) {
  369|       |    if (lhs.GetWord(i) != rhs.GetWord(i)) {
  370|       |      return false;
  371|       |    }
  372|       |  }
  373|       |  return true;
  374|       |}
  375|       |
  376|       |template <int N, int M>
  377|       |bool operator!=(const BigUnsigned<N>& lhs, const BigUnsigned<M>& rhs) {
  378|       |  return !(lhs == rhs);
  379|       |}
  380|       |
  381|       |template <int N, int M>
  382|       |bool operator<(const BigUnsigned<N>& lhs, const BigUnsigned<M>& rhs) {
  383|       |  return Compare(lhs, rhs) == -1;
  384|       |}
  385|       |
  386|       |template <int N, int M>
  387|       |bool operator>(const BigUnsigned<N>& lhs, const BigUnsigned<M>& rhs) {
  388|       |  return rhs < lhs;
  389|       |}
  390|       |template <int N, int M>
  391|       |bool operator<=(const BigUnsigned<N>& lhs, const BigUnsigned<M>& rhs) {
  392|       |  return !(rhs < lhs);
  393|       |}
  394|       |template <int N, int M>
  395|       |bool operator>=(const BigUnsigned<N>& lhs, const BigUnsigned<M>& rhs) {
  396|       |  return !(lhs < rhs);
  397|       |}
  398|       |
  399|       |// Output operator for BigUnsigned, for testing purposes only.
  400|       |template <int N>
  401|       |std::ostream& operator<<(std::ostream& os, const BigUnsigned<N>& num) {
  402|       |  return os << num.ToString();
  403|       |}
  404|       |
  405|       |// Explicit instantiation declarations for the sizes of BigUnsigned that we
  406|       |// are using.
  407|       |//
  408|       |// For now, the choices of 4 and 84 are arbitrary; 4 is a small value that is
  409|       |// still bigger than an int128, and 84 is a large value we will want to use
  410|       |// in the from_chars implementation.
  411|       |//
  412|       |// Comments justifying the use of 84 belong in the from_chars implementation,
  413|       |// and will be added in a follow-up CL.
  414|       |extern template class BigUnsigned<4>;
  415|       |extern template class BigUnsigned<84>;
  416|       |
  417|       |}  // namespace strings_internal
  418|       |}  // inline namespace lts_2019_08_08
  419|       |}  // namespace absl
  420|       |
  421|       |#endif  // ABSL_STRINGS_INTERNAL_CHARCONV_BIGINT_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/charconv_parse.cc:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/internal/charconv_parse.h"
   16|       |#include "absl/strings/charconv.h"
   17|       |
   18|       |#include <cassert>
   19|       |#include <cstdint>
   20|       |#include <limits>
   21|       |
   22|       |#include "absl/strings/internal/memutil.h"
   23|       |
   24|       |namespace absl {
   25|       |inline namespace lts_2019_08_08 {
   26|       |namespace {
   27|       |
   28|       |// ParseFloat<10> will read the first 19 significant digits of the mantissa.
   29|       |// This number was chosen for multiple reasons.
   30|       |//
   31|       |// (a) First, for whatever integer type we choose to represent the mantissa, we
   32|       |// want to choose the largest possible number of decimal digits for that integer
   33|       |// type.  We are using uint64_t, which can express any 19-digit unsigned
   34|       |// integer.
   35|       |//
   36|       |// (b) Second, we need to parse enough digits that the binary value of any
   37|       |// mantissa we capture has more bits of resolution than the mantissa
   38|       |// representation in the target float.  Our algorithm requires at least 3 bits
   39|       |// of headway, but 19 decimal digits give a little more than that.
   40|       |//
   41|       |// The following static assertions verify the above comments:
   42|       |constexpr int kDecimalMantissaDigitsMax = 19;
   43|       |
   44|       |static_assert(std::numeric_limits<uint64_t>::digits10 ==
   45|       |                  kDecimalMantissaDigitsMax,
   46|       |              "(a) above");
   47|       |
   48|       |// IEEE doubles, which we assume in Abseil, have 53 binary bits of mantissa.
   49|       |static_assert(std::numeric_limits<double>::is_iec559, "IEEE double assumed");
   50|       |static_assert(std::numeric_limits<double>::radix == 2, "IEEE double fact");
   51|       |static_assert(std::numeric_limits<double>::digits == 53, "IEEE double fact");
   52|       |
   53|       |// The lowest valued 19-digit decimal mantissa we can read still contains
   54|       |// sufficient information to reconstruct a binary mantissa.
   55|       |static_assert(1000000000000000000u > (uint64_t(1) << (53 + 3)), "(b) above");
   56|       |
   57|       |// ParseFloat<16> will read the first 15 significant digits of the mantissa.
   58|       |//
   59|       |// Because a base-16-to-base-2 conversion can be done exactly, we do not need
   60|       |// to maximize the number of scanned hex digits to improve our conversion.  What
   61|       |// is required is to scan two more bits than the mantissa can represent, so that
   62|       |// we always round correctly.
   63|       |//
   64|       |// (One extra bit does not suffice to perform correct rounding, since a number
   65|       |// exactly halfway between two representable floats has unique rounding rules,
   66|       |// so we need to differentiate between a "halfway between" number and a "closer
   67|       |// to the larger value" number.)
   68|       |constexpr int kHexadecimalMantissaDigitsMax = 15;
   69|       |
   70|       |// The minimum number of significant bits that will be read from
   71|       |// kHexadecimalMantissaDigitsMax hex digits.  We must subtract by three, since
   72|       |// the most significant digit can be a "1", which only contributes a single
   73|       |// significant bit.
   74|       |constexpr int kGuaranteedHexadecimalMantissaBitPrecision =
   75|       |    4 * kHexadecimalMantissaDigitsMax - 3;
   76|       |
   77|       |static_assert(kGuaranteedHexadecimalMantissaBitPrecision >
   78|       |                  std::numeric_limits<double>::digits + 2,
   79|       |              "kHexadecimalMantissaDigitsMax too small");
   80|       |
   81|       |// We also impose a limit on the number of significant digits we will read from
   82|       |// an exponent, to avoid having to deal with integer overflow.  We use 9 for
   83|       |// this purpose.
   84|       |//
   85|       |// If we read a 9 digit exponent, the end result of the conversion will
   86|       |// necessarily be infinity or zero, depending on the sign of the exponent.
   87|       |// Therefore we can just drop extra digits on the floor without any extra
   88|       |// logic.
   89|       |constexpr int kDecimalExponentDigitsMax = 9;
   90|       |static_assert(std::numeric_limits<int>::digits10 >= kDecimalExponentDigitsMax,
   91|       |              "int type too small");
   92|       |
   93|       |// To avoid incredibly large inputs causing integer overflow for our exponent,
   94|       |// we impose an arbitrary but very large limit on the number of significant
   95|       |// digits we will accept.  The implementation refuses to match a string with
   96|       |// more consecutive significant mantissa digits than this.
   97|       |constexpr int kDecimalDigitLimit = 50000000;
   98|       |
   99|       |// Corresponding limit for hexadecimal digit inputs.  This is one fourth the
  100|       |// amount of kDecimalDigitLimit, since each dropped hexadecimal digit requires
  101|       |// a binary exponent adjustment of 4.
  102|       |constexpr int kHexadecimalDigitLimit = kDecimalDigitLimit / 4;
  103|       |
  104|       |// The largest exponent we can read is 999999999 (per
  105|       |// kDecimalExponentDigitsMax), and the largest exponent adjustment we can get
  106|       |// from dropped mantissa digits is 2 * kDecimalDigitLimit, and the sum of these
  107|       |// comfortably fits in an integer.
  108|       |//
  109|       |// We count kDecimalDigitLimit twice because there are independent limits for
  110|       |// numbers before and after the decimal point.  (In the case where there are no
  111|       |// significant digits before the decimal point, there are independent limits for
  112|       |// post-decimal-point leading zeroes and for significant digits.)
  113|       |static_assert(999999999 + 2 * kDecimalDigitLimit <
  114|       |                  std::numeric_limits<int>::max(),
  115|       |              "int type too small");
  116|       |static_assert(999999999 + 2 * (4 * kHexadecimalDigitLimit) <
  117|       |                  std::numeric_limits<int>::max(),
  118|       |              "int type too small");
  119|       |
  120|       |// Returns true if the provided bitfield allows parsing an exponent value
  121|       |// (e.g., "1.5e100").
  122|      0|bool AllowExponent(chars_format flags) {
  123|      0|  bool fixed = (flags & chars_format::fixed) == chars_format::fixed;
  124|      0|  bool scientific =
  125|      0|      (flags & chars_format::scientific) == chars_format::scientific;
  126|      0|  return scientific || !fixed;
  127|      0|}
  128|       |
  129|       |// Returns true if the provided bitfield requires an exponent value be present.
  130|      0|bool RequireExponent(chars_format flags) {
  131|      0|  bool fixed = (flags & chars_format::fixed) == chars_format::fixed;
  132|      0|  bool scientific =
  133|      0|      (flags & chars_format::scientific) == chars_format::scientific;
  134|      0|  return scientific && !fixed;
  135|      0|}
  136|       |
  137|       |const int8_t kAsciiToInt[256] = {
  138|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  139|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  140|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0,  1,  2,  3,  4,  5,  6,  7,  8,
  141|       |    9,  -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1,
  142|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  143|       |    -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  144|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  145|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  146|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  147|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  148|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  149|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  150|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  151|       |    -1, -1, -1, -1, -1, -1, -1, -1, -1};
  152|       |
  153|       |// Returns true if `ch` is a digit in the given base
  154|       |template <int base>
  155|       |bool IsDigit(char ch);
  156|       |
  157|       |// Converts a valid `ch` to its digit value in the given base.
  158|       |template <int base>
  159|       |unsigned ToDigit(char ch);
  160|       |
  161|       |// Returns true if `ch` is the exponent delimiter for the given base.
  162|       |template <int base>
  163|       |bool IsExponentCharacter(char ch);
  164|       |
  165|       |// Returns the maximum number of significant digits we will read for a float
  166|       |// in the given base.
  167|       |template <int base>
  168|       |constexpr int MantissaDigitsMax();
  169|       |
  170|       |// Returns the largest consecutive run of digits we will accept when parsing a
  171|       |// number in the given base.
  172|       |template <int base>
  173|       |constexpr int DigitLimit();
  174|       |
  175|       |// Returns the amount the exponent must be adjusted by for each dropped digit.
  176|       |// (For decimal this is 1, since the digits are in base 10 and the exponent base
  177|       |// is also 10, but for hexadecimal this is 4, since the digits are base 16 but
  178|       |// the exponent base is 2.)
  179|       |template <int base>
  180|       |constexpr int DigitMagnitude();
  181|       |
  182|       |template <>
  183|      0|bool IsDigit<10>(char ch) {
  184|      0|  return ch >= '0' && ch <= '9';
  185|      0|}
  186|       |template <>
  187|      0|bool IsDigit<16>(char ch) {
  188|      0|  return kAsciiToInt[static_cast<unsigned char>(ch)] >= 0;
  189|      0|}
  190|       |
  191|       |template <>
  192|      0|unsigned ToDigit<10>(char ch) {
  193|      0|  return ch - '0';
  194|      0|}
  195|       |template <>
  196|      0|unsigned ToDigit<16>(char ch) {
  197|      0|  return kAsciiToInt[static_cast<unsigned char>(ch)];
  198|      0|}
  199|       |
  200|       |template <>
  201|      0|bool IsExponentCharacter<10>(char ch) {
  202|      0|  return ch == 'e' || ch == 'E';
  203|      0|}
  204|       |
  205|       |template <>
  206|      0|bool IsExponentCharacter<16>(char ch) {
  207|      0|  return ch == 'p' || ch == 'P';
  208|      0|}
  209|       |
  210|       |template <>
  211|      0|constexpr int MantissaDigitsMax<10>() {
  212|      0|  return kDecimalMantissaDigitsMax;
  213|      0|}
  214|       |template <>
  215|      0|constexpr int MantissaDigitsMax<16>() {
  216|      0|  return kHexadecimalMantissaDigitsMax;
  217|      0|}
  218|       |
  219|       |template <>
  220|      0|constexpr int DigitLimit<10>() {
  221|      0|  return kDecimalDigitLimit;
  222|      0|}
  223|       |template <>
  224|      0|constexpr int DigitLimit<16>() {
  225|      0|  return kHexadecimalDigitLimit;
  226|      0|}
  227|       |
  228|       |template <>
  229|      0|constexpr int DigitMagnitude<10>() {
  230|      0|  return 1;
  231|      0|}
  232|       |template <>
  233|      0|constexpr int DigitMagnitude<16>() {
  234|      0|  return 4;
  235|      0|}
  236|       |
  237|       |// Reads decimal digits from [begin, end) into *out.  Returns the number of
  238|       |// digits consumed.
  239|       |//
  240|       |// After max_digits has been read, keeps consuming characters, but no longer
  241|       |// adjusts *out.  If a nonzero digit is dropped this way, *dropped_nonzero_digit
  242|       |// is set; otherwise, it is left unmodified.
  243|       |//
  244|       |// If no digits are matched, returns 0 and leaves *out unchanged.
  245|       |//
  246|       |// ConsumeDigits does not protect against overflow on *out; max_digits must
  247|       |// be chosen with respect to type T to avoid the possibility of overflow.
  248|       |template <int base, typename T>
  249|       |std::size_t ConsumeDigits(const char* begin, const char* end, int max_digits,
  250|      0|                          T* out, bool* dropped_nonzero_digit) {
  251|      0|  if (base == 10) {
  252|      0|    assert(max_digits <= std::numeric_limits<T>::digits10);
  253|      0|  } else if (base == 16) {
  254|      0|    assert(max_digits * 4 <= std::numeric_limits<T>::digits);
  255|      0|  }
  256|      0|  const char* const original_begin = begin;
  257|      0|  T accumulator = *out;
  258|      0|  const char* significant_digits_end =
  259|      0|      (end - begin > max_digits) ? begin + max_digits : end;
  260|      0|  while (begin < significant_digits_end && IsDigit<base>(*begin)) {
  261|      0|    // Do not guard against *out overflow; max_digits was chosen to avoid this.
  262|      0|    // Do assert against it, to detect problems in debug builds.
  263|      0|    auto digit = static_cast<T>(ToDigit<base>(*begin));
  264|      0|    assert(accumulator * base >= accumulator);
  265|      0|    accumulator *= base;
  266|      0|    assert(accumulator + digit >= accumulator);
  267|      0|    accumulator += digit;
  268|      0|    ++begin;
  269|      0|  }
  270|      0|  bool dropped_nonzero = false;
  271|      0|  while (begin < end && IsDigit<base>(*begin)) {
  272|      0|    dropped_nonzero = dropped_nonzero || (*begin != '0');
  273|      0|    ++begin;
  274|      0|  }
  275|      0|  if (dropped_nonzero && dropped_nonzero_digit != nullptr) {
  276|      0|    *dropped_nonzero_digit = true;
  277|      0|  }
  278|      0|  *out = accumulator;
  279|      0|  return begin - original_begin;
  280|      0|}
  ------------------
  | Unexecuted instantiation: charconv_parse.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_113ConsumeDigitsILi10EyEEmPKcS4_iPT0_Pb
  ------------------
  | Unexecuted instantiation: charconv_parse.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_113ConsumeDigitsILi10EiEEmPKcS4_iPT0_Pb
  ------------------
  | Unexecuted instantiation: charconv_parse.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_113ConsumeDigitsILi16EyEEmPKcS4_iPT0_Pb
  ------------------
  281|       |
  282|       |// Returns true if `v` is one of the chars allowed inside parentheses following
  283|       |// a NaN.
  284|      0|bool IsNanChar(char v) {
  285|      0|  return (v == '_') || (v >= '0' && v <= '9') || (v >= 'a' && v <= 'z') ||
  286|      0|         (v >= 'A' && v <= 'Z');
  287|      0|}
  288|       |
  289|       |// Checks the range [begin, end) for a strtod()-formatted infinity or NaN.  If
  290|       |// one is found, sets `out` appropriately and returns true.
  291|       |bool ParseInfinityOrNan(const char* begin, const char* end,
  292|      0|                        strings_internal::ParsedFloat* out) {
  293|      0|  if (end - begin < 3) {
  294|      0|    return false;
  295|      0|  }
  296|      0|  switch (*begin) {
  297|      0|    case 'i':
  298|      0|    case 'I': {
  299|      0|      // An infinity std::string consists of the characters "inf" or "infinity",
  300|      0|      // case insensitive.
  301|      0|      if (strings_internal::memcasecmp(begin + 1, "nf", 2) != 0) {
  302|      0|        return false;
  303|      0|      }
  304|      0|      out->type = strings_internal::FloatType::kInfinity;
  305|      0|      if (end - begin >= 8 &&
  306|      0|          strings_internal::memcasecmp(begin + 3, "inity", 5) == 0) {
  307|      0|        out->end = begin + 8;
  308|      0|      } else {
  309|      0|        out->end = begin + 3;
  310|      0|      }
  311|      0|      return true;
  312|      0|    }
  313|      0|    case 'n':
  314|      0|    case 'N': {
  315|      0|      // A NaN consists of the characters "nan", case insensitive, optionally
  316|      0|      // followed by a parenthesized sequence of zero or more alphanumeric
  317|      0|      // characters and/or underscores.
  318|      0|      if (strings_internal::memcasecmp(begin + 1, "an", 2) != 0) {
  319|      0|        return false;
  320|      0|      }
  321|      0|      out->type = strings_internal::FloatType::kNan;
  322|      0|      out->end = begin + 3;
  323|      0|      // NaN is allowed to be followed by a parenthesized std::string, consisting of
  324|      0|      // only the characters [a-zA-Z0-9_].  Match that if it's present.
  325|      0|      begin += 3;
  326|      0|      if (begin < end && *begin == '(') {
  327|      0|        const char* nan_begin = begin + 1;
  328|      0|        while (nan_begin < end && IsNanChar(*nan_begin)) {
  329|      0|          ++nan_begin;
  330|      0|        }
  331|      0|        if (nan_begin < end && *nan_begin == ')') {
  332|      0|          // We found an extra NaN specifier range
  333|      0|          out->subrange_begin = begin + 1;
  334|      0|          out->subrange_end = nan_begin;
  335|      0|          out->end = nan_begin + 1;
  336|      0|        }
  337|      0|      }
  338|      0|      return true;
  339|      0|    }
  340|      0|    default:
  341|      0|      return false;
  342|      0|  }
  343|      0|}
  344|       |}  // namespace
  345|       |
  346|       |namespace strings_internal {
  347|       |
  348|       |template <int base>
  349|       |strings_internal::ParsedFloat ParseFloat(const char* begin, const char* end,
  350|      0|                                         chars_format format_flags) {
  351|      0|  strings_internal::ParsedFloat result;
  352|      0|
  353|      0|  // Exit early if we're given an empty range.
  354|      0|  if (begin == end) return result;
  355|      0|
  356|      0|  // Handle the infinity and NaN cases.
  357|      0|  if (ParseInfinityOrNan(begin, end, &result)) {
  358|      0|    return result;
  359|      0|  }
  360|      0|
  361|      0|  const char* const mantissa_begin = begin;
  362|      0|  while (begin < end && *begin == '0') {
  363|      0|    ++begin;  // skip leading zeros
  364|      0|  }
  365|      0|  uint64_t mantissa = 0;
  366|      0|
  367|      0|  int exponent_adjustment = 0;
  368|      0|  bool mantissa_is_inexact = false;
  369|      0|  std::size_t pre_decimal_digits = ConsumeDigits<base>(
  370|      0|      begin, end, MantissaDigitsMax<base>(), &mantissa, &mantissa_is_inexact);
  371|      0|  begin += pre_decimal_digits;
  372|      0|  int digits_left;
  373|      0|  if (pre_decimal_digits >= DigitLimit<base>()) {
  374|      0|    // refuse to parse pathological inputs
  375|      0|    return result;
  376|      0|  } else if (pre_decimal_digits > MantissaDigitsMax<base>()) {
  377|      0|    // We dropped some non-fraction digits on the floor.  Adjust our exponent
  378|      0|    // to compensate.
  379|      0|    exponent_adjustment =
  380|      0|        static_cast<int>(pre_decimal_digits - MantissaDigitsMax<base>());
  381|      0|    digits_left = 0;
  382|      0|  } else {
  383|      0|    digits_left =
  384|      0|        static_cast<int>(MantissaDigitsMax<base>() - pre_decimal_digits);
  385|      0|  }
  386|      0|  if (begin < end && *begin == '.') {
  387|      0|    ++begin;
  388|      0|    if (mantissa == 0) {
  389|      0|      // If we haven't seen any nonzero digits yet, keep skipping zeros.  We
  390|      0|      // have to adjust the exponent to reflect the changed place value.
  391|      0|      const char* begin_zeros = begin;
  392|      0|      while (begin < end && *begin == '0') {
  393|      0|        ++begin;
  394|      0|      }
  395|      0|      std::size_t zeros_skipped = begin - begin_zeros;
  396|      0|      if (zeros_skipped >= DigitLimit<base>()) {
  397|      0|        // refuse to parse pathological inputs
  398|      0|        return result;
  399|      0|      }
  400|      0|      exponent_adjustment -= static_cast<int>(zeros_skipped);
  401|      0|    }
  402|      0|    std::size_t post_decimal_digits = ConsumeDigits<base>(
  403|      0|        begin, end, digits_left, &mantissa, &mantissa_is_inexact);
  404|      0|    begin += post_decimal_digits;
  405|      0|
  406|      0|    // Since `mantissa` is an integer, each significant digit we read after
  407|      0|    // the decimal point requires an adjustment to the exponent. "1.23e0" will
  408|      0|    // be stored as `mantissa` == 123 and `exponent` == -2 (that is,
  409|      0|    // "123e-2").
  410|      0|    if (post_decimal_digits >= DigitLimit<base>()) {
  411|      0|      // refuse to parse pathological inputs
  412|      0|      return result;
  413|      0|    } else if (post_decimal_digits > digits_left) {
  414|      0|      exponent_adjustment -= digits_left;
  415|      0|    } else {
  416|      0|      exponent_adjustment -= post_decimal_digits;
  417|      0|    }
  418|      0|  }
  419|      0|  // If we've found no mantissa whatsoever, this isn't a number.
  420|      0|  if (mantissa_begin == begin) {
  421|      0|    return result;
  422|      0|  }
  423|      0|  // A bare "." doesn't count as a mantissa either.
  424|      0|  if (begin - mantissa_begin == 1 && *mantissa_begin == '.') {
  425|      0|    return result;
  426|      0|  }
  427|      0|
  428|      0|  if (mantissa_is_inexact) {
  429|      0|    // We dropped significant digits on the floor.  Handle this appropriately.
  430|      0|    if (base == 10) {
  431|      0|      // If we truncated significant decimal digits, store the full range of the
  432|      0|      // mantissa for future big integer math for exact rounding.
  433|      0|      result.subrange_begin = mantissa_begin;
  434|      0|      result.subrange_end = begin;
  435|      0|    } else if (base == 16) {
  436|      0|      // If we truncated hex digits, reflect this fact by setting the low
  437|      0|      // ("sticky") bit.  This allows for correct rounding in all cases.
  438|      0|      mantissa |= 1;
  439|      0|    }
  440|      0|  }
  441|      0|  result.mantissa = mantissa;
  442|      0|
  443|      0|  const char* const exponent_begin = begin;
  444|      0|  result.literal_exponent = 0;
  445|      0|  bool found_exponent = false;
  446|      0|  if (AllowExponent(format_flags) && begin < end &&
  447|      0|      IsExponentCharacter<base>(*begin)) {
  448|      0|    bool negative_exponent = false;
  449|      0|    ++begin;
  450|      0|    if (begin < end && *begin == '-') {
  451|      0|      negative_exponent = true;
  452|      0|      ++begin;
  453|      0|    } else if (begin < end && *begin == '+') {
  454|      0|      ++begin;
  455|      0|    }
  456|      0|    const char* const exponent_digits_begin = begin;
  457|      0|    // Exponent is always expressed in decimal, even for hexadecimal floats.
  458|      0|    begin += ConsumeDigits<10>(begin, end, kDecimalExponentDigitsMax,
  459|      0|                               &result.literal_exponent, nullptr);
  460|      0|    if (begin == exponent_digits_begin) {
  461|      0|      // there were no digits where we expected an exponent.  We failed to read
  462|      0|      // an exponent and should not consume the 'e' after all.  Rewind 'begin'.
  463|      0|      found_exponent = false;
  464|      0|      begin = exponent_begin;
  465|      0|    } else {
  466|      0|      found_exponent = true;
  467|      0|      if (negative_exponent) {
  468|      0|        result.literal_exponent = -result.literal_exponent;
  469|      0|      }
  470|      0|    }
  471|      0|  }
  472|      0|
  473|      0|  if (!found_exponent && RequireExponent(format_flags)) {
  474|      0|    // Provided flags required an exponent, but none was found.  This results
  475|      0|    // in a failure to scan.
  476|      0|    return result;
  477|      0|  }
  478|      0|
  479|      0|  // Success!
  480|      0|  result.type = strings_internal::FloatType::kNumber;
  481|      0|  if (result.mantissa > 0) {
  482|      0|    result.exponent = result.literal_exponent +
  483|      0|                      (DigitMagnitude<base>() * exponent_adjustment);
  484|      0|  } else {
  485|      0|    result.exponent = 0;
  486|      0|  }
  487|      0|  result.end = begin;
  488|      0|  return result;
  489|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal10ParseFloatILi10EEENS1_11ParsedFloatEPKcS5_NS0_12chars_formatE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal10ParseFloatILi16EEENS1_11ParsedFloatEPKcS5_NS0_12chars_formatE
  ------------------
  490|       |
  491|       |template ParsedFloat ParseFloat<10>(const char* begin, const char* end,
  492|       |                                    chars_format format_flags);
  493|       |template ParsedFloat ParseFloat<16>(const char* begin, const char* end,
  494|       |                                    chars_format format_flags);
  495|       |
  496|       |}  // namespace strings_internal
  497|       |}  // inline namespace lts_2019_08_08
  498|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/memutil.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/internal/memutil.h"
   16|       |
   17|       |#include <cstdlib>
   18|       |
   19|       |namespace absl {
   20|       |inline namespace lts_2019_08_08 {
   21|       |namespace strings_internal {
   22|       |
   23|      0|int memcasecmp(const char* s1, const char* s2, size_t len) {
   24|      0|  const unsigned char* us1 = reinterpret_cast<const unsigned char*>(s1);
   25|      0|  const unsigned char* us2 = reinterpret_cast<const unsigned char*>(s2);
   26|      0|
   27|      0|  for (size_t i = 0; i < len; i++) {
   28|      0|    const int diff =
   29|      0|        int{static_cast<unsigned char>(absl::ascii_tolower(us1[i]))} -
   30|      0|        int{static_cast<unsigned char>(absl::ascii_tolower(us2[i]))};
   31|      0|    if (diff != 0) return diff;
   32|      0|  }
   33|      0|  return 0;
   34|      0|}
   35|       |
   36|      0|char* memdup(const char* s, size_t slen) {
   37|      0|  void* copy;
   38|      0|  if ((copy = malloc(slen)) == nullptr) return nullptr;
   39|      0|  memcpy(copy, s, slen);
   40|      0|  return reinterpret_cast<char*>(copy);
   41|      0|}
   42|       |
   43|      0|char* memrchr(const char* s, int c, size_t slen) {
   44|      0|  for (const char* e = s + slen - 1; e >= s; e--) {
   45|      0|    if (*e == c) return const_cast<char*>(e);
   46|      0|  }
   47|      0|  return nullptr;
   48|      0|}
   49|       |
   50|      0|size_t memspn(const char* s, size_t slen, const char* accept) {
   51|      0|  const char* p = s;
   52|      0|  const char* spanp;
   53|      0|  char c, sc;
   54|      0|
   55|      0|cont:
   56|      0|  c = *p++;
   57|      0|  if (slen-- == 0) return p - 1 - s;
   58|      0|  for (spanp = accept; (sc = *spanp++) != '\0';)
   59|      0|    if (sc == c) goto cont;
   60|      0|  return p - 1 - s;
   61|      0|}
   62|       |
   63|      0|size_t memcspn(const char* s, size_t slen, const char* reject) {
   64|      0|  const char* p = s;
   65|      0|  const char* spanp;
   66|      0|  char c, sc;
   67|      0|
   68|      0|  while (slen-- != 0) {
   69|      0|    c = *p++;
   70|      0|    for (spanp = reject; (sc = *spanp++) != '\0';)
   71|      0|      if (sc == c) return p - 1 - s;
   72|      0|  }
   73|      0|  return p - s;
   74|      0|}
   75|       |
   76|      0|char* mempbrk(const char* s, size_t slen, const char* accept) {
   77|      0|  const char* scanp;
   78|      0|  int sc;
   79|      0|
   80|      0|  for (; slen; ++s, --slen) {
   81|      0|    for (scanp = accept; (sc = *scanp++) != '\0';)
   82|      0|      if (sc == *s) return const_cast<char*>(s);
   83|      0|  }
   84|      0|  return nullptr;
   85|      0|}
   86|       |
   87|       |// This is significantly faster for case-sensitive matches with very
   88|       |// few possible matches.  See unit test for benchmarks.
   89|       |const char* memmatch(const char* phaystack, size_t haylen, const char* pneedle,
   90|      0|                     size_t neelen) {
   91|      0|  if (0 == neelen) {
   92|      0|    return phaystack;  // even if haylen is 0
   93|      0|  }
   94|      0|  if (haylen < neelen) return nullptr;
   95|      0|
   96|      0|  const char* match;
   97|      0|  const char* hayend = phaystack + haylen - neelen + 1;
   98|      0|  // A static cast is used here to work around the fact that memchr returns
   99|      0|  // a void* on Posix-compliant systems and const void* on Windows.
  100|      0|  while ((match = static_cast<const char*>(
  101|      0|              memchr(phaystack, pneedle[0], hayend - phaystack)))) {
  102|      0|    if (memcmp(match, pneedle, neelen) == 0)
  103|      0|      return match;
  104|      0|    else
  105|      0|      phaystack = match + 1;
  106|      0|  }
  107|      0|  return nullptr;
  108|      0|}
  109|       |
  110|       |}  // namespace strings_internal
  111|       |}  // inline namespace lts_2019_08_08
  112|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/memutil.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |
   17|       |// These routines provide mem versions of standard C string routines,
   18|       |// such as strpbrk.  They function exactly the same as the str versions,
   19|       |// so if you wonder what they are, replace the word "mem" by
   20|       |// "str" and check out the man page.  I could return void*, as the
   21|       |// strutil.h mem*() routines tend to do, but I return char* instead
   22|       |// since this is by far the most common way these functions are called.
   23|       |//
   24|       |// The difference between the mem and str versions is the mem version
   25|       |// takes a pointer and a length, rather than a '\0'-terminated string.
   26|       |// The memcase* routines defined here assume the locale is "C"
   27|       |// (they use absl::ascii_tolower instead of tolower).
   28|       |//
   29|       |// These routines are based on the BSD library.
   30|       |//
   31|       |// Here's a list of routines from string.h, and their mem analogues.
   32|       |// Functions in lowercase are defined in string.h; those in UPPERCASE
   33|       |// are defined here:
   34|       |//
   35|       |// strlen                  --
   36|       |// strcat strncat          MEMCAT
   37|       |// strcpy strncpy          memcpy
   38|       |// --                      memccpy   (very cool function, btw)
   39|       |// --                      memmove
   40|       |// --                      memset
   41|       |// strcmp strncmp          memcmp
   42|       |// strcasecmp strncasecmp  MEMCASECMP
   43|       |// strchr                  memchr
   44|       |// strcoll                 --
   45|       |// strxfrm                 --
   46|       |// strdup strndup          MEMDUP
   47|       |// strrchr                 MEMRCHR
   48|       |// strspn                  MEMSPN
   49|       |// strcspn                 MEMCSPN
   50|       |// strpbrk                 MEMPBRK
   51|       |// strstr                  MEMSTR MEMMEM
   52|       |// (g)strcasestr           MEMCASESTR MEMCASEMEM
   53|       |// strtok                  --
   54|       |// strprefix               MEMPREFIX      (strprefix is from strutil.h)
   55|       |// strcaseprefix           MEMCASEPREFIX  (strcaseprefix is from strutil.h)
   56|       |// strsuffix               MEMSUFFIX      (strsuffix is from strutil.h)
   57|       |// strcasesuffix           MEMCASESUFFIX  (strcasesuffix is from strutil.h)
   58|       |// --                      MEMIS
   59|       |// --                      MEMCASEIS
   60|       |// strcount                MEMCOUNT       (strcount is from strutil.h)
   61|       |
   62|       |#ifndef ABSL_STRINGS_INTERNAL_MEMUTIL_H_
   63|       |#define ABSL_STRINGS_INTERNAL_MEMUTIL_H_
   64|       |
   65|       |#include <cstddef>
   66|       |#include <cstring>
   67|       |
   68|       |#include "absl/base/port.h"  // disable some warnings on Windows
   69|       |#include "absl/strings/ascii.h"  // for absl::ascii_tolower
   70|       |
   71|       |namespace absl {
   72|       |inline namespace lts_2019_08_08 {
   73|       |namespace strings_internal {
   74|       |
   75|       |inline char* memcat(char* dest, size_t destlen, const char* src,
   76|      0|                    size_t srclen) {
   77|      0|  return reinterpret_cast<char*>(memcpy(dest + destlen, src, srclen));
   78|      0|}
   79|       |
   80|       |int memcasecmp(const char* s1, const char* s2, size_t len);
   81|       |char* memdup(const char* s, size_t slen);
   82|       |char* memrchr(const char* s, int c, size_t slen);
   83|       |size_t memspn(const char* s, size_t slen, const char* accept);
   84|       |size_t memcspn(const char* s, size_t slen, const char* reject);
   85|       |char* mempbrk(const char* s, size_t slen, const char* accept);
   86|       |
   87|       |// This is for internal use only.  Don't call this directly
   88|       |template <bool case_sensitive>
   89|       |const char* int_memmatch(const char* haystack, size_t haylen,
   90|      0|                         const char* needle, size_t neelen) {
   91|      0|  if (0 == neelen) {
   92|      0|    return haystack;  // even if haylen is 0
   93|      0|  }
   94|      0|  const char* hayend = haystack + haylen;
   95|      0|  const char* needlestart = needle;
   96|      0|  const char* needleend = needlestart + neelen;
   97|      0|
   98|      0|  for (; haystack < hayend; ++haystack) {
   99|      0|    char hay = case_sensitive
  100|      0|                   ? *haystack
  101|      0|                   : absl::ascii_tolower(static_cast<unsigned char>(*haystack));
  102|      0|    char nee = case_sensitive
  103|      0|                   ? *needle
  104|      0|                   : absl::ascii_tolower(static_cast<unsigned char>(*needle));
  105|      0|    if (hay == nee) {
  106|      0|      if (++needle == needleend) {
  107|      0|        return haystack + 1 - neelen;
  108|      0|      }
  109|      0|    } else if (needle != needlestart) {
  110|      0|      // must back up haystack in case a prefix matched (find "aab" in "aaab")
  111|      0|      haystack -= needle - needlestart;  // for loop will advance one more
  112|      0|      needle = needlestart;
  113|      0|    }
  114|      0|  }
  115|      0|  return nullptr;
  116|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal12int_memmatchILb1EEEPKcS4_mS4_m
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816strings_internal12int_memmatchILb0EEEPKcS4_mS4_m
  ------------------
  117|       |
  118|       |// These are the guys you can call directly
  119|       |inline const char* memstr(const char* phaystack, size_t haylen,
  120|      0|                          const char* pneedle) {
  121|      0|  return int_memmatch<true>(phaystack, haylen, pneedle, strlen(pneedle));
  122|      0|}
  123|       |
  124|       |inline const char* memcasestr(const char* phaystack, size_t haylen,
  125|      0|                              const char* pneedle) {
  126|      0|  return int_memmatch<false>(phaystack, haylen, pneedle, strlen(pneedle));
  127|      0|}
  128|       |
  129|       |inline const char* memmem(const char* phaystack, size_t haylen,
  130|      0|                          const char* pneedle, size_t needlelen) {
  131|      0|  return int_memmatch<true>(phaystack, haylen, pneedle, needlelen);
  132|      0|}
  133|       |
  134|       |inline const char* memcasemem(const char* phaystack, size_t haylen,
  135|      0|                              const char* pneedle, size_t needlelen) {
  136|      0|  return int_memmatch<false>(phaystack, haylen, pneedle, needlelen);
  137|      0|}
  138|       |
  139|       |// This is significantly faster for case-sensitive matches with very
  140|       |// few possible matches.  See unit test for benchmarks.
  141|       |const char* memmatch(const char* phaystack, size_t haylen, const char* pneedle,
  142|       |                     size_t neelen);
  143|       |
  144|       |}  // namespace strings_internal
  145|       |}  // inline namespace lts_2019_08_08
  146|       |}  // namespace absl
  147|       |
  148|       |#endif  // ABSL_STRINGS_INTERNAL_MEMUTIL_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/ostringstream.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/internal/ostringstream.h"
   16|       |
   17|       |namespace absl {
   18|       |inline namespace lts_2019_08_08 {
   19|       |namespace strings_internal {
   20|       |
   21|      0|OStringStream::Buf::int_type OStringStream::overflow(int c) {
   22|      0|  assert(s_);
   23|      0|  if (!Buf::traits_type::eq_int_type(c, Buf::traits_type::eof()))
   24|      0|    s_->push_back(static_cast<char>(c));
   25|      0|  return 1;
   26|      0|}
   27|       |
   28|      0|std::streamsize OStringStream::xsputn(const char* s, std::streamsize n) {
   29|      0|  assert(s_);
   30|      0|  s_->append(s, n);
   31|      0|  return n;
   32|      0|}
   33|       |
   34|       |}  // namespace strings_internal
   35|       |}  // inline namespace lts_2019_08_08
   36|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/ostringstream.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#ifndef ABSL_STRINGS_INTERNAL_OSTRINGSTREAM_H_
   16|       |#define ABSL_STRINGS_INTERNAL_OSTRINGSTREAM_H_
   17|       |
   18|       |#include <cassert>
   19|       |#include <ostream>
   20|       |#include <streambuf>
   21|       |#include <string>
   22|       |
   23|       |#include "absl/base/port.h"
   24|       |
   25|       |namespace absl {
   26|       |inline namespace lts_2019_08_08 {
   27|       |namespace strings_internal {
   28|       |
   29|       |// The same as std::ostringstream but appends to a user-specified std::string,
   30|       |// and is faster. It is ~70% faster to create, ~50% faster to write to, and
   31|       |// completely free to extract the result std::string.
   32|       |//
   33|       |//   std::string s;
   34|       |//   OStringStream strm(&s);
   35|       |//   strm << 42 << ' ' << 3.14;  // appends to `s`
   36|       |//
   37|       |// The stream object doesn't have to be named. Starting from C++11 operator<<
   38|       |// works with rvalues of std::ostream.
   39|       |//
   40|       |//   std::string s;
   41|       |//   OStringStream(&s) << 42 << ' ' << 3.14;  // appends to `s`
   42|       |//
   43|       |// OStringStream is faster to create than std::ostringstream but it's still
   44|       |// relatively slow. Avoid creating multiple streams where a single stream will
   45|       |// do.
   46|       |//
   47|       |// Creates unnecessary instances of OStringStream: slow.
   48|       |//
   49|       |//   std::string s;
   50|       |//   OStringStream(&s) << 42;
   51|       |//   OStringStream(&s) << ' ';
   52|       |//   OStringStream(&s) << 3.14;
   53|       |//
   54|       |// Creates a single instance of OStringStream and reuses it: fast.
   55|       |//
   56|       |//   std::string s;
   57|       |//   OStringStream strm(&s);
   58|       |//   strm << 42;
   59|       |//   strm << ' ';
   60|       |//   strm << 3.14;
   61|       |//
   62|       |// Note: flush() has no effect. No reason to call it.
   63|       |class OStringStream : private std::basic_streambuf<char>, public std::ostream {
   64|       | public:
   65|       |  // The argument can be null, in which case you'll need to call str(p) with a
   66|       |  // non-null argument before you can write to the stream.
   67|       |  //
   68|       |  // The destructor of OStringStream doesn't use the std::string. It's OK to
   69|       |  // destroy the std::string before the stream.
   70|      0|  explicit OStringStream(std::string* s) : std::ostream(this), s_(s) {}
   71|       |
   72|      0|  std::string* str() { return s_; }
   73|      0|  const std::string* str() const { return s_; }
   74|      0|  void str(std::string* s) { s_ = s; }
   75|       |
   76|       | private:
   77|       |  using Buf = std::basic_streambuf<char>;
   78|       |
   79|       |  Buf::int_type overflow(int c) override;
   80|       |  std::streamsize xsputn(const char* s, std::streamsize n) override;
   81|       |
   82|       |  std::string* s_;
   83|       |};
   84|       |
   85|       |}  // namespace strings_internal
   86|       |}  // inline namespace lts_2019_08_08
   87|       |}  // namespace absl
   88|       |
   89|       |#endif  // ABSL_STRINGS_INTERNAL_OSTRINGSTREAM_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/resize_uninitialized.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |
   17|       |#ifndef ABSL_STRINGS_INTERNAL_RESIZE_UNINITIALIZED_H_
   18|       |#define ABSL_STRINGS_INTERNAL_RESIZE_UNINITIALIZED_H_
   19|       |
   20|       |#include <string>
   21|       |#include <type_traits>
   22|       |#include <utility>
   23|       |
   24|       |#include "absl/base/port.h"
   25|       |#include "absl/meta/type_traits.h"  //  for void_t
   26|       |
   27|       |namespace absl {
   28|       |inline namespace lts_2019_08_08 {
   29|       |namespace strings_internal {
   30|       |
   31|       |// Is a subclass of true_type or false_type, depending on whether or not
   32|       |// T has a __resize_default_init member.
   33|       |template <typename string_type, typename = void>
   34|       |struct ResizeUninitializedTraits {
   35|       |  using HasMember = std::false_type;
   36|       |  static void Resize(string_type* s, size_t new_size) { s->resize(new_size); }
   37|       |};
   38|       |
   39|       |// __resize_default_init is provided by libc++ >= 8.0 and by Google's internal
   40|       |// ::string implementation.
   41|       |template <typename string_type>
   42|       |struct ResizeUninitializedTraits<
   43|       |    string_type, absl::void_t<decltype(std::declval<string_type&>()
   44|       |                                           .__resize_default_init(237))> > {
   45|       |  using HasMember = std::true_type;
   46|      0|  static void Resize(string_type* s, size_t new_size) {
   47|      0|    s->__resize_default_init(new_size);
   48|      0|  }
   49|       |};
   50|       |
   51|       |// Returns true if the std::string implementation supports a resize where
   52|       |// the new characters added to the std::string are left untouched.
   53|       |//
   54|       |// (A better name might be "STLStringSupportsUninitializedResize", alluding to
   55|       |// the previous function.)
   56|       |template <typename string_type>
   57|       |inline constexpr bool STLStringSupportsNontrashingResize(string_type*) {
   58|       |  return ResizeUninitializedTraits<string_type>::HasMember::value;
   59|       |}
   60|       |
   61|       |// Like str->resize(new_size), except any new characters added to "*str" as a
   62|       |// result of resizing may be left uninitialized, rather than being filled with
   63|       |// '0' bytes. Typically used when code is then going to overwrite the backing
   64|       |// store of the std::string with known data.
   65|       |template <typename string_type, typename = void>
   66|      0|inline void STLStringResizeUninitialized(string_type* s, size_t new_size) {
   67|      0|  ResizeUninitializedTraits<string_type>::Resize(s, new_size);
   68|      0|}
   69|       |
   70|       |}  // namespace strings_internal
   71|       |}  // inline namespace lts_2019_08_08
   72|       |}  // namespace absl
   73|       |
   74|       |#endif  // ABSL_STRINGS_INTERNAL_RESIZE_UNINITIALIZED_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/str_join_internal.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |
   17|       |// This file declares INTERNAL parts of the Join API that are inlined/templated
   18|       |// or otherwise need to be available at compile time. The main abstractions
   19|       |// defined in this file are:
   20|       |//
   21|       |//   - A handful of default Formatters
   22|       |//   - JoinAlgorithm() overloads
   23|       |//   - JoinRange() overloads
   24|       |//   - JoinTuple()
   25|       |//
   26|       |// DO NOT INCLUDE THIS FILE DIRECTLY. Use this file by including
   27|       |// absl/strings/str_join.h
   28|       |//
   29|       |// IWYU pragma: private, include "absl/strings/str_join.h"
   30|       |
   31|       |#ifndef ABSL_STRINGS_INTERNAL_STR_JOIN_INTERNAL_H_
   32|       |#define ABSL_STRINGS_INTERNAL_STR_JOIN_INTERNAL_H_
   33|       |
   34|       |#include <cstring>
   35|       |#include <iterator>
   36|       |#include <memory>
   37|       |#include <string>
   38|       |#include <type_traits>
   39|       |#include <utility>
   40|       |
   41|       |#include "absl/strings/internal/ostringstream.h"
   42|       |#include "absl/strings/internal/resize_uninitialized.h"
   43|       |#include "absl/strings/str_cat.h"
   44|       |
   45|       |namespace absl {
   46|       |inline namespace lts_2019_08_08 {
   47|       |namespace strings_internal {
   48|       |
   49|       |//
   50|       |// Formatter objects
   51|       |//
   52|       |// The following are implementation classes for standard Formatter objects. The
   53|       |// factory functions that users will call to create and use these formatters are
   54|       |// defined and documented in strings/join.h.
   55|       |//
   56|       |
   57|       |// The default formatter. Converts alpha-numeric types to strings.
   58|       |struct AlphaNumFormatterImpl {
   59|       |  // This template is needed in order to support passing in a dereferenced
   60|       |  // vector<bool>::iterator
   61|       |  template <typename T>
   62|       |  void operator()(std::string* out, const T& t) const {
   63|       |    StrAppend(out, AlphaNum(t));
   64|       |  }
   65|       |
   66|      0|  void operator()(std::string* out, const AlphaNum& t) const {
   67|      0|    StrAppend(out, t);
   68|      0|  }
   69|       |};
   70|       |
   71|       |// A type that's used to overload the JoinAlgorithm() function (defined below)
   72|       |// for ranges that do not require additional formatting (e.g., a range of
   73|       |// strings).
   74|       |
   75|       |struct NoFormatter : public AlphaNumFormatterImpl {};
   76|       |
   77|       |// Formats types to strings using the << operator.
   78|       |class StreamFormatterImpl {
   79|       | public:
   80|       |  // The method isn't const because it mutates state. Making it const will
   81|       |  // render StreamFormatterImpl thread-hostile.
   82|       |  template <typename T>
   83|       |  void operator()(std::string* out, const T& t) {
   84|       |    // The stream is created lazily to avoid paying the relatively high cost
   85|       |    // of its construction when joining an empty range.
   86|       |    if (strm_) {
   87|       |      strm_->clear();  // clear the bad, fail and eof bits in case they were set
   88|       |      strm_->str(out);
   89|       |    } else {
   90|       |      strm_.reset(new strings_internal::OStringStream(out));
   91|       |    }
   92|       |    *strm_ << t;
   93|       |  }
   94|       |
   95|       | private:
   96|       |  std::unique_ptr<strings_internal::OStringStream> strm_;
   97|       |};
   98|       |
   99|       |// Formats a std::pair<>. The 'first' member is formatted using f1_ and the
  100|       |// 'second' member is formatted using f2_. sep_ is the separator.
  101|       |template <typename F1, typename F2>
  102|       |class PairFormatterImpl {
  103|       | public:
  104|       |  PairFormatterImpl(F1 f1, absl::string_view sep, F2 f2)
  105|       |      : f1_(std::move(f1)), sep_(sep), f2_(std::move(f2)) {}
  106|       |
  107|       |  template <typename T>
  108|       |  void operator()(std::string* out, const T& p) {
  109|       |    f1_(out, p.first);
  110|       |    out->append(sep_);
  111|       |    f2_(out, p.second);
  112|       |  }
  113|       |
  114|       |  template <typename T>
  115|       |  void operator()(std::string* out, const T& p) const {
  116|       |    f1_(out, p.first);
  117|       |    out->append(sep_);
  118|       |    f2_(out, p.second);
  119|       |  }
  120|       |
  121|       | private:
  122|       |  F1 f1_;
  123|       |  std::string sep_;
  124|       |  F2 f2_;
  125|       |};
  126|       |
  127|       |// Wraps another formatter and dereferences the argument to operator() then
  128|       |// passes the dereferenced argument to the wrapped formatter. This can be
  129|       |// useful, for example, to join a std::vector<int*>.
  130|       |template <typename Formatter>
  131|       |class DereferenceFormatterImpl {
  132|       | public:
  133|       |  DereferenceFormatterImpl() : f_() {}
  134|       |  explicit DereferenceFormatterImpl(Formatter&& f)
  135|       |      : f_(std::forward<Formatter>(f)) {}
  136|       |
  137|       |  template <typename T>
  138|       |  void operator()(std::string* out, const T& t) {
  139|       |    f_(out, *t);
  140|       |  }
  141|       |
  142|       |  template <typename T>
  143|       |  void operator()(std::string* out, const T& t) const {
  144|       |    f_(out, *t);
  145|       |  }
  146|       |
  147|       | private:
  148|       |  Formatter f_;
  149|       |};
  150|       |
  151|       |// DefaultFormatter<T> is a traits class that selects a default Formatter to use
  152|       |// for the given type T. The ::Type member names the Formatter to use. This is
  153|       |// used by the strings::Join() functions that do NOT take a Formatter argument,
  154|       |// in which case a default Formatter must be chosen.
  155|       |//
  156|       |// AlphaNumFormatterImpl is the default in the base template, followed by
  157|       |// specializations for other types.
  158|       |template <typename ValueType>
  159|       |struct DefaultFormatter {
  160|       |  typedef AlphaNumFormatterImpl Type;
  161|       |};
  162|       |template <>
  163|       |struct DefaultFormatter<const char*> {
  164|       |  typedef AlphaNumFormatterImpl Type;
  165|       |};
  166|       |template <>
  167|       |struct DefaultFormatter<char*> {
  168|       |  typedef AlphaNumFormatterImpl Type;
  169|       |};
  170|       |template <>
  171|       |struct DefaultFormatter<std::string> {
  172|       |  typedef NoFormatter Type;
  173|       |};
  174|       |template <>
  175|       |struct DefaultFormatter<absl::string_view> {
  176|       |  typedef NoFormatter Type;
  177|       |};
  178|       |template <typename ValueType>
  179|       |struct DefaultFormatter<ValueType*> {
  180|       |  typedef DereferenceFormatterImpl<typename DefaultFormatter<ValueType>::Type>
  181|       |      Type;
  182|       |};
  183|       |
  184|       |template <typename ValueType>
  185|       |struct DefaultFormatter<std::unique_ptr<ValueType>>
  186|       |    : public DefaultFormatter<ValueType*> {};
  187|       |
  188|       |//
  189|       |// JoinAlgorithm() functions
  190|       |//
  191|       |
  192|       |// The main joining algorithm. This simply joins the elements in the given
  193|       |// iterator range, each separated by the given separator, into an output string,
  194|       |// and formats each element using the provided Formatter object.
  195|       |template <typename Iterator, typename Formatter>
  196|       |std::string JoinAlgorithm(Iterator start, Iterator end, absl::string_view s,
  197|       |                          Formatter&& f) {
  198|       |  std::string result;
  199|       |  absl::string_view sep("");
  200|       |  for (Iterator it = start; it != end; ++it) {
  201|       |    result.append(sep.data(), sep.size());
  202|       |    f(&result, *it);
  203|       |    sep = s;
  204|       |  }
  205|       |  return result;
  206|       |}
  207|       |
  208|       |// A joining algorithm that's optimized for a forward iterator range of
  209|       |// string-like objects that do not need any additional formatting. This is to
  210|       |// optimize the common case of joining, say, a std::vector<string> or a
  211|       |// std::vector<absl::string_view>.
  212|       |//
  213|       |// This is an overload of the previous JoinAlgorithm() function. Here the
  214|       |// Formatter argument is of type NoFormatter. Since NoFormatter is an internal
  215|       |// type, this overload is only invoked when strings::Join() is called with a
  216|       |// range of string-like objects (e.g., std::string, absl::string_view), and an
  217|       |// explicit Formatter argument was NOT specified.
  218|       |//
  219|       |// The optimization is that the needed space will be reserved in the output
  220|       |// string to avoid the need to resize while appending. To do this, the iterator
  221|       |// range will be traversed twice: once to calculate the total needed size, and
  222|       |// then again to copy the elements and delimiters to the output string.
  223|       |template <typename Iterator,
  224|       |          typename = typename std::enable_if<std::is_convertible<
  225|       |              typename std::iterator_traits<Iterator>::iterator_category,
  226|       |              std::forward_iterator_tag>::value>::type>
  227|       |std::string JoinAlgorithm(Iterator start, Iterator end, absl::string_view s,
  228|       |                          NoFormatter) {
  229|       |  std::string result;
  230|       |  if (start != end) {
  231|       |    // Sums size
  232|       |    size_t result_size = start->size();
  233|       |    for (Iterator it = start; ++it != end;) {
  234|       |      result_size += s.size();
  235|       |      result_size += it->size();
  236|       |    }
  237|       |
  238|       |    if (result_size > 0) {
  239|       |      STLStringResizeUninitialized(&result, result_size);
  240|       |
  241|       |      // Joins strings
  242|       |      char* result_buf = &*result.begin();
  243|       |      memcpy(result_buf, start->data(), start->size());
  244|       |      result_buf += start->size();
  245|       |      for (Iterator it = start; ++it != end;) {
  246|       |        memcpy(result_buf, s.data(), s.size());
  247|       |        result_buf += s.size();
  248|       |        memcpy(result_buf, it->data(), it->size());
  249|       |        result_buf += it->size();
  250|       |      }
  251|       |    }
  252|       |  }
  253|       |
  254|       |  return result;
  255|       |}
  256|       |
  257|       |// JoinTupleLoop implements a loop over the elements of a std::tuple, which
  258|       |// are heterogeneous. The primary template matches the tuple interior case. It
  259|       |// continues the iteration after appending a separator (for nonzero indices)
  260|       |// and formatting an element of the tuple. The specialization for the I=N case
  261|       |// matches the end-of-tuple, and terminates the iteration.
  262|       |template <size_t I, size_t N>
  263|       |struct JoinTupleLoop {
  264|       |  template <typename Tup, typename Formatter>
  265|       |  void operator()(std::string* out, const Tup& tup, absl::string_view sep,
  266|       |                  Formatter&& fmt) {
  267|       |    if (I > 0) out->append(sep.data(), sep.size());
  268|       |    fmt(out, std::get<I>(tup));
  269|       |    JoinTupleLoop<I + 1, N>()(out, tup, sep, fmt);
  270|       |  }
  271|       |};
  272|       |template <size_t N>
  273|       |struct JoinTupleLoop<N, N> {
  274|       |  template <typename Tup, typename Formatter>
  275|       |  void operator()(std::string*, const Tup&, absl::string_view, Formatter&&) {}
  276|       |};
  277|       |
  278|       |template <typename... T, typename Formatter>
  279|       |std::string JoinAlgorithm(const std::tuple<T...>& tup, absl::string_view sep,
  280|       |                          Formatter&& fmt) {
  281|       |  std::string result;
  282|       |  JoinTupleLoop<0, sizeof...(T)>()(&result, tup, sep, fmt);
  283|       |  return result;
  284|       |}
  285|       |
  286|       |template <typename Iterator>
  287|       |std::string JoinRange(Iterator first, Iterator last,
  288|       |                      absl::string_view separator) {
  289|       |  // No formatter was explicitly given, so a default must be chosen.
  290|       |  typedef typename std::iterator_traits<Iterator>::value_type ValueType;
  291|       |  typedef typename DefaultFormatter<ValueType>::Type Formatter;
  292|       |  return JoinAlgorithm(first, last, separator, Formatter());
  293|       |}
  294|       |
  295|       |template <typename Range, typename Formatter>
  296|       |std::string JoinRange(const Range& range, absl::string_view separator,
  297|       |                      Formatter&& fmt) {
  298|       |  using std::begin;
  299|       |  using std::end;
  300|       |  return JoinAlgorithm(begin(range), end(range), separator, fmt);
  301|       |}
  302|       |
  303|       |template <typename Range>
  304|       |std::string JoinRange(const Range& range, absl::string_view separator) {
  305|       |  using std::begin;
  306|       |  using std::end;
  307|       |  return JoinRange(begin(range), end(range), separator);
  308|       |}
  309|       |
  310|       |}  // namespace strings_internal
  311|       |}  // inline namespace lts_2019_08_08
  312|       |}  // namespace absl
  313|       |
  314|       |#endif  // ABSL_STRINGS_INTERNAL_STR_JOIN_INTERNAL_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/str_split_internal.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |
   16|       |// This file declares INTERNAL parts of the Split API that are inline/templated
   17|       |// or otherwise need to be available at compile time. The main abstractions
   18|       |// defined in here are
   19|       |//
   20|       |//   - ConvertibleToStringView
   21|       |//   - SplitIterator<>
   22|       |//   - Splitter<>
   23|       |//
   24|       |// DO NOT INCLUDE THIS FILE DIRECTLY. Use this file by including
   25|       |// absl/strings/str_split.h.
   26|       |//
   27|       |// IWYU pragma: private, include "absl/strings/str_split.h"
   28|       |
   29|       |#ifndef ABSL_STRINGS_INTERNAL_STR_SPLIT_INTERNAL_H_
   30|       |#define ABSL_STRINGS_INTERNAL_STR_SPLIT_INTERNAL_H_
   31|       |
   32|       |#include <array>
   33|       |#include <initializer_list>
   34|       |#include <iterator>
   35|       |#include <map>
   36|       |#include <type_traits>
   37|       |#include <utility>
   38|       |#include <vector>
   39|       |
   40|       |#include "absl/base/macros.h"
   41|       |#include "absl/base/port.h"
   42|       |#include "absl/meta/type_traits.h"
   43|       |#include "absl/strings/string_view.h"
   44|       |
   45|       |#ifdef _GLIBCXX_DEBUG
   46|       |#include "absl/strings/internal/stl_type_traits.h"
   47|       |#endif  // _GLIBCXX_DEBUG
   48|       |
   49|       |namespace absl {
   50|       |inline namespace lts_2019_08_08 {
   51|       |namespace strings_internal {
   52|       |
   53|       |// This class is implicitly constructible from everything that absl::string_view
   54|       |// is implicitly constructible from. If it's constructed from a temporary
   55|       |// string, the data is moved into a data member so its lifetime matches that of
   56|       |// the ConvertibleToStringView instance.
   57|       |class ConvertibleToStringView {
   58|       | public:
   59|       |  ConvertibleToStringView(const char* s)  // NOLINT(runtime/explicit)
   60|      0|      : value_(s) {}
   61|      0|  ConvertibleToStringView(char* s) : value_(s) {}  // NOLINT(runtime/explicit)
   62|       |  ConvertibleToStringView(absl::string_view s)     // NOLINT(runtime/explicit)
   63|      0|      : value_(s) {}
   64|       |  ConvertibleToStringView(const std::string& s)  // NOLINT(runtime/explicit)
   65|      0|      : value_(s) {}
   66|       |
   67|       |  // Matches rvalue strings and moves their data to a member.
   68|       |ConvertibleToStringView(std::string&& s)  // NOLINT(runtime/explicit)
   69|      0|    : copy_(std::move(s)), value_(copy_) {}
   70|       |
   71|       |  ConvertibleToStringView(const ConvertibleToStringView& other)
   72|       |      : copy_(other.copy_),
   73|      0|        value_(other.IsSelfReferential() ? copy_ : other.value_) {}
   74|       |
   75|      0|  ConvertibleToStringView(ConvertibleToStringView&& other) {
   76|      0|    StealMembers(std::move(other));
   77|      0|  }
   78|       |
   79|      0|  ConvertibleToStringView& operator=(ConvertibleToStringView other) {
   80|      0|    StealMembers(std::move(other));
   81|      0|    return *this;
   82|      0|  }
   83|       |
   84|       |  absl::string_view value() const { return value_; }
   85|       |
   86|       | private:
   87|       |  // Returns true if ctsp's value refers to its internal copy_ member.
   88|       |  bool IsSelfReferential() const { return value_.data() == copy_.data(); }
   89|       |
   90|       |  void StealMembers(ConvertibleToStringView&& other) {
   91|       |    if (other.IsSelfReferential()) {
   92|       |      copy_ = std::move(other.copy_);
   93|       |      value_ = copy_;
   94|       |      other.value_ = other.copy_;
   95|       |    } else {
   96|       |      value_ = other.value_;
   97|       |    }
   98|       |  }
   99|       |
  100|       |  // Holds the data moved from temporary std::string arguments. Declared first
  101|       |  // so that 'value' can refer to 'copy_'.
  102|       |  std::string copy_;
  103|       |  absl::string_view value_;
  104|       |};
  105|       |
  106|       |// An iterator that enumerates the parts of a string from a Splitter. The text
  107|       |// to be split, the Delimiter, and the Predicate are all taken from the given
  108|       |// Splitter object. Iterators may only be compared if they refer to the same
  109|       |// Splitter instance.
  110|       |//
  111|       |// This class is NOT part of the public splitting API.
  112|       |template <typename Splitter>
  113|       |class SplitIterator {
  114|       | public:
  115|       |  using iterator_category = std::input_iterator_tag;
  116|       |  using value_type = absl::string_view;
  117|       |  using difference_type = ptrdiff_t;
  118|       |  using pointer = const value_type*;
  119|       |  using reference = const value_type&;
  120|       |
  121|       |  enum State { kInitState, kLastState, kEndState };
  122|       |  SplitIterator(State state, const Splitter* splitter)
  123|       |      : pos_(0),
  124|       |        state_(state),
  125|       |        splitter_(splitter),
  126|       |        delimiter_(splitter->delimiter()),
  127|       |        predicate_(splitter->predicate()) {
  128|       |    // Hack to maintain backward compatibility. This one block makes it so an
  129|       |    // empty absl::string_view whose .data() happens to be nullptr behaves
  130|       |    // *differently* from an otherwise empty absl::string_view whose .data() is
  131|       |    // not nullptr. This is an undesirable difference in general, but this
  132|       |    // behavior is maintained to avoid breaking existing code that happens to
  133|       |    // depend on this old behavior/bug. Perhaps it will be fixed one day. The
  134|       |    // difference in behavior is as follows:
  135|       |    //   Split(absl::string_view(""), '-');  // {""}
  136|       |    //   Split(absl::string_view(), '-');    // {}
  137|       |    if (splitter_->text().data() == nullptr) {
  138|       |      state_ = kEndState;
  139|       |      pos_ = splitter_->text().size();
  140|       |      return;
  141|       |    }
  142|       |
  143|       |    if (state_ == kEndState) {
  144|       |      pos_ = splitter_->text().size();
  145|       |    } else {
  146|       |      ++(*this);
  147|       |    }
  148|       |  }
  149|       |
  150|       |  bool at_end() const { return state_ == kEndState; }
  151|       |
  152|       |  reference operator*() const { return curr_; }
  153|       |  pointer operator->() const { return &curr_; }
  154|       |
  155|       |  SplitIterator& operator++() {
  156|       |    do {
  157|       |      if (state_ == kLastState) {
  158|       |        state_ = kEndState;
  159|       |        return *this;
  160|       |      }
  161|       |      const absl::string_view text = splitter_->text();
  162|       |      const absl::string_view d = delimiter_.Find(text, pos_);
  163|       |      if (d.data() == text.data() + text.size()) state_ = kLastState;
  164|       |      curr_ = text.substr(pos_, d.data() - (text.data() + pos_));
  165|       |      pos_ += curr_.size() + d.size();
  166|       |    } while (!predicate_(curr_));
  167|       |    return *this;
  168|       |  }
  169|       |
  170|       |  SplitIterator operator++(int) {
  171|       |    SplitIterator old(*this);
  172|       |    ++(*this);
  173|       |    return old;
  174|       |  }
  175|       |
  176|       |  friend bool operator==(const SplitIterator& a, const SplitIterator& b) {
  177|       |    return a.state_ == b.state_ && a.pos_ == b.pos_;
  178|       |  }
  179|       |
  180|       |  friend bool operator!=(const SplitIterator& a, const SplitIterator& b) {
  181|       |    return !(a == b);
  182|       |  }
  183|       |
  184|       | private:
  185|       |  size_t pos_;
  186|       |  State state_;
  187|       |  absl::string_view curr_;
  188|       |  const Splitter* splitter_;
  189|       |  typename Splitter::DelimiterType delimiter_;
  190|       |  typename Splitter::PredicateType predicate_;
  191|       |};
  192|       |
  193|       |// HasMappedType<T>::value is true iff there exists a type T::mapped_type.
  194|       |template <typename T, typename = void>
  195|       |struct HasMappedType : std::false_type {};
  196|       |template <typename T>
  197|       |struct HasMappedType<T, absl::void_t<typename T::mapped_type>>
  198|       |    : std::true_type {};
  199|       |
  200|       |// HasValueType<T>::value is true iff there exists a type T::value_type.
  201|       |template <typename T, typename = void>
  202|       |struct HasValueType : std::false_type {};
  203|       |template <typename T>
  204|       |struct HasValueType<T, absl::void_t<typename T::value_type>> : std::true_type {
  205|       |};
  206|       |
  207|       |// HasConstIterator<T>::value is true iff there exists a type T::const_iterator.
  208|       |template <typename T, typename = void>
  209|       |struct HasConstIterator : std::false_type {};
  210|       |template <typename T>
  211|       |struct HasConstIterator<T, absl::void_t<typename T::const_iterator>>
  212|       |    : std::true_type {};
  213|       |
  214|       |// IsInitializerList<T>::value is true iff T is an std::initializer_list. More
  215|       |// details below in Splitter<> where this is used.
  216|       |std::false_type IsInitializerListDispatch(...);  // default: No
  217|       |template <typename T>
  218|       |std::true_type IsInitializerListDispatch(std::initializer_list<T>*);
  219|       |template <typename T>
  220|       |struct IsInitializerList
  221|       |    : decltype(IsInitializerListDispatch(static_cast<T*>(nullptr))) {};
  222|       |
  223|       |// A SplitterIsConvertibleTo<C>::type alias exists iff the specified condition
  224|       |// is true for type 'C'.
  225|       |//
  226|       |// Restricts conversion to container-like types (by testing for the presence of
  227|       |// a const_iterator member type) and also to disable conversion to an
  228|       |// std::initializer_list (which also has a const_iterator). Otherwise, code
  229|       |// compiled in C++11 will get an error due to ambiguous conversion paths (in
  230|       |// C++11 std::vector<T>::operator= is overloaded to take either a std::vector<T>
  231|       |// or an std::initializer_list<T>).
  232|       |
  233|       |template <typename C, bool has_value_type, bool has_mapped_type>
  234|       |struct SplitterIsConvertibleToImpl : std::false_type {};
  235|       |
  236|       |template <typename C>
  237|       |struct SplitterIsConvertibleToImpl<C, true, false>
  238|       |    : std::is_constructible<typename C::value_type, absl::string_view> {};
  239|       |
  240|       |template <typename C>
  241|       |struct SplitterIsConvertibleToImpl<C, true, true>
  242|       |    : absl::conjunction<
  243|       |          std::is_constructible<typename C::key_type, absl::string_view>,
  244|       |          std::is_constructible<typename C::mapped_type, absl::string_view>> {};
  245|       |
  246|       |template <typename C>
  247|       |struct SplitterIsConvertibleTo
  248|       |    : SplitterIsConvertibleToImpl<
  249|       |          C,
  250|       |#ifdef _GLIBCXX_DEBUG
  251|       |          !IsStrictlyBaseOfAndConvertibleToSTLContainer<C>::value &&
  252|       |#endif  // _GLIBCXX_DEBUG
  253|       |              !IsInitializerList<
  254|       |                  typename std::remove_reference<C>::type>::value &&
  255|       |              HasValueType<C>::value && HasConstIterator<C>::value,
  256|       |          HasMappedType<C>::value> {
  257|       |};
  258|       |
  259|       |// This class implements the range that is returned by absl::StrSplit(). This
  260|       |// class has templated conversion operators that allow it to be implicitly
  261|       |// converted to a variety of types that the caller may have specified on the
  262|       |// left-hand side of an assignment.
  263|       |//
  264|       |// The main interface for interacting with this class is through its implicit
  265|       |// conversion operators. However, this class may also be used like a container
  266|       |// in that it has .begin() and .end() member functions. It may also be used
  267|       |// within a range-for loop.
  268|       |//
  269|       |// Output containers can be collections of any type that is constructible from
  270|       |// an absl::string_view.
  271|       |//
  272|       |// An Predicate functor may be supplied. This predicate will be used to filter
  273|       |// the split strings: only strings for which the predicate returns true will be
  274|       |// kept. A Predicate object is any unary functor that takes an absl::string_view
  275|       |// and returns bool.
  276|       |template <typename Delimiter, typename Predicate>
  277|       |class Splitter {
  278|       | public:
  279|       |  using DelimiterType = Delimiter;
  280|       |  using PredicateType = Predicate;
  281|       |  using const_iterator = strings_internal::SplitIterator<Splitter>;
  282|       |  using value_type = typename std::iterator_traits<const_iterator>::value_type;
  283|       |
  284|       |  Splitter(ConvertibleToStringView input_text, Delimiter d, Predicate p)
  285|       |      : text_(std::move(input_text)),
  286|       |        delimiter_(std::move(d)),
  287|       |        predicate_(std::move(p)) {}
  288|       |
  289|       |  absl::string_view text() const { return text_.value(); }
  290|       |  const Delimiter& delimiter() const { return delimiter_; }
  291|       |  const Predicate& predicate() const { return predicate_; }
  292|       |
  293|       |  // Range functions that iterate the split substrings as absl::string_view
  294|       |  // objects. These methods enable a Splitter to be used in a range-based for
  295|       |  // loop.
  296|       |  const_iterator begin() const { return {const_iterator::kInitState, this}; }
  297|       |  const_iterator end() const { return {const_iterator::kEndState, this}; }
  298|       |
  299|       |  // An implicit conversion operator that is restricted to only those containers
  300|       |  // that the splitter is convertible to.
  301|       |  template <typename Container,
  302|       |            typename = typename std::enable_if<
  303|       |                SplitterIsConvertibleTo<Container>::value>::type>
  304|       |  operator Container() const {  // NOLINT(runtime/explicit)
  305|       |    return ConvertToContainer<Container, typename Container::value_type,
  306|       |                              HasMappedType<Container>::value>()(*this);
  307|       |  }
  308|       |
  309|       |  // Returns a pair with its .first and .second members set to the first two
  310|       |  // strings returned by the begin() iterator. Either/both of .first and .second
  311|       |  // will be constructed with empty strings if the iterator doesn't have a
  312|       |  // corresponding value.
  313|       |  template <typename First, typename Second>
  314|       |  operator std::pair<First, Second>() const {  // NOLINT(runtime/explicit)
  315|       |    absl::string_view first, second;
  316|       |    auto it = begin();
  317|       |    if (it != end()) {
  318|       |      first = *it;
  319|       |      if (++it != end()) {
  320|       |        second = *it;
  321|       |      }
  322|       |    }
  323|       |    return {First(first), Second(second)};
  324|       |  }
  325|       |
  326|       | private:
  327|       |  // ConvertToContainer is a functor converting a Splitter to the requested
  328|       |  // Container of ValueType. It is specialized below to optimize splitting to
  329|       |  // certain combinations of Container and ValueType.
  330|       |  //
  331|       |  // This base template handles the generic case of storing the split results in
  332|       |  // the requested non-map-like container and converting the split substrings to
  333|       |  // the requested type.
  334|       |  template <typename Container, typename ValueType, bool is_map = false>
  335|       |  struct ConvertToContainer {
  336|       |    Container operator()(const Splitter& splitter) const {
  337|       |      Container c;
  338|       |      auto it = std::inserter(c, c.end());
  339|       |      for (const auto sp : splitter) {
  340|       |        *it++ = ValueType(sp);
  341|       |      }
  342|       |      return c;
  343|       |    }
  344|       |  };
  345|       |
  346|       |  // Partial specialization for a std::vector<absl::string_view>.
  347|       |  //
  348|       |  // Optimized for the common case of splitting to a
  349|       |  // std::vector<absl::string_view>. In this case we first split the results to
  350|       |  // a small array of absl::string_view on the stack, to reduce reallocations.
  351|       |  template <typename A>
  352|       |  struct ConvertToContainer<std::vector<absl::string_view, A>,
  353|       |                            absl::string_view, false> {
  354|       |    std::vector<absl::string_view, A> operator()(
  355|       |        const Splitter& splitter) const {
  356|       |      struct raw_view {
  357|       |        const char* data;
  358|       |        size_t size;
  359|       |        operator absl::string_view() const {  // NOLINT(runtime/explicit)
  360|       |          return {data, size};
  361|       |        }
  362|       |      };
  363|       |      std::vector<absl::string_view, A> v;
  364|       |      std::array<raw_view, 16> ar;
  365|       |      for (auto it = splitter.begin(); !it.at_end();) {
  366|       |        size_t index = 0;
  367|       |        do {
  368|       |          ar[index].data = it->data();
  369|       |          ar[index].size = it->size();
  370|       |          ++it;
  371|       |        } while (++index != ar.size() && !it.at_end());
  372|       |        v.insert(v.end(), ar.begin(), ar.begin() + index);
  373|       |      }
  374|       |      return v;
  375|       |    }
  376|       |  };
  377|       |
  378|       |  // Partial specialization for a std::vector<std::string>.
  379|       |  //
  380|       |  // Optimized for the common case of splitting to a std::vector<std::string>.
  381|       |  // In this case we first split the results to a std::vector<absl::string_view>
  382|       |  // so the returned std::vector<std::string> can have space reserved to avoid
  383|       |  // std::string moves.
  384|       |  template <typename A>
  385|       |  struct ConvertToContainer<std::vector<std::string, A>, std::string, false> {
  386|       |    std::vector<std::string, A> operator()(const Splitter& splitter) const {
  387|       |      const std::vector<absl::string_view> v = splitter;
  388|       |      return std::vector<std::string, A>(v.begin(), v.end());
  389|       |    }
  390|       |  };
  391|       |
  392|       |  // Partial specialization for containers of pairs (e.g., maps).
  393|       |  //
  394|       |  // The algorithm is to insert a new pair into the map for each even-numbered
  395|       |  // item, with the even-numbered item as the key with a default-constructed
  396|       |  // value. Each odd-numbered item will then be assigned to the last pair's
  397|       |  // value.
  398|       |  template <typename Container, typename First, typename Second>
  399|       |  struct ConvertToContainer<Container, std::pair<const First, Second>, true> {
  400|       |    Container operator()(const Splitter& splitter) const {
  401|       |      Container m;
  402|       |      typename Container::iterator it;
  403|       |      bool insert = true;
  404|       |      for (const auto sp : splitter) {
  405|       |        if (insert) {
  406|       |          it = Inserter<Container>::Insert(&m, First(sp), Second());
  407|       |        } else {
  408|       |          it->second = Second(sp);
  409|       |        }
  410|       |        insert = !insert;
  411|       |      }
  412|       |      return m;
  413|       |    }
  414|       |
  415|       |    // Inserts the key and value into the given map, returning an iterator to
  416|       |    // the inserted item. Specialized for std::map and std::multimap to use
  417|       |    // emplace() and adapt emplace()'s return value.
  418|       |    template <typename Map>
  419|       |    struct Inserter {
  420|       |      using M = Map;
  421|       |      template <typename... Args>
  422|       |      static typename M::iterator Insert(M* m, Args&&... args) {
  423|       |        return m->insert(std::make_pair(std::forward<Args>(args)...)).first;
  424|       |      }
  425|       |    };
  426|       |
  427|       |    template <typename... Ts>
  428|       |    struct Inserter<std::map<Ts...>> {
  429|       |      using M = std::map<Ts...>;
  430|       |      template <typename... Args>
  431|       |      static typename M::iterator Insert(M* m, Args&&... args) {
  432|       |        return m->emplace(std::make_pair(std::forward<Args>(args)...)).first;
  433|       |      }
  434|       |    };
  435|       |
  436|       |    template <typename... Ts>
  437|       |    struct Inserter<std::multimap<Ts...>> {
  438|       |      using M = std::multimap<Ts...>;
  439|       |      template <typename... Args>
  440|       |      static typename M::iterator Insert(M* m, Args&&... args) {
  441|       |        return m->emplace(std::make_pair(std::forward<Args>(args)...));
  442|       |      }
  443|       |    };
  444|       |  };
  445|       |
  446|       |  ConvertibleToStringView text_;
  447|       |  Delimiter delimiter_;
  448|       |  Predicate predicate_;
  449|       |};
  450|       |
  451|       |}  // namespace strings_internal
  452|       |}  // inline namespace lts_2019_08_08
  453|       |}  // namespace absl
  454|       |
  455|       |#endif  // ABSL_STRINGS_INTERNAL_STR_SPLIT_INTERNAL_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/internal/utf8.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |// UTF8 utilities, implemented to reduce dependencies.
   16|       |
   17|       |#include "absl/strings/internal/utf8.h"
   18|       |
   19|       |namespace absl {
   20|       |inline namespace lts_2019_08_08 {
   21|       |namespace strings_internal {
   22|       |
   23|      0|size_t EncodeUTF8Char(char *buffer, char32_t utf8_char) {
   24|      0|  if (utf8_char <= 0x7F) {
   25|      0|    *buffer = static_cast<char>(utf8_char);
   26|      0|    return 1;
   27|      0|  } else if (utf8_char <= 0x7FF) {
   28|      0|    buffer[1] = 0x80 | (utf8_char & 0x3F);
   29|      0|    utf8_char >>= 6;
   30|      0|    buffer[0] = 0xC0 | utf8_char;
   31|      0|    return 2;
   32|      0|  } else if (utf8_char <= 0xFFFF) {
   33|      0|    buffer[2] = 0x80 | (utf8_char & 0x3F);
   34|      0|    utf8_char >>= 6;
   35|      0|    buffer[1] = 0x80 | (utf8_char & 0x3F);
   36|      0|    utf8_char >>= 6;
   37|      0|    buffer[0] = 0xE0 | utf8_char;
   38|      0|    return 3;
   39|      0|  } else {
   40|      0|    buffer[3] = 0x80 | (utf8_char & 0x3F);
   41|      0|    utf8_char >>= 6;
   42|      0|    buffer[2] = 0x80 | (utf8_char & 0x3F);
   43|      0|    utf8_char >>= 6;
   44|      0|    buffer[1] = 0x80 | (utf8_char & 0x3F);
   45|      0|    utf8_char >>= 6;
   46|      0|    buffer[0] = 0xF0 | utf8_char;
   47|      0|    return 4;
   48|      0|  }
   49|      0|}
   50|       |
   51|       |}  // namespace strings_internal
   52|       |}  // inline namespace lts_2019_08_08
   53|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/match.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/match.h"
   16|       |
   17|       |#include "absl/strings/internal/memutil.h"
   18|       |
   19|       |namespace absl {
   20|       |inline namespace lts_2019_08_08 {
   21|       |
   22|      0|bool EqualsIgnoreCase(absl::string_view piece1, absl::string_view piece2) {
   23|      0|  return (piece1.size() == piece2.size() &&
   24|      0|          0 == absl::strings_internal::memcasecmp(piece1.data(), piece2.data(),
   25|      0|                                                  piece1.size()));
   26|      0|  // memcasecmp uses absl::ascii_tolower().
   27|      0|}
   28|       |
   29|      0|bool StartsWithIgnoreCase(absl::string_view text, absl::string_view prefix) {
   30|      0|  return (text.size() >= prefix.size()) &&
   31|      0|         EqualsIgnoreCase(text.substr(0, prefix.size()), prefix);
   32|      0|}
   33|       |
   34|      0|bool EndsWithIgnoreCase(absl::string_view text, absl::string_view suffix) {
   35|      0|  return (text.size() >= suffix.size()) &&
   36|      0|         EqualsIgnoreCase(text.substr(text.size() - suffix.size()), suffix);
   37|      0|}
   38|       |
   39|       |}  // inline namespace lts_2019_08_08
   40|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/match.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: match.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This file contains simple utilities for performing string matching checks.
   21|       |// All of these function parameters are specified as `absl::string_view`,
   22|       |// meaning that these functions can accept `std::string`, `absl::string_view` or
   23|       |// nul-terminated C-style strings.
   24|       |//
   25|       |// Examples:
   26|       |//   std::string s = "foo";
   27|       |//   absl::string_view sv = "f";
   28|       |//   assert(absl::StrContains(s, sv));
   29|       |//
   30|       |// Note: The order of parameters in these functions is designed to mimic the
   31|       |// order an equivalent member function would exhibit;
   32|       |// e.g. `s.Contains(x)` ==> `absl::StrContains(s, x).
   33|       |#ifndef ABSL_STRINGS_MATCH_H_
   34|       |#define ABSL_STRINGS_MATCH_H_
   35|       |
   36|       |#include <cstring>
   37|       |
   38|       |#include "absl/strings/string_view.h"
   39|       |
   40|       |namespace absl {
   41|       |inline namespace lts_2019_08_08 {
   42|       |
   43|       |// StrContains()
   44|       |//
   45|       |// Returns whether a given string `haystack` contains the substring `needle`.
   46|      0|inline bool StrContains(absl::string_view haystack, absl::string_view needle) {
   47|      0|  return haystack.find(needle, 0) != haystack.npos;
   48|      0|}
   49|       |
   50|       |// StartsWith()
   51|       |//
   52|       |// Returns whether a given string `text` begins with `prefix`.
   53|       |inline bool StartsWith(absl::string_view text, absl::string_view prefix) {
   54|       |  return prefix.empty() ||
   55|       |         (text.size() >= prefix.size() &&
   56|       |          memcmp(text.data(), prefix.data(), prefix.size()) == 0);
   57|       |}
   58|       |
   59|       |// EndsWith()
   60|       |//
   61|       |// Returns whether a given string `text` ends with `suffix`.
   62|       |inline bool EndsWith(absl::string_view text, absl::string_view suffix) {
   63|       |  return suffix.empty() ||
   64|       |         (text.size() >= suffix.size() &&
   65|       |          memcmp(text.data() + (text.size() - suffix.size()), suffix.data(),
   66|       |                 suffix.size()) == 0);
   67|       |}
   68|       |
   69|       |// EqualsIgnoreCase()
   70|       |//
   71|       |// Returns whether given ASCII strings `piece1` and `piece2` are equal, ignoring
   72|       |// case in the comparison.
   73|       |bool EqualsIgnoreCase(absl::string_view piece1, absl::string_view piece2);
   74|       |
   75|       |// StartsWithIgnoreCase()
   76|       |//
   77|       |// Returns whether a given ASCII string `text` starts with `prefix`,
   78|       |// ignoring case in the comparison.
   79|       |bool StartsWithIgnoreCase(absl::string_view text, absl::string_view prefix);
   80|       |
   81|       |// EndsWithIgnoreCase()
   82|       |//
   83|       |// Returns whether a given ASCII string `text` ends with `suffix`, ignoring
   84|       |// case in the comparison.
   85|       |bool EndsWithIgnoreCase(absl::string_view text, absl::string_view suffix);
   86|       |
   87|       |}  // inline namespace lts_2019_08_08
   88|       |}  // namespace absl
   89|       |
   90|       |#endif  // ABSL_STRINGS_MATCH_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/numbers.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |// This file contains string processing functions related to
   16|       |// numeric values.
   17|       |
   18|       |#include "absl/strings/numbers.h"
   19|       |
   20|       |#include <algorithm>
   21|       |#include <cassert>
   22|       |#include <cfloat>          // for DBL_DIG and FLT_DIG
   23|       |#include <cmath>           // for HUGE_VAL
   24|       |#include <cstdint>
   25|       |#include <cstdio>
   26|       |#include <cstdlib>
   27|       |#include <cstring>
   28|       |#include <iterator>
   29|       |#include <limits>
   30|       |#include <memory>
   31|       |#include <utility>
   32|       |
   33|       |#include "absl/base/internal/bits.h"
   34|       |#include "absl/base/internal/raw_logging.h"
   35|       |#include "absl/strings/ascii.h"
   36|       |#include "absl/strings/charconv.h"
   37|       |#include "absl/strings/internal/memutil.h"
   38|       |#include "absl/strings/match.h"
   39|       |#include "absl/strings/str_cat.h"
   40|       |
   41|       |namespace absl {
   42|       |inline namespace lts_2019_08_08 {
   43|       |
   44|      0|bool SimpleAtof(absl::string_view str, float* out) {
   45|      0|  *out = 0.0;
   46|      0|  str = StripAsciiWhitespace(str);
   47|      0|  if (!str.empty() && str[0] == '+') {
   48|      0|    str.remove_prefix(1);
   49|      0|  }
   50|      0|  auto result = absl::from_chars(str.data(), str.data() + str.size(), *out);
   51|      0|  if (result.ec == std::errc::invalid_argument) {
   52|      0|    return false;
   53|      0|  }
   54|      0|  if (result.ptr != str.data() + str.size()) {
   55|      0|    // not all non-whitespace characters consumed
   56|      0|    return false;
   57|      0|  }
   58|      0|  // from_chars() with DR 3081's current wording will return max() on
   59|      0|  // overflow.  SimpleAtof returns infinity instead.
   60|      0|  if (result.ec == std::errc::result_out_of_range) {
   61|      0|    if (*out > 1.0) {
   62|      0|      *out = std::numeric_limits<float>::infinity();
   63|      0|    } else if (*out < -1.0) {
   64|      0|      *out = -std::numeric_limits<float>::infinity();
   65|      0|    }
   66|      0|  }
   67|      0|  return true;
   68|      0|}
   69|       |
   70|      0|bool SimpleAtod(absl::string_view str, double* out) {
   71|      0|  *out = 0.0;
   72|      0|  str = StripAsciiWhitespace(str);
   73|      0|  if (!str.empty() && str[0] == '+') {
   74|      0|    str.remove_prefix(1);
   75|      0|  }
   76|      0|  auto result = absl::from_chars(str.data(), str.data() + str.size(), *out);
   77|      0|  if (result.ec == std::errc::invalid_argument) {
   78|      0|    return false;
   79|      0|  }
   80|      0|  if (result.ptr != str.data() + str.size()) {
   81|      0|    // not all non-whitespace characters consumed
   82|      0|    return false;
   83|      0|  }
   84|      0|  // from_chars() with DR 3081's current wording will return max() on
   85|      0|  // overflow.  SimpleAtod returns infinity instead.
   86|      0|  if (result.ec == std::errc::result_out_of_range) {
   87|      0|    if (*out > 1.0) {
   88|      0|      *out = std::numeric_limits<double>::infinity();
   89|      0|    } else if (*out < -1.0) {
   90|      0|      *out = -std::numeric_limits<double>::infinity();
   91|      0|    }
   92|      0|  }
   93|      0|  return true;
   94|      0|}
   95|       |
   96|       |namespace {
   97|       |
   98|       |// Writes a two-character representation of 'i' to 'buf'. 'i' must be in the
   99|       |// range 0 <= i < 100, and buf must have space for two characters. Example:
  100|       |//   char buf[2];
  101|       |//   PutTwoDigits(42, buf);
  102|       |//   // buf[0] == '4'
  103|       |//   // buf[1] == '2'
  104|      0|inline void PutTwoDigits(size_t i, char* buf) {
  105|      0|  static const char two_ASCII_digits[100][2] = {
  106|      0|    {'0', '0'}, {'0', '1'}, {'0', '2'}, {'0', '3'}, {'0', '4'},
  107|      0|    {'0', '5'}, {'0', '6'}, {'0', '7'}, {'0', '8'}, {'0', '9'},
  108|      0|    {'1', '0'}, {'1', '1'}, {'1', '2'}, {'1', '3'}, {'1', '4'},
  109|      0|    {'1', '5'}, {'1', '6'}, {'1', '7'}, {'1', '8'}, {'1', '9'},
  110|      0|    {'2', '0'}, {'2', '1'}, {'2', '2'}, {'2', '3'}, {'2', '4'},
  111|      0|    {'2', '5'}, {'2', '6'}, {'2', '7'}, {'2', '8'}, {'2', '9'},
  112|      0|    {'3', '0'}, {'3', '1'}, {'3', '2'}, {'3', '3'}, {'3', '4'},
  113|      0|    {'3', '5'}, {'3', '6'}, {'3', '7'}, {'3', '8'}, {'3', '9'},
  114|      0|    {'4', '0'}, {'4', '1'}, {'4', '2'}, {'4', '3'}, {'4', '4'},
  115|      0|    {'4', '5'}, {'4', '6'}, {'4', '7'}, {'4', '8'}, {'4', '9'},
  116|      0|    {'5', '0'}, {'5', '1'}, {'5', '2'}, {'5', '3'}, {'5', '4'},
  117|      0|    {'5', '5'}, {'5', '6'}, {'5', '7'}, {'5', '8'}, {'5', '9'},
  118|      0|    {'6', '0'}, {'6', '1'}, {'6', '2'}, {'6', '3'}, {'6', '4'},
  119|      0|    {'6', '5'}, {'6', '6'}, {'6', '7'}, {'6', '8'}, {'6', '9'},
  120|      0|    {'7', '0'}, {'7', '1'}, {'7', '2'}, {'7', '3'}, {'7', '4'},
  121|      0|    {'7', '5'}, {'7', '6'}, {'7', '7'}, {'7', '8'}, {'7', '9'},
  122|      0|    {'8', '0'}, {'8', '1'}, {'8', '2'}, {'8', '3'}, {'8', '4'},
  123|      0|    {'8', '5'}, {'8', '6'}, {'8', '7'}, {'8', '8'}, {'8', '9'},
  124|      0|    {'9', '0'}, {'9', '1'}, {'9', '2'}, {'9', '3'}, {'9', '4'},
  125|      0|    {'9', '5'}, {'9', '6'}, {'9', '7'}, {'9', '8'}, {'9', '9'}
  126|      0|  };
  127|      0|  assert(i < 100);
  128|      0|  memcpy(buf, two_ASCII_digits[i], 2);
  129|      0|}
  130|       |
  131|       |}  // namespace
  132|       |
  133|      0|bool SimpleAtob(absl::string_view str, bool* out) {
  134|      0|  ABSL_RAW_CHECK(out != nullptr, "Output pointer must not be nullptr.");
  135|      0|  if (EqualsIgnoreCase(str, "true") || EqualsIgnoreCase(str, "t") ||
  136|      0|      EqualsIgnoreCase(str, "yes") || EqualsIgnoreCase(str, "y") ||
  137|      0|      EqualsIgnoreCase(str, "1")) {
  138|      0|    *out = true;
  139|      0|    return true;
  140|      0|  }
  141|      0|  if (EqualsIgnoreCase(str, "false") || EqualsIgnoreCase(str, "f") ||
  142|      0|      EqualsIgnoreCase(str, "no") || EqualsIgnoreCase(str, "n") ||
  143|      0|      EqualsIgnoreCase(str, "0")) {
  144|      0|    *out = false;
  145|      0|    return true;
  146|      0|  }
  147|      0|  return false;
  148|      0|}
  149|       |
  150|       |// ----------------------------------------------------------------------
  151|       |// FastIntToBuffer() overloads
  152|       |//
  153|       |// Like the Fast*ToBuffer() functions above, these are intended for speed.
  154|       |// Unlike the Fast*ToBuffer() functions, however, these functions write
  155|       |// their output to the beginning of the buffer.  The caller is responsible
  156|       |// for ensuring that the buffer has enough space to hold the output.
  157|       |//
  158|       |// Returns a pointer to the end of the string (i.e. the null character
  159|       |// terminating the string).
  160|       |// ----------------------------------------------------------------------
  161|       |
  162|       |namespace {
  163|       |
  164|       |// Used to optimize printing a decimal number's final digit.
  165|       |const char one_ASCII_final_digits[10][2] {
  166|       |  {'0', 0}, {'1', 0}, {'2', 0}, {'3', 0}, {'4', 0},
  167|       |  {'5', 0}, {'6', 0}, {'7', 0}, {'8', 0}, {'9', 0},
  168|       |};
  169|       |
  170|       |}  // namespace
  171|       |
  172|      0|char* numbers_internal::FastIntToBuffer(uint32_t i, char* buffer) {
  173|      0|  uint32_t digits;
  174|      0|  // The idea of this implementation is to trim the number of divides to as few
  175|      0|  // as possible, and also reducing memory stores and branches, by going in
  176|      0|  // steps of two digits at a time rather than one whenever possible.
  177|      0|  // The huge-number case is first, in the hopes that the compiler will output
  178|      0|  // that case in one branch-free block of code, and only output conditional
  179|      0|  // branches into it from below.
  180|      0|  if (i >= 1000000000) {     // >= 1,000,000,000
  181|      0|    digits = i / 100000000;  //      100,000,000
  182|      0|    i -= digits * 100000000;
  183|      0|    PutTwoDigits(digits, buffer);
  184|      0|    buffer += 2;
  185|      0|  lt100_000_000:
  186|      0|    digits = i / 1000000;  // 1,000,000
  187|      0|    i -= digits * 1000000;
  188|      0|    PutTwoDigits(digits, buffer);
  189|      0|    buffer += 2;
  190|      0|  lt1_000_000:
  191|      0|    digits = i / 10000;  // 10,000
  192|      0|    i -= digits * 10000;
  193|      0|    PutTwoDigits(digits, buffer);
  194|      0|    buffer += 2;
  195|      0|  lt10_000:
  196|      0|    digits = i / 100;
  197|      0|    i -= digits * 100;
  198|      0|    PutTwoDigits(digits, buffer);
  199|      0|    buffer += 2;
  200|      0| lt100:
  201|      0|    digits = i;
  202|      0|    PutTwoDigits(digits, buffer);
  203|      0|    buffer += 2;
  204|      0|    *buffer = 0;
  205|      0|    return buffer;
  206|      0|  }
  207|      0|
  208|      0|  if (i < 100) {
  209|      0|    digits = i;
  210|      0|    if (i >= 10) goto lt100;
  211|      0|    memcpy(buffer, one_ASCII_final_digits[i], 2);
  212|      0|    return buffer + 1;
  213|      0|  }
  214|      0|  if (i < 10000) {  //    10,000
  215|      0|    if (i >= 1000) goto lt10_000;
  216|      0|    digits = i / 100;
  217|      0|    i -= digits * 100;
  218|      0|    *buffer++ = '0' + digits;
  219|      0|    goto lt100;
  220|      0|  }
  221|      0|  if (i < 1000000) {  //    1,000,000
  222|      0|    if (i >= 100000) goto lt1_000_000;
  223|      0|    digits = i / 10000;  //    10,000
  224|      0|    i -= digits * 10000;
  225|      0|    *buffer++ = '0' + digits;
  226|      0|    goto lt10_000;
  227|      0|  }
  228|      0|  if (i < 100000000) {  //    100,000,000
  229|      0|    if (i >= 10000000) goto lt100_000_000;
  230|      0|    digits = i / 1000000;  //   1,000,000
  231|      0|    i -= digits * 1000000;
  232|      0|    *buffer++ = '0' + digits;
  233|      0|    goto lt1_000_000;
  234|      0|  }
  235|      0|  // we already know that i < 1,000,000,000
  236|      0|  digits = i / 100000000;  //   100,000,000
  237|      0|  i -= digits * 100000000;
  238|      0|  *buffer++ = '0' + digits;
  239|      0|  goto lt100_000_000;
  240|      0|}
  241|       |
  242|      0|char* numbers_internal::FastIntToBuffer(int32_t i, char* buffer) {
  243|      0|  uint32_t u = i;
  244|      0|  if (i < 0) {
  245|      0|    *buffer++ = '-';
  246|      0|    // We need to do the negation in modular (i.e., "unsigned")
  247|      0|    // arithmetic; MSVC++ apprently warns for plain "-u", so
  248|      0|    // we write the equivalent expression "0 - u" instead.
  249|      0|    u = 0 - u;
  250|      0|  }
  251|      0|  return numbers_internal::FastIntToBuffer(u, buffer);
  252|      0|}
  253|       |
  254|      0|char* numbers_internal::FastIntToBuffer(uint64_t i, char* buffer) {
  255|      0|  uint32_t u32 = static_cast<uint32_t>(i);
  256|      0|  if (u32 == i) return numbers_internal::FastIntToBuffer(u32, buffer);
  257|      0|
  258|      0|  // Here we know i has at least 10 decimal digits.
  259|      0|  uint64_t top_1to11 = i / 1000000000;
  260|      0|  u32 = static_cast<uint32_t>(i - top_1to11 * 1000000000);
  261|      0|  uint32_t top_1to11_32 = static_cast<uint32_t>(top_1to11);
  262|      0|
  263|      0|  if (top_1to11_32 == top_1to11) {
  264|      0|    buffer = numbers_internal::FastIntToBuffer(top_1to11_32, buffer);
  265|      0|  } else {
  266|      0|    // top_1to11 has more than 32 bits too; print it in two steps.
  267|      0|    uint32_t top_8to9 = static_cast<uint32_t>(top_1to11 / 100);
  268|      0|    uint32_t mid_2 = static_cast<uint32_t>(top_1to11 - top_8to9 * 100);
  269|      0|    buffer = numbers_internal::FastIntToBuffer(top_8to9, buffer);
  270|      0|    PutTwoDigits(mid_2, buffer);
  271|      0|    buffer += 2;
  272|      0|  }
  273|      0|
  274|      0|  // We have only 9 digits now, again the maximum uint32_t can handle fully.
  275|      0|  uint32_t digits = u32 / 10000000;  // 10,000,000
  276|      0|  u32 -= digits * 10000000;
  277|      0|  PutTwoDigits(digits, buffer);
  278|      0|  buffer += 2;
  279|      0|  digits = u32 / 100000;  // 100,000
  280|      0|  u32 -= digits * 100000;
  281|      0|  PutTwoDigits(digits, buffer);
  282|      0|  buffer += 2;
  283|      0|  digits = u32 / 1000;  // 1,000
  284|      0|  u32 -= digits * 1000;
  285|      0|  PutTwoDigits(digits, buffer);
  286|      0|  buffer += 2;
  287|      0|  digits = u32 / 10;
  288|      0|  u32 -= digits * 10;
  289|      0|  PutTwoDigits(digits, buffer);
  290|      0|  buffer += 2;
  291|      0|  memcpy(buffer, one_ASCII_final_digits[u32], 2);
  292|      0|  return buffer + 1;
  293|      0|}
  294|       |
  295|      0|char* numbers_internal::FastIntToBuffer(int64_t i, char* buffer) {
  296|      0|  uint64_t u = i;
  297|      0|  if (i < 0) {
  298|      0|    *buffer++ = '-';
  299|      0|    u = 0 - u;
  300|      0|  }
  301|      0|  return numbers_internal::FastIntToBuffer(u, buffer);
  302|      0|}
  303|       |
  304|       |// Given a 128-bit number expressed as a pair of uint64_t, high half first,
  305|       |// return that number multiplied by the given 32-bit value.  If the result is
  306|       |// too large to fit in a 128-bit number, divide it by 2 until it fits.
  307|       |static std::pair<uint64_t, uint64_t> Mul32(std::pair<uint64_t, uint64_t> num,
  308|      0|                                           uint32_t mul) {
  309|      0|  uint64_t bits0_31 = num.second & 0xFFFFFFFF;
  310|      0|  uint64_t bits32_63 = num.second >> 32;
  311|      0|  uint64_t bits64_95 = num.first & 0xFFFFFFFF;
  312|      0|  uint64_t bits96_127 = num.first >> 32;
  313|      0|
  314|      0|  // The picture so far: each of these 64-bit values has only the lower 32 bits
  315|      0|  // filled in.
  316|      0|  // bits96_127:          [ 00000000 xxxxxxxx ]
  317|      0|  // bits64_95:                    [ 00000000 xxxxxxxx ]
  318|      0|  // bits32_63:                             [ 00000000 xxxxxxxx ]
  319|      0|  // bits0_31:                                       [ 00000000 xxxxxxxx ]
  320|      0|
  321|      0|  bits0_31 *= mul;
  322|      0|  bits32_63 *= mul;
  323|      0|  bits64_95 *= mul;
  324|      0|  bits96_127 *= mul;
  325|      0|
  326|      0|  // Now the top halves may also have value, though all 64 of their bits will
  327|      0|  // never be set at the same time, since they are a result of a 32x32 bit
  328|      0|  // multiply.  This makes the carry calculation slightly easier.
  329|      0|  // bits96_127:          [ mmmmmmmm | mmmmmmmm ]
  330|      0|  // bits64_95:                    [ | mmmmmmmm mmmmmmmm | ]
  331|      0|  // bits32_63:                      |        [ mmmmmmmm | mmmmmmmm ]
  332|      0|  // bits0_31:                       |                 [ | mmmmmmmm mmmmmmmm ]
  333|      0|  // eventually:        [ bits128_up | ...bits64_127.... | ..bits0_63... ]
  334|      0|
  335|      0|  uint64_t bits0_63 = bits0_31 + (bits32_63 << 32);
  336|      0|  uint64_t bits64_127 = bits64_95 + (bits96_127 << 32) + (bits32_63 >> 32) +
  337|      0|                        (bits0_63 < bits0_31);
  338|      0|  uint64_t bits128_up = (bits96_127 >> 32) + (bits64_127 < bits64_95);
  339|      0|  if (bits128_up == 0) return {bits64_127, bits0_63};
  340|      0|
  341|      0|  int shift = 64 - base_internal::CountLeadingZeros64(bits128_up);
  342|      0|  uint64_t lo = (bits0_63 >> shift) + (bits64_127 << (64 - shift));
  343|      0|  uint64_t hi = (bits64_127 >> shift) + (bits128_up << (64 - shift));
  344|      0|  return {hi, lo};
  345|      0|}
  346|       |
  347|       |// Compute num * 5 ^ expfive, and return the first 128 bits of the result,
  348|       |// where the first bit is always a one.  So PowFive(1, 0) starts 0b100000,
  349|       |// PowFive(1, 1) starts 0b101000, PowFive(1, 2) starts 0b110010, etc.
  350|      0|static std::pair<uint64_t, uint64_t> PowFive(uint64_t num, int expfive) {
  351|      0|  std::pair<uint64_t, uint64_t> result = {num, 0};
  352|      0|  while (expfive >= 13) {
  353|      0|    // 5^13 is the highest power of five that will fit in a 32-bit integer.
  354|      0|    result = Mul32(result, 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5);
  355|      0|    expfive -= 13;
  356|      0|  }
  357|      0|  constexpr int powers_of_five[13] = {
  358|      0|      1,
  359|      0|      5,
  360|      0|      5 * 5,
  361|      0|      5 * 5 * 5,
  362|      0|      5 * 5 * 5 * 5,
  363|      0|      5 * 5 * 5 * 5 * 5,
  364|      0|      5 * 5 * 5 * 5 * 5 * 5,
  365|      0|      5 * 5 * 5 * 5 * 5 * 5 * 5,
  366|      0|      5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
  367|      0|      5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
  368|      0|      5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
  369|      0|      5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
  370|      0|      5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5};
  371|      0|  result = Mul32(result, powers_of_five[expfive & 15]);
  372|      0|  int shift = base_internal::CountLeadingZeros64(result.first);
  373|      0|  if (shift != 0) {
  374|      0|    result.first = (result.first << shift) + (result.second >> (64 - shift));
  375|      0|    result.second = (result.second << shift);
  376|      0|  }
  377|      0|  return result;
  378|      0|}
  379|       |
  380|       |struct ExpDigits {
  381|       |  int32_t exponent;
  382|       |  char digits[6];
  383|       |};
  384|       |
  385|       |// SplitToSix converts value, a positive double-precision floating-point number,
  386|       |// into a base-10 exponent and 6 ASCII digits, where the first digit is never
  387|       |// zero.  For example, SplitToSix(1) returns an exponent of zero and a digits
  388|       |// array of {'1', '0', '0', '0', '0', '0'}.  If value is exactly halfway between
  389|       |// two possible representations, e.g. value = 100000.5, then "round to even" is
  390|       |// performed.
  391|      0|static ExpDigits SplitToSix(const double value) {
  392|      0|  ExpDigits exp_dig;
  393|      0|  int exp = 5;
  394|      0|  double d = value;
  395|      0|  // First step: calculate a close approximation of the output, where the
  396|      0|  // value d will be between 100,000 and 999,999, representing the digits
  397|      0|  // in the output ASCII array, and exp is the base-10 exponent.  It would be
  398|      0|  // faster to use a table here, and to look up the base-2 exponent of value,
  399|      0|  // however value is an IEEE-754 64-bit number, so the table would have 2,000
  400|      0|  // entries, which is not cache-friendly.
  401|      0|  if (d >= 999999.5) {
  402|      0|    if (d >= 1e+261) exp += 256, d *= 1e-256;
  403|      0|    if (d >= 1e+133) exp += 128, d *= 1e-128;
  404|      0|    if (d >= 1e+69) exp += 64, d *= 1e-64;
  405|      0|    if (d >= 1e+37) exp += 32, d *= 1e-32;
  406|      0|    if (d >= 1e+21) exp += 16, d *= 1e-16;
  407|      0|    if (d >= 1e+13) exp += 8, d *= 1e-8;
  408|      0|    if (d >= 1e+9) exp += 4, d *= 1e-4;
  409|      0|    if (d >= 1e+7) exp += 2, d *= 1e-2;
  410|      0|    if (d >= 1e+6) exp += 1, d *= 1e-1;
  411|      0|  } else {
  412|      0|    if (d < 1e-250) exp -= 256, d *= 1e256;
  413|      0|    if (d < 1e-122) exp -= 128, d *= 1e128;
  414|      0|    if (d < 1e-58) exp -= 64, d *= 1e64;
  415|      0|    if (d < 1e-26) exp -= 32, d *= 1e32;
  416|      0|    if (d < 1e-10) exp -= 16, d *= 1e16;
  417|      0|    if (d < 1e-2) exp -= 8, d *= 1e8;
  418|      0|    if (d < 1e+2) exp -= 4, d *= 1e4;
  419|      0|    if (d < 1e+4) exp -= 2, d *= 1e2;
  420|      0|    if (d < 1e+5) exp -= 1, d *= 1e1;
  421|      0|  }
  422|      0|  // At this point, d is in the range [99999.5..999999.5) and exp is in the
  423|      0|  // range [-324..308]. Since we need to round d up, we want to add a half
  424|      0|  // and truncate.
  425|      0|  // However, the technique above may have lost some precision, due to its
  426|      0|  // repeated multiplication by constants that each may be off by half a bit
  427|      0|  // of precision.  This only matters if we're close to the edge though.
  428|      0|  // Since we'd like to know if the fractional part of d is close to a half,
  429|      0|  // we multiply it by 65536 and see if the fractional part is close to 32768.
  430|      0|  // (The number doesn't have to be a power of two,but powers of two are faster)
  431|      0|  uint64_t d64k = d * 65536;
  432|      0|  int dddddd;  // A 6-digit decimal integer.
  433|      0|  if ((d64k % 65536) == 32767 || (d64k % 65536) == 32768) {
  434|      0|    // OK, it's fairly likely that precision was lost above, which is
  435|      0|    // not a surprise given only 52 mantissa bits are available.  Therefore
  436|      0|    // redo the calculation using 128-bit numbers.  (64 bits are not enough).
  437|      0|
  438|      0|    // Start out with digits rounded down; maybe add one below.
  439|      0|    dddddd = static_cast<int>(d64k / 65536);
  440|      0|
  441|      0|    // mantissa is a 64-bit integer representing M.mmm... * 2^63.  The actual
  442|      0|    // value we're representing, of course, is M.mmm... * 2^exp2.
  443|      0|    int exp2;
  444|      0|    double m = std::frexp(value, &exp2);
  445|      0|    uint64_t mantissa = m * (32768.0 * 65536.0 * 65536.0 * 65536.0);
  446|      0|    // std::frexp returns an m value in the range [0.5, 1.0), however we
  447|      0|    // can't multiply it by 2^64 and convert to an integer because some FPUs
  448|      0|    // throw an exception when converting an number higher than 2^63 into an
  449|      0|    // integer - even an unsigned 64-bit integer!  Fortunately it doesn't matter
  450|      0|    // since m only has 52 significant bits anyway.
  451|      0|    mantissa <<= 1;
  452|      0|    exp2 -= 64;  // not needed, but nice for debugging
  453|      0|
  454|      0|    // OK, we are here to compare:
  455|      0|    //     (dddddd + 0.5) * 10^(exp-5)  vs.  mantissa * 2^exp2
  456|      0|    // so we can round up dddddd if appropriate.  Those values span the full
  457|      0|    // range of 600 orders of magnitude of IEE 64-bit floating-point.
  458|      0|    // Fortunately, we already know they are very close, so we don't need to
  459|      0|    // track the base-2 exponent of both sides.  This greatly simplifies the
  460|      0|    // the math since the 2^exp2 calculation is unnecessary and the power-of-10
  461|      0|    // calculation can become a power-of-5 instead.
  462|      0|
  463|      0|    std::pair<uint64_t, uint64_t> edge, val;
  464|      0|    if (exp >= 6) {
  465|      0|      // Compare (dddddd + 0.5) * 5 ^ (exp - 5) to mantissa
  466|      0|      // Since we're tossing powers of two, 2 * dddddd + 1 is the
  467|      0|      // same as dddddd + 0.5
  468|      0|      edge = PowFive(2 * dddddd + 1, exp - 5);
  469|      0|
  470|      0|      val.first = mantissa;
  471|      0|      val.second = 0;
  472|      0|    } else {
  473|      0|      // We can't compare (dddddd + 0.5) * 5 ^ (exp - 5) to mantissa as we did
  474|      0|      // above because (exp - 5) is negative.  So we compare (dddddd + 0.5) to
  475|      0|      // mantissa * 5 ^ (5 - exp)
  476|      0|      edge = PowFive(2 * dddddd + 1, 0);
  477|      0|
  478|      0|      val = PowFive(mantissa, 5 - exp);
  479|      0|    }
  480|      0|    // printf("exp=%d %016lx %016lx vs %016lx %016lx\n", exp, val.first,
  481|      0|    //        val.second, edge.first, edge.second);
  482|      0|    if (val > edge) {
  483|      0|      dddddd++;
  484|      0|    } else if (val == edge) {
  485|      0|      dddddd += (dddddd & 1);
  486|      0|    }
  487|      0|  } else {
  488|      0|    // Here, we are not close to the edge.
  489|      0|    dddddd = static_cast<int>((d64k + 32768) / 65536);
  490|      0|  }
  491|      0|  if (dddddd == 1000000) {
  492|      0|    dddddd = 100000;
  493|      0|    exp += 1;
  494|      0|  }
  495|      0|  exp_dig.exponent = exp;
  496|      0|
  497|      0|  int two_digits = dddddd / 10000;
  498|      0|  dddddd -= two_digits * 10000;
  499|      0|  PutTwoDigits(two_digits, &exp_dig.digits[0]);
  500|      0|
  501|      0|  two_digits = dddddd / 100;
  502|      0|  dddddd -= two_digits * 100;
  503|      0|  PutTwoDigits(two_digits, &exp_dig.digits[2]);
  504|      0|
  505|      0|  PutTwoDigits(dddddd, &exp_dig.digits[4]);
  506|      0|  return exp_dig;
  507|      0|}
  508|       |
  509|       |// Helper function for fast formatting of floating-point.
  510|       |// The result is the same as "%g", a.k.a. "%.6g".
  511|      0|size_t numbers_internal::SixDigitsToBuffer(double d, char* const buffer) {
  512|      0|  static_assert(std::numeric_limits<float>::is_iec559,
  513|      0|                "IEEE-754/IEC-559 support only");
  514|      0|
  515|      0|  char* out = buffer;  // we write data to out, incrementing as we go, but
  516|      0|                       // FloatToBuffer always returns the address of the buffer
  517|      0|                       // passed in.
  518|      0|
  519|      0|  if (std::isnan(d)) {
  520|      0|    strcpy(out, "nan");  // NOLINT(runtime/printf)
  521|      0|    return 3;
  522|      0|  }
  523|      0|  if (d == 0) {  // +0 and -0 are handled here
  524|      0|    if (std::signbit(d)) *out++ = '-';
  525|      0|    *out++ = '0';
  526|      0|    *out = 0;
  527|      0|    return out - buffer;
  528|      0|  }
  529|      0|  if (d < 0) {
  530|      0|    *out++ = '-';
  531|      0|    d = -d;
  532|      0|  }
  533|      0|  if (std::isinf(d)) {
  534|      0|    strcpy(out, "inf");  // NOLINT(runtime/printf)
  535|      0|    return out + 3 - buffer;
  536|      0|  }
  537|      0|
  538|      0|  auto exp_dig = SplitToSix(d);
  539|      0|  int exp = exp_dig.exponent;
  540|      0|  const char* digits = exp_dig.digits;
  541|      0|  out[0] = '0';
  542|      0|  out[1] = '.';
  543|      0|  switch (exp) {
  544|      0|    case 5:
  545|      0|      memcpy(out, &digits[0], 6), out += 6;
  546|      0|      *out = 0;
  547|      0|      return out - buffer;
  548|      0|    case 4:
  549|      0|      memcpy(out, &digits[0], 5), out += 5;
  550|      0|      if (digits[5] != '0') {
  551|      0|        *out++ = '.';
  552|      0|        *out++ = digits[5];
  553|      0|      }
  554|      0|      *out = 0;
  555|      0|      return out - buffer;
  556|      0|    case 3:
  557|      0|      memcpy(out, &digits[0], 4), out += 4;
  558|      0|      if ((digits[5] | digits[4]) != '0') {
  559|      0|        *out++ = '.';
  560|      0|        *out++ = digits[4];
  561|      0|        if (digits[5] != '0') *out++ = digits[5];
  562|      0|      }
  563|      0|      *out = 0;
  564|      0|      return out - buffer;
  565|      0|    case 2:
  566|      0|      memcpy(out, &digits[0], 3), out += 3;
  567|      0|      *out++ = '.';
  568|      0|      memcpy(out, &digits[3], 3);
  569|      0|      out += 3;
  570|      0|      while (out[-1] == '0') --out;
  571|      0|      if (out[-1] == '.') --out;
  572|      0|      *out = 0;
  573|      0|      return out - buffer;
  574|      0|    case 1:
  575|      0|      memcpy(out, &digits[0], 2), out += 2;
  576|      0|      *out++ = '.';
  577|      0|      memcpy(out, &digits[2], 4);
  578|      0|      out += 4;
  579|      0|      while (out[-1] == '0') --out;
  580|      0|      if (out[-1] == '.') --out;
  581|      0|      *out = 0;
  582|      0|      return out - buffer;
  583|      0|    case 0:
  584|      0|      memcpy(out, &digits[0], 1), out += 1;
  585|      0|      *out++ = '.';
  586|      0|      memcpy(out, &digits[1], 5);
  587|      0|      out += 5;
  588|      0|      while (out[-1] == '0') --out;
  589|      0|      if (out[-1] == '.') --out;
  590|      0|      *out = 0;
  591|      0|      return out - buffer;
  592|      0|    case -4:
  593|      0|      out[2] = '0';
  594|      0|      ++out;
  595|      0|      ABSL_FALLTHROUGH_INTENDED;
  596|      0|    case -3:
  597|      0|      out[2] = '0';
  598|      0|      ++out;
  599|      0|      ABSL_FALLTHROUGH_INTENDED;
  600|      0|    case -2:
  601|      0|      out[2] = '0';
  602|      0|      ++out;
  603|      0|      ABSL_FALLTHROUGH_INTENDED;
  604|      0|    case -1:
  605|      0|      out += 2;
  606|      0|      memcpy(out, &digits[0], 6);
  607|      0|      out += 6;
  608|      0|      while (out[-1] == '0') --out;
  609|      0|      *out = 0;
  610|      0|      return out - buffer;
  611|      0|  }
  612|      0|  assert(exp < -4 || exp >= 6);
  613|      0|  out[0] = digits[0];
  614|      0|  assert(out[1] == '.');
  615|      0|  out += 2;
  616|      0|  memcpy(out, &digits[1], 5), out += 5;
  617|      0|  while (out[-1] == '0') --out;
  618|      0|  if (out[-1] == '.') --out;
  619|      0|  *out++ = 'e';
  620|      0|  if (exp > 0) {
  621|      0|    *out++ = '+';
  622|      0|  } else {
  623|      0|    *out++ = '-';
  624|      0|    exp = -exp;
  625|      0|  }
  626|      0|  if (exp > 99) {
  627|      0|    int dig1 = exp / 100;
  628|      0|    exp -= dig1 * 100;
  629|      0|    *out++ = '0' + dig1;
  630|      0|  }
  631|      0|  PutTwoDigits(exp, out);
  632|      0|  out += 2;
  633|      0|  *out = 0;
  634|      0|  return out - buffer;
  635|      0|}
  636|       |
  637|       |namespace {
  638|       |// Represents integer values of digits.
  639|       |// Uses 36 to indicate an invalid character since we support
  640|       |// bases up to 36.
  641|       |static const int8_t kAsciiToInt[256] = {
  642|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,  // 16 36s.
  643|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
  644|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 0,  1,  2,  3,  4,  5,
  645|       |    6,  7,  8,  9,  36, 36, 36, 36, 36, 36, 36, 10, 11, 12, 13, 14, 15, 16, 17,
  646|       |    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
  647|       |    36, 36, 36, 36, 36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
  648|       |    24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36, 36, 36,
  649|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
  650|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
  651|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
  652|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
  653|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
  654|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
  655|       |    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36};
  656|       |
  657|       |// Parse the sign and optional hex or oct prefix in text.
  658|       |inline bool safe_parse_sign_and_base(absl::string_view* text /*inout*/,
  659|       |                                     int* base_ptr /*inout*/,
  660|      0|                                     bool* negative_ptr /*output*/) {
  661|      0|  if (text->data() == nullptr) {
  662|      0|    return false;
  663|      0|  }
  664|      0|
  665|      0|  const char* start = text->data();
  666|      0|  const char* end = start + text->size();
  667|      0|  int base = *base_ptr;
  668|      0|
  669|      0|  // Consume whitespace.
  670|      0|  while (start < end && absl::ascii_isspace(start[0])) {
  671|      0|    ++start;
  672|      0|  }
  673|      0|  while (start < end && absl::ascii_isspace(end[-1])) {
  674|      0|    --end;
  675|      0|  }
  676|      0|  if (start >= end) {
  677|      0|    return false;
  678|      0|  }
  679|      0|
  680|      0|  // Consume sign.
  681|      0|  *negative_ptr = (start[0] == '-');
  682|      0|  if (*negative_ptr || start[0] == '+') {
  683|      0|    ++start;
  684|      0|    if (start >= end) {
  685|      0|      return false;
  686|      0|    }
  687|      0|  }
  688|      0|
  689|      0|  // Consume base-dependent prefix.
  690|      0|  //  base 0: "0x" -> base 16, "0" -> base 8, default -> base 10
  691|      0|  //  base 16: "0x" -> base 16
  692|      0|  // Also validate the base.
  693|      0|  if (base == 0) {
  694|      0|    if (end - start >= 2 && start[0] == '0' &&
  695|      0|        (start[1] == 'x' || start[1] == 'X')) {
  696|      0|      base = 16;
  697|      0|      start += 2;
  698|      0|      if (start >= end) {
  699|      0|        // "0x" with no digits after is invalid.
  700|      0|        return false;
  701|      0|      }
  702|      0|    } else if (end - start >= 1 && start[0] == '0') {
  703|      0|      base = 8;
  704|      0|      start += 1;
  705|      0|    } else {
  706|      0|      base = 10;
  707|      0|    }
  708|      0|  } else if (base == 16) {
  709|      0|    if (end - start >= 2 && start[0] == '0' &&
  710|      0|        (start[1] == 'x' || start[1] == 'X')) {
  711|      0|      start += 2;
  712|      0|      if (start >= end) {
  713|      0|        // "0x" with no digits after is invalid.
  714|      0|        return false;
  715|      0|      }
  716|      0|    }
  717|      0|  } else if (base >= 2 && base <= 36) {
  718|      0|    // okay
  719|      0|  } else {
  720|      0|    return false;
  721|      0|  }
  722|      0|  *text = absl::string_view(start, end - start);
  723|      0|  *base_ptr = base;
  724|      0|  return true;
  725|      0|}
  726|       |
  727|       |// Consume digits.
  728|       |//
  729|       |// The classic loop:
  730|       |//
  731|       |//   for each digit
  732|       |//     value = value * base + digit
  733|       |//   value *= sign
  734|       |//
  735|       |// The classic loop needs overflow checking.  It also fails on the most
  736|       |// negative integer, -2147483648 in 32-bit two's complement representation.
  737|       |//
  738|       |// My improved loop:
  739|       |//
  740|       |//  if (!negative)
  741|       |//    for each digit
  742|       |//      value = value * base
  743|       |//      value = value + digit
  744|       |//  else
  745|       |//    for each digit
  746|       |//      value = value * base
  747|       |//      value = value - digit
  748|       |//
  749|       |// Overflow checking becomes simple.
  750|       |
  751|       |// Lookup tables per IntType:
  752|       |// vmax/base and vmin/base are precomputed because division costs at least 8ns.
  753|       |// TODO(junyer): Doing this per base instead (i.e. an array of structs, not a
  754|       |// struct of arrays) would probably be better in terms of d-cache for the most
  755|       |// commonly used bases.
  756|       |template <typename IntType>
  757|       |struct LookupTables {
  758|       |  static const IntType kVmaxOverBase[];
  759|       |  static const IntType kVminOverBase[];
  760|       |};
  761|       |
  762|       |// An array initializer macro for X/base where base in [0, 36].
  763|       |// However, note that lookups for base in [0, 1] should never happen because
  764|       |// base has been validated to be in [2, 36] by safe_parse_sign_and_base().
  765|       |#define X_OVER_BASE_INITIALIZER(X)                                        \
  766|       |  {                                                                       \
  767|       |    0, 0, X / 2, X / 3, X / 4, X / 5, X / 6, X / 7, X / 8, X / 9, X / 10, \
  768|       |        X / 11, X / 12, X / 13, X / 14, X / 15, X / 16, X / 17, X / 18,   \
  769|       |        X / 19, X / 20, X / 21, X / 22, X / 23, X / 24, X / 25, X / 26,   \
  770|       |        X / 27, X / 28, X / 29, X / 30, X / 31, X / 32, X / 33, X / 34,   \
  771|       |        X / 35, X / 36,                                                   \
  772|       |  }
  773|       |
  774|       |template <typename IntType>
  775|       |const IntType LookupTables<IntType>::kVmaxOverBase[] =
  776|       |    X_OVER_BASE_INITIALIZER(std::numeric_limits<IntType>::max());
  777|       |
  778|       |template <typename IntType>
  779|       |const IntType LookupTables<IntType>::kVminOverBase[] =
  780|       |    X_OVER_BASE_INITIALIZER(std::numeric_limits<IntType>::min());
  781|       |
  782|       |#undef X_OVER_BASE_INITIALIZER
  783|       |
  784|       |template <typename IntType>
  785|       |inline bool safe_parse_positive_int(absl::string_view text, int base,
  786|      0|                                    IntType* value_p) {
  787|      0|  IntType value = 0;
  788|      0|  const IntType vmax = std::numeric_limits<IntType>::max();
  789|      0|  assert(vmax > 0);
  790|      0|  assert(base >= 0);
  791|      0|  assert(vmax >= static_cast<IntType>(base));
  792|      0|  const IntType vmax_over_base = LookupTables<IntType>::kVmaxOverBase[base];
  793|      0|  const char* start = text.data();
  794|      0|  const char* end = start + text.size();
  795|      0|  // loop over digits
  796|      0|  for (; start < end; ++start) {
  797|      0|    unsigned char c = static_cast<unsigned char>(start[0]);
  798|      0|    int digit = kAsciiToInt[c];
  799|      0|    if (digit >= base) {
  800|      0|      *value_p = value;
  801|      0|      return false;
  802|      0|    }
  803|      0|    if (value > vmax_over_base) {
  804|      0|      *value_p = vmax;
  805|      0|      return false;
  806|      0|    }
  807|      0|    value *= base;
  808|      0|    if (value > vmax - digit) {
  809|      0|      *value_p = vmax;
  810|      0|      return false;
  811|      0|    }
  812|      0|    value += digit;
  813|      0|  }
  814|      0|  *value_p = value;
  815|      0|  return true;
  816|      0|}
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_123safe_parse_positive_intIiEEbNS0_11string_viewEiPT_
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_123safe_parse_positive_intIxEEbNS0_11string_viewEiPT_
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_123safe_parse_positive_intIjEEbNS0_11string_viewEiPT_
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_123safe_parse_positive_intIyEEbNS0_11string_viewEiPT_
  ------------------
  817|       |
  818|       |template <typename IntType>
  819|       |inline bool safe_parse_negative_int(absl::string_view text, int base,
  820|      0|                                    IntType* value_p) {
  821|      0|  IntType value = 0;
  822|      0|  const IntType vmin = std::numeric_limits<IntType>::min();
  823|      0|  assert(vmin < 0);
  824|      0|  assert(vmin <= 0 - base);
  825|      0|  IntType vmin_over_base = LookupTables<IntType>::kVminOverBase[base];
  826|      0|  // 2003 c++ standard [expr.mul]
  827|      0|  // "... the sign of the remainder is implementation-defined."
  828|      0|  // Although (vmin/base)*base + vmin%base is always vmin.
  829|      0|  // 2011 c++ standard tightens the spec but we cannot rely on it.
  830|      0|  // TODO(junyer): Handle this in the lookup table generation.
  831|      0|  if (vmin % base > 0) {
  832|      0|    vmin_over_base += 1;
  833|      0|  }
  834|      0|  const char* start = text.data();
  835|      0|  const char* end = start + text.size();
  836|      0|  // loop over digits
  837|      0|  for (; start < end; ++start) {
  838|      0|    unsigned char c = static_cast<unsigned char>(start[0]);
  839|      0|    int digit = kAsciiToInt[c];
  840|      0|    if (digit >= base) {
  841|      0|      *value_p = value;
  842|      0|      return false;
  843|      0|    }
  844|      0|    if (value < vmin_over_base) {
  845|      0|      *value_p = vmin;
  846|      0|      return false;
  847|      0|    }
  848|      0|    value *= base;
  849|      0|    if (value < vmin + digit) {
  850|      0|      *value_p = vmin;
  851|      0|      return false;
  852|      0|    }
  853|      0|    value -= digit;
  854|      0|  }
  855|      0|  *value_p = value;
  856|      0|  return true;
  857|      0|}
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_123safe_parse_negative_intIiEEbNS0_11string_viewEiPT_
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_123safe_parse_negative_intIxEEbNS0_11string_viewEiPT_
  ------------------
  858|       |
  859|       |// Input format based on POSIX.1-2008 strtol
  860|       |// http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtol.html
  861|       |template <typename IntType>
  862|       |inline bool safe_int_internal(absl::string_view text, IntType* value_p,
  863|      0|                              int base) {
  864|      0|  *value_p = 0;
  865|      0|  bool negative;
  866|      0|  if (!safe_parse_sign_and_base(&text, &base, &negative)) {
  867|      0|    return false;
  868|      0|  }
  869|      0|  if (!negative) {
  870|      0|    return safe_parse_positive_int(text, base, value_p);
  871|      0|  } else {
  872|      0|    return safe_parse_negative_int(text, base, value_p);
  873|      0|  }
  874|      0|}
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_117safe_int_internalIiEEbNS0_11string_viewEPT_i
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_117safe_int_internalIxEEbNS0_11string_viewEPT_i
  ------------------
  875|       |
  876|       |template <typename IntType>
  877|       |inline bool safe_uint_internal(absl::string_view text, IntType* value_p,
  878|      0|                               int base) {
  879|      0|  *value_p = 0;
  880|      0|  bool negative;
  881|      0|  if (!safe_parse_sign_and_base(&text, &base, &negative) || negative) {
  882|      0|    return false;
  883|      0|  }
  884|      0|  return safe_parse_positive_int(text, base, value_p);
  885|      0|}
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_118safe_uint_internalIjEEbNS0_11string_viewEPT_i
  ------------------
  | Unexecuted instantiation: numbers.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_118safe_uint_internalIyEEbNS0_11string_viewEPT_i
  ------------------
  886|       |}  // anonymous namespace
  887|       |
  888|       |namespace numbers_internal {
  889|      0|bool safe_strto32_base(absl::string_view text, int32_t* value, int base) {
  890|      0|  return safe_int_internal<int32_t>(text, value, base);
  891|      0|}
  892|       |
  893|      0|bool safe_strto64_base(absl::string_view text, int64_t* value, int base) {
  894|      0|  return safe_int_internal<int64_t>(text, value, base);
  895|      0|}
  896|       |
  897|      0|bool safe_strtou32_base(absl::string_view text, uint32_t* value, int base) {
  898|      0|  return safe_uint_internal<uint32_t>(text, value, base);
  899|      0|}
  900|       |
  901|      0|bool safe_strtou64_base(absl::string_view text, uint64_t* value, int base) {
  902|      0|  return safe_uint_internal<uint64_t>(text, value, base);
  903|      0|}
  904|       |}  // namespace numbers_internal
  905|       |
  906|       |}  // inline namespace lts_2019_08_08
  907|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/numbers.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: numbers.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This package contains functions for converting strings to numbers. For
   21|       |// converting numbers to strings, use `StrCat()` or `StrAppend()` in str_cat.h,
   22|       |// which automatically detect and convert most number values appropriately.
   23|       |
   24|       |#ifndef ABSL_STRINGS_NUMBERS_H_
   25|       |#define ABSL_STRINGS_NUMBERS_H_
   26|       |
   27|       |#include <cstddef>
   28|       |#include <cstdlib>
   29|       |#include <cstring>
   30|       |#include <ctime>
   31|       |#include <limits>
   32|       |#include <string>
   33|       |#include <type_traits>
   34|       |
   35|       |#include "absl/base/macros.h"
   36|       |#include "absl/base/port.h"
   37|       |#include "absl/numeric/int128.h"
   38|       |#include "absl/strings/string_view.h"
   39|       |
   40|       |namespace absl {
   41|       |inline namespace lts_2019_08_08 {
   42|       |
   43|       |// SimpleAtoi()
   44|       |//
   45|       |// Converts the given string into an integer value, returning `true` if
   46|       |// successful. The string must reflect a base-10 integer (optionally followed or
   47|       |// preceded by ASCII whitespace) whose value falls within the range of the
   48|       |// integer type. If any errors are encountered, this function returns `false`,
   49|       |// leaving `out` in an unspecified state.
   50|       |template <typename int_type>
   51|       |ABSL_MUST_USE_RESULT bool SimpleAtoi(absl::string_view str, int_type* out);
   52|       |
   53|       |// SimpleAtof()
   54|       |//
   55|       |// Converts the given string (optionally followed or preceded by ASCII
   56|       |// whitespace) into a float, which may be rounded on overflow or underflow.
   57|       |// See https://en.cppreference.com/w/c/string/byte/strtof for details about the
   58|       |// allowed formats for `str`. If any errors are encountered, this function
   59|       |// returns `false`, leaving `out` in an unspecified state.
   60|       |ABSL_MUST_USE_RESULT bool SimpleAtof(absl::string_view str, float* out);
   61|       |
   62|       |// SimpleAtod()
   63|       |//
   64|       |// Converts the given string (optionally followed or preceded by ASCII
   65|       |// whitespace) into a double, which may be rounded on overflow or underflow.
   66|       |// See https://en.cppreference.com/w/c/string/byte/strtof for details about the
   67|       |// allowed formats for `str`. If any errors are encountered, this function
   68|       |// returns `false`, leaving `out` in an unspecified state.
   69|       |ABSL_MUST_USE_RESULT bool SimpleAtod(absl::string_view str, double* out);
   70|       |
   71|       |// SimpleAtob()
   72|       |//
   73|       |// Converts the given string into a boolean, returning `true` if successful.
   74|       |// The following case-insensitive strings are interpreted as boolean `true`:
   75|       |// "true", "t", "yes", "y", "1". The following case-insensitive strings
   76|       |// are interpreted as boolean `false`: "false", "f", "no", "n", "0". If any
   77|       |// errors are encountered, this function returns `false`, leaving `out` in an
   78|       |// unspecified state.
   79|       |ABSL_MUST_USE_RESULT bool SimpleAtob(absl::string_view str, bool* out);
   80|       |
   81|       |}  // inline namespace lts_2019_08_08
   82|       |}  // namespace absl
   83|       |
   84|       |// End of public API.  Implementation details follow.
   85|       |
   86|       |namespace absl {
   87|       |inline namespace lts_2019_08_08 {
   88|       |namespace numbers_internal {
   89|       |
   90|       |// safe_strto?() functions for implementing SimpleAtoi()
   91|       |bool safe_strto32_base(absl::string_view text, int32_t* value, int base);
   92|       |bool safe_strto64_base(absl::string_view text, int64_t* value, int base);
   93|       |bool safe_strtou32_base(absl::string_view text, uint32_t* value, int base);
   94|       |bool safe_strtou64_base(absl::string_view text, uint64_t* value, int base);
   95|       |
   96|       |static const int kFastToBufferSize = 32;
   97|       |static const int kSixDigitsToBufferSize = 16;
   98|       |
   99|       |// Helper function for fast formatting of floating-point values.
  100|       |// The result is the same as printf's "%g", a.k.a. "%.6g"; that is, six
  101|       |// significant digits are returned, trailing zeros are removed, and numbers
  102|       |// outside the range 0.0001-999999 are output using scientific notation
  103|       |// (1.23456e+06). This routine is heavily optimized.
  104|       |// Required buffer size is `kSixDigitsToBufferSize`.
  105|       |size_t SixDigitsToBuffer(double d, char* buffer);
  106|       |
  107|       |// These functions are intended for speed. All functions take an output buffer
  108|       |// as an argument and return a pointer to the last byte they wrote, which is the
  109|       |// terminating '\0'. At most `kFastToBufferSize` bytes are written.
  110|       |char* FastIntToBuffer(int32_t, char*);
  111|       |char* FastIntToBuffer(uint32_t, char*);
  112|       |char* FastIntToBuffer(int64_t, char*);
  113|       |char* FastIntToBuffer(uint64_t, char*);
  114|       |
  115|       |// For enums and integer types that are not an exact match for the types above,
  116|       |// use templates to call the appropriate one of the four overloads above.
  117|       |template <typename int_type>
  118|      0|char* FastIntToBuffer(int_type i, char* buffer) {
  119|      0|  static_assert(sizeof(i) <= 64 / 8,
  120|      0|                "FastIntToBuffer works only with 64-bit-or-less integers.");
  121|      0|  // TODO(jorg): This signed-ness check is used because it works correctly
  122|      0|  // with enums, and it also serves to check that int_type is not a pointer.
  123|      0|  // If one day something like std::is_signed<enum E> works, switch to it.
  124|      0|  if (static_cast<int_type>(1) - 2 < 0) {  // Signed
  125|      0|    if (sizeof(i) > 32 / 8) {           // 33-bit to 64-bit
  126|      0|      return FastIntToBuffer(static_cast<int64_t>(i), buffer);
  127|      0|    } else {  // 32-bit or less
  128|      0|      return FastIntToBuffer(static_cast<int32_t>(i), buffer);
  129|      0|    }
  130|      0|  } else {                     // Unsigned
  131|      0|    if (sizeof(i) > 32 / 8) {  // 33-bit to 64-bit
  132|      0|      return FastIntToBuffer(static_cast<uint64_t>(i), buffer);
  133|      0|    } else {  // 32-bit or less
  134|      0|      return FastIntToBuffer(static_cast<uint32_t>(i), buffer);
  135|      0|    }
  136|      0|  }
  137|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816numbers_internal15FastIntToBufferIsEEPcT_S3_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0816numbers_internal15FastIntToBufferItEEPcT_S3_
  ------------------
  138|       |
  139|       |// Implementation of SimpleAtoi, generalized to support arbitrary base (used
  140|       |// with base different from 10 elsewhere in Abseil implementation).
  141|       |template <typename int_type>
  142|       |ABSL_MUST_USE_RESULT bool safe_strtoi_base(absl::string_view s, int_type* out,
  143|       |                                           int base) {
  144|       |  static_assert(sizeof(*out) == 4 || sizeof(*out) == 8,
  145|       |                "SimpleAtoi works only with 32-bit or 64-bit integers.");
  146|       |  static_assert(!std::is_floating_point<int_type>::value,
  147|       |                "Use SimpleAtof or SimpleAtod instead.");
  148|       |  bool parsed;
  149|       |  // TODO(jorg): This signed-ness check is used because it works correctly
  150|       |  // with enums, and it also serves to check that int_type is not a pointer.
  151|       |  // If one day something like std::is_signed<enum E> works, switch to it.
  152|       |  if (static_cast<int_type>(1) - 2 < 0) {  // Signed
  153|       |    if (sizeof(*out) == 64 / 8) {       // 64-bit
  154|       |      int64_t val;
  155|       |      parsed = numbers_internal::safe_strto64_base(s, &val, base);
  156|       |      *out = static_cast<int_type>(val);
  157|       |    } else {  // 32-bit
  158|       |      int32_t val;
  159|       |      parsed = numbers_internal::safe_strto32_base(s, &val, base);
  160|       |      *out = static_cast<int_type>(val);
  161|       |    }
  162|       |  } else {                         // Unsigned
  163|       |    if (sizeof(*out) == 64 / 8) {  // 64-bit
  164|       |      uint64_t val;
  165|       |      parsed = numbers_internal::safe_strtou64_base(s, &val, base);
  166|       |      *out = static_cast<int_type>(val);
  167|       |    } else {  // 32-bit
  168|       |      uint32_t val;
  169|       |      parsed = numbers_internal::safe_strtou32_base(s, &val, base);
  170|       |      *out = static_cast<int_type>(val);
  171|       |    }
  172|       |  }
  173|       |  return parsed;
  174|       |}
  175|       |
  176|       |}  // namespace numbers_internal
  177|       |
  178|       |// SimpleAtoi()
  179|       |//
  180|       |// Converts a string to an integer, using `safe_strto?()` functions for actual
  181|       |// parsing, returning `true` if successful. The `safe_strto?()` functions apply
  182|       |// strict checking; the string must be a base-10 integer, optionally followed or
  183|       |// preceded by ASCII whitespace, with a value in the range of the corresponding
  184|       |// integer type.
  185|       |template <typename int_type>
  186|       |ABSL_MUST_USE_RESULT bool SimpleAtoi(absl::string_view str, int_type* out) {
  187|       |  return numbers_internal::safe_strtoi_base(str, out, 10);
  188|       |}
  189|       |
  190|       |}  // inline namespace lts_2019_08_08
  191|       |}  // namespace absl
  192|       |
  193|       |#endif  // ABSL_STRINGS_NUMBERS_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/str_cat.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/str_cat.h"
   16|       |
   17|       |#include <assert.h>
   18|       |#include <algorithm>
   19|       |#include <cstdint>
   20|       |#include <cstring>
   21|       |
   22|       |#include "absl/strings/ascii.h"
   23|       |#include "absl/strings/internal/resize_uninitialized.h"
   24|       |
   25|       |namespace absl {
   26|       |inline namespace lts_2019_08_08 {
   27|       |
   28|      0|AlphaNum::AlphaNum(Hex hex) {
   29|      0|  char* const end = &digits_[numbers_internal::kFastToBufferSize];
   30|      0|  char* writer = end;
   31|      0|  uint64_t value = hex.value;
   32|      0|  static const char hexdigits[] = "0123456789abcdef";
   33|      0|  do {
   34|      0|    *--writer = hexdigits[value & 0xF];
   35|      0|    value >>= 4;
   36|      0|  } while (value != 0);
   37|      0|
   38|      0|  char* beg;
   39|      0|  if (end - writer < hex.width) {
   40|      0|    beg = end - hex.width;
   41|      0|    std::fill_n(beg, writer - beg, hex.fill);
   42|      0|  } else {
   43|      0|    beg = writer;
   44|      0|  }
   45|      0|
   46|      0|  piece_ = absl::string_view(beg, end - beg);
   47|      0|}
   48|       |
   49|      0|AlphaNum::AlphaNum(Dec dec) {
   50|      0|  assert(dec.width <= numbers_internal::kFastToBufferSize);
   51|      0|  char* const end = &digits_[numbers_internal::kFastToBufferSize];
   52|      0|  char* const minfill = end - dec.width;
   53|      0|  char* writer = end;
   54|      0|  uint64_t value = dec.value;
   55|      0|  bool neg = dec.neg;
   56|      0|  while (value > 9) {
   57|      0|    *--writer = '0' + (value % 10);
   58|      0|    value /= 10;
   59|      0|  }
   60|      0|  *--writer = '0' + value;
   61|      0|  if (neg) *--writer = '-';
   62|      0|
   63|      0|  ptrdiff_t fillers = writer - minfill;
   64|      0|  if (fillers > 0) {
   65|      0|    // Tricky: if the fill character is ' ', then it's <fill><+/-><digits>
   66|      0|    // But...: if the fill character is '0', then it's <+/-><fill><digits>
   67|      0|    bool add_sign_again = false;
   68|      0|    if (neg && dec.fill == '0') {  // If filling with '0',
   69|      0|      ++writer;                    // ignore the sign we just added
   70|      0|      add_sign_again = true;       // and re-add the sign later.
   71|      0|    }
   72|      0|    writer -= fillers;
   73|      0|    std::fill_n(writer, fillers, dec.fill);
   74|      0|    if (add_sign_again) *--writer = '-';
   75|      0|  }
   76|      0|
   77|      0|  piece_ = absl::string_view(writer, end - writer);
   78|      0|}
   79|       |
   80|       |// ----------------------------------------------------------------------
   81|       |// StrCat()
   82|       |//    This merges the given strings or integers, with no delimiter. This
   83|       |//    is designed to be the fastest possible way to construct a string out
   84|       |//    of a mix of raw C strings, string_views, strings, and integer values.
   85|       |// ----------------------------------------------------------------------
   86|       |
   87|       |// Append is merely a version of memcpy that returns the address of the byte
   88|       |// after the area just overwritten.
   89|      0|static char* Append(char* out, const AlphaNum& x) {
   90|      0|  // memcpy is allowed to overwrite arbitrary memory, so doing this after the
   91|      0|  // call would force an extra fetch of x.size().
   92|      0|  char* after = out + x.size();
   93|      0|  if (x.size() != 0) {
   94|      0|    memcpy(out, x.data(), x.size());
   95|      0|  }
   96|      0|  return after;
   97|      0|}
   98|       |
   99|      0|std::string StrCat(const AlphaNum& a, const AlphaNum& b) {
  100|      0|  std::string result;
  101|      0|  absl::strings_internal::STLStringResizeUninitialized(&result,
  102|      0|                                                       a.size() + b.size());
  103|      0|  char* const begin = &*result.begin();
  104|      0|  char* out = begin;
  105|      0|  out = Append(out, a);
  106|      0|  out = Append(out, b);
  107|      0|  assert(out == begin + result.size());
  108|      0|  return result;
  109|      0|}
  110|       |
  111|      0|std::string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c) {
  112|      0|  std::string result;
  113|      0|  strings_internal::STLStringResizeUninitialized(
  114|      0|      &result, a.size() + b.size() + c.size());
  115|      0|  char* const begin = &*result.begin();
  116|      0|  char* out = begin;
  117|      0|  out = Append(out, a);
  118|      0|  out = Append(out, b);
  119|      0|  out = Append(out, c);
  120|      0|  assert(out == begin + result.size());
  121|      0|  return result;
  122|      0|}
  123|       |
  124|       |std::string StrCat(const AlphaNum& a, const AlphaNum& b, const AlphaNum& c,
  125|      0|                   const AlphaNum& d) {
  126|      0|  std::string result;
  127|      0|  strings_internal::STLStringResizeUninitialized(
  128|      0|      &result, a.size() + b.size() + c.size() + d.size());
  129|      0|  char* const begin = &*result.begin();
  130|      0|  char* out = begin;
  131|      0|  out = Append(out, a);
  132|      0|  out = Append(out, b);
  133|      0|  out = Append(out, c);
  134|      0|  out = Append(out, d);
  135|      0|  assert(out == begin + result.size());
  136|      0|  return result;
  137|      0|}
  138|       |
  139|       |namespace strings_internal {
  140|       |
  141|       |// Do not call directly - these are not part of the public API.
  142|      0|std::string CatPieces(std::initializer_list<absl::string_view> pieces) {
  143|      0|  std::string result;
  144|      0|  size_t total_size = 0;
  145|      0|  for (const absl::string_view piece : pieces) total_size += piece.size();
  146|      0|  strings_internal::STLStringResizeUninitialized(&result, total_size);
  147|      0|
  148|      0|  char* const begin = &*result.begin();
  149|      0|  char* out = begin;
  150|      0|  for (const absl::string_view piece : pieces) {
  151|      0|    const size_t this_size = piece.size();
  152|      0|    if (this_size != 0) {
  153|      0|      memcpy(out, piece.data(), this_size);
  154|      0|      out += this_size;
  155|      0|    }
  156|      0|  }
  157|      0|  assert(out == begin + result.size());
  158|      0|  return result;
  159|      0|}
  160|       |
  161|       |// It's possible to call StrAppend with an absl::string_view that is itself a
  162|       |// fragment of the string we're appending to.  However the results of this are
  163|       |// random. Therefore, check for this in debug mode.  Use unsigned math so we
  164|       |// only have to do one comparison. Note, there's an exception case: appending an
  165|       |// empty string is always allowed.
  166|       |#define ASSERT_NO_OVERLAP(dest, src) \
  167|      0|  assert(((src).size() == 0) ||      \
  168|      0|         (uintptr_t((src).data() - (dest).data()) > uintptr_t((dest).size())))
  169|       |
  170|       |void AppendPieces(std::string* dest,
  171|      0|                  std::initializer_list<absl::string_view> pieces) {
  172|      0|  size_t old_size = dest->size();
  173|      0|  size_t total_size = old_size;
  174|      0|  for (const absl::string_view piece : pieces) {
  175|      0|    ASSERT_NO_OVERLAP(*dest, piece);
  176|      0|    total_size += piece.size();
  177|      0|  }
  178|      0|  strings_internal::STLStringResizeUninitialized(dest, total_size);
  179|      0|
  180|      0|  char* const begin = &*dest->begin();
  181|      0|  char* out = begin + old_size;
  182|      0|  for (const absl::string_view piece : pieces) {
  183|      0|    const size_t this_size = piece.size();
  184|      0|    if (this_size != 0) {
  185|      0|      memcpy(out, piece.data(), this_size);
  186|      0|      out += this_size;
  187|      0|    }
  188|      0|  }
  189|      0|  assert(out == begin + dest->size());
  190|      0|}
  191|       |
  192|       |}  // namespace strings_internal
  193|       |
  194|      0|void StrAppend(std::string* dest, const AlphaNum& a) {
  195|      0|  ASSERT_NO_OVERLAP(*dest, a);
  196|      0|  dest->append(a.data(), a.size());
  197|      0|}
  198|       |
  199|      0|void StrAppend(std::string* dest, const AlphaNum& a, const AlphaNum& b) {
  200|      0|  ASSERT_NO_OVERLAP(*dest, a);
  201|      0|  ASSERT_NO_OVERLAP(*dest, b);
  202|      0|  std::string::size_type old_size = dest->size();
  203|      0|  strings_internal::STLStringResizeUninitialized(
  204|      0|      dest, old_size + a.size() + b.size());
  205|      0|  char* const begin = &*dest->begin();
  206|      0|  char* out = begin + old_size;
  207|      0|  out = Append(out, a);
  208|      0|  out = Append(out, b);
  209|      0|  assert(out == begin + dest->size());
  210|      0|}
  211|       |
  212|       |void StrAppend(std::string* dest, const AlphaNum& a, const AlphaNum& b,
  213|      0|               const AlphaNum& c) {
  214|      0|  ASSERT_NO_OVERLAP(*dest, a);
  215|      0|  ASSERT_NO_OVERLAP(*dest, b);
  216|      0|  ASSERT_NO_OVERLAP(*dest, c);
  217|      0|  std::string::size_type old_size = dest->size();
  218|      0|  strings_internal::STLStringResizeUninitialized(
  219|      0|      dest, old_size + a.size() + b.size() + c.size());
  220|      0|  char* const begin = &*dest->begin();
  221|      0|  char* out = begin + old_size;
  222|      0|  out = Append(out, a);
  223|      0|  out = Append(out, b);
  224|      0|  out = Append(out, c);
  225|      0|  assert(out == begin + dest->size());
  226|      0|}
  227|       |
  228|       |void StrAppend(std::string* dest, const AlphaNum& a, const AlphaNum& b,
  229|      0|               const AlphaNum& c, const AlphaNum& d) {
  230|      0|  ASSERT_NO_OVERLAP(*dest, a);
  231|      0|  ASSERT_NO_OVERLAP(*dest, b);
  232|      0|  ASSERT_NO_OVERLAP(*dest, c);
  233|      0|  ASSERT_NO_OVERLAP(*dest, d);
  234|      0|  std::string::size_type old_size = dest->size();
  235|      0|  strings_internal::STLStringResizeUninitialized(
  236|      0|      dest, old_size + a.size() + b.size() + c.size() + d.size());
  237|      0|  char* const begin = &*dest->begin();
  238|      0|  char* out = begin + old_size;
  239|      0|  out = Append(out, a);
  240|      0|  out = Append(out, b);
  241|      0|  out = Append(out, c);
  242|      0|  out = Append(out, d);
  243|      0|  assert(out == begin + dest->size());
  244|      0|}
  245|       |
  246|       |}  // inline namespace lts_2019_08_08
  247|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/str_cat.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: str_cat.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This package contains functions for efficiently concatenating and appending
   21|       |// strings: `StrCat()` and `StrAppend()`. Most of the work within these routines
   22|       |// is actually handled through use of a special AlphaNum type, which was
   23|       |// designed to be used as a parameter type that efficiently manages conversion
   24|       |// to strings and avoids copies in the above operations.
   25|       |//
   26|       |// Any routine accepting either a string or a number may accept `AlphaNum`.
   27|       |// The basic idea is that by accepting a `const AlphaNum &` as an argument
   28|       |// to your function, your callers will automagically convert bools, integers,
   29|       |// and floating point values to strings for you.
   30|       |//
   31|       |// NOTE: Use of `AlphaNum` outside of the //absl/strings package is unsupported
   32|       |// except for the specific case of function parameters of type `AlphaNum` or
   33|       |// `const AlphaNum &`. In particular, instantiating `AlphaNum` directly as a
   34|       |// stack variable is not supported.
   35|       |//
   36|       |// Conversion from 8-bit values is not accepted because, if it were, then an
   37|       |// attempt to pass ':' instead of ":" might result in a 58 ending up in your
   38|       |// result.
   39|       |//
   40|       |// Bools convert to "0" or "1". Pointers to types other than `char *` are not
   41|       |// valid inputs. No output is generated for null `char *` pointers.
   42|       |//
   43|       |// Floating point numbers are formatted with six-digit precision, which is
   44|       |// the default for "std::cout <<" or printf "%g" (the same as "%.6g").
   45|       |//
   46|       |// You can convert to hexadecimal output rather than decimal output using the
   47|       |// `Hex` type contained here. To do so, pass `Hex(my_int)` as a parameter to
   48|       |// `StrCat()` or `StrAppend()`. You may specify a minimum hex field width using
   49|       |// a `PadSpec` enum.
   50|       |//
   51|       |// -----------------------------------------------------------------------------
   52|       |
   53|       |#ifndef ABSL_STRINGS_STR_CAT_H_
   54|       |#define ABSL_STRINGS_STR_CAT_H_
   55|       |
   56|       |#include <array>
   57|       |#include <cstdint>
   58|       |#include <string>
   59|       |#include <type_traits>
   60|       |#include <vector>
   61|       |
   62|       |#include "absl/base/port.h"
   63|       |#include "absl/strings/numbers.h"
   64|       |#include "absl/strings/string_view.h"
   65|       |
   66|       |namespace absl {
   67|       |inline namespace lts_2019_08_08 {
   68|       |
   69|       |namespace strings_internal {
   70|       |// AlphaNumBuffer allows a way to pass a string to StrCat without having to do
   71|       |// memory allocation.  It is simply a pair of a fixed-size character array, and
   72|       |// a size.  Please don't use outside of absl, yet.
   73|       |template <size_t max_size>
   74|       |struct AlphaNumBuffer {
   75|       |  std::array<char, max_size> data;
   76|       |  size_t size;
   77|       |};
   78|       |
   79|       |}  // namespace strings_internal
   80|       |
   81|       |// Enum that specifies the number of significant digits to return in a `Hex` or
   82|       |// `Dec` conversion and fill character to use. A `kZeroPad2` value, for example,
   83|       |// would produce hexadecimal strings such as "0a","0f" and a 'kSpacePad5' value
   84|       |// would produce hexadecimal strings such as "    a","    f".
   85|       |enum PadSpec : uint8_t {
   86|       |  kNoPad = 1,
   87|       |  kZeroPad2,
   88|       |  kZeroPad3,
   89|       |  kZeroPad4,
   90|       |  kZeroPad5,
   91|       |  kZeroPad6,
   92|       |  kZeroPad7,
   93|       |  kZeroPad8,
   94|       |  kZeroPad9,
   95|       |  kZeroPad10,
   96|       |  kZeroPad11,
   97|       |  kZeroPad12,
   98|       |  kZeroPad13,
   99|       |  kZeroPad14,
  100|       |  kZeroPad15,
  101|       |  kZeroPad16,
  102|       |  kZeroPad17,
  103|       |  kZeroPad18,
  104|       |  kZeroPad19,
  105|       |  kZeroPad20,
  106|       |
  107|       |  kSpacePad2 = kZeroPad2 + 64,
  108|       |  kSpacePad3,
  109|       |  kSpacePad4,
  110|       |  kSpacePad5,
  111|       |  kSpacePad6,
  112|       |  kSpacePad7,
  113|       |  kSpacePad8,
  114|       |  kSpacePad9,
  115|       |  kSpacePad10,
  116|       |  kSpacePad11,
  117|       |  kSpacePad12,
  118|       |  kSpacePad13,
  119|       |  kSpacePad14,
  120|       |  kSpacePad15,
  121|       |  kSpacePad16,
  122|       |  kSpacePad17,
  123|       |  kSpacePad18,
  124|       |  kSpacePad19,
  125|       |  kSpacePad20,
  126|       |};
  127|       |
  128|       |// -----------------------------------------------------------------------------
  129|       |// Hex
  130|       |// -----------------------------------------------------------------------------
  131|       |//
  132|       |// `Hex` stores a set of hexadecimal string conversion parameters for use
  133|       |// within `AlphaNum` string conversions.
  134|       |struct Hex {
  135|       |  uint64_t value;
  136|       |  uint8_t width;
  137|       |  char fill;
  138|       |
  139|       |  template <typename Int>
  140|       |  explicit Hex(
  141|       |      Int v, PadSpec spec = absl::kNoPad,
  142|       |      typename std::enable_if<sizeof(Int) == 1 &&
  143|       |                              !std::is_pointer<Int>::value>::type* = nullptr)
  144|       |      : Hex(spec, static_cast<uint8_t>(v)) {}
  145|       |  template <typename Int>
  146|       |  explicit Hex(
  147|       |      Int v, PadSpec spec = absl::kNoPad,
  148|       |      typename std::enable_if<sizeof(Int) == 2 &&
  149|       |                              !std::is_pointer<Int>::value>::type* = nullptr)
  150|       |      : Hex(spec, static_cast<uint16_t>(v)) {}
  151|       |  template <typename Int>
  152|       |  explicit Hex(
  153|       |      Int v, PadSpec spec = absl::kNoPad,
  154|       |      typename std::enable_if<sizeof(Int) == 4 &&
  155|       |                              !std::is_pointer<Int>::value>::type* = nullptr)
  156|       |      : Hex(spec, static_cast<uint32_t>(v)) {}
  157|       |  template <typename Int>
  158|       |  explicit Hex(
  159|       |      Int v, PadSpec spec = absl::kNoPad,
  160|       |      typename std::enable_if<sizeof(Int) == 8 &&
  161|       |                              !std::is_pointer<Int>::value>::type* = nullptr)
  162|       |      : Hex(spec, static_cast<uint64_t>(v)) {}
  163|       |  template <typename Pointee>
  164|       |  explicit Hex(Pointee* v, PadSpec spec = absl::kNoPad)
  165|       |      : Hex(spec, reinterpret_cast<uintptr_t>(v)) {}
  166|       |
  167|       | private:
  168|       |  Hex(PadSpec spec, uint64_t v)
  169|       |      : value(v),
  170|       |        width(spec == absl::kNoPad
  171|       |                  ? 1
  172|       |                  : spec >= absl::kSpacePad2 ? spec - absl::kSpacePad2 + 2
  173|       |                                             : spec - absl::kZeroPad2 + 2),
  174|       |        fill(spec >= absl::kSpacePad2 ? ' ' : '0') {}
  175|       |};
  176|       |
  177|       |// -----------------------------------------------------------------------------
  178|       |// Dec
  179|       |// -----------------------------------------------------------------------------
  180|       |//
  181|       |// `Dec` stores a set of decimal string conversion parameters for use
  182|       |// within `AlphaNum` string conversions.  Dec is slower than the default
  183|       |// integer conversion, so use it only if you need padding.
  184|       |struct Dec {
  185|       |  uint64_t value;
  186|       |  uint8_t width;
  187|       |  char fill;
  188|       |  bool neg;
  189|       |
  190|       |  template <typename Int>
  191|       |  explicit Dec(Int v, PadSpec spec = absl::kNoPad,
  192|       |               typename std::enable_if<(sizeof(Int) <= 8)>::type* = nullptr)
  193|       |      : value(v >= 0 ? static_cast<uint64_t>(v)
  194|       |                     : uint64_t{0} - static_cast<uint64_t>(v)),
  195|       |        width(spec == absl::kNoPad
  196|       |                  ? 1
  197|       |                  : spec >= absl::kSpacePad2 ? spec - absl::kSpacePad2 + 2
  198|       |                                             : spec - absl::kZeroPad2 + 2),
  199|       |        fill(spec >= absl::kSpacePad2 ? ' ' : '0'),
  200|       |        neg(v < 0) {}
  201|       |};
  202|       |
  203|       |// -----------------------------------------------------------------------------
  204|       |// AlphaNum
  205|       |// -----------------------------------------------------------------------------
  206|       |//
  207|       |// The `AlphaNum` class acts as the main parameter type for `StrCat()` and
  208|       |// `StrAppend()`, providing efficient conversion of numeric, boolean, and
  209|       |// hexadecimal values (through the `Hex` type) into strings.
  210|       |
  211|       |class AlphaNum {
  212|       | public:
  213|       |  // No bool ctor -- bools convert to an integral type.
  214|       |  // A bool ctor would also convert incoming pointers (bletch).
  215|       |
  216|       |  AlphaNum(int x)  // NOLINT(runtime/explicit)
  217|       |      : piece_(digits_,
  218|      0|               numbers_internal::FastIntToBuffer(x, digits_) - &digits_[0]) {}
  219|       |  AlphaNum(unsigned int x)  // NOLINT(runtime/explicit)
  220|       |      : piece_(digits_,
  221|      0|               numbers_internal::FastIntToBuffer(x, digits_) - &digits_[0]) {}
  222|       |  AlphaNum(long x)  // NOLINT(*)
  223|       |      : piece_(digits_,
  224|      0|               numbers_internal::FastIntToBuffer(x, digits_) - &digits_[0]) {}
  225|       |  AlphaNum(unsigned long x)  // NOLINT(*)
  226|       |      : piece_(digits_,
  227|      0|               numbers_internal::FastIntToBuffer(x, digits_) - &digits_[0]) {}
  228|       |  AlphaNum(long long x)  // NOLINT(*)
  229|       |      : piece_(digits_,
  230|      0|               numbers_internal::FastIntToBuffer(x, digits_) - &digits_[0]) {}
  231|       |  AlphaNum(unsigned long long x)  // NOLINT(*)
  232|       |      : piece_(digits_,
  233|      0|               numbers_internal::FastIntToBuffer(x, digits_) - &digits_[0]) {}
  234|       |
  235|       |  AlphaNum(float f)  // NOLINT(runtime/explicit)
  236|      0|      : piece_(digits_, numbers_internal::SixDigitsToBuffer(f, digits_)) {}
  237|       |  AlphaNum(double f)  // NOLINT(runtime/explicit)
  238|      0|      : piece_(digits_, numbers_internal::SixDigitsToBuffer(f, digits_)) {}
  239|       |
  240|       |  AlphaNum(Hex hex);  // NOLINT(runtime/explicit)
  241|       |  AlphaNum(Dec dec);  // NOLINT(runtime/explicit)
  242|       |
  243|       |  template <size_t size>
  244|       |  AlphaNum(  // NOLINT(runtime/explicit)
  245|       |      const strings_internal::AlphaNumBuffer<size>& buf)
  246|       |      : piece_(&buf.data[0], buf.size) {}
  247|       |
  248|      0|  AlphaNum(const char* c_str) : piece_(c_str) {}  // NOLINT(runtime/explicit)
  249|      0|  AlphaNum(absl::string_view pc) : piece_(pc) {}  // NOLINT(runtime/explicit)
  250|       |
  251|       |  template <typename Allocator>
  252|       |  AlphaNum(  // NOLINT(runtime/explicit)
  253|       |      const std::basic_string<char, std::char_traits<char>, Allocator>& str)
  254|      0|      : piece_(str) {}
  255|       |
  256|       |  // Use std::string literals ":" instead of character literals ':'.
  257|       |  AlphaNum(char c) = delete;  // NOLINT(runtime/explicit)
  258|       |
  259|       |  AlphaNum(const AlphaNum&) = delete;
  260|       |  AlphaNum& operator=(const AlphaNum&) = delete;
  261|       |
  262|      0|  absl::string_view::size_type size() const { return piece_.size(); }
  263|      0|  const char* data() const { return piece_.data(); }
  264|       |  absl::string_view Piece() const { return piece_; }
  265|       |
  266|       |  // Normal enums are already handled by the integer formatters.
  267|       |  // This overload matches only scoped enums.
  268|       |  template <typename T,
  269|       |            typename = typename std::enable_if<
  270|       |                std::is_enum<T>{} && !std::is_convertible<T, int>{}>::type>
  271|       |  AlphaNum(T e)  // NOLINT(runtime/explicit)
  272|       |      : AlphaNum(static_cast<typename std::underlying_type<T>::type>(e)) {}
  273|       |
  274|       |  // vector<bool>::reference and const_reference require special help to
  275|       |  // convert to `AlphaNum` because it requires two user defined conversions.
  276|       |  template <
  277|       |      typename T,
  278|       |      typename std::enable_if<
  279|       |          std::is_class<T>::value &&
  280|       |          (std::is_same<T, std::vector<bool>::reference>::value ||
  281|       |           std::is_same<T, std::vector<bool>::const_reference>::value)>::type* =
  282|       |          nullptr>
  283|       |  AlphaNum(T e) : AlphaNum(static_cast<bool>(e)) {}  // NOLINT(runtime/explicit)
  284|       |
  285|       | private:
  286|       |  absl::string_view piece_;
  287|       |  char digits_[numbers_internal::kFastToBufferSize];
  288|       |};
  289|       |
  290|       |// -----------------------------------------------------------------------------
  291|       |// StrCat()
  292|       |// -----------------------------------------------------------------------------
  293|       |//
  294|       |// Merges given strings or numbers, using no delimiter(s).
  295|       |//
  296|       |// `StrCat()` is designed to be the fastest possible way to construct a string
  297|       |// out of a mix of raw C strings, string_views, strings, bool values,
  298|       |// and numeric values.
  299|       |//
  300|       |// Don't use `StrCat()` for user-visible strings. The localization process
  301|       |// works poorly on strings built up out of fragments.
  302|       |//
  303|       |// For clarity and performance, don't use `StrCat()` when appending to a
  304|       |// string. Use `StrAppend()` instead. In particular, avoid using any of these
  305|       |// (anti-)patterns:
  306|       |//
  307|       |//   str.append(StrCat(...))
  308|       |//   str += StrCat(...)
  309|       |//   str = StrCat(str, ...)
  310|       |//
  311|       |// The last case is the worst, with a potential to change a loop
  312|       |// from a linear time operation with O(1) dynamic allocations into a
  313|       |// quadratic time operation with O(n) dynamic allocations.
  314|       |//
  315|       |// See `StrAppend()` below for more information.
  316|       |
  317|       |namespace strings_internal {
  318|       |
  319|       |// Do not call directly - this is not part of the public API.
  320|       |std::string CatPieces(std::initializer_list<absl::string_view> pieces);
  321|       |void AppendPieces(std::string* dest,
  322|       |                  std::initializer_list<absl::string_view> pieces);
  323|       |
  324|       |}  // namespace strings_internal
  325|       |
  326|      0|ABSL_MUST_USE_RESULT inline std::string StrCat() { return std::string(); }
  327|       |
  328|      0|ABSL_MUST_USE_RESULT inline std::string StrCat(const AlphaNum& a) {
  329|      0|  return std::string(a.data(), a.size());
  330|      0|}
  331|       |
  332|       |ABSL_MUST_USE_RESULT std::string StrCat(const AlphaNum& a, const AlphaNum& b);
  333|       |ABSL_MUST_USE_RESULT std::string StrCat(const AlphaNum& a, const AlphaNum& b,
  334|       |                                        const AlphaNum& c);
  335|       |ABSL_MUST_USE_RESULT std::string StrCat(const AlphaNum& a, const AlphaNum& b,
  336|       |                                        const AlphaNum& c, const AlphaNum& d);
  337|       |
  338|       |// Support 5 or more arguments
  339|       |template <typename... AV>
  340|       |ABSL_MUST_USE_RESULT inline std::string StrCat(
  341|       |    const AlphaNum& a, const AlphaNum& b, const AlphaNum& c, const AlphaNum& d,
  342|       |    const AlphaNum& e, const AV&... args) {
  343|       |  return strings_internal::CatPieces(
  344|       |      {a.Piece(), b.Piece(), c.Piece(), d.Piece(), e.Piece(),
  345|       |       static_cast<const AlphaNum&>(args).Piece()...});
  346|       |}
  347|       |
  348|       |// -----------------------------------------------------------------------------
  349|       |// StrAppend()
  350|       |// -----------------------------------------------------------------------------
  351|       |//
  352|       |// Appends a string or set of strings to an existing string, in a similar
  353|       |// fashion to `StrCat()`.
  354|       |//
  355|       |// WARNING: `StrAppend(&str, a, b, c, ...)` requires that none of the
  356|       |// a, b, c, parameters be a reference into str. For speed, `StrAppend()` does
  357|       |// not try to check each of its input arguments to be sure that they are not
  358|       |// a subset of the string being appended to. That is, while this will work:
  359|       |//
  360|       |//   std::string s = "foo";
  361|       |//   s += s;
  362|       |//
  363|       |// This output is undefined:
  364|       |//
  365|       |//   std::string s = "foo";
  366|       |//   StrAppend(&s, s);
  367|       |//
  368|       |// This output is undefined as well, since `absl::string_view` does not own its
  369|       |// data:
  370|       |//
  371|       |//   std::string s = "foobar";
  372|       |//   absl::string_view p = s;
  373|       |//   StrAppend(&s, p);
  374|       |
  375|      0|inline void StrAppend(std::string*) {}
  376|       |void StrAppend(std::string* dest, const AlphaNum& a);
  377|       |void StrAppend(std::string* dest, const AlphaNum& a, const AlphaNum& b);
  378|       |void StrAppend(std::string* dest, const AlphaNum& a, const AlphaNum& b,
  379|       |               const AlphaNum& c);
  380|       |void StrAppend(std::string* dest, const AlphaNum& a, const AlphaNum& b,
  381|       |               const AlphaNum& c, const AlphaNum& d);
  382|       |
  383|       |// Support 5 or more arguments
  384|       |template <typename... AV>
  385|       |inline void StrAppend(std::string* dest, const AlphaNum& a, const AlphaNum& b,
  386|       |                      const AlphaNum& c, const AlphaNum& d, const AlphaNum& e,
  387|       |                      const AV&... args) {
  388|       |  strings_internal::AppendPieces(
  389|       |      dest, {a.Piece(), b.Piece(), c.Piece(), d.Piece(), e.Piece(),
  390|       |             static_cast<const AlphaNum&>(args).Piece()...});
  391|       |}
  392|       |
  393|       |// Helper function for the future StrCat default floating-point format, %.6g
  394|       |// This is fast.
  395|       |inline strings_internal::AlphaNumBuffer<
  396|       |    numbers_internal::kSixDigitsToBufferSize>
  397|      0|SixDigits(double d) {
  398|      0|  strings_internal::AlphaNumBuffer<numbers_internal::kSixDigitsToBufferSize>
  399|      0|      result;
  400|      0|  result.size = numbers_internal::SixDigitsToBuffer(d, &result.data[0]);
  401|      0|  return result;
  402|      0|}
  403|       |
  404|       |}  // inline namespace lts_2019_08_08
  405|       |}  // namespace absl
  406|       |
  407|       |#endif  // ABSL_STRINGS_STR_CAT_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/str_join.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: str_join.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This header file contains functions for joining a range of elements and
   21|       |// returning the result as a std::string. StrJoin operations are specified by
   22|       |// passing a range, a separator string to use between the elements joined, and
   23|       |// an optional Formatter responsible for converting each argument in the range
   24|       |// to a string. If omitted, a default `AlphaNumFormatter()` is called on the
   25|       |// elements to be joined, using the same formatting that `absl::StrCat()` uses.
   26|       |// This package defines a number of default formatters, and you can define your
   27|       |// own implementations.
   28|       |//
   29|       |// Ranges are specified by passing a container with `std::begin()` and
   30|       |// `std::end()` iterators, container-specific `begin()` and `end()` iterators, a
   31|       |// brace-initialized `std::initializer_list`, or a `std::tuple` of heterogeneous
   32|       |// objects. The separator string is specified as an `absl::string_view`.
   33|       |//
   34|       |// Because the default formatter uses the `absl::AlphaNum` class,
   35|       |// `absl::StrJoin()`, like `absl::StrCat()`, will work out-of-the-box on
   36|       |// collections of strings, ints, floats, doubles, etc.
   37|       |//
   38|       |// Example:
   39|       |//
   40|       |//   std::vector<std::string> v = {"foo", "bar", "baz"};
   41|       |//   std::string s = absl::StrJoin(v, "-");
   42|       |//   EXPECT_EQ("foo-bar-baz", s);
   43|       |//
   44|       |// See comments on the `absl::StrJoin()` function for more examples.
   45|       |
   46|       |#ifndef ABSL_STRINGS_STR_JOIN_H_
   47|       |#define ABSL_STRINGS_STR_JOIN_H_
   48|       |
   49|       |#include <cstdio>
   50|       |#include <cstring>
   51|       |#include <initializer_list>
   52|       |#include <iterator>
   53|       |#include <string>
   54|       |#include <tuple>
   55|       |#include <type_traits>
   56|       |#include <utility>
   57|       |
   58|       |#include "absl/base/macros.h"
   59|       |#include "absl/strings/internal/str_join_internal.h"
   60|       |#include "absl/strings/string_view.h"
   61|       |
   62|       |namespace absl {
   63|       |inline namespace lts_2019_08_08 {
   64|       |
   65|       |// -----------------------------------------------------------------------------
   66|       |// Concept: Formatter
   67|       |// -----------------------------------------------------------------------------
   68|       |//
   69|       |// A Formatter is a function object that is responsible for formatting its
   70|       |// argument as a string and appending it to a given output std::string.
   71|       |// Formatters may be implemented as function objects, lambdas, or normal
   72|       |// functions. You may provide your own Formatter to enable `absl::StrJoin()` to
   73|       |// work with arbitrary types.
   74|       |//
   75|       |// The following is an example of a custom Formatter that simply uses
   76|       |// `std::to_string()` to format an integer as a std::string.
   77|       |//
   78|       |//   struct MyFormatter {
   79|       |//     void operator()(std::string* out, int i) const {
   80|       |//       out->append(std::to_string(i));
   81|       |//     }
   82|       |//   };
   83|       |//
   84|       |// You would use the above formatter by passing an instance of it as the final
   85|       |// argument to `absl::StrJoin()`:
   86|       |//
   87|       |//   std::vector<int> v = {1, 2, 3, 4};
   88|       |//   std::string s = absl::StrJoin(v, "-", MyFormatter());
   89|       |//   EXPECT_EQ("1-2-3-4", s);
   90|       |//
   91|       |// The following standard formatters are provided within this file:
   92|       |//
   93|       |// - `AlphaNumFormatter()` (the default)
   94|       |// - `StreamFormatter()`
   95|       |// - `PairFormatter()`
   96|       |// - `DereferenceFormatter()`
   97|       |
   98|       |// AlphaNumFormatter()
   99|       |//
  100|       |// Default formatter used if none is specified. Uses `absl::AlphaNum` to convert
  101|       |// numeric arguments to strings.
  102|      0|inline strings_internal::AlphaNumFormatterImpl AlphaNumFormatter() {
  103|      0|  return strings_internal::AlphaNumFormatterImpl();
  104|      0|}
  105|       |
  106|       |// StreamFormatter()
  107|       |//
  108|       |// Formats its argument using the << operator.
  109|      0|inline strings_internal::StreamFormatterImpl StreamFormatter() {
  110|      0|  return strings_internal::StreamFormatterImpl();
  111|      0|}
  112|       |
  113|       |// Function Template: PairFormatter(Formatter, absl::string_view, Formatter)
  114|       |//
  115|       |// Formats a `std::pair` by putting a given separator between the pair's
  116|       |// `.first` and `.second` members. This formatter allows you to specify
  117|       |// custom Formatters for both the first and second member of each pair.
  118|       |template <typename FirstFormatter, typename SecondFormatter>
  119|       |inline strings_internal::PairFormatterImpl<FirstFormatter, SecondFormatter>
  120|      0|PairFormatter(FirstFormatter f1, absl::string_view sep, SecondFormatter f2) {
  121|      0|  return strings_internal::PairFormatterImpl<FirstFormatter, SecondFormatter>(
  122|      0|      std::move(f1), sep, std::move(f2));
  123|      0|}
  124|       |
  125|       |// Function overload of PairFormatter() for using a default
  126|       |// `AlphaNumFormatter()` for each Formatter in the pair.
  127|       |inline strings_internal::PairFormatterImpl<
  128|       |    strings_internal::AlphaNumFormatterImpl,
  129|       |    strings_internal::AlphaNumFormatterImpl>
  130|      0|PairFormatter(absl::string_view sep) {
  131|      0|  return PairFormatter(AlphaNumFormatter(), sep, AlphaNumFormatter());
  132|      0|}
  133|       |
  134|       |// Function Template: DereferenceFormatter(Formatter)
  135|       |//
  136|       |// Formats its argument by dereferencing it and then applying the given
  137|       |// formatter. This formatter is useful for formatting a container of
  138|       |// pointer-to-T. This pattern often shows up when joining repeated fields in
  139|       |// protocol buffers.
  140|       |template <typename Formatter>
  141|       |strings_internal::DereferenceFormatterImpl<Formatter> DereferenceFormatter(
  142|       |    Formatter&& f) {
  143|       |  return strings_internal::DereferenceFormatterImpl<Formatter>(
  144|       |      std::forward<Formatter>(f));
  145|       |}
  146|       |
  147|       |// Function overload of `DererefenceFormatter()` for using a default
  148|       |// `AlphaNumFormatter()`.
  149|       |inline strings_internal::DereferenceFormatterImpl<
  150|       |    strings_internal::AlphaNumFormatterImpl>
  151|      0|DereferenceFormatter() {
  152|      0|  return strings_internal::DereferenceFormatterImpl<
  153|      0|      strings_internal::AlphaNumFormatterImpl>(AlphaNumFormatter());
  154|      0|}
  155|       |
  156|       |// -----------------------------------------------------------------------------
  157|       |// StrJoin()
  158|       |// -----------------------------------------------------------------------------
  159|       |//
  160|       |// Joins a range of elements and returns the result as a std::string.
  161|       |// `absl::StrJoin()` takes a range, a separator string to use between the
  162|       |// elements joined, and an optional Formatter responsible for converting each
  163|       |// argument in the range to a string.
  164|       |//
  165|       |// If omitted, the default `AlphaNumFormatter()` is called on the elements to be
  166|       |// joined.
  167|       |//
  168|       |// Example 1:
  169|       |//   // Joins a collection of strings. This pattern also works with a collection
  170|       |//   // of `absl::string_view` or even `const char*`.
  171|       |//   std::vector<std::string> v = {"foo", "bar", "baz"};
  172|       |//   std::string s = absl::StrJoin(v, "-");
  173|       |//   EXPECT_EQ("foo-bar-baz", s);
  174|       |//
  175|       |// Example 2:
  176|       |//   // Joins the values in the given `std::initializer_list<>` specified using
  177|       |//   // brace initialization. This pattern also works with an initializer_list
  178|       |//   // of ints or `absl::string_view` -- any `AlphaNum`-compatible type.
  179|       |//   std::string s = absl::StrJoin({"foo", "bar", "baz"}, "-");
  180|       |//   EXPECT_EQ("foo-bar-baz", s);
  181|       |//
  182|       |// Example 3:
  183|       |//   // Joins a collection of ints. This pattern also works with floats,
  184|       |//   // doubles, int64s -- any `StrCat()`-compatible type.
  185|       |//   std::vector<int> v = {1, 2, 3, -4};
  186|       |//   std::string s = absl::StrJoin(v, "-");
  187|       |//   EXPECT_EQ("1-2-3--4", s);
  188|       |//
  189|       |// Example 4:
  190|       |//   // Joins a collection of pointer-to-int. By default, pointers are
  191|       |//   // dereferenced and the pointee is formatted using the default format for
  192|       |//   // that type; such dereferencing occurs for all levels of indirection, so
  193|       |//   // this pattern works just as well for `std::vector<int**>` as for
  194|       |//   // `std::vector<int*>`.
  195|       |//   int x = 1, y = 2, z = 3;
  196|       |//   std::vector<int*> v = {&x, &y, &z};
  197|       |//   std::string s = absl::StrJoin(v, "-");
  198|       |//   EXPECT_EQ("1-2-3", s);
  199|       |//
  200|       |// Example 5:
  201|       |//   // Dereferencing of `std::unique_ptr<>` is also supported:
  202|       |//   std::vector<std::unique_ptr<int>> v
  203|       |//   v.emplace_back(new int(1));
  204|       |//   v.emplace_back(new int(2));
  205|       |//   v.emplace_back(new int(3));
  206|       |//   std::string s = absl::StrJoin(v, "-");
  207|       |//   EXPECT_EQ("1-2-3", s);
  208|       |//
  209|       |// Example 6:
  210|       |//   // Joins a `std::map`, with each key-value pair separated by an equals
  211|       |//   // sign. This pattern would also work with, say, a
  212|       |//   // `std::vector<std::pair<>>`.
  213|       |//   std::map<std::string, int> m = {
  214|       |//       std::make_pair("a", 1),
  215|       |//       std::make_pair("b", 2),
  216|       |//       std::make_pair("c", 3)};
  217|       |//   std::string s = absl::StrJoin(m, ",", absl::PairFormatter("="));
  218|       |//   EXPECT_EQ("a=1,b=2,c=3", s);
  219|       |//
  220|       |// Example 7:
  221|       |//   // These examples show how `absl::StrJoin()` handles a few common edge
  222|       |//   // cases:
  223|       |//   std::vector<std::string> v_empty;
  224|       |//   EXPECT_EQ("", absl::StrJoin(v_empty, "-"));
  225|       |//
  226|       |//   std::vector<std::string> v_one_item = {"foo"};
  227|       |//   EXPECT_EQ("foo", absl::StrJoin(v_one_item, "-"));
  228|       |//
  229|       |//   std::vector<std::string> v_empty_string = {""};
  230|       |//   EXPECT_EQ("", absl::StrJoin(v_empty_string, "-"));
  231|       |//
  232|       |//   std::vector<std::string> v_one_item_empty_string = {"a", ""};
  233|       |//   EXPECT_EQ("a-", absl::StrJoin(v_one_item_empty_string, "-"));
  234|       |//
  235|       |//   std::vector<std::string> v_two_empty_string = {"", ""};
  236|       |//   EXPECT_EQ("-", absl::StrJoin(v_two_empty_string, "-"));
  237|       |//
  238|       |// Example 8:
  239|       |//   // Joins a `std::tuple<T...>` of heterogeneous types, converting each to
  240|       |//   // a std::string using the `absl::AlphaNum` class.
  241|       |//   std::string s = absl::StrJoin(std::make_tuple(123, "abc", 0.456), "-");
  242|       |//   EXPECT_EQ("123-abc-0.456", s);
  243|       |
  244|       |template <typename Iterator, typename Formatter>
  245|       |std::string StrJoin(Iterator start, Iterator end, absl::string_view sep,
  246|       |                    Formatter&& fmt) {
  247|       |  return strings_internal::JoinAlgorithm(start, end, sep, fmt);
  248|       |}
  249|       |
  250|       |template <typename Range, typename Formatter>
  251|       |std::string StrJoin(const Range& range, absl::string_view separator,
  252|       |                    Formatter&& fmt) {
  253|       |  return strings_internal::JoinRange(range, separator, fmt);
  254|       |}
  255|       |
  256|       |template <typename T, typename Formatter>
  257|       |std::string StrJoin(std::initializer_list<T> il, absl::string_view separator,
  258|       |                    Formatter&& fmt) {
  259|       |  return strings_internal::JoinRange(il, separator, fmt);
  260|       |}
  261|       |
  262|       |template <typename... T, typename Formatter>
  263|       |std::string StrJoin(const std::tuple<T...>& value, absl::string_view separator,
  264|       |                    Formatter&& fmt) {
  265|       |  return strings_internal::JoinAlgorithm(value, separator, fmt);
  266|       |}
  267|       |
  268|       |template <typename Iterator>
  269|       |std::string StrJoin(Iterator start, Iterator end, absl::string_view separator) {
  270|       |  return strings_internal::JoinRange(start, end, separator);
  271|       |}
  272|       |
  273|       |template <typename Range>
  274|       |std::string StrJoin(const Range& range, absl::string_view separator) {
  275|       |  return strings_internal::JoinRange(range, separator);
  276|       |}
  277|       |
  278|       |template <typename T>
  279|       |std::string StrJoin(std::initializer_list<T> il,
  280|       |                    absl::string_view separator) {
  281|       |  return strings_internal::JoinRange(il, separator);
  282|       |}
  283|       |
  284|       |template <typename... T>
  285|       |std::string StrJoin(const std::tuple<T...>& value,
  286|       |                    absl::string_view separator) {
  287|       |  return strings_internal::JoinAlgorithm(value, separator, AlphaNumFormatter());
  288|       |}
  289|       |
  290|       |}  // inline namespace lts_2019_08_08
  291|       |}  // namespace absl
  292|       |
  293|       |#endif  // ABSL_STRINGS_STR_JOIN_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/str_replace.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/str_replace.h"
   16|       |
   17|       |#include "absl/strings/str_cat.h"
   18|       |
   19|       |namespace absl {
   20|       |inline namespace lts_2019_08_08 {
   21|       |namespace strings_internal {
   22|       |
   23|       |using FixedMapping =
   24|       |    std::initializer_list<std::pair<absl::string_view, absl::string_view>>;
   25|       |
   26|       |// Applies the ViableSubstitutions in subs_ptr to the absl::string_view s, and
   27|       |// stores the result in *result_ptr. Returns the number of substitutions that
   28|       |// occurred.
   29|       |int ApplySubstitutions(
   30|       |    absl::string_view s,
   31|       |    std::vector<strings_internal::ViableSubstitution>* subs_ptr,
   32|      0|    std::string* result_ptr) {
   33|      0|  auto& subs = *subs_ptr;
   34|      0|  int substitutions = 0;
   35|      0|  size_t pos = 0;
   36|      0|  while (!subs.empty()) {
   37|      0|    auto& sub = subs.back();
   38|      0|    if (sub.offset >= pos) {
   39|      0|      if (pos <= s.size()) {
   40|      0|        StrAppend(result_ptr, s.substr(pos, sub.offset - pos), sub.replacement);
   41|      0|      }
   42|      0|      pos = sub.offset + sub.old.size();
   43|      0|      substitutions += 1;
   44|      0|    }
   45|      0|    sub.offset = s.find(sub.old, pos);
   46|      0|    if (sub.offset == s.npos) {
   47|      0|      subs.pop_back();
   48|      0|    } else {
   49|      0|      // Insertion sort to ensure the last ViableSubstitution continues to be
   50|      0|      // before all the others.
   51|      0|      size_t index = subs.size();
   52|      0|      while (--index && subs[index - 1].OccursBefore(subs[index])) {
   53|      0|        std::swap(subs[index], subs[index - 1]);
   54|      0|      }
   55|      0|    }
   56|      0|  }
   57|      0|  result_ptr->append(s.data() + pos, s.size() - pos);
   58|      0|  return substitutions;
   59|      0|}
   60|       |
   61|       |}  // namespace strings_internal
   62|       |
   63|       |// We can implement this in terms of the generic StrReplaceAll, but
   64|       |// we must specify the template overload because C++ cannot deduce the type
   65|       |// of an initializer_list parameter to a function, and also if we don't specify
   66|       |// the type, we just call ourselves.
   67|       |//
   68|       |// Note that we implement them here, rather than in the header, so that they
   69|       |// aren't inlined.
   70|       |
   71|       |std::string StrReplaceAll(absl::string_view s,
   72|      0|                          strings_internal::FixedMapping replacements) {
   73|      0|  return StrReplaceAll<strings_internal::FixedMapping>(s, replacements);
   74|      0|}
   75|       |
   76|       |int StrReplaceAll(strings_internal::FixedMapping replacements,
   77|      0|                  std::string* target) {
   78|      0|  return StrReplaceAll<strings_internal::FixedMapping>(replacements, target);
   79|      0|}
   80|       |
   81|       |}  // inline namespace lts_2019_08_08
   82|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/str_replace.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: str_replace.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This file defines `absl::StrReplaceAll()`, a general-purpose string
   21|       |// replacement function designed for large, arbitrary text substitutions,
   22|       |// especially on strings which you are receiving from some other system for
   23|       |// further processing (e.g. processing regular expressions, escaping HTML
   24|       |// entities, etc.). `StrReplaceAll` is designed to be efficient even when only
   25|       |// one substitution is being performed, or when substitution is rare.
   26|       |//
   27|       |// If the string being modified is known at compile-time, and the substitutions
   28|       |// vary, `absl::Substitute()` may be a better choice.
   29|       |//
   30|       |// Example:
   31|       |//
   32|       |// std::string html_escaped = absl::StrReplaceAll(user_input, {
   33|       |//                                                {"&", "&amp;"},
   34|       |//                                                {"<", "&lt;"},
   35|       |//                                                {">", "&gt;"},
   36|       |//                                                {"\"", "&quot;"},
   37|       |//                                                {"'", "&#39;"}});
   38|       |#ifndef ABSL_STRINGS_STR_REPLACE_H_
   39|       |#define ABSL_STRINGS_STR_REPLACE_H_
   40|       |
   41|       |#include <string>
   42|       |#include <utility>
   43|       |#include <vector>
   44|       |
   45|       |#include "absl/base/attributes.h"
   46|       |#include "absl/strings/string_view.h"
   47|       |
   48|       |namespace absl {
   49|       |inline namespace lts_2019_08_08 {
   50|       |
   51|       |// StrReplaceAll()
   52|       |//
   53|       |// Replaces character sequences within a given string with replacements provided
   54|       |// within an initializer list of key/value pairs. Candidate replacements are
   55|       |// considered in order as they occur within the string, with earlier matches
   56|       |// taking precedence, and longer matches taking precedence for candidates
   57|       |// starting at the same position in the string. Once a substitution is made, the
   58|       |// replaced text is not considered for any further substitutions.
   59|       |//
   60|       |// Example:
   61|       |//
   62|       |//   std::string s = absl::StrReplaceAll(
   63|       |//       "$who bought $count #Noun. Thanks $who!",
   64|       |//       {{"$count", absl::StrCat(5)},
   65|       |//        {"$who", "Bob"},
   66|       |//        {"#Noun", "Apples"}});
   67|       |//   EXPECT_EQ("Bob bought 5 Apples. Thanks Bob!", s);
   68|       |ABSL_MUST_USE_RESULT std::string StrReplaceAll(
   69|       |    absl::string_view s,
   70|       |    std::initializer_list<std::pair<absl::string_view, absl::string_view>>
   71|       |        replacements);
   72|       |
   73|       |// Overload of `StrReplaceAll()` to accept a container of key/value replacement
   74|       |// pairs (typically either an associative map or a `std::vector` of `std::pair`
   75|       |// elements). A vector of pairs is generally more efficient.
   76|       |//
   77|       |// Examples:
   78|       |//
   79|       |//   std::map<const absl::string_view, const absl::string_view> replacements;
   80|       |//   replacements["$who"] = "Bob";
   81|       |//   replacements["$count"] = "5";
   82|       |//   replacements["#Noun"] = "Apples";
   83|       |//   std::string s = absl::StrReplaceAll(
   84|       |//       "$who bought $count #Noun. Thanks $who!",
   85|       |//       replacements);
   86|       |//   EXPECT_EQ("Bob bought 5 Apples. Thanks Bob!", s);
   87|       |//
   88|       |//   // A std::vector of std::pair elements can be more efficient.
   89|       |//   std::vector<std::pair<const absl::string_view, std::string>> replacements;
   90|       |//   replacements.push_back({"&", "&amp;"});
   91|       |//   replacements.push_back({"<", "&lt;"});
   92|       |//   replacements.push_back({">", "&gt;"});
   93|       |//   std::string s = absl::StrReplaceAll("if (ptr < &foo)",
   94|       |//                                  replacements);
   95|       |//   EXPECT_EQ("if (ptr &lt; &amp;foo)", s);
   96|       |template <typename StrToStrMapping>
   97|       |std::string StrReplaceAll(absl::string_view s,
   98|       |                          const StrToStrMapping& replacements);
   99|       |
  100|       |// Overload of `StrReplaceAll()` to replace character sequences within a given
  101|       |// output string *in place* with replacements provided within an initializer
  102|       |// list of key/value pairs, returning the number of substitutions that occurred.
  103|       |//
  104|       |// Example:
  105|       |//
  106|       |//   std::string s = std::string("$who bought $count #Noun. Thanks $who!");
  107|       |//   int count;
  108|       |//   count = absl::StrReplaceAll({{"$count", absl::StrCat(5)},
  109|       |//                               {"$who", "Bob"},
  110|       |//                               {"#Noun", "Apples"}}, &s);
  111|       |//  EXPECT_EQ(count, 4);
  112|       |//  EXPECT_EQ("Bob bought 5 Apples. Thanks Bob!", s);
  113|       |int StrReplaceAll(
  114|       |    std::initializer_list<std::pair<absl::string_view, absl::string_view>>
  115|       |        replacements,
  116|       |    std::string* target);
  117|       |
  118|       |// Overload of `StrReplaceAll()` to replace patterns within a given output
  119|       |// string *in place* with replacements provided within a container of key/value
  120|       |// pairs.
  121|       |//
  122|       |// Example:
  123|       |//
  124|       |//   std::string s = std::string("if (ptr < &foo)");
  125|       |//   int count = absl::StrReplaceAll({{"&", "&amp;"},
  126|       |//                                    {"<", "&lt;"},
  127|       |//                                    {">", "&gt;"}}, &s);
  128|       |//  EXPECT_EQ(count, 2);
  129|       |//  EXPECT_EQ("if (ptr &lt; &amp;foo)", s);
  130|       |template <typename StrToStrMapping>
  131|       |int StrReplaceAll(const StrToStrMapping& replacements, std::string* target);
  132|       |
  133|       |// Implementation details only, past this point.
  134|       |namespace strings_internal {
  135|       |
  136|       |struct ViableSubstitution {
  137|       |  absl::string_view old;
  138|       |  absl::string_view replacement;
  139|       |  size_t offset;
  140|       |
  141|       |  ViableSubstitution(absl::string_view old_str,
  142|       |                     absl::string_view replacement_str, size_t offset_val)
  143|      0|      : old(old_str), replacement(replacement_str), offset(offset_val) {}
  144|       |
  145|       |  // One substitution occurs "before" another (takes priority) if either
  146|       |  // it has the lowest offset, or it has the same offset but a larger size.
  147|      0|  bool OccursBefore(const ViableSubstitution& y) const {
  148|      0|    if (offset != y.offset) return offset < y.offset;
  149|      0|    return old.size() > y.old.size();
  150|      0|  }
  151|       |};
  152|       |
  153|       |// Build a vector of ViableSubstitutions based on the given list of
  154|       |// replacements. subs can be implemented as a priority_queue. However, it turns
  155|       |// out that most callers have small enough a list of substitutions that the
  156|       |// overhead of such a queue isn't worth it.
  157|       |template <typename StrToStrMapping>
  158|       |std::vector<ViableSubstitution> FindSubstitutions(
  159|      0|    absl::string_view s, const StrToStrMapping& replacements) {
  160|      0|  std::vector<ViableSubstitution> subs;
  161|      0|  subs.reserve(replacements.size());
  162|      0|
  163|      0|  for (const auto& rep : replacements) {
  164|      0|    using std::get;
  165|      0|    absl::string_view old(get<0>(rep));
  166|      0|
  167|      0|    size_t pos = s.find(old);
  168|      0|    if (pos == s.npos) continue;
  169|      0|
  170|      0|    // Ignore attempts to replace "". This condition is almost never true,
  171|      0|    // but above condition is frequently true. That's why we test for this
  172|      0|    // now and not before.
  173|      0|    if (old.empty()) continue;
  174|      0|
  175|      0|    subs.emplace_back(old, get<1>(rep), pos);
  176|      0|
  177|      0|    // Insertion sort to ensure the last ViableSubstitution comes before
  178|      0|    // all the others.
  179|      0|    size_t index = subs.size();
  180|      0|    while (--index && subs[index - 1].OccursBefore(subs[index])) {
  181|      0|      std::swap(subs[index], subs[index - 1]);
  182|      0|    }
  183|      0|  }
  184|      0|  return subs;
  185|      0|}
  186|       |
  187|       |int ApplySubstitutions(absl::string_view s,
  188|       |                       std::vector<ViableSubstitution>* subs_ptr,
  189|       |                       std::string* result_ptr);
  190|       |
  191|       |}  // namespace strings_internal
  192|       |
  193|       |template <typename StrToStrMapping>
  194|       |std::string StrReplaceAll(absl::string_view s,
  195|      0|                          const StrToStrMapping& replacements) {
  196|      0|  auto subs = strings_internal::FindSubstitutions(s, replacements);
  197|      0|  std::string result;
  198|      0|  result.reserve(s.size());
  199|      0|  strings_internal::ApplySubstitutions(s, &subs, &result);
  200|      0|  return result;
  201|      0|}
  202|       |
  203|       |template <typename StrToStrMapping>
  204|      0|int StrReplaceAll(const StrToStrMapping& replacements, std::string* target) {
  205|      0|  auto subs = strings_internal::FindSubstitutions(*target, replacements);
  206|      0|  if (subs.empty()) return 0;
  207|      0|
  208|      0|  std::string result;
  209|      0|  result.reserve(target->size());
  210|      0|  int substitutions =
  211|      0|      strings_internal::ApplySubstitutions(*target, &subs, &result);
  212|      0|  target->swap(result);
  213|      0|  return substitutions;
  214|      0|}
  215|       |
  216|       |}  // inline namespace lts_2019_08_08
  217|       |}  // namespace absl
  218|       |
  219|       |#endif  // ABSL_STRINGS_STR_REPLACE_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/str_split.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/str_split.h"
   16|       |
   17|       |#include <algorithm>
   18|       |#include <cassert>
   19|       |#include <cstdint>
   20|       |#include <cstdlib>
   21|       |#include <cstring>
   22|       |#include <iterator>
   23|       |#include <limits>
   24|       |#include <memory>
   25|       |
   26|       |#include "absl/base/internal/raw_logging.h"
   27|       |#include "absl/strings/ascii.h"
   28|       |
   29|       |namespace absl {
   30|       |inline namespace lts_2019_08_08 {
   31|       |
   32|       |namespace {
   33|       |
   34|       |// This GenericFind() template function encapsulates the finding algorithm
   35|       |// shared between the ByString and ByAnyChar delimiters. The FindPolicy
   36|       |// template parameter allows each delimiter to customize the actual find
   37|       |// function to use and the length of the found delimiter. For example, the
   38|       |// Literal delimiter will ultimately use absl::string_view::find(), and the
   39|       |// AnyOf delimiter will use absl::string_view::find_first_of().
   40|       |template <typename FindPolicy>
   41|       |absl::string_view GenericFind(absl::string_view text,
   42|       |                              absl::string_view delimiter, size_t pos,
   43|      0|                              FindPolicy find_policy) {
   44|      0|  if (delimiter.empty() && text.length() > 0) {
   45|      0|    // Special case for empty std::string delimiters: always return a zero-length
   46|      0|    // absl::string_view referring to the item at position 1 past pos.
   47|      0|    return absl::string_view(text.data() + pos + 1, 0);
   48|      0|  }
   49|      0|  size_t found_pos = absl::string_view::npos;
   50|      0|  absl::string_view found(text.data() + text.size(),
   51|      0|                          0);  // By default, not found
   52|      0|  found_pos = find_policy.Find(text, delimiter, pos);
   53|      0|  if (found_pos != absl::string_view::npos) {
   54|      0|    found = absl::string_view(text.data() + found_pos,
   55|      0|                              find_policy.Length(delimiter));
   56|      0|  }
   57|      0|  return found;
   58|      0|}
  ------------------
  | Unexecuted instantiation: str_split.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_111GenericFindINS1_13LiteralPolicyEEENS0_11string_viewES4_S4_mT_
  ------------------
  | Unexecuted instantiation: str_split.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_111GenericFindINS1_11AnyOfPolicyEEENS0_11string_viewES4_S4_mT_
  ------------------
   59|       |
   60|       |// Finds using absl::string_view::find(), therefore the length of the found
   61|       |// delimiter is delimiter.length().
   62|       |struct LiteralPolicy {
   63|      0|  size_t Find(absl::string_view text, absl::string_view delimiter, size_t pos) {
   64|      0|    return text.find(delimiter, pos);
   65|      0|  }
   66|      0|  size_t Length(absl::string_view delimiter) { return delimiter.length(); }
   67|       |};
   68|       |
   69|       |// Finds using absl::string_view::find_first_of(), therefore the length of the
   70|       |// found delimiter is 1.
   71|       |struct AnyOfPolicy {
   72|      0|  size_t Find(absl::string_view text, absl::string_view delimiter, size_t pos) {
   73|      0|    return text.find_first_of(delimiter, pos);
   74|      0|  }
   75|      0|  size_t Length(absl::string_view /* delimiter */) { return 1; }
   76|       |};
   77|       |
   78|       |}  // namespace
   79|       |
   80|       |//
   81|       |// ByString
   82|       |//
   83|       |
   84|      0|ByString::ByString(absl::string_view sp) : delimiter_(sp) {}
   85|       |
   86|      0|absl::string_view ByString::Find(absl::string_view text, size_t pos) const {
   87|      0|  if (delimiter_.length() == 1) {
   88|      0|    // Much faster to call find on a single character than on an
   89|      0|    // absl::string_view.
   90|      0|    size_t found_pos = text.find(delimiter_[0], pos);
   91|      0|    if (found_pos == absl::string_view::npos)
   92|      0|      return absl::string_view(text.data() + text.size(), 0);
   93|      0|    return text.substr(found_pos, 1);
   94|      0|  }
   95|      0|  return GenericFind(text, delimiter_, pos, LiteralPolicy());
   96|      0|}
   97|       |
   98|       |//
   99|       |// ByChar
  100|       |//
  101|       |
  102|      0|absl::string_view ByChar::Find(absl::string_view text, size_t pos) const {
  103|      0|  size_t found_pos = text.find(c_, pos);
  104|      0|  if (found_pos == absl::string_view::npos)
  105|      0|    return absl::string_view(text.data() + text.size(), 0);
  106|      0|  return text.substr(found_pos, 1);
  107|      0|}
  108|       |
  109|       |//
  110|       |// ByAnyChar
  111|       |//
  112|       |
  113|      0|ByAnyChar::ByAnyChar(absl::string_view sp) : delimiters_(sp) {}
  114|       |
  115|      0|absl::string_view ByAnyChar::Find(absl::string_view text, size_t pos) const {
  116|      0|  return GenericFind(text, delimiters_, pos, AnyOfPolicy());
  117|      0|}
  118|       |
  119|       |//
  120|       |// ByLength
  121|       |//
  122|      0|ByLength::ByLength(ptrdiff_t length) : length_(length) {
  123|      0|  ABSL_RAW_CHECK(length > 0, "");
  124|      0|}
  125|       |
  126|       |absl::string_view ByLength::Find(absl::string_view text,
  127|      0|                                      size_t pos) const {
  128|      0|  pos = std::min(pos, text.size());  // truncate `pos`
  129|      0|  absl::string_view substr = text.substr(pos);
  130|      0|  // If the std::string is shorter than the chunk size we say we
  131|      0|  // "can't find the delimiter" so this will be the last chunk.
  132|      0|  if (substr.length() <= static_cast<size_t>(length_))
  133|      0|    return absl::string_view(text.data() + text.size(), 0);
  134|      0|
  135|      0|  return absl::string_view(substr.data() + length_, 0);
  136|      0|}
  137|       |
  138|       |}  // inline namespace lts_2019_08_08
  139|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/str_split.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: str_split.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This file contains functions for splitting strings. It defines the main
   21|       |// `StrSplit()` function, several delimiters for determining the boundaries on
   22|       |// which to split the string, and predicates for filtering delimited results.
   23|       |// `StrSplit()` adapts the returned collection to the type specified by the
   24|       |// caller.
   25|       |//
   26|       |// Example:
   27|       |//
   28|       |//   // Splits the given string on commas. Returns the results in a
   29|       |//   // vector of strings.
   30|       |//   std::vector<std::string> v = absl::StrSplit("a,b,c", ',');
   31|       |//   // Can also use ","
   32|       |//   // v[0] == "a", v[1] == "b", v[2] == "c"
   33|       |//
   34|       |// See StrSplit() below for more information.
   35|       |#ifndef ABSL_STRINGS_STR_SPLIT_H_
   36|       |#define ABSL_STRINGS_STR_SPLIT_H_
   37|       |
   38|       |#include <algorithm>
   39|       |#include <cstddef>
   40|       |#include <map>
   41|       |#include <set>
   42|       |#include <string>
   43|       |#include <utility>
   44|       |#include <vector>
   45|       |
   46|       |#include "absl/base/internal/raw_logging.h"
   47|       |#include "absl/strings/internal/str_split_internal.h"
   48|       |#include "absl/strings/string_view.h"
   49|       |#include "absl/strings/strip.h"
   50|       |
   51|       |namespace absl {
   52|       |inline namespace lts_2019_08_08 {
   53|       |
   54|       |//------------------------------------------------------------------------------
   55|       |// Delimiters
   56|       |//------------------------------------------------------------------------------
   57|       |//
   58|       |// `StrSplit()` uses delimiters to define the boundaries between elements in the
   59|       |// provided input. Several `Delimiter` types are defined below. If a string
   60|       |// (`const char*`, `std::string`, or `absl::string_view`) is passed in place of
   61|       |// an explicit `Delimiter` object, `StrSplit()` treats it the same way as if it
   62|       |// were passed a `ByString` delimiter.
   63|       |//
   64|       |// A `Delimiter` is an object with a `Find()` function that knows how to find
   65|       |// the first occurrence of itself in a given `absl::string_view`.
   66|       |//
   67|       |// The following `Delimiter` types are available for use within `StrSplit()`:
   68|       |//
   69|       |//   - `ByString` (default for string arguments)
   70|       |//   - `ByChar` (default for a char argument)
   71|       |//   - `ByAnyChar`
   72|       |//   - `ByLength`
   73|       |//   - `MaxSplits`
   74|       |//
   75|       |// A Delimiter's `Find()` member function will be passed an input `text` that is
   76|       |// to be split and a position (`pos`) to begin searching for the next delimiter
   77|       |// in `text`. The returned absl::string_view should refer to the next occurrence
   78|       |// (after `pos`) of the represented delimiter; this returned absl::string_view
   79|       |// represents the next location where the input `text` should be broken.
   80|       |//
   81|       |// The returned absl::string_view may be zero-length if the Delimiter does not
   82|       |// represent a part of the string (e.g., a fixed-length delimiter). If no
   83|       |// delimiter is found in the input `text`, a zero-length absl::string_view
   84|       |// referring to `text.end()` should be returned (e.g.,
   85|       |// `text.substr(text.size())`). It is important that the returned
   86|       |// absl::string_view always be within the bounds of the input `text` given as an
   87|       |// argument--it must not refer to a string that is physically located outside of
   88|       |// the given string.
   89|       |//
   90|       |// The following example is a simple Delimiter object that is created with a
   91|       |// single char and will look for that char in the text passed to the `Find()`
   92|       |// function:
   93|       |//
   94|       |//   struct SimpleDelimiter {
   95|       |//     const char c_;
   96|       |//     explicit SimpleDelimiter(char c) : c_(c) {}
   97|       |//     absl::string_view Find(absl::string_view text, size_t pos) {
   98|       |//       auto found = text.find(c_, pos);
   99|       |//       if (found == absl::string_view::npos)
  100|       |//         return text.substr(text.size());
  101|       |//
  102|       |//       return text.substr(found, 1);
  103|       |//     }
  104|       |//   };
  105|       |
  106|       |// ByString
  107|       |//
  108|       |// A sub-string delimiter. If `StrSplit()` is passed a string in place of a
  109|       |// `Delimiter` object, the string will be implicitly converted into a
  110|       |// `ByString` delimiter.
  111|       |//
  112|       |// Example:
  113|       |//
  114|       |//   // Because a string literal is converted to an `absl::ByString`,
  115|       |//   // the following two splits are equivalent.
  116|       |//
  117|       |//   std::vector<std::string> v1 = absl::StrSplit("a, b, c", ", ");
  118|       |//
  119|       |//   using absl::ByString;
  120|       |//   std::vector<std::string> v2 = absl::StrSplit("a, b, c",
  121|       |//                                                ByString(", "));
  122|       |//   // v[0] == "a", v[1] == "b", v[2] == "c"
  123|       |class ByString {
  124|       | public:
  125|       |  explicit ByString(absl::string_view sp);
  126|       |  absl::string_view Find(absl::string_view text, size_t pos) const;
  127|       |
  128|       | private:
  129|       |  const std::string delimiter_;
  130|       |};
  131|       |
  132|       |// ByChar
  133|       |//
  134|       |// A single character delimiter. `ByChar` is functionally equivalent to a
  135|       |// 1-char string within a `ByString` delimiter, but slightly more efficient.
  136|       |//
  137|       |// Example:
  138|       |//
  139|       |//   // Because a char literal is converted to a absl::ByChar,
  140|       |//   // the following two splits are equivalent.
  141|       |//   std::vector<std::string> v1 = absl::StrSplit("a,b,c", ',');
  142|       |//   using absl::ByChar;
  143|       |//   std::vector<std::string> v2 = absl::StrSplit("a,b,c", ByChar(','));
  144|       |//   // v[0] == "a", v[1] == "b", v[2] == "c"
  145|       |//
  146|       |// `ByChar` is also the default delimiter if a single character is given
  147|       |// as the delimiter to `StrSplit()`. For example, the following calls are
  148|       |// equivalent:
  149|       |//
  150|       |//   std::vector<std::string> v = absl::StrSplit("a-b", '-');
  151|       |//
  152|       |//   using absl::ByChar;
  153|       |//   std::vector<std::string> v = absl::StrSplit("a-b", ByChar('-'));
  154|       |//
  155|       |class ByChar {
  156|       | public:
  157|      0|  explicit ByChar(char c) : c_(c) {}
  158|       |  absl::string_view Find(absl::string_view text, size_t pos) const;
  159|       |
  160|       | private:
  161|       |  char c_;
  162|       |};
  163|       |
  164|       |// ByAnyChar
  165|       |//
  166|       |// A delimiter that will match any of the given byte-sized characters within
  167|       |// its provided string.
  168|       |//
  169|       |// Note: this delimiter works with single-byte string data, but does not work
  170|       |// with variable-width encodings, such as UTF-8.
  171|       |//
  172|       |// Example:
  173|       |//
  174|       |//   using absl::ByAnyChar;
  175|       |//   std::vector<std::string> v = absl::StrSplit("a,b=c", ByAnyChar(",="));
  176|       |//   // v[0] == "a", v[1] == "b", v[2] == "c"
  177|       |//
  178|       |// If `ByAnyChar` is given the empty string, it behaves exactly like
  179|       |// `ByString` and matches each individual character in the input string.
  180|       |//
  181|       |class ByAnyChar {
  182|       | public:
  183|       |  explicit ByAnyChar(absl::string_view sp);
  184|       |  absl::string_view Find(absl::string_view text, size_t pos) const;
  185|       |
  186|       | private:
  187|       |  const std::string delimiters_;
  188|       |};
  189|       |
  190|       |// ByLength
  191|       |//
  192|       |// A delimiter for splitting into equal-length strings. The length argument to
  193|       |// the constructor must be greater than 0.
  194|       |//
  195|       |// Note: this delimiter works with single-byte string data, but does not work
  196|       |// with variable-width encodings, such as UTF-8.
  197|       |//
  198|       |// Example:
  199|       |//
  200|       |//   using absl::ByLength;
  201|       |//   std::vector<std::string> v = absl::StrSplit("123456789", ByLength(3));
  202|       |
  203|       |//   // v[0] == "123", v[1] == "456", v[2] == "789"
  204|       |//
  205|       |// Note that the string does not have to be a multiple of the fixed split
  206|       |// length. In such a case, the last substring will be shorter.
  207|       |//
  208|       |//   using absl::ByLength;
  209|       |//   std::vector<std::string> v = absl::StrSplit("12345", ByLength(2));
  210|       |//
  211|       |//   // v[0] == "12", v[1] == "34", v[2] == "5"
  212|       |class ByLength {
  213|       | public:
  214|       |  explicit ByLength(ptrdiff_t length);
  215|       |  absl::string_view Find(absl::string_view text, size_t pos) const;
  216|       |
  217|       | private:
  218|       |  const ptrdiff_t length_;
  219|       |};
  220|       |
  221|       |namespace strings_internal {
  222|       |
  223|       |// A traits-like metafunction for selecting the default Delimiter object type
  224|       |// for a particular Delimiter type. The base case simply exposes type Delimiter
  225|       |// itself as the delimiter's Type. However, there are specializations for
  226|       |// string-like objects that map them to the ByString delimiter object.
  227|       |// This allows functions like absl::StrSplit() and absl::MaxSplits() to accept
  228|       |// string-like objects (e.g., ',') as delimiter arguments but they will be
  229|       |// treated as if a ByString delimiter was given.
  230|       |template <typename Delimiter>
  231|       |struct SelectDelimiter {
  232|       |  using type = Delimiter;
  233|       |};
  234|       |
  235|       |template <>
  236|       |struct SelectDelimiter<char> {
  237|       |  using type = ByChar;
  238|       |};
  239|       |template <>
  240|       |struct SelectDelimiter<char*> {
  241|       |  using type = ByString;
  242|       |};
  243|       |template <>
  244|       |struct SelectDelimiter<const char*> {
  245|       |  using type = ByString;
  246|       |};
  247|       |template <>
  248|       |struct SelectDelimiter<absl::string_view> {
  249|       |  using type = ByString;
  250|       |};
  251|       |template <>
  252|       |struct SelectDelimiter<std::string> {
  253|       |  using type = ByString;
  254|       |};
  255|       |
  256|       |// Wraps another delimiter and sets a max number of matches for that delimiter.
  257|       |template <typename Delimiter>
  258|       |class MaxSplitsImpl {
  259|       | public:
  260|       |  MaxSplitsImpl(Delimiter delimiter, int limit)
  261|       |      : delimiter_(delimiter), limit_(limit), count_(0) {}
  262|       |  absl::string_view Find(absl::string_view text, size_t pos) {
  263|       |    if (count_++ == limit_) {
  264|       |      return absl::string_view(text.data() + text.size(),
  265|       |                               0);  // No more matches.
  266|       |    }
  267|       |    return delimiter_.Find(text, pos);
  268|       |  }
  269|       |
  270|       | private:
  271|       |  Delimiter delimiter_;
  272|       |  const int limit_;
  273|       |  int count_;
  274|       |};
  275|       |
  276|       |}  // namespace strings_internal
  277|       |
  278|       |// MaxSplits()
  279|       |//
  280|       |// A delimiter that limits the number of matches which can occur to the passed
  281|       |// `limit`. The last element in the returned collection will contain all
  282|       |// remaining unsplit pieces, which may contain instances of the delimiter.
  283|       |// The collection will contain at most `limit` + 1 elements.
  284|       |// Example:
  285|       |//
  286|       |//   using absl::MaxSplits;
  287|       |//   std::vector<std::string> v = absl::StrSplit("a,b,c", MaxSplits(',', 1));
  288|       |//
  289|       |//   // v[0] == "a", v[1] == "b,c"
  290|       |template <typename Delimiter>
  291|       |inline strings_internal::MaxSplitsImpl<
  292|       |    typename strings_internal::SelectDelimiter<Delimiter>::type>
  293|       |MaxSplits(Delimiter delimiter, int limit) {
  294|       |  typedef
  295|       |      typename strings_internal::SelectDelimiter<Delimiter>::type DelimiterType;
  296|       |  return strings_internal::MaxSplitsImpl<DelimiterType>(
  297|       |      DelimiterType(delimiter), limit);
  298|       |}
  299|       |
  300|       |//------------------------------------------------------------------------------
  301|       |// Predicates
  302|       |//------------------------------------------------------------------------------
  303|       |//
  304|       |// Predicates filter the results of a `StrSplit()` by determining whether or not
  305|       |// a resultant element is included in the result set. A predicate may be passed
  306|       |// as an optional third argument to the `StrSplit()` function.
  307|       |//
  308|       |// Predicates are unary functions (or functors) that take a single
  309|       |// `absl::string_view` argument and return a bool indicating whether the
  310|       |// argument should be included (`true`) or excluded (`false`).
  311|       |//
  312|       |// Predicates are useful when filtering out empty substrings. By default, empty
  313|       |// substrings may be returned by `StrSplit()`, which is similar to the way split
  314|       |// functions work in other programming languages.
  315|       |
  316|       |// AllowEmpty()
  317|       |//
  318|       |// Always returns `true`, indicating that all strings--including empty
  319|       |// strings--should be included in the split output. This predicate is not
  320|       |// strictly needed because this is the default behavior of `StrSplit()`;
  321|       |// however, it might be useful at some call sites to make the intent explicit.
  322|       |//
  323|       |// Example:
  324|       |//
  325|       |//  std::vector<std::string> v = absl::StrSplit(" a , ,,b,", ',', AllowEmpty());
  326|       |//
  327|       |//  // v[0] == " a ", v[1] == " ", v[2] == "", v[3] = "b", v[4] == ""
  328|       |struct AllowEmpty {
  329|      0|  bool operator()(absl::string_view) const { return true; }
  330|       |};
  331|       |
  332|       |// SkipEmpty()
  333|       |//
  334|       |// Returns `false` if the given `absl::string_view` is empty, indicating that
  335|       |// `StrSplit()` should omit the empty string.
  336|       |//
  337|       |// Example:
  338|       |//
  339|       |//   std::vector<std::string> v = absl::StrSplit(",a,,b,", ',', SkipEmpty());
  340|       |//
  341|       |//   // v[0] == "a", v[1] == "b"
  342|       |//
  343|       |// Note: `SkipEmpty()` does not consider a string containing only whitespace
  344|       |// to be empty. To skip such whitespace as well, use the `SkipWhitespace()`
  345|       |// predicate.
  346|       |struct SkipEmpty {
  347|       |  bool operator()(absl::string_view sp) const { return !sp.empty(); }
  348|       |};
  349|       |
  350|       |// SkipWhitespace()
  351|       |//
  352|       |// Returns `false` if the given `absl::string_view` is empty *or* contains only
  353|       |// whitespace, indicating that `StrSplit()` should omit the string.
  354|       |//
  355|       |// Example:
  356|       |//
  357|       |//   std::vector<std::string> v = absl::StrSplit(" a , ,,b,",
  358|       |//                                               ',', SkipWhitespace());
  359|       |//   // v[0] == " a ", v[1] == "b"
  360|       |//
  361|       |//   // SkipEmpty() would return whitespace elements
  362|       |//   std::vector<std::string> v = absl::StrSplit(" a , ,,b,", ',', SkipEmpty());
  363|       |//   // v[0] == " a ", v[1] == " ", v[2] == "b"
  364|       |struct SkipWhitespace {
  365|      0|  bool operator()(absl::string_view sp) const {
  366|      0|    sp = absl::StripAsciiWhitespace(sp);
  367|      0|    return !sp.empty();
  368|      0|  }
  369|       |};
  370|       |
  371|       |//------------------------------------------------------------------------------
  372|       |//                                  StrSplit()
  373|       |//------------------------------------------------------------------------------
  374|       |
  375|       |// StrSplit()
  376|       |//
  377|       |// Splits a given string based on the provided `Delimiter` object, returning the
  378|       |// elements within the type specified by the caller. Optionally, you may pass a
  379|       |// `Predicate` to `StrSplit()` indicating whether to include or exclude the
  380|       |// resulting element within the final result set. (See the overviews for
  381|       |// Delimiters and Predicates above.)
  382|       |//
  383|       |// Example:
  384|       |//
  385|       |//   std::vector<std::string> v = absl::StrSplit("a,b,c,d", ',');
  386|       |//   // v[0] == "a", v[1] == "b", v[2] == "c", v[3] == "d"
  387|       |//
  388|       |// You can also provide an explicit `Delimiter` object:
  389|       |//
  390|       |// Example:
  391|       |//
  392|       |//   using absl::ByAnyChar;
  393|       |//   std::vector<std::string> v = absl::StrSplit("a,b=c", ByAnyChar(",="));
  394|       |//   // v[0] == "a", v[1] == "b", v[2] == "c"
  395|       |//
  396|       |// See above for more information on delimiters.
  397|       |//
  398|       |// By default, empty strings are included in the result set. You can optionally
  399|       |// include a third `Predicate` argument to apply a test for whether the
  400|       |// resultant element should be included in the result set:
  401|       |//
  402|       |// Example:
  403|       |//
  404|       |//   std::vector<std::string> v = absl::StrSplit(" a , ,,b,",
  405|       |//                                               ',', SkipWhitespace());
  406|       |//   // v[0] == " a ", v[1] == "b"
  407|       |//
  408|       |// See above for more information on predicates.
  409|       |//
  410|       |//------------------------------------------------------------------------------
  411|       |// StrSplit() Return Types
  412|       |//------------------------------------------------------------------------------
  413|       |//
  414|       |// The `StrSplit()` function adapts the returned collection to the collection
  415|       |// specified by the caller (e.g. `std::vector` above). The returned collections
  416|       |// may contain `std::string`, `absl::string_view` (in which case the original
  417|       |// string being split must ensure that it outlives the collection), or any
  418|       |// object that can be explicitly created from an `absl::string_view`. This
  419|       |// behavior works for:
  420|       |//
  421|       |// 1) All standard STL containers including `std::vector`, `std::list`,
  422|       |//    `std::deque`, `std::set`,`std::multiset`, 'std::map`, and `std::multimap`
  423|       |// 2) `std::pair` (which is not actually a container). See below.
  424|       |//
  425|       |// Example:
  426|       |//
  427|       |//   // The results are returned as `absl::string_view` objects. Note that we
  428|       |//   // have to ensure that the input string outlives any results.
  429|       |//   std::vector<absl::string_view> v = absl::StrSplit("a,b,c", ',');
  430|       |//
  431|       |//   // Stores results in a std::set<std::string>, which also performs
  432|       |//   // de-duplication and orders the elements in ascending order.
  433|       |//   std::set<std::string> a = absl::StrSplit("b,a,c,a,b", ',');
  434|       |//   // v[0] == "a", v[1] == "b", v[2] = "c"
  435|       |//
  436|       |//   // `StrSplit()` can be used within a range-based for loop, in which case
  437|       |//   // each element will be of type `absl::string_view`.
  438|       |//   std::vector<std::string> v;
  439|       |//   for (const auto sv : absl::StrSplit("a,b,c", ',')) {
  440|       |//     if (sv != "b") v.emplace_back(sv);
  441|       |//   }
  442|       |//   // v[0] == "a", v[1] == "c"
  443|       |//
  444|       |//   // Stores results in a map. The map implementation assumes that the input
  445|       |//   // is provided as a series of key/value pairs. For example, the 0th element
  446|       |//   // resulting from the split will be stored as a key to the 1st element. If
  447|       |//   // an odd number of elements are resolved, the last element is paired with
  448|       |//   // a default-constructed value (e.g., empty string).
  449|       |//   std::map<std::string, std::string> m = absl::StrSplit("a,b,c", ',');
  450|       |//   // m["a"] == "b", m["c"] == ""     // last component value equals ""
  451|       |//
  452|       |// Splitting to `std::pair` is an interesting case because it can hold only two
  453|       |// elements and is not a collection type. When splitting to a `std::pair` the
  454|       |// first two split strings become the `std::pair` `.first` and `.second`
  455|       |// members, respectively. The remaining split substrings are discarded. If there
  456|       |// are less than two split substrings, the empty string is used for the
  457|       |// corresponding
  458|       |// `std::pair` member.
  459|       |//
  460|       |// Example:
  461|       |//
  462|       |//   // Stores first two split strings as the members in a std::pair.
  463|       |//   std::pair<std::string, std::string> p = absl::StrSplit("a,b,c", ',');
  464|       |//   // p.first == "a", p.second == "b"       // "c" is omitted.
  465|       |//
  466|       |// The `StrSplit()` function can be used multiple times to perform more
  467|       |// complicated splitting logic, such as intelligently parsing key-value pairs.
  468|       |//
  469|       |// Example:
  470|       |//
  471|       |//   // The input string "a=b=c,d=e,f=,g" becomes
  472|       |//   // { "a" => "b=c", "d" => "e", "f" => "", "g" => "" }
  473|       |//   std::map<std::string, std::string> m;
  474|       |//   for (absl::string_view sp : absl::StrSplit("a=b=c,d=e,f=,g", ',')) {
  475|       |//     m.insert(absl::StrSplit(sp, absl::MaxSplits('=', 1)));
  476|       |//   }
  477|       |//   EXPECT_EQ("b=c", m.find("a")->second);
  478|       |//   EXPECT_EQ("e", m.find("d")->second);
  479|       |//   EXPECT_EQ("", m.find("f")->second);
  480|       |//   EXPECT_EQ("", m.find("g")->second);
  481|       |//
  482|       |// WARNING: Due to a legacy bug that is maintained for backward compatibility,
  483|       |// splitting the following empty string_views produces different results:
  484|       |//
  485|       |//   absl::StrSplit(absl::string_view(""), '-');  // {""}
  486|       |//   absl::StrSplit(absl::string_view(), '-');    // {}, but should be {""}
  487|       |//
  488|       |// Try not to depend on this distinction because the bug may one day be fixed.
  489|       |template <typename Delimiter>
  490|       |strings_internal::Splitter<
  491|       |    typename strings_internal::SelectDelimiter<Delimiter>::type, AllowEmpty>
  492|       |StrSplit(strings_internal::ConvertibleToStringView text, Delimiter d) {
  493|       |  using DelimiterType =
  494|       |      typename strings_internal::SelectDelimiter<Delimiter>::type;
  495|       |  return strings_internal::Splitter<DelimiterType, AllowEmpty>(
  496|       |      std::move(text), DelimiterType(d), AllowEmpty());
  497|       |}
  498|       |
  499|       |template <typename Delimiter, typename Predicate>
  500|       |strings_internal::Splitter<
  501|       |    typename strings_internal::SelectDelimiter<Delimiter>::type, Predicate>
  502|       |StrSplit(strings_internal::ConvertibleToStringView text, Delimiter d,
  503|       |         Predicate p) {
  504|       |  using DelimiterType =
  505|       |      typename strings_internal::SelectDelimiter<Delimiter>::type;
  506|       |  return strings_internal::Splitter<DelimiterType, Predicate>(
  507|       |      std::move(text), DelimiterType(d), std::move(p));
  508|       |}
  509|       |
  510|       |}  // inline namespace lts_2019_08_08
  511|       |}  // namespace absl
  512|       |
  513|       |#endif  // ABSL_STRINGS_STR_SPLIT_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/string_view.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/string_view.h"
   16|       |
   17|       |#ifndef ABSL_HAVE_STD_STRING_VIEW
   18|       |
   19|       |#include <algorithm>
   20|       |#include <climits>
   21|       |#include <cstring>
   22|       |#include <ostream>
   23|       |
   24|       |#include "absl/strings/internal/memutil.h"
   25|       |
   26|       |namespace absl {
   27|       |inline namespace lts_2019_08_08 {
   28|       |
   29|       |namespace {
   30|      0|void WritePadding(std::ostream& o, size_t pad) {
   31|      0|  char fill_buf[32];
   32|      0|  memset(fill_buf, o.fill(), sizeof(fill_buf));
   33|      0|  while (pad) {
   34|      0|    size_t n = std::min(pad, sizeof(fill_buf));
   35|      0|    o.write(fill_buf, n);
   36|      0|    pad -= n;
   37|      0|  }
   38|      0|}
   39|       |
   40|       |class LookupTable {
   41|       | public:
   42|       |  // For each character in wanted, sets the index corresponding
   43|       |  // to the ASCII code of that character. This is used by
   44|       |  // the find_.*_of methods below to tell whether or not a character is in
   45|       |  // the lookup table in constant time.
   46|      0|  explicit LookupTable(string_view wanted) {
   47|      0|    for (char c : wanted) {
   48|      0|      table_[Index(c)] = true;
   49|      0|    }
   50|      0|  }
   51|      0|  bool operator[](char c) const { return table_[Index(c)]; }
   52|       |
   53|       | private:
   54|      0|  static unsigned char Index(char c) { return static_cast<unsigned char>(c); }
   55|       |  bool table_[UCHAR_MAX + 1] = {};
   56|       |};
   57|       |
   58|       |}  // namespace
   59|       |
   60|      0|std::ostream& operator<<(std::ostream& o, string_view piece) {
   61|      0|  std::ostream::sentry sentry(o);
   62|      0|  if (sentry) {
   63|      0|    size_t lpad = 0;
   64|      0|    size_t rpad = 0;
   65|      0|    if (static_cast<size_t>(o.width()) > piece.size()) {
   66|      0|      size_t pad = o.width() - piece.size();
   67|      0|      if ((o.flags() & o.adjustfield) == o.left) {
   68|      0|        rpad = pad;
   69|      0|      } else {
   70|      0|        lpad = pad;
   71|      0|      }
   72|      0|    }
   73|      0|    if (lpad) WritePadding(o, lpad);
   74|      0|    o.write(piece.data(), piece.size());
   75|      0|    if (rpad) WritePadding(o, rpad);
   76|      0|    o.width(0);
   77|      0|  }
   78|      0|  return o;
   79|      0|}
   80|       |
   81|       |string_view::size_type string_view::find(string_view s, size_type pos) const
   82|      0|    noexcept {
   83|      0|  if (empty() || pos > length_) {
   84|      0|    if (empty() && pos == 0 && s.empty()) return 0;
   85|      0|    return npos;
   86|      0|  }
   87|      0|  const char* result =
   88|      0|      strings_internal::memmatch(ptr_ + pos, length_ - pos, s.ptr_, s.length_);
   89|      0|  return result ? result - ptr_ : npos;
   90|      0|}
   91|       |
   92|      0|string_view::size_type string_view::find(char c, size_type pos) const noexcept {
   93|      0|  if (empty() || pos >= length_) {
   94|      0|    return npos;
   95|      0|  }
   96|      0|  const char* result =
   97|      0|      static_cast<const char*>(memchr(ptr_ + pos, c, length_ - pos));
   98|      0|  return result != nullptr ? result - ptr_ : npos;
   99|      0|}
  100|       |
  101|       |string_view::size_type string_view::rfind(string_view s, size_type pos) const
  102|      0|    noexcept {
  103|      0|  if (length_ < s.length_) return npos;
  104|      0|  if (s.empty()) return std::min(length_, pos);
  105|      0|  const char* last = ptr_ + std::min(length_ - s.length_, pos) + s.length_;
  106|      0|  const char* result = std::find_end(ptr_, last, s.ptr_, s.ptr_ + s.length_);
  107|      0|  return result != last ? result - ptr_ : npos;
  108|      0|}
  109|       |
  110|       |// Search range is [0..pos] inclusive.  If pos == npos, search everything.
  111|       |string_view::size_type string_view::rfind(char c, size_type pos) const
  112|      0|    noexcept {
  113|      0|  // Note: memrchr() is not available on Windows.
  114|      0|  if (empty()) return npos;
  115|      0|  for (size_type i = std::min(pos, length_ - 1);; --i) {
  116|      0|    if (ptr_[i] == c) {
  117|      0|      return i;
  118|      0|    }
  119|      0|    if (i == 0) break;
  120|      0|  }
  121|      0|  return npos;
  122|      0|}
  123|       |
  124|       |string_view::size_type string_view::find_first_of(string_view s,
  125|       |                                                  size_type pos) const
  126|      0|    noexcept {
  127|      0|  if (empty() || s.empty()) {
  128|      0|    return npos;
  129|      0|  }
  130|      0|  // Avoid the cost of LookupTable() for a single-character search.
  131|      0|  if (s.length_ == 1) return find_first_of(s.ptr_[0], pos);
  132|      0|  LookupTable tbl(s);
  133|      0|  for (size_type i = pos; i < length_; ++i) {
  134|      0|    if (tbl[ptr_[i]]) {
  135|      0|      return i;
  136|      0|    }
  137|      0|  }
  138|      0|  return npos;
  139|      0|}
  140|       |
  141|       |string_view::size_type string_view::find_first_not_of(string_view s,
  142|       |                                                      size_type pos) const
  143|      0|    noexcept {
  144|      0|  if (empty()) return npos;
  145|      0|  // Avoid the cost of LookupTable() for a single-character search.
  146|      0|  if (s.length_ == 1) return find_first_not_of(s.ptr_[0], pos);
  147|      0|  LookupTable tbl(s);
  148|      0|  for (size_type i = pos; i < length_; ++i) {
  149|      0|    if (!tbl[ptr_[i]]) {
  150|      0|      return i;
  151|      0|    }
  152|      0|  }
  153|      0|  return npos;
  154|      0|}
  155|       |
  156|       |string_view::size_type string_view::find_first_not_of(char c,
  157|       |                                                      size_type pos) const
  158|      0|    noexcept {
  159|      0|  if (empty()) return npos;
  160|      0|  for (; pos < length_; ++pos) {
  161|      0|    if (ptr_[pos] != c) {
  162|      0|      return pos;
  163|      0|    }
  164|      0|  }
  165|      0|  return npos;
  166|      0|}
  167|       |
  168|       |string_view::size_type string_view::find_last_of(string_view s,
  169|      0|                                                 size_type pos) const noexcept {
  170|      0|  if (empty() || s.empty()) return npos;
  171|      0|  // Avoid the cost of LookupTable() for a single-character search.
  172|      0|  if (s.length_ == 1) return find_last_of(s.ptr_[0], pos);
  173|      0|  LookupTable tbl(s);
  174|      0|  for (size_type i = std::min(pos, length_ - 1);; --i) {
  175|      0|    if (tbl[ptr_[i]]) {
  176|      0|      return i;
  177|      0|    }
  178|      0|    if (i == 0) break;
  179|      0|  }
  180|      0|  return npos;
  181|      0|}
  182|       |
  183|       |string_view::size_type string_view::find_last_not_of(string_view s,
  184|       |                                                     size_type pos) const
  185|      0|    noexcept {
  186|      0|  if (empty()) return npos;
  187|      0|  size_type i = std::min(pos, length_ - 1);
  188|      0|  if (s.empty()) return i;
  189|      0|  // Avoid the cost of LookupTable() for a single-character search.
  190|      0|  if (s.length_ == 1) return find_last_not_of(s.ptr_[0], pos);
  191|      0|  LookupTable tbl(s);
  192|      0|  for (;; --i) {
  193|      0|    if (!tbl[ptr_[i]]) {
  194|      0|      return i;
  195|      0|    }
  196|      0|    if (i == 0) break;
  197|      0|  }
  198|      0|  return npos;
  199|      0|}
  200|       |
  201|       |string_view::size_type string_view::find_last_not_of(char c,
  202|       |                                                     size_type pos) const
  203|      0|    noexcept {
  204|      0|  if (empty()) return npos;
  205|      0|  size_type i = std::min(pos, length_ - 1);
  206|      0|  for (;; --i) {
  207|      0|    if (ptr_[i] != c) {
  208|      0|      return i;
  209|      0|    }
  210|      0|    if (i == 0) break;
  211|      0|  }
  212|      0|  return npos;
  213|      0|}
  214|       |
  215|       |// MSVC has non-standard behavior that implicitly creates definitions for static
  216|       |// const members. These implicit definitions conflict with explicit out-of-class
  217|       |// member definitions that are required by the C++ standard, resulting in
  218|       |// LNK1169 "multiply defined" errors at link time. __declspec(selectany) asks
  219|       |// MSVC to choose only one definition for the symbol it decorates. See details
  220|       |// at https://msdn.microsoft.com/en-us/library/34h23df8(v=vs.100).aspx
  221|       |#ifdef _MSC_VER
  222|       |#define ABSL_STRING_VIEW_SELECTANY __declspec(selectany)
  223|       |#else
  224|       |#define ABSL_STRING_VIEW_SELECTANY
  225|       |#endif
  226|       |
  227|       |ABSL_STRING_VIEW_SELECTANY
  228|       |constexpr string_view::size_type string_view::npos;
  229|       |ABSL_STRING_VIEW_SELECTANY
  230|       |constexpr string_view::size_type string_view::kMaxSize;
  231|       |
  232|       |}  // inline namespace lts_2019_08_08
  233|       |}  // namespace absl
  234|       |
  235|       |#endif  // ABSL_HAVE_STD_STRING_VIEW

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/string_view.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: string_view.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This file contains the definition of the `absl::string_view` class. A
   21|       |// `string_view` points to a contiguous span of characters, often part or all of
   22|       |// another `std::string`, double-quoted string literal, character array, or even
   23|       |// another `string_view`.
   24|       |//
   25|       |// This `absl::string_view` abstraction is designed to be a drop-in
   26|       |// replacement for the C++17 `std::string_view` abstraction.
   27|       |#ifndef ABSL_STRINGS_STRING_VIEW_H_
   28|       |#define ABSL_STRINGS_STRING_VIEW_H_
   29|       |
   30|       |#include <algorithm>
   31|       |#include "absl/base/config.h"
   32|       |
   33|       |#ifdef ABSL_HAVE_STD_STRING_VIEW
   34|       |
   35|       |#include <string_view>  // IWYU pragma: export
   36|       |
   37|       |namespace absl {
   38|       |inline namespace lts_2019_08_08 {
   39|       |using std::string_view;
   40|       |}  // inline namespace lts_2019_08_08
   41|       |}  // namespace absl
   42|       |
   43|       |#else  // ABSL_HAVE_STD_STRING_VIEW
   44|       |
   45|       |#include <cassert>
   46|       |#include <cstddef>
   47|       |#include <cstring>
   48|       |#include <iosfwd>
   49|       |#include <iterator>
   50|       |#include <limits>
   51|       |#include <string>
   52|       |
   53|       |#include "absl/base/internal/throw_delegate.h"
   54|       |#include "absl/base/macros.h"
   55|       |#include "absl/base/optimization.h"
   56|       |#include "absl/base/port.h"
   57|       |
   58|       |namespace absl {
   59|       |inline namespace lts_2019_08_08 {
   60|       |
   61|       |// absl::string_view
   62|       |//
   63|       |// A `string_view` provides a lightweight view into the string data provided by
   64|       |// a `std::string`, double-quoted string literal, character array, or even
   65|       |// another `string_view`. A `string_view` does *not* own the string to which it
   66|       |// points, and that data cannot be modified through the view.
   67|       |//
   68|       |// You can use `string_view` as a function or method parameter anywhere a
   69|       |// parameter can receive a double-quoted string literal, `const char*`,
   70|       |// `std::string`, or another `absl::string_view` argument with no need to copy
   71|       |// the string data. Systematic use of `string_view` within function arguments
   72|       |// reduces data copies and `strlen()` calls.
   73|       |//
   74|       |// Because of its small size, prefer passing `string_view` by value:
   75|       |//
   76|       |//   void MyFunction(absl::string_view arg);
   77|       |//
   78|       |// If circumstances require, you may also pass one by const reference:
   79|       |//
   80|       |//   void MyFunction(const absl::string_view& arg);  // not preferred
   81|       |//
   82|       |// Passing by value generates slightly smaller code for many architectures.
   83|       |//
   84|       |// In either case, the source data of the `string_view` must outlive the
   85|       |// `string_view` itself.
   86|       |//
   87|       |// A `string_view` is also suitable for local variables if you know that the
   88|       |// lifetime of the underlying object is longer than the lifetime of your
   89|       |// `string_view` variable. However, beware of binding a `string_view` to a
   90|       |// temporary value:
   91|       |//
   92|       |//   // BAD use of string_view: lifetime problem
   93|       |//   absl::string_view sv = obj.ReturnAString();
   94|       |//
   95|       |//   // GOOD use of string_view: str outlives sv
   96|       |//   std::string str = obj.ReturnAString();
   97|       |//   absl::string_view sv = str;
   98|       |//
   99|       |// Due to lifetime issues, a `string_view` is sometimes a poor choice for a
  100|       |// return value and usually a poor choice for a data member. If you do use a
  101|       |// `string_view` this way, it is your responsibility to ensure that the object
  102|       |// pointed to by the `string_view` outlives the `string_view`.
  103|       |//
  104|       |// A `string_view` may represent a whole string or just part of a string. For
  105|       |// example, when splitting a string, `std::vector<absl::string_view>` is a
  106|       |// natural data type for the output.
  107|       |//
  108|       |// When constructed from a source which is nul-terminated, the `string_view`
  109|       |// itself will not include the nul-terminator unless a specific size (including
  110|       |// the nul) is passed to the constructor. As a result, common idioms that work
  111|       |// on nul-terminated strings do not work on `string_view` objects. If you write
  112|       |// code that scans a `string_view`, you must check its length rather than test
  113|       |// for nul, for example. Note, however, that nuls may still be embedded within
  114|       |// a `string_view` explicitly.
  115|       |//
  116|       |// You may create a null `string_view` in two ways:
  117|       |//
  118|       |//   absl::string_view sv();
  119|       |//   absl::string_view sv(nullptr, 0);
  120|       |//
  121|       |// For the above, `sv.data() == nullptr`, `sv.length() == 0`, and
  122|       |// `sv.empty() == true`. Also, if you create a `string_view` with a non-null
  123|       |// pointer then `sv.data() != nullptr`. Thus, you can use `string_view()` to
  124|       |// signal an undefined value that is different from other `string_view` values
  125|       |// in a similar fashion to how `const char* p1 = nullptr;` is different from
  126|       |// `const char* p2 = "";`. However, in practice, it is not recommended to rely
  127|       |// on this behavior.
  128|       |//
  129|       |// Be careful not to confuse a null `string_view` with an empty one. A null
  130|       |// `string_view` is an empty `string_view`, but some empty `string_view`s are
  131|       |// not null. Prefer checking for emptiness over checking for null.
  132|       |//
  133|       |// There are many ways to create an empty string_view:
  134|       |//
  135|       |//   const char* nullcp = nullptr;
  136|       |//   // string_view.size() will return 0 in all cases.
  137|       |//   absl::string_view();
  138|       |//   absl::string_view(nullcp, 0);
  139|       |//   absl::string_view("");
  140|       |//   absl::string_view("", 0);
  141|       |//   absl::string_view("abcdef", 0);
  142|       |//   absl::string_view("abcdef" + 6, 0);
  143|       |//
  144|       |// All empty `string_view` objects whether null or not, are equal:
  145|       |//
  146|       |//   absl::string_view() == absl::string_view("", 0)
  147|       |//   absl::string_view(nullptr, 0) == absl::string_view("abcdef"+6, 0)
  148|       |class string_view {
  149|       | public:
  150|       |  using traits_type = std::char_traits<char>;
  151|       |  using value_type = char;
  152|       |  using pointer = char*;
  153|       |  using const_pointer = const char*;
  154|       |  using reference = char&;
  155|       |  using const_reference = const char&;
  156|       |  using const_iterator = const char*;
  157|       |  using iterator = const_iterator;
  158|       |  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
  159|       |  using reverse_iterator = const_reverse_iterator;
  160|       |  using size_type = size_t;
  161|       |  using difference_type = std::ptrdiff_t;
  162|       |
  163|       |  static constexpr size_type npos = static_cast<size_type>(-1);
  164|       |
  165|       |  // Null `string_view` constructor
  166|      0|  constexpr string_view() noexcept : ptr_(nullptr), length_(0) {}
  167|       |
  168|       |  // Implicit constructors
  169|       |
  170|       |  template <typename Allocator>
  171|       |  string_view(  // NOLINT(runtime/explicit)
  172|       |      const std::basic_string<char, std::char_traits<char>, Allocator>&
  173|       |          str) noexcept
  174|      0|      : ptr_(str.data()), length_(CheckLengthInternal(str.size())) {}
  175|       |
  176|       |  // Implicit constructor of a `string_view` from nul-terminated `str`. When
  177|       |  // accepting possibly null strings, use `absl::NullSafeStringView(str)`
  178|       |  // instead (see below).
  179|       |  constexpr string_view(const char* str)  // NOLINT(runtime/explicit)
  180|       |      : ptr_(str),
  181|      0|        length_(str ? CheckLengthInternal(StrlenInternal(str)) : 0) {}
  182|       |
  183|       |  // Implicit constructor of a `string_view` from a `const char*` and length.
  184|       |  constexpr string_view(const char* data, size_type len)
  185|      0|      : ptr_(data), length_(CheckLengthInternal(len)) {}
  186|       |
  187|       |  // NOTE: Harmlessly omitted to work around gdb bug.
  188|       |  //   constexpr string_view(const string_view&) noexcept = default;
  189|       |  //   string_view& operator=(const string_view&) noexcept = default;
  190|       |
  191|       |  // Iterators
  192|       |
  193|       |  // string_view::begin()
  194|       |  //
  195|       |  // Returns an iterator pointing to the first character at the beginning of the
  196|       |  // `string_view`, or `end()` if the `string_view` is empty.
  197|      0|  constexpr const_iterator begin() const noexcept { return ptr_; }
  198|       |
  199|       |  // string_view::end()
  200|       |  //
  201|       |  // Returns an iterator pointing just beyond the last character at the end of
  202|       |  // the `string_view`. This iterator acts as a placeholder; attempting to
  203|       |  // access it results in undefined behavior.
  204|      0|  constexpr const_iterator end() const noexcept { return ptr_ + length_; }
  205|       |
  206|       |  // string_view::cbegin()
  207|       |  //
  208|       |  // Returns a const iterator pointing to the first character at the beginning
  209|       |  // of the `string_view`, or `end()` if the `string_view` is empty.
  210|      0|  constexpr const_iterator cbegin() const noexcept { return begin(); }
  211|       |
  212|       |  // string_view::cend()
  213|       |  //
  214|       |  // Returns a const iterator pointing just beyond the last character at the end
  215|       |  // of the `string_view`. This pointer acts as a placeholder; attempting to
  216|       |  // access its element results in undefined behavior.
  217|      0|  constexpr const_iterator cend() const noexcept { return end(); }
  218|       |
  219|       |  // string_view::rbegin()
  220|       |  //
  221|       |  // Returns a reverse iterator pointing to the last character at the end of the
  222|       |  // `string_view`, or `rend()` if the `string_view` is empty.
  223|      0|  const_reverse_iterator rbegin() const noexcept {
  224|      0|    return const_reverse_iterator(end());
  225|      0|  }
  226|       |
  227|       |  // string_view::rend()
  228|       |  //
  229|       |  // Returns a reverse iterator pointing just before the first character at the
  230|       |  // beginning of the `string_view`. This pointer acts as a placeholder;
  231|       |  // attempting to access its element results in undefined behavior.
  232|      0|  const_reverse_iterator rend() const noexcept {
  233|      0|    return const_reverse_iterator(begin());
  234|      0|  }
  235|       |
  236|       |  // string_view::crbegin()
  237|       |  //
  238|       |  // Returns a const reverse iterator pointing to the last character at the end
  239|       |  // of the `string_view`, or `crend()` if the `string_view` is empty.
  240|      0|  const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  241|       |
  242|       |  // string_view::crend()
  243|       |  //
  244|       |  // Returns a const reverse iterator pointing just before the first character
  245|       |  // at the beginning of the `string_view`. This pointer acts as a placeholder;
  246|       |  // attempting to access its element results in undefined behavior.
  247|      0|  const_reverse_iterator crend() const noexcept { return rend(); }
  248|       |
  249|       |  // Capacity Utilities
  250|       |
  251|       |  // string_view::size()
  252|       |  //
  253|       |  // Returns the number of characters in the `string_view`.
  254|      0|  constexpr size_type size() const noexcept {
  255|      0|    return length_;
  256|      0|  }
  257|       |
  258|       |  // string_view::length()
  259|       |  //
  260|       |  // Returns the number of characters in the `string_view`. Alias for `size()`.
  261|      0|  constexpr size_type length() const noexcept { return size(); }
  262|       |
  263|       |  // string_view::max_size()
  264|       |  //
  265|       |  // Returns the maximum number of characters the `string_view` can hold.
  266|      0|  constexpr size_type max_size() const noexcept { return kMaxSize; }
  267|       |
  268|       |  // string_view::empty()
  269|       |  //
  270|       |  // Checks if the `string_view` is empty (refers to no characters).
  271|      0|  constexpr bool empty() const noexcept { return length_ == 0; }
  272|       |
  273|       |  // string_view::operator[]
  274|       |  //
  275|       |  // Returns the ith element of an `string_view` using the array operator.
  276|       |  // Note that this operator does not perform any bounds checking.
  277|      0|  constexpr const_reference operator[](size_type i) const { return ptr_[i]; }
  278|       |
  279|       |  // string_view::front()
  280|       |  //
  281|       |  // Returns the first element of a `string_view`.
  282|      0|  constexpr const_reference front() const { return ptr_[0]; }
  283|       |
  284|       |  // string_view::back()
  285|       |  //
  286|       |  // Returns the last element of a `string_view`.
  287|      0|  constexpr const_reference back() const { return ptr_[size() - 1]; }
  288|       |
  289|       |  // string_view::data()
  290|       |  //
  291|       |  // Returns a pointer to the underlying character array (which is of course
  292|       |  // stored elsewhere). Note that `string_view::data()` may contain embedded nul
  293|       |  // characters, but the returned buffer may or may not be nul-terminated;
  294|       |  // therefore, do not pass `data()` to a routine that expects a nul-terminated
  295|       |  // std::string.
  296|      0|  constexpr const_pointer data() const noexcept { return ptr_; }
  297|       |
  298|       |  // Modifiers
  299|       |
  300|       |  // string_view::remove_prefix()
  301|       |  //
  302|       |  // Removes the first `n` characters from the `string_view`. Note that the
  303|       |  // underlying std::string is not changed, only the view.
  304|      0|  void remove_prefix(size_type n) {
  305|      0|    assert(n <= length_);
  306|      0|    ptr_ += n;
  307|      0|    length_ -= n;
  308|      0|  }
  309|       |
  310|       |  // string_view::remove_suffix()
  311|       |  //
  312|       |  // Removes the last `n` characters from the `string_view`. Note that the
  313|       |  // underlying std::string is not changed, only the view.
  314|      0|  void remove_suffix(size_type n) {
  315|      0|    assert(n <= length_);
  316|      0|    length_ -= n;
  317|      0|  }
  318|       |
  319|       |  // string_view::swap()
  320|       |  //
  321|       |  // Swaps this `string_view` with another `string_view`.
  322|      0|  void swap(string_view& s) noexcept {
  323|      0|    auto t = *this;
  324|      0|    *this = s;
  325|      0|    s = t;
  326|      0|  }
  327|       |
  328|       |  // Explicit conversion operators
  329|       |
  330|       |  // Converts to `std::basic_string`.
  331|       |  template <typename A>
  332|      0|  explicit operator std::basic_string<char, traits_type, A>() const {
  333|      0|    if (!data()) return {};
  334|      0|    return std::basic_string<char, traits_type, A>(data(), size());
  335|      0|  }
  336|       |
  337|       |  // string_view::copy()
  338|       |  //
  339|       |  // Copies the contents of the `string_view` at offset `pos` and length `n`
  340|       |  // into `buf`.
  341|      0|  size_type copy(char* buf, size_type n, size_type pos = 0) const {
  342|      0|    if (ABSL_PREDICT_FALSE(pos > length_)) {
  343|      0|      base_internal::ThrowStdOutOfRange("absl::string_view::copy");
  344|      0|    }
  345|      0|    size_type rlen = (std::min)(length_ - pos, n);
  346|      0|    if (rlen > 0) {
  347|      0|      const char* start = ptr_ + pos;
  348|      0|      std::copy(start, start + rlen, buf);
  349|      0|    }
  350|      0|    return rlen;
  351|      0|  }
  352|       |
  353|       |  // string_view::substr()
  354|       |  //
  355|       |  // Returns a "substring" of the `string_view` (at offset `pos` and length
  356|       |  // `n`) as another string_view. This function throws `std::out_of_bounds` if
  357|       |  // `pos > size`.
  358|      0|  string_view substr(size_type pos, size_type n = npos) const {
  359|      0|    if (ABSL_PREDICT_FALSE(pos > length_))
  360|      0|      base_internal::ThrowStdOutOfRange("absl::string_view::substr");
  361|      0|    n = (std::min)(n, length_ - pos);
  362|      0|    return string_view(ptr_ + pos, n);
  363|      0|  }
  364|       |
  365|       |  // string_view::compare()
  366|       |  //
  367|       |  // Performs a lexicographical comparison between the `string_view` and
  368|       |  // another `absl::string_view`, returning -1 if `this` is less than, 0 if
  369|       |  // `this` is equal to, and 1 if `this` is greater than the passed std::string
  370|       |  // view. Note that in the case of data equality, a further comparison is made
  371|       |  // on the respective sizes of the two `string_view`s to determine which is
  372|       |  // smaller, equal, or greater.
  373|       |  int compare(string_view x) const noexcept {
  374|       |    auto min_length = (std::min)(length_, x.length_);
  375|       |    if (min_length > 0) {
  376|       |      int r = memcmp(ptr_, x.ptr_, min_length);
  377|       |      if (r < 0) return -1;
  378|       |      if (r > 0) return 1;
  379|       |    }
  380|       |    if (length_ < x.length_) return -1;
  381|       |    if (length_ > x.length_) return 1;
  382|       |    return 0;
  383|       |  }
  384|       |
  385|       |  // Overload of `string_view::compare()` for comparing a substring of the
  386|       |  // 'string_view` and another `absl::string_view`.
  387|      0|  int compare(size_type pos1, size_type count1, string_view v) const {
  388|      0|    return substr(pos1, count1).compare(v);
  389|      0|  }
  390|       |
  391|       |  // Overload of `string_view::compare()` for comparing a substring of the
  392|       |  // `string_view` and a substring of another `absl::string_view`.
  393|       |  int compare(size_type pos1, size_type count1, string_view v, size_type pos2,
  394|      0|              size_type count2) const {
  395|      0|    return substr(pos1, count1).compare(v.substr(pos2, count2));
  396|      0|  }
  397|       |
  398|       |  // Overload of `string_view::compare()` for comparing a `string_view` and a
  399|       |  // a different  C-style std::string `s`.
  400|      0|  int compare(const char* s) const { return compare(string_view(s)); }
  401|       |
  402|       |  // Overload of `string_view::compare()` for comparing a substring of the
  403|       |  // `string_view` and a different std::string C-style std::string `s`.
  404|      0|  int compare(size_type pos1, size_type count1, const char* s) const {
  405|      0|    return substr(pos1, count1).compare(string_view(s));
  406|      0|  }
  407|       |
  408|       |  // Overload of `string_view::compare()` for comparing a substring of the
  409|       |  // `string_view` and a substring of a different C-style std::string `s`.
  410|       |  int compare(size_type pos1, size_type count1, const char* s,
  411|      0|              size_type count2) const {
  412|      0|    return substr(pos1, count1).compare(string_view(s, count2));
  413|      0|  }
  414|       |
  415|       |  // Find Utilities
  416|       |
  417|       |  // string_view::find()
  418|       |  //
  419|       |  // Finds the first occurrence of the substring `s` within the `string_view`,
  420|       |  // returning the position of the first character's match, or `npos` if no
  421|       |  // match was found.
  422|       |  size_type find(string_view s, size_type pos = 0) const noexcept;
  423|       |
  424|       |  // Overload of `string_view::find()` for finding the given character `c`
  425|       |  // within the `string_view`.
  426|       |  size_type find(char c, size_type pos = 0) const noexcept;
  427|       |
  428|       |  // string_view::rfind()
  429|       |  //
  430|       |  // Finds the last occurrence of a substring `s` within the `string_view`,
  431|       |  // returning the position of the first character's match, or `npos` if no
  432|       |  // match was found.
  433|       |  size_type rfind(string_view s, size_type pos = npos) const
  434|       |      noexcept;
  435|       |
  436|       |  // Overload of `string_view::rfind()` for finding the last given character `c`
  437|       |  // within the `string_view`.
  438|       |  size_type rfind(char c, size_type pos = npos) const noexcept;
  439|       |
  440|       |  // string_view::find_first_of()
  441|       |  //
  442|       |  // Finds the first occurrence of any of the characters in `s` within the
  443|       |  // `string_view`, returning the start position of the match, or `npos` if no
  444|       |  // match was found.
  445|       |  size_type find_first_of(string_view s, size_type pos = 0) const
  446|       |      noexcept;
  447|       |
  448|       |  // Overload of `string_view::find_first_of()` for finding a character `c`
  449|       |  // within the `string_view`.
  450|       |  size_type find_first_of(char c, size_type pos = 0) const
  451|      0|      noexcept {
  452|      0|    return find(c, pos);
  453|      0|  }
  454|       |
  455|       |  // string_view::find_last_of()
  456|       |  //
  457|       |  // Finds the last occurrence of any of the characters in `s` within the
  458|       |  // `string_view`, returning the start position of the match, or `npos` if no
  459|       |  // match was found.
  460|       |  size_type find_last_of(string_view s, size_type pos = npos) const
  461|       |      noexcept;
  462|       |
  463|       |  // Overload of `string_view::find_last_of()` for finding a character `c`
  464|       |  // within the `string_view`.
  465|       |  size_type find_last_of(char c, size_type pos = npos) const
  466|      0|      noexcept {
  467|      0|    return rfind(c, pos);
  468|      0|  }
  469|       |
  470|       |  // string_view::find_first_not_of()
  471|       |  //
  472|       |  // Finds the first occurrence of any of the characters not in `s` within the
  473|       |  // `string_view`, returning the start position of the first non-match, or
  474|       |  // `npos` if no non-match was found.
  475|       |  size_type find_first_not_of(string_view s, size_type pos = 0) const noexcept;
  476|       |
  477|       |  // Overload of `string_view::find_first_not_of()` for finding a character
  478|       |  // that is not `c` within the `string_view`.
  479|       |  size_type find_first_not_of(char c, size_type pos = 0) const noexcept;
  480|       |
  481|       |  // string_view::find_last_not_of()
  482|       |  //
  483|       |  // Finds the last occurrence of any of the characters not in `s` within the
  484|       |  // `string_view`, returning the start position of the last non-match, or
  485|       |  // `npos` if no non-match was found.
  486|       |  size_type find_last_not_of(string_view s,
  487|       |                                          size_type pos = npos) const noexcept;
  488|       |
  489|       |  // Overload of `string_view::find_last_not_of()` for finding a character
  490|       |  // that is not `c` within the `string_view`.
  491|       |  size_type find_last_not_of(char c, size_type pos = npos) const
  492|       |      noexcept;
  493|       |
  494|       | private:
  495|       |  static constexpr size_type kMaxSize =
  496|       |      (std::numeric_limits<difference_type>::max)();
  497|       |
  498|      0|  static constexpr size_type CheckLengthInternal(size_type len) {
  499|      0|    return ABSL_ASSERT(len <= kMaxSize), len;
  500|      0|  }
  501|       |
  502|      0|  static constexpr size_type StrlenInternal(const char* str) {
  503|       |#if defined(_MSC_VER) && _MSC_VER >= 1910 && !defined(__clang__)
  504|       |    // MSVC 2017+ can evaluate this at compile-time.
  505|       |    const char* begin = str;
  506|       |    while (*str != '\0') ++str;
  507|       |    return str - begin;
  508|       |#elif ABSL_HAVE_BUILTIN(__builtin_strlen) || \
  509|       |    (defined(__GNUC__) && !defined(__clang__))
  510|       |    // GCC has __builtin_strlen according to
  511|      0|    // https://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Other-Builtins.html, but
  512|      0|    // ABSL_HAVE_BUILTIN doesn't detect that, so we use the extra checks above.
  513|      0|    // __builtin_strlen is constexpr.
  514|      0|    return __builtin_strlen(str);
  515|       |#else
  516|       |    return str ? strlen(str) : 0;
  517|       |#endif
  518|       |  }
  519|       |
  520|       |  const char* ptr_;
  521|       |  size_type length_;
  522|       |};
  523|       |
  524|       |// This large function is defined inline so that in a fairly common case where
  525|       |// one of the arguments is a literal, the compiler can elide a lot of the
  526|       |// following comparisons.
  527|       |inline bool operator==(string_view x, string_view y) noexcept {
  528|       |  auto len = x.size();
  529|       |  if (len != y.size()) {
  530|       |    return false;
  531|       |  }
  532|       |
  533|       |  return x.data() == y.data() || len <= 0 ||
  534|       |         memcmp(x.data(), y.data(), len) == 0;
  535|       |}
  536|       |
  537|       |inline bool operator!=(string_view x, string_view y) noexcept {
  538|       |  return !(x == y);
  539|       |}
  540|       |
  541|      0|inline bool operator<(string_view x, string_view y) noexcept {
  542|      0|  auto min_size = (std::min)(x.size(), y.size());
  543|      0|  const int r = min_size == 0 ? 0 : memcmp(x.data(), y.data(), min_size);
  544|      0|  return (r < 0) || (r == 0 && x.size() < y.size());
  545|      0|}
  546|       |
  547|      0|inline bool operator>(string_view x, string_view y) noexcept { return y < x; }
  548|       |
  549|      0|inline bool operator<=(string_view x, string_view y) noexcept {
  550|      0|  return !(y < x);
  551|      0|}
  552|       |
  553|      0|inline bool operator>=(string_view x, string_view y) noexcept {
  554|      0|  return !(x < y);
  555|      0|}
  556|       |
  557|       |// IO Insertion Operator
  558|       |std::ostream& operator<<(std::ostream& o, string_view piece);
  559|       |
  560|       |}  // inline namespace lts_2019_08_08
  561|       |}  // namespace absl
  562|       |
  563|       |#endif  // ABSL_HAVE_STD_STRING_VIEW
  564|       |
  565|       |namespace absl {
  566|       |inline namespace lts_2019_08_08 {
  567|       |
  568|       |// ClippedSubstr()
  569|       |//
  570|       |// Like `s.substr(pos, n)`, but clips `pos` to an upper bound of `s.size()`.
  571|       |// Provided because std::string_view::substr throws if `pos > size()`
  572|       |inline string_view ClippedSubstr(string_view s, size_t pos,
  573|      0|                                 size_t n = string_view::npos) {
  574|      0|  pos = (std::min)(pos, static_cast<size_t>(s.size()));
  575|      0|  return s.substr(pos, n);
  576|      0|}
  577|       |
  578|       |// NullSafeStringView()
  579|       |//
  580|       |// Creates an `absl::string_view` from a pointer `p` even if it's null-valued.
  581|       |// This function should be used where an `absl::string_view` can be created from
  582|       |// a possibly-null pointer.
  583|      0|inline string_view NullSafeStringView(const char* p) {
  584|      0|  return p ? string_view(p) : string_view();
  585|      0|}
  586|       |
  587|       |}  // inline namespace lts_2019_08_08
  588|       |}  // namespace absl
  589|       |
  590|       |#endif  // ABSL_STRINGS_STRING_VIEW_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/strip.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: strip.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This file contains various functions for stripping substrings from a string.
   21|       |#ifndef ABSL_STRINGS_STRIP_H_
   22|       |#define ABSL_STRINGS_STRIP_H_
   23|       |
   24|       |#include <cstddef>
   25|       |#include <string>
   26|       |
   27|       |#include "absl/base/macros.h"
   28|       |#include "absl/strings/ascii.h"
   29|       |#include "absl/strings/match.h"
   30|       |#include "absl/strings/string_view.h"
   31|       |
   32|       |namespace absl {
   33|       |inline namespace lts_2019_08_08 {
   34|       |
   35|       |// ConsumePrefix()
   36|       |//
   37|       |// Strips the `expected` prefix from the start of the given string, returning
   38|       |// `true` if the strip operation succeeded or false otherwise.
   39|       |//
   40|       |// Example:
   41|       |//
   42|       |//   absl::string_view input("abc");
   43|       |//   EXPECT_TRUE(absl::ConsumePrefix(&input, "a"));
   44|       |//   EXPECT_EQ(input, "bc");
   45|      0|inline bool ConsumePrefix(absl::string_view* str, absl::string_view expected) {
   46|      0|  if (!absl::StartsWith(*str, expected)) return false;
   47|      0|  str->remove_prefix(expected.size());
   48|      0|  return true;
   49|      0|}
   50|       |// ConsumeSuffix()
   51|       |//
   52|       |// Strips the `expected` suffix from the end of the given string, returning
   53|       |// `true` if the strip operation succeeded or false otherwise.
   54|       |//
   55|       |// Example:
   56|       |//
   57|       |//   absl::string_view input("abcdef");
   58|       |//   EXPECT_TRUE(absl::ConsumeSuffix(&input, "def"));
   59|       |//   EXPECT_EQ(input, "abc");
   60|      0|inline bool ConsumeSuffix(absl::string_view* str, absl::string_view expected) {
   61|      0|  if (!absl::EndsWith(*str, expected)) return false;
   62|      0|  str->remove_suffix(expected.size());
   63|      0|  return true;
   64|      0|}
   65|       |
   66|       |// StripPrefix()
   67|       |//
   68|       |// Returns a view into the input string 'str' with the given 'prefix' removed,
   69|       |// but leaving the original string intact. If the prefix does not match at the
   70|       |// start of the string, returns the original string instead.
   71|       |ABSL_MUST_USE_RESULT inline absl::string_view StripPrefix(
   72|      0|    absl::string_view str, absl::string_view prefix) {
   73|      0|  if (absl::StartsWith(str, prefix)) str.remove_prefix(prefix.size());
   74|      0|  return str;
   75|      0|}
   76|       |
   77|       |// StripSuffix()
   78|       |//
   79|       |// Returns a view into the input string 'str' with the given 'suffix' removed,
   80|       |// but leaving the original string intact. If the suffix does not match at the
   81|       |// end of the string, returns the original string instead.
   82|       |ABSL_MUST_USE_RESULT inline absl::string_view StripSuffix(
   83|      0|    absl::string_view str, absl::string_view suffix) {
   84|      0|  if (absl::EndsWith(str, suffix)) str.remove_suffix(suffix.size());
   85|      0|  return str;
   86|      0|}
   87|       |
   88|       |}  // inline namespace lts_2019_08_08
   89|       |}  // namespace absl
   90|       |
   91|       |#endif  // ABSL_STRINGS_STRIP_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/substitute.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/strings/substitute.h"
   16|       |
   17|       |#include <algorithm>
   18|       |
   19|       |#include "absl/base/internal/raw_logging.h"
   20|       |#include "absl/strings/ascii.h"
   21|       |#include "absl/strings/escaping.h"
   22|       |#include "absl/strings/internal/resize_uninitialized.h"
   23|       |#include "absl/strings/string_view.h"
   24|       |
   25|       |namespace absl {
   26|       |inline namespace lts_2019_08_08 {
   27|       |namespace substitute_internal {
   28|       |
   29|       |void SubstituteAndAppendArray(std::string* output, absl::string_view format,
   30|       |                              const absl::string_view* args_array,
   31|      0|                              size_t num_args) {
   32|      0|  // Determine total size needed.
   33|      0|  size_t size = 0;
   34|      0|  for (size_t i = 0; i < format.size(); i++) {
   35|      0|    if (format[i] == '$') {
   36|      0|      if (i + 1 >= format.size()) {
   37|      0|#ifndef NDEBUG
   38|      0|        ABSL_RAW_LOG(FATAL,
   39|      0|                     "Invalid strings::Substitute() format std::string: \"%s\".",
   40|      0|                     absl::CEscape(format).c_str());
   41|      0|#endif
   42|      0|        return;
   43|      0|      } else if (absl::ascii_isdigit(format[i + 1])) {
   44|      0|        int index = format[i + 1] - '0';
   45|      0|        if (static_cast<size_t>(index) >= num_args) {
   46|      0|#ifndef NDEBUG
   47|      0|          ABSL_RAW_LOG(
   48|      0|              FATAL,
   49|      0|              "Invalid strings::Substitute() format std::string: asked for \"$"
   50|      0|              "%d\", but only %d args were given.  Full format std::string was: "
   51|      0|              "\"%s\".",
   52|      0|              index, static_cast<int>(num_args), absl::CEscape(format).c_str());
   53|      0|#endif
   54|      0|          return;
   55|      0|        }
   56|      0|        size += args_array[index].size();
   57|      0|        ++i;  // Skip next char.
   58|      0|      } else if (format[i + 1] == '$') {
   59|      0|        ++size;
   60|      0|        ++i;  // Skip next char.
   61|      0|      } else {
   62|      0|#ifndef NDEBUG
   63|      0|        ABSL_RAW_LOG(FATAL,
   64|      0|                     "Invalid strings::Substitute() format std::string: \"%s\".",
   65|      0|                     absl::CEscape(format).c_str());
   66|      0|#endif
   67|      0|        return;
   68|      0|      }
   69|      0|    } else {
   70|      0|      ++size;
   71|      0|    }
   72|      0|  }
   73|      0|
   74|      0|  if (size == 0) return;
   75|      0|
   76|      0|  // Build the std::string.
   77|      0|  size_t original_size = output->size();
   78|      0|  strings_internal::STLStringResizeUninitialized(output, original_size + size);
   79|      0|  char* target = &(*output)[original_size];
   80|      0|  for (size_t i = 0; i < format.size(); i++) {
   81|      0|    if (format[i] == '$') {
   82|      0|      if (absl::ascii_isdigit(format[i + 1])) {
   83|      0|        const absl::string_view src = args_array[format[i + 1] - '0'];
   84|      0|        target = std::copy(src.begin(), src.end(), target);
   85|      0|        ++i;  // Skip next char.
   86|      0|      } else if (format[i + 1] == '$') {
   87|      0|        *target++ = '$';
   88|      0|        ++i;  // Skip next char.
   89|      0|      }
   90|      0|    } else {
   91|      0|      *target++ = format[i];
   92|      0|    }
   93|      0|  }
   94|      0|
   95|      0|  assert(target == output->data() + output->size());
   96|      0|}
   97|       |
   98|       |static const char kHexDigits[] = "0123456789abcdef";
   99|      0|Arg::Arg(const void* value) {
  100|      0|  static_assert(sizeof(scratch_) >= sizeof(value) * 2 + 2,
  101|      0|                "fix sizeof(scratch_)");
  102|      0|  if (value == nullptr) {
  103|      0|    piece_ = "NULL";
  104|      0|  } else {
  105|      0|    char* ptr = scratch_ + sizeof(scratch_);
  106|      0|    uintptr_t num = reinterpret_cast<uintptr_t>(value);
  107|      0|    do {
  108|      0|      *--ptr = kHexDigits[num & 0xf];
  109|      0|      num >>= 4;
  110|      0|    } while (num != 0);
  111|      0|    *--ptr = 'x';
  112|      0|    *--ptr = '0';
  113|      0|    piece_ = absl::string_view(ptr, scratch_ + sizeof(scratch_) - ptr);
  114|      0|  }
  115|      0|}
  116|       |
  117|       |// TODO(jorg): Don't duplicate so much code between here and str_cat.cc
  118|      0|Arg::Arg(Hex hex) {
  119|      0|  char* const end = &scratch_[numbers_internal::kFastToBufferSize];
  120|      0|  char* writer = end;
  121|      0|  uint64_t value = hex.value;
  122|      0|  do {
  123|      0|    *--writer = kHexDigits[value & 0xF];
  124|      0|    value >>= 4;
  125|      0|  } while (value != 0);
  126|      0|
  127|      0|  char* beg;
  128|      0|  if (end - writer < hex.width) {
  129|      0|    beg = end - hex.width;
  130|      0|    std::fill_n(beg, writer - beg, hex.fill);
  131|      0|  } else {
  132|      0|    beg = writer;
  133|      0|  }
  134|      0|
  135|      0|  piece_ = absl::string_view(beg, end - beg);
  136|      0|}
  137|       |
  138|       |// TODO(jorg): Don't duplicate so much code between here and str_cat.cc
  139|      0|Arg::Arg(Dec dec) {
  140|      0|  assert(dec.width <= numbers_internal::kFastToBufferSize);
  141|      0|  char* const end = &scratch_[numbers_internal::kFastToBufferSize];
  142|      0|  char* const minfill = end - dec.width;
  143|      0|  char* writer = end;
  144|      0|  uint64_t value = dec.value;
  145|      0|  bool neg = dec.neg;
  146|      0|  while (value > 9) {
  147|      0|    *--writer = '0' + (value % 10);
  148|      0|    value /= 10;
  149|      0|  }
  150|      0|  *--writer = '0' + value;
  151|      0|  if (neg) *--writer = '-';
  152|      0|
  153|      0|  ptrdiff_t fillers = writer - minfill;
  154|      0|  if (fillers > 0) {
  155|      0|    // Tricky: if the fill character is ' ', then it's <fill><+/-><digits>
  156|      0|    // But...: if the fill character is '0', then it's <+/-><fill><digits>
  157|      0|    bool add_sign_again = false;
  158|      0|    if (neg && dec.fill == '0') {  // If filling with '0',
  159|      0|      ++writer;                    // ignore the sign we just added
  160|      0|      add_sign_again = true;       // and re-add the sign later.
  161|      0|    }
  162|      0|    writer -= fillers;
  163|      0|    std::fill_n(writer, fillers, dec.fill);
  164|      0|    if (add_sign_again) *--writer = '-';
  165|      0|  }
  166|      0|
  167|      0|  piece_ = absl::string_view(writer, end - writer);
  168|      0|}
  169|       |
  170|       |}  // namespace substitute_internal
  171|       |}  // inline namespace lts_2019_08_08
  172|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/strings/substitute.h:
    1|       |//
    2|       |// Copyright 2017 The Abseil Authors.
    3|       |//
    4|       |// Licensed under the Apache License, Version 2.0 (the "License");
    5|       |// you may not use this file except in compliance with the License.
    6|       |// You may obtain a copy of the License at
    7|       |//
    8|       |//      https://www.apache.org/licenses/LICENSE-2.0
    9|       |//
   10|       |// Unless required by applicable law or agreed to in writing, software
   11|       |// distributed under the License is distributed on an "AS IS" BASIS,
   12|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |// See the License for the specific language governing permissions and
   14|       |// limitations under the License.
   15|       |//
   16|       |// -----------------------------------------------------------------------------
   17|       |// File: substitute.h
   18|       |// -----------------------------------------------------------------------------
   19|       |//
   20|       |// This package contains functions for efficiently performing string
   21|       |// substitutions using a format string with positional notation:
   22|       |// `Substitute()` and `SubstituteAndAppend()`.
   23|       |//
   24|       |// Unlike printf-style format specifiers, `Substitute()` functions do not need
   25|       |// to specify the type of the substitution arguments. Supported arguments
   26|       |// following the format string, such as strings, string_views, ints,
   27|       |// floats, and bools, are automatically converted to strings during the
   28|       |// substitution process. (See below for a full list of supported types.)
   29|       |//
   30|       |// `Substitute()` does not allow you to specify *how* to format a value, beyond
   31|       |// the default conversion to string. For example, you cannot format an integer
   32|       |// in hex.
   33|       |//
   34|       |// The format string uses positional identifiers indicated by a dollar sign ($)
   35|       |// and single digit positional ids to indicate which substitution arguments to
   36|       |// use at that location within the format string.
   37|       |//
   38|       |// A '$$' sequence in the format string causes a literal '$' character to be
   39|       |// output.
   40|       |//
   41|       |// Example 1:
   42|       |//   std::string s = Substitute("$1 purchased $0 $2 for $$10. Thanks $1!",
   43|       |//                              5, "Bob", "Apples");
   44|       |//   EXPECT_EQ("Bob purchased 5 Apples for $10. Thanks Bob!", s);
   45|       |//
   46|       |// Example 2:
   47|       |//   std::string s = "Hi. ";
   48|       |//   SubstituteAndAppend(&s, "My name is $0 and I am $1 years old.", "Bob", 5);
   49|       |//   EXPECT_EQ("Hi. My name is Bob and I am 5 years old.", s);
   50|       |//
   51|       |// Supported types:
   52|       |//   * absl::string_view, std::string, const char* (null is equivalent to "")
   53|       |//   * int32_t, int64_t, uint32_t, uint64
   54|       |//   * float, double
   55|       |//   * bool (Printed as "true" or "false")
   56|       |//   * pointer types other than char* (Printed as "0x<lower case hex string>",
   57|       |//     except that null is printed as "NULL")
   58|       |//
   59|       |// If an invalid format string is provided, Substitute returns an empty string
   60|       |// and SubstituteAndAppend does not change the provided output string.
   61|       |// A format string is invalid if it:
   62|       |//   * ends in an unescaped $ character,
   63|       |//     e.g. "Hello $", or
   64|       |//   * calls for a position argument which is not provided,
   65|       |//     e.g. Substitute("Hello $2", "world"), or
   66|       |//   * specifies a non-digit, non-$ character after an unescaped $ character,
   67|       |//     e.g. "Hello $f".
   68|       |// In debug mode, i.e. #ifndef NDEBUG, such errors terminate the program.
   69|       |
   70|       |#ifndef ABSL_STRINGS_SUBSTITUTE_H_
   71|       |#define ABSL_STRINGS_SUBSTITUTE_H_
   72|       |
   73|       |#include <cstring>
   74|       |#include <string>
   75|       |#include <type_traits>
   76|       |#include <vector>
   77|       |
   78|       |#include "absl/base/macros.h"
   79|       |#include "absl/base/port.h"
   80|       |#include "absl/strings/ascii.h"
   81|       |#include "absl/strings/escaping.h"
   82|       |#include "absl/strings/numbers.h"
   83|       |#include "absl/strings/str_cat.h"
   84|       |#include "absl/strings/str_split.h"
   85|       |#include "absl/strings/string_view.h"
   86|       |#include "absl/strings/strip.h"
   87|       |
   88|       |namespace absl {
   89|       |inline namespace lts_2019_08_08 {
   90|       |namespace substitute_internal {
   91|       |
   92|       |// Arg
   93|       |//
   94|       |// This class provides an argument type for `absl::Substitute()` and
   95|       |// `absl::SubstituteAndAppend()`. `Arg` handles implicit conversion of various
   96|       |// types to a string. (`Arg` is very similar to the `AlphaNum` class in
   97|       |// `StrCat()`.)
   98|       |//
   99|       |// This class has implicit constructors.
  100|       |class Arg {
  101|       | public:
  102|       |  // Overloads for std::string-y things
  103|       |  //
  104|       |  // Explicitly overload `const char*` so the compiler doesn't cast to `bool`.
  105|       |  Arg(const char* value)  // NOLINT(runtime/explicit)
  106|      0|      : piece_(absl::NullSafeStringView(value)) {}
  107|       |  template <typename Allocator>
  108|       |  Arg(  // NOLINT
  109|       |      const std::basic_string<char, std::char_traits<char>, Allocator>&
  110|       |          value) noexcept
  111|       |      : piece_(value) {}
  112|       |  Arg(absl::string_view value)  // NOLINT(runtime/explicit)
  113|      0|      : piece_(value) {}
  114|       |
  115|       |  // Overloads for primitives
  116|       |  //
  117|       |  // No overloads are available for signed and unsigned char because if people
  118|       |  // are explicitly declaring their chars as signed or unsigned then they are
  119|       |  // probably using them as 8-bit integers and would probably prefer an integer
  120|       |  // representation. However, we can't really know, so we make the caller decide
  121|       |  // what to do.
  122|       |  Arg(char value)  // NOLINT(runtime/explicit)
  123|      0|      : piece_(scratch_, 1) { scratch_[0] = value; }
  124|       |  Arg(short value)  // NOLINT(*)
  125|       |      : piece_(scratch_,
  126|      0|               numbers_internal::FastIntToBuffer(value, scratch_) - scratch_) {}
  127|       |  Arg(unsigned short value)  // NOLINT(*)
  128|       |      : piece_(scratch_,
  129|      0|               numbers_internal::FastIntToBuffer(value, scratch_) - scratch_) {}
  130|       |  Arg(int value)  // NOLINT(runtime/explicit)
  131|       |      : piece_(scratch_,
  132|      0|               numbers_internal::FastIntToBuffer(value, scratch_) - scratch_) {}
  133|       |  Arg(unsigned int value)  // NOLINT(runtime/explicit)
  134|       |      : piece_(scratch_,
  135|      0|               numbers_internal::FastIntToBuffer(value, scratch_) - scratch_) {}
  136|       |  Arg(long value)  // NOLINT(*)
  137|       |      : piece_(scratch_,
  138|      0|               numbers_internal::FastIntToBuffer(value, scratch_) - scratch_) {}
  139|       |  Arg(unsigned long value)  // NOLINT(*)
  140|       |      : piece_(scratch_,
  141|      0|               numbers_internal::FastIntToBuffer(value, scratch_) - scratch_) {}
  142|       |  Arg(long long value)  // NOLINT(*)
  143|       |      : piece_(scratch_,
  144|      0|               numbers_internal::FastIntToBuffer(value, scratch_) - scratch_) {}
  145|       |  Arg(unsigned long long value)  // NOLINT(*)
  146|       |      : piece_(scratch_,
  147|      0|               numbers_internal::FastIntToBuffer(value, scratch_) - scratch_) {}
  148|       |  Arg(float value)  // NOLINT(runtime/explicit)
  149|      0|      : piece_(scratch_, numbers_internal::SixDigitsToBuffer(value, scratch_)) {
  150|      0|  }
  151|       |  Arg(double value)  // NOLINT(runtime/explicit)
  152|      0|      : piece_(scratch_, numbers_internal::SixDigitsToBuffer(value, scratch_)) {
  153|      0|  }
  154|       |  Arg(bool value)  // NOLINT(runtime/explicit)
  155|      0|      : piece_(value ? "true" : "false") {}
  156|       |
  157|       |  Arg(Hex hex);  // NOLINT(runtime/explicit)
  158|       |  Arg(Dec dec);  // NOLINT(runtime/explicit)
  159|       |
  160|       |  // vector<bool>::reference and const_reference require special help to
  161|       |  // convert to `AlphaNum` because it requires two user defined conversions.
  162|       |  template <typename T,
  163|       |            absl::enable_if_t<
  164|       |                std::is_class<T>::value &&
  165|       |                (std::is_same<T, std::vector<bool>::reference>::value ||
  166|       |                 std::is_same<T, std::vector<bool>::const_reference>::value)>* =
  167|       |                nullptr>
  168|       |  Arg(T value)  // NOLINT(google-explicit-constructor)
  169|       |      : Arg(static_cast<bool>(value)) {}
  170|       |
  171|       |  // `void*` values, with the exception of `char*`, are printed as
  172|       |  // "0x<hex value>". However, in the case of `nullptr`, "NULL" is printed.
  173|       |  Arg(const void* value);  // NOLINT(runtime/explicit)
  174|       |
  175|       |  Arg(const Arg&) = delete;
  176|       |  Arg& operator=(const Arg&) = delete;
  177|       |
  178|      0|  absl::string_view piece() const { return piece_; }
  179|       |
  180|       | private:
  181|       |  absl::string_view piece_;
  182|       |  char scratch_[numbers_internal::kFastToBufferSize];
  183|       |};
  184|       |
  185|       |// Internal helper function. Don't call this from outside this implementation.
  186|       |// This interface may change without notice.
  187|       |void SubstituteAndAppendArray(std::string* output, absl::string_view format,
  188|       |                              const absl::string_view* args_array,
  189|       |                              size_t num_args);
  190|       |
  191|       |#if defined(ABSL_BAD_CALL_IF)
  192|      0|constexpr int CalculateOneBit(const char* format) {
  193|      0|  return (*format < '0' || *format > '9') ? 0 : (1 << (*format - '0'));
  194|      0|}
  195|       |
  196|      0|constexpr const char* SkipNumber(const char* format) {
  197|      0|  return !*format ? format : (format + 1);
  198|      0|}
  199|       |
  200|      0|constexpr int PlaceholderBitmask(const char* format) {
  201|      0|  return !*format ? 0 : *format != '$'
  202|      0|                             ? PlaceholderBitmask(format + 1)
  203|      0|                             : (CalculateOneBit(format + 1) |
  204|      0|                                   PlaceholderBitmask(SkipNumber(format + 1)));
  205|      0|}
  206|       |#endif  // ABSL_BAD_CALL_IF
  207|       |
  208|       |}  // namespace substitute_internal
  209|       |
  210|       |//
  211|       |// PUBLIC API
  212|       |//
  213|       |
  214|       |// SubstituteAndAppend()
  215|       |//
  216|       |// Substitutes variables into a given format string and appends to a given
  217|       |// output string. See file comments above for usage.
  218|       |//
  219|       |// The declarations of `SubstituteAndAppend()` below consist of overloads
  220|       |// for passing 0 to 10 arguments, respectively.
  221|       |//
  222|       |// NOTE: A zero-argument `SubstituteAndAppend()` may be used within variadic
  223|       |// templates to allow a variable number of arguments.
  224|       |//
  225|       |// Example:
  226|       |//  template <typename... Args>
  227|       |//  void VarMsg(std::string* boilerplate, absl::string_view format,
  228|       |//      const Args&... args) {
  229|       |//    absl::SubstituteAndAppend(boilerplate, format, args...);
  230|       |//  }
  231|       |//
  232|      0|inline void SubstituteAndAppend(std::string* output, absl::string_view format) {
  233|      0|  substitute_internal::SubstituteAndAppendArray(output, format, nullptr, 0);
  234|      0|}
  235|       |
  236|       |inline void SubstituteAndAppend(std::string* output, absl::string_view format,
  237|      0|                                const substitute_internal::Arg& a0) {
  238|      0|  const absl::string_view args[] = {a0.piece()};
  239|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  240|      0|                                                ABSL_ARRAYSIZE(args));
  241|      0|}
  242|       |
  243|       |inline void SubstituteAndAppend(std::string* output, absl::string_view format,
  244|       |                                const substitute_internal::Arg& a0,
  245|      0|                                const substitute_internal::Arg& a1) {
  246|      0|  const absl::string_view args[] = {a0.piece(), a1.piece()};
  247|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  248|      0|                                                ABSL_ARRAYSIZE(args));
  249|      0|}
  250|       |
  251|       |inline void SubstituteAndAppend(std::string* output, absl::string_view format,
  252|       |                                const substitute_internal::Arg& a0,
  253|       |                                const substitute_internal::Arg& a1,
  254|      0|                                const substitute_internal::Arg& a2) {
  255|      0|  const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece()};
  256|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  257|      0|                                                ABSL_ARRAYSIZE(args));
  258|      0|}
  259|       |
  260|       |inline void SubstituteAndAppend(std::string* output, absl::string_view format,
  261|       |                                const substitute_internal::Arg& a0,
  262|       |                                const substitute_internal::Arg& a1,
  263|       |                                const substitute_internal::Arg& a2,
  264|      0|                                const substitute_internal::Arg& a3) {
  265|      0|  const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
  266|      0|                                    a3.piece()};
  267|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  268|      0|                                                ABSL_ARRAYSIZE(args));
  269|      0|}
  270|       |
  271|       |inline void SubstituteAndAppend(std::string* output, absl::string_view format,
  272|       |                                const substitute_internal::Arg& a0,
  273|       |                                const substitute_internal::Arg& a1,
  274|       |                                const substitute_internal::Arg& a2,
  275|       |                                const substitute_internal::Arg& a3,
  276|      0|                                const substitute_internal::Arg& a4) {
  277|      0|  const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
  278|      0|                                    a3.piece(), a4.piece()};
  279|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  280|      0|                                                ABSL_ARRAYSIZE(args));
  281|      0|}
  282|       |
  283|       |inline void SubstituteAndAppend(std::string* output, absl::string_view format,
  284|       |                                const substitute_internal::Arg& a0,
  285|       |                                const substitute_internal::Arg& a1,
  286|       |                                const substitute_internal::Arg& a2,
  287|       |                                const substitute_internal::Arg& a3,
  288|       |                                const substitute_internal::Arg& a4,
  289|      0|                                const substitute_internal::Arg& a5) {
  290|      0|  const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
  291|      0|                                    a3.piece(), a4.piece(), a5.piece()};
  292|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  293|      0|                                                ABSL_ARRAYSIZE(args));
  294|      0|}
  295|       |
  296|       |inline void SubstituteAndAppend(std::string* output, absl::string_view format,
  297|       |                                const substitute_internal::Arg& a0,
  298|       |                                const substitute_internal::Arg& a1,
  299|       |                                const substitute_internal::Arg& a2,
  300|       |                                const substitute_internal::Arg& a3,
  301|       |                                const substitute_internal::Arg& a4,
  302|       |                                const substitute_internal::Arg& a5,
  303|      0|                                const substitute_internal::Arg& a6) {
  304|      0|  const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
  305|      0|                                    a3.piece(), a4.piece(), a5.piece(),
  306|      0|                                    a6.piece()};
  307|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  308|      0|                                                ABSL_ARRAYSIZE(args));
  309|      0|}
  310|       |
  311|       |inline void SubstituteAndAppend(
  312|       |    std::string* output, absl::string_view format,
  313|       |    const substitute_internal::Arg& a0, const substitute_internal::Arg& a1,
  314|       |    const substitute_internal::Arg& a2, const substitute_internal::Arg& a3,
  315|       |    const substitute_internal::Arg& a4, const substitute_internal::Arg& a5,
  316|      0|    const substitute_internal::Arg& a6, const substitute_internal::Arg& a7) {
  317|      0|  const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
  318|      0|                                    a3.piece(), a4.piece(), a5.piece(),
  319|      0|                                    a6.piece(), a7.piece()};
  320|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  321|      0|                                                ABSL_ARRAYSIZE(args));
  322|      0|}
  323|       |
  324|       |inline void SubstituteAndAppend(
  325|       |    std::string* output, absl::string_view format,
  326|       |    const substitute_internal::Arg& a0, const substitute_internal::Arg& a1,
  327|       |    const substitute_internal::Arg& a2, const substitute_internal::Arg& a3,
  328|       |    const substitute_internal::Arg& a4, const substitute_internal::Arg& a5,
  329|       |    const substitute_internal::Arg& a6, const substitute_internal::Arg& a7,
  330|      0|    const substitute_internal::Arg& a8) {
  331|      0|  const absl::string_view args[] = {a0.piece(), a1.piece(), a2.piece(),
  332|      0|                                    a3.piece(), a4.piece(), a5.piece(),
  333|      0|                                    a6.piece(), a7.piece(), a8.piece()};
  334|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  335|      0|                                                ABSL_ARRAYSIZE(args));
  336|      0|}
  337|       |
  338|       |inline void SubstituteAndAppend(
  339|       |    std::string* output, absl::string_view format,
  340|       |    const substitute_internal::Arg& a0, const substitute_internal::Arg& a1,
  341|       |    const substitute_internal::Arg& a2, const substitute_internal::Arg& a3,
  342|       |    const substitute_internal::Arg& a4, const substitute_internal::Arg& a5,
  343|       |    const substitute_internal::Arg& a6, const substitute_internal::Arg& a7,
  344|      0|    const substitute_internal::Arg& a8, const substitute_internal::Arg& a9) {
  345|      0|  const absl::string_view args[] = {
  346|      0|      a0.piece(), a1.piece(), a2.piece(), a3.piece(), a4.piece(),
  347|      0|      a5.piece(), a6.piece(), a7.piece(), a8.piece(), a9.piece()};
  348|      0|  substitute_internal::SubstituteAndAppendArray(output, format, args,
  349|      0|                                                ABSL_ARRAYSIZE(args));
  350|      0|}
  351|       |
  352|       |#if defined(ABSL_BAD_CALL_IF)
  353|       |// This body of functions catches cases where the number of placeholders
  354|       |// doesn't match the number of data arguments.
  355|       |void SubstituteAndAppend(std::string* output, const char* format)
  356|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 0,
  357|       |                     "There were no substitution arguments "
  358|       |                     "but this format std::string has a $[0-9] in it");
  359|       |
  360|       |void SubstituteAndAppend(std::string* output, const char* format,
  361|       |                         const substitute_internal::Arg& a0)
  362|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 1,
  363|       |                     "There was 1 substitution argument given, but "
  364|       |                     "this format std::string is either missing its $0, or "
  365|       |                     "contains one of $1-$9");
  366|       |
  367|       |void SubstituteAndAppend(std::string* output, const char* format,
  368|       |                         const substitute_internal::Arg& a0,
  369|       |                         const substitute_internal::Arg& a1)
  370|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 3,
  371|       |                     "There were 2 substitution arguments given, but "
  372|       |                     "this format std::string is either missing its $0/$1, or "
  373|       |                     "contains one of $2-$9");
  374|       |
  375|       |void SubstituteAndAppend(std::string* output, const char* format,
  376|       |                         const substitute_internal::Arg& a0,
  377|       |                         const substitute_internal::Arg& a1,
  378|       |                         const substitute_internal::Arg& a2)
  379|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 7,
  380|       |                     "There were 3 substitution arguments given, but "
  381|       |                     "this format std::string is either missing its $0/$1/$2, or "
  382|       |                     "contains one of $3-$9");
  383|       |
  384|       |void SubstituteAndAppend(std::string* output, const char* format,
  385|       |                         const substitute_internal::Arg& a0,
  386|       |                         const substitute_internal::Arg& a1,
  387|       |                         const substitute_internal::Arg& a2,
  388|       |                         const substitute_internal::Arg& a3)
  389|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 15,
  390|       |                     "There were 4 substitution arguments given, but "
  391|       |                     "this format std::string is either missing its $0-$3, or "
  392|       |                     "contains one of $4-$9");
  393|       |
  394|       |void SubstituteAndAppend(std::string* output, const char* format,
  395|       |                         const substitute_internal::Arg& a0,
  396|       |                         const substitute_internal::Arg& a1,
  397|       |                         const substitute_internal::Arg& a2,
  398|       |                         const substitute_internal::Arg& a3,
  399|       |                         const substitute_internal::Arg& a4)
  400|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 31,
  401|       |                     "There were 5 substitution arguments given, but "
  402|       |                     "this format std::string is either missing its $0-$4, or "
  403|       |                     "contains one of $5-$9");
  404|       |
  405|       |void SubstituteAndAppend(std::string* output, const char* format,
  406|       |                         const substitute_internal::Arg& a0,
  407|       |                         const substitute_internal::Arg& a1,
  408|       |                         const substitute_internal::Arg& a2,
  409|       |                         const substitute_internal::Arg& a3,
  410|       |                         const substitute_internal::Arg& a4,
  411|       |                         const substitute_internal::Arg& a5)
  412|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 63,
  413|       |                     "There were 6 substitution arguments given, but "
  414|       |                     "this format std::string is either missing its $0-$5, or "
  415|       |                     "contains one of $6-$9");
  416|       |
  417|       |void SubstituteAndAppend(
  418|       |    std::string* output, const char* format, const substitute_internal::Arg& a0,
  419|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  420|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  421|       |    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6)
  422|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 127,
  423|       |                     "There were 7 substitution arguments given, but "
  424|       |                     "this format std::string is either missing its $0-$6, or "
  425|       |                     "contains one of $7-$9");
  426|       |
  427|       |void SubstituteAndAppend(
  428|       |    std::string* output, const char* format, const substitute_internal::Arg& a0,
  429|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  430|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  431|       |    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
  432|       |    const substitute_internal::Arg& a7)
  433|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 255,
  434|       |                     "There were 8 substitution arguments given, but "
  435|       |                     "this format std::string is either missing its $0-$7, or "
  436|       |                     "contains one of $8-$9");
  437|       |
  438|       |void SubstituteAndAppend(
  439|       |    std::string* output, const char* format, const substitute_internal::Arg& a0,
  440|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  441|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  442|       |    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
  443|       |    const substitute_internal::Arg& a7, const substitute_internal::Arg& a8)
  444|       |    ABSL_BAD_CALL_IF(
  445|       |        substitute_internal::PlaceholderBitmask(format) != 511,
  446|       |        "There were 9 substitution arguments given, but "
  447|       |        "this format std::string is either missing its $0-$8, or contains a $9");
  448|       |
  449|       |void SubstituteAndAppend(
  450|       |    std::string* output, const char* format, const substitute_internal::Arg& a0,
  451|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  452|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  453|       |    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
  454|       |    const substitute_internal::Arg& a7, const substitute_internal::Arg& a8,
  455|       |    const substitute_internal::Arg& a9)
  456|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 1023,
  457|       |                     "There were 10 substitution arguments given, but this "
  458|       |                     "format std::string doesn't contain all of $0 through $9");
  459|       |#endif  // ABSL_BAD_CALL_IF
  460|       |
  461|       |// Substitute()
  462|       |//
  463|       |// Substitutes variables into a given format string. See file comments above
  464|       |// for usage.
  465|       |//
  466|       |// The declarations of `Substitute()` below consist of overloads for passing 0
  467|       |// to 10 arguments, respectively.
  468|       |//
  469|       |// NOTE: A zero-argument `Substitute()` may be used within variadic templates to
  470|       |// allow a variable number of arguments.
  471|       |//
  472|       |// Example:
  473|       |//  template <typename... Args>
  474|       |//  void VarMsg(absl::string_view format, const Args&... args) {
  475|       |//    std::string s = absl::Substitute(format, args...);
  476|       |
  477|      0|ABSL_MUST_USE_RESULT inline std::string Substitute(absl::string_view format) {
  478|      0|  std::string result;
  479|      0|  SubstituteAndAppend(&result, format);
  480|      0|  return result;
  481|      0|}
  482|       |
  483|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  484|      0|    absl::string_view format, const substitute_internal::Arg& a0) {
  485|      0|  std::string result;
  486|      0|  SubstituteAndAppend(&result, format, a0);
  487|      0|  return result;
  488|      0|}
  489|       |
  490|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  491|       |    absl::string_view format, const substitute_internal::Arg& a0,
  492|      0|    const substitute_internal::Arg& a1) {
  493|      0|  std::string result;
  494|      0|  SubstituteAndAppend(&result, format, a0, a1);
  495|      0|  return result;
  496|      0|}
  497|       |
  498|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  499|       |    absl::string_view format, const substitute_internal::Arg& a0,
  500|      0|    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2) {
  501|      0|  std::string result;
  502|      0|  SubstituteAndAppend(&result, format, a0, a1, a2);
  503|      0|  return result;
  504|      0|}
  505|       |
  506|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  507|       |    absl::string_view format, const substitute_internal::Arg& a0,
  508|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  509|      0|    const substitute_internal::Arg& a3) {
  510|      0|  std::string result;
  511|      0|  SubstituteAndAppend(&result, format, a0, a1, a2, a3);
  512|      0|  return result;
  513|      0|}
  514|       |
  515|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  516|       |    absl::string_view format, const substitute_internal::Arg& a0,
  517|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  518|      0|    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4) {
  519|      0|  std::string result;
  520|      0|  SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4);
  521|      0|  return result;
  522|      0|}
  523|       |
  524|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  525|       |    absl::string_view format, const substitute_internal::Arg& a0,
  526|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  527|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  528|      0|    const substitute_internal::Arg& a5) {
  529|      0|  std::string result;
  530|      0|  SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5);
  531|      0|  return result;
  532|      0|}
  533|       |
  534|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  535|       |    absl::string_view format, const substitute_internal::Arg& a0,
  536|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  537|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  538|      0|    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6) {
  539|      0|  std::string result;
  540|      0|  SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5, a6);
  541|      0|  return result;
  542|      0|}
  543|       |
  544|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  545|       |    absl::string_view format, const substitute_internal::Arg& a0,
  546|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  547|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  548|       |    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
  549|      0|    const substitute_internal::Arg& a7) {
  550|      0|  std::string result;
  551|      0|  SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5, a6, a7);
  552|      0|  return result;
  553|      0|}
  554|       |
  555|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  556|       |    absl::string_view format, const substitute_internal::Arg& a0,
  557|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  558|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  559|       |    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
  560|      0|    const substitute_internal::Arg& a7, const substitute_internal::Arg& a8) {
  561|      0|  std::string result;
  562|      0|  SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5, a6, a7, a8);
  563|      0|  return result;
  564|      0|}
  565|       |
  566|       |ABSL_MUST_USE_RESULT inline std::string Substitute(
  567|       |    absl::string_view format, const substitute_internal::Arg& a0,
  568|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  569|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  570|       |    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
  571|       |    const substitute_internal::Arg& a7, const substitute_internal::Arg& a8,
  572|      0|    const substitute_internal::Arg& a9) {
  573|      0|  std::string result;
  574|      0|  SubstituteAndAppend(&result, format, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  575|      0|  return result;
  576|      0|}
  577|       |
  578|       |#if defined(ABSL_BAD_CALL_IF)
  579|       |// This body of functions catches cases where the number of placeholders
  580|       |// doesn't match the number of data arguments.
  581|       |std::string Substitute(const char* format)
  582|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 0,
  583|       |                     "There were no substitution arguments "
  584|       |                     "but this format std::string has a $[0-9] in it");
  585|       |
  586|       |std::string Substitute(const char* format, const substitute_internal::Arg& a0)
  587|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 1,
  588|       |                     "There was 1 substitution argument given, but "
  589|       |                     "this format std::string is either missing its $0, or "
  590|       |                     "contains one of $1-$9");
  591|       |
  592|       |std::string Substitute(const char* format, const substitute_internal::Arg& a0,
  593|       |                       const substitute_internal::Arg& a1)
  594|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 3,
  595|       |                     "There were 2 substitution arguments given, but "
  596|       |                     "this format std::string is either missing its $0/$1, or "
  597|       |                     "contains one of $2-$9");
  598|       |
  599|       |std::string Substitute(const char* format, const substitute_internal::Arg& a0,
  600|       |                       const substitute_internal::Arg& a1,
  601|       |                       const substitute_internal::Arg& a2)
  602|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 7,
  603|       |                     "There were 3 substitution arguments given, but "
  604|       |                     "this format std::string is either missing its $0/$1/$2, or "
  605|       |                     "contains one of $3-$9");
  606|       |
  607|       |std::string Substitute(const char* format, const substitute_internal::Arg& a0,
  608|       |                       const substitute_internal::Arg& a1,
  609|       |                       const substitute_internal::Arg& a2,
  610|       |                       const substitute_internal::Arg& a3)
  611|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 15,
  612|       |                     "There were 4 substitution arguments given, but "
  613|       |                     "this format std::string is either missing its $0-$3, or "
  614|       |                     "contains one of $4-$9");
  615|       |
  616|       |std::string Substitute(const char* format, const substitute_internal::Arg& a0,
  617|       |                       const substitute_internal::Arg& a1,
  618|       |                       const substitute_internal::Arg& a2,
  619|       |                       const substitute_internal::Arg& a3,
  620|       |                       const substitute_internal::Arg& a4)
  621|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 31,
  622|       |                     "There were 5 substitution arguments given, but "
  623|       |                     "this format std::string is either missing its $0-$4, or "
  624|       |                     "contains one of $5-$9");
  625|       |
  626|       |std::string Substitute(const char* format, const substitute_internal::Arg& a0,
  627|       |                       const substitute_internal::Arg& a1,
  628|       |                       const substitute_internal::Arg& a2,
  629|       |                       const substitute_internal::Arg& a3,
  630|       |                       const substitute_internal::Arg& a4,
  631|       |                       const substitute_internal::Arg& a5)
  632|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 63,
  633|       |                     "There were 6 substitution arguments given, but "
  634|       |                     "this format std::string is either missing its $0-$5, or "
  635|       |                     "contains one of $6-$9");
  636|       |
  637|       |std::string Substitute(const char* format, const substitute_internal::Arg& a0,
  638|       |                       const substitute_internal::Arg& a1,
  639|       |                       const substitute_internal::Arg& a2,
  640|       |                       const substitute_internal::Arg& a3,
  641|       |                       const substitute_internal::Arg& a4,
  642|       |                       const substitute_internal::Arg& a5,
  643|       |                       const substitute_internal::Arg& a6)
  644|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 127,
  645|       |                     "There were 7 substitution arguments given, but "
  646|       |                     "this format std::string is either missing its $0-$6, or "
  647|       |                     "contains one of $7-$9");
  648|       |
  649|       |std::string Substitute(const char* format, const substitute_internal::Arg& a0,
  650|       |                       const substitute_internal::Arg& a1,
  651|       |                       const substitute_internal::Arg& a2,
  652|       |                       const substitute_internal::Arg& a3,
  653|       |                       const substitute_internal::Arg& a4,
  654|       |                       const substitute_internal::Arg& a5,
  655|       |                       const substitute_internal::Arg& a6,
  656|       |                       const substitute_internal::Arg& a7)
  657|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 255,
  658|       |                     "There were 8 substitution arguments given, but "
  659|       |                     "this format std::string is either missing its $0-$7, or "
  660|       |                     "contains one of $8-$9");
  661|       |
  662|       |std::string Substitute(
  663|       |    const char* format, const substitute_internal::Arg& a0,
  664|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  665|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  666|       |    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
  667|       |    const substitute_internal::Arg& a7, const substitute_internal::Arg& a8)
  668|       |    ABSL_BAD_CALL_IF(
  669|       |        substitute_internal::PlaceholderBitmask(format) != 511,
  670|       |        "There were 9 substitution arguments given, but "
  671|       |        "this format std::string is either missing its $0-$8, or contains a $9");
  672|       |
  673|       |std::string Substitute(
  674|       |    const char* format, const substitute_internal::Arg& a0,
  675|       |    const substitute_internal::Arg& a1, const substitute_internal::Arg& a2,
  676|       |    const substitute_internal::Arg& a3, const substitute_internal::Arg& a4,
  677|       |    const substitute_internal::Arg& a5, const substitute_internal::Arg& a6,
  678|       |    const substitute_internal::Arg& a7, const substitute_internal::Arg& a8,
  679|       |    const substitute_internal::Arg& a9)
  680|       |    ABSL_BAD_CALL_IF(substitute_internal::PlaceholderBitmask(format) != 1023,
  681|       |                     "There were 10 substitution arguments given, but this "
  682|       |                     "format std::string doesn't contain all of $0 through $9");
  683|       |#endif  // ABSL_BAD_CALL_IF
  684|       |
  685|       |}  // inline namespace lts_2019_08_08
  686|       |}  // namespace absl
  687|       |
  688|       |#endif  // ABSL_STRINGS_SUBSTITUTE_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/civil_time.cc:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/time/civil_time.h"
   16|       |
   17|       |#include <cstdlib>
   18|       |#include <string>
   19|       |
   20|       |#include "absl/strings/str_cat.h"
   21|       |#include "absl/time/time.h"
   22|       |
   23|       |namespace absl {
   24|       |inline namespace lts_2019_08_08 {
   25|       |
   26|       |namespace {
   27|       |
   28|       |// Since a civil time has a larger year range than absl::Time (64-bit years vs
   29|       |// 64-bit seconds, respectively) we normalize years to roughly +/- 400 years
   30|       |// around the year 2400, which will produce an equivalent year in a range that
   31|       |// absl::Time can handle.
   32|      0|inline civil_year_t NormalizeYear(civil_year_t year) {
   33|      0|  return 2400 + year % 400;
   34|      0|}
   35|       |
   36|       |// Formats the given CivilSecond according to the given format.
   37|      0|std::string FormatYearAnd(string_view fmt, CivilSecond cs) {
   38|      0|  const CivilSecond ncs(NormalizeYear(cs.year()), cs.month(), cs.day(),
   39|      0|                        cs.hour(), cs.minute(), cs.second());
   40|      0|  const TimeZone utc = UTCTimeZone();
   41|      0|  // TODO(absl-team): Avoid conversion of fmt std::string.
   42|      0|  return StrCat(cs.year(),
   43|      0|                FormatTime(std::string(fmt), FromCivil(ncs, utc), utc));
   44|      0|}
   45|       |
   46|       |}  // namespace
   47|       |
   48|      0|std::string FormatCivilTime(CivilSecond c) {
   49|      0|  return FormatYearAnd("-%m-%dT%H:%M:%S", c);
   50|      0|}
   51|      0|std::string FormatCivilTime(CivilMinute c) {
   52|      0|  return FormatYearAnd("-%m-%dT%H:%M", c);
   53|      0|}
   54|      0|std::string FormatCivilTime(CivilHour c) {
   55|      0|  return FormatYearAnd("-%m-%dT%H", c);
   56|      0|}
   57|      0|std::string FormatCivilTime(CivilDay c) { return FormatYearAnd("-%m-%d", c); }
   58|      0|std::string FormatCivilTime(CivilMonth c) { return FormatYearAnd("-%m", c); }
   59|      0|std::string FormatCivilTime(CivilYear c) { return FormatYearAnd("", c); }
   60|       |
   61|       |namespace time_internal {
   62|       |
   63|      0|std::ostream& operator<<(std::ostream& os, CivilYear y) {
   64|      0|  return os << FormatCivilTime(y);
   65|      0|}
   66|      0|std::ostream& operator<<(std::ostream& os, CivilMonth m) {
   67|      0|  return os << FormatCivilTime(m);
   68|      0|}
   69|      0|std::ostream& operator<<(std::ostream& os, CivilDay d) {
   70|      0|  return os << FormatCivilTime(d);
   71|      0|}
   72|      0|std::ostream& operator<<(std::ostream& os, CivilHour h) {
   73|      0|  return os << FormatCivilTime(h);
   74|      0|}
   75|      0|std::ostream& operator<<(std::ostream& os, CivilMinute m) {
   76|      0|  return os << FormatCivilTime(m);
   77|      0|}
   78|      0|std::ostream& operator<<(std::ostream& os, CivilSecond s) {
   79|      0|  return os << FormatCivilTime(s);
   80|      0|}
   81|       |
   82|       |}  // namespace time_internal
   83|       |
   84|       |}  // inline namespace lts_2019_08_08
   85|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/civil_time.h:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// -----------------------------------------------------------------------------
   16|       |// File: civil_time.h
   17|       |// -----------------------------------------------------------------------------
   18|       |//
   19|       |// This header file defines abstractions for computing with "civil time".
   20|       |// The term "civil time" refers to the legally recognized human-scale time
   21|       |// that is represented by the six fields `YYYY-MM-DD hh:mm:ss`. A "date"
   22|       |// is perhaps the most common example of a civil time (represented here as
   23|       |// an `absl::CivilDay`).
   24|       |//
   25|       |// Modern-day civil time follows the Gregorian Calendar and is a
   26|       |// time-zone-independent concept: a civil time of "2015-06-01 12:00:00", for
   27|       |// example, is not tied to a time zone. Put another way, a civil time does not
   28|       |// map to a unique point in time; a civil time must be mapped to an absolute
   29|       |// time *through* a time zone.
   30|       |//
   31|       |// Because a civil time is what most people think of as "time," it is common to
   32|       |// map absolute times to civil times to present to users.
   33|       |//
   34|       |// Time zones define the relationship between absolute and civil times. Given an
   35|       |// absolute or civil time and a time zone, you can compute the other time:
   36|       |//
   37|       |//   Civil Time = F(Absolute Time, Time Zone)
   38|       |//   Absolute Time = G(Civil Time, Time Zone)
   39|       |//
   40|       |// The Abseil time library allows you to construct such civil times from
   41|       |// absolute times; consult time.h for such functionality.
   42|       |//
   43|       |// This library provides six classes for constructing civil-time objects, and
   44|       |// provides several helper functions for rounding, iterating, and performing
   45|       |// arithmetic on civil-time objects, while avoiding complications like
   46|       |// daylight-saving time (DST):
   47|       |//
   48|       |//   * `absl::CivilSecond`
   49|       |//   * `absl::CivilMinute`
   50|       |//   * `absl::CivilHour`
   51|       |//   * `absl::CivilDay`
   52|       |//   * `absl::CivilMonth`
   53|       |//   * `absl::CivilYear`
   54|       |//
   55|       |// Example:
   56|       |//
   57|       |//   // Construct a civil-time object for a specific day
   58|       |//   const absl::CivilDay cd(1969, 07, 20);
   59|       |//
   60|       |//   // Construct a civil-time object for a specific second
   61|       |//   const absl::CivilSecond cd(2018, 8, 1, 12, 0, 1);
   62|       |//
   63|       |// Note: In C++14 and later, this library is usable in a constexpr context.
   64|       |//
   65|       |// Example:
   66|       |//
   67|       |//   // Valid in C++14
   68|       |//   constexpr absl::CivilDay cd(1969, 07, 20);
   69|       |
   70|       |#ifndef ABSL_TIME_CIVIL_TIME_H_
   71|       |#define ABSL_TIME_CIVIL_TIME_H_
   72|       |
   73|       |#include <string>
   74|       |
   75|       |#include "absl/strings/string_view.h"
   76|       |#include "absl/time/internal/cctz/include/cctz/civil_time.h"
   77|       |
   78|       |namespace absl {
   79|       |inline namespace lts_2019_08_08 {
   80|       |
   81|       |namespace time_internal {
   82|       |struct second_tag : cctz::detail::second_tag {};
   83|       |struct minute_tag : second_tag, cctz::detail::minute_tag {};
   84|       |struct hour_tag : minute_tag, cctz::detail::hour_tag {};
   85|       |struct day_tag : hour_tag, cctz::detail::day_tag {};
   86|       |struct month_tag : day_tag, cctz::detail::month_tag {};
   87|       |struct year_tag : month_tag, cctz::detail::year_tag {};
   88|       |}  // namespace time_internal
   89|       |
   90|       |// -----------------------------------------------------------------------------
   91|       |// CivilSecond, CivilMinute, CivilHour, CivilDay, CivilMonth, CivilYear
   92|       |// -----------------------------------------------------------------------------
   93|       |//
   94|       |// Each of these civil-time types is a simple value type with the same
   95|       |// interface for construction and the same six accessors for each of the civil
   96|       |// time fields (year, month, day, hour, minute, and second, aka YMDHMS). These
   97|       |// classes differ only in their alignment, which is indicated by the type name
   98|       |// and specifies the field on which arithmetic operates.
   99|       |//
  100|       |// CONSTRUCTION
  101|       |//
  102|       |// Each of the civil-time types can be constructed in two ways: by directly
  103|       |// passing to the constructor up to six integers representing the YMDHMS fields,
  104|       |// or by copying the YMDHMS fields from a differently aligned civil-time type.
  105|       |// Omitted fields are assigned their minimum valid value. Hours, minutes, and
  106|       |// seconds will be set to 0, month and day will be set to 1. Since there is no
  107|       |// minimum year, the default is 1970.
  108|       |//
  109|       |// Examples:
  110|       |//
  111|       |//   absl::CivilDay default_value;               // 1970-01-01 00:00:00
  112|       |//
  113|       |//   absl::CivilDay a(2015, 2, 3);               // 2015-02-03 00:00:00
  114|       |//   absl::CivilDay b(2015, 2, 3, 4, 5, 6);      // 2015-02-03 00:00:00
  115|       |//   absl::CivilDay c(2015);                     // 2015-01-01 00:00:00
  116|       |//
  117|       |//   absl::CivilSecond ss(2015, 2, 3, 4, 5, 6);  // 2015-02-03 04:05:06
  118|       |//   absl::CivilMinute mm(ss);                   // 2015-02-03 04:05:00
  119|       |//   absl::CivilHour hh(mm);                     // 2015-02-03 04:00:00
  120|       |//   absl::CivilDay d(hh);                       // 2015-02-03 00:00:00
  121|       |//   absl::CivilMonth m(d);                      // 2015-02-01 00:00:00
  122|       |//   absl::CivilYear y(m);                       // 2015-01-01 00:00:00
  123|       |//
  124|       |//   m = absl::CivilMonth(y);                    // 2015-01-01 00:00:00
  125|       |//   d = absl::CivilDay(m);                      // 2015-01-01 00:00:00
  126|       |//   hh = absl::CivilHour(d);                    // 2015-01-01 00:00:00
  127|       |//   mm = absl::CivilMinute(hh);                 // 2015-01-01 00:00:00
  128|       |//   ss = absl::CivilSecond(mm);                 // 2015-01-01 00:00:00
  129|       |//
  130|       |// Each civil-time class is aligned to the civil-time field indicated in the
  131|       |// class's name after normalization. Alignment is performed by setting all the
  132|       |// inferior fields to their minimum valid value (as described above). The
  133|       |// following are examples of how each of the six types would align the fields
  134|       |// representing November 22, 2015 at 12:34:56 in the afternoon. (Note: the
  135|       |// string format used here is not important; it's just a shorthand way of
  136|       |// showing the six YMDHMS fields.)
  137|       |//
  138|       |//   absl::CivilSecond   : 2015-11-22 12:34:56
  139|       |//   absl::CivilMinute   : 2015-11-22 12:34:00
  140|       |//   absl::CivilHour     : 2015-11-22 12:00:00
  141|       |//   absl::CivilDay      : 2015-11-22 00:00:00
  142|       |//   absl::CivilMonth    : 2015-11-01 00:00:00
  143|       |//   absl::CivilYear     : 2015-01-01 00:00:00
  144|       |//
  145|       |// Each civil-time type performs arithmetic on the field to which it is
  146|       |// aligned. This means that adding 1 to an absl::CivilDay increments the day
  147|       |// field (normalizing as necessary), and subtracting 7 from an absl::CivilMonth
  148|       |// operates on the month field (normalizing as necessary). All arithmetic
  149|       |// produces a valid civil time. Difference requires two similarly aligned
  150|       |// civil-time objects and returns the scalar answer in units of the objects'
  151|       |// alignment. For example, the difference between two absl::CivilHour objects
  152|       |// will give an answer in units of civil hours.
  153|       |//
  154|       |// ALIGNMENT CONVERSION
  155|       |//
  156|       |// The alignment of a civil-time object cannot change, but the object may be
  157|       |// used to construct a new object with a different alignment. This is referred
  158|       |// to as "realigning". When realigning to a type with the same or more
  159|       |// precision (e.g., absl::CivilDay -> absl::CivilSecond), the conversion may be
  160|       |// performed implicitly since no information is lost. However, if information
  161|       |// could be discarded (e.g., CivilSecond -> CivilDay), the conversion must
  162|       |// be explicit at the call site.
  163|       |//
  164|       |// Examples:
  165|       |//
  166|       |//   void UseDay(absl::CivilDay day);
  167|       |//
  168|       |//   absl::CivilSecond cs;
  169|       |//   UseDay(cs);                  // Won't compile because data may be discarded
  170|       |//   UseDay(absl::CivilDay(cs));  // OK: explicit conversion
  171|       |//
  172|       |//   absl::CivilDay cd;
  173|       |//   UseDay(cd);                  // OK: no conversion needed
  174|       |//
  175|       |//   absl::CivilMonth cm;
  176|       |//   UseDay(cm);                  // OK: implicit conversion to absl::CivilDay
  177|       |//
  178|       |// NORMALIZATION
  179|       |//
  180|       |// Normalization takes invalid values and adjusts them to produce valid values.
  181|       |// Within the civil-time library, integer arguments passed to the Civil*
  182|       |// constructors may be out-of-range, in which case they are normalized by
  183|       |// carrying overflow into a field of courser granularity to produce valid
  184|       |// civil-time objects. This normalization enables natural arithmetic on
  185|       |// constructor arguments without worrying about the field's range.
  186|       |//
  187|       |// Examples:
  188|       |//
  189|       |//   // Out-of-range; normalized to 2016-11-01
  190|       |//   absl::CivilDay d(2016, 10, 32);
  191|       |//   // Out-of-range, negative: normalized to 2016-10-30T23
  192|       |//   absl::CivilHour h1(2016, 10, 31, -1);
  193|       |//   // Normalization is cumulative: normalized to 2016-10-30T23
  194|       |//   absl::CivilHour h2(2016, 10, 32, -25);
  195|       |//
  196|       |// Note: If normalization is undesired, you can signal an error by comparing
  197|       |// the constructor arguments to the normalized values returned by the YMDHMS
  198|       |// properties.
  199|       |//
  200|       |// COMPARISON
  201|       |//
  202|       |// Comparison between civil-time objects considers all six YMDHMS fields,
  203|       |// regardless of the type's alignment. Comparison between differently aligned
  204|       |// civil-time types is allowed.
  205|       |//
  206|       |// Examples:
  207|       |//
  208|       |//   absl::CivilDay feb_3(2015, 2, 3);  // 2015-02-03 00:00:00
  209|       |//   absl::CivilDay mar_4(2015, 3, 4);  // 2015-03-04 00:00:00
  210|       |//   // feb_3 < mar_4
  211|       |//   // absl::CivilYear(feb_3) == absl::CivilYear(mar_4)
  212|       |//
  213|       |//   absl::CivilSecond feb_3_noon(2015, 2, 3, 12, 0, 0);  // 2015-02-03 12:00:00
  214|       |//   // feb_3 < feb_3_noon
  215|       |//   // feb_3 == absl::CivilDay(feb_3_noon)
  216|       |//
  217|       |//   // Iterates all the days of February 2015.
  218|       |//   for (absl::CivilDay d(2015, 2, 1); d < absl::CivilMonth(2015, 3); ++d) {
  219|       |//     // ...
  220|       |//   }
  221|       |//
  222|       |// ARITHMETIC
  223|       |//
  224|       |// Civil-time types support natural arithmetic operators such as addition,
  225|       |// subtraction, and difference. Arithmetic operates on the civil-time field
  226|       |// indicated in the type's name. Difference operators require arguments with
  227|       |// the same alignment and return the answer in units of the alignment.
  228|       |//
  229|       |// Example:
  230|       |//
  231|       |//   absl::CivilDay a(2015, 2, 3);
  232|       |//   ++a;                              // 2015-02-04 00:00:00
  233|       |//   --a;                              // 2015-02-03 00:00:00
  234|       |//   absl::CivilDay b = a + 1;         // 2015-02-04 00:00:00
  235|       |//   absl::CivilDay c = 1 + b;         // 2015-02-05 00:00:00
  236|       |//   int n = c - a;                    // n = 2 (civil days)
  237|       |//   int m = c - absl::CivilMonth(c);  // Won't compile: different types.
  238|       |//
  239|       |// ACCESSORS
  240|       |//
  241|       |// Each civil-time type has accessors for all six of the civil-time fields:
  242|       |// year, month, day, hour, minute, and second.
  243|       |//
  244|       |// civil_year_t year()
  245|       |// int          month()
  246|       |// int          day()
  247|       |// int          hour()
  248|       |// int          minute()
  249|       |// int          second()
  250|       |//
  251|       |// Recall that fields inferior to the type's aligment will be set to their
  252|       |// minimum valid value.
  253|       |//
  254|       |// Example:
  255|       |//
  256|       |//   absl::CivilDay d(2015, 6, 28);
  257|       |//   // d.year() == 2015
  258|       |//   // d.month() == 6
  259|       |//   // d.day() == 28
  260|       |//   // d.hour() == 0
  261|       |//   // d.minute() == 0
  262|       |//   // d.second() == 0
  263|       |//
  264|       |// CASE STUDY: Adding a month to January 31.
  265|       |//
  266|       |// One of the classic questions that arises when considering a civil time
  267|       |// library (or a date library or a date/time library) is this:
  268|       |//   "What is the result of adding a month to January 31?"
  269|       |// This is an interesting question because it is unclear what is meant by a
  270|       |// "month", and several different answers are possible, depending on context:
  271|       |//
  272|       |//   1. March 3 (or 2 if a leap year), if "add a month" means to add a month to
  273|       |//      the current month, and adjust the date to overflow the extra days into
  274|       |//      March. In this case the result of "February 31" would be normalized as
  275|       |//      within the civil-time library.
  276|       |//   2. February 28 (or 29 if a leap year), if "add a month" means to add a
  277|       |//      month, and adjust the date while holding the resulting month constant.
  278|       |//      In this case, the result of "February 31" would be truncated to the last
  279|       |//      day in February.
  280|       |//   3. An error. The caller may get some error, an exception, an invalid date
  281|       |//      object, or perhaps return `false`. This may make sense because there is
  282|       |//      no single unambiguously correct answer to the question.
  283|       |//
  284|       |// Practically speaking, any answer that is not what the programmer intended
  285|       |// is the wrong answer.
  286|       |//
  287|       |// The Abseil time library avoids this problem by making it impossible to
  288|       |// ask ambiguous questions. All civil-time objects are aligned to a particular
  289|       |// civil-field boundary (such as aligned to a year, month, day, hour, minute,
  290|       |// or second), and arithmetic operates on the field to which the object is
  291|       |// aligned. This means that in order to "add a month" the object must first be
  292|       |// aligned to a month boundary, which is equivalent to the first day of that
  293|       |// month.
  294|       |//
  295|       |// Of course, there are ways to compute an answer the question at hand using
  296|       |// this Abseil time library, but they require the programmer to be explicit
  297|       |// about the answer they expect. To illustrate, let's see how to compute all
  298|       |// three of the above possible answers to the question of "Jan 31 plus 1
  299|       |// month":
  300|       |//
  301|       |// Example:
  302|       |//
  303|       |//   const absl::CivilDay d(2015, 1, 31);
  304|       |//
  305|       |//   // Answer 1:
  306|       |//   // Add 1 to the month field in the constructor, and rely on normalization.
  307|       |//   const auto normalized = absl::CivilDay(d.year(), d.month() + 1, d.day());
  308|       |//   // normalized == 2015-03-03 (aka Feb 31)
  309|       |//
  310|       |//   // Answer 2:
  311|       |//   // Add 1 to month field, capping to the end of next month.
  312|       |//   const auto next_month = absl::CivilMonth(d) + 1;
  313|       |//   const auto last_day_of_next_month = absl::CivilDay(next_month + 1) - 1;
  314|       |//   const auto capped = std::min(normalized, last_day_of_next_month);
  315|       |//   // capped == 2015-02-28
  316|       |//
  317|       |//   // Answer 3:
  318|       |//   // Signal an error if the normalized answer is not in next month.
  319|       |//   if (absl::CivilMonth(normalized) != next_month) {
  320|       |//     // error, month overflow
  321|       |//   }
  322|       |//
  323|       |using CivilSecond =
  324|       |    time_internal::cctz::detail::civil_time<time_internal::second_tag>;
  325|       |using CivilMinute =
  326|       |    time_internal::cctz::detail::civil_time<time_internal::minute_tag>;
  327|       |using CivilHour =
  328|       |    time_internal::cctz::detail::civil_time<time_internal::hour_tag>;
  329|       |using CivilDay =
  330|       |    time_internal::cctz::detail::civil_time<time_internal::day_tag>;
  331|       |using CivilMonth =
  332|       |    time_internal::cctz::detail::civil_time<time_internal::month_tag>;
  333|       |using CivilYear =
  334|       |    time_internal::cctz::detail::civil_time<time_internal::year_tag>;
  335|       |
  336|       |// civil_year_t
  337|       |//
  338|       |// Type alias of a civil-time year value. This type is guaranteed to (at least)
  339|       |// support any year value supported by `time_t`.
  340|       |//
  341|       |// Example:
  342|       |//
  343|       |//   absl::CivilSecond cs = ...;
  344|       |//   absl::civil_year_t y = cs.year();
  345|       |//   cs = absl::CivilSecond(y, 1, 1, 0, 0, 0);  // CivilSecond(CivilYear(cs))
  346|       |//
  347|       |using civil_year_t = time_internal::cctz::year_t;
  348|       |
  349|       |// civil_diff_t
  350|       |//
  351|       |// Type alias of the difference between two civil-time values.
  352|       |// This type is used to indicate arguments that are not
  353|       |// normalized (such as parameters to the civil-time constructors), the results
  354|       |// of civil-time subtraction, or the operand to civil-time addition.
  355|       |//
  356|       |// Example:
  357|       |//
  358|       |//   absl::civil_diff_t n_sec = cs1 - cs2;             // cs1 == cs2 + n_sec;
  359|       |//
  360|       |using civil_diff_t = time_internal::cctz::diff_t;
  361|       |
  362|       |// Weekday::monday, Weekday::tuesday, Weekday::wednesday, Weekday::thursday,
  363|       |// Weekday::friday, Weekday::saturday, Weekday::sunday
  364|       |//
  365|       |// The Weekday enum class represents the civil-time concept of a "weekday" with
  366|       |// members for all days of the week.
  367|       |//
  368|       |//   absl::Weekday wd = absl::Weekday::thursday;
  369|       |//
  370|       |using Weekday = time_internal::cctz::weekday;
  371|       |
  372|       |// GetWeekday()
  373|       |//
  374|       |// Returns the absl::Weekday for the given (realigned) civil-time value.
  375|       |//
  376|       |// Example:
  377|       |//
  378|       |//   absl::CivilDay a(2015, 8, 13);
  379|       |//   absl::Weekday wd = absl::GetWeekday(a);  // wd == absl::Weekday::thursday
  380|       |//
  381|      0|inline Weekday GetWeekday(CivilSecond cs) {
  382|      0|  return time_internal::cctz::get_weekday(cs);
  383|      0|}
  384|       |
  385|       |// NextWeekday()
  386|       |// PrevWeekday()
  387|       |//
  388|       |// Returns the absl::CivilDay that strictly follows or precedes a given
  389|       |// absl::CivilDay, and that falls on the given absl::Weekday.
  390|       |//
  391|       |// Example, given the following month:
  392|       |//
  393|       |//       August 2015
  394|       |//   Su Mo Tu We Th Fr Sa
  395|       |//                      1
  396|       |//    2  3  4  5  6  7  8
  397|       |//    9 10 11 12 13 14 15
  398|       |//   16 17 18 19 20 21 22
  399|       |//   23 24 25 26 27 28 29
  400|       |//   30 31
  401|       |//
  402|       |//   absl::CivilDay a(2015, 8, 13);
  403|       |//   // absl::GetWeekday(a) == absl::Weekday::thursday
  404|       |//   absl::CivilDay b = absl::NextWeekday(a, absl::Weekday::thursday);
  405|       |//   // b = 2015-08-20
  406|       |//   absl::CivilDay c = absl::PrevWeekday(a, absl::Weekday::thursday);
  407|       |//   // c = 2015-08-06
  408|       |//
  409|       |//   absl::CivilDay d = ...
  410|       |//   // Gets the following Thursday if d is not already Thursday
  411|       |//   absl::CivilDay thurs1 = absl::NextWeekday(d - 1, absl::Weekday::thursday);
  412|       |//   // Gets the previous Thursday if d is not already Thursday
  413|       |//   absl::CivilDay thurs2 = absl::PrevWeekday(d + 1, absl::Weekday::thursday);
  414|       |//
  415|      0|inline CivilDay NextWeekday(CivilDay cd, Weekday wd) {
  416|      0|  return CivilDay(time_internal::cctz::next_weekday(cd, wd));
  417|      0|}
  418|      0|inline CivilDay PrevWeekday(CivilDay cd, Weekday wd) {
  419|      0|  return CivilDay(time_internal::cctz::prev_weekday(cd, wd));
  420|      0|}
  421|       |
  422|       |// GetYearDay()
  423|       |//
  424|       |// Returns the day-of-year for the given (realigned) civil-time value.
  425|       |//
  426|       |// Example:
  427|       |//
  428|       |//   absl::CivilDay a(2015, 1, 1);
  429|       |//   int yd_jan_1 = absl::GetYearDay(a);   // yd_jan_1 = 1
  430|       |//   absl::CivilDay b(2015, 12, 31);
  431|       |//   int yd_dec_31 = absl::GetYearDay(b);  // yd_dec_31 = 365
  432|       |//
  433|      0|inline int GetYearDay(CivilSecond cs) {
  434|      0|  return time_internal::cctz::get_yearday(cs);
  435|      0|}
  436|       |
  437|       |// FormatCivilTime()
  438|       |//
  439|       |// Formats the given civil-time value into a string value of the following
  440|       |// format:
  441|       |//
  442|       |//  Type        | Format
  443|       |//  ---------------------------------
  444|       |//  CivilSecond | YYYY-MM-DDTHH:MM:SS
  445|       |//  CivilMinute | YYYY-MM-DDTHH:MM
  446|       |//  CivilHour   | YYYY-MM-DDTHH
  447|       |//  CivilDay    | YYYY-MM-DD
  448|       |//  CivilMonth  | YYYY-MM
  449|       |//  CivilYear   | YYYY
  450|       |//
  451|       |// Example:
  452|       |//
  453|       |//   absl::CivilDay d = absl::CivilDay(1969, 7, 20);
  454|       |//   std::string day_string = absl::FormatCivilTime(d);  // "1969-07-20"
  455|       |//
  456|       |std::string FormatCivilTime(CivilSecond c);
  457|       |std::string FormatCivilTime(CivilMinute c);
  458|       |std::string FormatCivilTime(CivilHour c);
  459|       |std::string FormatCivilTime(CivilDay c);
  460|       |std::string FormatCivilTime(CivilMonth c);
  461|       |std::string FormatCivilTime(CivilYear c);
  462|       |
  463|       |namespace time_internal {  // For functions found via ADL on civil-time tags.
  464|       |
  465|       |// Streaming Operators
  466|       |//
  467|       |// Each civil-time type may be sent to an output stream using operator<<().
  468|       |// The result matches the string produced by `FormatCivilTime()`.
  469|       |//
  470|       |// Example:
  471|       |//
  472|       |//   absl::CivilDay d = absl::CivilDay("1969-07-20");
  473|       |//   std::cout << "Date is: " << d << "\n";
  474|       |//
  475|       |std::ostream& operator<<(std::ostream& os, CivilYear y);
  476|       |std::ostream& operator<<(std::ostream& os, CivilMonth m);
  477|       |std::ostream& operator<<(std::ostream& os, CivilDay d);
  478|       |std::ostream& operator<<(std::ostream& os, CivilHour h);
  479|       |std::ostream& operator<<(std::ostream& os, CivilMinute m);
  480|       |std::ostream& operator<<(std::ostream& os, CivilSecond s);
  481|       |
  482|       |}  // namespace time_internal
  483|       |
  484|       |}  // inline namespace lts_2019_08_08
  485|       |}  // namespace absl
  486|       |
  487|       |#endif  // ABSL_TIME_CIVIL_TIME_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/clock.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/time/clock.h"
   16|       |
   17|       |#include "absl/base/attributes.h"
   18|       |
   19|       |#ifdef _WIN32
   20|       |#include <windows.h>
   21|       |#endif
   22|       |
   23|       |#include <algorithm>
   24|       |#include <atomic>
   25|       |#include <cerrno>
   26|       |#include <cstdint>
   27|       |#include <ctime>
   28|       |#include <limits>
   29|       |
   30|       |#include "absl/base/internal/spinlock.h"
   31|       |#include "absl/base/internal/unscaledcycleclock.h"
   32|       |#include "absl/base/macros.h"
   33|       |#include "absl/base/port.h"
   34|       |#include "absl/base/thread_annotations.h"
   35|       |
   36|       |namespace absl {
   37|       |inline namespace lts_2019_08_08 {
   38|      0|Time Now() {
   39|      0|  // TODO(bww): Get a timespec instead so we don't have to divide.
   40|      0|  int64_t n = absl::GetCurrentTimeNanos();
   41|      0|  if (n >= 0) {
   42|      0|    return time_internal::FromUnixDuration(
   43|      0|        time_internal::MakeDuration(n / 1000000000, n % 1000000000 * 4));
   44|      0|  }
   45|      0|  return time_internal::FromUnixDuration(absl::Nanoseconds(n));
   46|      0|}
   47|       |}  // inline namespace lts_2019_08_08
   48|       |}  // namespace absl
   49|       |
   50|       |// Decide if we should use the fast GetCurrentTimeNanos() algorithm
   51|       |// based on the cyclecounter, otherwise just get the time directly
   52|       |// from the OS on every call. This can be chosen at compile-time via
   53|       |// -DABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS=[0|1]
   54|       |#ifndef ABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS
   55|       |#if ABSL_USE_UNSCALED_CYCLECLOCK
   56|       |#define ABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS 1
   57|       |#else
   58|       |#define ABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS 0
   59|       |#endif
   60|       |#endif
   61|       |
   62|       |#if defined(__APPLE__) || defined(_WIN32)
   63|       |#include "absl/time/internal/get_current_time_chrono.inc"
   64|       |#else
   65|       |#include "absl/time/internal/get_current_time_posix.inc"
   66|       |#endif
   67|       |
   68|       |// Allows override by test.
   69|       |#ifndef GET_CURRENT_TIME_NANOS_FROM_SYSTEM
   70|       |#define GET_CURRENT_TIME_NANOS_FROM_SYSTEM() \
   71|      0|  ::absl::time_internal::GetCurrentTimeNanosFromSystem()
   72|       |#endif
   73|       |
   74|       |#if !ABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS
   75|       |namespace absl {
   76|       |inline namespace lts_2019_08_08 {
   77|      0|int64_t GetCurrentTimeNanos() {
   78|      0|  return GET_CURRENT_TIME_NANOS_FROM_SYSTEM();
   79|      0|}
   80|       |}  // inline namespace lts_2019_08_08
   81|       |}  // namespace absl
   82|       |#else  // Use the cyclecounter-based implementation below.
   83|       |
   84|       |// Allows override by test.
   85|       |#ifndef GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW
   86|       |#define GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW() \
   87|       |  ::absl::time_internal::UnscaledCycleClockWrapperForGetCurrentTime::Now()
   88|       |#endif
   89|       |
   90|       |// The following counters are used only by the test code.
   91|       |static int64_t stats_initializations;
   92|       |static int64_t stats_reinitializations;
   93|       |static int64_t stats_calibrations;
   94|       |static int64_t stats_slow_paths;
   95|       |static int64_t stats_fast_slow_paths;
   96|       |
   97|       |namespace absl {
   98|       |inline namespace lts_2019_08_08 {
   99|       |namespace time_internal {
  100|       |// This is a friend wrapper around UnscaledCycleClock::Now()
  101|       |// (needed to access UnscaledCycleClock).
  102|       |class UnscaledCycleClockWrapperForGetCurrentTime {
  103|       | public:
  104|       |  static int64_t Now() { return base_internal::UnscaledCycleClock::Now(); }
  105|       |};
  106|       |}  // namespace time_internal
  107|       |
  108|       |// uint64_t is used in this module to provide an extra bit in multiplications
  109|       |
  110|       |// Return the time in ns as told by the kernel interface.  Place in *cycleclock
  111|       |// the value of the cycleclock at about the time of the syscall.
  112|       |// This call represents the time base that this module synchronizes to.
  113|       |// Ensures that *cycleclock does not step back by up to (1 << 16) from
  114|       |// last_cycleclock, to discard small backward counter steps.  (Larger steps are
  115|       |// assumed to be complete resyncs, which shouldn't happen.  If they do, a full
  116|       |// reinitialization of the outer algorithm should occur.)
  117|       |static int64_t GetCurrentTimeNanosFromKernel(uint64_t last_cycleclock,
  118|       |                                             uint64_t *cycleclock) {
  119|       |  // We try to read clock values at about the same time as the kernel clock.
  120|       |  // This value gets adjusted up or down as estimate of how long that should
  121|       |  // take, so we can reject attempts that take unusually long.
  122|       |  static std::atomic<uint64_t> approx_syscall_time_in_cycles{10 * 1000};
  123|       |
  124|       |  uint64_t local_approx_syscall_time_in_cycles =  // local copy
  125|       |      approx_syscall_time_in_cycles.load(std::memory_order_relaxed);
  126|       |
  127|       |  int64_t current_time_nanos_from_system;
  128|       |  uint64_t before_cycles;
  129|       |  uint64_t after_cycles;
  130|       |  uint64_t elapsed_cycles;
  131|       |  int loops = 0;
  132|       |  do {
  133|       |    before_cycles = GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW();
  134|       |    current_time_nanos_from_system = GET_CURRENT_TIME_NANOS_FROM_SYSTEM();
  135|       |    after_cycles = GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW();
  136|       |    // elapsed_cycles is unsigned, so is large on overflow
  137|       |    elapsed_cycles = after_cycles - before_cycles;
  138|       |    if (elapsed_cycles >= local_approx_syscall_time_in_cycles &&
  139|       |        ++loops == 20) {  // clock changed frequencies?  Back off.
  140|       |      loops = 0;
  141|       |      if (local_approx_syscall_time_in_cycles < 1000 * 1000) {
  142|       |        local_approx_syscall_time_in_cycles =
  143|       |            (local_approx_syscall_time_in_cycles + 1) << 1;
  144|       |      }
  145|       |      approx_syscall_time_in_cycles.store(
  146|       |          local_approx_syscall_time_in_cycles,
  147|       |          std::memory_order_relaxed);
  148|       |    }
  149|       |  } while (elapsed_cycles >= local_approx_syscall_time_in_cycles ||
  150|       |           last_cycleclock - after_cycles < (static_cast<uint64_t>(1) << 16));
  151|       |
  152|       |  // Number of times in a row we've seen a kernel time call take substantially
  153|       |  // less than approx_syscall_time_in_cycles.
  154|       |  static std::atomic<uint32_t> seen_smaller{ 0 };
  155|       |
  156|       |  // Adjust approx_syscall_time_in_cycles to be within a factor of 2
  157|       |  // of the typical time to execute one iteration of the loop above.
  158|       |  if ((local_approx_syscall_time_in_cycles >> 1) < elapsed_cycles) {
  159|       |    // measured time is no smaller than half current approximation
  160|       |    seen_smaller.store(0, std::memory_order_relaxed);
  161|       |  } else if (seen_smaller.fetch_add(1, std::memory_order_relaxed) >= 3) {
  162|       |    // smaller delays several times in a row; reduce approximation by 12.5%
  163|       |    const uint64_t new_approximation =
  164|       |        local_approx_syscall_time_in_cycles -
  165|       |        (local_approx_syscall_time_in_cycles >> 3);
  166|       |    approx_syscall_time_in_cycles.store(new_approximation,
  167|       |                                        std::memory_order_relaxed);
  168|       |    seen_smaller.store(0, std::memory_order_relaxed);
  169|       |  }
  170|       |
  171|       |  *cycleclock = after_cycles;
  172|       |  return current_time_nanos_from_system;
  173|       |}
  174|       |
  175|       |
  176|       |// ---------------------------------------------------------------------
  177|       |// An implementation of reader-write locks that use no atomic ops in the read
  178|       |// case.  This is a generalization of Lamport's method for reading a multiword
  179|       |// clock.  Increment a word on each write acquisition, using the low-order bit
  180|       |// as a spinlock; the word is the high word of the "clock".  Readers read the
  181|       |// high word, then all other data, then the high word again, and repeat the
  182|       |// read if the reads of the high words yields different answers, or an odd
  183|       |// value (either case suggests possible interference from a writer).
  184|       |// Here we use a spinlock to ensure only one writer at a time, rather than
  185|       |// spinning on the bottom bit of the word to benefit from SpinLock
  186|       |// spin-delay tuning.
  187|       |
  188|       |// Acquire seqlock (*seq) and return the value to be written to unlock.
  189|       |static inline uint64_t SeqAcquire(std::atomic<uint64_t> *seq) {
  190|       |  uint64_t x = seq->fetch_add(1, std::memory_order_relaxed);
  191|       |
  192|       |  // We put a release fence between update to *seq and writes to shared data.
  193|       |  // Thus all stores to shared data are effectively release operations and
  194|       |  // update to *seq above cannot be re-ordered past any of them.  Note that
  195|       |  // this barrier is not for the fetch_add above.  A release barrier for the
  196|       |  // fetch_add would be before it, not after.
  197|       |  std::atomic_thread_fence(std::memory_order_release);
  198|       |
  199|       |  return x + 2;   // original word plus 2
  200|       |}
  201|       |
  202|       |// Release seqlock (*seq) by writing x to it---a value previously returned by
  203|       |// SeqAcquire.
  204|       |static inline void SeqRelease(std::atomic<uint64_t> *seq, uint64_t x) {
  205|       |  // The unlock store to *seq must have release ordering so that all
  206|       |  // updates to shared data must finish before this store.
  207|       |  seq->store(x, std::memory_order_release);  // release lock for readers
  208|       |}
  209|       |
  210|       |// ---------------------------------------------------------------------
  211|       |
  212|       |// "nsscaled" is unit of time equal to a (2**kScale)th of a nanosecond.
  213|       |enum { kScale = 30 };
  214|       |
  215|       |// The minimum interval between samples of the time base.
  216|       |// We pick enough time to amortize the cost of the sample,
  217|       |// to get a reasonably accurate cycle counter rate reading,
  218|       |// and not so much that calculations will overflow 64-bits.
  219|       |static const uint64_t kMinNSBetweenSamples = 2000 << 20;
  220|       |
  221|       |// We require that kMinNSBetweenSamples shifted by kScale
  222|       |// have at least a bit left over for 64-bit calculations.
  223|       |static_assert(((kMinNSBetweenSamples << (kScale + 1)) >> (kScale + 1)) ==
  224|       |               kMinNSBetweenSamples,
  225|       |               "cannot represent kMaxBetweenSamplesNSScaled");
  226|       |
  227|       |// A reader-writer lock protecting the static locations below.
  228|       |// See SeqAcquire() and SeqRelease() above.
  229|       |static absl::base_internal::SpinLock lock(
  230|       |    absl::base_internal::kLinkerInitialized);
  231|       |static std::atomic<uint64_t> seq(0);
  232|       |
  233|       |// data from a sample of the kernel's time value
  234|       |struct TimeSampleAtomic {
  235|       |  std::atomic<uint64_t> raw_ns;              // raw kernel time
  236|       |  std::atomic<uint64_t> base_ns;             // our estimate of time
  237|       |  std::atomic<uint64_t> base_cycles;         // cycle counter reading
  238|       |  std::atomic<uint64_t> nsscaled_per_cycle;  // cycle period
  239|       |  // cycles before we'll sample again (a scaled reciprocal of the period,
  240|       |  // to avoid a division on the fast path).
  241|       |  std::atomic<uint64_t> min_cycles_per_sample;
  242|       |};
  243|       |// Same again, but with non-atomic types
  244|       |struct TimeSample {
  245|       |  uint64_t raw_ns;                 // raw kernel time
  246|       |  uint64_t base_ns;                // our estimate of time
  247|       |  uint64_t base_cycles;            // cycle counter reading
  248|       |  uint64_t nsscaled_per_cycle;     // cycle period
  249|       |  uint64_t min_cycles_per_sample;  // approx cycles before next sample
  250|       |};
  251|       |
  252|       |static struct TimeSampleAtomic last_sample;   // the last sample; under seq
  253|       |
  254|       |static int64_t GetCurrentTimeNanosSlowPath() ABSL_ATTRIBUTE_COLD;
  255|       |
  256|       |// Read the contents of *atomic into *sample.
  257|       |// Each field is read atomically, but to maintain atomicity between fields,
  258|       |// the access must be done under a lock.
  259|       |static void ReadTimeSampleAtomic(const struct TimeSampleAtomic *atomic,
  260|       |                                 struct TimeSample *sample) {
  261|       |  sample->base_ns = atomic->base_ns.load(std::memory_order_relaxed);
  262|       |  sample->base_cycles = atomic->base_cycles.load(std::memory_order_relaxed);
  263|       |  sample->nsscaled_per_cycle =
  264|       |      atomic->nsscaled_per_cycle.load(std::memory_order_relaxed);
  265|       |  sample->min_cycles_per_sample =
  266|       |      atomic->min_cycles_per_sample.load(std::memory_order_relaxed);
  267|       |  sample->raw_ns = atomic->raw_ns.load(std::memory_order_relaxed);
  268|       |}
  269|       |
  270|       |// Public routine.
  271|       |// Algorithm:  We wish to compute real time from a cycle counter.  In normal
  272|       |// operation, we construct a piecewise linear approximation to the kernel time
  273|       |// source, using the cycle counter value.  The start of each line segment is at
  274|       |// the same point as the end of the last, but may have a different slope (that
  275|       |// is, a different idea of the cycle counter frequency).  Every couple of
  276|       |// seconds, the kernel time source is sampled and compared with the current
  277|       |// approximation.  A new slope is chosen that, if followed for another couple
  278|       |// of seconds, will correct the error at the current position.  The information
  279|       |// for a sample is in the "last_sample" struct.  The linear approximation is
  280|       |//   estimated_time = last_sample.base_ns +
  281|       |//     last_sample.ns_per_cycle * (counter_reading - last_sample.base_cycles)
  282|       |// (ns_per_cycle is actually stored in different units and scaled, to avoid
  283|       |// overflow).  The base_ns of the next linear approximation is the
  284|       |// estimated_time using the last approximation; the base_cycles is the cycle
  285|       |// counter value at that time; the ns_per_cycle is the number of ns per cycle
  286|       |// measured since the last sample, but adjusted so that most of the difference
  287|       |// between the estimated_time and the kernel time will be corrected by the
  288|       |// estimated time to the next sample.  In normal operation, this algorithm
  289|       |// relies on:
  290|       |// - the cycle counter and kernel time rates not changing a lot in a few
  291|       |//   seconds.
  292|       |// - the client calling into the code often compared to a couple of seconds, so
  293|       |//   the time to the next correction can be estimated.
  294|       |// Any time ns_per_cycle is not known, a major error is detected, or the
  295|       |// assumption about frequent calls is violated, the implementation returns the
  296|       |// kernel time.  It records sufficient data that a linear approximation can
  297|       |// resume a little later.
  298|       |
  299|       |int64_t GetCurrentTimeNanos() {
  300|       |  // read the data from the "last_sample" struct (but don't need raw_ns yet)
  301|       |  // The reads of "seq" and test of the values emulate a reader lock.
  302|       |  uint64_t base_ns;
  303|       |  uint64_t base_cycles;
  304|       |  uint64_t nsscaled_per_cycle;
  305|       |  uint64_t min_cycles_per_sample;
  306|       |  uint64_t seq_read0;
  307|       |  uint64_t seq_read1;
  308|       |
  309|       |  // If we have enough information to interpolate, the value returned will be
  310|       |  // derived from this cycleclock-derived time estimate.  On some platforms
  311|       |  // (POWER) the function to retrieve this value has enough complexity to
  312|       |  // contribute to register pressure - reading it early before initializing
  313|       |  // the other pieces of the calculation minimizes spill/restore instructions,
  314|       |  // minimizing icache cost.
  315|       |  uint64_t now_cycles = GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW();
  316|       |
  317|       |  // Acquire pairs with the barrier in SeqRelease - if this load sees that
  318|       |  // store, the shared-data reads necessarily see that SeqRelease's updates
  319|       |  // to the same shared data.
  320|       |  seq_read0 = seq.load(std::memory_order_acquire);
  321|       |
  322|       |  base_ns = last_sample.base_ns.load(std::memory_order_relaxed);
  323|       |  base_cycles = last_sample.base_cycles.load(std::memory_order_relaxed);
  324|       |  nsscaled_per_cycle =
  325|       |      last_sample.nsscaled_per_cycle.load(std::memory_order_relaxed);
  326|       |  min_cycles_per_sample =
  327|       |      last_sample.min_cycles_per_sample.load(std::memory_order_relaxed);
  328|       |
  329|       |  // This acquire fence pairs with the release fence in SeqAcquire.  Since it
  330|       |  // is sequenced between reads of shared data and seq_read1, the reads of
  331|       |  // shared data are effectively acquiring.
  332|       |  std::atomic_thread_fence(std::memory_order_acquire);
  333|       |
  334|       |  // The shared-data reads are effectively acquire ordered, and the
  335|       |  // shared-data writes are effectively release ordered. Therefore if our
  336|       |  // shared-data reads see any of a particular update's shared-data writes,
  337|       |  // seq_read1 is guaranteed to see that update's SeqAcquire.
  338|       |  seq_read1 = seq.load(std::memory_order_relaxed);
  339|       |
  340|       |  // Fast path.  Return if min_cycles_per_sample has not yet elapsed since the
  341|       |  // last sample, and we read a consistent sample.  The fast path activates
  342|       |  // only when min_cycles_per_sample is non-zero, which happens when we get an
  343|       |  // estimate for the cycle time.  The predicate will fail if now_cycles <
  344|       |  // base_cycles, or if some other thread is in the slow path.
  345|       |  //
  346|       |  // Since we now read now_cycles before base_ns, it is possible for now_cycles
  347|       |  // to be less than base_cycles (if we were interrupted between those loads and
  348|       |  // last_sample was updated). This is harmless, because delta_cycles will wrap
  349|       |  // and report a time much much bigger than min_cycles_per_sample. In that case
  350|       |  // we will take the slow path.
  351|       |  uint64_t delta_cycles = now_cycles - base_cycles;
  352|       |  if (seq_read0 == seq_read1 && (seq_read0 & 1) == 0 &&
  353|       |      delta_cycles < min_cycles_per_sample) {
  354|       |    return base_ns + ((delta_cycles * nsscaled_per_cycle) >> kScale);
  355|       |  }
  356|       |  return GetCurrentTimeNanosSlowPath();
  357|       |}
  358|       |
  359|       |// Return (a << kScale)/b.
  360|       |// Zero is returned if b==0.   Scaling is performed internally to
  361|       |// preserve precision without overflow.
  362|       |static uint64_t SafeDivideAndScale(uint64_t a, uint64_t b) {
  363|       |  // Find maximum safe_shift so that
  364|       |  //  0 <= safe_shift <= kScale  and  (a << safe_shift) does not overflow.
  365|       |  int safe_shift = kScale;
  366|       |  while (((a << safe_shift) >> safe_shift) != a) {
  367|       |    safe_shift--;
  368|       |  }
  369|       |  uint64_t scaled_b = b >> (kScale - safe_shift);
  370|       |  uint64_t quotient = 0;
  371|       |  if (scaled_b != 0) {
  372|       |    quotient = (a << safe_shift) / scaled_b;
  373|       |  }
  374|       |  return quotient;
  375|       |}
  376|       |
  377|       |static uint64_t UpdateLastSample(
  378|       |    uint64_t now_cycles, uint64_t now_ns, uint64_t delta_cycles,
  379|       |    const struct TimeSample *sample) ABSL_ATTRIBUTE_COLD;
  380|       |
  381|       |// The slow path of GetCurrentTimeNanos().  This is taken while gathering
  382|       |// initial samples, when enough time has elapsed since the last sample, and if
  383|       |// any other thread is writing to last_sample.
  384|       |//
  385|       |// Manually mark this 'noinline' to minimize stack frame size of the fast
  386|       |// path.  Without this, sometimes a compiler may inline this big block of code
  387|       |// into the fast path.  That causes lots of register spills and reloads that
  388|       |// are unnecessary unless the slow path is taken.
  389|       |//
  390|       |// TODO(absl-team): Remove this attribute when our compiler is smart enough
  391|       |// to do the right thing.
  392|       |ABSL_ATTRIBUTE_NOINLINE
  393|       |static int64_t GetCurrentTimeNanosSlowPath() LOCKS_EXCLUDED(lock) {
  394|       |  // Serialize access to slow-path.  Fast-path readers are not blocked yet, and
  395|       |  // code below must not modify last_sample until the seqlock is acquired.
  396|       |  lock.Lock();
  397|       |
  398|       |  // Sample the kernel time base.  This is the definition of
  399|       |  // "now" if we take the slow path.
  400|       |  static uint64_t last_now_cycles;  // protected by lock
  401|       |  uint64_t now_cycles;
  402|       |  uint64_t now_ns = GetCurrentTimeNanosFromKernel(last_now_cycles, &now_cycles);
  403|       |  last_now_cycles = now_cycles;
  404|       |
  405|       |  uint64_t estimated_base_ns;
  406|       |
  407|       |  // ----------
  408|       |  // Read the "last_sample" values again; this time holding the write lock.
  409|       |  struct TimeSample sample;
  410|       |  ReadTimeSampleAtomic(&last_sample, &sample);
  411|       |
  412|       |  // ----------
  413|       |  // Try running the fast path again; another thread may have updated the
  414|       |  // sample between our run of the fast path and the sample we just read.
  415|       |  uint64_t delta_cycles = now_cycles - sample.base_cycles;
  416|       |  if (delta_cycles < sample.min_cycles_per_sample) {
  417|       |    // Another thread updated the sample.  This path does not take the seqlock
  418|       |    // so that blocked readers can make progress without blocking new readers.
  419|       |    estimated_base_ns = sample.base_ns +
  420|       |        ((delta_cycles * sample.nsscaled_per_cycle) >> kScale);
  421|       |    stats_fast_slow_paths++;
  422|       |  } else {
  423|       |    estimated_base_ns =
  424|       |        UpdateLastSample(now_cycles, now_ns, delta_cycles, &sample);
  425|       |  }
  426|       |
  427|       |  lock.Unlock();
  428|       |
  429|       |  return estimated_base_ns;
  430|       |}
  431|       |
  432|       |// Main part of the algorithm.  Locks out readers, updates the approximation
  433|       |// using the new sample from the kernel, and stores the result in last_sample
  434|       |// for readers.  Returns the new estimated time.
  435|       |static uint64_t UpdateLastSample(uint64_t now_cycles, uint64_t now_ns,
  436|       |                                 uint64_t delta_cycles,
  437|       |                                 const struct TimeSample *sample)
  438|       |    EXCLUSIVE_LOCKS_REQUIRED(lock) {
  439|       |  uint64_t estimated_base_ns = now_ns;
  440|       |  uint64_t lock_value = SeqAcquire(&seq);  // acquire seqlock to block readers
  441|       |
  442|       |  // The 5s in the next if-statement limits the time for which we will trust
  443|       |  // the cycle counter and our last sample to give a reasonable result.
  444|       |  // Errors in the rate of the source clock can be multiplied by the ratio
  445|       |  // between this limit and kMinNSBetweenSamples.
  446|       |  if (sample->raw_ns == 0 ||  // no recent sample, or clock went backwards
  447|       |      sample->raw_ns + static_cast<uint64_t>(5) * 1000 * 1000 * 1000 < now_ns ||
  448|       |      now_ns < sample->raw_ns || now_cycles < sample->base_cycles) {
  449|       |    // record this sample, and forget any previously known slope.
  450|       |    last_sample.raw_ns.store(now_ns, std::memory_order_relaxed);
  451|       |    last_sample.base_ns.store(estimated_base_ns, std::memory_order_relaxed);
  452|       |    last_sample.base_cycles.store(now_cycles, std::memory_order_relaxed);
  453|       |    last_sample.nsscaled_per_cycle.store(0, std::memory_order_relaxed);
  454|       |    last_sample.min_cycles_per_sample.store(0, std::memory_order_relaxed);
  455|       |    stats_initializations++;
  456|       |  } else if (sample->raw_ns + 500 * 1000 * 1000 < now_ns &&
  457|       |             sample->base_cycles + 100 < now_cycles) {
  458|       |    // Enough time has passed to compute the cycle time.
  459|       |    if (sample->nsscaled_per_cycle != 0) {  // Have a cycle time estimate.
  460|       |      // Compute time from counter reading, but avoiding overflow
  461|       |      // delta_cycles may be larger than on the fast path.
  462|       |      uint64_t estimated_scaled_ns;
  463|       |      int s = -1;
  464|       |      do {
  465|       |        s++;
  466|       |        estimated_scaled_ns = (delta_cycles >> s) * sample->nsscaled_per_cycle;
  467|       |      } while (estimated_scaled_ns / sample->nsscaled_per_cycle !=
  468|       |               (delta_cycles >> s));
  469|       |      estimated_base_ns = sample->base_ns +
  470|       |                          (estimated_scaled_ns >> (kScale - s));
  471|       |    }
  472|       |
  473|       |    // Compute the assumed cycle time kMinNSBetweenSamples ns into the future
  474|       |    // assuming the cycle counter rate stays the same as the last interval.
  475|       |    uint64_t ns = now_ns - sample->raw_ns;
  476|       |    uint64_t measured_nsscaled_per_cycle = SafeDivideAndScale(ns, delta_cycles);
  477|       |
  478|       |    uint64_t assumed_next_sample_delta_cycles =
  479|       |        SafeDivideAndScale(kMinNSBetweenSamples, measured_nsscaled_per_cycle);
  480|       |
  481|       |    int64_t diff_ns = now_ns - estimated_base_ns;  // estimate low by this much
  482|       |
  483|       |    // We want to set nsscaled_per_cycle so that our estimate of the ns time
  484|       |    // at the assumed cycle time is the assumed ns time.
  485|       |    // That is, we want to set nsscaled_per_cycle so:
  486|       |    //  kMinNSBetweenSamples + diff_ns  ==
  487|       |    //  (assumed_next_sample_delta_cycles * nsscaled_per_cycle) >> kScale
  488|       |    // But we wish to damp oscillations, so instead correct only most
  489|       |    // of our current error, by solving:
  490|       |    //  kMinNSBetweenSamples + diff_ns - (diff_ns / 16) ==
  491|       |    //  (assumed_next_sample_delta_cycles * nsscaled_per_cycle) >> kScale
  492|       |    ns = kMinNSBetweenSamples + diff_ns - (diff_ns / 16);
  493|       |    uint64_t new_nsscaled_per_cycle =
  494|       |        SafeDivideAndScale(ns, assumed_next_sample_delta_cycles);
  495|       |    if (new_nsscaled_per_cycle != 0 &&
  496|       |        diff_ns < 100 * 1000 * 1000 && -diff_ns < 100 * 1000 * 1000) {
  497|       |      // record the cycle time measurement
  498|       |      last_sample.nsscaled_per_cycle.store(
  499|       |          new_nsscaled_per_cycle, std::memory_order_relaxed);
  500|       |      uint64_t new_min_cycles_per_sample =
  501|       |          SafeDivideAndScale(kMinNSBetweenSamples, new_nsscaled_per_cycle);
  502|       |      last_sample.min_cycles_per_sample.store(
  503|       |          new_min_cycles_per_sample, std::memory_order_relaxed);
  504|       |      stats_calibrations++;
  505|       |    } else {  // something went wrong; forget the slope
  506|       |      last_sample.nsscaled_per_cycle.store(0, std::memory_order_relaxed);
  507|       |      last_sample.min_cycles_per_sample.store(0, std::memory_order_relaxed);
  508|       |      estimated_base_ns = now_ns;
  509|       |      stats_reinitializations++;
  510|       |    }
  511|       |    last_sample.raw_ns.store(now_ns, std::memory_order_relaxed);
  512|       |    last_sample.base_ns.store(estimated_base_ns, std::memory_order_relaxed);
  513|       |    last_sample.base_cycles.store(now_cycles, std::memory_order_relaxed);
  514|       |  } else {
  515|       |    // have a sample, but no slope; waiting for enough time for a calibration
  516|       |    stats_slow_paths++;
  517|       |  }
  518|       |
  519|       |  SeqRelease(&seq, lock_value);  // release the readers
  520|       |
  521|       |  return estimated_base_ns;
  522|       |}
  523|       |}  // inline namespace lts_2019_08_08
  524|       |}  // namespace absl
  525|       |#endif  // ABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS
  526|       |
  527|       |namespace absl {
  528|       |inline namespace lts_2019_08_08 {
  529|       |namespace {
  530|       |
  531|       |// Returns the maximum duration that SleepOnce() can sleep for.
  532|      0|constexpr absl::Duration MaxSleep() {
  533|       |#ifdef _WIN32
  534|       |  // Windows Sleep() takes unsigned long argument in milliseconds.
  535|       |  return absl::Milliseconds(
  536|       |      std::numeric_limits<unsigned long>::max());  // NOLINT(runtime/int)
  537|       |#else
  538|       |  return absl::Seconds(std::numeric_limits<time_t>::max());
  539|      0|#endif
  540|      0|}
  541|       |
  542|       |// Sleeps for the given duration.
  543|       |// REQUIRES: to_sleep <= MaxSleep().
  544|      0|void SleepOnce(absl::Duration to_sleep) {
  545|       |#ifdef _WIN32
  546|       |  Sleep(to_sleep / absl::Milliseconds(1));
  547|       |#else
  548|       |  struct timespec sleep_time = absl::ToTimespec(to_sleep);
  549|      0|  while (nanosleep(&sleep_time, &sleep_time) != 0 && errno == EINTR) {
  550|      0|    // Ignore signals and wait for the full interval to elapse.
  551|      0|  }
  552|      0|#endif
  553|      0|}
  554|       |
  555|       |}  // namespace
  556|       |}  // inline namespace lts_2019_08_08
  557|       |}  // namespace absl
  558|       |
  559|       |extern "C" {
  560|       |
  561|      0|ABSL_ATTRIBUTE_WEAK void AbslInternalSleepFor(absl::Duration duration) {
  562|      0|  while (duration > absl::ZeroDuration()) {
  563|      0|    absl::Duration to_sleep = std::min(duration, absl::MaxSleep());
  564|      0|    absl::SleepOnce(to_sleep);
  565|      0|    duration -= to_sleep;
  566|      0|  }
  567|      0|}
  568|       |
  569|       |}  // extern "C"

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/clock.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// -----------------------------------------------------------------------------
   16|       |// File: clock.h
   17|       |// -----------------------------------------------------------------------------
   18|       |//
   19|       |// This header file contains utility functions for working with the system-wide
   20|       |// realtime clock. For descriptions of the main time abstractions used within
   21|       |// this header file, consult the time.h header file.
   22|       |#ifndef ABSL_TIME_CLOCK_H_
   23|       |#define ABSL_TIME_CLOCK_H_
   24|       |
   25|       |#include "absl/base/macros.h"
   26|       |#include "absl/time/time.h"
   27|       |
   28|       |namespace absl {
   29|       |inline namespace lts_2019_08_08 {
   30|       |
   31|       |// Now()
   32|       |//
   33|       |// Returns the current time, expressed as an `absl::Time` absolute time value.
   34|       |absl::Time Now();
   35|       |
   36|       |// GetCurrentTimeNanos()
   37|       |//
   38|       |// Returns the current time, expressed as a count of nanoseconds since the Unix
   39|       |// Epoch (https://en.wikipedia.org/wiki/Unix_time). Prefer `absl::Now()` instead
   40|       |// for all but the most performance-sensitive cases (i.e. when you are calling
   41|       |// this function hundreds of thousands of times per second).
   42|       |int64_t GetCurrentTimeNanos();
   43|       |
   44|       |// SleepFor()
   45|       |//
   46|       |// Sleeps for the specified duration, expressed as an `absl::Duration`.
   47|       |//
   48|       |// Notes:
   49|       |// * Signal interruptions will not reduce the sleep duration.
   50|       |// * Returns immediately when passed a nonpositive duration.
   51|       |void SleepFor(absl::Duration duration);
   52|       |
   53|       |}  // inline namespace lts_2019_08_08
   54|       |}  // namespace absl
   55|       |
   56|       |// -----------------------------------------------------------------------------
   57|       |// Implementation Details
   58|       |// -----------------------------------------------------------------------------
   59|       |
   60|       |// In some build configurations we pass --detect-odr-violations to the
   61|       |// gold linker.  This causes it to flag weak symbol overrides as ODR
   62|       |// violations.  Because ODR only applies to C++ and not C,
   63|       |// --detect-odr-violations ignores symbols not mangled with C++ names.
   64|       |// By changing our extension points to be extern "C", we dodge this
   65|       |// check.
   66|       |extern "C" {
   67|       |void AbslInternalSleepFor(absl::Duration duration);
   68|       |}  // extern "C"
   69|       |
   70|      0|inline void absl::SleepFor(absl::Duration duration) {
   71|      0|  AbslInternalSleepFor(duration);
   72|      0|}
   73|       |
   74|       |#endif  // ABSL_TIME_CLOCK_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/duration.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |// The implementation of the absl::Duration class, which is declared in
   16|       |// //absl/time.h.  This class behaves like a numeric type; it has no public
   17|       |// methods and is used only through the operators defined here.
   18|       |//
   19|       |// Implementation notes:
   20|       |//
   21|       |// An absl::Duration is represented as
   22|       |//
   23|       |//   rep_hi_ : (int64_t)  Whole seconds
   24|       |//   rep_lo_ : (uint32_t) Fractions of a second
   25|       |//
   26|       |// The seconds value (rep_hi_) may be positive or negative as appropriate.
   27|       |// The fractional seconds (rep_lo_) is always a positive offset from rep_hi_.
   28|       |// The API for Duration guarantees at least nanosecond resolution, which
   29|       |// means rep_lo_ could have a max value of 1B - 1 if it stored nanoseconds.
   30|       |// However, to utilize more of the available 32 bits of space in rep_lo_,
   31|       |// we instead store quarters of a nanosecond in rep_lo_ resulting in a max
   32|       |// value of 4B - 1.  This allows us to correctly handle calculations like
   33|       |// 0.5 nanos + 0.5 nanos = 1 nano.  The following example shows the actual
   34|       |// Duration rep using quarters of a nanosecond.
   35|       |//
   36|       |//    2.5 sec = {rep_hi_=2,  rep_lo_=2000000000}  // lo = 4 * 500000000
   37|       |//   -2.5 sec = {rep_hi_=-3, rep_lo_=2000000000}
   38|       |//
   39|       |// Infinite durations are represented as Durations with the rep_lo_ field set
   40|       |// to all 1s.
   41|       |//
   42|       |//   +InfiniteDuration:
   43|       |//     rep_hi_ : kint64max
   44|       |//     rep_lo_ : ~0U
   45|       |//
   46|       |//   -InfiniteDuration:
   47|       |//     rep_hi_ : kint64min
   48|       |//     rep_lo_ : ~0U
   49|       |//
   50|       |// Arithmetic overflows/underflows to +/- infinity and saturates.
   51|       |
   52|       |#if defined(_MSC_VER)
   53|       |#include <winsock2.h>  // for timeval
   54|       |#endif
   55|       |
   56|       |#include <algorithm>
   57|       |#include <cassert>
   58|       |#include <cctype>
   59|       |#include <cerrno>
   60|       |#include <cmath>
   61|       |#include <cstdint>
   62|       |#include <cstdlib>
   63|       |#include <cstring>
   64|       |#include <ctime>
   65|       |#include <functional>
   66|       |#include <limits>
   67|       |#include <string>
   68|       |
   69|       |#include "absl/base/casts.h"
   70|       |#include "absl/numeric/int128.h"
   71|       |#include "absl/time/time.h"
   72|       |
   73|       |namespace absl {
   74|       |inline namespace lts_2019_08_08 {
   75|       |
   76|       |namespace {
   77|       |
   78|       |using time_internal::kTicksPerNanosecond;
   79|       |using time_internal::kTicksPerSecond;
   80|       |
   81|       |constexpr int64_t kint64max = std::numeric_limits<int64_t>::max();
   82|       |constexpr int64_t kint64min = std::numeric_limits<int64_t>::min();
   83|       |
   84|       |// Can't use std::isinfinite() because it doesn't exist on windows.
   85|      0|inline bool IsFinite(double d) {
   86|      0|  if (std::isnan(d)) return false;
   87|      0|  return d != std::numeric_limits<double>::infinity() &&
   88|      0|         d != -std::numeric_limits<double>::infinity();
   89|      0|}
   90|       |
   91|      0|inline bool IsValidDivisor(double d) {
   92|      0|  if (std::isnan(d)) return false;
   93|      0|  return d != 0.0;
   94|      0|}
   95|       |
   96|       |// Can't use std::round() because it is only available in C++11.
   97|       |// Note that we ignore the possibility of floating-point over/underflow.
   98|       |template <typename Double>
   99|      0|inline double Round(Double d) {
  100|      0|  return d < 0 ? std::ceil(d - 0.5) : std::floor(d + 0.5);
  101|      0|}
  102|       |
  103|       |// *sec may be positive or negative.  *ticks must be in the range
  104|       |// -kTicksPerSecond < *ticks < kTicksPerSecond.  If *ticks is negative it
  105|       |// will be normalized to a positive value by adjusting *sec accordingly.
  106|      0|inline void NormalizeTicks(int64_t* sec, int64_t* ticks) {
  107|      0|  if (*ticks < 0) {
  108|      0|    --*sec;
  109|      0|    *ticks += kTicksPerSecond;
  110|      0|  }
  111|      0|}
  112|       |
  113|       |// Makes a uint128 from the absolute value of the given scalar.
  114|      0|inline uint128 MakeU128(int64_t a) {
  115|      0|  uint128 u128 = 0;
  116|      0|  if (a < 0) {
  117|      0|    ++u128;
  118|      0|    ++a;  // Makes it safe to negate 'a'
  119|      0|    a = -a;
  120|      0|  }
  121|      0|  u128 += static_cast<uint64_t>(a);
  122|      0|  return u128;
  123|      0|}
  124|       |
  125|       |// Makes a uint128 count of ticks out of the absolute value of the Duration.
  126|      0|inline uint128 MakeU128Ticks(Duration d) {
  127|      0|  int64_t rep_hi = time_internal::GetRepHi(d);
  128|      0|  uint32_t rep_lo = time_internal::GetRepLo(d);
  129|      0|  if (rep_hi < 0) {
  130|      0|    ++rep_hi;
  131|      0|    rep_hi = -rep_hi;
  132|      0|    rep_lo = kTicksPerSecond - rep_lo;
  133|      0|  }
  134|      0|  uint128 u128 = static_cast<uint64_t>(rep_hi);
  135|      0|  u128 *= static_cast<uint64_t>(kTicksPerSecond);
  136|      0|  u128 += rep_lo;
  137|      0|  return u128;
  138|      0|}
  139|       |
  140|       |// Breaks a uint128 of ticks into a Duration.
  141|      0|inline Duration MakeDurationFromU128(uint128 u128, bool is_neg) {
  142|      0|  int64_t rep_hi;
  143|      0|  uint32_t rep_lo;
  144|      0|  const uint64_t h64 = Uint128High64(u128);
  145|      0|  const uint64_t l64 = Uint128Low64(u128);
  146|      0|  if (h64 == 0) {  // fastpath
  147|      0|    const uint64_t hi = l64 / kTicksPerSecond;
  148|      0|    rep_hi = static_cast<int64_t>(hi);
  149|      0|    rep_lo = static_cast<uint32_t>(l64 - hi * kTicksPerSecond);
  150|      0|  } else {
  151|      0|    // kMaxRepHi64 is the high 64 bits of (2^63 * kTicksPerSecond).
  152|      0|    // Any positive tick count whose high 64 bits are >= kMaxRepHi64
  153|      0|    // is not representable as a Duration.  A negative tick count can
  154|      0|    // have its high 64 bits == kMaxRepHi64 but only when the low 64
  155|      0|    // bits are all zero, otherwise it is not representable either.
  156|      0|    const uint64_t kMaxRepHi64 = 0x77359400UL;
  157|      0|    if (h64 >= kMaxRepHi64) {
  158|      0|      if (is_neg && h64 == kMaxRepHi64 && l64 == 0) {
  159|      0|        // Avoid trying to represent -kint64min below.
  160|      0|        return time_internal::MakeDuration(kint64min);
  161|      0|      }
  162|      0|      return is_neg ? -InfiniteDuration() : InfiniteDuration();
  163|      0|    }
  164|      0|    const uint128 kTicksPerSecond128 = static_cast<uint64_t>(kTicksPerSecond);
  165|      0|    const uint128 hi = u128 / kTicksPerSecond128;
  166|      0|    rep_hi = static_cast<int64_t>(Uint128Low64(hi));
  167|      0|    rep_lo =
  168|      0|        static_cast<uint32_t>(Uint128Low64(u128 - hi * kTicksPerSecond128));
  169|      0|  }
  170|      0|  if (is_neg) {
  171|      0|    rep_hi = -rep_hi;
  172|      0|    if (rep_lo != 0) {
  173|      0|      --rep_hi;
  174|      0|      rep_lo = kTicksPerSecond - rep_lo;
  175|      0|    }
  176|      0|  }
  177|      0|  return time_internal::MakeDuration(rep_hi, rep_lo);
  178|      0|}
  179|       |
  180|       |// Convert between int64_t and uint64_t, preserving representation. This
  181|       |// allows us to do arithmetic in the unsigned domain, where overflow has
  182|       |// well-defined behavior. See operator+=() and operator-=().
  183|       |//
  184|       |// C99 7.20.1.1.1, as referenced by C++11 18.4.1.2, says, "The typedef
  185|       |// name intN_t designates a signed integer type with width N, no padding
  186|       |// bits, and a two's complement representation." So, we can convert to
  187|       |// and from the corresponding uint64_t value using a bit cast.
  188|      0|inline uint64_t EncodeTwosComp(int64_t v) {
  189|      0|  return absl::bit_cast<uint64_t>(v);
  190|      0|}
  191|      0|inline int64_t DecodeTwosComp(uint64_t v) { return absl::bit_cast<int64_t>(v); }
  192|       |
  193|       |// Note: The overflow detection in this function is done using greater/less *or
  194|       |// equal* because kint64max/min is too large to be represented exactly in a
  195|       |// double (which only has 53 bits of precision). In order to avoid assigning to
  196|       |// rep->hi a double value that is too large for an int64_t (and therefore is
  197|       |// undefined), we must consider computations that equal kint64max/min as a
  198|       |// double as overflow cases.
  199|      0|inline bool SafeAddRepHi(double a_hi, double b_hi, Duration* d) {
  200|      0|  double c = a_hi + b_hi;
  201|      0|  if (c >= kint64max) {
  202|      0|    *d = InfiniteDuration();
  203|      0|    return false;
  204|      0|  }
  205|      0|  if (c <= kint64min) {
  206|      0|    *d = -InfiniteDuration();
  207|      0|    return false;
  208|      0|  }
  209|      0|  *d = time_internal::MakeDuration(c, time_internal::GetRepLo(*d));
  210|      0|  return true;
  211|      0|}
  212|       |
  213|       |// A functor that's similar to std::multiplies<T>, except this returns the max
  214|       |// T value instead of overflowing. This is only defined for uint128.
  215|       |template <typename Ignored>
  216|       |struct SafeMultiply {
  217|      0|  uint128 operator()(uint128 a, uint128 b) const {
  218|      0|    // b hi is always zero because it originated as an int64_t.
  219|      0|    assert(Uint128High64(b) == 0);
  220|      0|    // Fastpath to avoid the expensive overflow check with division.
  221|      0|    if (Uint128High64(a) == 0) {
  222|      0|      return (((Uint128Low64(a) | Uint128Low64(b)) >> 32) == 0)
  223|      0|                 ? static_cast<uint128>(Uint128Low64(a) * Uint128Low64(b))
  224|      0|                 : a * b;
  225|      0|    }
  226|      0|    return b == 0 ? b : (a > kuint128max / b) ? kuint128max : a * b;
  227|      0|  }
  228|       |};
  229|       |
  230|       |// Scales (i.e., multiplies or divides, depending on the Operation template)
  231|       |// the Duration d by the int64_t r.
  232|       |template <template <typename> class Operation>
  233|      0|inline Duration ScaleFixed(Duration d, int64_t r) {
  234|      0|  const uint128 a = MakeU128Ticks(d);
  235|      0|  const uint128 b = MakeU128(r);
  236|      0|  const uint128 q = Operation<uint128>()(a, b);
  237|      0|  const bool is_neg = (time_internal::GetRepHi(d) < 0) != (r < 0);
  238|      0|  return MakeDurationFromU128(q, is_neg);
  239|      0|}
  ------------------
  | Unexecuted instantiation: duration.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_110ScaleFixedINS1_12SafeMultiplyEEENS0_8DurationES4_x
  ------------------
  | Unexecuted instantiation: duration.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_110ScaleFixedINSt3__17dividesEEENS0_8DurationES5_x
  ------------------
  240|       |
  241|       |// Scales (i.e., multiplies or divides, depending on the Operation template)
  242|       |// the Duration d by the double r.
  243|       |template <template <typename> class Operation>
  244|      0|inline Duration ScaleDouble(Duration d, double r) {
  245|      0|  Operation<double> op;
  246|      0|  double hi_doub = op(time_internal::GetRepHi(d), r);
  247|      0|  double lo_doub = op(time_internal::GetRepLo(d), r);
  248|      0|
  249|      0|  double hi_int = 0;
  250|      0|  double hi_frac = std::modf(hi_doub, &hi_int);
  251|      0|
  252|      0|  // Moves hi's fractional bits to lo.
  253|      0|  lo_doub /= kTicksPerSecond;
  254|      0|  lo_doub += hi_frac;
  255|      0|
  256|      0|  double lo_int = 0;
  257|      0|  double lo_frac = std::modf(lo_doub, &lo_int);
  258|      0|
  259|      0|  // Rolls lo into hi if necessary.
  260|      0|  int64_t lo64 = Round(lo_frac * kTicksPerSecond);
  261|      0|
  262|      0|  Duration ans;
  263|      0|  if (!SafeAddRepHi(hi_int, lo_int, &ans)) return ans;
  264|      0|  int64_t hi64 = time_internal::GetRepHi(ans);
  265|      0|  if (!SafeAddRepHi(hi64, lo64 / kTicksPerSecond, &ans)) return ans;
  266|      0|  hi64 = time_internal::GetRepHi(ans);
  267|      0|  lo64 %= kTicksPerSecond;
  268|      0|  NormalizeTicks(&hi64, &lo64);
  269|      0|  return time_internal::MakeDuration(hi64, lo64);
  270|      0|}
  ------------------
  | Unexecuted instantiation: duration.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_111ScaleDoubleINSt3__110multipliesEEENS0_8DurationES5_d
  ------------------
  | Unexecuted instantiation: duration.cc:_ZN4absl14lts_2019_08_0812_GLOBAL__N_111ScaleDoubleINSt3__17dividesEEENS0_8DurationES5_d
  ------------------
  271|       |
  272|       |// Tries to divide num by den as fast as possible by looking for common, easy
  273|       |// cases. If the division was done, the quotient is in *q and the remainder is
  274|       |// in *rem and true will be returned.
  275|       |inline bool IDivFastPath(const Duration num, const Duration den, int64_t* q,
  276|      0|                         Duration* rem) {
  277|      0|  // Bail if num or den is an infinity.
  278|      0|  if (time_internal::IsInfiniteDuration(num) ||
  279|      0|      time_internal::IsInfiniteDuration(den))
  280|      0|    return false;
  281|      0|
  282|      0|  int64_t num_hi = time_internal::GetRepHi(num);
  283|      0|  uint32_t num_lo = time_internal::GetRepLo(num);
  284|      0|  int64_t den_hi = time_internal::GetRepHi(den);
  285|      0|  uint32_t den_lo = time_internal::GetRepLo(den);
  286|      0|
  287|      0|  if (den_hi == 0 && den_lo == kTicksPerNanosecond) {
  288|      0|    // Dividing by 1ns
  289|      0|    if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 1000000000) {
  290|      0|      *q = num_hi * 1000000000 + num_lo / kTicksPerNanosecond;
  291|      0|      *rem = time_internal::MakeDuration(0, num_lo % den_lo);
  292|      0|      return true;
  293|      0|    }
  294|      0|  } else if (den_hi == 0 && den_lo == 100 * kTicksPerNanosecond) {
  295|      0|    // Dividing by 100ns (common when converting to Universal time)
  296|      0|    if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 10000000) {
  297|      0|      *q = num_hi * 10000000 + num_lo / (100 * kTicksPerNanosecond);
  298|      0|      *rem = time_internal::MakeDuration(0, num_lo % den_lo);
  299|      0|      return true;
  300|      0|    }
  301|      0|  } else if (den_hi == 0 && den_lo == 1000 * kTicksPerNanosecond) {
  302|      0|    // Dividing by 1us
  303|      0|    if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 1000000) {
  304|      0|      *q = num_hi * 1000000 + num_lo / (1000 * kTicksPerNanosecond);
  305|      0|      *rem = time_internal::MakeDuration(0, num_lo % den_lo);
  306|      0|      return true;
  307|      0|    }
  308|      0|  } else if (den_hi == 0 && den_lo == 1000000 * kTicksPerNanosecond) {
  309|      0|    // Dividing by 1ms
  310|      0|    if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 1000) {
  311|      0|      *q = num_hi * 1000 + num_lo / (1000000 * kTicksPerNanosecond);
  312|      0|      *rem = time_internal::MakeDuration(0, num_lo % den_lo);
  313|      0|      return true;
  314|      0|    }
  315|      0|  } else if (den_hi > 0 && den_lo == 0) {
  316|      0|    // Dividing by positive multiple of 1s
  317|      0|    if (num_hi >= 0) {
  318|      0|      if (den_hi == 1) {
  319|      0|        *q = num_hi;
  320|      0|        *rem = time_internal::MakeDuration(0, num_lo);
  321|      0|        return true;
  322|      0|      }
  323|      0|      *q = num_hi / den_hi;
  324|      0|      *rem = time_internal::MakeDuration(num_hi % den_hi, num_lo);
  325|      0|      return true;
  326|      0|    }
  327|      0|    if (num_lo != 0) {
  328|      0|      num_hi += 1;
  329|      0|    }
  330|      0|    int64_t quotient = num_hi / den_hi;
  331|      0|    int64_t rem_sec = num_hi % den_hi;
  332|      0|    if (rem_sec > 0) {
  333|      0|      rem_sec -= den_hi;
  334|      0|      quotient += 1;
  335|      0|    }
  336|      0|    if (num_lo != 0) {
  337|      0|      rem_sec -= 1;
  338|      0|    }
  339|      0|    *q = quotient;
  340|      0|    *rem = time_internal::MakeDuration(rem_sec, num_lo);
  341|      0|    return true;
  342|      0|  }
  343|      0|
  344|      0|  return false;
  345|      0|}
  346|       |
  347|       |}  // namespace
  348|       |
  349|       |namespace time_internal {
  350|       |
  351|       |// The 'satq' argument indicates whether the quotient should saturate at the
  352|       |// bounds of int64_t.  If it does saturate, the difference will spill over to
  353|       |// the remainder.  If it does not saturate, the remainder remain accurate,
  354|       |// but the returned quotient will over/underflow int64_t and should not be used.
  355|       |int64_t IDivDuration(bool satq, const Duration num, const Duration den,
  356|      0|                   Duration* rem) {
  357|      0|  int64_t q = 0;
  358|      0|  if (IDivFastPath(num, den, &q, rem)) {
  359|      0|    return q;
  360|      0|  }
  361|      0|
  362|      0|  const bool num_neg = num < ZeroDuration();
  363|      0|  const bool den_neg = den < ZeroDuration();
  364|      0|  const bool quotient_neg = num_neg != den_neg;
  365|      0|
  366|      0|  if (time_internal::IsInfiniteDuration(num) || den == ZeroDuration()) {
  367|      0|    *rem = num_neg ? -InfiniteDuration() : InfiniteDuration();
  368|      0|    return quotient_neg ? kint64min : kint64max;
  369|      0|  }
  370|      0|  if (time_internal::IsInfiniteDuration(den)) {
  371|      0|    *rem = num;
  372|      0|    return 0;
  373|      0|  }
  374|      0|
  375|      0|  const uint128 a = MakeU128Ticks(num);
  376|      0|  const uint128 b = MakeU128Ticks(den);
  377|      0|  uint128 quotient128 = a / b;
  378|      0|
  379|      0|  if (satq) {
  380|      0|    // Limits the quotient to the range of int64_t.
  381|      0|    if (quotient128 > uint128(static_cast<uint64_t>(kint64max))) {
  382|      0|      quotient128 = quotient_neg ? uint128(static_cast<uint64_t>(kint64min))
  383|      0|                                 : uint128(static_cast<uint64_t>(kint64max));
  384|      0|    }
  385|      0|  }
  386|      0|
  387|      0|  const uint128 remainder128 = a - quotient128 * b;
  388|      0|  *rem = MakeDurationFromU128(remainder128, num_neg);
  389|      0|
  390|      0|  if (!quotient_neg || quotient128 == 0) {
  391|      0|    return Uint128Low64(quotient128) & kint64max;
  392|      0|  }
  393|      0|  // The quotient needs to be negated, but we need to carefully handle
  394|      0|  // quotient128s with the top bit on.
  395|      0|  return -static_cast<int64_t>(Uint128Low64(quotient128 - 1) & kint64max) - 1;
  396|      0|}
  397|       |
  398|       |}  // namespace time_internal
  399|       |
  400|       |//
  401|       |// Additive operators.
  402|       |//
  403|       |
  404|      0|Duration& Duration::operator+=(Duration rhs) {
  405|      0|  if (time_internal::IsInfiniteDuration(*this)) return *this;
  406|      0|  if (time_internal::IsInfiniteDuration(rhs)) return *this = rhs;
  407|      0|  const int64_t orig_rep_hi = rep_hi_;
  408|      0|  rep_hi_ =
  409|      0|      DecodeTwosComp(EncodeTwosComp(rep_hi_) + EncodeTwosComp(rhs.rep_hi_));
  410|      0|  if (rep_lo_ >= kTicksPerSecond - rhs.rep_lo_) {
  411|      0|    rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_) + 1);
  412|      0|    rep_lo_ -= kTicksPerSecond;
  413|      0|  }
  414|      0|  rep_lo_ += rhs.rep_lo_;
  415|      0|  if (rhs.rep_hi_ < 0 ? rep_hi_ > orig_rep_hi : rep_hi_ < orig_rep_hi) {
  416|      0|    return *this = rhs.rep_hi_ < 0 ? -InfiniteDuration() : InfiniteDuration();
  417|      0|  }
  418|      0|  return *this;
  419|      0|}
  420|       |
  421|      0|Duration& Duration::operator-=(Duration rhs) {
  422|      0|  if (time_internal::IsInfiniteDuration(*this)) return *this;
  423|      0|  if (time_internal::IsInfiniteDuration(rhs)) {
  424|      0|    return *this = rhs.rep_hi_ >= 0 ? -InfiniteDuration() : InfiniteDuration();
  425|      0|  }
  426|      0|  const int64_t orig_rep_hi = rep_hi_;
  427|      0|  rep_hi_ =
  428|      0|      DecodeTwosComp(EncodeTwosComp(rep_hi_) - EncodeTwosComp(rhs.rep_hi_));
  429|      0|  if (rep_lo_ < rhs.rep_lo_) {
  430|      0|    rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_) - 1);
  431|      0|    rep_lo_ += kTicksPerSecond;
  432|      0|  }
  433|      0|  rep_lo_ -= rhs.rep_lo_;
  434|      0|  if (rhs.rep_hi_ < 0 ? rep_hi_ < orig_rep_hi : rep_hi_ > orig_rep_hi) {
  435|      0|    return *this = rhs.rep_hi_ >= 0 ? -InfiniteDuration() : InfiniteDuration();
  436|      0|  }
  437|      0|  return *this;
  438|      0|}
  439|       |
  440|       |//
  441|       |// Multiplicative operators.
  442|       |//
  443|       |
  444|      0|Duration& Duration::operator*=(int64_t r) {
  445|      0|  if (time_internal::IsInfiniteDuration(*this)) {
  446|      0|    const bool is_neg = (r < 0) != (rep_hi_ < 0);
  447|      0|    return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
  448|      0|  }
  449|      0|  return *this = ScaleFixed<SafeMultiply>(*this, r);
  450|      0|}
  451|       |
  452|      0|Duration& Duration::operator*=(double r) {
  453|      0|  if (time_internal::IsInfiniteDuration(*this) || !IsFinite(r)) {
  454|      0|    const bool is_neg = (std::signbit(r) != 0) != (rep_hi_ < 0);
  455|      0|    return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
  456|      0|  }
  457|      0|  return *this = ScaleDouble<std::multiplies>(*this, r);
  458|      0|}
  459|       |
  460|      0|Duration& Duration::operator/=(int64_t r) {
  461|      0|  if (time_internal::IsInfiniteDuration(*this) || r == 0) {
  462|      0|    const bool is_neg = (r < 0) != (rep_hi_ < 0);
  463|      0|    return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
  464|      0|  }
  465|      0|  return *this = ScaleFixed<std::divides>(*this, r);
  466|      0|}
  467|       |
  468|      0|Duration& Duration::operator/=(double r) {
  469|      0|  if (time_internal::IsInfiniteDuration(*this) || !IsValidDivisor(r)) {
  470|      0|    const bool is_neg = (std::signbit(r) != 0) != (rep_hi_ < 0);
  471|      0|    return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
  472|      0|  }
  473|      0|  return *this = ScaleDouble<std::divides>(*this, r);
  474|      0|}
  475|       |
  476|      0|Duration& Duration::operator%=(Duration rhs) {
  477|      0|  time_internal::IDivDuration(false, *this, rhs, this);
  478|      0|  return *this;
  479|      0|}
  480|       |
  481|      0|double FDivDuration(Duration num, Duration den) {
  482|      0|  // Arithmetic with infinity is sticky.
  483|      0|  if (time_internal::IsInfiniteDuration(num) || den == ZeroDuration()) {
  484|      0|    return (num < ZeroDuration()) == (den < ZeroDuration())
  485|      0|               ? std::numeric_limits<double>::infinity()
  486|      0|               : -std::numeric_limits<double>::infinity();
  487|      0|  }
  488|      0|  if (time_internal::IsInfiniteDuration(den)) return 0.0;
  489|      0|
  490|      0|  double a =
  491|      0|      static_cast<double>(time_internal::GetRepHi(num)) * kTicksPerSecond +
  492|      0|      time_internal::GetRepLo(num);
  493|      0|  double b =
  494|      0|      static_cast<double>(time_internal::GetRepHi(den)) * kTicksPerSecond +
  495|      0|      time_internal::GetRepLo(den);
  496|      0|  return a / b;
  497|      0|}
  498|       |
  499|       |//
  500|       |// Trunc/Floor/Ceil.
  501|       |//
  502|       |
  503|      0|Duration Trunc(Duration d, Duration unit) {
  504|      0|  return d - (d % unit);
  505|      0|}
  506|       |
  507|      0|Duration Floor(const Duration d, const Duration unit) {
  508|      0|  const absl::Duration td = Trunc(d, unit);
  509|      0|  return td <= d ? td : td - AbsDuration(unit);
  510|      0|}
  511|       |
  512|      0|Duration Ceil(const Duration d, const Duration unit) {
  513|      0|  const absl::Duration td = Trunc(d, unit);
  514|      0|  return td >= d ? td : td + AbsDuration(unit);
  515|      0|}
  516|       |
  517|       |//
  518|       |// Factory functions.
  519|       |//
  520|       |
  521|      0|Duration DurationFromTimespec(timespec ts) {
  522|      0|  if (static_cast<uint64_t>(ts.tv_nsec) < 1000 * 1000 * 1000) {
  523|      0|    int64_t ticks = ts.tv_nsec * kTicksPerNanosecond;
  524|      0|    return time_internal::MakeDuration(ts.tv_sec, ticks);
  525|      0|  }
  526|      0|  return Seconds(ts.tv_sec) + Nanoseconds(ts.tv_nsec);
  527|      0|}
  528|       |
  529|      0|Duration DurationFromTimeval(timeval tv) {
  530|      0|  if (static_cast<uint64_t>(tv.tv_usec) < 1000 * 1000) {
  531|      0|    int64_t ticks = tv.tv_usec * 1000 * kTicksPerNanosecond;
  532|      0|    return time_internal::MakeDuration(tv.tv_sec, ticks);
  533|      0|  }
  534|      0|  return Seconds(tv.tv_sec) + Microseconds(tv.tv_usec);
  535|      0|}
  536|       |
  537|       |//
  538|       |// Conversion to other duration types.
  539|       |//
  540|       |
  541|      0|int64_t ToInt64Nanoseconds(Duration d) {
  542|      0|  if (time_internal::GetRepHi(d) >= 0 &&
  543|      0|      time_internal::GetRepHi(d) >> 33 == 0) {
  544|      0|    return (time_internal::GetRepHi(d) * 1000 * 1000 * 1000) +
  545|      0|           (time_internal::GetRepLo(d) / kTicksPerNanosecond);
  546|      0|  }
  547|      0|  return d / Nanoseconds(1);
  548|      0|}
  549|      0|int64_t ToInt64Microseconds(Duration d) {
  550|      0|  if (time_internal::GetRepHi(d) >= 0 &&
  551|      0|      time_internal::GetRepHi(d) >> 43 == 0) {
  552|      0|    return (time_internal::GetRepHi(d) * 1000 * 1000) +
  553|      0|           (time_internal::GetRepLo(d) / (kTicksPerNanosecond * 1000));
  554|      0|  }
  555|      0|  return d / Microseconds(1);
  556|      0|}
  557|      0|int64_t ToInt64Milliseconds(Duration d) {
  558|      0|  if (time_internal::GetRepHi(d) >= 0 &&
  559|      0|      time_internal::GetRepHi(d) >> 53 == 0) {
  560|      0|    return (time_internal::GetRepHi(d) * 1000) +
  561|      0|           (time_internal::GetRepLo(d) / (kTicksPerNanosecond * 1000 * 1000));
  562|      0|  }
  563|      0|  return d / Milliseconds(1);
  564|      0|}
  565|      0|int64_t ToInt64Seconds(Duration d) {
  566|      0|  int64_t hi = time_internal::GetRepHi(d);
  567|      0|  if (time_internal::IsInfiniteDuration(d)) return hi;
  568|      0|  if (hi < 0 && time_internal::GetRepLo(d) != 0) ++hi;
  569|      0|  return hi;
  570|      0|}
  571|      0|int64_t ToInt64Minutes(Duration d) {
  572|      0|  int64_t hi = time_internal::GetRepHi(d);
  573|      0|  if (time_internal::IsInfiniteDuration(d)) return hi;
  574|      0|  if (hi < 0 && time_internal::GetRepLo(d) != 0) ++hi;
  575|      0|  return hi / 60;
  576|      0|}
  577|      0|int64_t ToInt64Hours(Duration d) {
  578|      0|  int64_t hi = time_internal::GetRepHi(d);
  579|      0|  if (time_internal::IsInfiniteDuration(d)) return hi;
  580|      0|  if (hi < 0 && time_internal::GetRepLo(d) != 0) ++hi;
  581|      0|  return hi / (60 * 60);
  582|      0|}
  583|       |
  584|      0|double ToDoubleNanoseconds(Duration d) {
  585|      0|  return FDivDuration(d, Nanoseconds(1));
  586|      0|}
  587|      0|double ToDoubleMicroseconds(Duration d) {
  588|      0|  return FDivDuration(d, Microseconds(1));
  589|      0|}
  590|      0|double ToDoubleMilliseconds(Duration d) {
  591|      0|  return FDivDuration(d, Milliseconds(1));
  592|      0|}
  593|      0|double ToDoubleSeconds(Duration d) {
  594|      0|  return FDivDuration(d, Seconds(1));
  595|      0|}
  596|      0|double ToDoubleMinutes(Duration d) {
  597|      0|  return FDivDuration(d, Minutes(1));
  598|      0|}
  599|      0|double ToDoubleHours(Duration d) {
  600|      0|  return FDivDuration(d, Hours(1));
  601|      0|}
  602|       |
  603|      0|timespec ToTimespec(Duration d) {
  604|      0|  timespec ts;
  605|      0|  if (!time_internal::IsInfiniteDuration(d)) {
  606|      0|    int64_t rep_hi = time_internal::GetRepHi(d);
  607|      0|    uint32_t rep_lo = time_internal::GetRepLo(d);
  608|      0|    if (rep_hi < 0) {
  609|      0|      // Tweak the fields so that unsigned division of rep_lo
  610|      0|      // maps to truncation (towards zero) for the timespec.
  611|      0|      rep_lo += kTicksPerNanosecond - 1;
  612|      0|      if (rep_lo >= kTicksPerSecond) {
  613|      0|        rep_hi += 1;
  614|      0|        rep_lo -= kTicksPerSecond;
  615|      0|      }
  616|      0|    }
  617|      0|    ts.tv_sec = rep_hi;
  618|      0|    if (ts.tv_sec == rep_hi) {  // no time_t narrowing
  619|      0|      ts.tv_nsec = rep_lo / kTicksPerNanosecond;
  620|      0|      return ts;
  621|      0|    }
  622|      0|  }
  623|      0|  if (d >= ZeroDuration()) {
  624|      0|    ts.tv_sec = std::numeric_limits<time_t>::max();
  625|      0|    ts.tv_nsec = 1000 * 1000 * 1000 - 1;
  626|      0|  } else {
  627|      0|    ts.tv_sec = std::numeric_limits<time_t>::min();
  628|      0|    ts.tv_nsec = 0;
  629|      0|  }
  630|      0|  return ts;
  631|      0|}
  632|       |
  633|      0|timeval ToTimeval(Duration d) {
  634|      0|  timeval tv;
  635|      0|  timespec ts = ToTimespec(d);
  636|      0|  if (ts.tv_sec < 0) {
  637|      0|    // Tweak the fields so that positive division of tv_nsec
  638|      0|    // maps to truncation (towards zero) for the timeval.
  639|      0|    ts.tv_nsec += 1000 - 1;
  640|      0|    if (ts.tv_nsec >= 1000 * 1000 * 1000) {
  641|      0|      ts.tv_sec += 1;
  642|      0|      ts.tv_nsec -= 1000 * 1000 * 1000;
  643|      0|    }
  644|      0|  }
  645|      0|  tv.tv_sec = ts.tv_sec;
  646|      0|  if (tv.tv_sec != ts.tv_sec) {  // narrowing
  647|      0|    if (ts.tv_sec < 0) {
  648|      0|      tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::min();
  649|      0|      tv.tv_usec = 0;
  650|      0|    } else {
  651|      0|      tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::max();
  652|      0|      tv.tv_usec = 1000 * 1000 - 1;
  653|      0|    }
  654|      0|    return tv;
  655|      0|  }
  656|      0|  tv.tv_usec = static_cast<int>(ts.tv_nsec / 1000);  // suseconds_t
  657|      0|  return tv;
  658|      0|}
  659|       |
  660|      0|std::chrono::nanoseconds ToChronoNanoseconds(Duration d) {
  661|      0|  return time_internal::ToChronoDuration<std::chrono::nanoseconds>(d);
  662|      0|}
  663|      0|std::chrono::microseconds ToChronoMicroseconds(Duration d) {
  664|      0|  return time_internal::ToChronoDuration<std::chrono::microseconds>(d);
  665|      0|}
  666|      0|std::chrono::milliseconds ToChronoMilliseconds(Duration d) {
  667|      0|  return time_internal::ToChronoDuration<std::chrono::milliseconds>(d);
  668|      0|}
  669|      0|std::chrono::seconds ToChronoSeconds(Duration d) {
  670|      0|  return time_internal::ToChronoDuration<std::chrono::seconds>(d);
  671|      0|}
  672|      0|std::chrono::minutes ToChronoMinutes(Duration d) {
  673|      0|  return time_internal::ToChronoDuration<std::chrono::minutes>(d);
  674|      0|}
  675|      0|std::chrono::hours ToChronoHours(Duration d) {
  676|      0|  return time_internal::ToChronoDuration<std::chrono::hours>(d);
  677|      0|}
  678|       |
  679|       |//
  680|       |// To/From string formatting.
  681|       |//
  682|       |
  683|       |namespace {
  684|       |
  685|       |// Formats a positive 64-bit integer in the given field width.  Note that
  686|       |// it is up to the caller of Format64() to ensure that there is sufficient
  687|       |// space before ep to hold the conversion.
  688|      0|char* Format64(char* ep, int width, int64_t v) {
  689|      0|  do {
  690|      0|    --width;
  691|      0|    *--ep = '0' + (v % 10);  // contiguous digits
  692|      0|  } while (v /= 10);
  693|      0|  while (--width >= 0) *--ep = '0';  // zero pad
  694|      0|  return ep;
  695|      0|}
  696|       |
  697|       |// Helpers for FormatDuration() that format 'n' and append it to 'out'
  698|       |// followed by the given 'unit'.  If 'n' formats to "0", nothing is
  699|       |// appended (not even the unit).
  700|       |
  701|       |// A type that encapsulates how to display a value of a particular unit. For
  702|       |// values that are displayed with fractional parts, the precision indicates
  703|       |// where to round the value. The precision varies with the display unit because
  704|       |// a Duration can hold only quarters of a nanosecond, so displaying information
  705|       |// beyond that is just noise.
  706|       |//
  707|       |// For example, a microsecond value of 42.00025xxxxx should not display beyond 5
  708|       |// fractional digits, because it is in the noise of what a Duration can
  709|       |// represent.
  710|       |struct DisplayUnit {
  711|       |  const char* abbr;
  712|       |  int prec;
  713|       |  double pow10;
  714|       |};
  715|       |const DisplayUnit kDisplayNano = {"ns", 2, 1e2};
  716|       |const DisplayUnit kDisplayMicro = {"us", 5, 1e5};
  717|       |const DisplayUnit kDisplayMilli = {"ms", 8, 1e8};
  718|       |const DisplayUnit kDisplaySec = {"s", 11, 1e11};
  719|       |const DisplayUnit kDisplayMin = {"m", -1, 0.0};   // prec ignored
  720|       |const DisplayUnit kDisplayHour = {"h", -1, 0.0};  // prec ignored
  721|       |
  722|      0|void AppendNumberUnit(std::string* out, int64_t n, DisplayUnit unit) {
  723|      0|  char buf[sizeof("2562047788015216")];  // hours in max duration
  724|      0|  char* const ep = buf + sizeof(buf);
  725|      0|  char* bp = Format64(ep, 0, n);
  726|      0|  if (*bp != '0' || bp + 1 != ep) {
  727|      0|    out->append(bp, ep - bp);
  728|      0|    out->append(unit.abbr);
  729|      0|  }
  730|      0|}
  731|       |
  732|       |// Note: unit.prec is limited to double's digits10 value (typically 15) so it
  733|       |// always fits in buf[].
  734|      0|void AppendNumberUnit(std::string* out, double n, DisplayUnit unit) {
  735|      0|  const int buf_size = std::numeric_limits<double>::digits10;
  736|      0|  const int prec = std::min(buf_size, unit.prec);
  737|      0|  char buf[buf_size];  // also large enough to hold integer part
  738|      0|  char* ep = buf + sizeof(buf);
  739|      0|  double d = 0;
  740|      0|  int64_t frac_part = Round(std::modf(n, &d) * unit.pow10);
  741|      0|  int64_t int_part = d;
  742|      0|  if (int_part != 0 || frac_part != 0) {
  743|      0|    char* bp = Format64(ep, 0, int_part);  // always < 1000
  744|      0|    out->append(bp, ep - bp);
  745|      0|    if (frac_part != 0) {
  746|      0|      out->push_back('.');
  747|      0|      bp = Format64(ep, prec, frac_part);
  748|      0|      while (ep[-1] == '0') --ep;
  749|      0|      out->append(bp, ep - bp);
  750|      0|    }
  751|      0|    out->append(unit.abbr);
  752|      0|  }
  753|      0|}
  754|       |
  755|       |}  // namespace
  756|       |
  757|       |// From Go's doc at https://golang.org/pkg/time/#Duration.String
  758|       |//   [FormatDuration] returns a string representing the duration in the
  759|       |//   form "72h3m0.5s". Leading zero units are omitted.  As a special
  760|       |//   case, durations less than one second format use a smaller unit
  761|       |//   (milli-, micro-, or nanoseconds) to ensure that the leading digit
  762|       |//   is non-zero.  The zero duration formats as 0, with no unit.
  763|      0|std::string FormatDuration(Duration d) {
  764|      0|  const Duration min_duration = Seconds(kint64min);
  765|      0|  if (d == min_duration) {
  766|      0|    // Avoid needing to negate kint64min by directly returning what the
  767|      0|    // following code should produce in that case.
  768|      0|    return "-2562047788015215h30m8s";
  769|      0|  }
  770|      0|  std::string s;
  771|      0|  if (d < ZeroDuration()) {
  772|      0|    s.append("-");
  773|      0|    d = -d;
  774|      0|  }
  775|      0|  if (d == InfiniteDuration()) {
  776|      0|    s.append("inf");
  777|      0|  } else if (d < Seconds(1)) {
  778|      0|    // Special case for durations with a magnitude < 1 second.  The duration
  779|      0|    // is printed as a fraction of a single unit, e.g., "1.2ms".
  780|      0|    if (d < Microseconds(1)) {
  781|      0|      AppendNumberUnit(&s, FDivDuration(d, Nanoseconds(1)), kDisplayNano);
  782|      0|    } else if (d < Milliseconds(1)) {
  783|      0|      AppendNumberUnit(&s, FDivDuration(d, Microseconds(1)), kDisplayMicro);
  784|      0|    } else {
  785|      0|      AppendNumberUnit(&s, FDivDuration(d, Milliseconds(1)), kDisplayMilli);
  786|      0|    }
  787|      0|  } else {
  788|      0|    AppendNumberUnit(&s, IDivDuration(d, Hours(1), &d), kDisplayHour);
  789|      0|    AppendNumberUnit(&s, IDivDuration(d, Minutes(1), &d), kDisplayMin);
  790|      0|    AppendNumberUnit(&s, FDivDuration(d, Seconds(1)), kDisplaySec);
  791|      0|  }
  792|      0|  if (s.empty() || s == "-") {
  793|      0|    s = "0";
  794|      0|  }
  795|      0|  return s;
  796|      0|}
  797|       |
  798|       |namespace {
  799|       |
  800|       |// A helper for ParseDuration() that parses a leading number from the given
  801|       |// string and stores the result in *int_part/*frac_part/*frac_scale.  The
  802|       |// given string pointer is modified to point to the first unconsumed char.
  803|       |bool ConsumeDurationNumber(const char** dpp, int64_t* int_part,
  804|      0|                           int64_t* frac_part, int64_t* frac_scale) {
  805|      0|  *int_part = 0;
  806|      0|  *frac_part = 0;
  807|      0|  *frac_scale = 1;  // invariant: *frac_part < *frac_scale
  808|      0|  const char* start = *dpp;
  809|      0|  for (; std::isdigit(**dpp); *dpp += 1) {
  810|      0|    const int d = **dpp - '0';  // contiguous digits
  811|      0|    if (*int_part > kint64max / 10) return false;
  812|      0|    *int_part *= 10;
  813|      0|    if (*int_part > kint64max - d) return false;
  814|      0|    *int_part += d;
  815|      0|  }
  816|      0|  const bool int_part_empty = (*dpp == start);
  817|      0|  if (**dpp != '.') return !int_part_empty;
  818|      0|  for (*dpp += 1; std::isdigit(**dpp); *dpp += 1) {
  819|      0|    const int d = **dpp - '0';  // contiguous digits
  820|      0|    if (*frac_scale <= kint64max / 10) {
  821|      0|      *frac_part *= 10;
  822|      0|      *frac_part += d;
  823|      0|      *frac_scale *= 10;
  824|      0|    }
  825|      0|  }
  826|      0|  return !int_part_empty || *frac_scale != 1;
  827|      0|}
  828|       |
  829|       |// A helper for ParseDuration() that parses a leading unit designator (e.g.,
  830|       |// ns, us, ms, s, m, h) from the given string and stores the resulting unit
  831|       |// in "*unit".  The given string pointer is modified to point to the first
  832|       |// unconsumed char.
  833|      0|bool ConsumeDurationUnit(const char** start, Duration* unit) {
  834|      0|  const char *s = *start;
  835|      0|  bool ok = true;
  836|      0|  if (strncmp(s, "ns", 2) == 0) {
  837|      0|    s += 2;
  838|      0|    *unit = Nanoseconds(1);
  839|      0|  } else if (strncmp(s, "us", 2) == 0) {
  840|      0|    s += 2;
  841|      0|    *unit = Microseconds(1);
  842|      0|  } else if (strncmp(s, "ms", 2) == 0) {
  843|      0|    s += 2;
  844|      0|    *unit = Milliseconds(1);
  845|      0|  } else if (strncmp(s, "s", 1) == 0) {
  846|      0|    s += 1;
  847|      0|    *unit = Seconds(1);
  848|      0|  } else if (strncmp(s, "m", 1) == 0) {
  849|      0|    s += 1;
  850|      0|    *unit = Minutes(1);
  851|      0|  } else if (strncmp(s, "h", 1) == 0) {
  852|      0|    s += 1;
  853|      0|    *unit = Hours(1);
  854|      0|  } else {
  855|      0|    ok = false;
  856|      0|  }
  857|      0|  *start = s;
  858|      0|  return ok;
  859|      0|}
  860|       |
  861|       |}  // namespace
  862|       |
  863|       |// From Go's doc at https://golang.org/pkg/time/#ParseDuration
  864|       |//   [ParseDuration] parses a duration string. A duration string is
  865|       |//   a possibly signed sequence of decimal numbers, each with optional
  866|       |//   fraction and a unit suffix, such as "300ms", "-1.5h" or "2h45m".
  867|       |//   Valid time units are "ns", "us" "ms", "s", "m", "h".
  868|      0|bool ParseDuration(const std::string& dur_string, Duration* d) {
  869|      0|  const char* start = dur_string.c_str();
  870|      0|  int sign = 1;
  871|      0|
  872|      0|  if (*start == '-' || *start == '+') {
  873|      0|    sign = *start == '-' ? -1 : 1;
  874|      0|    ++start;
  875|      0|  }
  876|      0|
  877|      0|  // Can't parse a duration from an empty std::string.
  878|      0|  if (*start == '\0') {
  879|      0|    return false;
  880|      0|  }
  881|      0|
  882|      0|  // Special case for a std::string of "0".
  883|      0|  if (*start == '0' && *(start + 1) == '\0') {
  884|      0|    *d = ZeroDuration();
  885|      0|    return true;
  886|      0|  }
  887|      0|
  888|      0|  if (strcmp(start, "inf") == 0) {
  889|      0|    *d = sign * InfiniteDuration();
  890|      0|    return true;
  891|      0|  }
  892|      0|
  893|      0|  Duration dur;
  894|      0|  while (*start != '\0') {
  895|      0|    int64_t int_part;
  896|      0|    int64_t frac_part;
  897|      0|    int64_t frac_scale;
  898|      0|    Duration unit;
  899|      0|    if (!ConsumeDurationNumber(&start, &int_part, &frac_part, &frac_scale) ||
  900|      0|        !ConsumeDurationUnit(&start, &unit)) {
  901|      0|      return false;
  902|      0|    }
  903|      0|    if (int_part != 0) dur += sign * int_part * unit;
  904|      0|    if (frac_part != 0) dur += sign * frac_part * unit / frac_scale;
  905|      0|  }
  906|      0|  *d = dur;
  907|      0|  return true;
  908|      0|}
  909|       |
  910|      0|bool ParseFlag(const std::string& text, Duration* dst, std::string* ) {
  911|      0|  return ParseDuration(text, dst);
  912|      0|}
  913|       |
  914|      0|std::string UnparseFlag(Duration d) { return FormatDuration(d); }
  915|       |
  916|       |}  // inline namespace lts_2019_08_08
  917|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/format.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include <string.h>
   16|       |#include <cctype>
   17|       |#include <cstdint>
   18|       |
   19|       |#include "absl/time/internal/cctz/include/cctz/time_zone.h"
   20|       |#include "absl/time/time.h"
   21|       |
   22|       |namespace cctz = absl::time_internal::cctz;
   23|       |
   24|       |namespace absl {
   25|       |inline namespace lts_2019_08_08 {
   26|       |
   27|       |extern const char RFC3339_full[] = "%Y-%m-%dT%H:%M:%E*S%Ez";
   28|       |extern const char RFC3339_sec[] =  "%Y-%m-%dT%H:%M:%S%Ez";
   29|       |
   30|       |extern const char RFC1123_full[] = "%a, %d %b %E4Y %H:%M:%S %z";
   31|       |extern const char RFC1123_no_wday[] =  "%d %b %E4Y %H:%M:%S %z";
   32|       |
   33|       |namespace {
   34|       |
   35|       |const char kInfiniteFutureStr[] = "infinite-future";
   36|       |const char kInfinitePastStr[] = "infinite-past";
   37|       |
   38|       |struct cctz_parts {
   39|       |  cctz::time_point<cctz::seconds> sec;
   40|       |  cctz::detail::femtoseconds fem;
   41|       |};
   42|       |
   43|      0|inline cctz::time_point<cctz::seconds> unix_epoch() {
   44|      0|  return std::chrono::time_point_cast<cctz::seconds>(
   45|      0|      std::chrono::system_clock::from_time_t(0));
   46|      0|}
   47|       |
   48|       |// Splits a Time into seconds and femtoseconds, which can be used with CCTZ.
   49|       |// Requires that 't' is finite. See duration.cc for details about rep_hi and
   50|       |// rep_lo.
   51|      0|cctz_parts Split(absl::Time t) {
   52|      0|  const auto d = time_internal::ToUnixDuration(t);
   53|      0|  const int64_t rep_hi = time_internal::GetRepHi(d);
   54|      0|  const int64_t rep_lo = time_internal::GetRepLo(d);
   55|      0|  const auto sec = unix_epoch() + cctz::seconds(rep_hi);
   56|      0|  const auto fem = cctz::detail::femtoseconds(rep_lo * (1000 * 1000 / 4));
   57|      0|  return {sec, fem};
   58|      0|}
   59|       |
   60|       |// Joins the given seconds and femtoseconds into a Time. See duration.cc for
   61|       |// details about rep_hi and rep_lo.
   62|      0|absl::Time Join(const cctz_parts& parts) {
   63|      0|  const int64_t rep_hi = (parts.sec - unix_epoch()).count();
   64|      0|  const uint32_t rep_lo = parts.fem.count() / (1000 * 1000 / 4);
   65|      0|  const auto d = time_internal::MakeDuration(rep_hi, rep_lo);
   66|      0|  return time_internal::FromUnixDuration(d);
   67|      0|}
   68|       |
   69|       |}  // namespace
   70|       |
   71|       |std::string FormatTime(const std::string& format, absl::Time t,
   72|      0|                       absl::TimeZone tz) {
   73|      0|  if (t == absl::InfiniteFuture()) return kInfiniteFutureStr;
   74|      0|  if (t == absl::InfinitePast()) return kInfinitePastStr;
   75|      0|  const auto parts = Split(t);
   76|      0|  return cctz::detail::format(format, parts.sec, parts.fem,
   77|      0|                              cctz::time_zone(tz));
   78|      0|}
   79|       |
   80|      0|std::string FormatTime(absl::Time t, absl::TimeZone tz) {
   81|      0|  return FormatTime(RFC3339_full, t, tz);
   82|      0|}
   83|       |
   84|      0|std::string FormatTime(absl::Time t) {
   85|      0|  return absl::FormatTime(RFC3339_full, t, absl::LocalTimeZone());
   86|      0|}
   87|       |
   88|       |bool ParseTime(const std::string& format, const std::string& input,
   89|      0|               absl::Time* time, std::string* err) {
   90|      0|  return absl::ParseTime(format, input, absl::UTCTimeZone(), time, err);
   91|      0|}
   92|       |
   93|       |// If the input string does not contain an explicit UTC offset, interpret
   94|       |// the fields with respect to the given TimeZone.
   95|       |bool ParseTime(const std::string& format, const std::string& input,
   96|      0|               absl::TimeZone tz, absl::Time* time, std::string* err) {
   97|      0|  const char* data = input.c_str();
   98|      0|  while (std::isspace(*data)) ++data;
   99|      0|
  100|      0|  size_t inf_size = strlen(kInfiniteFutureStr);
  101|      0|  if (strncmp(data, kInfiniteFutureStr, inf_size) == 0) {
  102|      0|    const char* new_data = data + inf_size;
  103|      0|    while (std::isspace(*new_data)) ++new_data;
  104|      0|    if (*new_data == '\0') {
  105|      0|      *time = InfiniteFuture();
  106|      0|      return true;
  107|      0|    }
  108|      0|  }
  109|      0|
  110|      0|  inf_size = strlen(kInfinitePastStr);
  111|      0|  if (strncmp(data, kInfinitePastStr, inf_size) == 0) {
  112|      0|    const char* new_data = data + inf_size;
  113|      0|    while (std::isspace(*new_data)) ++new_data;
  114|      0|    if (*new_data == '\0') {
  115|      0|      *time = InfinitePast();
  116|      0|      return true;
  117|      0|    }
  118|      0|  }
  119|      0|
  120|      0|  std::string error;
  121|      0|  cctz_parts parts;
  122|      0|  const bool b = cctz::detail::parse(format, input, cctz::time_zone(tz),
  123|      0|                                     &parts.sec, &parts.fem, &error);
  124|      0|  if (b) {
  125|      0|    *time = Join(parts);
  126|      0|  } else if (err != nullptr) {
  127|      0|    *err = error;
  128|      0|  }
  129|      0|  return b;
  130|      0|}
  131|       |
  132|       |// Functions required to support absl::Time flags.
  133|      0|bool ParseFlag(const std::string& text, absl::Time* t, std::string* error) {
  134|      0|  return absl::ParseTime(RFC3339_full, text, absl::UTCTimeZone(), t, error);
  135|      0|}
  136|       |
  137|      0|std::string UnparseFlag(absl::Time t) {
  138|      0|  return absl::FormatTime(RFC3339_full, t, absl::UTCTimeZone());
  139|      0|}
  140|       |
  141|       |}  // inline namespace lts_2019_08_08
  142|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/include/cctz/civil_time_detail.h:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#ifndef ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_
   16|       |#define ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_
   17|       |
   18|       |#include <cstdint>
   19|       |#include <limits>
   20|       |#include <ostream>
   21|       |#include <type_traits>
   22|       |
   23|       |// Disable constexpr support unless we are in C++14 mode.
   24|       |#if __cpp_constexpr >= 201304 || (defined(_MSC_VER) && _MSC_VER >= 1910)
   25|      0|#define CONSTEXPR_D constexpr  // data
   26|       |#define CONSTEXPR_F constexpr  // function
   27|       |#define CONSTEXPR_M constexpr  // member
   28|       |#else
   29|       |#define CONSTEXPR_D const
   30|       |#define CONSTEXPR_F inline
   31|       |#define CONSTEXPR_M
   32|       |#endif
   33|       |
   34|       |namespace absl {
   35|       |inline namespace lts_2019_08_08 {
   36|       |namespace time_internal {
   37|       |namespace cctz {
   38|       |
   39|       |// Support years that at least span the range of 64-bit time_t values.
   40|       |using year_t = std::int_fast64_t;
   41|       |
   42|       |// Type alias that indicates an argument is not normalized (e.g., the
   43|       |// constructor parameters and operands/results of addition/subtraction).
   44|       |using diff_t = std::int_fast64_t;
   45|       |
   46|       |namespace detail {
   47|       |
   48|       |// Type aliases that indicate normalized argument values.
   49|       |using month_t = std::int_fast8_t;   // [1:12]
   50|       |using day_t = std::int_fast8_t;     // [1:31]
   51|       |using hour_t = std::int_fast8_t;    // [0:23]
   52|       |using minute_t = std::int_fast8_t;  // [0:59]
   53|       |using second_t = std::int_fast8_t;  // [0:59]
   54|       |
   55|       |// Normalized civil-time fields: Y-M-D HH:MM:SS.
   56|       |struct fields {
   57|       |  CONSTEXPR_M fields(year_t year, month_t month, day_t day,
   58|       |                     hour_t hour, minute_t minute, second_t second)
   59|      0|      : y(year), m(month), d(day), hh(hour), mm(minute), ss(second) {}
   60|       |  std::int_least64_t y;
   61|       |  std::int_least8_t m;
   62|       |  std::int_least8_t d;
   63|       |  std::int_least8_t hh;
   64|       |  std::int_least8_t mm;
   65|       |  std::int_least8_t ss;
   66|       |};
   67|       |
   68|       |struct second_tag {};
   69|       |struct minute_tag : second_tag {};
   70|       |struct hour_tag : minute_tag {};
   71|       |struct day_tag : hour_tag {};
   72|       |struct month_tag : day_tag {};
   73|       |struct year_tag : month_tag {};
   74|       |
   75|       |////////////////////////////////////////////////////////////////////////
   76|       |
   77|       |// Field normalization (without avoidable overflow).
   78|       |
   79|       |namespace impl {
   80|       |
   81|      0|CONSTEXPR_F bool is_leap_year(year_t y) noexcept {
   82|      0|  return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
   83|      0|}
   84|      0|CONSTEXPR_F int year_index(year_t y, month_t m) noexcept {
   85|      0|  return (static_cast<int>((y + (m > 2)) % 400) + 400) % 400;
   86|      0|}
   87|      0|CONSTEXPR_F int days_per_century(year_t y, month_t m) noexcept {
   88|      0|  const int yi = year_index(y, m);
   89|      0|  return 36524 + (yi == 0 || yi > 300);
   90|      0|}
   91|      0|CONSTEXPR_F int days_per_4years(year_t y, month_t m) noexcept {
   92|      0|  const int yi = year_index(y, m);
   93|      0|  return 1460 + (yi == 0 || yi > 300 || (yi - 1) % 100 < 96);
   94|      0|}
   95|      0|CONSTEXPR_F int days_per_year(year_t y, month_t m) noexcept {
   96|      0|  return is_leap_year(y + (m > 2)) ? 366 : 365;
   97|      0|}
   98|      0|CONSTEXPR_F int days_per_month(year_t y, month_t m) noexcept {
   99|      0|  CONSTEXPR_D int k_days_per_month[1 + 12] = {
  100|      0|      -1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  // non leap year
  101|      0|  };
  102|      0|  return k_days_per_month[m] + (m == 2 && is_leap_year(y));
  103|      0|}
  104|       |
  105|       |CONSTEXPR_F fields n_day(year_t y, month_t m, diff_t d, diff_t cd,
  106|      0|                         hour_t hh, minute_t mm, second_t ss) noexcept {
  107|      0|  y += (cd / 146097) * 400;
  108|      0|  cd %= 146097;
  109|      0|  if (cd < 0) {
  110|      0|    y -= 400;
  111|      0|    cd += 146097;
  112|      0|  }
  113|      0|  y += (d / 146097) * 400;
  114|      0|  d = d % 146097 + cd;
  115|      0|  if (d > 0) {
  116|      0|    if (d > 146097) {
  117|      0|      y += 400;
  118|      0|      d -= 146097;
  119|      0|    }
  120|      0|  } else {
  121|      0|    if (d > -365) {
  122|      0|      // We often hit the previous year when stepping a civil time backwards,
  123|      0|      // so special case it to avoid counting up by 100/4/1-year chunks.
  124|      0|      y -= 1;
  125|      0|      d += days_per_year(y, m);
  126|      0|    } else {
  127|      0|      y -= 400;
  128|      0|      d += 146097;
  129|      0|    }
  130|      0|  }
  131|      0|  if (d > 365) {
  132|      0|    for (int n = days_per_century(y, m); d > n; n = days_per_century(y, m)) {
  133|      0|      d -= n;
  134|      0|      y += 100;
  135|      0|    }
  136|      0|    for (int n = days_per_4years(y, m); d > n; n = days_per_4years(y, m)) {
  137|      0|      d -= n;
  138|      0|      y += 4;
  139|      0|    }
  140|      0|    for (int n = days_per_year(y, m); d > n; n = days_per_year(y, m)) {
  141|      0|      d -= n;
  142|      0|      ++y;
  143|      0|    }
  144|      0|  }
  145|      0|  if (d > 28) {
  146|      0|    for (int n = days_per_month(y, m); d > n; n = days_per_month(y, m)) {
  147|      0|      d -= n;
  148|      0|      if (++m > 12) {
  149|      0|        ++y;
  150|      0|        m = 1;
  151|      0|      }
  152|      0|    }
  153|      0|  }
  154|      0|  return fields(y, m, static_cast<day_t>(d), hh, mm, ss);
  155|      0|}
  156|       |CONSTEXPR_F fields n_mon(year_t y, diff_t m, diff_t d, diff_t cd,
  157|      0|                         hour_t hh, minute_t mm, second_t ss) noexcept {
  158|      0|  if (m != 12) {
  159|      0|    y += m / 12;
  160|      0|    m %= 12;
  161|      0|    if (m <= 0) {
  162|      0|      y -= 1;
  163|      0|      m += 12;
  164|      0|    }
  165|      0|  }
  166|      0|  return n_day(y, static_cast<month_t>(m), d, cd, hh, mm, ss);
  167|      0|}
  168|       |CONSTEXPR_F fields n_hour(year_t y, diff_t m, diff_t d, diff_t cd,
  169|      0|                          diff_t hh, minute_t mm, second_t ss) noexcept {
  170|      0|  cd += hh / 24;
  171|      0|  hh %= 24;
  172|      0|  if (hh < 0) {
  173|      0|    cd -= 1;
  174|      0|    hh += 24;
  175|      0|  }
  176|      0|  return n_mon(y, m, d, cd, static_cast<hour_t>(hh), mm, ss);
  177|      0|}
  178|       |CONSTEXPR_F fields n_min(year_t y, diff_t m, diff_t d, diff_t hh, diff_t ch,
  179|      0|                         diff_t mm, second_t ss) noexcept {
  180|      0|  ch += mm / 60;
  181|      0|  mm %= 60;
  182|      0|  if (mm < 0) {
  183|      0|    ch -= 1;
  184|      0|    mm += 60;
  185|      0|  }
  186|      0|  return n_hour(y, m, d, hh / 24 + ch / 24, hh % 24 + ch % 24,
  187|      0|                static_cast<minute_t>(mm), ss);
  188|      0|}
  189|       |CONSTEXPR_F fields n_sec(year_t y, diff_t m, diff_t d, diff_t hh, diff_t mm,
  190|      0|                         diff_t ss) noexcept {
  191|      0|  // Optimization for when (non-constexpr) fields are already normalized.
  192|      0|  if (0 <= ss && ss < 60) {
  193|      0|    const second_t nss = static_cast<second_t>(ss);
  194|      0|    if (0 <= mm && mm < 60) {
  195|      0|      const minute_t nmm = static_cast<minute_t>(mm);
  196|      0|      if (0 <= hh && hh < 24) {
  197|      0|        const hour_t nhh = static_cast<hour_t>(hh);
  198|      0|        if (1 <= d && d <= 28 && 1 <= m && m <= 12) {
  199|      0|          const day_t nd = static_cast<day_t>(d);
  200|      0|          const month_t nm = static_cast<month_t>(m);
  201|      0|          return fields(y, nm, nd, nhh, nmm, nss);
  202|      0|        }
  203|      0|        return n_mon(y, m, d, 0, nhh, nmm, nss);
  204|      0|      }
  205|      0|      return n_hour(y, m, d, hh / 24, hh % 24, nmm, nss);
  206|      0|    }
  207|      0|    return n_min(y, m, d, hh, mm / 60, mm % 60, nss);
  208|      0|  }
  209|      0|  diff_t cm = ss / 60;
  210|      0|  ss %= 60;
  211|      0|  if (ss < 0) {
  212|      0|    cm -= 1;
  213|      0|    ss += 60;
  214|      0|  }
  215|      0|  return n_min(y, m, d, hh, mm / 60 + cm / 60, mm % 60 + cm % 60,
  216|      0|               static_cast<second_t>(ss));
  217|      0|}
  218|       |
  219|       |}  // namespace impl
  220|       |
  221|       |////////////////////////////////////////////////////////////////////////
  222|       |
  223|       |// Increments the indicated (normalized) field by "n".
  224|      0|CONSTEXPR_F fields step(second_tag, fields f, diff_t n) noexcept {
  225|      0|  return impl::n_sec(f.y, f.m, f.d, f.hh, f.mm + n / 60, f.ss + n % 60);
  226|      0|}
  227|      0|CONSTEXPR_F fields step(minute_tag, fields f, diff_t n) noexcept {
  228|      0|  return impl::n_min(f.y, f.m, f.d, f.hh + n / 60, 0, f.mm + n % 60, f.ss);
  229|      0|}
  230|      0|CONSTEXPR_F fields step(hour_tag, fields f, diff_t n) noexcept {
  231|      0|  return impl::n_hour(f.y, f.m, f.d + n / 24, 0, f.hh + n % 24, f.mm, f.ss);
  232|      0|}
  233|      0|CONSTEXPR_F fields step(day_tag, fields f, diff_t n) noexcept {
  234|      0|  return impl::n_day(f.y, f.m, f.d, n, f.hh, f.mm, f.ss);
  235|      0|}
  236|      0|CONSTEXPR_F fields step(month_tag, fields f, diff_t n) noexcept {
  237|      0|  return impl::n_mon(f.y + n / 12, f.m + n % 12, f.d, 0, f.hh, f.mm, f.ss);
  238|      0|}
  239|      0|CONSTEXPR_F fields step(year_tag, fields f, diff_t n) noexcept {
  240|      0|  return fields(f.y + n, f.m, f.d, f.hh, f.mm, f.ss);
  241|      0|}
  242|       |
  243|       |////////////////////////////////////////////////////////////////////////
  244|       |
  245|       |namespace impl {
  246|       |
  247|       |// Returns (v * f + a) but avoiding intermediate overflow when possible.
  248|      0|CONSTEXPR_F diff_t scale_add(diff_t v, diff_t f, diff_t a) noexcept {
  249|      0|  return (v < 0) ? ((v + 1) * f + a) - f : ((v - 1) * f + a) + f;
  250|      0|}
  251|       |
  252|       |// Map a (normalized) Y/M/D to the number of days before/after 1970-01-01.
  253|       |// Probably overflows for years outside [-292277022656:292277026595].
  254|      0|CONSTEXPR_F diff_t ymd_ord(year_t y, month_t m, day_t d) noexcept {
  255|      0|  const diff_t eyear = (m <= 2) ? y - 1 : y;
  256|      0|  const diff_t era = (eyear >= 0 ? eyear : eyear - 399) / 400;
  257|      0|  const diff_t yoe = eyear - era * 400;
  258|      0|  const diff_t doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;
  259|      0|  const diff_t doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
  260|      0|  return era * 146097 + doe - 719468;
  261|      0|}
  262|       |
  263|       |// Returns the difference in days between two normalized Y-M-D tuples.
  264|       |// ymd_ord() will encounter integer overflow given extreme year values,
  265|       |// yet the difference between two such extreme values may actually be
  266|       |// small, so we take a little care to avoid overflow when possible by
  267|       |// exploiting the 146097-day cycle.
  268|       |CONSTEXPR_F diff_t day_difference(year_t y1, month_t m1, day_t d1,
  269|      0|                                  year_t y2, month_t m2, day_t d2) noexcept {
  270|      0|  const diff_t a_c4_off = y1 % 400;
  271|      0|  const diff_t b_c4_off = y2 % 400;
  272|      0|  diff_t c4_diff = (y1 - a_c4_off) - (y2 - b_c4_off);
  273|      0|  diff_t delta = ymd_ord(a_c4_off, m1, d1) - ymd_ord(b_c4_off, m2, d2);
  274|      0|  if (c4_diff > 0 && delta < 0) {
  275|      0|    delta += 2 * 146097;
  276|      0|    c4_diff -= 2 * 400;
  277|      0|  } else if (c4_diff < 0 && delta > 0) {
  278|      0|    delta -= 2 * 146097;
  279|      0|    c4_diff += 2 * 400;
  280|      0|  }
  281|      0|  return (c4_diff / 400 * 146097) + delta;
  282|      0|}
  283|       |
  284|       |}  // namespace impl
  285|       |
  286|       |// Returns the difference between fields structs using the indicated unit.
  287|      0|CONSTEXPR_F diff_t difference(year_tag, fields f1, fields f2) noexcept {
  288|      0|  return f1.y - f2.y;
  289|      0|}
  290|      0|CONSTEXPR_F diff_t difference(month_tag, fields f1, fields f2) noexcept {
  291|      0|  return impl::scale_add(difference(year_tag{}, f1, f2), 12, (f1.m - f2.m));
  292|      0|}
  293|      0|CONSTEXPR_F diff_t difference(day_tag, fields f1, fields f2) noexcept {
  294|      0|  return impl::day_difference(f1.y, f1.m, f1.d, f2.y, f2.m, f2.d);
  295|      0|}
  296|      0|CONSTEXPR_F diff_t difference(hour_tag, fields f1, fields f2) noexcept {
  297|      0|  return impl::scale_add(difference(day_tag{}, f1, f2), 24, (f1.hh - f2.hh));
  298|      0|}
  299|      0|CONSTEXPR_F diff_t difference(minute_tag, fields f1, fields f2) noexcept {
  300|      0|  return impl::scale_add(difference(hour_tag{}, f1, f2), 60, (f1.mm - f2.mm));
  301|      0|}
  302|      0|CONSTEXPR_F diff_t difference(second_tag, fields f1, fields f2) noexcept {
  303|      0|  return impl::scale_add(difference(minute_tag{}, f1, f2), 60, f1.ss - f2.ss);
  304|      0|}
  305|       |
  306|       |////////////////////////////////////////////////////////////////////////
  307|       |
  308|       |// Aligns the (normalized) fields struct to the indicated field.
  309|      0|CONSTEXPR_F fields align(second_tag, fields f) noexcept {
  310|      0|  return f;
  311|      0|}
  312|      0|CONSTEXPR_F fields align(minute_tag, fields f) noexcept {
  313|      0|  return fields{f.y, f.m, f.d, f.hh, f.mm, 0};
  314|      0|}
  315|      0|CONSTEXPR_F fields align(hour_tag, fields f) noexcept {
  316|      0|  return fields{f.y, f.m, f.d, f.hh, 0, 0};
  317|      0|}
  318|      0|CONSTEXPR_F fields align(day_tag, fields f) noexcept {
  319|      0|  return fields{f.y, f.m, f.d, 0, 0, 0};
  320|      0|}
  321|      0|CONSTEXPR_F fields align(month_tag, fields f) noexcept {
  322|      0|  return fields{f.y, f.m, 1, 0, 0, 0};
  323|      0|}
  324|      0|CONSTEXPR_F fields align(year_tag, fields f) noexcept {
  325|      0|  return fields{f.y, 1, 1, 0, 0, 0};
  326|      0|}
  327|       |
  328|       |////////////////////////////////////////////////////////////////////////
  329|       |
  330|       |namespace impl {
  331|       |
  332|       |template <typename H>
  333|       |H AbslHashValueImpl(second_tag, H h, fields f) {
  334|       |  return H::combine(std::move(h), f.y, f.m, f.d, f.hh, f.mm, f.ss);
  335|       |}
  336|       |template <typename H>
  337|       |H AbslHashValueImpl(minute_tag, H h, fields f) {
  338|       |  return H::combine(std::move(h), f.y, f.m, f.d, f.hh, f.mm);
  339|       |}
  340|       |template <typename H>
  341|       |H AbslHashValueImpl(hour_tag, H h, fields f) {
  342|       |  return H::combine(std::move(h), f.y, f.m, f.d, f.hh);
  343|       |}
  344|       |template <typename H>
  345|       |H AbslHashValueImpl(day_tag, H h, fields f) {
  346|       |  return H::combine(std::move(h), f.y, f.m, f.d);
  347|       |}
  348|       |template <typename H>
  349|       |H AbslHashValueImpl(month_tag, H h, fields f) {
  350|       |  return H::combine(std::move(h), f.y, f.m);
  351|       |}
  352|       |template <typename H>
  353|       |H AbslHashValueImpl(year_tag, H h, fields f) {
  354|       |  return H::combine(std::move(h), f.y);
  355|       |}
  356|       |
  357|       |}  // namespace impl
  358|       |
  359|       |////////////////////////////////////////////////////////////////////////
  360|       |
  361|       |template <typename T>
  362|       |class civil_time {
  363|       | public:
  364|       |  explicit CONSTEXPR_M civil_time(year_t y, diff_t m = 1, diff_t d = 1,
  365|       |                                  diff_t hh = 0, diff_t mm = 0,
  366|       |                                  diff_t ss = 0) noexcept
  367|      0|      : civil_time(impl::n_sec(y, m, d, hh, mm, ss)) {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEEC1Exxxxxx
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEEC1Exxxxxx
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_7day_tagEEC1Exxxxxx
  ------------------
  368|       |
  369|      0|  CONSTEXPR_M civil_time() noexcept : f_{1970, 1, 1, 0, 0, 0} {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEEC2Ev
  ------------------
  370|       |  civil_time(const civil_time&) = default;
  371|       |  civil_time& operator=(const civil_time&) = default;
  372|       |
  373|       |  // Conversion between civil times of different alignment. Conversion to
  374|       |  // a more precise alignment is allowed implicitly (e.g., day -> hour),
  375|       |  // but conversion where information is discarded must be explicit
  376|       |  // (e.g., second -> minute).
  377|       |  template <typename U, typename S>
  378|       |  using preserves_data =
  379|       |      typename std::enable_if<std::is_base_of<U, S>::value>::type;
  380|       |  template <typename U>
  381|       |  CONSTEXPR_M civil_time(const civil_time<U>& ct,
  382|       |                         preserves_data<T, U>* = nullptr) noexcept
  383|      0|      : civil_time(ct.f_) {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEEC1INS1_10minute_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS5_S9_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEEC1INS1_8hour_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS5_S9_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEEC1INS1_7day_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS5_S9_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEEC1INS1_9month_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS5_S9_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEEC1INS1_8year_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS5_S9_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEEC1INS3_7day_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS5_S9_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEEC1INS1_10second_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS5_S9_EE5valueEvE4typeE
  ------------------
  384|       |  template <typename U>
  385|       |  explicit CONSTEXPR_M civil_time(const civil_time<U>& ct,
  386|       |                                  preserves_data<U, T>* = nullptr) noexcept
  387|      0|      : civil_time(ct.f_) {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_8year_tagEEC1INS3_9month_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS9_S5_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_9month_tagEEC1INS3_7day_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS9_S5_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_7day_tagEEC1INS3_8hour_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS9_S5_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_8hour_tagEEC1INS3_10minute_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS9_S5_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10minute_tagEEC1INS3_10second_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS9_S5_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_7day_tagEEC1INS3_10second_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS9_S5_EE5valueEvE4typeE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEEC1INS3_10second_tagEEERKNS4_IT_EEPNSt3__19enable_ifIXsr3std10is_base_ofIS9_S5_EE5valueEvE4typeE
  ------------------
  388|       |
  389|       |  // Factories for the maximum/minimum representable civil_time.
  390|      0|  static CONSTEXPR_F civil_time (max)() {
  391|      0|    const auto max_year = (std::numeric_limits<std::int_least64_t>::max)();
  392|      0|    return civil_time(max_year, 12, 31, 23, 59, 59);
  393|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEE3maxEv
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEE3maxEv
  ------------------
  394|      0|  static CONSTEXPR_F civil_time (min)() {
  395|      0|    const auto min_year = (std::numeric_limits<std::int_least64_t>::min)();
  396|      0|    return civil_time(min_year, 1, 1, 0, 0, 0);
  397|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEE3minEv
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEE3minEv
  ------------------
  398|       |
  399|       |  // Field accessors.  Note: All but year() return an int.
  400|      0|  CONSTEXPR_M year_t year() const noexcept { return f_.y; }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEE4yearEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEE4yearEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_8year_tagEE4yearEv
  ------------------
  401|      0|  CONSTEXPR_M int month() const noexcept { return f_.m; }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEE5monthEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEE5monthEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_9month_tagEE5monthEv
  ------------------
  402|      0|  CONSTEXPR_M int day() const noexcept { return f_.d; }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEE3dayEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEE3dayEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_7day_tagEE3dayEv
  ------------------
  403|      0|  CONSTEXPR_M int hour() const noexcept { return f_.hh; }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEE4hourEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_8hour_tagEE4hourEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEE4hourEv
  ------------------
  404|      0|  CONSTEXPR_M int minute() const noexcept { return f_.mm; }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEE6minuteEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10minute_tagEE6minuteEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEE6minuteEv
  ------------------
  405|      0|  CONSTEXPR_M int second() const noexcept { return f_.ss; }
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEE6secondEv
  ------------------
  | Unexecuted instantiation: _ZNK4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEE6secondEv
  ------------------
  406|       |
  407|       |  // Assigning arithmetic.
  408|      0|  CONSTEXPR_M civil_time& operator+=(diff_t n) noexcept {
  409|      0|    f_ = step(T{}, f_, n);
  410|      0|    return *this;
  411|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_7day_tagEEpLEx
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEEpLEx
  ------------------
  412|      0|  CONSTEXPR_M civil_time& operator-=(diff_t n) noexcept {
  413|      0|    if (n != (std::numeric_limits<diff_t>::min)()) {
  414|      0|      f_ = step(T{}, f_, -n);
  415|      0|    } else {
  416|      0|      f_ = step(T{}, step(T{}, f_, -(n + 1)), 1);
  417|      0|    }
  418|      0|    return *this;
  419|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_7day_tagEEmIEx
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEEmIEx
  ------------------
  420|       |  CONSTEXPR_M civil_time& operator++() noexcept {
  421|       |    return *this += 1;
  422|       |  }
  423|       |  CONSTEXPR_M civil_time operator++(int) noexcept {
  424|       |    const civil_time a = *this;
  425|       |    ++*this;
  426|       |    return a;
  427|       |  }
  428|       |  CONSTEXPR_M civil_time& operator--() noexcept {
  429|       |    return *this -= 1;
  430|       |  }
  431|       |  CONSTEXPR_M civil_time operator--(int) noexcept {
  432|       |    const civil_time a = *this;
  433|       |    --*this;
  434|       |    return a;
  435|       |  }
  436|       |
  437|       |  // Binary arithmetic operators.
  438|      0|  friend CONSTEXPR_F civil_time operator+(civil_time a, diff_t n) noexcept {
  439|      0|    return a += n;
  440|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detailplENS3_10civil_timeINS3_7day_tagEEEx
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detailplENS3_10civil_timeINS3_10second_tagEEEx
  ------------------
  441|       |  friend CONSTEXPR_F civil_time operator+(diff_t n, civil_time a) noexcept {
  442|       |    return a += n;
  443|       |  }
  444|      0|  friend CONSTEXPR_F civil_time operator-(civil_time a, diff_t n) noexcept {
  445|      0|    return a -= n;
  446|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detailmiENS3_10civil_timeINS3_7day_tagEEEx
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detailmiENS3_10civil_timeINS3_10second_tagEEEx
  ------------------
  447|      0|  friend CONSTEXPR_F diff_t operator-(civil_time lhs, civil_time rhs) noexcept {
  448|      0|    return difference(T{}, lhs.f_, rhs.f_);
  449|      0|  }
  450|       |
  451|       |  template <typename H>
  452|       |  friend H AbslHashValue(H h, civil_time a) {
  453|       |    return impl::AbslHashValueImpl(T{}, std::move(h), a.f_);
  454|       |  }
  455|       |
  456|       | private:
  457|       |  // All instantiations of this template are allowed to call the following
  458|       |  // private constructor and access the private fields member.
  459|       |  template <typename U>
  460|       |  friend class civil_time;
  461|       |
  462|       |  // The designated constructor that all others eventually call.
  463|      0|  explicit CONSTEXPR_M civil_time(fields f) noexcept : f_(align(T{}, f)) {}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS1_10second_tagEEC2ENS3_6fieldsE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_8year_tagEEC2ENS3_6fieldsE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_9month_tagEEC2ENS3_6fieldsE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_7day_tagEEC2ENS3_6fieldsE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_8hour_tagEEC2ENS3_6fieldsE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10minute_tagEEC2ENS3_6fieldsE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz6detail10civil_timeINS3_10second_tagEEC2ENS3_6fieldsE
  ------------------
  464|       |
  465|       |  fields f_;
  466|       |};
  467|       |
  468|       |// Disallows difference between differently aligned types.
  469|       |// auto n = civil_day(...) - civil_hour(...);  // would be confusing.
  470|       |template <typename T, typename U>
  471|       |CONSTEXPR_F diff_t operator-(civil_time<T>, civil_time<U>) = delete;
  472|       |
  473|       |using civil_year = civil_time<year_tag>;
  474|       |using civil_month = civil_time<month_tag>;
  475|       |using civil_day = civil_time<day_tag>;
  476|       |using civil_hour = civil_time<hour_tag>;
  477|       |using civil_minute = civil_time<minute_tag>;
  478|       |using civil_second = civil_time<second_tag>;
  479|       |
  480|       |////////////////////////////////////////////////////////////////////////
  481|       |
  482|       |// Relational operators that work with differently aligned objects.
  483|       |// Always compares all six fields.
  484|       |template <typename T1, typename T2>
  485|       |CONSTEXPR_F bool operator<(const civil_time<T1>& lhs,
  486|      0|                           const civil_time<T2>& rhs) noexcept {
  487|      0|  return (lhs.year() < rhs.year() ||
  488|      0|          (lhs.year() == rhs.year() &&
  489|      0|           (lhs.month() < rhs.month() ||
  490|      0|            (lhs.month() == rhs.month() &&
  491|      0|             (lhs.day() < rhs.day() ||
  492|      0|              (lhs.day() == rhs.day() &&
  493|      0|               (lhs.hour() < rhs.hour() ||
  494|      0|                (lhs.hour() == rhs.hour() &&
  495|      0|                 (lhs.minute() < rhs.minute() ||
  496|      0|                  (lhs.minute() == rhs.minute() &&
  497|      0|                   (lhs.second() < rhs.second())))))))))));
  498|      0|}
  499|       |template <typename T1, typename T2>
  500|       |CONSTEXPR_F bool operator<=(const civil_time<T1>& lhs,
  501|      0|                            const civil_time<T2>& rhs) noexcept {
  502|      0|  return !(rhs < lhs);
  503|      0|}
  504|       |template <typename T1, typename T2>
  505|       |CONSTEXPR_F bool operator>=(const civil_time<T1>& lhs,
  506|      0|                            const civil_time<T2>& rhs) noexcept {
  507|      0|  return !(lhs < rhs);
  508|      0|}
  509|       |template <typename T1, typename T2>
  510|       |CONSTEXPR_F bool operator>(const civil_time<T1>& lhs,
  511|      0|                           const civil_time<T2>& rhs) noexcept {
  512|      0|  return rhs < lhs;
  513|      0|}
  514|       |template <typename T1, typename T2>
  515|       |CONSTEXPR_F bool operator==(const civil_time<T1>& lhs,
  516|       |                            const civil_time<T2>& rhs) noexcept {
  517|       |  return lhs.year() == rhs.year() && lhs.month() == rhs.month() &&
  518|       |         lhs.day() == rhs.day() && lhs.hour() == rhs.hour() &&
  519|       |         lhs.minute() == rhs.minute() && lhs.second() == rhs.second();
  520|       |}
  521|       |template <typename T1, typename T2>
  522|       |CONSTEXPR_F bool operator!=(const civil_time<T1>& lhs,
  523|       |                            const civil_time<T2>& rhs) noexcept {
  524|       |  return !(lhs == rhs);
  525|       |}
  526|       |
  527|       |////////////////////////////////////////////////////////////////////////
  528|       |
  529|       |enum class weekday {
  530|       |  monday,
  531|       |  tuesday,
  532|       |  wednesday,
  533|       |  thursday,
  534|       |  friday,
  535|       |  saturday,
  536|       |  sunday,
  537|       |};
  538|       |
  539|      0|CONSTEXPR_F weekday get_weekday(const civil_second& cs) noexcept {
  540|      0|  CONSTEXPR_D weekday k_weekday_by_mon_off[13] = {
  541|      0|      weekday::monday,    weekday::tuesday,  weekday::wednesday,
  542|      0|      weekday::thursday,  weekday::friday,   weekday::saturday,
  543|      0|      weekday::sunday,    weekday::monday,   weekday::tuesday,
  544|      0|      weekday::wednesday, weekday::thursday, weekday::friday,
  545|      0|      weekday::saturday,
  546|      0|  };
  547|      0|  CONSTEXPR_D int k_weekday_offsets[1 + 12] = {
  548|      0|      -1, 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4,
  549|      0|  };
  550|      0|  year_t wd = 2400 + (cs.year() % 400) - (cs.month() < 3);
  551|      0|  wd += wd / 4 - wd / 100 + wd / 400;
  552|      0|  wd += k_weekday_offsets[cs.month()] + cs.day();
  553|      0|  return k_weekday_by_mon_off[wd % 7 + 6];
  554|      0|}
  555|       |
  556|       |////////////////////////////////////////////////////////////////////////
  557|       |
  558|      0|CONSTEXPR_F civil_day next_weekday(civil_day cd, weekday wd) noexcept {
  559|      0|  CONSTEXPR_D weekday k_weekdays_forw[14] = {
  560|      0|      weekday::monday,    weekday::tuesday,  weekday::wednesday,
  561|      0|      weekday::thursday,  weekday::friday,   weekday::saturday,
  562|      0|      weekday::sunday,    weekday::monday,   weekday::tuesday,
  563|      0|      weekday::wednesday, weekday::thursday, weekday::friday,
  564|      0|      weekday::saturday,  weekday::sunday,
  565|      0|  };
  566|      0|  weekday base = get_weekday(cd);
  567|      0|  for (int i = 0;; ++i) {
  568|      0|    if (base == k_weekdays_forw[i]) {
  569|      0|      for (int j = i + 1;; ++j) {
  570|      0|        if (wd == k_weekdays_forw[j]) {
  571|      0|          return cd + (j - i);
  572|      0|        }
  573|      0|      }
  574|      0|    }
  575|      0|  }
  576|      0|}
  577|       |
  578|      0|CONSTEXPR_F civil_day prev_weekday(civil_day cd, weekday wd) noexcept {
  579|      0|  CONSTEXPR_D weekday k_weekdays_back[14] = {
  580|      0|      weekday::sunday,   weekday::saturday,  weekday::friday,
  581|      0|      weekday::thursday, weekday::wednesday, weekday::tuesday,
  582|      0|      weekday::monday,   weekday::sunday,    weekday::saturday,
  583|      0|      weekday::friday,   weekday::thursday,  weekday::wednesday,
  584|      0|      weekday::tuesday,  weekday::monday,
  585|      0|  };
  586|      0|  weekday base = get_weekday(cd);
  587|      0|  for (int i = 0;; ++i) {
  588|      0|    if (base == k_weekdays_back[i]) {
  589|      0|      for (int j = i + 1;; ++j) {
  590|      0|        if (wd == k_weekdays_back[j]) {
  591|      0|          return cd - (j - i);
  592|      0|        }
  593|      0|      }
  594|      0|    }
  595|      0|  }
  596|      0|}
  597|       |
  598|      0|CONSTEXPR_F int get_yearday(const civil_second& cs) noexcept {
  599|      0|  CONSTEXPR_D int k_month_offsets[1 + 12] = {
  600|      0|      -1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
  601|      0|  };
  602|      0|  const int feb29 = (cs.month() > 2 && impl::is_leap_year(cs.year()));
  603|      0|  return k_month_offsets[cs.month()] + feb29 + cs.day();
  604|      0|}
  605|       |
  606|       |////////////////////////////////////////////////////////////////////////
  607|       |
  608|       |std::ostream& operator<<(std::ostream& os, const civil_year& y);
  609|       |std::ostream& operator<<(std::ostream& os, const civil_month& m);
  610|       |std::ostream& operator<<(std::ostream& os, const civil_day& d);
  611|       |std::ostream& operator<<(std::ostream& os, const civil_hour& h);
  612|       |std::ostream& operator<<(std::ostream& os, const civil_minute& m);
  613|       |std::ostream& operator<<(std::ostream& os, const civil_second& s);
  614|       |std::ostream& operator<<(std::ostream& os, weekday wd);
  615|       |
  616|       |}  // namespace detail
  617|       |}  // namespace cctz
  618|       |}  // namespace time_internal
  619|       |}  // inline namespace lts_2019_08_08
  620|       |}  // namespace absl
  621|       |
  622|       |#undef CONSTEXPR_M
  623|       |#undef CONSTEXPR_F
  624|       |#undef CONSTEXPR_D
  625|       |
  626|       |#endif  // ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/include/cctz/time_zone.h:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |// A library for translating between absolute times (represented by
   16|       |// std::chrono::time_points of the std::chrono::system_clock) and civil
   17|       |// times (represented by cctz::civil_second) using the rules defined by
   18|       |// a time zone (cctz::time_zone).
   19|       |
   20|       |#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_H_
   21|       |#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_H_
   22|       |
   23|       |#include <chrono>
   24|       |#include <cstdint>
   25|       |#include <string>
   26|       |#include <utility>
   27|       |
   28|       |#include "absl/time/internal/cctz/include/cctz/civil_time.h"
   29|       |
   30|       |namespace absl {
   31|       |inline namespace lts_2019_08_08 {
   32|       |namespace time_internal {
   33|       |namespace cctz {
   34|       |
   35|       |// Convenience aliases. Not intended as public API points.
   36|       |template <typename D>
   37|       |using time_point = std::chrono::time_point<std::chrono::system_clock, D>;
   38|       |using seconds = std::chrono::duration<std::int_fast64_t>;
   39|       |using sys_seconds = seconds;  // Deprecated.  Use cctz::seconds instead.
   40|       |
   41|       |namespace detail {
   42|       |template <typename D>
   43|       |inline std::pair<time_point<seconds>, D>
   44|       |split_seconds(const time_point<D>& tp) {
   45|       |  auto sec = std::chrono::time_point_cast<seconds>(tp);
   46|       |  auto sub = tp - sec;
   47|       |  if (sub.count() < 0) {
   48|       |    sec -= seconds(1);
   49|       |    sub += seconds(1);
   50|       |  }
   51|       |  return {sec, std::chrono::duration_cast<D>(sub)};
   52|       |}
   53|       |inline std::pair<time_point<seconds>, seconds>
   54|      0|split_seconds(const time_point<seconds>& tp) {
   55|      0|  return {tp, seconds::zero()};
   56|      0|}
   57|       |}  // namespace detail
   58|       |
   59|       |// cctz::time_zone is an opaque, small, value-type class representing a
   60|       |// geo-political region within which particular rules are used for mapping
   61|       |// between absolute and civil times. Time zones are named using the TZ
   62|       |// identifiers from the IANA Time Zone Database, such as "America/Los_Angeles"
   63|       |// or "Australia/Sydney". Time zones are created from factory functions such
   64|       |// as load_time_zone(). Note: strings like "PST" and "EDT" are not valid TZ
   65|       |// identifiers.
   66|       |//
   67|       |// Example:
   68|       |//   cctz::time_zone utc = cctz::utc_time_zone();
   69|       |//   cctz::time_zone pst = cctz::fixed_time_zone(std::chrono::hours(-8));
   70|       |//   cctz::time_zone loc = cctz::local_time_zone();
   71|       |//   cctz::time_zone lax;
   72|       |//   if (!cctz::load_time_zone("America/Los_Angeles", &lax)) { ... }
   73|       |//
   74|       |// See also:
   75|       |// - http://www.iana.org/time-zones
   76|       |// - https://en.wikipedia.org/wiki/Zoneinfo
   77|       |class time_zone {
   78|       | public:
   79|      0|  time_zone() : time_zone(nullptr) {}  // Equivalent to UTC
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz9time_zoneC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal4cctz9time_zoneC1Ev
  ------------------
   80|       |  time_zone(const time_zone&) = default;
   81|       |  time_zone& operator=(const time_zone&) = default;
   82|       |
   83|       |  std::string name() const;
   84|       |
   85|       |  // An absolute_lookup represents the civil time (cctz::civil_second) within
   86|       |  // this time_zone at the given absolute time (time_point). There are
   87|       |  // additionally a few other fields that may be useful when working with
   88|       |  // older APIs, such as std::tm.
   89|       |  //
   90|       |  // Example:
   91|       |  //   const cctz::time_zone tz = ...
   92|       |  //   const auto tp = std::chrono::system_clock::now();
   93|       |  //   const cctz::time_zone::absolute_lookup al = tz.lookup(tp);
   94|       |  struct absolute_lookup {
   95|       |    civil_second cs;
   96|       |    // Note: The following fields exist for backward compatibility with older
   97|       |    // APIs. Accessing these fields directly is a sign of imprudent logic in
   98|       |    // the calling code. Modern time-related code should only access this data
   99|       |    // indirectly by way of cctz::format().
  100|       |    int offset;        // civil seconds east of UTC
  101|       |    bool is_dst;       // is offset non-standard?
  102|       |    const char* abbr;  // time-zone abbreviation (e.g., "PST")
  103|       |  };
  104|       |  absolute_lookup lookup(const time_point<seconds>& tp) const;
  105|       |  template <typename D>
  106|       |  absolute_lookup lookup(const time_point<D>& tp) const {
  107|       |    return lookup(detail::split_seconds(tp).first);
  108|       |  }
  109|       |
  110|       |  // A civil_lookup represents the absolute time(s) (time_point) that
  111|       |  // correspond to the given civil time (cctz::civil_second) within this
  112|       |  // time_zone. Usually the given civil time represents a unique instant
  113|       |  // in time, in which case the conversion is unambiguous. However,
  114|       |  // within this time zone, the given civil time may be skipped (e.g.,
  115|       |  // during a positive UTC offset shift), or repeated (e.g., during a
  116|       |  // negative UTC offset shift). To account for these possibilities,
  117|       |  // civil_lookup is richer than just a single time_point.
  118|       |  //
  119|       |  // In all cases the civil_lookup::kind enum will indicate the nature
  120|       |  // of the given civil-time argument, and the pre, trans, and post
  121|       |  // members will give the absolute time answers using the pre-transition
  122|       |  // offset, the transition point itself, and the post-transition offset,
  123|       |  // respectively (all three times are equal if kind == UNIQUE). If any
  124|       |  // of these three absolute times is outside the representable range of a
  125|       |  // time_point<seconds> the field is set to its maximum/minimum value.
  126|       |  //
  127|       |  // Example:
  128|       |  //   cctz::time_zone lax;
  129|       |  //   if (!cctz::load_time_zone("America/Los_Angeles", &lax)) { ... }
  130|       |  //
  131|       |  //   // A unique civil time.
  132|       |  //   auto jan01 = lax.lookup(cctz::civil_second(2011, 1, 1, 0, 0, 0));
  133|       |  //   // jan01.kind == cctz::time_zone::civil_lookup::UNIQUE
  134|       |  //   // jan01.pre    is 2011/01/01 00:00:00 -0800
  135|       |  //   // jan01.trans  is 2011/01/01 00:00:00 -0800
  136|       |  //   // jan01.post   is 2011/01/01 00:00:00 -0800
  137|       |  //
  138|       |  //   // A Spring DST transition, when there is a gap in civil time.
  139|       |  //   auto mar13 = lax.lookup(cctz::civil_second(2011, 3, 13, 2, 15, 0));
  140|       |  //   // mar13.kind == cctz::time_zone::civil_lookup::SKIPPED
  141|       |  //   // mar13.pre   is 2011/03/13 03:15:00 -0700
  142|       |  //   // mar13.trans is 2011/03/13 03:00:00 -0700
  143|       |  //   // mar13.post  is 2011/03/13 01:15:00 -0800
  144|       |  //
  145|       |  //   // A Fall DST transition, when civil times are repeated.
  146|       |  //   auto nov06 = lax.lookup(cctz::civil_second(2011, 11, 6, 1, 15, 0));
  147|       |  //   // nov06.kind == cctz::time_zone::civil_lookup::REPEATED
  148|       |  //   // nov06.pre   is 2011/11/06 01:15:00 -0700
  149|       |  //   // nov06.trans is 2011/11/06 01:00:00 -0800
  150|       |  //   // nov06.post  is 2011/11/06 01:15:00 -0800
  151|       |  struct civil_lookup {
  152|       |    enum civil_kind {
  153|       |      UNIQUE,    // the civil time was singular (pre == trans == post)
  154|       |      SKIPPED,   // the civil time did not exist (pre >= trans > post)
  155|       |      REPEATED,  // the civil time was ambiguous (pre < trans <= post)
  156|       |    } kind;
  157|       |    time_point<seconds> pre;    // uses the pre-transition offset
  158|       |    time_point<seconds> trans;  // instant of civil-offset change
  159|       |    time_point<seconds> post;   // uses the post-transition offset
  160|       |  };
  161|       |  civil_lookup lookup(const civil_second& cs) const;
  162|       |
  163|       |  // Finds the time of the next/previous offset change in this time zone.
  164|       |  //
  165|       |  // By definition, next_transition(tp, &trans) returns false when tp has
  166|       |  // its maximum value, and prev_transition(tp, &trans) returns false
  167|       |  // when tp has its minimum value. If the zone has no transitions, the
  168|       |  // result will also be false no matter what the argument.
  169|       |  //
  170|       |  // Otherwise, when tp has its minimum value, next_transition(tp, &trans)
  171|       |  // returns true and sets trans to the first recorded transition. Chains
  172|       |  // of calls to next_transition()/prev_transition() will eventually return
  173|       |  // false, but it is unspecified exactly when next_transition(tp, &trans)
  174|       |  // jumps to false, or what time is set by prev_transition(tp, &trans) for
  175|       |  // a very distant tp.
  176|       |  //
  177|       |  // Note: Enumeration of time-zone transitions is for informational purposes
  178|       |  // only. Modern time-related code should not care about when offset changes
  179|       |  // occur.
  180|       |  //
  181|       |  // Example:
  182|       |  //   cctz::time_zone nyc;
  183|       |  //   if (!cctz::load_time_zone("America/New_York", &nyc)) { ... }
  184|       |  //   const auto now = std::chrono::system_clock::now();
  185|       |  //   auto tp = cctz::time_point<cctz::seconds>::min();
  186|       |  //   cctz::time_zone::civil_transition trans;
  187|       |  //   while (tp <= now && nyc.next_transition(tp, &trans)) {
  188|       |  //     // transition: trans.from -> trans.to
  189|       |  //     tp = nyc.lookup(trans.to).trans;
  190|       |  //   }
  191|       |  struct civil_transition {
  192|       |    civil_second from;  // the civil time we jump from
  193|       |    civil_second to;    // the civil time we jump to
  194|       |  };
  195|       |  bool next_transition(const time_point<seconds>& tp,
  196|       |                       civil_transition* trans) const;
  197|       |  template <typename D>
  198|       |  bool next_transition(const time_point<D>& tp,
  199|       |                       civil_transition* trans) const {
  200|       |    return next_transition(detail::split_seconds(tp).first, trans);
  201|       |  }
  202|       |  bool prev_transition(const time_point<seconds>& tp,
  203|       |                       civil_transition* trans) const;
  204|       |  template <typename D>
  205|       |  bool prev_transition(const time_point<D>& tp,
  206|       |                       civil_transition* trans) const {
  207|       |    return prev_transition(detail::split_seconds(tp).first, trans);
  208|       |  }
  209|       |
  210|       |  // version() and description() provide additional information about the
  211|       |  // time zone. The content of each of the returned strings is unspecified,
  212|       |  // however, when the IANA Time Zone Database is the underlying data source
  213|       |  // the version() std::string will be in the familar form (e.g, "2018e") or
  214|       |  // empty when unavailable.
  215|       |  //
  216|       |  // Note: These functions are for informational or testing purposes only.
  217|       |  std::string version() const;  // empty when unknown
  218|       |  std::string description() const;
  219|       |
  220|       |  // Relational operators.
  221|      0|  friend bool operator==(time_zone lhs, time_zone rhs) {
  222|      0|    return &lhs.effective_impl() == &rhs.effective_impl();
  223|      0|  }
  224|      0|  friend bool operator!=(time_zone lhs, time_zone rhs) {
  225|      0|    return !(lhs == rhs);
  226|      0|  }
  227|       |
  228|       |  template <typename H>
  229|       |  friend H AbslHashValue(H h, time_zone tz) {
  230|       |    return H::combine(std::move(h), &tz.effective_impl());
  231|       |  }
  232|       |
  233|       |  class Impl;
  234|       |
  235|       | private:
  236|      0|  explicit time_zone(const Impl* impl) : impl_(impl) {}
  237|       |  const Impl& effective_impl() const;  // handles implicit UTC
  238|       |  const Impl* impl_;
  239|       |};
  240|       |
  241|       |// Loads the named time zone. May perform I/O on the initial load.
  242|       |// If the name is invalid, or some other kind of error occurs, returns
  243|       |// false and "*tz" is set to the UTC time zone.
  244|       |bool load_time_zone(const std::string& name, time_zone* tz);
  245|       |
  246|       |// Returns a time_zone representing UTC. Cannot fail.
  247|       |time_zone utc_time_zone();
  248|       |
  249|       |// Returns a time zone that is a fixed offset (seconds east) from UTC.
  250|       |// Note: If the absolute value of the offset is greater than 24 hours
  251|       |// you'll get UTC (i.e., zero offset) instead.
  252|       |time_zone fixed_time_zone(const seconds& offset);
  253|       |
  254|       |// Returns a time zone representing the local time zone. Falls back to UTC.
  255|       |// Note: local_time_zone.name() may only be something like "localtime".
  256|       |time_zone local_time_zone();
  257|       |
  258|       |// Returns the civil time (cctz::civil_second) within the given time zone at
  259|       |// the given absolute time (time_point). Since the additional fields provided
  260|       |// by the time_zone::absolute_lookup struct should rarely be needed in modern
  261|       |// code, this convert() function is simpler and should be preferred.
  262|       |template <typename D>
  263|       |inline civil_second convert(const time_point<D>& tp, const time_zone& tz) {
  264|       |  return tz.lookup(tp).cs;
  265|       |}
  266|       |
  267|       |// Returns the absolute time (time_point) that corresponds to the given civil
  268|       |// time within the given time zone. If the civil time is not unique (i.e., if
  269|       |// it was either repeated or non-existent), then the returned time_point is
  270|       |// the best estimate that preserves relative order. That is, this function
  271|       |// guarantees that if cs1 < cs2, then convert(cs1, tz) <= convert(cs2, tz).
  272|       |inline time_point<seconds> convert(const civil_second& cs,
  273|      0|                                   const time_zone& tz) {
  274|      0|  const time_zone::civil_lookup cl = tz.lookup(cs);
  275|      0|  if (cl.kind == time_zone::civil_lookup::SKIPPED) return cl.trans;
  276|      0|  return cl.pre;
  277|      0|}
  278|       |
  279|       |namespace detail {
  280|       |using femtoseconds = std::chrono::duration<std::int_fast64_t, std::femto>;
  281|       |std::string format(const std::string&, const time_point<seconds>&,
  282|       |                   const femtoseconds&, const time_zone&);
  283|       |bool parse(const std::string&, const std::string&, const time_zone&,
  284|       |           time_point<seconds>*, femtoseconds*, std::string* err = nullptr);
  285|       |}  // namespace detail
  286|       |
  287|       |// Formats the given time_point in the given cctz::time_zone according to
  288|       |// the provided format string. Uses strftime()-like formatting options,
  289|       |// with the following extensions:
  290|       |//
  291|       |//   - %Ez  - RFC3339-compatible numeric UTC offset (+hh:mm or -hh:mm)
  292|       |//   - %E*z - Full-resolution numeric UTC offset (+hh:mm:ss or -hh:mm:ss)
  293|       |//   - %E#S - Seconds with # digits of fractional precision
  294|       |//   - %E*S - Seconds with full fractional precision (a literal '*')
  295|       |//   - %E#f - Fractional seconds with # digits of precision
  296|       |//   - %E*f - Fractional seconds with full precision (a literal '*')
  297|       |//   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)
  298|       |//
  299|       |// Note that %E0S behaves like %S, and %E0f produces no characters. In
  300|       |// contrast %E*f always produces at least one digit, which may be '0'.
  301|       |//
  302|       |// Note that %Y produces as many characters as it takes to fully render the
  303|       |// year. A year outside of [-999:9999] when formatted with %E4Y will produce
  304|       |// more than four characters, just like %Y.
  305|       |//
  306|       |// Tip: Format strings should include the UTC offset (e.g., %z, %Ez, or %E*z)
  307|       |// so that the resulting string uniquely identifies an absolute time.
  308|       |//
  309|       |// Example:
  310|       |//   cctz::time_zone lax;
  311|       |//   if (!cctz::load_time_zone("America/Los_Angeles", &lax)) { ... }
  312|       |//   auto tp = cctz::convert(cctz::civil_second(2013, 1, 2, 3, 4, 5), lax);
  313|       |//   std::string f = cctz::format("%H:%M:%S", tp, lax);  // "03:04:05"
  314|       |//   f = cctz::format("%H:%M:%E3S", tp, lax);            // "03:04:05.000"
  315|       |template <typename D>
  316|       |inline std::string format(const std::string& fmt, const time_point<D>& tp,
  317|       |                          const time_zone& tz) {
  318|       |  const auto p = detail::split_seconds(tp);
  319|       |  const auto n = std::chrono::duration_cast<detail::femtoseconds>(p.second);
  320|       |  return detail::format(fmt, p.first, n, tz);
  321|       |}
  322|       |
  323|       |// Parses an input string according to the provided format string and
  324|       |// returns the corresponding time_point. Uses strftime()-like formatting
  325|       |// options, with the same extensions as cctz::format(), but with the
  326|       |// exceptions that %E#S is interpreted as %E*S, and %E#f as %E*f. %Ez
  327|       |// and %E*z also accept the same inputs.
  328|       |//
  329|       |// %Y consumes as many numeric characters as it can, so the matching data
  330|       |// should always be terminated with a non-numeric. %E4Y always consumes
  331|       |// exactly four characters, including any sign.
  332|       |//
  333|       |// Unspecified fields are taken from the default date and time of ...
  334|       |//
  335|       |//   "1970-01-01 00:00:00.0 +0000"
  336|       |//
  337|       |// For example, parsing a string of "15:45" (%H:%M) will return a time_point
  338|       |// that represents "1970-01-01 15:45:00.0 +0000".
  339|       |//
  340|       |// Note that parse() returns time instants, so it makes most sense to parse
  341|       |// fully-specified date/time strings that include a UTC offset (%z, %Ez, or
  342|       |// %E*z).
  343|       |//
  344|       |// Note also that parse() only heeds the fields year, month, day, hour,
  345|       |// minute, (fractional) second, and UTC offset. Other fields, like weekday (%a
  346|       |// or %A), while parsed for syntactic validity, are ignored in the conversion.
  347|       |//
  348|       |// Date and time fields that are out-of-range will be treated as errors rather
  349|       |// than normalizing them like cctz::civil_second() would do. For example, it
  350|       |// is an error to parse the date "Oct 32, 2013" because 32 is out of range.
  351|       |//
  352|       |// A second of ":60" is normalized to ":00" of the following minute with
  353|       |// fractional seconds discarded. The following table shows how the given
  354|       |// seconds and subseconds will be parsed:
  355|       |//
  356|       |//   "59.x" -> 59.x  // exact
  357|       |//   "60.x" -> 00.0  // normalized
  358|       |//   "00.x" -> 00.x  // exact
  359|       |//
  360|       |// Errors are indicated by returning false.
  361|       |//
  362|       |// Example:
  363|       |//   const cctz::time_zone tz = ...
  364|       |//   std::chrono::system_clock::time_point tp;
  365|       |//   if (cctz::parse("%Y-%m-%d", "2015-10-09", tz, &tp)) {
  366|       |//     ...
  367|       |//   }
  368|       |template <typename D>
  369|       |inline bool parse(const std::string& fmt, const std::string& input,
  370|       |                  const time_zone& tz, time_point<D>* tpp) {
  371|       |  time_point<seconds> sec;
  372|       |  detail::femtoseconds fs;
  373|       |  const bool b = detail::parse(fmt, input, tz, &sec, &fs);
  374|       |  if (b) {
  375|       |    // TODO: Return false if unrepresentable as a time_point<D>.
  376|       |    *tpp = std::chrono::time_point_cast<D>(sec);
  377|       |    *tpp += std::chrono::duration_cast<D>(fs);
  378|       |  }
  379|       |  return b;
  380|       |}
  381|       |
  382|       |}  // namespace cctz
  383|       |}  // namespace time_internal
  384|       |}  // inline namespace lts_2019_08_08
  385|       |}  // namespace absl
  386|       |
  387|       |#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/civil_time_detail.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#include "absl/time/internal/cctz/include/cctz/civil_time_detail.h"
   16|       |
   17|       |#include <iomanip>
   18|       |#include <ostream>
   19|       |#include <sstream>
   20|       |
   21|       |namespace absl {
   22|       |inline namespace lts_2019_08_08 {
   23|       |namespace time_internal {
   24|       |namespace cctz {
   25|       |namespace detail {
   26|       |
   27|       |// Output stream operators output a format matching YYYY-MM-DDThh:mm:ss,
   28|       |// while omitting fields inferior to the type's alignment. For example,
   29|       |// civil_day is formatted only as YYYY-MM-DD.
   30|      0|std::ostream& operator<<(std::ostream& os, const civil_year& y) {
   31|      0|  std::stringstream ss;
   32|      0|  ss << y.year();  // No padding.
   33|      0|  return os << ss.str();
   34|      0|}
   35|      0|std::ostream& operator<<(std::ostream& os, const civil_month& m) {
   36|      0|  std::stringstream ss;
   37|      0|  ss << civil_year(m) << '-';
   38|      0|  ss << std::setfill('0') << std::setw(2) << m.month();
   39|      0|  return os << ss.str();
   40|      0|}
   41|      0|std::ostream& operator<<(std::ostream& os, const civil_day& d) {
   42|      0|  std::stringstream ss;
   43|      0|  ss << civil_month(d) << '-';
   44|      0|  ss << std::setfill('0') << std::setw(2) << d.day();
   45|      0|  return os << ss.str();
   46|      0|}
   47|      0|std::ostream& operator<<(std::ostream& os, const civil_hour& h) {
   48|      0|  std::stringstream ss;
   49|      0|  ss << civil_day(h) << 'T';
   50|      0|  ss << std::setfill('0') << std::setw(2) << h.hour();
   51|      0|  return os << ss.str();
   52|      0|}
   53|      0|std::ostream& operator<<(std::ostream& os, const civil_minute& m) {
   54|      0|  std::stringstream ss;
   55|      0|  ss << civil_hour(m) << ':';
   56|      0|  ss << std::setfill('0') << std::setw(2) << m.minute();
   57|      0|  return os << ss.str();
   58|      0|}
   59|      0|std::ostream& operator<<(std::ostream& os, const civil_second& s) {
   60|      0|  std::stringstream ss;
   61|      0|  ss << civil_minute(s) << ':';
   62|      0|  ss << std::setfill('0') << std::setw(2) << s.second();
   63|      0|  return os << ss.str();
   64|      0|}
   65|       |
   66|       |////////////////////////////////////////////////////////////////////////
   67|       |
   68|      0|std::ostream& operator<<(std::ostream& os, weekday wd) {
   69|      0|  switch (wd) {
   70|      0|    case weekday::monday:
   71|      0|      return os << "Monday";
   72|      0|    case weekday::tuesday:
   73|      0|      return os << "Tuesday";
   74|      0|    case weekday::wednesday:
   75|      0|      return os << "Wednesday";
   76|      0|    case weekday::thursday:
   77|      0|      return os << "Thursday";
   78|      0|    case weekday::friday:
   79|      0|      return os << "Friday";
   80|      0|    case weekday::saturday:
   81|      0|      return os << "Saturday";
   82|      0|    case weekday::sunday:
   83|      0|      return os << "Sunday";
   84|      0|  }
   85|      0|  return os;  // Should never get here, but -Wreturn-type may warn without this.
   86|      0|}
   87|       |
   88|       |}  // namespace detail
   89|       |}  // namespace cctz
   90|       |}  // namespace time_internal
   91|       |}  // inline namespace lts_2019_08_08
   92|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_fixed.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#include "time_zone_fixed.h"
   16|       |
   17|       |#include <algorithm>
   18|       |#include <cassert>
   19|       |#include <chrono>
   20|       |#include <cstring>
   21|       |#include <string>
   22|       |
   23|       |namespace absl {
   24|       |inline namespace lts_2019_08_08 {
   25|       |namespace time_internal {
   26|       |namespace cctz {
   27|       |
   28|       |namespace {
   29|       |
   30|       |// The prefix used for the internal names of fixed-offset zones.
   31|       |const char kFixedZonePrefix[] = "Fixed/UTC";
   32|       |
   33|       |const char kDigits[] = "0123456789";
   34|       |
   35|      0|char* Format02d(char* p, int v) {
   36|      0|  *p++ = kDigits[(v / 10) % 10];
   37|      0|  *p++ = kDigits[v % 10];
   38|      0|  return p;
   39|      0|}
   40|       |
   41|      0|int Parse02d(const char* p) {
   42|      0|  if (const char* ap = std::strchr(kDigits, *p)) {
   43|      0|    int v = static_cast<int>(ap - kDigits);
   44|      0|    if (const char* bp = std::strchr(kDigits, *++p)) {
   45|      0|      return (v * 10) + static_cast<int>(bp - kDigits);
   46|      0|    }
   47|      0|  }
   48|      0|  return -1;
   49|      0|}
   50|       |
   51|       |}  // namespace
   52|       |
   53|      0|bool FixedOffsetFromName(const std::string& name, seconds* offset) {
   54|      0|  if (name.compare(0, std::string::npos, "UTC", 3) == 0) {
   55|      0|    *offset = seconds::zero();
   56|      0|    return true;
   57|      0|  }
   58|      0|
   59|      0|  const std::size_t prefix_len = sizeof(kFixedZonePrefix) - 1;
   60|      0|  const char* const ep = kFixedZonePrefix + prefix_len;
   61|      0|  if (name.size() != prefix_len + 9)  // <prefix>+99:99:99
   62|      0|    return false;
   63|      0|  if (!std::equal(kFixedZonePrefix, ep, name.begin()))
   64|      0|    return false;
   65|      0|  const char* np = name.data() + prefix_len;
   66|      0|  if (np[0] != '+' && np[0] != '-')
   67|      0|    return false;
   68|      0|  if (np[3] != ':' || np[6] != ':')  // see note below about large offsets
   69|      0|    return false;
   70|      0|
   71|      0|  int hours = Parse02d(np + 1);
   72|      0|  if (hours == -1) return false;
   73|      0|  int mins = Parse02d(np + 4);
   74|      0|  if (mins == -1) return false;
   75|      0|  int secs = Parse02d(np + 7);
   76|      0|  if (secs == -1) return false;
   77|      0|
   78|      0|  secs += ((hours * 60) + mins) * 60;
   79|      0|  if (secs > 24 * 60 * 60) return false;  // outside supported offset range
   80|      0|  *offset = seconds(secs * (np[0] == '-' ? -1 : 1));  // "-" means west
   81|      0|  return true;
   82|      0|}
   83|       |
   84|      0|std::string FixedOffsetToName(const seconds& offset) {
   85|      0|  if (offset == seconds::zero()) return "UTC";
   86|      0|  if (offset < std::chrono::hours(-24) || offset > std::chrono::hours(24)) {
   87|      0|    // We don't support fixed-offset zones more than 24 hours
   88|      0|    // away from UTC to avoid complications in rendering such
   89|      0|    // offsets and to (somewhat) limit the total number of zones.
   90|      0|    return "UTC";
   91|      0|  }
   92|      0|  int seconds = static_cast<int>(offset.count());
   93|      0|  const char sign = (seconds < 0 ? '-' : '+');
   94|      0|  int minutes = seconds / 60;
   95|      0|  seconds %= 60;
   96|      0|  if (sign == '-') {
   97|      0|    if (seconds > 0) {
   98|      0|      seconds -= 60;
   99|      0|      minutes += 1;
  100|      0|    }
  101|      0|    seconds = -seconds;
  102|      0|    minutes = -minutes;
  103|      0|  }
  104|      0|  int hours = minutes / 60;
  105|      0|  minutes %= 60;
  106|      0|  const std::size_t prefix_len = sizeof(kFixedZonePrefix) - 1;
  107|      0|  char buf[prefix_len + sizeof("-24:00:00")];
  108|      0|  char* ep = std::copy(kFixedZonePrefix, kFixedZonePrefix + prefix_len, buf);
  109|      0|  *ep++ = sign;
  110|      0|  ep = Format02d(ep, hours);
  111|      0|  *ep++ = ':';
  112|      0|  ep = Format02d(ep, minutes);
  113|      0|  *ep++ = ':';
  114|      0|  ep = Format02d(ep, seconds);
  115|      0|  *ep++ = '\0';
  116|      0|  assert(ep == buf + sizeof(buf));
  117|      0|  return buf;
  118|      0|}
  119|       |
  120|      0|std::string FixedOffsetToAbbr(const seconds& offset) {
  121|      0|  std::string abbr = FixedOffsetToName(offset);
  122|      0|  const std::size_t prefix_len = sizeof(kFixedZonePrefix) - 1;
  123|      0|  if (abbr.size() == prefix_len + 9) {         // <prefix>+99:99:99
  124|      0|    abbr.erase(0, prefix_len);                 // +99:99:99
  125|      0|    abbr.erase(6, 1);                          // +99:9999
  126|      0|    abbr.erase(3, 1);                          // +999999
  127|      0|    if (abbr[5] == '0' && abbr[6] == '0') {    // +999900
  128|      0|      abbr.erase(5, 2);                        // +9999
  129|      0|      if (abbr[3] == '0' && abbr[4] == '0') {  // +9900
  130|      0|        abbr.erase(3, 2);                      // +99
  131|      0|      }
  132|      0|    }
  133|      0|  }
  134|      0|  return abbr;
  135|      0|}
  136|       |
  137|       |}  // namespace cctz
  138|       |}  // namespace time_internal
  139|       |}  // inline namespace lts_2019_08_08
  140|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_format.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#if !defined(HAS_STRPTIME)
   16|       |# if !defined(_MSC_VER) && !defined(__MINGW32__)
   17|       |#  define HAS_STRPTIME 1  // assume everyone has strptime() except windows
   18|       |# endif
   19|       |#endif
   20|       |
   21|       |#if defined(HAS_STRPTIME) && HAS_STRPTIME
   22|       |# if !defined(_XOPEN_SOURCE)
   23|       |#  define _XOPEN_SOURCE  // Definedness suffices for strptime.
   24|       |# endif
   25|       |#endif
   26|       |
   27|       |#include "absl/time/internal/cctz/include/cctz/time_zone.h"
   28|       |
   29|       |// Include time.h directly since, by C++ standards, ctime doesn't have to
   30|       |// declare strptime.
   31|       |#include <time.h>
   32|       |
   33|       |#include <cctype>
   34|       |#include <chrono>
   35|       |#include <cstddef>
   36|       |#include <cstdint>
   37|       |#include <cstring>
   38|       |#include <ctime>
   39|       |#include <limits>
   40|       |#include <string>
   41|       |#include <vector>
   42|       |#if !HAS_STRPTIME
   43|       |#include <iomanip>
   44|       |#include <sstream>
   45|       |#endif
   46|       |
   47|       |#include "absl/time/internal/cctz/include/cctz/civil_time.h"
   48|       |#include "time_zone_if.h"
   49|       |
   50|       |namespace absl {
   51|       |inline namespace lts_2019_08_08 {
   52|       |namespace time_internal {
   53|       |namespace cctz {
   54|       |namespace detail {
   55|       |
   56|       |namespace {
   57|       |
   58|       |#if !HAS_STRPTIME
   59|       |// Build a strptime() using C++11's std::get_time().
   60|       |char* strptime(const char* s, const char* fmt, std::tm* tm) {
   61|       |  std::istringstream input(s);
   62|       |  input >> std::get_time(tm, fmt);
   63|       |  if (input.fail()) return nullptr;
   64|       |  return const_cast<char*>(s) +
   65|       |         (input.eof() ? strlen(s) : static_cast<std::size_t>(input.tellg()));
   66|       |}
   67|       |#endif
   68|       |
   69|      0|std::tm ToTM(const time_zone::absolute_lookup& al) {
   70|      0|  std::tm tm{};
   71|      0|  tm.tm_sec = al.cs.second();
   72|      0|  tm.tm_min = al.cs.minute();
   73|      0|  tm.tm_hour = al.cs.hour();
   74|      0|  tm.tm_mday = al.cs.day();
   75|      0|  tm.tm_mon = al.cs.month() - 1;
   76|      0|
   77|      0|  // Saturate tm.tm_year is cases of over/underflow.
   78|      0|  if (al.cs.year() < std::numeric_limits<int>::min() + 1900) {
   79|      0|    tm.tm_year = std::numeric_limits<int>::min();
   80|      0|  } else if (al.cs.year() - 1900 > std::numeric_limits<int>::max()) {
   81|      0|    tm.tm_year = std::numeric_limits<int>::max();
   82|      0|  } else {
   83|      0|    tm.tm_year = static_cast<int>(al.cs.year() - 1900);
   84|      0|  }
   85|      0|
   86|      0|  switch (get_weekday(al.cs)) {
   87|      0|    case weekday::sunday:
   88|      0|      tm.tm_wday = 0;
   89|      0|      break;
   90|      0|    case weekday::monday:
   91|      0|      tm.tm_wday = 1;
   92|      0|      break;
   93|      0|    case weekday::tuesday:
   94|      0|      tm.tm_wday = 2;
   95|      0|      break;
   96|      0|    case weekday::wednesday:
   97|      0|      tm.tm_wday = 3;
   98|      0|      break;
   99|      0|    case weekday::thursday:
  100|      0|      tm.tm_wday = 4;
  101|      0|      break;
  102|      0|    case weekday::friday:
  103|      0|      tm.tm_wday = 5;
  104|      0|      break;
  105|      0|    case weekday::saturday:
  106|      0|      tm.tm_wday = 6;
  107|      0|      break;
  108|      0|  }
  109|      0|  tm.tm_yday = get_yearday(al.cs) - 1;
  110|      0|  tm.tm_isdst = al.is_dst ? 1 : 0;
  111|      0|  return tm;
  112|      0|}
  113|       |
  114|       |const char kDigits[] = "0123456789";
  115|       |
  116|       |// Formats a 64-bit integer in the given field width.  Note that it is up
  117|       |// to the caller of Format64() [and Format02d()/FormatOffset()] to ensure
  118|       |// that there is sufficient space before ep to hold the conversion.
  119|      0|char* Format64(char* ep, int width, std::int_fast64_t v) {
  120|      0|  bool neg = false;
  121|      0|  if (v < 0) {
  122|      0|    --width;
  123|      0|    neg = true;
  124|      0|    if (v == std::numeric_limits<std::int_fast64_t>::min()) {
  125|      0|      // Avoid negating minimum value.
  126|      0|      std::int_fast64_t last_digit = -(v % 10);
  127|      0|      v /= 10;
  128|      0|      if (last_digit < 0) {
  129|      0|        ++v;
  130|      0|        last_digit += 10;
  131|      0|      }
  132|      0|      --width;
  133|      0|      *--ep = kDigits[last_digit];
  134|      0|    }
  135|      0|    v = -v;
  136|      0|  }
  137|      0|  do {
  138|      0|    --width;
  139|      0|    *--ep = kDigits[v % 10];
  140|      0|  } while (v /= 10);
  141|      0|  while (--width >= 0) *--ep = '0';  // zero pad
  142|      0|  if (neg) *--ep = '-';
  143|      0|  return ep;
  144|      0|}
  145|       |
  146|       |// Formats [0 .. 99] as %02d.
  147|      0|char* Format02d(char* ep, int v) {
  148|      0|  *--ep = kDigits[v % 10];
  149|      0|  *--ep = kDigits[(v / 10) % 10];
  150|      0|  return ep;
  151|      0|}
  152|       |
  153|       |// Formats a UTC offset, like +00:00.
  154|      0|char* FormatOffset(char* ep, int offset, const char* mode) {
  155|      0|  // TODO: Follow the RFC3339 "Unknown Local Offset Convention" and
  156|      0|  // generate a "negative zero" when we're formatting a zero offset
  157|      0|  // as the result of a failed load_time_zone().
  158|      0|  char sign = '+';
  159|      0|  if (offset < 0) {
  160|      0|    offset = -offset;  // bounded by 24h so no overflow
  161|      0|    sign = '-';
  162|      0|  }
  163|      0|  const int seconds = offset % 60;
  164|      0|  const int minutes = (offset /= 60) % 60;
  165|      0|  const int hours = offset /= 60;
  166|      0|  const char sep = mode[0];
  167|      0|  const bool ext = (sep != '\0' && mode[1] == '*');
  168|      0|  const bool ccc = (ext && mode[2] == ':');
  169|      0|  if (ext && (!ccc || seconds != 0)) {
  170|      0|    ep = Format02d(ep, seconds);
  171|      0|    *--ep = sep;
  172|      0|  } else {
  173|      0|    // If we're not rendering seconds, sub-minute negative offsets
  174|      0|    // should get a positive sign (e.g., offset=-10s => "+00:00").
  175|      0|    if (hours == 0 && minutes == 0) sign = '+';
  176|      0|  }
  177|      0|  if (!ccc || minutes != 0 || seconds != 0) {
  178|      0|    ep = Format02d(ep, minutes);
  179|      0|    if (sep != '\0') *--ep = sep;
  180|      0|  }
  181|      0|  ep = Format02d(ep, hours);
  182|      0|  *--ep = sign;
  183|      0|  return ep;
  184|      0|}
  185|       |
  186|       |// Formats a std::tm using strftime(3).
  187|      0|void FormatTM(std::string* out, const std::string& fmt, const std::tm& tm) {
  188|      0|  // strftime(3) returns the number of characters placed in the output
  189|      0|  // array (which may be 0 characters).  It also returns 0 to indicate
  190|      0|  // an error, like the array wasn't large enough.  To accommodate this,
  191|      0|  // the following code grows the buffer size from 2x the format std::string
  192|      0|  // length up to 32x.
  193|      0|  for (std::size_t i = 2; i != 32; i *= 2) {
  194|      0|    std::size_t buf_size = fmt.size() * i;
  195|      0|    std::vector<char> buf(buf_size);
  196|      0|    if (std::size_t len = strftime(&buf[0], buf_size, fmt.c_str(), &tm)) {
  197|      0|      out->append(&buf[0], len);
  198|      0|      return;
  199|      0|    }
  200|      0|  }
  201|      0|}
  202|       |
  203|       |// Used for %E#S/%E#f specifiers and for data values in parse().
  204|       |template <typename T>
  205|      0|const char* ParseInt(const char* dp, int width, T min, T max, T* vp) {
  206|      0|  if (dp != nullptr) {
  207|      0|    const T kmin = std::numeric_limits<T>::min();
  208|      0|    bool erange = false;
  209|      0|    bool neg = false;
  210|      0|    T value = 0;
  211|      0|    if (*dp == '-') {
  212|      0|      neg = true;
  213|      0|      if (width <= 0 || --width != 0) {
  214|      0|        ++dp;
  215|      0|      } else {
  216|      0|        dp = nullptr;  // width was 1
  217|      0|      }
  218|      0|    }
  219|      0|    if (const char* const bp = dp) {
  220|      0|      while (const char* cp = strchr(kDigits, *dp)) {
  221|      0|        int d = static_cast<int>(cp - kDigits);
  222|      0|        if (d >= 10) break;
  223|      0|        if (value < kmin / 10) {
  224|      0|          erange = true;
  225|      0|          break;
  226|      0|        }
  227|      0|        value *= 10;
  228|      0|        if (value < kmin + d) {
  229|      0|          erange = true;
  230|      0|          break;
  231|      0|        }
  232|      0|        value -= d;
  233|      0|        dp += 1;
  234|      0|        if (width > 0 && --width == 0) break;
  235|      0|      }
  236|      0|      if (dp != bp && !erange && (neg || value != kmin)) {
  237|      0|        if (!neg || value != 0) {
  238|      0|          if (!neg) value = -value;  // make positive
  239|      0|          if (min <= value && value <= max) {
  240|      0|            *vp = value;
  241|      0|          } else {
  242|      0|            dp = nullptr;
  243|      0|          }
  244|      0|        } else {
  245|      0|          dp = nullptr;
  246|      0|        }
  247|      0|      } else {
  248|      0|        dp = nullptr;
  249|      0|      }
  250|      0|    }
  251|      0|  }
  252|      0|  return dp;
  253|      0|}
  ------------------
  | Unexecuted instantiation: time_zone_format.cc:_ZN4absl14lts_2019_08_0813time_internal4cctz6detail12_GLOBAL__N_18ParseIntIiEEPKcS7_iT_S8_PS8_
  ------------------
  | Unexecuted instantiation: time_zone_format.cc:_ZN4absl14lts_2019_08_0813time_internal4cctz6detail12_GLOBAL__N_18ParseIntIxEEPKcS7_iT_S8_PS8_
  ------------------
  254|       |
  255|       |// The number of base-10 digits that can be represented by a signed 64-bit
  256|       |// integer.  That is, 10^kDigits10_64 <= 2^63 - 1 < 10^(kDigits10_64 + 1).
  257|       |const int kDigits10_64 = 18;
  258|       |
  259|       |// 10^n for everything that can be represented by a signed 64-bit integer.
  260|       |const std::int_fast64_t kExp10[kDigits10_64 + 1] = {
  261|       |    1,
  262|       |    10,
  263|       |    100,
  264|       |    1000,
  265|       |    10000,
  266|       |    100000,
  267|       |    1000000,
  268|       |    10000000,
  269|       |    100000000,
  270|       |    1000000000,
  271|       |    10000000000,
  272|       |    100000000000,
  273|       |    1000000000000,
  274|       |    10000000000000,
  275|       |    100000000000000,
  276|       |    1000000000000000,
  277|       |    10000000000000000,
  278|       |    100000000000000000,
  279|       |    1000000000000000000,
  280|       |};
  281|       |
  282|       |}  // namespace
  283|       |
  284|       |// Uses strftime(3) to format the given Time.  The following extended format
  285|       |// specifiers are also supported:
  286|       |//
  287|       |//   - %Ez  - RFC3339-compatible numeric UTC offset (+hh:mm or -hh:mm)
  288|       |//   - %E*z - Full-resolution numeric UTC offset (+hh:mm:ss or -hh:mm:ss)
  289|       |//   - %E#S - Seconds with # digits of fractional precision
  290|       |//   - %E*S - Seconds with full fractional precision (a literal '*')
  291|       |//   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)
  292|       |//
  293|       |// The standard specifiers from RFC3339_* (%Y, %m, %d, %H, %M, and %S) are
  294|       |// handled internally for performance reasons.  strftime(3) is slow due to
  295|       |// a POSIX requirement to respect changes to ${TZ}.
  296|       |//
  297|       |// The TZ/GNU %s extension is handled internally because strftime() has
  298|       |// to use mktime() to generate it, and that assumes the local time zone.
  299|       |//
  300|       |// We also handle the %z and %Z specifiers to accommodate platforms that do
  301|       |// not support the tm_gmtoff and tm_zone extensions to std::tm.
  302|       |//
  303|       |// Requires that zero() <= fs < seconds(1).
  304|       |std::string format(const std::string& format, const time_point<seconds>& tp,
  305|      0|                   const detail::femtoseconds& fs, const time_zone& tz) {
  306|      0|  std::string result;
  307|      0|  result.reserve(format.size());  // A reasonable guess for the result size.
  308|      0|  const time_zone::absolute_lookup al = tz.lookup(tp);
  309|      0|  const std::tm tm = ToTM(al);
  310|      0|
  311|      0|  // Scratch buffer for internal conversions.
  312|      0|  char buf[3 + kDigits10_64];  // enough for longest conversion
  313|      0|  char* const ep = buf + sizeof(buf);
  314|      0|  char* bp;  // works back from ep
  315|      0|
  316|      0|  // Maintain three, disjoint subsequences that span format.
  317|      0|  //   [format.begin() ... pending) : already formatted into result
  318|      0|  //   [pending ... cur) : formatting pending, but no special cases
  319|      0|  //   [cur ... format.end()) : unexamined
  320|      0|  // Initially, everything is in the unexamined part.
  321|      0|  const char* pending = format.c_str();  // NUL terminated
  322|      0|  const char* cur = pending;
  323|      0|  const char* end = pending + format.length();
  324|      0|
  325|      0|  while (cur != end) {  // while something is unexamined
  326|      0|    // Moves cur to the next percent sign.
  327|      0|    const char* start = cur;
  328|      0|    while (cur != end && *cur != '%') ++cur;
  329|      0|
  330|      0|    // If the new pending text is all ordinary, copy it out.
  331|      0|    if (cur != start && pending == start) {
  332|      0|      result.append(pending, static_cast<std::size_t>(cur - pending));
  333|      0|      pending = start = cur;
  334|      0|    }
  335|      0|
  336|      0|    // Span the sequential percent signs.
  337|      0|    const char* percent = cur;
  338|      0|    while (cur != end && *cur == '%') ++cur;
  339|      0|
  340|      0|    // If the new pending text is all percents, copy out one
  341|      0|    // percent for every matched pair, then skip those pairs.
  342|      0|    if (cur != start && pending == start) {
  343|      0|      std::size_t escaped = static_cast<std::size_t>(cur - pending) / 2;
  344|      0|      result.append(pending, escaped);
  345|      0|      pending += escaped * 2;
  346|      0|      // Also copy out a single trailing percent.
  347|      0|      if (pending != cur && cur == end) {
  348|      0|        result.push_back(*pending++);
  349|      0|      }
  350|      0|    }
  351|      0|
  352|      0|    // Loop unless we have an unescaped percent.
  353|      0|    if (cur == end || (cur - percent) % 2 == 0) continue;
  354|      0|
  355|      0|    // Simple specifiers that we handle ourselves.
  356|      0|    if (strchr("YmdeHMSzZs%", *cur)) {
  357|      0|      if (cur - 1 != pending) {
  358|      0|        FormatTM(&result, std::string(pending, cur - 1), tm);
  359|      0|      }
  360|      0|      switch (*cur) {
  361|      0|        case 'Y':
  362|      0|          // This avoids the tm.tm_year overflow problem for %Y, however
  363|      0|          // tm.tm_year will still be used by other specifiers like %D.
  364|      0|          bp = Format64(ep, 0, al.cs.year());
  365|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  366|      0|          break;
  367|      0|        case 'm':
  368|      0|          bp = Format02d(ep, al.cs.month());
  369|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  370|      0|          break;
  371|      0|        case 'd':
  372|      0|        case 'e':
  373|      0|          bp = Format02d(ep, al.cs.day());
  374|      0|          if (*cur == 'e' && *bp == '0') *bp = ' ';  // for Windows
  375|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  376|      0|          break;
  377|      0|        case 'H':
  378|      0|          bp = Format02d(ep, al.cs.hour());
  379|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  380|      0|          break;
  381|      0|        case 'M':
  382|      0|          bp = Format02d(ep, al.cs.minute());
  383|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  384|      0|          break;
  385|      0|        case 'S':
  386|      0|          bp = Format02d(ep, al.cs.second());
  387|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  388|      0|          break;
  389|      0|        case 'z':
  390|      0|          bp = FormatOffset(ep, al.offset, "");
  391|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  392|      0|          break;
  393|      0|        case 'Z':
  394|      0|          result.append(al.abbr);
  395|      0|          break;
  396|      0|        case 's':
  397|      0|          bp = Format64(ep, 0, ToUnixSeconds(tp));
  398|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  399|      0|          break;
  400|      0|        case '%':
  401|      0|          result.push_back('%');
  402|      0|          break;
  403|      0|      }
  404|      0|      pending = ++cur;
  405|      0|      continue;
  406|      0|    }
  407|      0|
  408|      0|    // More complex specifiers that we handle ourselves.
  409|      0|    if (*cur == ':' && cur + 1 != end) {
  410|      0|      if (*(cur + 1) == 'z') {
  411|      0|        // Formats %:z.
  412|      0|        if (cur - 1 != pending) {
  413|      0|          FormatTM(&result, std::string(pending, cur - 1), tm);
  414|      0|        }
  415|      0|        bp = FormatOffset(ep, al.offset, ":");
  416|      0|        result.append(bp, static_cast<std::size_t>(ep - bp));
  417|      0|        pending = cur += 2;
  418|      0|        continue;
  419|      0|      }
  420|      0|      if (*(cur + 1) == ':' && cur + 2 != end) {
  421|      0|        if (*(cur + 2) == 'z') {
  422|      0|          // Formats %::z.
  423|      0|          if (cur - 1 != pending) {
  424|      0|            FormatTM(&result, std::string(pending, cur - 1), tm);
  425|      0|          }
  426|      0|          bp = FormatOffset(ep, al.offset, ":*");
  427|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  428|      0|          pending = cur += 3;
  429|      0|          continue;
  430|      0|        }
  431|      0|        if (*(cur + 2) == ':' && cur + 3 != end) {
  432|      0|          if (*(cur + 3) == 'z') {
  433|      0|            // Formats %:::z.
  434|      0|            if (cur - 1 != pending) {
  435|      0|              FormatTM(&result, std::string(pending, cur - 1), tm);
  436|      0|            }
  437|      0|            bp = FormatOffset(ep, al.offset, ":*:");
  438|      0|            result.append(bp, static_cast<std::size_t>(ep - bp));
  439|      0|            pending = cur += 4;
  440|      0|            continue;
  441|      0|          }
  442|      0|        }
  443|      0|      }
  444|      0|    }
  445|      0|
  446|      0|    // Loop if there is no E modifier.
  447|      0|    if (*cur != 'E' || ++cur == end) continue;
  448|      0|
  449|      0|    // Format our extensions.
  450|      0|    if (*cur == 'z') {
  451|      0|      // Formats %Ez.
  452|      0|      if (cur - 2 != pending) {
  453|      0|        FormatTM(&result, std::string(pending, cur - 2), tm);
  454|      0|      }
  455|      0|      bp = FormatOffset(ep, al.offset, ":");
  456|      0|      result.append(bp, static_cast<std::size_t>(ep - bp));
  457|      0|      pending = ++cur;
  458|      0|    } else if (*cur == '*' && cur + 1 != end && *(cur + 1) == 'z') {
  459|      0|      // Formats %E*z.
  460|      0|      if (cur - 2 != pending) {
  461|      0|        FormatTM(&result, std::string(pending, cur - 2), tm);
  462|      0|      }
  463|      0|      bp = FormatOffset(ep, al.offset, ":*");
  464|      0|      result.append(bp, static_cast<std::size_t>(ep - bp));
  465|      0|      pending = cur += 2;
  466|      0|    } else if (*cur == '*' && cur + 1 != end &&
  467|      0|               (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {
  468|      0|      // Formats %E*S or %E*F.
  469|      0|      if (cur - 2 != pending) {
  470|      0|        FormatTM(&result, std::string(pending, cur - 2), tm);
  471|      0|      }
  472|      0|      char* cp = ep;
  473|      0|      bp = Format64(cp, 15, fs.count());
  474|      0|      while (cp != bp && cp[-1] == '0') --cp;
  475|      0|      switch (*(cur + 1)) {
  476|      0|        case 'S':
  477|      0|          if (cp != bp) *--bp = '.';
  478|      0|          bp = Format02d(bp, al.cs.second());
  479|      0|          break;
  480|      0|        case 'f':
  481|      0|          if (cp == bp) *--bp = '0';
  482|      0|          break;
  483|      0|      }
  484|      0|      result.append(bp, static_cast<std::size_t>(cp - bp));
  485|      0|      pending = cur += 2;
  486|      0|    } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {
  487|      0|      // Formats %E4Y.
  488|      0|      if (cur - 2 != pending) {
  489|      0|        FormatTM(&result, std::string(pending, cur - 2), tm);
  490|      0|      }
  491|      0|      bp = Format64(ep, 4, al.cs.year());
  492|      0|      result.append(bp, static_cast<std::size_t>(ep - bp));
  493|      0|      pending = cur += 2;
  494|      0|    } else if (std::isdigit(*cur)) {
  495|      0|      // Possibly found %E#S or %E#f.
  496|      0|      int n = 0;
  497|      0|      if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {
  498|      0|        if (*np == 'S' || *np == 'f') {
  499|      0|          // Formats %E#S or %E#f.
  500|      0|          if (cur - 2 != pending) {
  501|      0|            FormatTM(&result, std::string(pending, cur - 2), tm);
  502|      0|          }
  503|      0|          bp = ep;
  504|      0|          if (n > 0) {
  505|      0|            if (n > kDigits10_64) n = kDigits10_64;
  506|      0|            bp = Format64(bp, n, (n > 15) ? fs.count() * kExp10[n - 15]
  507|      0|                                          : fs.count() / kExp10[15 - n]);
  508|      0|            if (*np == 'S') *--bp = '.';
  509|      0|          }
  510|      0|          if (*np == 'S') bp = Format02d(bp, al.cs.second());
  511|      0|          result.append(bp, static_cast<std::size_t>(ep - bp));
  512|      0|          pending = cur = ++np;
  513|      0|        }
  514|      0|      }
  515|      0|    }
  516|      0|  }
  517|      0|
  518|      0|  // Formats any remaining data.
  519|      0|  if (end != pending) {
  520|      0|    FormatTM(&result, std::string(pending, end), tm);
  521|      0|  }
  522|      0|
  523|      0|  return result;
  524|      0|}
  525|       |
  526|       |namespace {
  527|       |
  528|      0|const char* ParseOffset(const char* dp, const char* mode, int* offset) {
  529|      0|  if (dp != nullptr) {
  530|      0|    const char first = *dp++;
  531|      0|    if (first == '+' || first == '-') {
  532|      0|      char sep = mode[0];
  533|      0|      int hours = 0;
  534|      0|      int minutes = 0;
  535|      0|      int seconds = 0;
  536|      0|      const char* ap = ParseInt(dp, 2, 0, 23, &hours);
  537|      0|      if (ap != nullptr && ap - dp == 2) {
  538|      0|        dp = ap;
  539|      0|        if (sep != '\0' && *ap == sep) ++ap;
  540|      0|        const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
  541|      0|        if (bp != nullptr && bp - ap == 2) {
  542|      0|          dp = bp;
  543|      0|          if (sep != '\0' && *bp == sep) ++bp;
  544|      0|          const char* cp = ParseInt(bp, 2, 0, 59, &seconds);
  545|      0|          if (cp != nullptr && cp - bp == 2) dp = cp;
  546|      0|        }
  547|      0|        *offset = ((hours * 60 + minutes) * 60) + seconds;
  548|      0|        if (first == '-') *offset = -*offset;
  549|      0|      } else {
  550|      0|        dp = nullptr;
  551|      0|      }
  552|      0|    } else if (first == 'Z') {  // Zulu
  553|      0|      *offset = 0;
  554|      0|    } else {
  555|      0|      dp = nullptr;
  556|      0|    }
  557|      0|  }
  558|      0|  return dp;
  559|      0|}
  560|       |
  561|      0|const char* ParseZone(const char* dp, std::string* zone) {
  562|      0|  zone->clear();
  563|      0|  if (dp != nullptr) {
  564|      0|    while (*dp != '\0' && !std::isspace(*dp)) zone->push_back(*dp++);
  565|      0|    if (zone->empty()) dp = nullptr;
  566|      0|  }
  567|      0|  return dp;
  568|      0|}
  569|       |
  570|      0|const char* ParseSubSeconds(const char* dp, detail::femtoseconds* subseconds) {
  571|      0|  if (dp != nullptr) {
  572|      0|    std::int_fast64_t v = 0;
  573|      0|    std::int_fast64_t exp = 0;
  574|      0|    const char* const bp = dp;
  575|      0|    while (const char* cp = strchr(kDigits, *dp)) {
  576|      0|      int d = static_cast<int>(cp - kDigits);
  577|      0|      if (d >= 10) break;
  578|      0|      if (exp < 15) {
  579|      0|        exp += 1;
  580|      0|        v *= 10;
  581|      0|        v += d;
  582|      0|      }
  583|      0|      ++dp;
  584|      0|    }
  585|      0|    if (dp != bp) {
  586|      0|      v *= kExp10[15 - exp];
  587|      0|      *subseconds = detail::femtoseconds(v);
  588|      0|    } else {
  589|      0|      dp = nullptr;
  590|      0|    }
  591|      0|  }
  592|      0|  return dp;
  593|      0|}
  594|       |
  595|       |// Parses a string into a std::tm using strptime(3).
  596|      0|const char* ParseTM(const char* dp, const char* fmt, std::tm* tm) {
  597|      0|  if (dp != nullptr) {
  598|      0|    dp = strptime(dp, fmt, tm);
  599|      0|  }
  600|      0|  return dp;
  601|      0|}
  602|       |
  603|       |}  // namespace
  604|       |
  605|       |// Uses strptime(3) to parse the given input.  Supports the same extended
  606|       |// format specifiers as format(), although %E#S and %E*S are treated
  607|       |// identically (and similarly for %E#f and %E*f).  %Ez and %E*z also accept
  608|       |// the same inputs.
  609|       |//
  610|       |// The standard specifiers from RFC3339_* (%Y, %m, %d, %H, %M, and %S) are
  611|       |// handled internally so that we can normally avoid strptime() altogether
  612|       |// (which is particularly helpful when the native implementation is broken).
  613|       |//
  614|       |// The TZ/GNU %s extension is handled internally because strptime() has to
  615|       |// use localtime_r() to generate it, and that assumes the local time zone.
  616|       |//
  617|       |// We also handle the %z specifier to accommodate platforms that do not
  618|       |// support the tm_gmtoff extension to std::tm.  %Z is parsed but ignored.
  619|       |bool parse(const std::string& format, const std::string& input,
  620|       |           const time_zone& tz, time_point<seconds>* sec,
  621|      0|           detail::femtoseconds* fs, std::string* err) {
  622|      0|  // The unparsed input.
  623|      0|  const char* data = input.c_str();  // NUL terminated
  624|      0|
  625|      0|  // Skips leading whitespace.
  626|      0|  while (std::isspace(*data)) ++data;
  627|      0|
  628|      0|  const year_t kyearmax = std::numeric_limits<year_t>::max();
  629|      0|  const year_t kyearmin = std::numeric_limits<year_t>::min();
  630|      0|
  631|      0|  // Sets default values for unspecified fields.
  632|      0|  bool saw_year = false;
  633|      0|  year_t year = 1970;
  634|      0|  std::tm tm{};
  635|      0|  tm.tm_year = 1970 - 1900;
  636|      0|  tm.tm_mon = 1 - 1;  // Jan
  637|      0|  tm.tm_mday = 1;
  638|      0|  tm.tm_hour = 0;
  639|      0|  tm.tm_min = 0;
  640|      0|  tm.tm_sec = 0;
  641|      0|  tm.tm_wday = 4;  // Thu
  642|      0|  tm.tm_yday = 0;
  643|      0|  tm.tm_isdst = 0;
  644|      0|  auto subseconds = detail::femtoseconds::zero();
  645|      0|  bool saw_offset = false;
  646|      0|  int offset = 0;  // No offset from passed tz.
  647|      0|  std::string zone = "UTC";
  648|      0|
  649|      0|  const char* fmt = format.c_str();  // NUL terminated
  650|      0|  bool twelve_hour = false;
  651|      0|  bool afternoon = false;
  652|      0|
  653|      0|  bool saw_percent_s = false;
  654|      0|  std::int_fast64_t percent_s = 0;
  655|      0|
  656|      0|  // Steps through format, one specifier at a time.
  657|      0|  while (data != nullptr && *fmt != '\0') {
  658|      0|    if (std::isspace(*fmt)) {
  659|      0|      while (std::isspace(*data)) ++data;
  660|      0|      while (std::isspace(*++fmt)) continue;
  661|      0|      continue;
  662|      0|    }
  663|      0|
  664|      0|    if (*fmt != '%') {
  665|      0|      if (*data == *fmt) {
  666|      0|        ++data;
  667|      0|        ++fmt;
  668|      0|      } else {
  669|      0|        data = nullptr;
  670|      0|      }
  671|      0|      continue;
  672|      0|    }
  673|      0|
  674|      0|    const char* percent = fmt;
  675|      0|    if (*++fmt == '\0') {
  676|      0|      data = nullptr;
  677|      0|      continue;
  678|      0|    }
  679|      0|    switch (*fmt++) {
  680|      0|      case 'Y':
  681|      0|        // Symmetrically with FormatTime(), directly handing %Y avoids the
  682|      0|        // tm.tm_year overflow problem.  However, tm.tm_year will still be
  683|      0|        // used by other specifiers like %D.
  684|      0|        data = ParseInt(data, 0, kyearmin, kyearmax, &year);
  685|      0|        if (data != nullptr) saw_year = true;
  686|      0|        continue;
  687|      0|      case 'm':
  688|      0|        data = ParseInt(data, 2, 1, 12, &tm.tm_mon);
  689|      0|        if (data != nullptr) tm.tm_mon -= 1;
  690|      0|        continue;
  691|      0|      case 'd':
  692|      0|      case 'e':
  693|      0|        data = ParseInt(data, 2, 1, 31, &tm.tm_mday);
  694|      0|        continue;
  695|      0|      case 'H':
  696|      0|        data = ParseInt(data, 2, 0, 23, &tm.tm_hour);
  697|      0|        twelve_hour = false;
  698|      0|        continue;
  699|      0|      case 'M':
  700|      0|        data = ParseInt(data, 2, 0, 59, &tm.tm_min);
  701|      0|        continue;
  702|      0|      case 'S':
  703|      0|        data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
  704|      0|        continue;
  705|      0|      case 'I':
  706|      0|      case 'l':
  707|      0|      case 'r':  // probably uses %I
  708|      0|        twelve_hour = true;
  709|      0|        break;
  710|      0|      case 'R':  // uses %H
  711|      0|      case 'T':  // uses %H
  712|      0|      case 'c':  // probably uses %H
  713|      0|      case 'X':  // probably uses %H
  714|      0|        twelve_hour = false;
  715|      0|        break;
  716|      0|      case 'z':
  717|      0|        data = ParseOffset(data, "", &offset);
  718|      0|        if (data != nullptr) saw_offset = true;
  719|      0|        continue;
  720|      0|      case 'Z':  // ignored; zone abbreviations are ambiguous
  721|      0|        data = ParseZone(data, &zone);
  722|      0|        continue;
  723|      0|      case 's':
  724|      0|        data = ParseInt(data, 0,
  725|      0|                        std::numeric_limits<std::int_fast64_t>::min(),
  726|      0|                        std::numeric_limits<std::int_fast64_t>::max(),
  727|      0|                        &percent_s);
  728|      0|        if (data != nullptr) saw_percent_s = true;
  729|      0|        continue;
  730|      0|      case ':':
  731|      0|        if (fmt[0] == 'z' ||
  732|      0|            (fmt[0] == ':' &&
  733|      0|             (fmt[1] == 'z' || (fmt[1] == ':' && fmt[2] == 'z')))) {
  734|      0|          data = ParseOffset(data, ":", &offset);
  735|      0|          if (data != nullptr) saw_offset = true;
  736|      0|          fmt += (fmt[0] == 'z') ? 1 : (fmt[1] == 'z') ? 2 : 3;
  737|      0|          continue;
  738|      0|        }
  739|      0|        break;
  740|      0|      case '%':
  741|      0|        data = (*data == '%' ? data + 1 : nullptr);
  742|      0|        continue;
  743|      0|      case 'E':
  744|      0|        if (fmt[0] == 'z' || (fmt[0] == '*' && fmt[1] == 'z')) {
  745|      0|          data = ParseOffset(data, ":", &offset);
  746|      0|          if (data != nullptr) saw_offset = true;
  747|      0|          fmt += (fmt[0] == 'z') ? 1 : 2;
  748|      0|          continue;
  749|      0|        }
  750|      0|        if (fmt[0] == '*' && fmt[1] == 'S') {
  751|      0|          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
  752|      0|          if (data != nullptr && *data == '.') {
  753|      0|            data = ParseSubSeconds(data + 1, &subseconds);
  754|      0|          }
  755|      0|          fmt += 2;
  756|      0|          continue;
  757|      0|        }
  758|      0|        if (fmt[0] == '*' && fmt[1] == 'f') {
  759|      0|          if (data != nullptr && std::isdigit(*data)) {
  760|      0|            data = ParseSubSeconds(data, &subseconds);
  761|      0|          }
  762|      0|          fmt += 2;
  763|      0|          continue;
  764|      0|        }
  765|      0|        if (fmt[0] == '4' && fmt[1] == 'Y') {
  766|      0|          const char* bp = data;
  767|      0|          data = ParseInt(data, 4, year_t{-999}, year_t{9999}, &year);
  768|      0|          if (data != nullptr) {
  769|      0|            if (data - bp == 4) {
  770|      0|              saw_year = true;
  771|      0|            } else {
  772|      0|              data = nullptr;  // stopped too soon
  773|      0|            }
  774|      0|          }
  775|      0|          fmt += 2;
  776|      0|          continue;
  777|      0|        }
  778|      0|        if (std::isdigit(*fmt)) {
  779|      0|          int n = 0;  // value ignored
  780|      0|          if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {
  781|      0|            if (*np == 'S') {
  782|      0|              data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
  783|      0|              if (data != nullptr && *data == '.') {
  784|      0|                data = ParseSubSeconds(data + 1, &subseconds);
  785|      0|              }
  786|      0|              fmt = ++np;
  787|      0|              continue;
  788|      0|            }
  789|      0|            if (*np == 'f') {
  790|      0|              if (data != nullptr && std::isdigit(*data)) {
  791|      0|                data = ParseSubSeconds(data, &subseconds);
  792|      0|              }
  793|      0|              fmt = ++np;
  794|      0|              continue;
  795|      0|            }
  796|      0|          }
  797|      0|        }
  798|      0|        if (*fmt == 'c') twelve_hour = false;  // probably uses %H
  799|      0|        if (*fmt == 'X') twelve_hour = false;  // probably uses %H
  800|      0|        if (*fmt != '\0') ++fmt;
  801|      0|        break;
  802|      0|      case 'O':
  803|      0|        if (*fmt == 'H') twelve_hour = false;
  804|      0|        if (*fmt == 'I') twelve_hour = true;
  805|      0|        if (*fmt != '\0') ++fmt;
  806|      0|        break;
  807|      0|    }
  808|      0|
  809|      0|    // Parses the current specifier.
  810|      0|    const char* orig_data = data;
  811|      0|    std::string spec(percent, static_cast<std::size_t>(fmt - percent));
  812|      0|    data = ParseTM(data, spec.c_str(), &tm);
  813|      0|
  814|      0|    // If we successfully parsed %p we need to remember whether the result
  815|      0|    // was AM or PM so that we can adjust tm_hour before time_zone::lookup().
  816|      0|    // So reparse the input with a known AM hour, and check if it is shifted
  817|      0|    // to a PM hour.
  818|      0|    if (spec == "%p" && data != nullptr) {
  819|      0|      std::string test_input = "1";
  820|      0|      test_input.append(orig_data, static_cast<std::size_t>(data - orig_data));
  821|      0|      const char* test_data = test_input.c_str();
  822|      0|      std::tm tmp{};
  823|      0|      ParseTM(test_data, "%I%p", &tmp);
  824|      0|      afternoon = (tmp.tm_hour == 13);
  825|      0|    }
  826|      0|  }
  827|      0|
  828|      0|  // Adjust a 12-hour tm_hour value if it should be in the afternoon.
  829|      0|  if (twelve_hour && afternoon && tm.tm_hour < 12) {
  830|      0|    tm.tm_hour += 12;
  831|      0|  }
  832|      0|
  833|      0|  if (data == nullptr) {
  834|      0|    if (err != nullptr) *err = "Failed to parse input";
  835|      0|    return false;
  836|      0|  }
  837|      0|
  838|      0|  // Skip any remaining whitespace.
  839|      0|  while (std::isspace(*data)) ++data;
  840|      0|
  841|      0|  // parse() must consume the entire input std::string.
  842|      0|  if (*data != '\0') {
  843|      0|    if (err != nullptr) *err = "Illegal trailing data in input string";
  844|      0|    return false;
  845|      0|  }
  846|      0|
  847|      0|  // If we saw %s then we ignore anything else and return that time.
  848|      0|  if (saw_percent_s) {
  849|      0|    *sec = FromUnixSeconds(percent_s);
  850|      0|    *fs = detail::femtoseconds::zero();
  851|      0|    return true;
  852|      0|  }
  853|      0|
  854|      0|  // If we saw %z, %Ez, or %E*z then we want to interpret the parsed fields
  855|      0|  // in UTC and then shift by that offset.  Otherwise we want to interpret
  856|      0|  // the fields directly in the passed time_zone.
  857|      0|  time_zone ptz = saw_offset ? utc_time_zone() : tz;
  858|      0|
  859|      0|  // Allows a leap second of 60 to normalize forward to the following ":00".
  860|      0|  if (tm.tm_sec == 60) {
  861|      0|    tm.tm_sec -= 1;
  862|      0|    offset -= 1;
  863|      0|    subseconds = detail::femtoseconds::zero();
  864|      0|  }
  865|      0|
  866|      0|  if (!saw_year) {
  867|      0|    year = year_t{tm.tm_year};
  868|      0|    if (year > kyearmax - 1900) {
  869|      0|      // Platform-dependent, maybe unreachable.
  870|      0|      if (err != nullptr) *err = "Out-of-range year";
  871|      0|      return false;
  872|      0|    }
  873|      0|    year += 1900;
  874|      0|  }
  875|      0|
  876|      0|  const int month = tm.tm_mon + 1;
  877|      0|  civil_second cs(year, month, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
  878|      0|
  879|      0|  // parse() should not allow normalization. Due to the restricted field
  880|      0|  // ranges above (see ParseInt()), the only possibility is for days to roll
  881|      0|  // into months. That is, parsing "Sep 31" should not produce "Oct 1".
  882|      0|  if (cs.month() != month || cs.day() != tm.tm_mday) {
  883|      0|    if (err != nullptr) *err = "Out-of-range field";
  884|      0|    return false;
  885|      0|  }
  886|      0|
  887|      0|  // Accounts for the offset adjustment before converting to absolute time.
  888|      0|  if ((offset < 0 && cs > civil_second::max() + offset) ||
  889|      0|      (offset > 0 && cs < civil_second::min() + offset)) {
  890|      0|    if (err != nullptr) *err = "Out-of-range field";
  891|      0|    return false;
  892|      0|  }
  893|      0|  cs -= offset;
  894|      0|
  895|      0|  const auto tp = ptz.lookup(cs).pre;
  896|      0|  // Checks for overflow/underflow and returns an error as necessary.
  897|      0|  if (tp == time_point<seconds>::max()) {
  898|      0|    const auto al = ptz.lookup(time_point<seconds>::max());
  899|      0|    if (cs > al.cs) {
  900|      0|      if (err != nullptr) *err = "Out-of-range field";
  901|      0|      return false;
  902|      0|    }
  903|      0|  }
  904|      0|  if (tp == time_point<seconds>::min()) {
  905|      0|    const auto al = ptz.lookup(time_point<seconds>::min());
  906|      0|    if (cs < al.cs) {
  907|      0|      if (err != nullptr) *err = "Out-of-range field";
  908|      0|      return false;
  909|      0|    }
  910|      0|  }
  911|      0|
  912|      0|  *sec = tp;
  913|      0|  *fs = subseconds;
  914|      0|  return true;
  915|      0|}
  916|       |
  917|       |}  // namespace detail
  918|       |}  // namespace cctz
  919|       |}  // namespace time_internal
  920|       |}  // inline namespace lts_2019_08_08
  921|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_if.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#include "time_zone_if.h"
   16|       |#include "time_zone_info.h"
   17|       |#include "time_zone_libc.h"
   18|       |
   19|       |namespace absl {
   20|       |inline namespace lts_2019_08_08 {
   21|       |namespace time_internal {
   22|       |namespace cctz {
   23|       |
   24|      0|std::unique_ptr<TimeZoneIf> TimeZoneIf::Load(const std::string& name) {
   25|      0|  // Support "libc:localtime" and "libc:*" to access the legacy
   26|      0|  // localtime and UTC support respectively from the C library.
   27|      0|  if (name.compare(0, 5, "libc:") == 0) {
   28|      0|    return std::unique_ptr<TimeZoneIf>(new TimeZoneLibC(name.substr(5)));
   29|      0|  }
   30|      0|
   31|      0|  // Otherwise use the "zoneinfo" implementation by default.
   32|      0|  std::unique_ptr<TimeZoneInfo> tz(new TimeZoneInfo);
   33|      0|  if (!tz->Load(name)) tz.reset();
   34|      0|  return std::unique_ptr<TimeZoneIf>(tz.release());
   35|      0|}
   36|       |
   37|       |// Defined out-of-line to avoid emitting a weak vtable in all TUs.
   38|      0|TimeZoneIf::~TimeZoneIf() {}
   39|       |
   40|       |}  // namespace cctz
   41|       |}  // namespace time_internal
   42|       |}  // inline namespace lts_2019_08_08
   43|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_if.h:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_
   16|       |#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_
   17|       |
   18|       |#include <chrono>
   19|       |#include <cstdint>
   20|       |#include <memory>
   21|       |#include <string>
   22|       |
   23|       |#include "absl/time/internal/cctz/include/cctz/civil_time.h"
   24|       |#include "absl/time/internal/cctz/include/cctz/time_zone.h"
   25|       |
   26|       |namespace absl {
   27|       |inline namespace lts_2019_08_08 {
   28|       |namespace time_internal {
   29|       |namespace cctz {
   30|       |
   31|       |// A simple interface used to hide time-zone complexities from time_zone::Impl.
   32|       |// Subclasses implement the functions for civil-time conversions in the zone.
   33|       |class TimeZoneIf {
   34|       | public:
   35|       |  // A factory function for TimeZoneIf implementations.
   36|       |  static std::unique_ptr<TimeZoneIf> Load(const std::string& name);
   37|       |
   38|       |  virtual ~TimeZoneIf();
   39|       |
   40|       |  virtual time_zone::absolute_lookup BreakTime(
   41|       |      const time_point<seconds>& tp) const = 0;
   42|       |  virtual time_zone::civil_lookup MakeTime(
   43|       |      const civil_second& cs) const = 0;
   44|       |
   45|       |  virtual bool NextTransition(const time_point<seconds>& tp,
   46|       |                              time_zone::civil_transition* trans) const = 0;
   47|       |  virtual bool PrevTransition(const time_point<seconds>& tp,
   48|       |                              time_zone::civil_transition* trans) const = 0;
   49|       |
   50|       |  virtual std::string Version() const = 0;
   51|       |  virtual std::string Description() const = 0;
   52|       |
   53|       | protected:
   54|      0|  TimeZoneIf() {}
   55|       |};
   56|       |
   57|       |// Convert between time_point<seconds> and a count of seconds since the
   58|       |// Unix epoch.  We assume that the std::chrono::system_clock and the
   59|       |// Unix clock are second aligned, but not that they share an epoch.
   60|      0|inline std::int_fast64_t ToUnixSeconds(const time_point<seconds>& tp) {
   61|      0|  return (tp - std::chrono::time_point_cast<seconds>(
   62|      0|                   std::chrono::system_clock::from_time_t(0))).count();
   63|      0|}
   64|      0|inline time_point<seconds> FromUnixSeconds(std::int_fast64_t t) {
   65|      0|  return std::chrono::time_point_cast<seconds>(
   66|      0|             std::chrono::system_clock::from_time_t(0)) + seconds(t);
   67|      0|}
   68|       |
   69|       |}  // namespace cctz
   70|       |}  // namespace time_internal
   71|       |}  // inline namespace lts_2019_08_08
   72|       |}  // namespace absl
   73|       |
   74|       |#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_impl.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#include "time_zone_impl.h"
   16|       |
   17|       |#include <mutex>
   18|       |#include <string>
   19|       |#include <unordered_map>
   20|       |#include <utility>
   21|       |
   22|       |#include "time_zone_fixed.h"
   23|       |
   24|       |namespace absl {
   25|       |inline namespace lts_2019_08_08 {
   26|       |namespace time_internal {
   27|       |namespace cctz {
   28|       |
   29|       |namespace {
   30|       |
   31|       |// time_zone::Impls are linked into a map to support fast lookup by name.
   32|       |using TimeZoneImplByName =
   33|       |    std::unordered_map<std::string, const time_zone::Impl*>;
   34|       |TimeZoneImplByName* time_zone_map = nullptr;
   35|       |
   36|       |// Mutual exclusion for time_zone_map.
   37|       |std::mutex time_zone_mutex;
   38|       |
   39|       |}  // namespace
   40|       |
   41|      0|time_zone time_zone::Impl::UTC() {
   42|      0|  return time_zone(UTCImpl());
   43|      0|}
   44|       |
   45|      0|bool time_zone::Impl::LoadTimeZone(const std::string& name, time_zone* tz) {
   46|      0|  const time_zone::Impl* const utc_impl = UTCImpl();
   47|      0|
   48|      0|  // First check for UTC (which is never a key in time_zone_map).
   49|      0|  auto offset = seconds::zero();
   50|      0|  if (FixedOffsetFromName(name, &offset) && offset == seconds::zero()) {
   51|      0|    *tz = time_zone(utc_impl);
   52|      0|    return true;
   53|      0|  }
   54|      0|
   55|      0|  // Then check, under a shared lock, whether the time zone has already
   56|      0|  // been loaded. This is the common path. TODO: Move to shared_mutex.
   57|      0|  {
   58|      0|    std::lock_guard<std::mutex> lock(time_zone_mutex);
   59|      0|    if (time_zone_map != nullptr) {
   60|      0|      TimeZoneImplByName::const_iterator itr = time_zone_map->find(name);
   61|      0|      if (itr != time_zone_map->end()) {
   62|      0|        *tz = time_zone(itr->second);
   63|      0|        return itr->second != utc_impl;
   64|      0|      }
   65|      0|    }
   66|      0|  }
   67|      0|
   68|      0|  // Now check again, under an exclusive lock.
   69|      0|  std::lock_guard<std::mutex> lock(time_zone_mutex);
   70|      0|  if (time_zone_map == nullptr) time_zone_map = new TimeZoneImplByName;
   71|      0|  const Impl*& impl = (*time_zone_map)[name];
   72|      0|  if (impl == nullptr) {
   73|      0|    // The first thread in loads the new time zone.
   74|      0|    Impl* new_impl = new Impl(name);
   75|      0|    new_impl->zone_ = TimeZoneIf::Load(new_impl->name_);
   76|      0|    if (new_impl->zone_ == nullptr) {
   77|      0|      delete new_impl;  // free the nascent Impl
   78|      0|      impl = utc_impl;  // and fallback to UTC
   79|      0|    } else {
   80|      0|      impl = new_impl;  // install new time zone
   81|      0|    }
   82|      0|  }
   83|      0|  *tz = time_zone(impl);
   84|      0|  return impl != utc_impl;
   85|      0|}
   86|       |
   87|      0|void time_zone::Impl::ClearTimeZoneMapTestOnly() {
   88|      0|  std::lock_guard<std::mutex> lock(time_zone_mutex);
   89|      0|  if (time_zone_map != nullptr) {
   90|      0|    // Existing time_zone::Impl* entries are in the wild, so we simply
   91|      0|    // leak them.  Future requests will result in reloading the data.
   92|      0|    time_zone_map->clear();
   93|      0|  }
   94|      0|}
   95|       |
   96|      0|time_zone::Impl::Impl(const std::string& name) : name_(name) {}
   97|       |
   98|      0|const time_zone::Impl* time_zone::Impl::UTCImpl() {
   99|      0|  static Impl* utc_impl = [] {
  100|      0|    Impl* impl = new Impl("UTC");
  101|      0|    impl->zone_ = TimeZoneIf::Load(impl->name_);  // never fails
  102|      0|    return impl;
  103|      0|  }();
  104|      0|  return utc_impl;
  105|      0|}
  106|       |
  107|       |}  // namespace cctz
  108|       |}  // namespace time_internal
  109|       |}  // inline namespace lts_2019_08_08
  110|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_impl.h:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IMPL_H_
   16|       |#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IMPL_H_
   17|       |
   18|       |#include <memory>
   19|       |#include <string>
   20|       |
   21|       |#include "absl/time/internal/cctz/include/cctz/civil_time.h"
   22|       |#include "absl/time/internal/cctz/include/cctz/time_zone.h"
   23|       |#include "time_zone_if.h"
   24|       |#include "time_zone_info.h"
   25|       |
   26|       |namespace absl {
   27|       |inline namespace lts_2019_08_08 {
   28|       |namespace time_internal {
   29|       |namespace cctz {
   30|       |
   31|       |// time_zone::Impl is the internal object referenced by a cctz::time_zone.
   32|       |class time_zone::Impl {
   33|       | public:
   34|       |  // The UTC time zone. Also used for other time zones that fail to load.
   35|       |  static time_zone UTC();
   36|       |
   37|       |  // Load a named time zone. Returns false if the name is invalid, or if
   38|       |  // some other kind of error occurs. Note that loading "UTC" never fails.
   39|       |  static bool LoadTimeZone(const std::string& name, time_zone* tz);
   40|       |
   41|       |  // Clears the map of cached time zones.  Primarily for use in benchmarks
   42|       |  // that gauge the performance of loading/parsing the time-zone data.
   43|       |  static void ClearTimeZoneMapTestOnly();
   44|       |
   45|       |  // The primary key is the time-zone ID (e.g., "America/New_York").
   46|      0|  const std::string& Name() const {
   47|      0|    // TODO: It would nice if the zoneinfo data included the zone name.
   48|      0|    return name_;
   49|      0|  }
   50|       |
   51|       |  // Breaks a time_point down to civil-time components in this time zone.
   52|      0|  time_zone::absolute_lookup BreakTime(const time_point<seconds>& tp) const {
   53|      0|    return zone_->BreakTime(tp);
   54|      0|  }
   55|       |
   56|       |  // Converts the civil-time components in this time zone into a time_point.
   57|       |  // That is, the opposite of BreakTime(). The requested civil time may be
   58|       |  // ambiguous or illegal due to a change of UTC offset.
   59|      0|  time_zone::civil_lookup MakeTime(const civil_second& cs) const {
   60|      0|    return zone_->MakeTime(cs);
   61|      0|  }
   62|       |
   63|       |  // Finds the time of the next/previous offset change in this time zone.
   64|       |  bool NextTransition(const time_point<seconds>& tp,
   65|      0|                      time_zone::civil_transition* trans) const {
   66|      0|    return zone_->NextTransition(tp, trans);
   67|      0|  }
   68|       |  bool PrevTransition(const time_point<seconds>& tp,
   69|      0|                      time_zone::civil_transition* trans) const {
   70|      0|    return zone_->PrevTransition(tp, trans);
   71|      0|  }
   72|       |
   73|       |  // Returns an implementation-defined version std::string for this time zone.
   74|      0|  std::string Version() const { return zone_->Version(); }
   75|       |
   76|       |  // Returns an implementation-defined description of this time zone.
   77|      0|  std::string Description() const { return zone_->Description(); }
   78|       |
   79|       | private:
   80|       |  explicit Impl(const std::string& name);
   81|       |  static const Impl* UTCImpl();
   82|       |
   83|       |  const std::string name_;
   84|       |  std::unique_ptr<TimeZoneIf> zone_;
   85|       |};
   86|       |
   87|       |}  // namespace cctz
   88|       |}  // namespace time_internal
   89|       |}  // inline namespace lts_2019_08_08
   90|       |}  // namespace absl
   91|       |
   92|       |#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IMPL_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_info.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |// This file implements the TimeZoneIf interface using the "zoneinfo"
   16|       |// data provided by the IANA Time Zone Database (i.e., the only real game
   17|       |// in town).
   18|       |//
   19|       |// TimeZoneInfo represents the history of UTC-offset changes within a time
   20|       |// zone. Most changes are due to daylight-saving rules, but occasionally
   21|       |// shifts are made to the time-zone's base offset. The database only attempts
   22|       |// to be definitive for times since 1970, so be wary of local-time conversions
   23|       |// before that. Also, rule and zone-boundary changes are made at the whim
   24|       |// of governments, so the conversion of future times needs to be taken with
   25|       |// a grain of salt.
   26|       |//
   27|       |// For more information see tzfile(5), http://www.iana.org/time-zones, or
   28|       |// https://en.wikipedia.org/wiki/Zoneinfo.
   29|       |//
   30|       |// Note that we assume the proleptic Gregorian calendar and 60-second
   31|       |// minutes throughout.
   32|       |
   33|       |#include "time_zone_info.h"
   34|       |
   35|       |#include <algorithm>
   36|       |#include <cassert>
   37|       |#include <chrono>
   38|       |#include <cstdint>
   39|       |#include <cstdio>
   40|       |#include <cstdlib>
   41|       |#include <cstring>
   42|       |#include <functional>
   43|       |#include <iostream>
   44|       |#include <memory>
   45|       |#include <sstream>
   46|       |#include <string>
   47|       |
   48|       |#include "absl/time/internal/cctz/include/cctz/civil_time.h"
   49|       |#include "time_zone_fixed.h"
   50|       |#include "time_zone_posix.h"
   51|       |
   52|       |namespace absl {
   53|       |inline namespace lts_2019_08_08 {
   54|       |namespace time_internal {
   55|       |namespace cctz {
   56|       |
   57|       |namespace {
   58|       |
   59|      0|inline bool IsLeap(year_t year) {
   60|      0|  return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0);
   61|      0|}
   62|       |
   63|       |// The number of days in non-leap and leap years respectively.
   64|       |const std::int_least32_t kDaysPerYear[2] = {365, 366};
   65|       |
   66|       |// The day offsets of the beginning of each (1-based) month in non-leap and
   67|       |// leap years respectively (e.g., 335 days before December in a leap year).
   68|       |const std::int_least16_t kMonthOffsets[2][1 + 12 + 1] = {
   69|       |  {-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
   70|       |  {-1, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366},
   71|       |};
   72|       |
   73|       |// We reject leap-second encoded zoneinfo and so assume 60-second minutes.
   74|       |const std::int_least32_t kSecsPerDay = 24 * 60 * 60;
   75|       |
   76|       |// 400-year chunks always have 146097 days (20871 weeks).
   77|       |const std::int_least64_t kSecsPer400Years = 146097LL * kSecsPerDay;
   78|       |
   79|       |// Like kDaysPerYear[] but scaled up by a factor of kSecsPerDay.
   80|       |const std::int_least32_t kSecsPerYear[2] = {
   81|       |  365 * kSecsPerDay,
   82|       |  366 * kSecsPerDay,
   83|       |};
   84|       |
   85|       |// Single-byte, unsigned numeric values are encoded directly.
   86|      0|inline std::uint_fast8_t Decode8(const char* cp) {
   87|      0|  return static_cast<std::uint_fast8_t>(*cp) & 0xff;
   88|      0|}
   89|       |
   90|       |// Multi-byte, numeric values are encoded using a MSB first,
   91|       |// twos-complement representation. These helpers decode, from
   92|       |// the given address, 4-byte and 8-byte values respectively.
   93|       |// Note: If int_fastXX_t == intXX_t and this machine is not
   94|       |// twos complement, then there will be at least one input value
   95|       |// we cannot represent.
   96|      0|std::int_fast32_t Decode32(const char* cp) {
   97|      0|  std::uint_fast32_t v = 0;
   98|      0|  for (int i = 0; i != (32 / 8); ++i) v = (v << 8) | Decode8(cp++);
   99|      0|  const std::int_fast32_t s32max = 0x7fffffff;
  100|      0|  const auto s32maxU = static_cast<std::uint_fast32_t>(s32max);
  101|      0|  if (v <= s32maxU) return static_cast<std::int_fast32_t>(v);
  102|      0|  return static_cast<std::int_fast32_t>(v - s32maxU - 1) - s32max - 1;
  103|      0|}
  104|       |
  105|      0|std::int_fast64_t Decode64(const char* cp) {
  106|      0|  std::uint_fast64_t v = 0;
  107|      0|  for (int i = 0; i != (64 / 8); ++i) v = (v << 8) | Decode8(cp++);
  108|      0|  const std::int_fast64_t s64max = 0x7fffffffffffffff;
  109|      0|  const auto s64maxU = static_cast<std::uint_fast64_t>(s64max);
  110|      0|  if (v <= s64maxU) return static_cast<std::int_fast64_t>(v);
  111|      0|  return static_cast<std::int_fast64_t>(v - s64maxU - 1) - s64max - 1;
  112|      0|}
  113|       |
  114|       |// Generate a year-relative offset for a PosixTransition.
  115|       |std::int_fast64_t TransOffset(bool leap_year, int jan1_weekday,
  116|      0|                              const PosixTransition& pt) {
  117|      0|  std::int_fast64_t days = 0;
  118|      0|  switch (pt.date.fmt) {
  119|      0|    case PosixTransition::J: {
  120|      0|      days = pt.date.j.day;
  121|      0|      if (!leap_year || days < kMonthOffsets[1][3]) days -= 1;
  122|      0|      break;
  123|      0|    }
  124|      0|    case PosixTransition::N: {
  125|      0|      days = pt.date.n.day;
  126|      0|      break;
  127|      0|    }
  128|      0|    case PosixTransition::M: {
  129|      0|      const bool last_week = (pt.date.m.week == 5);
  130|      0|      days = kMonthOffsets[leap_year][pt.date.m.month + last_week];
  131|      0|      const std::int_fast64_t weekday = (jan1_weekday + days) % 7;
  132|      0|      if (last_week) {
  133|      0|        days -= (weekday + 7 - 1 - pt.date.m.weekday) % 7 + 1;
  134|      0|      } else {
  135|      0|        days += (pt.date.m.weekday + 7 - weekday) % 7;
  136|      0|        days += (pt.date.m.week - 1) * 7;
  137|      0|      }
  138|      0|      break;
  139|      0|    }
  140|      0|  }
  141|      0|  return (days * kSecsPerDay) + pt.time.offset;
  142|      0|}
  143|       |
  144|      0|inline time_zone::civil_lookup MakeUnique(const time_point<seconds>& tp) {
  145|      0|  time_zone::civil_lookup cl;
  146|      0|  cl.kind = time_zone::civil_lookup::UNIQUE;
  147|      0|  cl.pre = cl.trans = cl.post = tp;
  148|      0|  return cl;
  149|      0|}
  150|       |
  151|      0|inline time_zone::civil_lookup MakeUnique(std::int_fast64_t unix_time) {
  152|      0|  return MakeUnique(FromUnixSeconds(unix_time));
  153|      0|}
  154|       |
  155|       |inline time_zone::civil_lookup MakeSkipped(const Transition& tr,
  156|      0|                                           const civil_second& cs) {
  157|      0|  time_zone::civil_lookup cl;
  158|      0|  cl.kind = time_zone::civil_lookup::SKIPPED;
  159|      0|  cl.pre = FromUnixSeconds(tr.unix_time - 1 + (cs - tr.prev_civil_sec));
  160|      0|  cl.trans = FromUnixSeconds(tr.unix_time);
  161|      0|  cl.post = FromUnixSeconds(tr.unix_time - (tr.civil_sec - cs));
  162|      0|  return cl;
  163|      0|}
  164|       |
  165|       |inline time_zone::civil_lookup MakeRepeated(const Transition& tr,
  166|      0|                                            const civil_second& cs) {
  167|      0|  time_zone::civil_lookup cl;
  168|      0|  cl.kind = time_zone::civil_lookup::REPEATED;
  169|      0|  cl.pre = FromUnixSeconds(tr.unix_time - 1 - (tr.prev_civil_sec - cs));
  170|      0|  cl.trans = FromUnixSeconds(tr.unix_time);
  171|      0|  cl.post = FromUnixSeconds(tr.unix_time + (cs - tr.civil_sec));
  172|      0|  return cl;
  173|      0|}
  174|       |
  175|      0|inline civil_second YearShift(const civil_second& cs, year_t shift) {
  176|      0|  return civil_second(cs.year() + shift, cs.month(), cs.day(),
  177|      0|                      cs.hour(), cs.minute(), cs.second());
  178|      0|}
  179|       |
  180|       |}  // namespace
  181|       |
  182|       |// What (no leap-seconds) UTC+seconds zoneinfo would look like.
  183|      0|bool TimeZoneInfo::ResetToBuiltinUTC(const seconds& offset) {
  184|      0|  transition_types_.resize(1);
  185|      0|  TransitionType& tt(transition_types_.back());
  186|      0|  tt.utc_offset = static_cast<std::int_least32_t>(offset.count());
  187|      0|  tt.is_dst = false;
  188|      0|  tt.abbr_index = 0;
  189|      0|
  190|      0|  // We temporarily add some redundant, contemporary (2013 through 2023)
  191|      0|  // transitions for performance reasons.  See TimeZoneInfo::LocalTime().
  192|      0|  // TODO: Fix the performance issue and remove the extra transitions.
  193|      0|  transitions_.clear();
  194|      0|  transitions_.reserve(12);
  195|      0|  for (const std::int_fast64_t unix_time : {
  196|      0|           -(1LL << 59),  // BIG_BANG
  197|      0|           1356998400LL,  // 2013-01-01T00:00:00+00:00
  198|      0|           1388534400LL,  // 2014-01-01T00:00:00+00:00
  199|      0|           1420070400LL,  // 2015-01-01T00:00:00+00:00
  200|      0|           1451606400LL,  // 2016-01-01T00:00:00+00:00
  201|      0|           1483228800LL,  // 2017-01-01T00:00:00+00:00
  202|      0|           1514764800LL,  // 2018-01-01T00:00:00+00:00
  203|      0|           1546300800LL,  // 2019-01-01T00:00:00+00:00
  204|      0|           1577836800LL,  // 2020-01-01T00:00:00+00:00
  205|      0|           1609459200LL,  // 2021-01-01T00:00:00+00:00
  206|      0|           1640995200LL,  // 2022-01-01T00:00:00+00:00
  207|      0|           1672531200LL,  // 2023-01-01T00:00:00+00:00
  208|      0|           2147483647LL,  // 2^31 - 1
  209|      0|       }) {
  210|      0|    Transition& tr(*transitions_.emplace(transitions_.end()));
  211|      0|    tr.unix_time = unix_time;
  212|      0|    tr.type_index = 0;
  213|      0|    tr.civil_sec = LocalTime(tr.unix_time, tt).cs;
  214|      0|    tr.prev_civil_sec = tr.civil_sec - 1;
  215|      0|  }
  216|      0|
  217|      0|  default_transition_type_ = 0;
  218|      0|  abbreviations_ = FixedOffsetToAbbr(offset);
  219|      0|  abbreviations_.append(1, '\0');  // add NUL
  220|      0|  future_spec_.clear();  // never needed for a fixed-offset zone
  221|      0|  extended_ = false;
  222|      0|
  223|      0|  tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
  224|      0|  tt.civil_min = LocalTime(seconds::min().count(), tt).cs;
  225|      0|
  226|      0|  transitions_.shrink_to_fit();
  227|      0|  return true;
  228|      0|}
  229|       |
  230|       |// Builds the in-memory header using the raw bytes from the file.
  231|      0|bool TimeZoneInfo::Header::Build(const tzhead& tzh) {
  232|      0|  std::int_fast32_t v;
  233|      0|  if ((v = Decode32(tzh.tzh_timecnt)) < 0) return false;
  234|      0|  timecnt = static_cast<std::size_t>(v);
  235|      0|  if ((v = Decode32(tzh.tzh_typecnt)) < 0) return false;
  236|      0|  typecnt = static_cast<std::size_t>(v);
  237|      0|  if ((v = Decode32(tzh.tzh_charcnt)) < 0) return false;
  238|      0|  charcnt = static_cast<std::size_t>(v);
  239|      0|  if ((v = Decode32(tzh.tzh_leapcnt)) < 0) return false;
  240|      0|  leapcnt = static_cast<std::size_t>(v);
  241|      0|  if ((v = Decode32(tzh.tzh_ttisstdcnt)) < 0) return false;
  242|      0|  ttisstdcnt = static_cast<std::size_t>(v);
  243|      0|  if ((v = Decode32(tzh.tzh_ttisutcnt)) < 0) return false;
  244|      0|  ttisutcnt = static_cast<std::size_t>(v);
  245|      0|  return true;
  246|      0|}
  247|       |
  248|       |// How many bytes of data are associated with this header. The result
  249|       |// depends upon whether this is a section with 4-byte or 8-byte times.
  250|      0|std::size_t TimeZoneInfo::Header::DataLength(std::size_t time_len) const {
  251|      0|  std::size_t len = 0;
  252|      0|  len += (time_len + 1) * timecnt;  // unix_time + type_index
  253|      0|  len += (4 + 1 + 1) * typecnt;     // utc_offset + is_dst + abbr_index
  254|      0|  len += 1 * charcnt;               // abbreviations
  255|      0|  len += (time_len + 4) * leapcnt;  // leap-time + TAI-UTC
  256|      0|  len += 1 * ttisstdcnt;            // UTC/local indicators
  257|      0|  len += 1 * ttisutcnt;             // standard/wall indicators
  258|      0|  return len;
  259|      0|}
  260|       |
  261|       |// Check that the TransitionType has the expected offset/is_dst/abbreviation.
  262|       |void TimeZoneInfo::CheckTransition(const std::string& name,
  263|       |                                   const TransitionType& tt,
  264|       |                                   std::int_fast32_t offset, bool is_dst,
  265|      0|                                   const std::string& abbr) const {
  266|      0|  if (tt.utc_offset != offset || tt.is_dst != is_dst ||
  267|      0|      &abbreviations_[tt.abbr_index] != abbr) {
  268|      0|    std::clog << name << ": Transition"
  269|      0|              << " offset=" << tt.utc_offset << "/"
  270|      0|              << (tt.is_dst ? "DST" : "STD")
  271|      0|              << "/abbr=" << &abbreviations_[tt.abbr_index]
  272|      0|              << " does not match POSIX spec '" << future_spec_ << "'\n";
  273|      0|  }
  274|      0|}
  275|       |
  276|       |// zic(8) can generate no-op transitions when a zone changes rules at an
  277|       |// instant when there is actually no discontinuity.  So we check whether
  278|       |// two transitions have equivalent types (same offset/is_dst/abbr).
  279|       |bool TimeZoneInfo::EquivTransitions(std::uint_fast8_t tt1_index,
  280|      0|                                    std::uint_fast8_t tt2_index) const {
  281|      0|  if (tt1_index == tt2_index) return true;
  282|      0|  const TransitionType& tt1(transition_types_[tt1_index]);
  283|      0|  const TransitionType& tt2(transition_types_[tt2_index]);
  284|      0|  if (tt1.is_dst != tt2.is_dst) return false;
  285|      0|  if (tt1.utc_offset != tt2.utc_offset) return false;
  286|      0|  if (tt1.abbr_index != tt2.abbr_index) return false;
  287|      0|  return true;
  288|      0|}
  289|       |
  290|       |// Use the POSIX-TZ-environment-variable-style string to handle times
  291|       |// in years after the last transition stored in the zoneinfo data.
  292|       |void TimeZoneInfo::ExtendTransitions(const std::string& name,
  293|      0|                                     const Header& hdr) {
  294|      0|  extended_ = false;
  295|      0|  bool extending = !future_spec_.empty();
  296|      0|
  297|      0|  PosixTimeZone posix;
  298|      0|  if (extending && !ParsePosixSpec(future_spec_, &posix)) {
  299|      0|    std::clog << name << ": Failed to parse '" << future_spec_ << "'\n";
  300|      0|    extending = false;
  301|      0|  }
  302|      0|
  303|      0|  if (extending && posix.dst_abbr.empty()) {  // std only
  304|      0|    // The future specification should match the last/default transition,
  305|      0|    // and that means that handling the future will fall out naturally.
  306|      0|    std::uint_fast8_t index = default_transition_type_;
  307|      0|    if (hdr.timecnt != 0) index = transitions_[hdr.timecnt - 1].type_index;
  308|      0|    const TransitionType& tt(transition_types_[index]);
  309|      0|    CheckTransition(name, tt, posix.std_offset, false, posix.std_abbr);
  310|      0|    extending = false;
  311|      0|  }
  312|      0|
  313|      0|  if (extending && hdr.timecnt < 2) {
  314|      0|    std::clog << name << ": Too few transitions for POSIX spec\n";
  315|      0|    extending = false;
  316|      0|  }
  317|      0|
  318|      0|  if (!extending) {
  319|      0|    // Ensure that there is always a transition in the second half of the
  320|      0|    // time line (the BIG_BANG transition is in the first half) so that the
  321|      0|    // signed difference between a civil_second and the civil_second of its
  322|      0|    // previous transition is always representable, without overflow.
  323|      0|    const Transition& last(transitions_.back());
  324|      0|    if (last.unix_time < 0) {
  325|      0|      const std::uint_fast8_t type_index = last.type_index;
  326|      0|      Transition& tr(*transitions_.emplace(transitions_.end()));
  327|      0|      tr.unix_time = 2147483647;  // 2038-01-19T03:14:07+00:00
  328|      0|      tr.type_index = type_index;
  329|      0|    }
  330|      0|    return;  // last transition wins
  331|      0|  }
  332|      0|
  333|      0|  // Extend the transitions for an additional 400 years using the
  334|      0|  // future specification. Years beyond those can be handled by
  335|      0|  // mapping back to a cycle-equivalent year within that range.
  336|      0|  // zic(8) should probably do this so that we don't have to.
  337|      0|  // TODO: Reduce the extension by the number of compatible
  338|      0|  // transitions already in place.
  339|      0|  transitions_.reserve(hdr.timecnt + 400 * 2 + 1);
  340|      0|  transitions_.resize(hdr.timecnt + 400 * 2);
  341|      0|  extended_ = true;
  342|      0|
  343|      0|  // The future specification should match the last two transitions,
  344|      0|  // and those transitions should have different is_dst flags.  Note
  345|      0|  // that nothing says the UTC offset used by the is_dst transition
  346|      0|  // must be greater than that used by the !is_dst transition.  (See
  347|      0|  // Europe/Dublin, for example.)
  348|      0|  const Transition* tr0 = &transitions_[hdr.timecnt - 1];
  349|      0|  const Transition* tr1 = &transitions_[hdr.timecnt - 2];
  350|      0|  const TransitionType* tt0 = &transition_types_[tr0->type_index];
  351|      0|  const TransitionType* tt1 = &transition_types_[tr1->type_index];
  352|      0|  const TransitionType& dst(tt0->is_dst ? *tt0 : *tt1);
  353|      0|  const TransitionType& std(tt0->is_dst ? *tt1 : *tt0);
  354|      0|  CheckTransition(name, dst, posix.dst_offset, true, posix.dst_abbr);
  355|      0|  CheckTransition(name, std, posix.std_offset, false, posix.std_abbr);
  356|      0|
  357|      0|  // Add the transitions to tr1 and back to tr0 for each extra year.
  358|      0|  last_year_ = LocalTime(tr0->unix_time, *tt0).cs.year();
  359|      0|  bool leap_year = IsLeap(last_year_);
  360|      0|  const civil_day jan1(last_year_, 1, 1);
  361|      0|  std::int_fast64_t jan1_time = civil_second(jan1) - civil_second();
  362|      0|  int jan1_weekday = (static_cast<int>(get_weekday(jan1)) + 1) % 7;
  363|      0|  Transition* tr = &transitions_[hdr.timecnt];  // next trans to fill
  364|      0|  if (LocalTime(tr1->unix_time, *tt1).cs.year() != last_year_) {
  365|      0|    // Add a single extra transition to align to a calendar year.
  366|      0|    transitions_.resize(transitions_.size() + 1);
  367|      0|    assert(tr == &transitions_[hdr.timecnt]);  // no reallocation
  368|      0|    const PosixTransition& pt1(tt0->is_dst ? posix.dst_end : posix.dst_start);
  369|      0|    std::int_fast64_t tr1_offset = TransOffset(leap_year, jan1_weekday, pt1);
  370|      0|    tr->unix_time = jan1_time + tr1_offset - tt0->utc_offset;
  371|      0|    tr++->type_index = tr1->type_index;
  372|      0|    tr0 = &transitions_[hdr.timecnt];
  373|      0|    tr1 = &transitions_[hdr.timecnt - 1];
  374|      0|    tt0 = &transition_types_[tr0->type_index];
  375|      0|    tt1 = &transition_types_[tr1->type_index];
  376|      0|  }
  377|      0|  const PosixTransition& pt1(tt0->is_dst ? posix.dst_end : posix.dst_start);
  378|      0|  const PosixTransition& pt0(tt0->is_dst ? posix.dst_start : posix.dst_end);
  379|      0|  for (const year_t limit = last_year_ + 400; last_year_ < limit;) {
  380|      0|    last_year_ += 1;  // an additional year of generated transitions
  381|      0|    jan1_time += kSecsPerYear[leap_year];
  382|      0|    jan1_weekday = (jan1_weekday + kDaysPerYear[leap_year]) % 7;
  383|      0|    leap_year = !leap_year && IsLeap(last_year_);
  384|      0|    std::int_fast64_t tr1_offset = TransOffset(leap_year, jan1_weekday, pt1);
  385|      0|    tr->unix_time = jan1_time + tr1_offset - tt0->utc_offset;
  386|      0|    tr++->type_index = tr1->type_index;
  387|      0|    std::int_fast64_t tr0_offset = TransOffset(leap_year, jan1_weekday, pt0);
  388|      0|    tr->unix_time = jan1_time + tr0_offset - tt1->utc_offset;
  389|      0|    tr++->type_index = tr0->type_index;
  390|      0|  }
  391|      0|  assert(tr == &transitions_[0] + transitions_.size());
  392|      0|}
  393|       |
  394|      0|bool TimeZoneInfo::Load(const std::string& name, ZoneInfoSource* zip) {
  395|      0|  // Read and validate the header.
  396|      0|  tzhead tzh;
  397|      0|  if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh))
  398|      0|    return false;
  399|      0|  if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
  400|      0|    return false;
  401|      0|  Header hdr;
  402|      0|  if (!hdr.Build(tzh))
  403|      0|    return false;
  404|      0|  std::size_t time_len = 4;
  405|      0|  if (tzh.tzh_version[0] != '\0') {
  406|      0|    // Skip the 4-byte data.
  407|      0|    if (zip->Skip(hdr.DataLength(time_len)) != 0)
  408|      0|      return false;
  409|      0|    // Read and validate the header for the 8-byte data.
  410|      0|    if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh))
  411|      0|      return false;
  412|      0|    if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
  413|      0|      return false;
  414|      0|    if (tzh.tzh_version[0] == '\0')
  415|      0|      return false;
  416|      0|    if (!hdr.Build(tzh))
  417|      0|      return false;
  418|      0|    time_len = 8;
  419|      0|  }
  420|      0|  if (hdr.typecnt == 0)
  421|      0|    return false;
  422|      0|  if (hdr.leapcnt != 0) {
  423|      0|    // This code assumes 60-second minutes so we do not want
  424|      0|    // the leap-second encoded zoneinfo. We could reverse the
  425|      0|    // compensation, but the "right" encoding is rarely used
  426|      0|    // so currently we simply reject such data.
  427|      0|    return false;
  428|      0|  }
  429|      0|  if (hdr.ttisstdcnt != 0 && hdr.ttisstdcnt != hdr.typecnt)
  430|      0|    return false;
  431|      0|  if (hdr.ttisutcnt != 0 && hdr.ttisutcnt != hdr.typecnt)
  432|      0|    return false;
  433|      0|
  434|      0|  // Read the data into a local buffer.
  435|      0|  std::size_t len = hdr.DataLength(time_len);
  436|      0|  std::vector<char> tbuf(len);
  437|      0|  if (zip->Read(tbuf.data(), len) != len)
  438|      0|    return false;
  439|      0|  const char* bp = tbuf.data();
  440|      0|
  441|      0|  // Decode and validate the transitions.
  442|      0|  transitions_.reserve(hdr.timecnt + 2);  // We might add a couple.
  443|      0|  transitions_.resize(hdr.timecnt);
  444|      0|  for (std::size_t i = 0; i != hdr.timecnt; ++i) {
  445|      0|    transitions_[i].unix_time = (time_len == 4) ? Decode32(bp) : Decode64(bp);
  446|      0|    bp += time_len;
  447|      0|    if (i != 0) {
  448|      0|      // Check that the transitions are ordered by time (as zic guarantees).
  449|      0|      if (!Transition::ByUnixTime()(transitions_[i - 1], transitions_[i]))
  450|      0|        return false;  // out of order
  451|      0|    }
  452|      0|  }
  453|      0|  bool seen_type_0 = false;
  454|      0|  for (std::size_t i = 0; i != hdr.timecnt; ++i) {
  455|      0|    transitions_[i].type_index = Decode8(bp++);
  456|      0|    if (transitions_[i].type_index >= hdr.typecnt)
  457|      0|      return false;
  458|      0|    if (transitions_[i].type_index == 0)
  459|      0|      seen_type_0 = true;
  460|      0|  }
  461|      0|
  462|      0|  // Decode and validate the transition types.
  463|      0|  transition_types_.resize(hdr.typecnt);
  464|      0|  for (std::size_t i = 0; i != hdr.typecnt; ++i) {
  465|      0|    transition_types_[i].utc_offset =
  466|      0|        static_cast<std::int_least32_t>(Decode32(bp));
  467|      0|    if (transition_types_[i].utc_offset >= kSecsPerDay ||
  468|      0|        transition_types_[i].utc_offset <= -kSecsPerDay)
  469|      0|      return false;
  470|      0|    bp += 4;
  471|      0|    transition_types_[i].is_dst = (Decode8(bp++) != 0);
  472|      0|    transition_types_[i].abbr_index = Decode8(bp++);
  473|      0|    if (transition_types_[i].abbr_index >= hdr.charcnt)
  474|      0|      return false;
  475|      0|  }
  476|      0|
  477|      0|  // Determine the before-first-transition type.
  478|      0|  default_transition_type_ = 0;
  479|      0|  if (seen_type_0 && hdr.timecnt != 0) {
  480|      0|    std::uint_fast8_t index = 0;
  481|      0|    if (transition_types_[0].is_dst) {
  482|      0|      index = transitions_[0].type_index;
  483|      0|      while (index != 0 && transition_types_[index].is_dst)
  484|      0|        --index;
  485|      0|    }
  486|      0|    while (index != hdr.typecnt && transition_types_[index].is_dst)
  487|      0|      ++index;
  488|      0|    if (index != hdr.typecnt)
  489|      0|      default_transition_type_ = index;
  490|      0|  }
  491|      0|
  492|      0|  // Copy all the abbreviations.
  493|      0|  abbreviations_.assign(bp, hdr.charcnt);
  494|      0|  bp += hdr.charcnt;
  495|      0|
  496|      0|  // Skip the unused portions. We've already dispensed with leap-second
  497|      0|  // encoded zoneinfo. The ttisstd/ttisgmt indicators only apply when
  498|      0|  // interpreting a POSIX spec that does not include start/end rules, and
  499|      0|  // that isn't the case here (see "zic -p").
  500|      0|  bp += (8 + 4) * hdr.leapcnt;  // leap-time + TAI-UTC
  501|      0|  bp += 1 * hdr.ttisstdcnt;     // UTC/local indicators
  502|      0|  bp += 1 * hdr.ttisutcnt;      // standard/wall indicators
  503|      0|  assert(bp == tbuf.data() + tbuf.size());
  504|      0|
  505|      0|  future_spec_.clear();
  506|      0|  if (tzh.tzh_version[0] != '\0') {
  507|      0|    // Snarf up the NL-enclosed future POSIX spec. Note
  508|      0|    // that version '3' files utilize an extended format.
  509|      0|    auto get_char = [](ZoneInfoSource* azip) -> int {
  510|      0|      unsigned char ch;  // all non-EOF results are positive
  511|      0|      return (azip->Read(&ch, 1) == 1) ? ch : EOF;
  512|      0|    };
  513|      0|    if (get_char(zip) != '\n')
  514|      0|      return false;
  515|      0|    for (int c = get_char(zip); c != '\n'; c = get_char(zip)) {
  516|      0|      if (c == EOF)
  517|      0|        return false;
  518|      0|      future_spec_.push_back(static_cast<char>(c));
  519|      0|    }
  520|      0|  }
  521|      0|
  522|      0|  // We don't check for EOF so that we're forwards compatible.
  523|      0|
  524|      0|  // If we did not find version information during the standard loading
  525|      0|  // process (as of tzh_version '3' that is unsupported), then ask the
  526|      0|  // ZoneInfoSource for any out-of-bound version std::string it may be privy to.
  527|      0|  if (version_.empty()) {
  528|      0|    version_ = zip->Version();
  529|      0|  }
  530|      0|
  531|      0|  // Trim redundant transitions. zic may have added these to work around
  532|      0|  // differences between the glibc and reference implementations (see
  533|      0|  // zic.c:dontmerge) and the Qt library (see zic.c:WORK_AROUND_QTBUG_53071).
  534|      0|  // For us, they just get in the way when we do future_spec_ extension.
  535|      0|  while (hdr.timecnt > 1) {
  536|      0|    if (!EquivTransitions(transitions_[hdr.timecnt - 1].type_index,
  537|      0|                          transitions_[hdr.timecnt - 2].type_index)) {
  538|      0|      break;
  539|      0|    }
  540|      0|    hdr.timecnt -= 1;
  541|      0|  }
  542|      0|  transitions_.resize(hdr.timecnt);
  543|      0|
  544|      0|  // Ensure that there is always a transition in the first half of the
  545|      0|  // time line (the second half is handled in ExtendTransitions()) so that
  546|      0|  // the signed difference between a civil_second and the civil_second of
  547|      0|  // its previous transition is always representable, without overflow.
  548|      0|  // A contemporary zic will usually have already done this for us.
  549|      0|  if (transitions_.empty() || transitions_.front().unix_time >= 0) {
  550|      0|    Transition& tr(*transitions_.emplace(transitions_.begin()));
  551|      0|    tr.unix_time = -(1LL << 59);  // see tz/zic.c "BIG_BANG"
  552|      0|    tr.type_index = default_transition_type_;
  553|      0|    hdr.timecnt += 1;
  554|      0|  }
  555|      0|
  556|      0|  // Extend the transitions using the future specification.
  557|      0|  ExtendTransitions(name, hdr);
  558|      0|
  559|      0|  // Compute the local civil time for each transition and the preceding
  560|      0|  // second. These will be used for reverse conversions in MakeTime().
  561|      0|  const TransitionType* ttp = &transition_types_[default_transition_type_];
  562|      0|  for (std::size_t i = 0; i != transitions_.size(); ++i) {
  563|      0|    Transition& tr(transitions_[i]);
  564|      0|    tr.prev_civil_sec = LocalTime(tr.unix_time, *ttp).cs - 1;
  565|      0|    ttp = &transition_types_[tr.type_index];
  566|      0|    tr.civil_sec = LocalTime(tr.unix_time, *ttp).cs;
  567|      0|    if (i != 0) {
  568|      0|      // Check that the transitions are ordered by civil time. Essentially
  569|      0|      // this means that an offset change cannot cross another such change.
  570|      0|      // No one does this in practice, and we depend on it in MakeTime().
  571|      0|      if (!Transition::ByCivilTime()(transitions_[i - 1], tr))
  572|      0|        return false;  // out of order
  573|      0|    }
  574|      0|  }
  575|      0|
  576|      0|  // Compute the maximum/minimum civil times that can be converted to a
  577|      0|  // time_point<seconds> for each of the zone's transition types.
  578|      0|  for (auto& tt : transition_types_) {
  579|      0|    tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
  580|      0|    tt.civil_min = LocalTime(seconds::min().count(), tt).cs;
  581|      0|  }
  582|      0|
  583|      0|  transitions_.shrink_to_fit();
  584|      0|  return true;
  585|      0|}
  586|       |
  587|       |namespace {
  588|       |
  589|       |// fopen(3) adaptor.
  590|      0|inline FILE* FOpen(const char* path, const char* mode) {
  591|       |#if defined(_MSC_VER)
  592|       |  FILE* fp;
  593|       |  if (fopen_s(&fp, path, mode) != 0) fp = nullptr;
  594|       |  return fp;
  595|       |#else
  596|       |  return fopen(path, mode);  // TODO: Enable the close-on-exec flag.
  597|      0|#endif
  598|      0|}
  599|       |
  600|       |// A stdio(3)-backed implementation of ZoneInfoSource.
  601|       |class FileZoneInfoSource : public ZoneInfoSource {
  602|       | public:
  603|       |  static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
  604|       |
  605|      0|  std::size_t Read(void* ptr, std::size_t size) override {
  606|      0|    size = std::min(size, len_);
  607|      0|    std::size_t nread = fread(ptr, 1, size, fp_.get());
  608|      0|    len_ -= nread;
  609|      0|    return nread;
  610|      0|  }
  611|      0|  int Skip(std::size_t offset) override {
  612|      0|    offset = std::min(offset, len_);
  613|      0|    int rc = fseek(fp_.get(), static_cast<long>(offset), SEEK_CUR);
  614|      0|    if (rc == 0) len_ -= offset;
  615|      0|    return rc;
  616|      0|  }
  617|      0|  std::string Version() const override {
  618|      0|    // TODO: It would nice if the zoneinfo data included the tzdb version.
  619|      0|    return std::string();
  620|      0|  }
  621|       |
  622|       | protected:
  623|       |  explicit FileZoneInfoSource(
  624|       |      FILE* fp, std::size_t len = std::numeric_limits<std::size_t>::max())
  625|      0|      : fp_(fp, fclose), len_(len) {}
  626|       |
  627|       | private:
  628|       |  std::unique_ptr<FILE, int(*)(FILE*)> fp_;
  629|       |  std::size_t len_;
  630|       |};
  631|       |
  632|       |std::unique_ptr<ZoneInfoSource> FileZoneInfoSource::Open(
  633|      0|    const std::string& name) {
  634|      0|  // Use of the "file:" prefix is intended for testing purposes only.
  635|      0|  if (name.compare(0, 5, "file:") == 0) return Open(name.substr(5));
  636|      0|
  637|      0|  // Map the time-zone name to a path name.
  638|      0|  std::string path;
  639|      0|  if (name.empty() || name[0] != '/') {
  640|      0|    const char* tzdir = "/usr/share/zoneinfo";
  641|      0|    char* tzdir_env = nullptr;
  642|       |#if defined(_MSC_VER)
  643|       |    _dupenv_s(&tzdir_env, nullptr, "TZDIR");
  644|       |#else
  645|       |    tzdir_env = std::getenv("TZDIR");
  646|      0|#endif
  647|      0|    if (tzdir_env && *tzdir_env) tzdir = tzdir_env;
  648|      0|    path += tzdir;
  649|      0|    path += '/';
  650|       |#if defined(_MSC_VER)
  651|       |    free(tzdir_env);
  652|       |#endif
  653|       |  }
  654|      0|  path += name;
  655|      0|
  656|      0|  // Open the zoneinfo file.
  657|      0|  FILE* fp = FOpen(path.c_str(), "rb");
  658|      0|  if (fp == nullptr) return nullptr;
  659|      0|  std::size_t length = 0;
  660|      0|  if (fseek(fp, 0, SEEK_END) == 0) {
  661|      0|    long pos = ftell(fp);
  662|      0|    if (pos >= 0) {
  663|      0|      length = static_cast<std::size_t>(pos);
  664|      0|    }
  665|      0|    rewind(fp);
  666|      0|  }
  667|      0|  return std::unique_ptr<ZoneInfoSource>(new FileZoneInfoSource(fp, length));
  668|      0|}
  669|       |
  670|       |class AndroidZoneInfoSource : public FileZoneInfoSource {
  671|       | public:
  672|       |  static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
  673|      0|  std::string Version() const override { return version_; }
  674|       |
  675|       | private:
  676|       |  explicit AndroidZoneInfoSource(FILE* fp, std::size_t len, const char* vers)
  677|      0|      : FileZoneInfoSource(fp, len), version_(vers) {}
  678|       |  std::string version_;
  679|       |};
  680|       |
  681|       |std::unique_ptr<ZoneInfoSource> AndroidZoneInfoSource::Open(
  682|      0|    const std::string& name) {
  683|      0|  // Use of the "file:" prefix is intended for testing purposes only.
  684|      0|  if (name.compare(0, 5, "file:") == 0) return Open(name.substr(5));
  685|      0|
  686|      0|  // See Android's libc/tzcode/bionic.cpp for additional information.
  687|      0|  for (const char* tzdata : {"/data/misc/zoneinfo/current/tzdata",
  688|      0|                             "/system/usr/share/zoneinfo/tzdata"}) {
  689|      0|    std::unique_ptr<FILE, int (*)(FILE*)> fp(FOpen(tzdata, "rb"), fclose);
  690|      0|    if (fp.get() == nullptr) continue;
  691|      0|
  692|      0|    char hbuf[24];  // covers header.zonetab_offset too
  693|      0|    if (fread(hbuf, 1, sizeof(hbuf), fp.get()) != sizeof(hbuf)) continue;
  694|      0|    if (strncmp(hbuf, "tzdata", 6) != 0) continue;
  695|      0|    const char* vers = (hbuf[11] == '\0') ? hbuf + 6 : "";
  696|      0|    const std::int_fast32_t index_offset = Decode32(hbuf + 12);
  697|      0|    const std::int_fast32_t data_offset = Decode32(hbuf + 16);
  698|      0|    if (index_offset < 0 || data_offset < index_offset) continue;
  699|      0|    if (fseek(fp.get(), static_cast<long>(index_offset), SEEK_SET) != 0)
  700|      0|      continue;
  701|      0|
  702|      0|    char ebuf[52];  // covers entry.unused too
  703|      0|    const std::size_t index_size =
  704|      0|        static_cast<std::size_t>(data_offset - index_offset);
  705|      0|    const std::size_t zonecnt = index_size / sizeof(ebuf);
  706|      0|    if (zonecnt * sizeof(ebuf) != index_size) continue;
  707|      0|    for (std::size_t i = 0; i != zonecnt; ++i) {
  708|      0|      if (fread(ebuf, 1, sizeof(ebuf), fp.get()) != sizeof(ebuf)) break;
  709|      0|      const std::int_fast32_t start = data_offset + Decode32(ebuf + 40);
  710|      0|      const std::int_fast32_t length = Decode32(ebuf + 44);
  711|      0|      if (start < 0 || length < 0) break;
  712|      0|      ebuf[40] = '\0';  // ensure zone name is NUL terminated
  713|      0|      if (strcmp(name.c_str(), ebuf) == 0) {
  714|      0|        if (fseek(fp.get(), static_cast<long>(start), SEEK_SET) != 0) break;
  715|      0|        return std::unique_ptr<ZoneInfoSource>(new AndroidZoneInfoSource(
  716|      0|            fp.release(), static_cast<std::size_t>(length), vers));
  717|      0|      }
  718|      0|    }
  719|      0|  }
  720|      0|
  721|      0|  return nullptr;
  722|      0|}
  723|       |
  724|       |}  // namespace
  725|       |
  726|      0|bool TimeZoneInfo::Load(const std::string& name) {
  727|      0|  // We can ensure that the loading of UTC or any other fixed-offset
  728|      0|  // zone never fails because the simple, fixed-offset state can be
  729|      0|  // internally generated. Note that this depends on our choice to not
  730|      0|  // accept leap-second encoded ("right") zoneinfo.
  731|      0|  auto offset = seconds::zero();
  732|      0|  if (FixedOffsetFromName(name, &offset)) {
  733|      0|    return ResetToBuiltinUTC(offset);
  734|      0|  }
  735|      0|
  736|      0|  // Find and use a ZoneInfoSource to load the named zone.
  737|      0|  auto zip = cctz_extension::zone_info_source_factory(
  738|      0|      name, [](const std::string& name) -> std::unique_ptr<ZoneInfoSource> {
  739|      0|        if (auto zip = FileZoneInfoSource::Open(name)) return zip;
  740|      0|        if (auto zip = AndroidZoneInfoSource::Open(name)) return zip;
  741|      0|        return nullptr;
  742|      0|      });
  743|      0|  return zip != nullptr && Load(name, zip.get());
  744|      0|}
  745|       |
  746|       |// BreakTime() translation for a particular transition type.
  747|       |time_zone::absolute_lookup TimeZoneInfo::LocalTime(
  748|      0|    std::int_fast64_t unix_time, const TransitionType& tt) const {
  749|      0|  // A civil time in "+offset" looks like (time+offset) in UTC.
  750|      0|  // Note: We perform two additions in the civil_second domain to
  751|      0|  // sidestep the chance of overflow in (unix_time + tt.utc_offset).
  752|      0|  return {(civil_second() + unix_time) + tt.utc_offset,
  753|      0|          tt.utc_offset, tt.is_dst, &abbreviations_[tt.abbr_index]};
  754|      0|}
  755|       |
  756|       |// BreakTime() translation for a particular transition.
  757|       |time_zone::absolute_lookup TimeZoneInfo::LocalTime(
  758|      0|    std::int_fast64_t unix_time, const Transition& tr) const {
  759|      0|  const TransitionType& tt = transition_types_[tr.type_index];
  760|      0|  // Note: (unix_time - tr.unix_time) will never overflow as we
  761|      0|  // have ensured that there is always a "nearby" transition.
  762|      0|  return {tr.civil_sec + (unix_time - tr.unix_time),  // TODO: Optimize.
  763|      0|          tt.utc_offset, tt.is_dst, &abbreviations_[tt.abbr_index]};
  764|      0|}
  765|       |
  766|       |// MakeTime() translation with a conversion-preserving +N * 400-year shift.
  767|       |time_zone::civil_lookup TimeZoneInfo::TimeLocal(const civil_second& cs,
  768|      0|                                                year_t c4_shift) const {
  769|      0|  assert(last_year_ - 400 < cs.year() && cs.year() <= last_year_);
  770|      0|  time_zone::civil_lookup cl = MakeTime(cs);
  771|      0|  if (c4_shift > seconds::max().count() / kSecsPer400Years) {
  772|      0|    cl.pre = cl.trans = cl.post = time_point<seconds>::max();
  773|      0|  } else {
  774|      0|    const auto offset = seconds(c4_shift * kSecsPer400Years);
  775|      0|    const auto limit = time_point<seconds>::max() - offset;
  776|      0|    for (auto* tp : {&cl.pre, &cl.trans, &cl.post}) {
  777|      0|      if (*tp > limit) {
  778|      0|        *tp = time_point<seconds>::max();
  779|      0|      } else {
  780|      0|        *tp += offset;
  781|      0|      }
  782|      0|    }
  783|      0|  }
  784|      0|  return cl;
  785|      0|}
  786|       |
  787|       |time_zone::absolute_lookup TimeZoneInfo::BreakTime(
  788|      0|    const time_point<seconds>& tp) const {
  789|      0|  std::int_fast64_t unix_time = ToUnixSeconds(tp);
  790|      0|  const std::size_t timecnt = transitions_.size();
  791|      0|  assert(timecnt != 0);  // We always add a transition.
  792|      0|
  793|      0|  if (unix_time < transitions_[0].unix_time) {
  794|      0|    return LocalTime(unix_time, transition_types_[default_transition_type_]);
  795|      0|  }
  796|      0|  if (unix_time >= transitions_[timecnt - 1].unix_time) {
  797|      0|    // After the last transition. If we extended the transitions using
  798|      0|    // future_spec_, shift back to a supported year using the 400-year
  799|      0|    // cycle of calendaric equivalence and then compensate accordingly.
  800|      0|    if (extended_) {
  801|      0|      const std::int_fast64_t diff =
  802|      0|          unix_time - transitions_[timecnt - 1].unix_time;
  803|      0|      const year_t shift = diff / kSecsPer400Years + 1;
  804|      0|      const auto d = seconds(shift * kSecsPer400Years);
  805|      0|      time_zone::absolute_lookup al = BreakTime(tp - d);
  806|      0|      al.cs = YearShift(al.cs, shift * 400);
  807|      0|      return al;
  808|      0|    }
  809|      0|    return LocalTime(unix_time, transitions_[timecnt - 1]);
  810|      0|  }
  811|      0|
  812|      0|  const std::size_t hint = local_time_hint_.load(std::memory_order_relaxed);
  813|      0|  if (0 < hint && hint < timecnt) {
  814|      0|    if (transitions_[hint - 1].unix_time <= unix_time) {
  815|      0|      if (unix_time < transitions_[hint].unix_time) {
  816|      0|        return LocalTime(unix_time, transitions_[hint - 1]);
  817|      0|      }
  818|      0|    }
  819|      0|  }
  820|      0|
  821|      0|  const Transition target = {unix_time, 0, civil_second(), civil_second()};
  822|      0|  const Transition* begin = &transitions_[0];
  823|      0|  const Transition* tr = std::upper_bound(begin, begin + timecnt, target,
  824|      0|                                          Transition::ByUnixTime());
  825|      0|  local_time_hint_.store(static_cast<std::size_t>(tr - begin),
  826|      0|                         std::memory_order_relaxed);
  827|      0|  return LocalTime(unix_time, *--tr);
  828|      0|}
  829|       |
  830|      0|time_zone::civil_lookup TimeZoneInfo::MakeTime(const civil_second& cs) const {
  831|      0|  const std::size_t timecnt = transitions_.size();
  832|      0|  assert(timecnt != 0);  // We always add a transition.
  833|      0|
  834|      0|  // Find the first transition after our target civil time.
  835|      0|  const Transition* tr = nullptr;
  836|      0|  const Transition* begin = &transitions_[0];
  837|      0|  const Transition* end = begin + timecnt;
  838|      0|  if (cs < begin->civil_sec) {
  839|      0|    tr = begin;
  840|      0|  } else if (cs >= transitions_[timecnt - 1].civil_sec) {
  841|      0|    tr = end;
  842|      0|  } else {
  843|      0|    const std::size_t hint = time_local_hint_.load(std::memory_order_relaxed);
  844|      0|    if (0 < hint && hint < timecnt) {
  845|      0|      if (transitions_[hint - 1].civil_sec <= cs) {
  846|      0|        if (cs < transitions_[hint].civil_sec) {
  847|      0|          tr = begin + hint;
  848|      0|        }
  849|      0|      }
  850|      0|    }
  851|      0|    if (tr == nullptr) {
  852|      0|      const Transition target = {0, 0, cs, civil_second()};
  853|      0|      tr = std::upper_bound(begin, end, target, Transition::ByCivilTime());
  854|      0|      time_local_hint_.store(static_cast<std::size_t>(tr - begin),
  855|      0|                             std::memory_order_relaxed);
  856|      0|    }
  857|      0|  }
  858|      0|
  859|      0|  if (tr == begin) {
  860|      0|    if (tr->prev_civil_sec >= cs) {
  861|      0|      // Before first transition, so use the default offset.
  862|      0|      const TransitionType& tt(transition_types_[default_transition_type_]);
  863|      0|      if (cs < tt.civil_min) return MakeUnique(time_point<seconds>::min());
  864|      0|      return MakeUnique(cs - (civil_second() + tt.utc_offset));
  865|      0|    }
  866|      0|    // tr->prev_civil_sec < cs < tr->civil_sec
  867|      0|    return MakeSkipped(*tr, cs);
  868|      0|  }
  869|      0|
  870|      0|  if (tr == end) {
  871|      0|    if (cs > (--tr)->prev_civil_sec) {
  872|      0|      // After the last transition. If we extended the transitions using
  873|      0|      // future_spec_, shift back to a supported year using the 400-year
  874|      0|      // cycle of calendaric equivalence and then compensate accordingly.
  875|      0|      if (extended_ && cs.year() > last_year_) {
  876|      0|        const year_t shift = (cs.year() - last_year_ - 1) / 400 + 1;
  877|      0|        return TimeLocal(YearShift(cs, shift * -400), shift);
  878|      0|      }
  879|      0|      const TransitionType& tt(transition_types_[tr->type_index]);
  880|      0|      if (cs > tt.civil_max) return MakeUnique(time_point<seconds>::max());
  881|      0|      return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
  882|      0|    }
  883|      0|    // tr->civil_sec <= cs <= tr->prev_civil_sec
  884|      0|    return MakeRepeated(*tr, cs);
  885|      0|  }
  886|      0|
  887|      0|  if (tr->prev_civil_sec < cs) {
  888|      0|    // tr->prev_civil_sec < cs < tr->civil_sec
  889|      0|    return MakeSkipped(*tr, cs);
  890|      0|  }
  891|      0|
  892|      0|  if (cs <= (--tr)->prev_civil_sec) {
  893|      0|    // tr->civil_sec <= cs <= tr->prev_civil_sec
  894|      0|    return MakeRepeated(*tr, cs);
  895|      0|  }
  896|      0|
  897|      0|  // In between transitions.
  898|      0|  return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
  899|      0|}
  900|       |
  901|      0|std::string TimeZoneInfo::Version() const {
  902|      0|  return version_;
  903|      0|}
  904|       |
  905|      0|std::string TimeZoneInfo::Description() const {
  906|      0|  std::ostringstream oss;
  907|      0|  oss << "#trans=" << transitions_.size();
  908|      0|  oss << " #types=" << transition_types_.size();
  909|      0|  oss << " spec='" << future_spec_ << "'";
  910|      0|  return oss.str();
  911|      0|}
  912|       |
  913|       |bool TimeZoneInfo::NextTransition(const time_point<seconds>& tp,
  914|      0|                                  time_zone::civil_transition* trans) const {
  915|      0|  if (transitions_.empty()) return false;
  916|      0|  const Transition* begin = &transitions_[0];
  917|      0|  const Transition* end = begin + transitions_.size();
  918|      0|  if (begin->unix_time <= -(1LL << 59)) {
  919|      0|    // Do not report the BIG_BANG found in recent zoneinfo data as it is
  920|      0|    // really a sentinel, not a transition.  See tz/zic.c.
  921|      0|    ++begin;
  922|      0|  }
  923|      0|  std::int_fast64_t unix_time = ToUnixSeconds(tp);
  924|      0|  const Transition target = {unix_time, 0, civil_second(), civil_second()};
  925|      0|  const Transition* tr = std::upper_bound(begin, end, target,
  926|      0|                                          Transition::ByUnixTime());
  927|      0|  for (; tr != end; ++tr) {  // skip no-op transitions
  928|      0|    std::uint_fast8_t prev_type_index =
  929|      0|        (tr == begin) ? default_transition_type_ : tr[-1].type_index;
  930|      0|    if (!EquivTransitions(prev_type_index, tr[0].type_index)) break;
  931|      0|  }
  932|      0|  // When tr == end we return false, ignoring future_spec_.
  933|      0|  if (tr == end) return false;
  934|      0|  trans->from = tr->prev_civil_sec + 1;
  935|      0|  trans->to = tr->civil_sec;
  936|      0|  return true;
  937|      0|}
  938|       |
  939|       |bool TimeZoneInfo::PrevTransition(const time_point<seconds>& tp,
  940|      0|                                  time_zone::civil_transition* trans) const {
  941|      0|  if (transitions_.empty()) return false;
  942|      0|  const Transition* begin = &transitions_[0];
  943|      0|  const Transition* end = begin + transitions_.size();
  944|      0|  if (begin->unix_time <= -(1LL << 59)) {
  945|      0|    // Do not report the BIG_BANG found in recent zoneinfo data as it is
  946|      0|    // really a sentinel, not a transition.  See tz/zic.c.
  947|      0|    ++begin;
  948|      0|  }
  949|      0|  std::int_fast64_t unix_time = ToUnixSeconds(tp);
  950|      0|  if (FromUnixSeconds(unix_time) != tp) {
  951|      0|    if (unix_time == std::numeric_limits<std::int_fast64_t>::max()) {
  952|      0|      if (end == begin) return false;  // Ignore future_spec_.
  953|      0|      trans->from = (--end)->prev_civil_sec + 1;
  954|      0|      trans->to = end->civil_sec;
  955|      0|      return true;
  956|      0|    }
  957|      0|    unix_time += 1;  // ceils
  958|      0|  }
  959|      0|  const Transition target = {unix_time, 0, civil_second(), civil_second()};
  960|      0|  const Transition* tr = std::lower_bound(begin, end, target,
  961|      0|                                          Transition::ByUnixTime());
  962|      0|  for (; tr != begin; --tr) {  // skip no-op transitions
  963|      0|    std::uint_fast8_t prev_type_index =
  964|      0|        (tr - 1 == begin) ? default_transition_type_ : tr[-2].type_index;
  965|      0|    if (!EquivTransitions(prev_type_index, tr[-1].type_index)) break;
  966|      0|  }
  967|      0|  // When tr == end we return the "last" transition, ignoring future_spec_.
  968|      0|  if (tr == begin) return false;
  969|      0|  trans->from = (--tr)->prev_civil_sec + 1;
  970|      0|  trans->to = tr->civil_sec;
  971|      0|  return true;
  972|      0|}
  973|       |
  974|       |}  // namespace cctz
  975|       |}  // namespace time_internal
  976|       |}  // inline namespace lts_2019_08_08
  977|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_info.h:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_INFO_H_
   16|       |#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_INFO_H_
   17|       |
   18|       |#include <atomic>
   19|       |#include <cstddef>
   20|       |#include <cstdint>
   21|       |#include <string>
   22|       |#include <vector>
   23|       |
   24|       |#include "absl/time/internal/cctz/include/cctz/civil_time.h"
   25|       |#include "absl/time/internal/cctz/include/cctz/time_zone.h"
   26|       |#include "absl/time/internal/cctz/include/cctz/zone_info_source.h"
   27|       |#include "time_zone_if.h"
   28|       |#include "tzfile.h"
   29|       |
   30|       |namespace absl {
   31|       |inline namespace lts_2019_08_08 {
   32|       |namespace time_internal {
   33|       |namespace cctz {
   34|       |
   35|       |// A transition to a new UTC offset.
   36|       |struct Transition {
   37|       |  std::int_least64_t unix_time;   // the instant of this transition
   38|       |  std::uint_least8_t type_index;  // index of the transition type
   39|       |  civil_second civil_sec;         // local civil time of transition
   40|       |  civil_second prev_civil_sec;    // local civil time one second earlier
   41|       |
   42|       |  struct ByUnixTime {
   43|      0|    inline bool operator()(const Transition& lhs, const Transition& rhs) const {
   44|      0|      return lhs.unix_time < rhs.unix_time;
   45|      0|    }
   46|       |  };
   47|       |  struct ByCivilTime {
   48|      0|    inline bool operator()(const Transition& lhs, const Transition& rhs) const {
   49|      0|      return lhs.civil_sec < rhs.civil_sec;
   50|      0|    }
   51|       |  };
   52|       |};
   53|       |
   54|       |// The characteristics of a particular transition.
   55|       |struct TransitionType {
   56|       |  std::int_least32_t utc_offset;  // the new prevailing UTC offset
   57|       |  civil_second civil_max;         // max convertible civil time for offset
   58|       |  civil_second civil_min;         // min convertible civil time for offset
   59|       |  bool is_dst;                    // did we move into daylight-saving time
   60|       |  std::uint_least8_t abbr_index;  // index of the new abbreviation
   61|       |};
   62|       |
   63|       |// A time zone backed by the IANA Time Zone Database (zoneinfo).
   64|       |class TimeZoneInfo : public TimeZoneIf {
   65|       | public:
   66|      0|  TimeZoneInfo() = default;
   67|       |  TimeZoneInfo(const TimeZoneInfo&) = delete;
   68|       |  TimeZoneInfo& operator=(const TimeZoneInfo&) = delete;
   69|       |
   70|       |  // Loads the zoneinfo for the given name, returning true if successful.
   71|       |  bool Load(const std::string& name);
   72|       |
   73|       |  // TimeZoneIf implementations.
   74|       |  time_zone::absolute_lookup BreakTime(
   75|       |      const time_point<seconds>& tp) const override;
   76|       |  time_zone::civil_lookup MakeTime(
   77|       |      const civil_second& cs) const override;
   78|       |  bool NextTransition(const time_point<seconds>& tp,
   79|       |                      time_zone::civil_transition* trans) const override;
   80|       |  bool PrevTransition(const time_point<seconds>& tp,
   81|       |                      time_zone::civil_transition* trans) const override;
   82|       |  std::string Version() const override;
   83|       |  std::string Description() const override;
   84|       |
   85|       | private:
   86|       |  struct Header {  // counts of:
   87|       |    std::size_t timecnt;     // transition times
   88|       |    std::size_t typecnt;     // transition types
   89|       |    std::size_t charcnt;     // zone abbreviation characters
   90|       |    std::size_t leapcnt;     // leap seconds (we expect none)
   91|       |    std::size_t ttisstdcnt;  // UTC/local indicators (unused)
   92|       |    std::size_t ttisutcnt;   // standard/wall indicators (unused)
   93|       |
   94|       |    bool Build(const tzhead& tzh);
   95|       |    std::size_t DataLength(std::size_t time_len) const;
   96|       |  };
   97|       |
   98|       |  void CheckTransition(const std::string& name, const TransitionType& tt,
   99|       |                       std::int_fast32_t offset, bool is_dst,
  100|       |                       const std::string& abbr) const;
  101|       |  bool EquivTransitions(std::uint_fast8_t tt1_index,
  102|       |                        std::uint_fast8_t tt2_index) const;
  103|       |  void ExtendTransitions(const std::string& name, const Header& hdr);
  104|       |
  105|       |  bool ResetToBuiltinUTC(const seconds& offset);
  106|       |  bool Load(const std::string& name, ZoneInfoSource* zip);
  107|       |
  108|       |  // Helpers for BreakTime() and MakeTime().
  109|       |  time_zone::absolute_lookup LocalTime(std::int_fast64_t unix_time,
  110|       |                                       const TransitionType& tt) const;
  111|       |  time_zone::absolute_lookup LocalTime(std::int_fast64_t unix_time,
  112|       |                                       const Transition& tr) const;
  113|       |  time_zone::civil_lookup TimeLocal(const civil_second& cs,
  114|       |                                    year_t c4_shift) const;
  115|       |
  116|       |  std::vector<Transition> transitions_;  // ordered by unix_time and civil_sec
  117|       |  std::vector<TransitionType> transition_types_;  // distinct transition types
  118|       |  std::uint_fast8_t default_transition_type_;  // for before first transition
  119|       |  std::string abbreviations_;  // all the NUL-terminated abbreviations
  120|       |
  121|       |  std::string version_;      // the tzdata version if available
  122|       |  std::string future_spec_;  // for after the last zic transition
  123|       |  bool extended_;            // future_spec_ was used to generate transitions
  124|       |  year_t last_year_;         // the final year of the generated transitions
  125|       |
  126|       |  // We remember the transitions found during the last BreakTime() and
  127|       |  // MakeTime() calls. If the next request is for the same transition we
  128|       |  // will avoid re-searching.
  129|       |  mutable std::atomic<std::size_t> local_time_hint_ = {};  // BreakTime() hint
  130|       |  mutable std::atomic<std::size_t> time_local_hint_ = {};  // MakeTime() hint
  131|       |};
  132|       |
  133|       |}  // namespace cctz
  134|       |}  // namespace time_internal
  135|       |}  // inline namespace lts_2019_08_08
  136|       |}  // namespace absl
  137|       |
  138|       |#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_INFO_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_libc.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#if defined(_WIN32) || defined(_WIN64)
   16|       |#define _CRT_SECURE_NO_WARNINGS 1
   17|       |#endif
   18|       |
   19|       |#include "time_zone_libc.h"
   20|       |
   21|       |#include <chrono>
   22|       |#include <ctime>
   23|       |#include <limits>
   24|       |#include <utility>
   25|       |
   26|       |#include "absl/time/internal/cctz/include/cctz/civil_time.h"
   27|       |#include "absl/time/internal/cctz/include/cctz/time_zone.h"
   28|       |
   29|       |namespace absl {
   30|       |inline namespace lts_2019_08_08 {
   31|       |namespace time_internal {
   32|       |namespace cctz {
   33|       |
   34|       |namespace {
   35|       |
   36|       |#if defined(_WIN32) || defined(_WIN64)
   37|       |// Uses the globals: '_timezone', '_dstbias' and '_tzname'.
   38|       |auto tm_gmtoff(const std::tm& tm) -> decltype(_timezone + _dstbias) {
   39|       |  const bool is_dst = tm.tm_isdst > 0;
   40|       |  return _timezone + (is_dst ? _dstbias : 0);
   41|       |}
   42|       |auto tm_zone(const std::tm& tm) -> decltype(_tzname[0]) {
   43|       |  const bool is_dst = tm.tm_isdst > 0;
   44|       |  return _tzname[is_dst];
   45|       |}
   46|       |#elif defined(__sun)
   47|       |// Uses the globals: 'timezone', 'altzone' and 'tzname'.
   48|       |auto tm_gmtoff(const std::tm& tm) -> decltype(timezone) {
   49|       |  const bool is_dst = tm.tm_isdst > 0;
   50|       |  return is_dst ? altzone : timezone;
   51|       |}
   52|       |auto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {
   53|       |  const bool is_dst = tm.tm_isdst > 0;
   54|       |  return tzname[is_dst];
   55|       |}
   56|       |#elif defined(__native_client__) || defined(__myriad2__) || \
   57|       |    defined(__EMSCRIPTEN__)
   58|       |// Uses the globals: 'timezone' and 'tzname'.
   59|       |auto tm_gmtoff(const std::tm& tm) -> decltype(_timezone + 0) {
   60|       |  const bool is_dst = tm.tm_isdst > 0;
   61|       |  return _timezone + (is_dst ? 60 * 60 : 0);
   62|       |}
   63|       |auto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {
   64|       |  const bool is_dst = tm.tm_isdst > 0;
   65|       |  return tzname[is_dst];
   66|       |}
   67|       |#else
   68|       |// Adapt to different spellings of the struct std::tm extension fields.
   69|       |#if defined(tm_gmtoff)
   70|       |auto tm_gmtoff(const std::tm& tm) -> decltype(tm.tm_gmtoff) {
   71|       |  return tm.tm_gmtoff;
   72|       |}
   73|       |#elif defined(__tm_gmtoff)
   74|       |auto tm_gmtoff(const std::tm& tm) -> decltype(tm.__tm_gmtoff) {
   75|       |  return tm.__tm_gmtoff;
   76|       |}
   77|       |#else
   78|       |template <typename T>
   79|      0|auto tm_gmtoff(const T& tm) -> decltype(tm.tm_gmtoff) {
   80|      0|  return tm.tm_gmtoff;
   81|      0|}
   82|       |template <typename T>
   83|       |auto tm_gmtoff(const T& tm) -> decltype(tm.__tm_gmtoff) {
   84|       |  return tm.__tm_gmtoff;
   85|       |}
   86|       |#endif  // tm_gmtoff
   87|       |#if defined(tm_zone)
   88|       |auto tm_zone(const std::tm& tm) -> decltype(tm.tm_zone) {
   89|       |  return tm.tm_zone;
   90|       |}
   91|       |#elif defined(__tm_zone)
   92|       |auto tm_zone(const std::tm& tm) -> decltype(tm.__tm_zone) {
   93|       |  return tm.__tm_zone;
   94|       |}
   95|       |#else
   96|       |template <typename T>
   97|      0|auto tm_zone(const T& tm) -> decltype(tm.tm_zone) {
   98|      0|  return tm.tm_zone;
   99|      0|}
  100|       |template <typename T>
  101|       |auto tm_zone(const T& tm) -> decltype(tm.__tm_zone) {
  102|       |  return tm.__tm_zone;
  103|       |}
  104|       |#endif  // tm_zone
  105|       |#endif
  106|       |
  107|      0|inline std::tm* gm_time(const std::time_t *timep, std::tm *result) {
  108|       |#if defined(_WIN32) || defined(_WIN64)
  109|       |    return gmtime_s(result, timep) ? nullptr : result;
  110|       |#else
  111|       |    return gmtime_r(timep, result);
  112|      0|#endif
  113|      0|}
  114|       |
  115|      0|inline std::tm* local_time(const std::time_t *timep, std::tm *result) {
  116|       |#if defined(_WIN32) || defined(_WIN64)
  117|       |    return localtime_s(result, timep) ? nullptr : result;
  118|       |#else
  119|       |    return localtime_r(timep, result);
  120|      0|#endif
  121|      0|}
  122|       |
  123|       |// Converts a civil second and "dst" flag into a time_t and UTC offset.
  124|       |// Returns false if time_t cannot represent the requested civil second.
  125|       |// Caller must have already checked that cs.year() will fit into a tm_year.
  126|      0|bool make_time(const civil_second& cs, int is_dst, std::time_t* t, int* off) {
  127|      0|  std::tm tm;
  128|      0|  tm.tm_year = static_cast<int>(cs.year() - year_t{1900});
  129|      0|  tm.tm_mon = cs.month() - 1;
  130|      0|  tm.tm_mday = cs.day();
  131|      0|  tm.tm_hour = cs.hour();
  132|      0|  tm.tm_min = cs.minute();
  133|      0|  tm.tm_sec = cs.second();
  134|      0|  tm.tm_isdst = is_dst;
  135|      0|  *t = std::mktime(&tm);
  136|      0|  if (*t == std::time_t{-1}) {
  137|      0|    std::tm tm2;
  138|      0|    const std::tm* tmp = local_time(t, &tm2);
  139|      0|    if (tmp == nullptr || tmp->tm_year != tm.tm_year ||
  140|      0|        tmp->tm_mon != tm.tm_mon || tmp->tm_mday != tm.tm_mday ||
  141|      0|        tmp->tm_hour != tm.tm_hour || tmp->tm_min != tm.tm_min ||
  142|      0|        tmp->tm_sec != tm.tm_sec) {
  143|      0|      // A true error (not just one second before the epoch).
  144|      0|      return false;
  145|      0|    }
  146|      0|  }
  147|      0|  *off = static_cast<int>(tm_gmtoff(tm));
  148|      0|  return true;
  149|      0|}
  150|       |
  151|       |// Find the least time_t in [lo:hi] where local time matches offset, given:
  152|       |// (1) lo doesn't match, (2) hi does, and (3) there is only one transition.
  153|      0|std::time_t find_trans(std::time_t lo, std::time_t hi, int offset) {
  154|      0|  std::tm tm;
  155|      0|  while (lo + 1 != hi) {
  156|      0|    const std::time_t mid = lo + (hi - lo) / 2;
  157|      0|    if (std::tm* tmp = local_time(&mid, &tm)) {
  158|      0|      if (tm_gmtoff(*tmp) == offset) {
  159|      0|        hi = mid;
  160|      0|      } else {
  161|      0|        lo = mid;
  162|      0|      }
  163|      0|    } else {
  164|      0|      // If std::tm cannot hold some result we resort to a linear search,
  165|      0|      // ignoring all failed conversions.  Slow, but never really happens.
  166|      0|      while (++lo != hi) {
  167|      0|        if (std::tm* tmp = local_time(&lo, &tm)) {
  168|      0|          if (tm_gmtoff(*tmp) == offset) break;
  169|      0|        }
  170|      0|      }
  171|      0|      return lo;
  172|      0|    }
  173|      0|  }
  174|      0|  return hi;
  175|      0|}
  176|       |
  177|       |}  // namespace
  178|       |
  179|       |TimeZoneLibC::TimeZoneLibC(const std::string& name)
  180|      0|    : local_(name == "localtime") {}
  181|       |
  182|       |time_zone::absolute_lookup TimeZoneLibC::BreakTime(
  183|      0|    const time_point<seconds>& tp) const {
  184|      0|  time_zone::absolute_lookup al;
  185|      0|  al.offset = 0;
  186|      0|  al.is_dst = false;
  187|      0|  al.abbr = "-00";
  188|      0|
  189|      0|  const std::int_fast64_t s = ToUnixSeconds(tp);
  190|      0|
  191|      0|  // If std::time_t cannot hold the input we saturate the output.
  192|      0|  if (s < std::numeric_limits<std::time_t>::min()) {
  193|      0|    al.cs = civil_second::min();
  194|      0|    return al;
  195|      0|  }
  196|      0|  if (s > std::numeric_limits<std::time_t>::max()) {
  197|      0|    al.cs = civil_second::max();
  198|      0|    return al;
  199|      0|  }
  200|      0|
  201|      0|  const std::time_t t = static_cast<std::time_t>(s);
  202|      0|  std::tm tm;
  203|      0|  std::tm* tmp = local_ ? local_time(&t, &tm) : gm_time(&t, &tm);
  204|      0|
  205|      0|  // If std::tm cannot hold the result we saturate the output.
  206|      0|  if (tmp == nullptr) {
  207|      0|    al.cs = (s < 0) ? civil_second::min() : civil_second::max();
  208|      0|    return al;
  209|      0|  }
  210|      0|
  211|      0|  const year_t year = tmp->tm_year + year_t{1900};
  212|      0|  al.cs = civil_second(year, tmp->tm_mon + 1, tmp->tm_mday,
  213|      0|                       tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
  214|      0|  al.offset = static_cast<int>(tm_gmtoff(*tmp));
  215|      0|  al.abbr = local_ ? tm_zone(*tmp) : "UTC";  // as expected by cctz
  216|      0|  al.is_dst = tmp->tm_isdst > 0;
  217|      0|  return al;
  218|      0|}
  219|       |
  220|      0|time_zone::civil_lookup TimeZoneLibC::MakeTime(const civil_second& cs) const {
  221|      0|  if (!local_) {
  222|      0|    // If time_point<seconds> cannot hold the result we saturate.
  223|      0|    static const civil_second min_tp_cs =
  224|      0|        civil_second() + ToUnixSeconds(time_point<seconds>::min());
  225|      0|    static const civil_second max_tp_cs =
  226|      0|        civil_second() + ToUnixSeconds(time_point<seconds>::max());
  227|      0|    const time_point<seconds> tp =
  228|      0|        (cs < min_tp_cs)
  229|      0|            ? time_point<seconds>::min()
  230|      0|            : (cs > max_tp_cs) ? time_point<seconds>::max()
  231|      0|                               : FromUnixSeconds(cs - civil_second());
  232|      0|    return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
  233|      0|  }
  234|      0|
  235|      0|  // If tm_year cannot hold the requested year we saturate the result.
  236|      0|  if (cs.year() < 0) {
  237|      0|    if (cs.year() < std::numeric_limits<int>::min() + year_t{1900}) {
  238|      0|      const time_point<seconds> tp = time_point<seconds>::min();
  239|      0|      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
  240|      0|    }
  241|      0|  } else {
  242|      0|    if (cs.year() - year_t{1900} > std::numeric_limits<int>::max()) {
  243|      0|      const time_point<seconds> tp = time_point<seconds>::max();
  244|      0|      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
  245|      0|    }
  246|      0|  }
  247|      0|
  248|      0|  // We probe with "is_dst" values of 0 and 1 to try to distinguish unique
  249|      0|  // civil seconds from skipped or repeated ones.  This is not always possible
  250|      0|  // however, as the "dst" flag does not change over some offset transitions.
  251|      0|  // We are also subject to the vagaries of mktime() implementations.
  252|      0|  std::time_t t0, t1;
  253|      0|  int offset0, offset1;
  254|      0|  if (make_time(cs, 0, &t0, &offset0) && make_time(cs, 1, &t1, &offset1)) {
  255|      0|    if (t0 == t1) {
  256|      0|      // The civil time was singular (pre == trans == post).
  257|      0|      const time_point<seconds> tp = FromUnixSeconds(t0);
  258|      0|      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
  259|      0|    }
  260|      0|
  261|      0|    if (t0 > t1) {
  262|      0|      std::swap(t0, t1);
  263|      0|      std::swap(offset0, offset1);
  264|      0|    }
  265|      0|    const std::time_t tt = find_trans(t0, t1, offset1);
  266|      0|    const time_point<seconds> trans = FromUnixSeconds(tt);
  267|      0|
  268|      0|    if (offset0 < offset1) {
  269|      0|      // The civil time did not exist (pre >= trans > post).
  270|      0|      const time_point<seconds> pre = FromUnixSeconds(t1);
  271|      0|      const time_point<seconds> post = FromUnixSeconds(t0);
  272|      0|      return {time_zone::civil_lookup::SKIPPED, pre, trans, post};
  273|      0|    }
  274|      0|
  275|      0|    // The civil time was ambiguous (pre < trans <= post).
  276|      0|    const time_point<seconds> pre = FromUnixSeconds(t0);
  277|      0|    const time_point<seconds> post = FromUnixSeconds(t1);
  278|      0|    return {time_zone::civil_lookup::REPEATED, pre, trans, post};
  279|      0|  }
  280|      0|
  281|      0|  // make_time() failed somehow so we saturate the result.
  282|      0|  const time_point<seconds> tp = (cs < civil_second())
  283|      0|                                     ? time_point<seconds>::min()
  284|      0|                                     : time_point<seconds>::max();
  285|      0|  return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
  286|      0|}
  287|       |
  288|       |bool TimeZoneLibC::NextTransition(const time_point<seconds>&,
  289|      0|                                  time_zone::civil_transition*) const {
  290|      0|  return false;
  291|      0|}
  292|       |
  293|       |bool TimeZoneLibC::PrevTransition(const time_point<seconds>&,
  294|      0|                                  time_zone::civil_transition*) const {
  295|      0|  return false;
  296|      0|}
  297|       |
  298|      0|std::string TimeZoneLibC::Version() const {
  299|      0|  return std::string();  // unknown
  300|      0|}
  301|       |
  302|      0|std::string TimeZoneLibC::Description() const {
  303|      0|  return local_ ? "localtime" : "UTC";
  304|      0|}
  305|       |
  306|       |}  // namespace cctz
  307|       |}  // namespace time_internal
  308|       |}  // inline namespace lts_2019_08_08
  309|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_lookup.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#include "absl/time/internal/cctz/include/cctz/time_zone.h"
   16|       |
   17|       |#if defined(__ANDROID__)
   18|       |#include <sys/system_properties.h>
   19|       |#if defined(__ANDROID_API__) && __ANDROID_API__ >= 21
   20|       |#include <dlfcn.h>
   21|       |#endif
   22|       |#endif
   23|       |
   24|       |#if defined(__APPLE__)
   25|       |#include <CoreFoundation/CFTimeZone.h>
   26|       |#include <vector>
   27|       |#endif
   28|       |
   29|       |#include <cstdlib>
   30|       |#include <cstring>
   31|       |#include <string>
   32|       |
   33|       |#include "time_zone_fixed.h"
   34|       |#include "time_zone_impl.h"
   35|       |
   36|       |namespace absl {
   37|       |inline namespace lts_2019_08_08 {
   38|       |namespace time_internal {
   39|       |namespace cctz {
   40|       |
   41|       |#if defined(__ANDROID__) && defined(__ANDROID_API__) && __ANDROID_API__ >= 21
   42|       |namespace {
   43|       |// Android 'L' removes __system_property_get() from the NDK, however
   44|       |// it is still a hidden symbol in libc so we use dlsym() to access it.
   45|       |// See Chromium's base/sys_info_android.cc for a similar example.
   46|       |
   47|       |using property_get_func = int (*)(const char*, char*);
   48|       |
   49|       |property_get_func LoadSystemPropertyGet() {
   50|       |  int flag = RTLD_LAZY | RTLD_GLOBAL;
   51|       |#if defined(RTLD_NOLOAD)
   52|       |  flag |= RTLD_NOLOAD;  // libc.so should already be resident
   53|       |#endif
   54|       |  if (void* handle = dlopen("libc.so", flag)) {
   55|       |    void* sym = dlsym(handle, "__system_property_get");
   56|       |    dlclose(handle);
   57|       |    return reinterpret_cast<property_get_func>(sym);
   58|       |  }
   59|       |  return nullptr;
   60|       |}
   61|       |
   62|       |int __system_property_get(const char* name, char* value) {
   63|       |  static property_get_func system_property_get = LoadSystemPropertyGet();
   64|       |  return system_property_get ? system_property_get(name, value) : -1;
   65|       |}
   66|       |
   67|       |}  // namespace
   68|       |#endif
   69|       |
   70|      0|std::string time_zone::name() const {
   71|      0|  return effective_impl().Name();
   72|      0|}
   73|       |
   74|       |time_zone::absolute_lookup time_zone::lookup(
   75|      0|    const time_point<seconds>& tp) const {
   76|      0|  return effective_impl().BreakTime(tp);
   77|      0|}
   78|       |
   79|      0|time_zone::civil_lookup time_zone::lookup(const civil_second& cs) const {
   80|      0|  return effective_impl().MakeTime(cs);
   81|      0|}
   82|       |
   83|       |bool time_zone::next_transition(const time_point<seconds>& tp,
   84|      0|                                civil_transition* trans) const {
   85|      0|  return effective_impl().NextTransition(tp, trans);
   86|      0|}
   87|       |
   88|       |bool time_zone::prev_transition(const time_point<seconds>& tp,
   89|      0|                                civil_transition* trans) const {
   90|      0|  return effective_impl().PrevTransition(tp, trans);
   91|      0|}
   92|       |
   93|      0|std::string time_zone::version() const {
   94|      0|  return effective_impl().Version();
   95|      0|}
   96|       |
   97|      0|std::string time_zone::description() const {
   98|      0|  return effective_impl().Description();
   99|      0|}
  100|       |
  101|      0|const time_zone::Impl& time_zone::effective_impl() const {
  102|      0|  if (impl_ == nullptr) {
  103|      0|    // Dereferencing an implicit-UTC time_zone is expected to be
  104|      0|    // rare, so we don't mind paying a small synchronization cost.
  105|      0|    return *time_zone::Impl::UTC().impl_;
  106|      0|  }
  107|      0|  return *impl_;
  108|      0|}
  109|       |
  110|      0|bool load_time_zone(const std::string& name, time_zone* tz) {
  111|      0|  return time_zone::Impl::LoadTimeZone(name, tz);
  112|      0|}
  113|       |
  114|      0|time_zone utc_time_zone() {
  115|      0|  return time_zone::Impl::UTC();  // avoid name lookup
  116|      0|}
  117|       |
  118|      0|time_zone fixed_time_zone(const seconds& offset) {
  119|      0|  time_zone tz;
  120|      0|  load_time_zone(FixedOffsetToName(offset), &tz);
  121|      0|  return tz;
  122|      0|}
  123|       |
  124|      0|time_zone local_time_zone() {
  125|      0|  const char* zone = ":localtime";
  126|       |#if defined(__ANDROID__)
  127|       |  char sysprop[PROP_VALUE_MAX];
  128|       |  if (__system_property_get("persist.sys.timezone", sysprop) > 0) {
  129|       |    zone = sysprop;
  130|       |  }
  131|       |#endif
  132|       |#if defined(__APPLE__)
  133|      0|  std::vector<char> buffer;
  134|      0|  CFTimeZoneRef tz_default = CFTimeZoneCopyDefault();
  135|      0|  if (CFStringRef tz_name = CFTimeZoneGetName(tz_default)) {
  136|      0|    CFStringEncoding encoding = kCFStringEncodingUTF8;
  137|      0|    CFIndex length = CFStringGetLength(tz_name);
  138|      0|    buffer.resize(CFStringGetMaximumSizeForEncoding(length, encoding) + 1);
  139|      0|    if (CFStringGetCString(tz_name, &buffer[0], buffer.size(), encoding)) {
  140|      0|      zone = &buffer[0];
  141|      0|    }
  142|      0|  }
  143|      0|  CFRelease(tz_default);
  144|      0|#endif
  145|      0|
  146|      0|  // Allow ${TZ} to override to default zone.
  147|      0|  char* tz_env = nullptr;
  148|       |#if defined(_MSC_VER)
  149|       |  _dupenv_s(&tz_env, nullptr, "TZ");
  150|       |#else
  151|       |  tz_env = std::getenv("TZ");
  152|      0|#endif
  153|      0|  if (tz_env) zone = tz_env;
  154|      0|
  155|      0|  // We only support the "[:]<zone-name>" form.
  156|      0|  if (*zone == ':') ++zone;
  157|      0|
  158|      0|  // Map "localtime" to a system-specific name, but
  159|      0|  // allow ${LOCALTIME} to override the default name.
  160|      0|  char* localtime_env = nullptr;
  161|      0|  if (strcmp(zone, "localtime") == 0) {
  162|       |#if defined(_MSC_VER)
  163|       |    // System-specific default is just "localtime".
  164|       |    _dupenv_s(&localtime_env, nullptr, "LOCALTIME");
  165|       |#else
  166|       |    zone = "/etc/localtime";  // System-specific default.
  167|      0|    localtime_env = std::getenv("LOCALTIME");
  168|      0|#endif
  169|      0|    if (localtime_env) zone = localtime_env;
  170|      0|  }
  171|      0|
  172|      0|  const std::string name = zone;
  173|       |#if defined(_MSC_VER)
  174|       |  free(localtime_env);
  175|       |  free(tz_env);
  176|       |#endif
  177|       |
  178|      0|  time_zone tz;
  179|      0|  load_time_zone(name, &tz);  // Falls back to UTC.
  180|      0|  // TODO: Follow the RFC3339 "Unknown Local Offset Convention" and
  181|      0|  // arrange for %z to generate "-0000" when we don't know the local
  182|      0|  // offset because the load_time_zone() failed and we're using UTC.
  183|      0|  return tz;
  184|      0|}
  185|       |
  186|       |}  // namespace cctz
  187|       |}  // namespace time_internal
  188|       |}  // inline namespace lts_2019_08_08
  189|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/time_zone_posix.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#include "time_zone_posix.h"
   16|       |
   17|       |#include <cstddef>
   18|       |#include <cstring>
   19|       |#include <limits>
   20|       |#include <string>
   21|       |
   22|       |namespace absl {
   23|       |inline namespace lts_2019_08_08 {
   24|       |namespace time_internal {
   25|       |namespace cctz {
   26|       |
   27|       |namespace {
   28|       |
   29|       |const char kDigits[] = "0123456789";
   30|       |
   31|      0|const char* ParseInt(const char* p, int min, int max, int* vp) {
   32|      0|  int value = 0;
   33|      0|  const char* op = p;
   34|      0|  const int kMaxInt = std::numeric_limits<int>::max();
   35|      0|  for (; const char* dp = strchr(kDigits, *p); ++p) {
   36|      0|    int d = static_cast<int>(dp - kDigits);
   37|      0|    if (d >= 10) break;  // '\0'
   38|      0|    if (value > kMaxInt / 10) return nullptr;
   39|      0|    value *= 10;
   40|      0|    if (value > kMaxInt - d) return nullptr;
   41|      0|    value += d;
   42|      0|  }
   43|      0|  if (p == op || value < min || value > max) return nullptr;
   44|      0|  *vp = value;
   45|      0|  return p;
   46|      0|}
   47|       |
   48|       |// abbr = <.*?> | [^-+,\d]{3,}
   49|      0|const char* ParseAbbr(const char* p, std::string* abbr) {
   50|      0|  const char* op = p;
   51|      0|  if (*p == '<') {  // special zoneinfo <...> form
   52|      0|    while (*++p != '>') {
   53|      0|      if (*p == '\0') return nullptr;
   54|      0|    }
   55|      0|    abbr->assign(op + 1, static_cast<std::size_t>(p - op) - 1);
   56|      0|    return ++p;
   57|      0|  }
   58|      0|  while (*p != '\0') {
   59|      0|    if (strchr("-+,", *p)) break;
   60|      0|    if (strchr(kDigits, *p)) break;
   61|      0|    ++p;
   62|      0|  }
   63|      0|  if (p - op < 3) return nullptr;
   64|      0|  abbr->assign(op, static_cast<std::size_t>(p - op));
   65|      0|  return p;
   66|      0|}
   67|       |
   68|       |// offset = [+|-]hh[:mm[:ss]] (aggregated into single seconds value)
   69|       |const char* ParseOffset(const char* p, int min_hour, int max_hour, int sign,
   70|      0|                        std::int_fast32_t* offset) {
   71|      0|  if (p == nullptr) return nullptr;
   72|      0|  if (*p == '+' || *p == '-') {
   73|      0|    if (*p++ == '-') sign = -sign;
   74|      0|  }
   75|      0|  int hours = 0;
   76|      0|  int minutes = 0;
   77|      0|  int seconds = 0;
   78|      0|
   79|      0|  p = ParseInt(p, min_hour, max_hour, &hours);
   80|      0|  if (p == nullptr) return nullptr;
   81|      0|  if (*p == ':') {
   82|      0|    p = ParseInt(p + 1, 0, 59, &minutes);
   83|      0|    if (p == nullptr) return nullptr;
   84|      0|    if (*p == ':') {
   85|      0|      p = ParseInt(p + 1, 0, 59, &seconds);
   86|      0|      if (p == nullptr) return nullptr;
   87|      0|    }
   88|      0|  }
   89|      0|  *offset = sign * ((((hours * 60) + minutes) * 60) + seconds);
   90|      0|  return p;
   91|      0|}
   92|       |
   93|       |// datetime = ( Jn | n | Mm.w.d ) [ / offset ]
   94|      0|const char* ParseDateTime(const char* p, PosixTransition* res) {
   95|      0|  if (p != nullptr && *p == ',') {
   96|      0|    if (*++p == 'M') {
   97|      0|      int month = 0;
   98|      0|      if ((p = ParseInt(p + 1, 1, 12, &month)) != nullptr && *p == '.') {
   99|      0|        int week = 0;
  100|      0|        if ((p = ParseInt(p + 1, 1, 5, &week)) != nullptr && *p == '.') {
  101|      0|          int weekday = 0;
  102|      0|          if ((p = ParseInt(p + 1, 0, 6, &weekday)) != nullptr) {
  103|      0|            res->date.fmt = PosixTransition::M;
  104|      0|            res->date.m.month = static_cast<std::int_fast8_t>(month);
  105|      0|            res->date.m.week = static_cast<std::int_fast8_t>(week);
  106|      0|            res->date.m.weekday = static_cast<std::int_fast8_t>(weekday);
  107|      0|          }
  108|      0|        }
  109|      0|      }
  110|      0|    } else if (*p == 'J') {
  111|      0|      int day = 0;
  112|      0|      if ((p = ParseInt(p + 1, 1, 365, &day)) != nullptr) {
  113|      0|        res->date.fmt = PosixTransition::J;
  114|      0|        res->date.j.day = static_cast<std::int_fast16_t>(day);
  115|      0|      }
  116|      0|    } else {
  117|      0|      int day = 0;
  118|      0|      if ((p = ParseInt(p, 0, 365, &day)) != nullptr) {
  119|      0|        res->date.fmt = PosixTransition::N;
  120|      0|        res->date.n.day = static_cast<std::int_fast16_t>(day);
  121|      0|      }
  122|      0|    }
  123|      0|  }
  124|      0|  if (p != nullptr) {
  125|      0|    res->time.offset = 2 * 60 * 60;  // default offset is 02:00:00
  126|      0|    if (*p == '/') p = ParseOffset(p + 1, -167, 167, 1, &res->time.offset);
  127|      0|  }
  128|      0|  return p;
  129|      0|}
  130|       |
  131|       |}  // namespace
  132|       |
  133|       |// spec = std offset [ dst [ offset ] , datetime , datetime ]
  134|      0|bool ParsePosixSpec(const std::string& spec, PosixTimeZone* res) {
  135|      0|  const char* p = spec.c_str();
  136|      0|  if (*p == ':') return false;
  137|      0|
  138|      0|  p = ParseAbbr(p, &res->std_abbr);
  139|      0|  p = ParseOffset(p, 0, 24, -1, &res->std_offset);
  140|      0|  if (p == nullptr) return false;
  141|      0|  if (*p == '\0') return true;
  142|      0|
  143|      0|  p = ParseAbbr(p, &res->dst_abbr);
  144|      0|  if (p == nullptr) return false;
  145|      0|  res->dst_offset = res->std_offset + (60 * 60);  // default
  146|      0|  if (*p != ',') p = ParseOffset(p, 0, 24, -1, &res->dst_offset);
  147|      0|
  148|      0|  p = ParseDateTime(p, &res->dst_start);
  149|      0|  p = ParseDateTime(p, &res->dst_end);
  150|      0|
  151|      0|  return p != nullptr && *p == '\0';
  152|      0|}
  153|       |
  154|       |}  // namespace cctz
  155|       |}  // namespace time_internal
  156|       |}  // inline namespace lts_2019_08_08
  157|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/tzfile.h:
    1|       |/* Layout and location of TZif files.  */
    2|       |
    3|       |#ifndef TZFILE_H
    4|       |
    5|       |#define TZFILE_H
    6|       |
    7|       |/*
    8|       |** This file is in the public domain, so clarified as of
    9|       |** 1996-06-05 by Arthur David Olson.
   10|       |*/
   11|       |
   12|       |/*
   13|       |** This header is for use ONLY with the time conversion code.
   14|       |** There is no guarantee that it will remain unchanged,
   15|       |** or that it will remain at all.
   16|       |** Do NOT copy it to any system include directory.
   17|       |** Thank you!
   18|       |*/
   19|       |
   20|       |/*
   21|       |** Information about time zone files.
   22|       |*/
   23|       |
   24|       |#ifndef TZDIR
   25|       |#define TZDIR	"/usr/share/zoneinfo" /* Time zone object file directory */
   26|       |#endif /* !defined TZDIR */
   27|       |
   28|       |#ifndef TZDEFAULT
   29|       |#define TZDEFAULT	"/etc/localtime"
   30|       |#endif /* !defined TZDEFAULT */
   31|       |
   32|       |#ifndef TZDEFRULES
   33|       |#define TZDEFRULES	"posixrules"
   34|       |#endif /* !defined TZDEFRULES */
   35|       |
   36|       |
   37|       |/* See Internet RFC 8536 for more details about the following format.  */
   38|       |
   39|       |/*
   40|       |** Each file begins with. . .
   41|       |*/
   42|       |
   43|      0|#define	TZ_MAGIC	"TZif"
   44|       |
   45|       |struct tzhead {
   46|       |	char	tzh_magic[4];		/* TZ_MAGIC */
   47|       |	char	tzh_version[1];		/* '\0' or '2' or '3' as of 2013 */
   48|       |	char	tzh_reserved[15];	/* reserved; must be zero */
   49|       |	char	tzh_ttisutcnt[4];	/* coded number of trans. time flags */
   50|       |	char	tzh_ttisstdcnt[4];	/* coded number of trans. time flags */
   51|       |	char	tzh_leapcnt[4];		/* coded number of leap seconds */
   52|       |	char	tzh_timecnt[4];		/* coded number of transition times */
   53|       |	char	tzh_typecnt[4];		/* coded number of local time types */
   54|       |	char	tzh_charcnt[4];		/* coded number of abbr. chars */
   55|       |};
   56|       |
   57|       |/*
   58|       |** . . .followed by. . .
   59|       |**
   60|       |**	tzh_timecnt (char [4])s		coded transition times a la time(2)
   61|       |**	tzh_timecnt (unsigned char)s	types of local time starting at above
   62|       |**	tzh_typecnt repetitions of
   63|       |**		one (char [4])		coded UT offset in seconds
   64|       |**		one (unsigned char)	used to set tm_isdst
   65|       |**		one (unsigned char)	that's an abbreviation list index
   66|       |**	tzh_charcnt (char)s		'\0'-terminated zone abbreviations
   67|       |**	tzh_leapcnt repetitions of
   68|       |**		one (char [4])		coded leap second transition times
   69|       |**		one (char [4])		total correction after above
   70|       |**	tzh_ttisstdcnt (char)s		indexed by type; if 1, transition
   71|       |**					time is standard time, if 0,
   72|       |**					transition time is local (wall clock)
   73|       |**					time; if absent, transition times are
   74|       |**					assumed to be local time
   75|       |**	tzh_ttisutcnt (char)s		indexed by type; if 1, transition
   76|       |**					time is UT, if 0, transition time is
   77|       |**					local time; if absent, transition
   78|       |**					times are assumed to be local time.
   79|       |**					When this is 1, the corresponding
   80|       |**					std/wall indicator must also be 1.
   81|       |*/
   82|       |
   83|       |/*
   84|       |** If tzh_version is '2' or greater, the above is followed by a second instance
   85|       |** of tzhead and a second instance of the data in which each coded transition
   86|       |** time uses 8 rather than 4 chars,
   87|       |** then a POSIX-TZ-environment-variable-style std::string for use in handling
   88|       |** instants after the last transition time stored in the file
   89|       |** (with nothing between the newlines if there is no POSIX representation for
   90|       |** such instants).
   91|       |**
   92|       |** If tz_version is '3' or greater, the above is extended as follows.
   93|       |** First, the POSIX TZ std::string's hour offset may range from -167
   94|       |** through 167 as compared to the POSIX-required 0 through 24.
   95|       |** Second, its DST start time may be January 1 at 00:00 and its stop
   96|       |** time December 31 at 24:00 plus the difference between DST and
   97|       |** standard time, indicating DST all year.
   98|       |*/
   99|       |
  100|       |/*
  101|       |** In the current implementation, "tzset()" refuses to deal with files that
  102|       |** exceed any of the limits below.
  103|       |*/
  104|       |
  105|       |#ifndef TZ_MAX_TIMES
  106|       |#define TZ_MAX_TIMES	2000
  107|       |#endif /* !defined TZ_MAX_TIMES */
  108|       |
  109|       |#ifndef TZ_MAX_TYPES
  110|       |/* This must be at least 17 for Europe/Samara and Europe/Vilnius.  */
  111|       |#define TZ_MAX_TYPES	256 /* Limited by what (unsigned char)'s can hold */
  112|       |#endif /* !defined TZ_MAX_TYPES */
  113|       |
  114|       |#ifndef TZ_MAX_CHARS
  115|       |#define TZ_MAX_CHARS	50	/* Maximum number of abbreviation characters */
  116|       |				/* (limited by what unsigned chars can hold) */
  117|       |#endif /* !defined TZ_MAX_CHARS */
  118|       |
  119|       |#ifndef TZ_MAX_LEAPS
  120|       |#define TZ_MAX_LEAPS	50	/* Maximum number of leap second corrections */
  121|       |#endif /* !defined TZ_MAX_LEAPS */
  122|       |
  123|       |#endif /* !defined TZFILE_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/cctz/src/zone_info_source.cc:
    1|       |// Copyright 2016 Google Inc. All Rights Reserved.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//   https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |//   Unless required by applicable law or agreed to in writing, software
   10|       |//   distributed under the License is distributed on an "AS IS" BASIS,
   11|       |//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |//   See the License for the specific language governing permissions and
   13|       |//   limitations under the License.
   14|       |
   15|       |#include "absl/time/internal/cctz/include/cctz/zone_info_source.h"
   16|       |
   17|       |namespace absl {
   18|       |inline namespace lts_2019_08_08 {
   19|       |namespace time_internal {
   20|       |namespace cctz {
   21|       |
   22|       |// Defined out-of-line to avoid emitting a weak vtable in all TUs.
   23|      0|ZoneInfoSource::~ZoneInfoSource() {}
   24|      0|std::string ZoneInfoSource::Version() const { return std::string(); }
   25|       |
   26|       |}  // namespace cctz
   27|       |}  // namespace time_internal
   28|       |}  // inline namespace lts_2019_08_08
   29|       |}  // namespace absl
   30|       |
   31|       |namespace absl {
   32|       |inline namespace lts_2019_08_08 {
   33|       |namespace time_internal {
   34|       |namespace cctz_extension {
   35|       |
   36|       |namespace {
   37|       |
   38|       |// A default for cctz_extension::zone_info_source_factory, which simply
   39|       |// defers to the fallback factory.
   40|       |std::unique_ptr<absl::time_internal::cctz::ZoneInfoSource> DefaultFactory(
   41|       |    const std::string& name,
   42|       |    const std::function<std::unique_ptr<absl::time_internal::cctz::ZoneInfoSource>(
   43|      0|        const std::string& name)>& fallback_factory) {
   44|      0|  return fallback_factory(name);
   45|      0|}
   46|       |
   47|       |}  // namespace
   48|       |
   49|       |// A "weak" definition for cctz_extension::zone_info_source_factory.
   50|       |// The user may override this with their own "strong" definition (see
   51|       |// zone_info_source.h).
   52|       |#if !defined(__has_attribute)
   53|       |#define __has_attribute(x) 0
   54|       |#endif
   55|       |#if __has_attribute(weak) || defined(__GNUC__)
   56|       |ZoneInfoSourceFactory zone_info_source_factory
   57|       |    __attribute__((weak)) = DefaultFactory;
   58|       |#elif defined(_MSC_VER) && !defined(_LIBCPP_VERSION)
   59|       |extern ZoneInfoSourceFactory zone_info_source_factory;
   60|       |extern ZoneInfoSourceFactory default_factory;
   61|       |ZoneInfoSourceFactory default_factory = DefaultFactory;
   62|       |#if defined(_M_IX86)
   63|       |#pragma comment( \
   64|       |    linker,      \
   65|       |    "/alternatename:?zone_info_source_factory@cctz_extension@time_internal@lts_2019_08_08@absl@@3P6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@U?$default_delete@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@6@ABV?$function@$$A6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@U?$default_delete@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@6@@ZA=?default_factory@cctz_extension@time_internal@lts_2019_08_08@absl@@3P6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@U?$default_delete@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@6@ABV?$function@$$A6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@U?$default_delete@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@6@@ZA")
   66|       |#elif defined(_M_IA_64) || defined(_M_AMD64) || defined(_M_ARM64)
   67|       |#pragma comment( \
   68|       |    linker,      \
   69|       |    "/alternatename:?zone_info_source_factory@cctz_extension@time_internal@lts_2019_08_08@absl@@3P6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@U?$default_delete@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@6@AEBV?$function@$$A6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@U?$default_delete@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@6@@ZEA=?default_factory@cctz_extension@time_internal@lts_2019_08_08@absl@@3P6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@U?$default_delete@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@6@AEBV?$function@$$A6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@U?$default_delete@VZoneInfoSource@cctz@time_internal@lts_2019_08_08@absl@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@6@@ZEA")
   70|       |#else
   71|       |#error Unsupported MSVC platform
   72|       |#endif  // _M_<PLATFORM>
   73|       |#else
   74|       |// Make it a "strong" definition if we have no other choice.
   75|       |ZoneInfoSourceFactory zone_info_source_factory = DefaultFactory;
   76|       |#endif
   77|       |
   78|       |}  // namespace cctz_extension
   79|       |}  // namespace time_internal
   80|       |}  // inline namespace lts_2019_08_08
   81|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/internal/get_current_time_chrono.inc:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include <chrono>
   16|       |#include <cstdint>
   17|       |
   18|       |namespace absl {
   19|       |inline namespace lts_2019_08_08 {
   20|       |namespace time_internal {
   21|       |
   22|      0|static int64_t GetCurrentTimeNanosFromSystem() {
   23|      0|  return std::chrono::duration_cast<std::chrono::nanoseconds>(
   24|      0|             std::chrono::system_clock::now() -
   25|      0|             std::chrono::system_clock::from_time_t(0))
   26|      0|      .count();
   27|      0|}
   28|       |
   29|       |}  // namespace time_internal
   30|       |}  // inline namespace lts_2019_08_08
   31|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/time.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |// The implementation of the absl::Time class, which is declared in
   16|       |// //absl/time.h.
   17|       |//
   18|       |// The representation for an absl::Time is an absl::Duration offset from the
   19|       |// epoch.  We use the traditional Unix epoch (1970-01-01 00:00:00 +0000)
   20|       |// for convenience, but this is not exposed in the API and could be changed.
   21|       |//
   22|       |// NOTE: To keep type verbosity to a minimum, the following variable naming
   23|       |// conventions are used throughout this file.
   24|       |//
   25|       |// tz: An absl::TimeZone
   26|       |// ci: An absl::TimeZone::CivilInfo
   27|       |// ti: An absl::TimeZone::TimeInfo
   28|       |// cd: An absl::CivilDay or a cctz::civil_day
   29|       |// cs: An absl::CivilSecond or a cctz::civil_second
   30|       |// bd: An absl::Time::Breakdown
   31|       |// cl: A cctz::time_zone::civil_lookup
   32|       |// al: A cctz::time_zone::absolute_lookup
   33|       |
   34|       |#include "absl/time/time.h"
   35|       |
   36|       |#if defined(_MSC_VER)
   37|       |#include <winsock2.h>  // for timeval
   38|       |#endif
   39|       |
   40|       |#include <cstring>
   41|       |#include <ctime>
   42|       |#include <limits>
   43|       |
   44|       |#include "absl/time/internal/cctz/include/cctz/civil_time.h"
   45|       |#include "absl/time/internal/cctz/include/cctz/time_zone.h"
   46|       |
   47|       |namespace cctz = absl::time_internal::cctz;
   48|       |
   49|       |namespace absl {
   50|       |inline namespace lts_2019_08_08 {
   51|       |
   52|       |namespace {
   53|       |
   54|      0|inline cctz::time_point<cctz::seconds> unix_epoch() {
   55|      0|  return std::chrono::time_point_cast<cctz::seconds>(
   56|      0|      std::chrono::system_clock::from_time_t(0));
   57|      0|}
   58|       |
   59|       |// Floors d to the next unit boundary closer to negative infinity.
   60|      0|inline int64_t FloorToUnit(absl::Duration d, absl::Duration unit) {
   61|      0|  absl::Duration rem;
   62|      0|  int64_t q = absl::IDivDuration(d, unit, &rem);
   63|      0|  return (q > 0 ||
   64|      0|          rem >= ZeroDuration() ||
   65|      0|          q == std::numeric_limits<int64_t>::min()) ? q : q - 1;
   66|      0|}
   67|       |
   68|      0|inline absl::Time::Breakdown InfiniteFutureBreakdown() {
   69|      0|  absl::Time::Breakdown bd;
   70|      0|  bd.year = std::numeric_limits<int64_t>::max();
   71|      0|  bd.month = 12;
   72|      0|  bd.day = 31;
   73|      0|  bd.hour = 23;
   74|      0|  bd.minute = 59;
   75|      0|  bd.second = 59;
   76|      0|  bd.subsecond = absl::InfiniteDuration();
   77|      0|  bd.weekday = 4;
   78|      0|  bd.yearday = 365;
   79|      0|  bd.offset = 0;
   80|      0|  bd.is_dst = false;
   81|      0|  bd.zone_abbr = "-00";
   82|      0|  return bd;
   83|      0|}
   84|       |
   85|      0|inline absl::Time::Breakdown InfinitePastBreakdown() {
   86|      0|  Time::Breakdown bd;
   87|      0|  bd.year = std::numeric_limits<int64_t>::min();
   88|      0|  bd.month = 1;
   89|      0|  bd.day = 1;
   90|      0|  bd.hour = 0;
   91|      0|  bd.minute = 0;
   92|      0|  bd.second = 0;
   93|      0|  bd.subsecond = -absl::InfiniteDuration();
   94|      0|  bd.weekday = 7;
   95|      0|  bd.yearday = 1;
   96|      0|  bd.offset = 0;
   97|      0|  bd.is_dst = false;
   98|      0|  bd.zone_abbr = "-00";
   99|      0|  return bd;
  100|      0|}
  101|       |
  102|      0|inline absl::TimeZone::CivilInfo InfiniteFutureCivilInfo() {
  103|      0|  TimeZone::CivilInfo ci;
  104|      0|  ci.cs = CivilSecond::max();
  105|      0|  ci.subsecond = InfiniteDuration();
  106|      0|  ci.offset = 0;
  107|      0|  ci.is_dst = false;
  108|      0|  ci.zone_abbr = "-00";
  109|      0|  return ci;
  110|      0|}
  111|       |
  112|      0|inline absl::TimeZone::CivilInfo InfinitePastCivilInfo() {
  113|      0|  TimeZone::CivilInfo ci;
  114|      0|  ci.cs = CivilSecond::min();
  115|      0|  ci.subsecond = -InfiniteDuration();
  116|      0|  ci.offset = 0;
  117|      0|  ci.is_dst = false;
  118|      0|  ci.zone_abbr = "-00";
  119|      0|  return ci;
  120|      0|}
  121|       |
  122|      0|inline absl::TimeConversion InfiniteFutureTimeConversion() {
  123|      0|  absl::TimeConversion tc;
  124|      0|  tc.pre = tc.trans = tc.post = absl::InfiniteFuture();
  125|      0|  tc.kind = absl::TimeConversion::UNIQUE;
  126|      0|  tc.normalized = true;
  127|      0|  return tc;
  128|      0|}
  129|       |
  130|      0|inline TimeConversion InfinitePastTimeConversion() {
  131|      0|  absl::TimeConversion tc;
  132|      0|  tc.pre = tc.trans = tc.post = absl::InfinitePast();
  133|      0|  tc.kind = absl::TimeConversion::UNIQUE;
  134|      0|  tc.normalized = true;
  135|      0|  return tc;
  136|      0|}
  137|       |
  138|       |// Makes a Time from sec, overflowing to InfiniteFuture/InfinitePast as
  139|       |// necessary. If sec is min/max, then consult cs+tz to check for overlow.
  140|       |Time MakeTimeWithOverflow(const cctz::time_point<cctz::seconds>& sec,
  141|       |                          const cctz::civil_second& cs,
  142|       |                          const cctz::time_zone& tz,
  143|      0|                          bool* normalized = nullptr) {
  144|      0|  const auto max = cctz::time_point<cctz::seconds>::max();
  145|      0|  const auto min = cctz::time_point<cctz::seconds>::min();
  146|      0|  if (sec == max) {
  147|      0|    const auto al = tz.lookup(max);
  148|      0|    if (cs > al.cs) {
  149|      0|      if (normalized) *normalized = true;
  150|      0|      return absl::InfiniteFuture();
  151|      0|    }
  152|      0|  }
  153|      0|  if (sec == min) {
  154|      0|    const auto al = tz.lookup(min);
  155|      0|    if (cs < al.cs) {
  156|      0|      if (normalized) *normalized = true;
  157|      0|      return absl::InfinitePast();
  158|      0|    }
  159|      0|  }
  160|      0|  const auto hi = (sec - unix_epoch()).count();
  161|      0|  return time_internal::FromUnixDuration(time_internal::MakeDuration(hi));
  162|      0|}
  163|       |
  164|       |// Returns Mon=1..Sun=7.
  165|      0|inline int MapWeekday(const cctz::weekday& wd) {
  166|      0|  switch (wd) {
  167|      0|    case cctz::weekday::monday:
  168|      0|      return 1;
  169|      0|    case cctz::weekday::tuesday:
  170|      0|      return 2;
  171|      0|    case cctz::weekday::wednesday:
  172|      0|      return 3;
  173|      0|    case cctz::weekday::thursday:
  174|      0|      return 4;
  175|      0|    case cctz::weekday::friday:
  176|      0|      return 5;
  177|      0|    case cctz::weekday::saturday:
  178|      0|      return 6;
  179|      0|    case cctz::weekday::sunday:
  180|      0|      return 7;
  181|      0|  }
  182|      0|  return 1;
  183|      0|}
  184|       |
  185|       |bool FindTransition(const cctz::time_zone& tz,
  186|       |                    bool (cctz::time_zone::*find_transition)(
  187|       |                        const cctz::time_point<cctz::seconds>& tp,
  188|       |                        cctz::time_zone::civil_transition* trans) const,
  189|      0|                    Time t, TimeZone::CivilTransition* trans) {
  190|      0|  // Transitions are second-aligned, so we can discard any fractional part.
  191|      0|  const auto tp = unix_epoch() + cctz::seconds(ToUnixSeconds(t));
  192|      0|  cctz::time_zone::civil_transition tr;
  193|      0|  if (!(tz.*find_transition)(tp, &tr)) return false;
  194|      0|  trans->from = CivilSecond(tr.from);
  195|      0|  trans->to = CivilSecond(tr.to);
  196|      0|  return true;
  197|      0|}
  198|       |
  199|       |}  // namespace
  200|       |
  201|       |//
  202|       |// Time
  203|       |//
  204|       |
  205|      0|absl::Time::Breakdown Time::In(absl::TimeZone tz) const {
  206|      0|  if (*this == absl::InfiniteFuture()) return InfiniteFutureBreakdown();
  207|      0|  if (*this == absl::InfinitePast()) return InfinitePastBreakdown();
  208|      0|
  209|      0|  const auto tp = unix_epoch() + cctz::seconds(time_internal::GetRepHi(rep_));
  210|      0|  const auto al = cctz::time_zone(tz).lookup(tp);
  211|      0|  const auto cs = al.cs;
  212|      0|  const auto cd = cctz::civil_day(cs);
  213|      0|
  214|      0|  absl::Time::Breakdown bd;
  215|      0|  bd.year = cs.year();
  216|      0|  bd.month = cs.month();
  217|      0|  bd.day = cs.day();
  218|      0|  bd.hour = cs.hour();
  219|      0|  bd.minute = cs.minute();
  220|      0|  bd.second = cs.second();
  221|      0|  bd.subsecond = time_internal::MakeDuration(0, time_internal::GetRepLo(rep_));
  222|      0|  bd.weekday = MapWeekday(cctz::get_weekday(cd));
  223|      0|  bd.yearday = cctz::get_yearday(cd);
  224|      0|  bd.offset = al.offset;
  225|      0|  bd.is_dst = al.is_dst;
  226|      0|  bd.zone_abbr = al.abbr;
  227|      0|  return bd;
  228|      0|}
  229|       |
  230|       |//
  231|       |// Conversions from/to other time types.
  232|       |//
  233|       |
  234|      0|absl::Time FromUDate(double udate) {
  235|      0|  return time_internal::FromUnixDuration(absl::Milliseconds(udate));
  236|      0|}
  237|       |
  238|      0|absl::Time FromUniversal(int64_t universal) {
  239|      0|  return absl::UniversalEpoch() + 100 * absl::Nanoseconds(universal);
  240|      0|}
  241|       |
  242|      0|int64_t ToUnixNanos(Time t) {
  243|      0|  if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&
  244|      0|      time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 33 == 0) {
  245|      0|    return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) *
  246|      0|            1000 * 1000 * 1000) +
  247|      0|           (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) / 4);
  248|      0|  }
  249|      0|  return FloorToUnit(time_internal::ToUnixDuration(t), absl::Nanoseconds(1));
  250|      0|}
  251|       |
  252|      0|int64_t ToUnixMicros(Time t) {
  253|      0|  if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&
  254|      0|      time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 43 == 0) {
  255|      0|    return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) *
  256|      0|            1000 * 1000) +
  257|      0|           (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) / 4000);
  258|      0|  }
  259|      0|  return FloorToUnit(time_internal::ToUnixDuration(t), absl::Microseconds(1));
  260|      0|}
  261|       |
  262|      0|int64_t ToUnixMillis(Time t) {
  263|      0|  if (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >= 0 &&
  264|      0|      time_internal::GetRepHi(time_internal::ToUnixDuration(t)) >> 53 == 0) {
  265|      0|    return (time_internal::GetRepHi(time_internal::ToUnixDuration(t)) * 1000) +
  266|      0|           (time_internal::GetRepLo(time_internal::ToUnixDuration(t)) /
  267|      0|            (4000 * 1000));
  268|      0|  }
  269|      0|  return FloorToUnit(time_internal::ToUnixDuration(t), absl::Milliseconds(1));
  270|      0|}
  271|       |
  272|      0|int64_t ToUnixSeconds(Time t) {
  273|      0|  return time_internal::GetRepHi(time_internal::ToUnixDuration(t));
  274|      0|}
  275|       |
  276|      0|time_t ToTimeT(Time t) { return absl::ToTimespec(t).tv_sec; }
  277|       |
  278|      0|double ToUDate(Time t) {
  279|      0|  return absl::FDivDuration(time_internal::ToUnixDuration(t),
  280|      0|                            absl::Milliseconds(1));
  281|      0|}
  282|       |
  283|      0|int64_t ToUniversal(absl::Time t) {
  284|      0|  return absl::FloorToUnit(t - absl::UniversalEpoch(), absl::Nanoseconds(100));
  285|      0|}
  286|       |
  287|      0|absl::Time TimeFromTimespec(timespec ts) {
  288|      0|  return time_internal::FromUnixDuration(absl::DurationFromTimespec(ts));
  289|      0|}
  290|       |
  291|      0|absl::Time TimeFromTimeval(timeval tv) {
  292|      0|  return time_internal::FromUnixDuration(absl::DurationFromTimeval(tv));
  293|      0|}
  294|       |
  295|      0|timespec ToTimespec(Time t) {
  296|      0|  timespec ts;
  297|      0|  absl::Duration d = time_internal::ToUnixDuration(t);
  298|      0|  if (!time_internal::IsInfiniteDuration(d)) {
  299|      0|    ts.tv_sec = time_internal::GetRepHi(d);
  300|      0|    if (ts.tv_sec == time_internal::GetRepHi(d)) {  // no time_t narrowing
  301|      0|      ts.tv_nsec = time_internal::GetRepLo(d) / 4;  // floor
  302|      0|      return ts;
  303|      0|    }
  304|      0|  }
  305|      0|  if (d >= absl::ZeroDuration()) {
  306|      0|    ts.tv_sec = std::numeric_limits<time_t>::max();
  307|      0|    ts.tv_nsec = 1000 * 1000 * 1000 - 1;
  308|      0|  } else {
  309|      0|    ts.tv_sec = std::numeric_limits<time_t>::min();
  310|      0|    ts.tv_nsec = 0;
  311|      0|  }
  312|      0|  return ts;
  313|      0|}
  314|       |
  315|      0|timeval ToTimeval(Time t) {
  316|      0|  timeval tv;
  317|      0|  timespec ts = absl::ToTimespec(t);
  318|      0|  tv.tv_sec = ts.tv_sec;
  319|      0|  if (tv.tv_sec != ts.tv_sec) {  // narrowing
  320|      0|    if (ts.tv_sec < 0) {
  321|      0|      tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::min();
  322|      0|      tv.tv_usec = 0;
  323|      0|    } else {
  324|      0|      tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::max();
  325|      0|      tv.tv_usec = 1000 * 1000 - 1;
  326|      0|    }
  327|      0|    return tv;
  328|      0|  }
  329|      0|  tv.tv_usec = static_cast<int>(ts.tv_nsec / 1000);  // suseconds_t
  330|      0|  return tv;
  331|      0|}
  332|       |
  333|      0|Time FromChrono(const std::chrono::system_clock::time_point& tp) {
  334|      0|  return time_internal::FromUnixDuration(time_internal::FromChrono(
  335|      0|      tp - std::chrono::system_clock::from_time_t(0)));
  336|      0|}
  337|       |
  338|      0|std::chrono::system_clock::time_point ToChronoTime(absl::Time t) {
  339|      0|  using D = std::chrono::system_clock::duration;
  340|      0|  auto d = time_internal::ToUnixDuration(t);
  341|      0|  if (d < ZeroDuration()) d = Floor(d, FromChrono(D{1}));
  342|      0|  return std::chrono::system_clock::from_time_t(0) +
  343|      0|         time_internal::ToChronoDuration<D>(d);
  344|      0|}
  345|       |
  346|       |//
  347|       |// TimeZone
  348|       |//
  349|       |
  350|      0|absl::TimeZone::CivilInfo TimeZone::At(Time t) const {
  351|      0|  if (t == absl::InfiniteFuture()) return InfiniteFutureCivilInfo();
  352|      0|  if (t == absl::InfinitePast()) return InfinitePastCivilInfo();
  353|      0|
  354|      0|  const auto ud = time_internal::ToUnixDuration(t);
  355|      0|  const auto tp = unix_epoch() + cctz::seconds(time_internal::GetRepHi(ud));
  356|      0|  const auto al = cz_.lookup(tp);
  357|      0|
  358|      0|  TimeZone::CivilInfo ci;
  359|      0|  ci.cs = CivilSecond(al.cs);
  360|      0|  ci.subsecond = time_internal::MakeDuration(0, time_internal::GetRepLo(ud));
  361|      0|  ci.offset = al.offset;
  362|      0|  ci.is_dst = al.is_dst;
  363|      0|  ci.zone_abbr = al.abbr;
  364|      0|  return ci;
  365|      0|}
  366|       |
  367|      0|absl::TimeZone::TimeInfo TimeZone::At(CivilSecond ct) const {
  368|      0|  const cctz::civil_second cs(ct);
  369|      0|  const auto cl = cz_.lookup(cs);
  370|      0|
  371|      0|  TimeZone::TimeInfo ti;
  372|      0|  switch (cl.kind) {
  373|      0|    case cctz::time_zone::civil_lookup::UNIQUE:
  374|      0|      ti.kind = TimeZone::TimeInfo::UNIQUE;
  375|      0|      break;
  376|      0|    case cctz::time_zone::civil_lookup::SKIPPED:
  377|      0|      ti.kind = TimeZone::TimeInfo::SKIPPED;
  378|      0|      break;
  379|      0|    case cctz::time_zone::civil_lookup::REPEATED:
  380|      0|      ti.kind = TimeZone::TimeInfo::REPEATED;
  381|      0|      break;
  382|      0|  }
  383|      0|  ti.pre = MakeTimeWithOverflow(cl.pre, cs, cz_);
  384|      0|  ti.trans = MakeTimeWithOverflow(cl.trans, cs, cz_);
  385|      0|  ti.post = MakeTimeWithOverflow(cl.post, cs, cz_);
  386|      0|  return ti;
  387|      0|}
  388|       |
  389|      0|bool TimeZone::NextTransition(Time t, CivilTransition* trans) const {
  390|      0|  return FindTransition(cz_, &cctz::time_zone::next_transition, t, trans);
  391|      0|}
  392|       |
  393|      0|bool TimeZone::PrevTransition(Time t, CivilTransition* trans) const {
  394|      0|  return FindTransition(cz_, &cctz::time_zone::prev_transition, t, trans);
  395|      0|}
  396|       |
  397|       |//
  398|       |// Conversions involving time zones.
  399|       |//
  400|       |
  401|       |absl::TimeConversion ConvertDateTime(int64_t year, int mon, int day, int hour,
  402|      0|                                     int min, int sec, TimeZone tz) {
  403|      0|  // Avoids years that are too extreme for CivilSecond to normalize.
  404|      0|  if (year > 300000000000) return InfiniteFutureTimeConversion();
  405|      0|  if (year < -300000000000) return InfinitePastTimeConversion();
  406|      0|
  407|      0|  const CivilSecond cs(year, mon, day, hour, min, sec);
  408|      0|  const auto ti = tz.At(cs);
  409|      0|
  410|      0|  TimeConversion tc;
  411|      0|  tc.pre = ti.pre;
  412|      0|  tc.trans = ti.trans;
  413|      0|  tc.post = ti.post;
  414|      0|  switch (ti.kind) {
  415|      0|    case TimeZone::TimeInfo::UNIQUE:
  416|      0|      tc.kind = TimeConversion::UNIQUE;
  417|      0|      break;
  418|      0|    case TimeZone::TimeInfo::SKIPPED:
  419|      0|      tc.kind = TimeConversion::SKIPPED;
  420|      0|      break;
  421|      0|    case TimeZone::TimeInfo::REPEATED:
  422|      0|      tc.kind = TimeConversion::REPEATED;
  423|      0|      break;
  424|      0|  }
  425|      0|  tc.normalized = false;
  426|      0|  if (year != cs.year() || mon != cs.month() || day != cs.day() ||
  427|      0|      hour != cs.hour() || min != cs.minute() || sec != cs.second()) {
  428|      0|    tc.normalized = true;
  429|      0|  }
  430|      0|  return tc;
  431|      0|}
  432|       |
  433|      0|absl::Time FromTM(const struct tm& tm, absl::TimeZone tz) {
  434|      0|  const CivilSecond cs(tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
  435|      0|                       tm.tm_hour, tm.tm_min, tm.tm_sec);
  436|      0|  const auto ti = tz.At(cs);
  437|      0|  return tm.tm_isdst == 0 ? ti.post : ti.pre;
  438|      0|}
  439|       |
  440|      0|struct tm ToTM(absl::Time t, absl::TimeZone tz) {
  441|      0|  struct tm tm = {};
  442|      0|
  443|      0|  const auto ci = tz.At(t);
  444|      0|  const auto& cs = ci.cs;
  445|      0|  tm.tm_sec = cs.second();
  446|      0|  tm.tm_min = cs.minute();
  447|      0|  tm.tm_hour = cs.hour();
  448|      0|  tm.tm_mday = cs.day();
  449|      0|  tm.tm_mon = cs.month() - 1;
  450|      0|
  451|      0|  // Saturates tm.tm_year in cases of over/underflow, accounting for the fact
  452|      0|  // that tm.tm_year is years since 1900.
  453|      0|  if (cs.year() < std::numeric_limits<int>::min() + 1900) {
  454|      0|    tm.tm_year = std::numeric_limits<int>::min();
  455|      0|  } else if (cs.year() > std::numeric_limits<int>::max()) {
  456|      0|    tm.tm_year = std::numeric_limits<int>::max() - 1900;
  457|      0|  } else {
  458|      0|    tm.tm_year = static_cast<int>(cs.year() - 1900);
  459|      0|  }
  460|      0|
  461|      0|  switch (GetWeekday(cs)) {
  462|      0|    case Weekday::sunday:
  463|      0|      tm.tm_wday = 0;
  464|      0|      break;
  465|      0|    case Weekday::monday:
  466|      0|      tm.tm_wday = 1;
  467|      0|      break;
  468|      0|    case Weekday::tuesday:
  469|      0|      tm.tm_wday = 2;
  470|      0|      break;
  471|      0|    case Weekday::wednesday:
  472|      0|      tm.tm_wday = 3;
  473|      0|      break;
  474|      0|    case Weekday::thursday:
  475|      0|      tm.tm_wday = 4;
  476|      0|      break;
  477|      0|    case Weekday::friday:
  478|      0|      tm.tm_wday = 5;
  479|      0|      break;
  480|      0|    case Weekday::saturday:
  481|      0|      tm.tm_wday = 6;
  482|      0|      break;
  483|      0|  }
  484|      0|  tm.tm_yday = GetYearDay(cs) - 1;
  485|      0|  tm.tm_isdst = ci.is_dst ? 1 : 0;
  486|      0|
  487|      0|  return tm;
  488|      0|}
  489|       |
  490|       |}  // inline namespace lts_2019_08_08
  491|       |}  // namespace absl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/time/time.h:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// -----------------------------------------------------------------------------
   16|       |// File: time.h
   17|       |// -----------------------------------------------------------------------------
   18|       |//
   19|       |// This header file defines abstractions for computing with absolute points
   20|       |// in time, durations of time, and formatting and parsing time within a given
   21|       |// time zone. The following abstractions are defined:
   22|       |//
   23|       |//  * `absl::Time` defines an absolute, specific instance in time
   24|       |//  * `absl::Duration` defines a signed, fixed-length span of time
   25|       |//  * `absl::TimeZone` defines geopolitical time zone regions (as collected
   26|       |//     within the IANA Time Zone database (https://www.iana.org/time-zones)).
   27|       |//
   28|       |// Note: Absolute times are distinct from civil times, which refer to the
   29|       |// human-scale time commonly represented by `YYYY-MM-DD hh:mm:ss`. The mapping
   30|       |// between absolute and civil times can be specified by use of time zones
   31|       |// (`absl::TimeZone` within this API). That is:
   32|       |//
   33|       |//   Civil Time = F(Absolute Time, Time Zone)
   34|       |//   Absolute Time = G(Civil Time, Time Zone)
   35|       |//
   36|       |// See civil_time.h for abstractions related to constructing and manipulating
   37|       |// civil time.
   38|       |//
   39|       |// Example:
   40|       |//
   41|       |//   absl::TimeZone nyc;
   42|       |//   // LoadTimeZone() may fail so it's always better to check for success.
   43|       |//   if (!absl::LoadTimeZone("America/New_York", &nyc)) {
   44|       |//      // handle error case
   45|       |//   }
   46|       |//
   47|       |//   // My flight leaves NYC on Jan 2, 2017 at 03:04:05
   48|       |//   absl::CivilSecond cs(2017, 1, 2, 3, 4, 5);
   49|       |//   absl::Time takeoff = absl::FromCivil(cs, nyc);
   50|       |//
   51|       |//   absl::Duration flight_duration = absl::Hours(21) + absl::Minutes(35);
   52|       |//   absl::Time landing = takeoff + flight_duration;
   53|       |//
   54|       |//   absl::TimeZone syd;
   55|       |//   if (!absl::LoadTimeZone("Australia/Sydney", &syd)) {
   56|       |//      // handle error case
   57|       |//   }
   58|       |//   std::string s = absl::FormatTime(
   59|       |//       "My flight will land in Sydney on %Y-%m-%d at %H:%M:%S",
   60|       |//       landing, syd);
   61|       |
   62|       |#ifndef ABSL_TIME_TIME_H_
   63|       |#define ABSL_TIME_TIME_H_
   64|       |
   65|       |#if !defined(_MSC_VER)
   66|       |#include <sys/time.h>
   67|       |#else
   68|       |// We don't include `winsock2.h` because it drags in `windows.h` and friends,
   69|       |// and they define conflicting macros like OPAQUE, ERROR, and more. This has the
   70|       |// potential to break Abseil users.
   71|       |//
   72|       |// Instead we only forward declare `timeval` and require Windows users include
   73|       |// `winsock2.h` themselves. This is both inconsistent and troublesome, but so is
   74|       |// including 'windows.h' so we are picking the lesser of two evils here.
   75|       |struct timeval;
   76|       |#endif
   77|       |#include <chrono>  // NOLINT(build/c++11)
   78|       |#include <cmath>
   79|       |#include <cstdint>
   80|       |#include <ctime>
   81|       |#include <ostream>
   82|       |#include <string>
   83|       |#include <type_traits>
   84|       |#include <utility>
   85|       |
   86|       |#include "absl/strings/string_view.h"
   87|       |#include "absl/time/civil_time.h"
   88|       |#include "absl/time/internal/cctz/include/cctz/time_zone.h"
   89|       |
   90|       |namespace absl {
   91|       |inline namespace lts_2019_08_08 {
   92|       |
   93|       |class Duration;  // Defined below
   94|       |class Time;      // Defined below
   95|       |class TimeZone;  // Defined below
   96|       |
   97|       |namespace time_internal {
   98|       |int64_t IDivDuration(bool satq, Duration num, Duration den, Duration* rem);
   99|       |constexpr Time FromUnixDuration(Duration d);
  100|       |constexpr Duration ToUnixDuration(Time t);
  101|       |constexpr int64_t GetRepHi(Duration d);
  102|       |constexpr uint32_t GetRepLo(Duration d);
  103|       |constexpr Duration MakeDuration(int64_t hi, uint32_t lo);
  104|       |constexpr Duration MakeDuration(int64_t hi, int64_t lo);
  105|       |inline Duration MakePosDoubleDuration(double n);
  106|       |constexpr int64_t kTicksPerNanosecond = 4;
  107|       |constexpr int64_t kTicksPerSecond = 1000 * 1000 * 1000 * kTicksPerNanosecond;
  108|       |template <std::intmax_t N>
  109|       |constexpr Duration FromInt64(int64_t v, std::ratio<1, N>);
  110|       |constexpr Duration FromInt64(int64_t v, std::ratio<60>);
  111|       |constexpr Duration FromInt64(int64_t v, std::ratio<3600>);
  112|       |template <typename T>
  113|       |using EnableIfIntegral = typename std::enable_if<
  114|       |    std::is_integral<T>::value || std::is_enum<T>::value, int>::type;
  115|       |template <typename T>
  116|       |using EnableIfFloat =
  117|       |    typename std::enable_if<std::is_floating_point<T>::value, int>::type;
  118|       |}  // namespace time_internal
  119|       |
  120|       |// Duration
  121|       |//
  122|       |// The `absl::Duration` class represents a signed, fixed-length span of time.
  123|       |// A `Duration` is generated using a unit-specific factory function, or is
  124|       |// the result of subtracting one `absl::Time` from another. Durations behave
  125|       |// like unit-safe integers and they support all the natural integer-like
  126|       |// arithmetic operations. Arithmetic overflows and saturates at +/- infinity.
  127|       |// `Duration` should be passed by value rather than const reference.
  128|       |//
  129|       |// Factory functions `Nanoseconds()`, `Microseconds()`, `Milliseconds()`,
  130|       |// `Seconds()`, `Minutes()`, `Hours()` and `InfiniteDuration()` allow for
  131|       |// creation of constexpr `Duration` values
  132|       |//
  133|       |// Examples:
  134|       |//
  135|       |//   constexpr absl::Duration ten_ns = absl::Nanoseconds(10);
  136|       |//   constexpr absl::Duration min = absl::Minutes(1);
  137|       |//   constexpr absl::Duration hour = absl::Hours(1);
  138|       |//   absl::Duration dur = 60 * min;  // dur == hour
  139|       |//   absl::Duration half_sec = absl::Milliseconds(500);
  140|       |//   absl::Duration quarter_sec = 0.25 * absl::Seconds(1);
  141|       |//
  142|       |// `Duration` values can be easily converted to an integral number of units
  143|       |// using the division operator.
  144|       |//
  145|       |// Example:
  146|       |//
  147|       |//   constexpr absl::Duration dur = absl::Milliseconds(1500);
  148|       |//   int64_t ns = dur / absl::Nanoseconds(1);   // ns == 1500000000
  149|       |//   int64_t ms = dur / absl::Milliseconds(1);  // ms == 1500
  150|       |//   int64_t sec = dur / absl::Seconds(1);    // sec == 1 (subseconds truncated)
  151|       |//   int64_t min = dur / absl::Minutes(1);    // min == 0
  152|       |//
  153|       |// See the `IDivDuration()` and `FDivDuration()` functions below for details on
  154|       |// how to access the fractional parts of the quotient.
  155|       |//
  156|       |// Alternatively, conversions can be performed using helpers such as
  157|       |// `ToInt64Microseconds()` and `ToDoubleSeconds()`.
  158|       |class Duration {
  159|       | public:
  160|       |  // Value semantics.
  161|      0|  constexpr Duration() : rep_hi_(0), rep_lo_(0) {}  // zero-length duration
  162|       |
  163|       |  // Copyable.
  164|       |#if !defined(__clang__) && defined(_MSC_VER) && _MSC_VER < 1910
  165|       |  // Explicitly defining the constexpr copy constructor avoids an MSVC bug.
  166|       |  constexpr Duration(const Duration& d)
  167|       |      : rep_hi_(d.rep_hi_), rep_lo_(d.rep_lo_) {}
  168|       |#else
  169|       |  constexpr Duration(const Duration& d) = default;
  170|       |#endif
  171|       |  Duration& operator=(const Duration& d) = default;
  172|       |
  173|       |  // Compound assignment operators.
  174|       |  Duration& operator+=(Duration d);
  175|       |  Duration& operator-=(Duration d);
  176|       |  Duration& operator*=(int64_t r);
  177|       |  Duration& operator*=(double r);
  178|       |  Duration& operator/=(int64_t r);
  179|       |  Duration& operator/=(double r);
  180|       |  Duration& operator%=(Duration rhs);
  181|       |
  182|       |  // Overloads that forward to either the int64_t or double overloads above.
  183|       |  // Integer operands must be representable as int64_t.
  184|       |  template <typename T>
  185|      0|  Duration& operator*=(T r) {
  186|      0|    int64_t x = r;
  187|      0|    return *this *= x;
  188|      0|  }
  189|       |  template <typename T>
  190|       |  Duration& operator/=(T r) {
  191|       |    int64_t x = r;
  192|       |    return *this /= x;
  193|       |  }
  194|      0|  Duration& operator*=(float r) { return *this *= static_cast<double>(r); }
  195|      0|  Duration& operator/=(float r) { return *this /= static_cast<double>(r); }
  196|       |
  197|       |  template <typename H>
  198|       |  friend H AbslHashValue(H h, Duration d) {
  199|       |    return H::combine(std::move(h), d.rep_hi_, d.rep_lo_);
  200|       |  }
  201|       |
  202|       | private:
  203|       |  friend constexpr int64_t time_internal::GetRepHi(Duration d);
  204|       |  friend constexpr uint32_t time_internal::GetRepLo(Duration d);
  205|       |  friend constexpr Duration time_internal::MakeDuration(int64_t hi,
  206|       |                                                        uint32_t lo);
  207|      0|  constexpr Duration(int64_t hi, uint32_t lo) : rep_hi_(hi), rep_lo_(lo) {}
  208|       |  int64_t rep_hi_;
  209|       |  uint32_t rep_lo_;
  210|       |};
  211|       |
  212|       |// Relational Operators
  213|       |constexpr bool operator<(Duration lhs, Duration rhs);
  214|      0|constexpr bool operator>(Duration lhs, Duration rhs) { return rhs < lhs; }
  215|      0|constexpr bool operator>=(Duration lhs, Duration rhs) { return !(lhs < rhs); }
  216|      0|constexpr bool operator<=(Duration lhs, Duration rhs) { return !(rhs < lhs); }
  217|       |constexpr bool operator==(Duration lhs, Duration rhs);
  218|      0|constexpr bool operator!=(Duration lhs, Duration rhs) { return !(lhs == rhs); }
  219|       |
  220|       |// Additive Operators
  221|       |constexpr Duration operator-(Duration d);
  222|      0|inline Duration operator+(Duration lhs, Duration rhs) { return lhs += rhs; }
  223|      0|inline Duration operator-(Duration lhs, Duration rhs) { return lhs -= rhs; }
  224|       |
  225|       |// Multiplicative Operators
  226|       |// Integer operands must be representable as int64_t.
  227|       |template <typename T>
  228|       |Duration operator*(Duration lhs, T rhs) {
  229|       |  return lhs *= rhs;
  230|       |}
  231|       |template <typename T>
  232|      0|Duration operator*(T lhs, Duration rhs) {
  233|      0|  return rhs *= lhs;
  234|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_08mlIiEENS0_8DurationET_S2_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_08mlIxEENS0_8DurationET_S2_
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_08mlIdEENS0_8DurationET_S2_
  ------------------
  235|       |template <typename T>
  236|      0|Duration operator/(Duration lhs, T rhs) {
  237|      0|  return lhs /= rhs;
  238|      0|}
  239|      0|inline int64_t operator/(Duration lhs, Duration rhs) {
  240|      0|  return time_internal::IDivDuration(true, lhs, rhs,
  241|      0|                                     &lhs);  // trunc towards zero
  242|      0|}
  243|      0|inline Duration operator%(Duration lhs, Duration rhs) { return lhs %= rhs; }
  244|       |
  245|       |// IDivDuration()
  246|       |//
  247|       |// Divides a numerator `Duration` by a denominator `Duration`, returning the
  248|       |// quotient and remainder. The remainder always has the same sign as the
  249|       |// numerator. The returned quotient and remainder respect the identity:
  250|       |//
  251|       |//   numerator = denominator * quotient + remainder
  252|       |//
  253|       |// Returned quotients are capped to the range of `int64_t`, with the difference
  254|       |// spilling into the remainder to uphold the above identity. This means that the
  255|       |// remainder returned could differ from the remainder returned by
  256|       |// `Duration::operator%` for huge quotients.
  257|       |//
  258|       |// See also the notes on `InfiniteDuration()` below regarding the behavior of
  259|       |// division involving zero and infinite durations.
  260|       |//
  261|       |// Example:
  262|       |//
  263|       |//   constexpr absl::Duration a =
  264|       |//       absl::Seconds(std::numeric_limits<int64_t>::max());  // big
  265|       |//   constexpr absl::Duration b = absl::Nanoseconds(1);       // small
  266|       |//
  267|       |//   absl::Duration rem = a % b;
  268|       |//   // rem == absl::ZeroDuration()
  269|       |//
  270|       |//   // Here, q would overflow int64_t, so rem accounts for the difference.
  271|       |//   int64_t q = absl::IDivDuration(a, b, &rem);
  272|       |//   // q == std::numeric_limits<int64_t>::max(), rem == a - b * q
  273|      0|inline int64_t IDivDuration(Duration num, Duration den, Duration* rem) {
  274|      0|  return time_internal::IDivDuration(true, num, den,
  275|      0|                                     rem);  // trunc towards zero
  276|      0|}
  277|       |
  278|       |// FDivDuration()
  279|       |//
  280|       |// Divides a `Duration` numerator into a fractional number of units of a
  281|       |// `Duration` denominator.
  282|       |//
  283|       |// See also the notes on `InfiniteDuration()` below regarding the behavior of
  284|       |// division involving zero and infinite durations.
  285|       |//
  286|       |// Example:
  287|       |//
  288|       |//   double d = absl::FDivDuration(absl::Milliseconds(1500), absl::Seconds(1));
  289|       |//   // d == 1.5
  290|       |double FDivDuration(Duration num, Duration den);
  291|       |
  292|       |// ZeroDuration()
  293|       |//
  294|       |// Returns a zero-length duration. This function behaves just like the default
  295|       |// constructor, but the name helps make the semantics clear at call sites.
  296|      0|constexpr Duration ZeroDuration() { return Duration(); }
  297|       |
  298|       |// AbsDuration()
  299|       |//
  300|       |// Returns the absolute value of a duration.
  301|      0|inline Duration AbsDuration(Duration d) {
  302|      0|  return (d < ZeroDuration()) ? -d : d;
  303|      0|}
  304|       |
  305|       |// Trunc()
  306|       |//
  307|       |// Truncates a duration (toward zero) to a multiple of a non-zero unit.
  308|       |//
  309|       |// Example:
  310|       |//
  311|       |//   absl::Duration d = absl::Nanoseconds(123456789);
  312|       |//   absl::Duration a = absl::Trunc(d, absl::Microseconds(1));  // 123456us
  313|       |Duration Trunc(Duration d, Duration unit);
  314|       |
  315|       |// Floor()
  316|       |//
  317|       |// Floors a duration using the passed duration unit to its largest value not
  318|       |// greater than the duration.
  319|       |//
  320|       |// Example:
  321|       |//
  322|       |//   absl::Duration d = absl::Nanoseconds(123456789);
  323|       |//   absl::Duration b = absl::Floor(d, absl::Microseconds(1));  // 123456us
  324|       |Duration Floor(Duration d, Duration unit);
  325|       |
  326|       |// Ceil()
  327|       |//
  328|       |// Returns the ceiling of a duration using the passed duration unit to its
  329|       |// smallest value not less than the duration.
  330|       |//
  331|       |// Example:
  332|       |//
  333|       |//   absl::Duration d = absl::Nanoseconds(123456789);
  334|       |//   absl::Duration c = absl::Ceil(d, absl::Microseconds(1));   // 123457us
  335|       |Duration Ceil(Duration d, Duration unit);
  336|       |
  337|       |// InfiniteDuration()
  338|       |//
  339|       |// Returns an infinite `Duration`.  To get a `Duration` representing negative
  340|       |// infinity, use `-InfiniteDuration()`.
  341|       |//
  342|       |// Duration arithmetic overflows to +/- infinity and saturates. In general,
  343|       |// arithmetic with `Duration` infinities is similar to IEEE 754 infinities
  344|       |// except where IEEE 754 NaN would be involved, in which case +/-
  345|       |// `InfiniteDuration()` is used in place of a "nan" Duration.
  346|       |//
  347|       |// Examples:
  348|       |//
  349|       |//   constexpr absl::Duration inf = absl::InfiniteDuration();
  350|       |//   const absl::Duration d = ... any finite duration ...
  351|       |//
  352|       |//   inf == inf + inf
  353|       |//   inf == inf + d
  354|       |//   inf == inf - inf
  355|       |//   -inf == d - inf
  356|       |//
  357|       |//   inf == d * 1e100
  358|       |//   inf == inf / 2
  359|       |//   0 == d / inf
  360|       |//   INT64_MAX == inf / d
  361|       |//
  362|       |//   d < inf
  363|       |//   -inf < d
  364|       |//
  365|       |//   // Division by zero returns infinity, or INT64_MIN/MAX where appropriate.
  366|       |//   inf == d / 0
  367|       |//   INT64_MAX == d / absl::ZeroDuration()
  368|       |//
  369|       |// The examples involving the `/` operator above also apply to `IDivDuration()`
  370|       |// and `FDivDuration()`.
  371|       |constexpr Duration InfiniteDuration();
  372|       |
  373|       |// Nanoseconds()
  374|       |// Microseconds()
  375|       |// Milliseconds()
  376|       |// Seconds()
  377|       |// Minutes()
  378|       |// Hours()
  379|       |//
  380|       |// Factory functions for constructing `Duration` values from an integral number
  381|       |// of the unit indicated by the factory function's name. The number must be
  382|       |// representable as int64_t.
  383|       |//
  384|       |// Note: no "Days()" factory function exists because "a day" is ambiguous.
  385|       |// Civil days are not always 24 hours long, and a 24-hour duration often does
  386|       |// not correspond with a civil day. If a 24-hour duration is needed, use
  387|       |// `absl::Hours(24)`. (If you actually want a civil day, use absl::CivilDay
  388|       |// from civil_time.h.)
  389|       |//
  390|       |// Example:
  391|       |//
  392|       |//   absl::Duration a = absl::Seconds(60);
  393|       |//   absl::Duration b = absl::Minutes(1);  // b == a
  394|       |constexpr Duration Nanoseconds(int64_t n);
  395|       |constexpr Duration Microseconds(int64_t n);
  396|       |constexpr Duration Milliseconds(int64_t n);
  397|       |constexpr Duration Seconds(int64_t n);
  398|       |constexpr Duration Minutes(int64_t n);
  399|       |constexpr Duration Hours(int64_t n);
  400|       |
  401|       |// Factory overloads for constructing `Duration` values from a floating-point
  402|       |// number of the unit indicated by the factory function's name. These functions
  403|       |// exist for convenience, but they are not as efficient as the integral
  404|       |// factories, which should be preferred.
  405|       |//
  406|       |// Example:
  407|       |//
  408|       |//   auto a = absl::Seconds(1.5);        // OK
  409|       |//   auto b = absl::Milliseconds(1500);  // BETTER
  410|       |template <typename T, time_internal::EnableIfFloat<T> = 0>
  411|       |Duration Nanoseconds(T n) {
  412|       |  return n * Nanoseconds(1);
  413|       |}
  414|       |template <typename T, time_internal::EnableIfFloat<T> = 0>
  415|       |Duration Microseconds(T n) {
  416|       |  return n * Microseconds(1);
  417|       |}
  418|       |template <typename T, time_internal::EnableIfFloat<T> = 0>
  419|      0|Duration Milliseconds(T n) {
  420|      0|  return n * Milliseconds(1);
  421|      0|}
  422|       |template <typename T, time_internal::EnableIfFloat<T> = 0>
  423|       |Duration Seconds(T n) {
  424|       |  if (n >= 0) {  // Note: `NaN >= 0` is false.
  425|       |    if (n >= (std::numeric_limits<int64_t>::max)()) return InfiniteDuration();
  426|       |    return time_internal::MakePosDoubleDuration(n);
  427|       |  } else {
  428|       |    if (std::isnan(n))
  429|       |      return std::signbit(n) ? -InfiniteDuration() : InfiniteDuration();
  430|       |    if (n <= (std::numeric_limits<int64_t>::min)()) return -InfiniteDuration();
  431|       |    return -time_internal::MakePosDoubleDuration(-n);
  432|       |  }
  433|       |}
  434|       |template <typename T, time_internal::EnableIfFloat<T> = 0>
  435|       |Duration Minutes(T n) {
  436|       |  return n * Minutes(1);
  437|       |}
  438|       |template <typename T, time_internal::EnableIfFloat<T> = 0>
  439|       |Duration Hours(T n) {
  440|       |  return n * Hours(1);
  441|       |}
  442|       |
  443|       |// ToInt64Nanoseconds()
  444|       |// ToInt64Microseconds()
  445|       |// ToInt64Milliseconds()
  446|       |// ToInt64Seconds()
  447|       |// ToInt64Minutes()
  448|       |// ToInt64Hours()
  449|       |//
  450|       |// Helper functions that convert a Duration to an integral count of the
  451|       |// indicated unit. These functions are shorthand for the `IDivDuration()`
  452|       |// function above; see its documentation for details about overflow, etc.
  453|       |//
  454|       |// Example:
  455|       |//
  456|       |//   absl::Duration d = absl::Milliseconds(1500);
  457|       |//   int64_t isec = absl::ToInt64Seconds(d);  // isec == 1
  458|       |int64_t ToInt64Nanoseconds(Duration d);
  459|       |int64_t ToInt64Microseconds(Duration d);
  460|       |int64_t ToInt64Milliseconds(Duration d);
  461|       |int64_t ToInt64Seconds(Duration d);
  462|       |int64_t ToInt64Minutes(Duration d);
  463|       |int64_t ToInt64Hours(Duration d);
  464|       |
  465|       |// ToDoubleNanoSeconds()
  466|       |// ToDoubleMicroseconds()
  467|       |// ToDoubleMilliseconds()
  468|       |// ToDoubleSeconds()
  469|       |// ToDoubleMinutes()
  470|       |// ToDoubleHours()
  471|       |//
  472|       |// Helper functions that convert a Duration to a floating point count of the
  473|       |// indicated unit. These functions are shorthand for the `FDivDuration()`
  474|       |// function above; see its documentation for details about overflow, etc.
  475|       |//
  476|       |// Example:
  477|       |//
  478|       |//   absl::Duration d = absl::Milliseconds(1500);
  479|       |//   double dsec = absl::ToDoubleSeconds(d);  // dsec == 1.5
  480|       |double ToDoubleNanoseconds(Duration d);
  481|       |double ToDoubleMicroseconds(Duration d);
  482|       |double ToDoubleMilliseconds(Duration d);
  483|       |double ToDoubleSeconds(Duration d);
  484|       |double ToDoubleMinutes(Duration d);
  485|       |double ToDoubleHours(Duration d);
  486|       |
  487|       |// FromChrono()
  488|       |//
  489|       |// Converts any of the pre-defined std::chrono durations to an absl::Duration.
  490|       |//
  491|       |// Example:
  492|       |//
  493|       |//   std::chrono::milliseconds ms(123);
  494|       |//   absl::Duration d = absl::FromChrono(ms);
  495|       |constexpr Duration FromChrono(const std::chrono::nanoseconds& d);
  496|       |constexpr Duration FromChrono(const std::chrono::microseconds& d);
  497|       |constexpr Duration FromChrono(const std::chrono::milliseconds& d);
  498|       |constexpr Duration FromChrono(const std::chrono::seconds& d);
  499|       |constexpr Duration FromChrono(const std::chrono::minutes& d);
  500|       |constexpr Duration FromChrono(const std::chrono::hours& d);
  501|       |
  502|       |// ToChronoNanoseconds()
  503|       |// ToChronoMicroseconds()
  504|       |// ToChronoMilliseconds()
  505|       |// ToChronoSeconds()
  506|       |// ToChronoMinutes()
  507|       |// ToChronoHours()
  508|       |//
  509|       |// Converts an absl::Duration to any of the pre-defined std::chrono durations.
  510|       |// If overflow would occur, the returned value will saturate at the min/max
  511|       |// chrono duration value instead.
  512|       |//
  513|       |// Example:
  514|       |//
  515|       |//   absl::Duration d = absl::Microseconds(123);
  516|       |//   auto x = absl::ToChronoMicroseconds(d);
  517|       |//   auto y = absl::ToChronoNanoseconds(d);  // x == y
  518|       |//   auto z = absl::ToChronoSeconds(absl::InfiniteDuration());
  519|       |//   // z == std::chrono::seconds::max()
  520|       |std::chrono::nanoseconds ToChronoNanoseconds(Duration d);
  521|       |std::chrono::microseconds ToChronoMicroseconds(Duration d);
  522|       |std::chrono::milliseconds ToChronoMilliseconds(Duration d);
  523|       |std::chrono::seconds ToChronoSeconds(Duration d);
  524|       |std::chrono::minutes ToChronoMinutes(Duration d);
  525|       |std::chrono::hours ToChronoHours(Duration d);
  526|       |
  527|       |// FormatDuration()
  528|       |//
  529|       |// Returns a string representing the duration in the form "72h3m0.5s".
  530|       |// Returns "inf" or "-inf" for +/- `InfiniteDuration()`.
  531|       |std::string FormatDuration(Duration d);
  532|       |
  533|       |// Output stream operator.
  534|      0|inline std::ostream& operator<<(std::ostream& os, Duration d) {
  535|      0|  return os << FormatDuration(d);
  536|      0|}
  537|       |
  538|       |// ParseDuration()
  539|       |//
  540|       |// Parses a duration string consisting of a possibly signed sequence of
  541|       |// decimal numbers, each with an optional fractional part and a unit
  542|       |// suffix.  The valid suffixes are "ns", "us" "ms", "s", "m", and "h".
  543|       |// Simple examples include "300ms", "-1.5h", and "2h45m".  Parses "0" as
  544|       |// `ZeroDuration()`. Parses "inf" and "-inf" as +/- `InfiniteDuration()`.
  545|       |bool ParseDuration(const std::string& dur_string, Duration* d);
  546|       |
  547|       |// Support for flag values of type Duration. Duration flags must be specified
  548|       |// in a format that is valid input for absl::ParseDuration().
  549|       |bool ParseFlag(const std::string& text, Duration* dst, std::string* error);
  550|       |std::string UnparseFlag(Duration d);
  551|       |
  552|       |// Time
  553|       |//
  554|       |// An `absl::Time` represents a specific instant in time. Arithmetic operators
  555|       |// are provided for naturally expressing time calculations. Instances are
  556|       |// created using `absl::Now()` and the `absl::From*()` factory functions that
  557|       |// accept the gamut of other time representations. Formatting and parsing
  558|       |// functions are provided for conversion to and from strings.  `absl::Time`
  559|       |// should be passed by value rather than const reference.
  560|       |//
  561|       |// `absl::Time` assumes there are 60 seconds in a minute, which means the
  562|       |// underlying time scales must be "smeared" to eliminate leap seconds.
  563|       |// See https://developers.google.com/time/smear.
  564|       |//
  565|       |// Even though `absl::Time` supports a wide range of timestamps, exercise
  566|       |// caution when using values in the distant past. `absl::Time` uses the
  567|       |// Proleptic Gregorian calendar, which extends the Gregorian calendar backward
  568|       |// to dates before its introduction in 1582.
  569|       |// See https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar
  570|       |// for more information. Use the ICU calendar classes to convert a date in
  571|       |// some other calendar (http://userguide.icu-project.org/datetime/calendar).
  572|       |//
  573|       |// Similarly, standardized time zones are a reasonably recent innovation, with
  574|       |// the Greenwich prime meridian being established in 1884. The TZ database
  575|       |// itself does not profess accurate offsets for timestamps prior to 1970. The
  576|       |// breakdown of future timestamps is subject to the whim of regional
  577|       |// governments.
  578|       |//
  579|       |// The `absl::Time` class represents an instant in time as a count of clock
  580|       |// ticks of some granularity (resolution) from some starting point (epoch).
  581|       |//
  582|       |// `absl::Time` uses a resolution that is high enough to avoid loss in
  583|       |// precision, and a range that is wide enough to avoid overflow, when
  584|       |// converting between tick counts in most Google time scales (i.e., resolution
  585|       |// of at least one nanosecond, and range +/-100 billion years).  Conversions
  586|       |// between the time scales are performed by truncating (towards negative
  587|       |// infinity) to the nearest representable point.
  588|       |//
  589|       |// Examples:
  590|       |//
  591|       |//   absl::Time t1 = ...;
  592|       |//   absl::Time t2 = t1 + absl::Minutes(2);
  593|       |//   absl::Duration d = t2 - t1;  // == absl::Minutes(2)
  594|       |//
  595|       |class Time {
  596|       | public:
  597|       |  // Value semantics.
  598|       |
  599|       |  // Returns the Unix epoch.  However, those reading your code may not know
  600|       |  // or expect the Unix epoch as the default value, so make your code more
  601|       |  // readable by explicitly initializing all instances before use.
  602|       |  //
  603|       |  // Example:
  604|       |  //   absl::Time t = absl::UnixEpoch();
  605|       |  //   absl::Time t = absl::Now();
  606|       |  //   absl::Time t = absl::TimeFromTimeval(tv);
  607|       |  //   absl::Time t = absl::InfinitePast();
  608|      0|  constexpr Time() = default;
  609|       |
  610|       |  // Copyable.
  611|       |  constexpr Time(const Time& t) = default;
  612|       |  Time& operator=(const Time& t) = default;
  613|       |
  614|       |  // Assignment operators.
  615|      0|  Time& operator+=(Duration d) {
  616|      0|    rep_ += d;
  617|      0|    return *this;
  618|      0|  }
  619|      0|  Time& operator-=(Duration d) {
  620|      0|    rep_ -= d;
  621|      0|    return *this;
  622|      0|  }
  623|       |
  624|       |  // Time::Breakdown
  625|       |  //
  626|       |  // The calendar and wall-clock (aka "civil time") components of an
  627|       |  // `absl::Time` in a certain `absl::TimeZone`. This struct is not
  628|       |  // intended to represent an instant in time. So, rather than passing
  629|       |  // a `Time::Breakdown` to a function, pass an `absl::Time` and an
  630|       |  // `absl::TimeZone`.
  631|       |  //
  632|       |  // Deprecated. Use `absl::TimeZone::CivilInfo`.
  633|       |  struct
  634|       |      Breakdown {
  635|       |    int64_t year;          // year (e.g., 2013)
  636|       |    int month;           // month of year [1:12]
  637|       |    int day;             // day of month [1:31]
  638|       |    int hour;            // hour of day [0:23]
  639|       |    int minute;          // minute of hour [0:59]
  640|       |    int second;          // second of minute [0:59]
  641|       |    Duration subsecond;  // [Seconds(0):Seconds(1)) if finite
  642|       |    int weekday;         // 1==Mon, ..., 7=Sun
  643|       |    int yearday;         // day of year [1:366]
  644|       |
  645|       |    // Note: The following fields exist for backward compatibility
  646|       |    // with older APIs.  Accessing these fields directly is a sign of
  647|       |    // imprudent logic in the calling code.  Modern time-related code
  648|       |    // should only access this data indirectly by way of FormatTime().
  649|       |    // These fields are undefined for InfiniteFuture() and InfinitePast().
  650|       |    int offset;             // seconds east of UTC
  651|       |    bool is_dst;            // is offset non-standard?
  652|       |    const char* zone_abbr;  // time-zone abbreviation (e.g., "PST")
  653|       |  };
  654|       |
  655|       |  // Time::In()
  656|       |  //
  657|       |  // Returns the breakdown of this instant in the given TimeZone.
  658|       |  //
  659|       |  // Deprecated. Use `absl::TimeZone::At(Time)`.
  660|       |  Breakdown In(TimeZone tz) const;
  661|       |
  662|       |  template <typename H>
  663|       |  friend H AbslHashValue(H h, Time t) {
  664|       |    return H::combine(std::move(h), t.rep_);
  665|       |  }
  666|       |
  667|       | private:
  668|       |  friend constexpr Time time_internal::FromUnixDuration(Duration d);
  669|       |  friend constexpr Duration time_internal::ToUnixDuration(Time t);
  670|       |  friend constexpr bool operator<(Time lhs, Time rhs);
  671|       |  friend constexpr bool operator==(Time lhs, Time rhs);
  672|       |  friend Duration operator-(Time lhs, Time rhs);
  673|       |  friend constexpr Time UniversalEpoch();
  674|       |  friend constexpr Time InfiniteFuture();
  675|       |  friend constexpr Time InfinitePast();
  676|      0|  constexpr explicit Time(Duration rep) : rep_(rep) {}
  677|       |  Duration rep_;
  678|       |};
  679|       |
  680|       |// Relational Operators
  681|      0|constexpr bool operator<(Time lhs, Time rhs) { return lhs.rep_ < rhs.rep_; }
  682|      0|constexpr bool operator>(Time lhs, Time rhs) { return rhs < lhs; }
  683|      0|constexpr bool operator>=(Time lhs, Time rhs) { return !(lhs < rhs); }
  684|      0|constexpr bool operator<=(Time lhs, Time rhs) { return !(rhs < lhs); }
  685|      0|constexpr bool operator==(Time lhs, Time rhs) { return lhs.rep_ == rhs.rep_; }
  686|      0|constexpr bool operator!=(Time lhs, Time rhs) { return !(lhs == rhs); }
  687|       |
  688|       |// Additive Operators
  689|      0|inline Time operator+(Time lhs, Duration rhs) { return lhs += rhs; }
  690|      0|inline Time operator+(Duration lhs, Time rhs) { return rhs += lhs; }
  691|      0|inline Time operator-(Time lhs, Duration rhs) { return lhs -= rhs; }
  692|      0|inline Duration operator-(Time lhs, Time rhs) { return lhs.rep_ - rhs.rep_; }
  693|       |
  694|       |// UnixEpoch()
  695|       |//
  696|       |// Returns the `absl::Time` representing "1970-01-01 00:00:00.0 +0000".
  697|      0|constexpr Time UnixEpoch() { return Time(); }
  698|       |
  699|       |// UniversalEpoch()
  700|       |//
  701|       |// Returns the `absl::Time` representing "0001-01-01 00:00:00.0 +0000", the
  702|       |// epoch of the ICU Universal Time Scale.
  703|      0|constexpr Time UniversalEpoch() {
  704|      0|  // 719162 is the number of days from 0001-01-01 to 1970-01-01,
  705|      0|  // assuming the Gregorian calendar.
  706|      0|  return Time(time_internal::MakeDuration(-24 * 719162 * int64_t{3600}, 0U));
  707|      0|}
  708|       |
  709|       |// InfiniteFuture()
  710|       |//
  711|       |// Returns an `absl::Time` that is infinitely far in the future.
  712|      0|constexpr Time InfiniteFuture() {
  713|      0|  return Time(
  714|      0|      time_internal::MakeDuration((std::numeric_limits<int64_t>::max)(), ~0U));
  715|      0|}
  716|       |
  717|       |// InfinitePast()
  718|       |//
  719|       |// Returns an `absl::Time` that is infinitely far in the past.
  720|      0|constexpr Time InfinitePast() {
  721|      0|  return Time(
  722|      0|      time_internal::MakeDuration((std::numeric_limits<int64_t>::min)(), ~0U));
  723|      0|}
  724|       |
  725|       |// FromUnixNanos()
  726|       |// FromUnixMicros()
  727|       |// FromUnixMillis()
  728|       |// FromUnixSeconds()
  729|       |// FromTimeT()
  730|       |// FromUDate()
  731|       |// FromUniversal()
  732|       |//
  733|       |// Creates an `absl::Time` from a variety of other representations.
  734|       |constexpr Time FromUnixNanos(int64_t ns);
  735|       |constexpr Time FromUnixMicros(int64_t us);
  736|       |constexpr Time FromUnixMillis(int64_t ms);
  737|       |constexpr Time FromUnixSeconds(int64_t s);
  738|       |constexpr Time FromTimeT(time_t t);
  739|       |Time FromUDate(double udate);
  740|       |Time FromUniversal(int64_t universal);
  741|       |
  742|       |// ToUnixNanos()
  743|       |// ToUnixMicros()
  744|       |// ToUnixMillis()
  745|       |// ToUnixSeconds()
  746|       |// ToTimeT()
  747|       |// ToUDate()
  748|       |// ToUniversal()
  749|       |//
  750|       |// Converts an `absl::Time` to a variety of other representations.  Note that
  751|       |// these operations round down toward negative infinity where necessary to
  752|       |// adjust to the resolution of the result type.  Beware of possible time_t
  753|       |// over/underflow in ToTime{T,val,spec}() on 32-bit platforms.
  754|       |int64_t ToUnixNanos(Time t);
  755|       |int64_t ToUnixMicros(Time t);
  756|       |int64_t ToUnixMillis(Time t);
  757|       |int64_t ToUnixSeconds(Time t);
  758|       |time_t ToTimeT(Time t);
  759|       |double ToUDate(Time t);
  760|       |int64_t ToUniversal(Time t);
  761|       |
  762|       |// DurationFromTimespec()
  763|       |// DurationFromTimeval()
  764|       |// ToTimespec()
  765|       |// ToTimeval()
  766|       |// TimeFromTimespec()
  767|       |// TimeFromTimeval()
  768|       |// ToTimespec()
  769|       |// ToTimeval()
  770|       |//
  771|       |// Some APIs use a timespec or a timeval as a Duration (e.g., nanosleep(2)
  772|       |// and select(2)), while others use them as a Time (e.g. clock_gettime(2)
  773|       |// and gettimeofday(2)), so conversion functions are provided for both cases.
  774|       |// The "to timespec/val" direction is easily handled via overloading, but
  775|       |// for "from timespec/val" the desired type is part of the function name.
  776|       |Duration DurationFromTimespec(timespec ts);
  777|       |Duration DurationFromTimeval(timeval tv);
  778|       |timespec ToTimespec(Duration d);
  779|       |timeval ToTimeval(Duration d);
  780|       |Time TimeFromTimespec(timespec ts);
  781|       |Time TimeFromTimeval(timeval tv);
  782|       |timespec ToTimespec(Time t);
  783|       |timeval ToTimeval(Time t);
  784|       |
  785|       |// FromChrono()
  786|       |//
  787|       |// Converts a std::chrono::system_clock::time_point to an absl::Time.
  788|       |//
  789|       |// Example:
  790|       |//
  791|       |//   auto tp = std::chrono::system_clock::from_time_t(123);
  792|       |//   absl::Time t = absl::FromChrono(tp);
  793|       |//   // t == absl::FromTimeT(123)
  794|       |Time FromChrono(const std::chrono::system_clock::time_point& tp);
  795|       |
  796|       |// ToChronoTime()
  797|       |//
  798|       |// Converts an absl::Time to a std::chrono::system_clock::time_point. If
  799|       |// overflow would occur, the returned value will saturate at the min/max time
  800|       |// point value instead.
  801|       |//
  802|       |// Example:
  803|       |//
  804|       |//   absl::Time t = absl::FromTimeT(123);
  805|       |//   auto tp = absl::ToChronoTime(t);
  806|       |//   // tp == std::chrono::system_clock::from_time_t(123);
  807|       |std::chrono::system_clock::time_point ToChronoTime(Time);
  808|       |
  809|       |// Support for flag values of type Time. Time flags must be specified in a
  810|       |// format that matches absl::RFC3339_full. For example:
  811|       |//
  812|       |//   --start_time=2016-01-02T03:04:05.678+08:00
  813|       |//
  814|       |// Note: A UTC offset (or 'Z' indicating a zero-offset from UTC) is required.
  815|       |//
  816|       |// Additionally, if you'd like to specify a time as a count of
  817|       |// seconds/milliseconds/etc from the Unix epoch, use an absl::Duration flag
  818|       |// and add that duration to absl::UnixEpoch() to get an absl::Time.
  819|       |bool ParseFlag(const std::string& text, Time* t, std::string* error);
  820|       |std::string UnparseFlag(Time t);
  821|       |
  822|       |// TimeZone
  823|       |//
  824|       |// The `absl::TimeZone` is an opaque, small, value-type class representing a
  825|       |// geo-political region within which particular rules are used for converting
  826|       |// between absolute and civil times (see https://git.io/v59Ly). `absl::TimeZone`
  827|       |// values are named using the TZ identifiers from the IANA Time Zone Database,
  828|       |// such as "America/Los_Angeles" or "Australia/Sydney". `absl::TimeZone` values
  829|       |// are created from factory functions such as `absl::LoadTimeZone()`. Note:
  830|       |// strings like "PST" and "EDT" are not valid TZ identifiers. Prefer to pass by
  831|       |// value rather than const reference.
  832|       |//
  833|       |// For more on the fundamental concepts of time zones, absolute times, and civil
  834|       |// times, see https://github.com/google/cctz#fundamental-concepts
  835|       |//
  836|       |// Examples:
  837|       |//
  838|       |//   absl::TimeZone utc = absl::UTCTimeZone();
  839|       |//   absl::TimeZone pst = absl::FixedTimeZone(-8 * 60 * 60);
  840|       |//   absl::TimeZone loc = absl::LocalTimeZone();
  841|       |//   absl::TimeZone lax;
  842|       |//   if (!absl::LoadTimeZone("America/Los_Angeles", &lax)) {
  843|       |//     // handle error case
  844|       |//   }
  845|       |//
  846|       |// See also:
  847|       |// - https://github.com/google/cctz
  848|       |// - https://www.iana.org/time-zones
  849|       |// - https://en.wikipedia.org/wiki/Zoneinfo
  850|       |class TimeZone {
  851|       | public:
  852|      0|  explicit TimeZone(time_internal::cctz::time_zone tz) : cz_(tz) {}
  853|       |  TimeZone() = default;  // UTC, but prefer UTCTimeZone() to be explicit.
  854|       |
  855|       |  // Copyable.
  856|       |  TimeZone(const TimeZone&) = default;
  857|       |  TimeZone& operator=(const TimeZone&) = default;
  858|       |
  859|      0|  explicit operator time_internal::cctz::time_zone() const { return cz_; }
  860|       |
  861|      0|  std::string name() const { return cz_.name(); }
  862|       |
  863|       |  // TimeZone::CivilInfo
  864|       |  //
  865|       |  // Information about the civil time corresponding to an absolute time.
  866|       |  // This struct is not intended to represent an instant in time. So, rather
  867|       |  // than passing a `TimeZone::CivilInfo` to a function, pass an `absl::Time`
  868|       |  // and an `absl::TimeZone`.
  869|       |  struct CivilInfo {
  870|       |    CivilSecond cs;
  871|       |    Duration subsecond;
  872|       |
  873|       |    // Note: The following fields exist for backward compatibility
  874|       |    // with older APIs.  Accessing these fields directly is a sign of
  875|       |    // imprudent logic in the calling code.  Modern time-related code
  876|       |    // should only access this data indirectly by way of FormatTime().
  877|       |    // These fields are undefined for InfiniteFuture() and InfinitePast().
  878|       |    int offset;             // seconds east of UTC
  879|       |    bool is_dst;            // is offset non-standard?
  880|       |    const char* zone_abbr;  // time-zone abbreviation (e.g., "PST")
  881|       |  };
  882|       |
  883|       |  // TimeZone::At(Time)
  884|       |  //
  885|       |  // Returns the civil time for this TimeZone at a certain `absl::Time`.
  886|       |  // If the input time is infinite, the output civil second will be set to
  887|       |  // CivilSecond::max() or min(), and the subsecond will be infinite.
  888|       |  //
  889|       |  // Example:
  890|       |  //
  891|       |  //   const auto epoch = lax.At(absl::UnixEpoch());
  892|       |  //   // epoch.cs == 1969-12-31 16:00:00
  893|       |  //   // epoch.subsecond == absl::ZeroDuration()
  894|       |  //   // epoch.offset == -28800
  895|       |  //   // epoch.is_dst == false
  896|       |  //   // epoch.abbr == "PST"
  897|       |  CivilInfo At(Time t) const;
  898|       |
  899|       |  // TimeZone::TimeInfo
  900|       |  //
  901|       |  // Information about the absolute times corresponding to a civil time.
  902|       |  // (Subseconds must be handled separately.)
  903|       |  //
  904|       |  // It is possible for a caller to pass a civil-time value that does
  905|       |  // not represent an actual or unique instant in time (due to a shift
  906|       |  // in UTC offset in the TimeZone, which results in a discontinuity in
  907|       |  // the civil-time components). For example, a daylight-saving-time
  908|       |  // transition skips or repeats civil times---in the United States,
  909|       |  // March 13, 2011 02:15 never occurred, while November 6, 2011 01:15
  910|       |  // occurred twice---so requests for such times are not well-defined.
  911|       |  // To account for these possibilities, `absl::TimeZone::TimeInfo` is
  912|       |  // richer than just a single `absl::Time`.
  913|       |  struct TimeInfo {
  914|       |    enum CivilKind {
  915|       |      UNIQUE,    // the civil time was singular (pre == trans == post)
  916|       |      SKIPPED,   // the civil time did not exist (pre >= trans > post)
  917|       |      REPEATED,  // the civil time was ambiguous (pre < trans <= post)
  918|       |    } kind;
  919|       |    Time pre;    // time calculated using the pre-transition offset
  920|       |    Time trans;  // when the civil-time discontinuity occurred
  921|       |    Time post;   // time calculated using the post-transition offset
  922|       |  };
  923|       |
  924|       |  // TimeZone::At(CivilSecond)
  925|       |  //
  926|       |  // Returns an `absl::TimeInfo` containing the absolute time(s) for this
  927|       |  // TimeZone at an `absl::CivilSecond`. When the civil time is skipped or
  928|       |  // repeated, returns times calculated using the pre-transition and post-
  929|       |  // transition UTC offsets, plus the transition time itself.
  930|       |  //
  931|       |  // Examples:
  932|       |  //
  933|       |  //   // A unique civil time
  934|       |  //   const auto jan01 = lax.At(absl::CivilSecond(2011, 1, 1, 0, 0, 0));
  935|       |  //   // jan01.kind == TimeZone::TimeInfo::UNIQUE
  936|       |  //   // jan01.pre    is 2011-01-01 00:00:00 -0800
  937|       |  //   // jan01.trans  is 2011-01-01 00:00:00 -0800
  938|       |  //   // jan01.post   is 2011-01-01 00:00:00 -0800
  939|       |  //
  940|       |  //   // A Spring DST transition, when there is a gap in civil time
  941|       |  //   const auto mar13 = lax.At(absl::CivilSecond(2011, 3, 13, 2, 15, 0));
  942|       |  //   // mar13.kind == TimeZone::TimeInfo::SKIPPED
  943|       |  //   // mar13.pre   is 2011-03-13 03:15:00 -0700
  944|       |  //   // mar13.trans is 2011-03-13 03:00:00 -0700
  945|       |  //   // mar13.post  is 2011-03-13 01:15:00 -0800
  946|       |  //
  947|       |  //   // A Fall DST transition, when civil times are repeated
  948|       |  //   const auto nov06 = lax.At(absl::CivilSecond(2011, 11, 6, 1, 15, 0));
  949|       |  //   // nov06.kind == TimeZone::TimeInfo::REPEATED
  950|       |  //   // nov06.pre   is 2011-11-06 01:15:00 -0700
  951|       |  //   // nov06.trans is 2011-11-06 01:00:00 -0800
  952|       |  //   // nov06.post  is 2011-11-06 01:15:00 -0800
  953|       |  TimeInfo At(CivilSecond ct) const;
  954|       |
  955|       |  // TimeZone::NextTransition()
  956|       |  // TimeZone::PrevTransition()
  957|       |  //
  958|       |  // Finds the time of the next/previous offset change in this time zone.
  959|       |  //
  960|       |  // By definition, `NextTransition(t, &trans)` returns false when `t` is
  961|       |  // `InfiniteFuture()`, and `PrevTransition(t, &trans)` returns false
  962|       |  // when `t` is `InfinitePast()`. If the zone has no transitions, the
  963|       |  // result will also be false no matter what the argument.
  964|       |  //
  965|       |  // Otherwise, when `t` is `InfinitePast()`, `NextTransition(t, &trans)`
  966|       |  // returns true and sets `trans` to the first recorded transition. Chains
  967|       |  // of calls to `NextTransition()/PrevTransition()` will eventually return
  968|       |  // false, but it is unspecified exactly when `NextTransition(t, &trans)`
  969|       |  // jumps to false, or what time is set by `PrevTransition(t, &trans)` for
  970|       |  // a very distant `t`.
  971|       |  //
  972|       |  // Note: Enumeration of time-zone transitions is for informational purposes
  973|       |  // only. Modern time-related code should not care about when offset changes
  974|       |  // occur.
  975|       |  //
  976|       |  // Example:
  977|       |  //   absl::TimeZone nyc;
  978|       |  //   if (!absl::LoadTimeZone("America/New_York", &nyc)) { ... }
  979|       |  //   const auto now = absl::Now();
  980|       |  //   auto t = absl::InfinitePast();
  981|       |  //   absl::TimeZone::CivilTransition trans;
  982|       |  //   while (t <= now && nyc.NextTransition(t, &trans)) {
  983|       |  //     // transition: trans.from -> trans.to
  984|       |  //     t = nyc.At(trans.to).trans;
  985|       |  //   }
  986|       |  struct CivilTransition {
  987|       |    CivilSecond from;  // the civil time we jump from
  988|       |    CivilSecond to;    // the civil time we jump to
  989|       |  };
  990|       |  bool NextTransition(Time t, CivilTransition* trans) const;
  991|       |  bool PrevTransition(Time t, CivilTransition* trans) const;
  992|       |
  993|       |  template <typename H>
  994|       |  friend H AbslHashValue(H h, TimeZone tz) {
  995|       |    return H::combine(std::move(h), tz.cz_);
  996|       |  }
  997|       |
  998|       | private:
  999|      0|  friend bool operator==(TimeZone a, TimeZone b) { return a.cz_ == b.cz_; }
 1000|      0|  friend bool operator!=(TimeZone a, TimeZone b) { return a.cz_ != b.cz_; }
 1001|      0|  friend std::ostream& operator<<(std::ostream& os, TimeZone tz) {
 1002|      0|    return os << tz.name();
 1003|      0|  }
 1004|       |
 1005|       |  time_internal::cctz::time_zone cz_;
 1006|       |};
 1007|       |
 1008|       |// LoadTimeZone()
 1009|       |//
 1010|       |// Loads the named zone. May perform I/O on the initial load of the named
 1011|       |// zone. If the name is invalid, or some other kind of error occurs, returns
 1012|       |// `false` and `*tz` is set to the UTC time zone.
 1013|      0|inline bool LoadTimeZone(const std::string& name, TimeZone* tz) {
 1014|      0|  if (name == "localtime") {
 1015|      0|    *tz = TimeZone(time_internal::cctz::local_time_zone());
 1016|      0|    return true;
 1017|      0|  }
 1018|      0|  time_internal::cctz::time_zone cz;
 1019|      0|  const bool b = time_internal::cctz::load_time_zone(name, &cz);
 1020|      0|  *tz = TimeZone(cz);
 1021|      0|  return b;
 1022|      0|}
 1023|       |
 1024|       |// FixedTimeZone()
 1025|       |//
 1026|       |// Returns a TimeZone that is a fixed offset (seconds east) from UTC.
 1027|       |// Note: If the absolute value of the offset is greater than 24 hours
 1028|       |// you'll get UTC (i.e., no offset) instead.
 1029|      0|inline TimeZone FixedTimeZone(int seconds) {
 1030|      0|  return TimeZone(
 1031|      0|      time_internal::cctz::fixed_time_zone(std::chrono::seconds(seconds)));
 1032|      0|}
 1033|       |
 1034|       |// UTCTimeZone()
 1035|       |//
 1036|       |// Convenience method returning the UTC time zone.
 1037|      0|inline TimeZone UTCTimeZone() {
 1038|      0|  return TimeZone(time_internal::cctz::utc_time_zone());
 1039|      0|}
 1040|       |
 1041|       |// LocalTimeZone()
 1042|       |//
 1043|       |// Convenience method returning the local time zone, or UTC if there is
 1044|       |// no configured local zone.  Warning: Be wary of using LocalTimeZone(),
 1045|       |// and particularly so in a server process, as the zone configured for the
 1046|       |// local machine should be irrelevant.  Prefer an explicit zone name.
 1047|      0|inline TimeZone LocalTimeZone() {
 1048|      0|  return TimeZone(time_internal::cctz::local_time_zone());
 1049|      0|}
 1050|       |
 1051|       |// ToCivilSecond()
 1052|       |// ToCivilMinute()
 1053|       |// ToCivilHour()
 1054|       |// ToCivilDay()
 1055|       |// ToCivilMonth()
 1056|       |// ToCivilYear()
 1057|       |//
 1058|       |// Helpers for TimeZone::At(Time) to return particularly aligned civil times.
 1059|       |//
 1060|       |// Example:
 1061|       |//
 1062|       |//   absl::Time t = ...;
 1063|       |//   absl::TimeZone tz = ...;
 1064|       |//   const auto cd = absl::ToCivilDay(t, tz);
 1065|      0|inline CivilSecond ToCivilSecond(Time t, TimeZone tz) {
 1066|      0|  return tz.At(t).cs;  // already a CivilSecond
 1067|      0|}
 1068|      0|inline CivilMinute ToCivilMinute(Time t, TimeZone tz) {
 1069|      0|  return CivilMinute(tz.At(t).cs);
 1070|      0|}
 1071|      0|inline CivilHour ToCivilHour(Time t, TimeZone tz) {
 1072|      0|  return CivilHour(tz.At(t).cs);
 1073|      0|}
 1074|      0|inline CivilDay ToCivilDay(Time t, TimeZone tz) {
 1075|      0|  return CivilDay(tz.At(t).cs);
 1076|      0|}
 1077|      0|inline CivilMonth ToCivilMonth(Time t, TimeZone tz) {
 1078|      0|  return CivilMonth(tz.At(t).cs);
 1079|      0|}
 1080|      0|inline CivilYear ToCivilYear(Time t, TimeZone tz) {
 1081|      0|  return CivilYear(tz.At(t).cs);
 1082|      0|}
 1083|       |
 1084|       |// FromCivil()
 1085|       |//
 1086|       |// Helper for TimeZone::At(CivilSecond) that provides "order-preserving
 1087|       |// semantics." If the civil time maps to a unique time, that time is
 1088|       |// returned. If the civil time is repeated in the given time zone, the
 1089|       |// time using the pre-transition offset is returned. Otherwise, the
 1090|       |// civil time is skipped in the given time zone, and the transition time
 1091|       |// is returned. This means that for any two civil times, ct1 and ct2,
 1092|       |// (ct1 < ct2) => (FromCivil(ct1) <= FromCivil(ct2)), the equal case
 1093|       |// being when two non-existent civil times map to the same transition time.
 1094|       |//
 1095|       |// Note: Accepts civil times of any alignment.
 1096|      0|inline Time FromCivil(CivilSecond ct, TimeZone tz) {
 1097|      0|  const auto ti = tz.At(ct);
 1098|      0|  if (ti.kind == TimeZone::TimeInfo::SKIPPED) return ti.trans;
 1099|      0|  return ti.pre;
 1100|      0|}
 1101|       |
 1102|       |// TimeConversion
 1103|       |//
 1104|       |// An `absl::TimeConversion` represents the conversion of year, month, day,
 1105|       |// hour, minute, and second values (i.e., a civil time), in a particular
 1106|       |// `absl::TimeZone`, to a time instant (an absolute time), as returned by
 1107|       |// `absl::ConvertDateTime()`. Lecacy version of `absl::TimeZone::TimeInfo`.
 1108|       |//
 1109|       |// Deprecated. Use `absl::TimeZone::TimeInfo`.
 1110|       |struct
 1111|       |    TimeConversion {
 1112|       |  Time pre;    // time calculated using the pre-transition offset
 1113|       |  Time trans;  // when the civil-time discontinuity occurred
 1114|       |  Time post;   // time calculated using the post-transition offset
 1115|       |
 1116|       |  enum Kind {
 1117|       |    UNIQUE,    // the civil time was singular (pre == trans == post)
 1118|       |    SKIPPED,   // the civil time did not exist
 1119|       |    REPEATED,  // the civil time was ambiguous
 1120|       |  };
 1121|       |  Kind kind;
 1122|       |
 1123|       |  bool normalized;  // input values were outside their valid ranges
 1124|       |};
 1125|       |
 1126|       |// ConvertDateTime()
 1127|       |//
 1128|       |// Legacy version of `absl::TimeZone::At(absl::CivilSecond)` that takes
 1129|       |// the civil time as six, separate values (YMDHMS).
 1130|       |//
 1131|       |// The input month, day, hour, minute, and second values can be outside
 1132|       |// of their valid ranges, in which case they will be "normalized" during
 1133|       |// the conversion.
 1134|       |//
 1135|       |// Example:
 1136|       |//
 1137|       |//   // "October 32" normalizes to "November 1".
 1138|       |//   absl::TimeConversion tc =
 1139|       |//       absl::ConvertDateTime(2013, 10, 32, 8, 30, 0, lax);
 1140|       |//   // tc.kind == TimeConversion::UNIQUE && tc.normalized == true
 1141|       |//   // absl::ToCivilDay(tc.pre, tz).month() == 11
 1142|       |//   // absl::ToCivilDay(tc.pre, tz).day() == 1
 1143|       |//
 1144|       |// Deprecated. Use `absl::TimeZone::At(CivilSecond)`.
 1145|       |TimeConversion ConvertDateTime(int64_t year, int mon, int day, int hour,
 1146|       |                               int min, int sec, TimeZone tz);
 1147|       |
 1148|       |// FromDateTime()
 1149|       |//
 1150|       |// A convenience wrapper for `absl::ConvertDateTime()` that simply returns
 1151|       |// the "pre" `absl::Time`.  That is, the unique result, or the instant that
 1152|       |// is correct using the pre-transition offset (as if the transition never
 1153|       |// happened).
 1154|       |//
 1155|       |// Example:
 1156|       |//
 1157|       |//   absl::Time t = absl::FromDateTime(2017, 9, 26, 9, 30, 0, lax);
 1158|       |//   // t = 2017-09-26 09:30:00 -0700
 1159|       |//
 1160|       |// Deprecated. Use `absl::FromCivil(CivilSecond, TimeZone)`. Note that the
 1161|       |// behavior of `FromCivil()` differs from `FromDateTime()` for skipped civil
 1162|       |// times. If you care about that see `absl::TimeZone::At(absl::CivilSecond)`.
 1163|       |inline Time FromDateTime(int64_t year, int mon, int day, int hour,
 1164|      0|                         int min, int sec, TimeZone tz) {
 1165|      0|  return ConvertDateTime(year, mon, day, hour, min, sec, tz).pre;
 1166|      0|}
 1167|       |
 1168|       |// FromTM()
 1169|       |//
 1170|       |// Converts the `tm_year`, `tm_mon`, `tm_mday`, `tm_hour`, `tm_min`, and
 1171|       |// `tm_sec` fields to an `absl::Time` using the given time zone. See ctime(3)
 1172|       |// for a description of the expected values of the tm fields. If the indicated
 1173|       |// time instant is not unique (see `absl::TimeZone::At(absl::CivilSecond)`
 1174|       |// above), the `tm_isdst` field is consulted to select the desired instant
 1175|       |// (`tm_isdst` > 0 means DST, `tm_isdst` == 0 means no DST, `tm_isdst` < 0
 1176|       |// means use the post-transition offset).
 1177|       |Time FromTM(const struct tm& tm, TimeZone tz);
 1178|       |
 1179|       |// ToTM()
 1180|       |//
 1181|       |// Converts the given `absl::Time` to a struct tm using the given time zone.
 1182|       |// See ctime(3) for a description of the values of the tm fields.
 1183|       |struct tm ToTM(Time t, TimeZone tz);
 1184|       |
 1185|       |// RFC3339_full
 1186|       |// RFC3339_sec
 1187|       |//
 1188|       |// FormatTime()/ParseTime() format specifiers for RFC3339 date/time strings,
 1189|       |// with trailing zeros trimmed or with fractional seconds omitted altogether.
 1190|       |//
 1191|       |// Note that RFC3339_sec[] matches an ISO 8601 extended format for date and
 1192|       |// time with UTC offset.  Also note the use of "%Y": RFC3339 mandates that
 1193|       |// years have exactly four digits, but we allow them to take their natural
 1194|       |// width.
 1195|       |extern const char RFC3339_full[];  // %Y-%m-%dT%H:%M:%E*S%Ez
 1196|       |extern const char RFC3339_sec[];   // %Y-%m-%dT%H:%M:%S%Ez
 1197|       |
 1198|       |// RFC1123_full
 1199|       |// RFC1123_no_wday
 1200|       |//
 1201|       |// FormatTime()/ParseTime() format specifiers for RFC1123 date/time strings.
 1202|       |extern const char RFC1123_full[];     // %a, %d %b %E4Y %H:%M:%S %z
 1203|       |extern const char RFC1123_no_wday[];  // %d %b %E4Y %H:%M:%S %z
 1204|       |
 1205|       |// FormatTime()
 1206|       |//
 1207|       |// Formats the given `absl::Time` in the `absl::TimeZone` according to the
 1208|       |// provided format string. Uses strftime()-like formatting options, with
 1209|       |// the following extensions:
 1210|       |//
 1211|       |//   - %Ez  - RFC3339-compatible numeric UTC offset (+hh:mm or -hh:mm)
 1212|       |//   - %E*z - Full-resolution numeric UTC offset (+hh:mm:ss or -hh:mm:ss)
 1213|       |//   - %E#S - Seconds with # digits of fractional precision
 1214|       |//   - %E*S - Seconds with full fractional precision (a literal '*')
 1215|       |//   - %E#f - Fractional seconds with # digits of precision
 1216|       |//   - %E*f - Fractional seconds with full precision (a literal '*')
 1217|       |//   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)
 1218|       |//
 1219|       |// Note that %E0S behaves like %S, and %E0f produces no characters.  In
 1220|       |// contrast %E*f always produces at least one digit, which may be '0'.
 1221|       |//
 1222|       |// Note that %Y produces as many characters as it takes to fully render the
 1223|       |// year.  A year outside of [-999:9999] when formatted with %E4Y will produce
 1224|       |// more than four characters, just like %Y.
 1225|       |//
 1226|       |// We recommend that format strings include the UTC offset (%z, %Ez, or %E*z)
 1227|       |// so that the result uniquely identifies a time instant.
 1228|       |//
 1229|       |// Example:
 1230|       |//
 1231|       |//   absl::CivilSecond cs(2013, 1, 2, 3, 4, 5);
 1232|       |//   absl::Time t = absl::FromCivil(cs, lax);
 1233|       |//   std::string f = absl::FormatTime("%H:%M:%S", t, lax);  // "03:04:05"
 1234|       |//   f = absl::FormatTime("%H:%M:%E3S", t, lax);  // "03:04:05.000"
 1235|       |//
 1236|       |// Note: If the given `absl::Time` is `absl::InfiniteFuture()`, the returned
 1237|       |// string will be exactly "infinite-future". If the given `absl::Time` is
 1238|       |// `absl::InfinitePast()`, the returned string will be exactly "infinite-past".
 1239|       |// In both cases the given format string and `absl::TimeZone` are ignored.
 1240|       |//
 1241|       |std::string FormatTime(const std::string& format, Time t, TimeZone tz);
 1242|       |
 1243|       |// Convenience functions that format the given time using the RFC3339_full
 1244|       |// format.  The first overload uses the provided TimeZone, while the second
 1245|       |// uses LocalTimeZone().
 1246|       |std::string FormatTime(Time t, TimeZone tz);
 1247|       |std::string FormatTime(Time t);
 1248|       |
 1249|       |// Output stream operator.
 1250|      0|inline std::ostream& operator<<(std::ostream& os, Time t) {
 1251|      0|  return os << FormatTime(t);
 1252|      0|}
 1253|       |
 1254|       |// ParseTime()
 1255|       |//
 1256|       |// Parses an input string according to the provided format string and
 1257|       |// returns the corresponding `absl::Time`. Uses strftime()-like formatting
 1258|       |// options, with the same extensions as FormatTime(), but with the
 1259|       |// exceptions that %E#S is interpreted as %E*S, and %E#f as %E*f.  %Ez
 1260|       |// and %E*z also accept the same inputs.
 1261|       |//
 1262|       |// %Y consumes as many numeric characters as it can, so the matching data
 1263|       |// should always be terminated with a non-numeric.  %E4Y always consumes
 1264|       |// exactly four characters, including any sign.
 1265|       |//
 1266|       |// Unspecified fields are taken from the default date and time of ...
 1267|       |//
 1268|       |//   "1970-01-01 00:00:00.0 +0000"
 1269|       |//
 1270|       |// For example, parsing a string of "15:45" (%H:%M) will return an absl::Time
 1271|       |// that represents "1970-01-01 15:45:00.0 +0000".
 1272|       |//
 1273|       |// Note that since ParseTime() returns time instants, it makes the most sense
 1274|       |// to parse fully-specified date/time strings that include a UTC offset (%z,
 1275|       |// %Ez, or %E*z).
 1276|       |//
 1277|       |// Note also that `absl::ParseTime()` only heeds the fields year, month, day,
 1278|       |// hour, minute, (fractional) second, and UTC offset.  Other fields, like
 1279|       |// weekday (%a or %A), while parsed for syntactic validity, are ignored
 1280|       |// in the conversion.
 1281|       |//
 1282|       |// Date and time fields that are out-of-range will be treated as errors
 1283|       |// rather than normalizing them like `absl::CivilSecond` does.  For example,
 1284|       |// it is an error to parse the date "Oct 32, 2013" because 32 is out of range.
 1285|       |//
 1286|       |// A leap second of ":60" is normalized to ":00" of the following minute
 1287|       |// with fractional seconds discarded.  The following table shows how the
 1288|       |// given seconds and subseconds will be parsed:
 1289|       |//
 1290|       |//   "59.x" -> 59.x  // exact
 1291|       |//   "60.x" -> 00.0  // normalized
 1292|       |//   "00.x" -> 00.x  // exact
 1293|       |//
 1294|       |// Errors are indicated by returning false and assigning an error message
 1295|       |// to the "err" out param if it is non-null.
 1296|       |//
 1297|       |// Note: If the input string is exactly "infinite-future", the returned
 1298|       |// `absl::Time` will be `absl::InfiniteFuture()` and `true` will be returned.
 1299|       |// If the input string is "infinite-past", the returned `absl::Time` will be
 1300|       |// `absl::InfinitePast()` and `true` will be returned.
 1301|       |//
 1302|       |bool ParseTime(const std::string& format, const std::string& input, Time* time,
 1303|       |               std::string* err);
 1304|       |
 1305|       |// Like ParseTime() above, but if the format string does not contain a UTC
 1306|       |// offset specification (%z/%Ez/%E*z) then the input is interpreted in the
 1307|       |// given TimeZone.  This means that the input, by itself, does not identify a
 1308|       |// unique instant.  Being time-zone dependent, it also admits the possibility
 1309|       |// of ambiguity or non-existence, in which case the "pre" time (as defined
 1310|       |// by TimeZone::TimeInfo) is returned.  For these reasons we recommend that
 1311|       |// all date/time strings include a UTC offset so they're context independent.
 1312|       |bool ParseTime(const std::string& format, const std::string& input, TimeZone tz,
 1313|       |               Time* time, std::string* err);
 1314|       |
 1315|       |// ============================================================================
 1316|       |// Implementation Details Follow
 1317|       |// ============================================================================
 1318|       |
 1319|       |namespace time_internal {
 1320|       |
 1321|       |// Creates a Duration with a given representation.
 1322|       |// REQUIRES: hi,lo is a valid representation of a Duration as specified
 1323|       |// in time/duration.cc.
 1324|      0|constexpr Duration MakeDuration(int64_t hi, uint32_t lo = 0) {
 1325|      0|  return Duration(hi, lo);
 1326|      0|}
 1327|       |
 1328|      0|constexpr Duration MakeDuration(int64_t hi, int64_t lo) {
 1329|      0|  return MakeDuration(hi, static_cast<uint32_t>(lo));
 1330|      0|}
 1331|       |
 1332|       |// Make a Duration value from a floating-point number, as long as that number
 1333|       |// is in the range [ 0 .. numeric_limits<int64_t>::max ), that is, as long as
 1334|       |// it's positive and can be converted to int64_t without risk of UB.
 1335|      0|inline Duration MakePosDoubleDuration(double n) {
 1336|      0|  const int64_t int_secs = static_cast<int64_t>(n);
 1337|      0|  const uint32_t ticks =
 1338|      0|      static_cast<uint32_t>((n - int_secs) * kTicksPerSecond + 0.5);
 1339|      0|  return ticks < kTicksPerSecond
 1340|      0|             ? MakeDuration(int_secs, ticks)
 1341|      0|             : MakeDuration(int_secs + 1, ticks - kTicksPerSecond);
 1342|      0|}
 1343|       |
 1344|       |// Creates a normalized Duration from an almost-normalized (sec,ticks)
 1345|       |// pair. sec may be positive or negative.  ticks must be in the range
 1346|       |// -kTicksPerSecond < *ticks < kTicksPerSecond.  If ticks is negative it
 1347|       |// will be normalized to a positive value in the resulting Duration.
 1348|      0|constexpr Duration MakeNormalizedDuration(int64_t sec, int64_t ticks) {
 1349|      0|  return (ticks < 0) ? MakeDuration(sec - 1, ticks + kTicksPerSecond)
 1350|      0|                     : MakeDuration(sec, ticks);
 1351|      0|}
 1352|       |
 1353|       |// Provide access to the Duration representation.
 1354|      0|constexpr int64_t GetRepHi(Duration d) { return d.rep_hi_; }
 1355|      0|constexpr uint32_t GetRepLo(Duration d) { return d.rep_lo_; }
 1356|       |
 1357|       |// Returns true iff d is positive or negative infinity.
 1358|      0|constexpr bool IsInfiniteDuration(Duration d) { return GetRepLo(d) == ~0U; }
 1359|       |
 1360|       |// Returns an infinite Duration with the opposite sign.
 1361|       |// REQUIRES: IsInfiniteDuration(d)
 1362|      0|constexpr Duration OppositeInfinity(Duration d) {
 1363|      0|  return GetRepHi(d) < 0
 1364|      0|             ? MakeDuration((std::numeric_limits<int64_t>::max)(), ~0U)
 1365|      0|             : MakeDuration((std::numeric_limits<int64_t>::min)(), ~0U);
 1366|      0|}
 1367|       |
 1368|       |// Returns (-n)-1 (equivalently -(n+1)) without avoidable overflow.
 1369|      0|constexpr int64_t NegateAndSubtractOne(int64_t n) {
 1370|      0|  // Note: Good compilers will optimize this expression to ~n when using
 1371|      0|  // a two's-complement representation (which is required for int64_t).
 1372|      0|  return (n < 0) ? -(n + 1) : (-n) - 1;
 1373|      0|}
 1374|       |
 1375|       |// Map between a Time and a Duration since the Unix epoch.  Note that these
 1376|       |// functions depend on the above mentioned choice of the Unix epoch for the
 1377|       |// Time representation (and both need to be Time friends).  Without this
 1378|       |// knowledge, we would need to add-in/subtract-out UnixEpoch() respectively.
 1379|      0|constexpr Time FromUnixDuration(Duration d) { return Time(d); }
 1380|      0|constexpr Duration ToUnixDuration(Time t) { return t.rep_; }
 1381|       |
 1382|       |template <std::intmax_t N>
 1383|      0|constexpr Duration FromInt64(int64_t v, std::ratio<1, N>) {
 1384|      0|  static_assert(0 < N && N <= 1000 * 1000 * 1000, "Unsupported ratio");
 1385|      0|  // Subsecond ratios cannot overflow.
 1386|      0|  return MakeNormalizedDuration(
 1387|      0|      v / N, v % N * kTicksPerNanosecond * 1000 * 1000 * 1000 / N);
 1388|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal9FromInt64ILl1000000000EEENS0_8DurationExNSt3__15ratioILl1EXT_EEE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal9FromInt64ILl1000000EEENS0_8DurationExNSt3__15ratioILl1EXT_EEE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal9FromInt64ILl1000EEENS0_8DurationExNSt3__15ratioILl1EXT_EEE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal9FromInt64ILl1EEENS0_8DurationExNSt3__15ratioILl1EXT_EEE
  ------------------
 1389|      0|constexpr Duration FromInt64(int64_t v, std::ratio<60>) {
 1390|      0|  return (v <= (std::numeric_limits<int64_t>::max)() / 60 &&
 1391|      0|          v >= (std::numeric_limits<int64_t>::min)() / 60)
 1392|      0|             ? MakeDuration(v * 60)
 1393|      0|             : v > 0 ? InfiniteDuration() : -InfiniteDuration();
 1394|      0|}
 1395|      0|constexpr Duration FromInt64(int64_t v, std::ratio<3600>) {
 1396|      0|  return (v <= (std::numeric_limits<int64_t>::max)() / 3600 &&
 1397|      0|          v >= (std::numeric_limits<int64_t>::min)() / 3600)
 1398|      0|             ? MakeDuration(v * 3600)
 1399|      0|             : v > 0 ? InfiniteDuration() : -InfiniteDuration();
 1400|      0|}
 1401|       |
 1402|       |// IsValidRep64<T>(0) is true if the expression `int64_t{std::declval<T>()}` is
 1403|       |// valid. That is, if a T can be assigned to an int64_t without narrowing.
 1404|       |template <typename T>
 1405|       |constexpr auto IsValidRep64(int)
 1406|      0|    -> decltype(int64_t{std::declval<T>()}, bool()) {
 1407|      0|  return true;
 1408|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal12IsValidRep64IxEEDTcmtlxclsr3stdE7declvalIT_EEEcvb_EEi
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal12IsValidRep64IlEEDTcmtlxclsr3stdE7declvalIT_EEEcvb_EEi
  ------------------
 1409|       |template <typename T>
 1410|       |constexpr auto IsValidRep64(char) -> bool {
 1411|       |  return false;
 1412|       |}
 1413|       |
 1414|       |// Converts a std::chrono::duration to an absl::Duration.
 1415|       |template <typename Rep, typename Period>
 1416|      0|constexpr Duration FromChrono(const std::chrono::duration<Rep, Period>& d) {
 1417|      0|  static_assert(IsValidRep64<Rep>(0), "duration::rep is invalid");
 1418|      0|  return FromInt64(int64_t{d.count()}, Period{});
 1419|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal10FromChronoIxNSt3__15ratioILl1ELl1000000000EEEEENS0_8DurationERKNS3_6chrono8durationIT_T0_EE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal10FromChronoIxNSt3__15ratioILl1ELl1000000EEEEENS0_8DurationERKNS3_6chrono8durationIT_T0_EE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal10FromChronoIxNSt3__15ratioILl1ELl1000EEEEENS0_8DurationERKNS3_6chrono8durationIT_T0_EE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal10FromChronoIxNSt3__15ratioILl1ELl1EEEEENS0_8DurationERKNS3_6chrono8durationIT_T0_EE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal10FromChronoIlNSt3__15ratioILl60ELl1EEEEENS0_8DurationERKNS3_6chrono8durationIT_T0_EE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal10FromChronoIlNSt3__15ratioILl3600ELl1EEEEENS0_8DurationERKNS3_6chrono8durationIT_T0_EE
  ------------------
 1420|       |
 1421|       |template <typename Ratio>
 1422|       |int64_t ToInt64(Duration d, Ratio) {
 1423|       |  // Note: This may be used on MSVC, which may have a system_clock period of
 1424|       |  // std::ratio<1, 10 * 1000 * 1000>
 1425|       |  return ToInt64Seconds(d * Ratio::den / Ratio::num);
 1426|       |}
 1427|       |// Fastpath implementations for the 6 common duration units.
 1428|      0|inline int64_t ToInt64(Duration d, std::nano) {
 1429|      0|  return ToInt64Nanoseconds(d);
 1430|      0|}
 1431|      0|inline int64_t ToInt64(Duration d, std::micro) {
 1432|      0|  return ToInt64Microseconds(d);
 1433|      0|}
 1434|      0|inline int64_t ToInt64(Duration d, std::milli) {
 1435|      0|  return ToInt64Milliseconds(d);
 1436|      0|}
 1437|      0|inline int64_t ToInt64(Duration d, std::ratio<1>) {
 1438|      0|  return ToInt64Seconds(d);
 1439|      0|}
 1440|      0|inline int64_t ToInt64(Duration d, std::ratio<60>) {
 1441|      0|  return ToInt64Minutes(d);
 1442|      0|}
 1443|      0|inline int64_t ToInt64(Duration d, std::ratio<3600>) {
 1444|      0|  return ToInt64Hours(d);
 1445|      0|}
 1446|       |
 1447|       |// Converts an absl::Duration to a chrono duration of type T.
 1448|       |template <typename T>
 1449|      0|T ToChronoDuration(Duration d) {
 1450|      0|  using Rep = typename T::rep;
 1451|      0|  using Period = typename T::period;
 1452|      0|  static_assert(IsValidRep64<Rep>(0), "duration::rep is invalid");
 1453|      0|  if (time_internal::IsInfiniteDuration(d))
 1454|      0|    return d < ZeroDuration() ? (T::min)() : (T::max)();
 1455|      0|  const auto v = ToInt64(d, Period{});
 1456|      0|  if (v > (std::numeric_limits<Rep>::max)()) return (T::max)();
 1457|      0|  if (v < (std::numeric_limits<Rep>::min)()) return (T::min)();
 1458|      0|  return T{v};
 1459|      0|}
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal16ToChronoDurationINSt3__16chrono8durationIxNS3_5ratioILl1ELl1000000000EEEEEEET_NS0_8DurationE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal16ToChronoDurationINSt3__16chrono8durationIxNS3_5ratioILl1ELl1000000EEEEEEET_NS0_8DurationE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal16ToChronoDurationINSt3__16chrono8durationIxNS3_5ratioILl1ELl1000EEEEEEET_NS0_8DurationE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal16ToChronoDurationINSt3__16chrono8durationIxNS3_5ratioILl1ELl1EEEEEEET_NS0_8DurationE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal16ToChronoDurationINSt3__16chrono8durationIlNS3_5ratioILl60ELl1EEEEEEET_NS0_8DurationE
  ------------------
  | Unexecuted instantiation: _ZN4absl14lts_2019_08_0813time_internal16ToChronoDurationINSt3__16chrono8durationIlNS3_5ratioILl3600ELl1EEEEEEET_NS0_8DurationE
  ------------------
 1460|       |
 1461|       |}  // namespace time_internal
 1462|       |
 1463|      0|constexpr Duration Nanoseconds(int64_t n) {
 1464|      0|  return time_internal::FromInt64(n, std::nano{});
 1465|      0|}
 1466|      0|constexpr Duration Microseconds(int64_t n) {
 1467|      0|  return time_internal::FromInt64(n, std::micro{});
 1468|      0|}
 1469|      0|constexpr Duration Milliseconds(int64_t n) {
 1470|      0|  return time_internal::FromInt64(n, std::milli{});
 1471|      0|}
 1472|      0|constexpr Duration Seconds(int64_t n) {
 1473|      0|  return time_internal::FromInt64(n, std::ratio<1>{});
 1474|      0|}
 1475|      0|constexpr Duration Minutes(int64_t n) {
 1476|      0|  return time_internal::FromInt64(n, std::ratio<60>{});
 1477|      0|}
 1478|      0|constexpr Duration Hours(int64_t n) {
 1479|      0|  return time_internal::FromInt64(n, std::ratio<3600>{});
 1480|      0|}
 1481|       |
 1482|      0|constexpr bool operator<(Duration lhs, Duration rhs) {
 1483|      0|  return time_internal::GetRepHi(lhs) != time_internal::GetRepHi(rhs)
 1484|      0|             ? time_internal::GetRepHi(lhs) < time_internal::GetRepHi(rhs)
 1485|      0|             : time_internal::GetRepHi(lhs) ==
 1486|      0|                       (std::numeric_limits<int64_t>::min)()
 1487|      0|                   ? time_internal::GetRepLo(lhs) + 1 <
 1488|      0|                         time_internal::GetRepLo(rhs) + 1
 1489|      0|                   : time_internal::GetRepLo(lhs) <
 1490|      0|                         time_internal::GetRepLo(rhs);
 1491|      0|}
 1492|       |
 1493|      0|constexpr bool operator==(Duration lhs, Duration rhs) {
 1494|      0|  return time_internal::GetRepHi(lhs) == time_internal::GetRepHi(rhs) &&
 1495|      0|         time_internal::GetRepLo(lhs) == time_internal::GetRepLo(rhs);
 1496|      0|}
 1497|       |
 1498|      0|constexpr Duration operator-(Duration d) {
 1499|      0|  // This is a little interesting because of the special cases.
 1500|      0|  //
 1501|      0|  // If rep_lo_ is zero, we have it easy; it's safe to negate rep_hi_, we're
 1502|      0|  // dealing with an integral number of seconds, and the only special case is
 1503|      0|  // the maximum negative finite duration, which can't be negated.
 1504|      0|  //
 1505|      0|  // Infinities stay infinite, and just change direction.
 1506|      0|  //
 1507|      0|  // Finally we're in the case where rep_lo_ is non-zero, and we can borrow
 1508|      0|  // a second's worth of ticks and avoid overflow (as negating int64_t-min + 1
 1509|      0|  // is safe).
 1510|      0|  return time_internal::GetRepLo(d) == 0
 1511|      0|             ? time_internal::GetRepHi(d) ==
 1512|      0|                       (std::numeric_limits<int64_t>::min)()
 1513|      0|                   ? InfiniteDuration()
 1514|      0|                   : time_internal::MakeDuration(-time_internal::GetRepHi(d))
 1515|      0|             : time_internal::IsInfiniteDuration(d)
 1516|      0|                   ? time_internal::OppositeInfinity(d)
 1517|      0|                   : time_internal::MakeDuration(
 1518|      0|                         time_internal::NegateAndSubtractOne(
 1519|      0|                             time_internal::GetRepHi(d)),
 1520|      0|                         time_internal::kTicksPerSecond -
 1521|      0|                             time_internal::GetRepLo(d));
 1522|      0|}
 1523|       |
 1524|      0|constexpr Duration InfiniteDuration() {
 1525|      0|  return time_internal::MakeDuration((std::numeric_limits<int64_t>::max)(),
 1526|      0|                                     ~0U);
 1527|      0|}
 1528|       |
 1529|      0|constexpr Duration FromChrono(const std::chrono::nanoseconds& d) {
 1530|      0|  return time_internal::FromChrono(d);
 1531|      0|}
 1532|      0|constexpr Duration FromChrono(const std::chrono::microseconds& d) {
 1533|      0|  return time_internal::FromChrono(d);
 1534|      0|}
 1535|      0|constexpr Duration FromChrono(const std::chrono::milliseconds& d) {
 1536|      0|  return time_internal::FromChrono(d);
 1537|      0|}
 1538|      0|constexpr Duration FromChrono(const std::chrono::seconds& d) {
 1539|      0|  return time_internal::FromChrono(d);
 1540|      0|}
 1541|      0|constexpr Duration FromChrono(const std::chrono::minutes& d) {
 1542|      0|  return time_internal::FromChrono(d);
 1543|      0|}
 1544|      0|constexpr Duration FromChrono(const std::chrono::hours& d) {
 1545|      0|  return time_internal::FromChrono(d);
 1546|      0|}
 1547|       |
 1548|      0|constexpr Time FromUnixNanos(int64_t ns) {
 1549|      0|  return time_internal::FromUnixDuration(Nanoseconds(ns));
 1550|      0|}
 1551|       |
 1552|      0|constexpr Time FromUnixMicros(int64_t us) {
 1553|      0|  return time_internal::FromUnixDuration(Microseconds(us));
 1554|      0|}
 1555|       |
 1556|      0|constexpr Time FromUnixMillis(int64_t ms) {
 1557|      0|  return time_internal::FromUnixDuration(Milliseconds(ms));
 1558|      0|}
 1559|       |
 1560|      0|constexpr Time FromUnixSeconds(int64_t s) {
 1561|      0|  return time_internal::FromUnixDuration(Seconds(s));
 1562|      0|}
 1563|       |
 1564|      0|constexpr Time FromTimeT(time_t t) {
 1565|      0|  return time_internal::FromUnixDuration(Seconds(t));
 1566|      0|}
 1567|       |
 1568|       |}  // inline namespace lts_2019_08_08
 1569|       |}  // namespace absl
 1570|       |
 1571|       |#endif  // ABSL_TIME_TIME_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/types/bad_any_cast.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/types/bad_any_cast.h"
   16|       |
   17|       |#ifndef ABSL_HAVE_STD_ANY
   18|       |
   19|       |#include <cstdlib>
   20|       |
   21|       |#include "absl/base/config.h"
   22|       |#include "absl/base/internal/raw_logging.h"
   23|       |
   24|       |namespace absl {
   25|       |inline namespace lts_2019_08_08 {
   26|       |
   27|      0|bad_any_cast::~bad_any_cast() = default;
   28|       |
   29|      0|const char* bad_any_cast::what() const noexcept { return "Bad any cast"; }
   30|       |
   31|       |namespace any_internal {
   32|       |
   33|      0|void ThrowBadAnyCast() {
   34|      0|#ifdef ABSL_HAVE_EXCEPTIONS
   35|      0|  throw bad_any_cast();
   36|       |#else
   37|       |  ABSL_RAW_LOG(FATAL, "Bad any cast");
   38|       |  std::abort();
   39|       |#endif
   40|       |}
   41|       |
   42|       |}  // namespace any_internal
   43|       |}  // inline namespace lts_2019_08_08
   44|       |}  // namespace absl
   45|       |
   46|       |#endif  // ABSL_HAVE_STD_ANY

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/types/bad_optional_access.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/types/bad_optional_access.h"
   16|       |
   17|       |#ifndef ABSL_HAVE_STD_OPTIONAL
   18|       |
   19|       |#include <cstdlib>
   20|       |
   21|       |#include "absl/base/config.h"
   22|       |#include "absl/base/internal/raw_logging.h"
   23|       |
   24|       |namespace absl {
   25|       |inline namespace lts_2019_08_08 {
   26|       |
   27|      0|bad_optional_access::~bad_optional_access() = default;
   28|       |
   29|      0|const char* bad_optional_access::what() const noexcept {
   30|      0|  return "optional has no value";
   31|      0|}
   32|       |
   33|       |namespace optional_internal {
   34|       |
   35|      0|void throw_bad_optional_access() {
   36|      0|#ifdef ABSL_HAVE_EXCEPTIONS
   37|      0|  throw bad_optional_access();
   38|       |#else
   39|       |  ABSL_RAW_LOG(FATAL, "Bad optional access");
   40|       |  abort();
   41|       |#endif
   42|       |}
   43|       |
   44|       |}  // namespace optional_internal
   45|       |}  // inline namespace lts_2019_08_08
   46|       |}  // namespace absl
   47|       |
   48|       |#endif  // ABSL_HAVE_STD_OPTIONAL

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/types/bad_optional_access.h:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// -----------------------------------------------------------------------------
   16|       |// bad_optional_access.h
   17|       |// -----------------------------------------------------------------------------
   18|       |//
   19|       |// This header file defines the `absl::bad_optional_access` type.
   20|       |
   21|       |#ifndef ABSL_TYPES_BAD_OPTIONAL_ACCESS_H_
   22|       |#define ABSL_TYPES_BAD_OPTIONAL_ACCESS_H_
   23|       |
   24|       |#include <stdexcept>
   25|       |
   26|       |#include "absl/base/config.h"
   27|       |
   28|       |#ifdef ABSL_HAVE_STD_OPTIONAL
   29|       |
   30|       |#include <optional>
   31|       |
   32|       |namespace absl {
   33|       |inline namespace lts_2019_08_08 {
   34|       |using std::bad_optional_access;
   35|       |}  // inline namespace lts_2019_08_08
   36|       |}  // namespace absl
   37|       |
   38|       |#else  // ABSL_HAVE_STD_OPTIONAL
   39|       |
   40|       |namespace absl {
   41|       |inline namespace lts_2019_08_08 {
   42|       |
   43|       |// -----------------------------------------------------------------------------
   44|       |// bad_optional_access
   45|       |// -----------------------------------------------------------------------------
   46|       |//
   47|       |// An `absl::bad_optional_access` type is an exception type that is thrown when
   48|       |// attempting to access an `absl::optional` object that does not contain a
   49|       |// value.
   50|       |//
   51|       |// Example:
   52|       |//
   53|       |//   absl::optional<int> o;
   54|       |//
   55|       |//   try {
   56|       |//     int n = o.value();
   57|       |//   } catch(const absl::bad_optional_access& e) {
   58|       |//     std::cout << "Bad optional access: " << e.what() << '\n';
   59|       |//   }
   60|       |class bad_optional_access : public std::exception {
   61|       | public:
   62|      0|  bad_optional_access() = default;
   63|       |  ~bad_optional_access() override;
   64|       |  const char* what() const noexcept override;
   65|       |};
   66|       |
   67|       |namespace optional_internal {
   68|       |
   69|       |// throw delegator
   70|       |[[noreturn]] void throw_bad_optional_access();
   71|       |
   72|       |}  // namespace optional_internal
   73|       |}  // inline namespace lts_2019_08_08
   74|       |}  // namespace absl
   75|       |
   76|       |#endif  // ABSL_HAVE_STD_OPTIONAL
   77|       |
   78|       |#endif  // ABSL_TYPES_BAD_OPTIONAL_ACCESS_H_

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/types/bad_variant_access.cc:
    1|       |// Copyright 2017 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include "absl/types/bad_variant_access.h"
   16|       |
   17|       |#ifndef ABSL_HAVE_STD_VARIANT
   18|       |
   19|       |#include <cstdlib>
   20|       |#include <stdexcept>
   21|       |
   22|       |#include "absl/base/config.h"
   23|       |#include "absl/base/internal/raw_logging.h"
   24|       |
   25|       |namespace absl {
   26|       |inline namespace lts_2019_08_08 {
   27|       |
   28|       |//////////////////////////
   29|       |// [variant.bad.access] //
   30|       |//////////////////////////
   31|       |
   32|      0|bad_variant_access::~bad_variant_access() = default;
   33|       |
   34|      0|const char* bad_variant_access::what() const noexcept {
   35|      0|  return "Bad variant access";
   36|      0|}
   37|       |
   38|       |namespace variant_internal {
   39|       |
   40|      0|void ThrowBadVariantAccess() {
   41|      0|#ifdef ABSL_HAVE_EXCEPTIONS
   42|      0|  throw bad_variant_access();
   43|       |#else
   44|       |  ABSL_RAW_LOG(FATAL, "Bad variant access");
   45|       |  abort();  // TODO(calabrese) Remove once RAW_LOG FATAL is noreturn.
   46|       |#endif
   47|       |}
   48|       |
   49|      0|void Rethrow() {
   50|      0|#ifdef ABSL_HAVE_EXCEPTIONS
   51|      0|  throw;
   52|       |#else
   53|       |  ABSL_RAW_LOG(FATAL,
   54|       |               "Internal error in absl::variant implementation. Attempted to "
   55|       |               "rethrow an exception when building with exceptions disabled.");
   56|       |  abort();  // TODO(calabrese) Remove once RAW_LOG FATAL is noreturn.
   57|       |#endif
   58|       |}
   59|       |
   60|       |}  // namespace variant_internal
   61|       |}  // inline namespace lts_2019_08_08
   62|       |}  // namespace absl
   63|       |
   64|       |#endif  // ABSL_HAVE_STD_VARIANT

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/abseil/absl/types/bad_variant_access.h:
    1|       |// Copyright 2018 The Abseil Authors.
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      https://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |//
   15|       |// -----------------------------------------------------------------------------
   16|       |// bad_variant_access.h
   17|       |// -----------------------------------------------------------------------------
   18|       |//
   19|       |// This header file defines the `absl::bad_variant_access` type.
   20|       |
   21|       |#ifndef ABSL_TYPES_BAD_VARIANT_ACCESS_H_
   22|       |#define ABSL_TYPES_BAD_VARIANT_ACCESS_H_
   23|       |
   24|       |#include <stdexcept>
   25|       |
   26|       |#include "absl/base/config.h"
   27|       |
   28|       |#ifdef ABSL_HAVE_STD_VARIANT
   29|       |
   30|       |#include <variant>
   31|       |
   32|       |namespace absl {
   33|       |inline namespace lts_2019_08_08 {
   34|       |using std::bad_variant_access;
   35|       |}  // inline namespace lts_2019_08_08
   36|       |}  // namespace absl
   37|       |
   38|       |#else  // ABSL_HAVE_STD_VARIANT
   39|       |
   40|       |namespace absl {
   41|       |inline namespace lts_2019_08_08 {
   42|       |
   43|       |// -----------------------------------------------------------------------------
   44|       |// bad_variant_access
   45|       |// -----------------------------------------------------------------------------
   46|       |//
   47|       |// An `absl::bad_variant_access` type is an exception type that is thrown in
   48|       |// the following cases:
   49|       |//
   50|       |//   * Calling `absl::get(absl::variant) with an index or type that does not
   51|       |//     match the currently selected alternative type
   52|       |//   * Calling `absl::visit on an `absl::variant` that is in the
   53|       |//     `variant::valueless_by_exception` state.
   54|       |//
   55|       |// Example:
   56|       |//
   57|       |//   absl::variant<int, std::string> v;
   58|       |//   v = 1;
   59|       |//   try {
   60|       |//     absl::get<std::string>(v);
   61|       |//   } catch(const absl::bad_variant_access& e) {
   62|       |//     std::cout << "Bad variant access: " << e.what() << '\n';
   63|       |//   }
   64|       |class bad_variant_access : public std::exception {
   65|       | public:
   66|      0|  bad_variant_access() noexcept = default;
   67|       |  ~bad_variant_access() override;
   68|       |  const char* what() const noexcept override;
   69|       |};
   70|       |
   71|       |namespace variant_internal {
   72|       |
   73|       |[[noreturn]] void ThrowBadVariantAccess();
   74|       |[[noreturn]] void Rethrow();
   75|       |
   76|       |}  // namespace variant_internal
   77|       |}  // inline namespace lts_2019_08_08
   78|       |}  // namespace absl
   79|       |
   80|       |#endif  // ABSL_HAVE_STD_VARIANT
   81|       |
   82|       |#endif  // ABSL_TYPES_BAD_VARIANT_ACCESS_H_

