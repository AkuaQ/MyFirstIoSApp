/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/AppDelegate.swift:
    1|       |//
    2|       |//  AppDelegate.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/07.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import OAuthSwift
   11|       |import Firebase
   12|       |
   13|       |@UIApplicationMain
   14|       |class AppDelegate: UIResponder, UIApplicationDelegate {
   15|       |    
   16|       |    var window: UIWindow?
   17|       |    
   18|       |    func application(_ application: UIApplication, didFinishLaunchingWithOptions
   19|     14|        launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
   20|     14|        // Override point for customization after application launch.
   21|     14|        FirebaseApp.configure()
   22|     14|        return true
   23|     14|    }
   24|       |    
   25|      0|    func applicationWillResignActive(_ application: UIApplication) {
   26|      0|        // Sent when the application is about to move from active to inactive state.
   27|      0|        //This can occur for certain types of temporary interruptions (such as an incoming
   28|      0|        //phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
   29|      0|        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks.
   30|      0|        //Games should use this method to pause the game.
   31|      0|    }
   32|       |    
   33|      0|    func applicationDidEnterBackground(_ application: UIApplication) {
   34|      0|        // Use this method to release shared resources, save user data, invalidate timers,
   35|      0|        //and store enough application state information to restore your application
   36|      0|        //to its current state in case it is terminated later.
   37|      0|        // If your application supports background execution, this method is called
   38|      0|        //instead of applicationWillTerminate: when the user quits.
   39|      0|    }
   40|       |    
   41|      0|    func applicationWillEnterForeground(_ application: UIApplication) {
   42|      0|        // Called as part of the transition from the background to the active state;
   43|      0|        //here you can undo many of the changes made on entering the background.
   44|      0|    }
   45|       |    
   46|     14|    func applicationDidBecomeActive(_ application: UIApplication) {
   47|     14|        // Restart any tasks that were paused (or not yet started) while the application was inactive.
   48|     14|        //If the application was previously in the background, optionally refresh the user interface.
   49|     14|    }
   50|       |    
   51|      0|    func applicationWillTerminate(_ application: UIApplication) {
   52|      0|        // Called when the application is about to terminate. Save data if appropriate.
   53|      0|        //See also applicationDidEnterBackground:.
   54|      0|    }
   55|       |    
   56|      0|    func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -> Bool {
   57|      0|        applicationHandle(url: url)
   58|      0|        return true
   59|      0|    }
   60|       |
   61|       |    @available(iOS 9.0, *)
   62|       |    func application(_ app: UIApplication, open url: URL,
   63|      0|                     options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
   64|      0|        applicationHandle(url: url)
   65|      0|        return true
   66|      0|    }
   67|       |}
   68|       |
   69|       |// MARK: handle callback url
   70|       |extension AppDelegate {
   71|      0|    func applicationHandle(url: URL) {
   72|      0|        if url.host == "oauth-callback" {
   73|      0|            OAuthSwift.handle(url: url)
   74|      0|        } else {
   75|      0|            // Google provider is the only one wuth your.bundle.id url schema.
   76|      0|            OAuthSwift.handle(url: url)
   77|      0|        }
   78|      0|    }
   79|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/BookDetails/Repository/DetailRepository.swift:
    1|       |//
    2|       |//  DetailRepository.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/04.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import OAuthSwift
   11|       |import SWXMLHash
   12|       |import SwiftyJSON
   13|       |
   14|       |class DetailRepository: DetailRepositoring, DetailRepositorable {
   15|       |    
   16|       |    var oauthswift: OAuthSwift?
   17|       |    var userId: String?
   18|       |    
   19|       |    weak var vModel: DetailViewModelling?
   20|     12|    lazy var alamofireService: DetailsAlamofireServicing = { return DetailsAlamofireService(repo: self) }()
   21|     12|    lazy var oauthService: DetailsOAuthswiftServicing = { return DetailsOAuthswiftService(repo: self) }()
   22|       |    
   23|     12|    func setViewModel(vModel: DetailViewModelling) {
   24|     12|        self.vModel = vModel
   25|     12|    }
   26|       |    
   27|      7|    func checkIfInList() {
   28|      7|        oauthService.getBookList()
   29|      7|    }
   30|       |    
   31|      7|    func parseBooklist(_ xml: XMLIndexer) {
   32|      7|        var books: [String] = []
   33|      7|        var reviews: [String] = []
   34|      7|        //Change this to include if statement inside for loop to speed up process
   35|    140|        for elem in xml["GoodreadsResponse"]["reviews"]["review"].all {
   36|    140|            //Add book ID to array
   37|    140|            books.append(elem["book"]["id"].element?.text ?? "")
   38|    140|            reviews.append(elem["id"].element?.text ?? "")
   39|    140|        }
   40|      7|        
   41|      7|        self.vModel?.compareList(books, reviews)
   42|      7|    }
   43|       |    
   44|      1|    func getUserId() -> String {
   45|      1|        guard let userID = userId else {
   46|      1|            return "error"
   47|      1|        }
   48|      0|        return userID
   49|      1|    }
   50|       |    
   51|      1|    func postToShelf(params: [String: Any]) {
   52|      1|        oauthService.postToShelf(params: params)
   53|      1|    }
   54|       |    
   55|      1|    func setBookmarkStatus() {
   56|      1|        vModel?.setBookmarkStatus()
   57|      1|    }
   58|       |    
   59|     12|    func getBookID (reviewDetails: String) {
   60|     12|        oauthService.getBookData(reviewDetails)
   61|     12|    }
   62|       |    
   63|      7|    func parseBookDetails(_ xml: XMLIndexer) {
   64|      7|        guard let bookId = xml["GoodreadsResponse"]["search"]["results"]["work"][0]["best_book"]["id"].element?.text else {
   65|      0|            self.vModel?.errorAlert("error3")
   66|      0|            return
   67|      7|        }
   68|      7|        self.vModel?.setBookID(bookId)
   69|      7|        alamofireService.getBook(bookId)
   70|      7|    }
   71|       |    
   72|      5|    func parseExtraDetails(_ xml: XMLIndexer) {
   73|      5|        guard let avgRating = xml["GoodreadsResponse"]["book"]["average_rating"].element?.text else {
   74|      0|            return
   75|      5|        }
   76|      5|        guard let numReviews = xml["GoodreadsResponse"]["book"]["work"]["ratings_count"].element?.text else {
   77|      0|            return
   78|      5|        }
   79|      5|        guard let publisher = xml["GoodreadsResponse"]["book"]["publisher"].element?.text else {
   80|      0|            return
   81|      5|        }
   82|      5|        guard let publishedYear = xml["GoodreadsResponse"]["book"]["publication_year"].element?.text else {
   83|      0|            return
   84|      5|        }
   85|      5|        
   86|      5|        guard let description = xml["GoodreadsResponse"]["book"]["description"].element?.text else {
   87|      0|            return
   88|      5|        }
   89|      5|        
   90|      5|        var similarBooksArray: [SimilarBook] = []
   91|     90|        for similar in xml["GoodreadsResponse"]["book"]["similar_books"]["book"].all {
   92|     90|            guard let similarBookId = similar["id"].element?.text else {
   93|      0|                return
   94|     90|            }
   95|     90|            guard let imageLink = (similar["image_url"].element?.text) else {
   96|      0|                return
   97|     90|            }
   98|     90|            guard let bookLink = (similar["link"].element?.text) else {
   99|      0|                return
  100|     90|            }
  101|     90|            guard let author = (similar["authors"]["author"]["name"].element?.text) else {
  102|      0|                return
  103|     90|            }
  104|     90|            guard let title = (similar["title"].element?.text) else {
  105|      0|                return
  106|     90|            }
  107|     90|            guard let pages = (similar["num_pages"].element?.text) else {
  108|      0|                return
  109|     90|            }
  110|     90|            guard let isbn = (similar["isbn"].element?.text) else {
  111|      0|                return
  112|     90|            }
  113|     90|            similarBooksArray.append(SimilarBook(bookId: similarBookId, imageLink: imageLink, title: title, author: author, bookLink: bookLink, pages: pages, isbn: isbn))
  114|     90|            
  115|     90|        }
  116|      5|        
  117|      5|        let extraDetailsModel = ExtraDetailsModel(avgRating: avgRating, numReviews: numReviews, yearPublished: publishedYear, publisher: publisher, details: description, similarBooks: similarBooksArray)
  118|      5|        vModel?.setRemainingDetails(model: extraDetailsModel)
  119|      5|    }
  120|       |    
  121|     12|    func checkReviews(_ reviewData: String) {
  122|     12|        alamofireService.checkReviews(reviewData)
  123|     12|    }
  124|       |    
  125|      8|    func decodeReviewCheck(json: JSON?) {
  126|      8|        let results = json?["book"]["critic_reviews"].arrayValue
  127|      8|        
  128|      8|        guard let empty = results?.isEmpty, !empty else {
  129|      2|            self.vModel?.setReviewVisibility(hasReviews: false)
  130|      2|            return
  131|      6|        }
  132|      6|        self.vModel?.setReviewVisibility(hasReviews: true)
  133|      6|        
  134|      6|        guard let review = (results?[0]["snippet"].stringValue) else {
  135|      0|            return
  136|      6|        }
  137|      6|        guard let reviewer = (results?[0]["source"].stringValue) else {
  138|      0|            return
  139|      6|        }
  140|      6|        guard let rating = (results?[0]["star_rating"].stringValue) else {
  141|      0|            return
  142|      6|        }
  143|      6|        guard let imageLink = results?[0]["source_logo"].stringValue else {
  144|      0|            return
  145|      6|        }
  146|      6|        
  147|      6|        let firstReview = ReviewModel(reviewerImageLink: imageLink, reviewerName: reviewer, rating: rating, review: review)
  148|      6|        
  149|      6|        self.vModel?.setFirstReview(review: firstReview)
  150|      6|    }
  151|       |    
  152|      1|    func errorAlert(_ error: String) {
  153|      1|        vModel?.errorAlert(error)
  154|      1|    }
  155|       |    
  156|      0|    func getToken() {
  157|      0|        let preferences = UserDefaults.standard
  158|      0|        let key = "oauth"
  159|      0|        if preferences.object(forKey: key) == nil {
  160|      0|            vModel?.errorAlert("error4")
  161|      0|        } else {
  162|      0|            let decoded  = preferences.object(forKey: key) as! Data
  163|      0|            if let credential = NSKeyedUnarchiver.unarchiveObject(with: decoded) as? OAuthSwiftCredential {
  164|      0|                guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
  165|      0|                    return
  166|      0|                }
  167|      0|                guard let goodreadsSecret = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Secret") as? String else {
  168|      0|                    return
  169|      0|                }
  170|      0|                let oauthS = OAuth1Swift(consumerKey: goodreadsKey,
  171|      0|                                         consumerSecret: goodreadsSecret)
  172|      0|                oauthS.client.credential.oauthToken = credential.oauthToken
  173|      0|                oauthS.client.credential.oauthTokenSecret = credential.oauthTokenSecret
  174|      0|                oauthService.setToken(oauthS)
  175|      0|            }
  176|      0|        }
  177|      0|        
  178|      0|        let idKey = "userID"
  179|      0|        if preferences.object(forKey: idKey) != nil {
  180|      0|            guard let safeId = preferences.string(forKey: idKey) else {
  181|      0|                return
  182|      0|            }
  183|      0|            userId = safeId
  184|      0|        }
  185|      0|    }
  186|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/BookDetails/Services/DetailsAlamofireService.swift:
    1|       |//
    2|       |//  DetailsAlamofireService.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/19.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Alamofire
   11|       |import SwiftyJSON
   12|       |import SWXMLHash
   13|       |
   14|       |class DetailsAlamofireService: DetailsAlamofireServicing {
   15|       |    weak var repo: DetailRepositorable?
   16|       |    
   17|     12|    init(repo: DetailRepositorable) {
   18|     12|        self.repo = repo
   19|     12|    }
   20|       |    
   21|     12|    func checkReviews(_ reviewData: String) {
   22|     12|        let uiTesting = ProcessInfo.processInfo.arguments.contains("Testing")
   23|     12|        
   24|     12|        if uiTesting {
   25|     12|            if let path = Bundle.main.path(forResource: "\(reviewData)_Reviews", ofType: "json") {
   26|      8|                do {
   27|      8|                    let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .alwaysMapped)
   28|      8|                    let jsonObj = try JSON(data: data)
   29|      8|                    repo?.decodeReviewCheck(json: jsonObj)
   30|      8|                } catch let error {
   31|      0|                    print("parse error: \(error.localizedDescription)")
   32|      8|                }
   33|     12|            } else {
   34|      4|                print("Invalid filename/path.")
   35|     12|            }
   36|     12|
   37|     12|        } else {
   38|      0|            guard let iDreamKey = Bundle.main.object(forInfoDictionaryKey: "iDreamBooks_Key") else {
   39|      0|                return
   40|      0|            }
   41|      0|            let urlWithSpaces = "https://idreambooks.com/api/books/reviews.json?q=\(reviewData)&key=\(iDreamKey)"
   42|      0|            
   43|      0|            guard let url = urlWithSpaces.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
   44|      0|                return
   45|      0|            }
   46|      0|            
   47|      0|            Alamofire.request(url).responseJSON { response in
   48|      0|                guard let data = response.data else {
   49|      0|                    self.repo?.errorAlert("error1")
   50|      0|                    return
   51|      0|                }
   52|      0|                let json = try? JSON(data: data)
   53|      0|                self.repo?.decodeReviewCheck(json: json)
   54|      0|            }
   55|     12|        }
   56|     12|    }
   57|       |    
   58|      7|    func getBook(_ bookId: String) {
   59|      7|        let uiTesting = ProcessInfo.processInfo.arguments.contains("Testing")
   60|      7|        if uiTesting {
   61|      7|            if let path = Bundle.main.path(forResource: "\(bookId)_Details", ofType: "xml") {
   62|      5|                do {
   63|      5|                    let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .alwaysMapped)
   64|      5|                    let xml = SWXMLHash.parse(data)
   65|      5|                    repo?.parseExtraDetails(xml)
   66|      5|                } catch let error {
   67|      0|                    print("parse error: \(error.localizedDescription)")
   68|      5|                }
   69|      7|            } else {
   70|      2|                print("Invalid filename/path.")
   71|      7|            }
   72|      7|        } else {
   73|      0|            guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") else {
   74|      0|                return
   75|      0|            }
   76|      0|            let url = "https://www.goodreads.com/book/show/\(bookId)?key=\(goodreadsKey)"
   77|      0|            Alamofire.request(url, method: .get).response { response in
   78|      0|                
   79|      0|                guard let data = response.data else {
   80|      0|                    self.repo?.errorAlert("error4") //Add error 4 or fix code
   81|      0|                    return
   82|      0|                }
   83|      0|                //Add another guard
   84|      0|                let xml = SWXMLHash.parse(data)
   85|      0|                self.repo?.parseExtraDetails(xml)
   86|      0|            }
   87|      7|        }
   88|      7|    }
   89|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/BookDetails/Services/DetailsOAuthswiftService.swift:
    1|       |//
    2|       |//  DetailsOAuthswiftService.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/19.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import OAuthSwift
   11|       |import SWXMLHash
   12|       |
   13|       |class DetailsOAuthswiftService: DetailsOAuthswiftServicing {
   14|       |    weak var repo: DetailRepositorable?
   15|       |    var oauthswift: OAuthSwift?
   16|       |    
   17|     12|    init(repo: DetailRepositorable) {
   18|     12|        self.repo = repo
   19|     12|    }
   20|       |    
   21|      0|    func setToken(_ token: OAuthSwift) {
   22|      0|        oauthswift = token
   23|      0|    }
   24|       |    
   25|      7|    func getBookList() {
   26|      7|        let uiTesting = ProcessInfo.processInfo.arguments.contains("Testing")
   27|      7|        
   28|      7|        if uiTesting {
   29|      7|            if let path = Bundle.main.path(forResource: "Book_List", ofType: "xml") {
   30|      7|                do {
   31|      7|                    let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .alwaysMapped)
   32|      7|                    let xml = SWXMLHash.parse(data)
   33|      7|                    repo?.parseBooklist(xml)
   34|      7|                } catch let error {
   35|      0|                    print("parse error: \(error.localizedDescription)")
   36|      7|                }
   37|      7|            } else {
   38|      0|                print("Invalid filename/path.")
   39|      7|            }
   40|      7|        } else {
   41|      0|            let oauthSwift: OAuth1Swift = oauthswift as! OAuth1Swift
   42|      0|            guard let userId = repo?.getUserId() else {
   43|      0|                return
   44|      0|            }
   45|      0|            //Uses ID that was received to get a list of users books read
   46|      0|            guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") else {
   47|      0|                return
   48|      0|            }
   49|      0|            _ = oauthSwift.client.request(
   50|      0|                "https://www.goodreads.com/review/list/\(userId).xml?key=\(goodreadsKey)&v=2", method: .GET,
   51|      0|                success: { response in
   52|      0|                    
   53|      0|                    guard let dataString = response.string else {
   54|      0|                        return
   55|      0|                    }
   56|      0|                    let xml = SWXMLHash.parse(dataString)
   57|      0|                    self.repo?.parseBooklist(xml)
   58|      0|            }, failure: { _ in
   59|      0|                self.repo?.errorAlert("error1")
   60|      0|            }
   61|      0|            )
   62|      7|        }
   63|      7|    }
   64|       |    
   65|     12|    func getBookData(_ reviewDetails: String) {
   66|     12|        let uiTesting = ProcessInfo.processInfo.arguments.contains("Testing")
   67|     12|        let uiErrorCase = ProcessInfo.processInfo.arguments.contains("Error")
   68|     12|        
   69|     12|        if uiErrorCase {
   70|      1|            repo?.errorAlert("error1")
   71|      1|            return
   72|     11|        }
   73|     11|        
   74|     11|        if uiTesting {
   75|     11|            if let path = Bundle.main.path(forResource: "\(reviewDetails)_Results", ofType: "xml") {
   76|      7|                do {
   77|      7|                    let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .alwaysMapped)
   78|      7|                    let xml = SWXMLHash.parse(data)
   79|      7|                    repo?.parseBookDetails(xml)
   80|      7|                } catch let error {
   81|      0|                    print("parse error: \(error.localizedDescription)")
   82|      7|                }
   83|     11|            } else {
   84|      4|                print("Invalid filename/path.")
   85|     11|            }
   86|     11|        } else {
   87|      0|            repo?.getToken()
   88|      0|            let oauthSwift: OAuth1Swift = oauthswift as! OAuth1Swift
   89|      0|            
   90|      0|            guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") else {
   91|      0|                return
   92|      0|            }
   93|      0|            
   94|      0|            let urlWithSpaces = "https://www.goodreads.com/search/index.xml?key=\(goodreadsKey)&q=\(reviewDetails)&search[title]"
   95|      0|            guard let url = urlWithSpaces.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
   96|      0|                return
   97|      0|            }
   98|      0|            
   99|      0|            _ = oauthSwift.client.get(url,
  100|      0|                                      success: { response in
  101|      0|                                        guard let dataString = response.string else {
  102|      0|                                            self.repo?.errorAlert("error3")
  103|      0|                                            return
  104|      0|                                        }
  105|      0|                                        let xml = SWXMLHash.parse(dataString)
  106|      0|                                        self.repo?.parseBookDetails(xml)
  107|      0|            }, failure: { _ in
  108|      0|                self.repo?.errorAlert("error1")
  109|      0|            })
  110|     11|        }
  111|     11|    }
  112|       |    
  113|      1|    func postToShelf(params: [String: Any]) {
  114|      1|        let uiTesting = ProcessInfo.processInfo.arguments.contains("Testing")
  115|      1|        if !uiTesting {
  116|      0|            let oauthSwift: OAuth1Swift = oauthswift as! OAuth1Swift
  117|      0|            
  118|      0|            _ = oauthSwift.client.post("https://www.goodreads.com/shelf/add_to_shelf.xml", parameters: params,
  119|      0|                                       success: { _ in
  120|      0|                                        self.repo?.setBookmarkStatus()},
  121|      0|                                       failure: {_ in
  122|      0|                                        self.repo?.errorAlert("error2")
  123|      0|            })
  124|      1|        } else {
  125|      1|            sleep(1)
  126|      1|            repo?.setBookmarkStatus()
  127|      1|        }
  128|      1|    }
  129|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/BookDetails/View/ViewController/NewDetailViewController.swift:
    1|       |//
    2|       |//  NewDetailViewController.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/04/17.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import SafariServices
   11|       |
   12|       |class NewDetailViewController: UIViewController {
   13|       |    
   14|       |    @IBOutlet weak var bookTitle: UILabel!
   15|       |    @IBOutlet weak var bookAuthor: UILabel!
   16|       |    @IBOutlet weak var bookAverageRating: CosmosView!
   17|       |    @IBOutlet weak var bookNumRatings: UILabel!
   18|       |    @IBOutlet weak var bookPages: UILabel!
   19|       |    @IBOutlet weak var bookPublisherInfo: UILabel!
   20|       |    @IBOutlet weak var bookImage: UIImageView!
   21|       |    @IBOutlet weak var bookSynopsis: UITextView!
   22|       |    @IBOutlet weak var reviewerImage: UIImageView!
   23|       |    @IBOutlet weak var reviewText: UITextView!
   24|       |    @IBOutlet weak var reviewerTitle: UILabel!
   25|       |    @IBOutlet weak var reviewerRating: CosmosView!
   26|       |    @IBOutlet weak var similarBook1: UIImageView!
   27|       |    @IBOutlet weak var similarBook2: UIImageView!
   28|       |    @IBOutlet weak var similarBook3: UIImageView!
   29|       |    @IBOutlet weak var similarBook4: UIImageView!
   30|       |    @IBOutlet weak var bookLinkButton: UIButton!
   31|       |    @IBOutlet weak var bookmarkButton: UIButton!
   32|       |    @IBOutlet weak var seeAllButton: UIButton!
   33|       |    @IBOutlet weak var secondLoadActivity: UIActivityIndicatorView!
   34|       |    
   35|       |    var reviewDetailsToSend: String?
   36|       |    var readingLink: String?
   37|       |    
   38|       |    var bookModel: SearchModel?
   39|       |    var newModel: ExtraDetailsModel?
   40|       |    
   41|     12|    lazy var model: DetailViewModelling = { return DetailViewModel(view: self, repo: DetailRepository()) }()
   42|       |    
   43|     12|    override func viewDidLoad() {
   44|     12|        super.viewDidLoad()
   45|     12|        setupView()
   46|     12|        secondLoadActivity.startAnimating()
   47|     12|        secondLoadActivity.hidesWhenStopped = true
   48|     12|    }
   49|       |    
   50|      0|    @IBAction func openBookLink(_ sender: UIButton) {
   51|      0|        let svc = SFSafariViewController(url: URL(string: readingLink!)!)
   52|      0|        self.present(svc, animated: true, completion: nil)
   53|      0|    }
   54|       |    
   55|      1|    @IBAction func bookmarkBook(_ sender: UIButton) {
   56|      1|        model.modifyBookshelf()
   57|      1|    }
   58|       |    
   59|      1|    @IBAction func seeAllReviews(_ sender: UIButton) {
   60|      1|        if let vControl = storyboard?.instantiateViewController(withIdentifier: "Reviews") as? ReviewsTableViewController {
   61|      1|            vControl.reviewDetails = reviewDetailsToSend
   62|      1|            vControl.title = "Reviews for: \(reviewDetailsToSend ?? "Error - No book")"
   63|      1|            navigationController?.pushViewController(vControl, animated: true)
   64|      1|        }
   65|      1|    }
   66|       |    
   67|      1|    @IBAction func leaveReview(_ sender: UIButton) {
   68|      1|        if let vControl = storyboard?.instantiateViewController(withIdentifier: "MyReview") as? MyReviewViewController {
   69|      1|            vControl.title = "Review for: \(bookTitle.text ?? "Error - No book")"
   70|      1|            let detailModel = model.getModel()
   71|      1|            vControl.detailModel = detailModel
   72|      1|            navigationController?.pushViewController(vControl, animated: true)
   73|      1|        }
   74|      1|    }
   75|       |    
   76|      5|    func doRemainingSetup() {
   77|      5|        if let publisher = newModel?.publisher {
   78|      5|            if let year = newModel?.yearPublished {
   79|      5|                self.bookPublisherInfo.text = "\(publisher) (\(year))"
   80|      5|            }
   81|      5|        }
   82|      5|        
   83|      5|        if let rating = newModel?.avgRating {
   84|      5|            if let convertedRating = Double(rating) {
   85|      5|                self.bookAverageRating.rating = convertedRating
   86|      5|            }
   87|      5|        }
   88|      5|        
   89|      5|        if let numRatings = newModel?.numReviews {
   90|      5|            self.bookNumRatings.text = numRatings
   91|      5|        }
   92|      5|        
   93|      5|        if let desc = newModel?.details {
   94|      5|            if self.bookSynopsis.text == "" {
   95|      0|                self.bookSynopsis.text = desc
   96|      5|            }
   97|      5|        }
   98|      5|        
   99|      5|        var count = 0
  100|      5|        if let similar = newModel?.similarBooks {
  101|     90|            for book in similar where count < 4 {
  102|     90|                    switch count {
  103|     90|                    case 0: similarBook1.fetchImage(url: book.imageLink)
  104|      5|                    let tapGesture1 = UITapGestureRecognizer(target: self, action: #selector(NewDetailViewController.image1Tapped(gesture:)))
  105|      5|                    similarBook1.addGestureRecognizer(tapGesture1)
  106|      5|                    similarBook1.isUserInteractionEnabled = true
  107|     90|
  108|     90|                    case 1: similarBook2.fetchImage(url: book.imageLink)
  109|      5|                    let tapGesture2 = UITapGestureRecognizer(target: self, action: #selector(NewDetailViewController.image2Tapped(gesture:)))
  110|      5|                    similarBook2.addGestureRecognizer(tapGesture2)
  111|      5|                    similarBook2.isUserInteractionEnabled = true
  112|     90|
  113|     90|                    case 2: similarBook3.fetchImage(url: book.imageLink)
  114|      5|                    let tapGesture3 = UITapGestureRecognizer(target: self, action: #selector(NewDetailViewController.image3Tapped(gesture:)))
  115|      5|                    similarBook3.addGestureRecognizer(tapGesture3)
  116|      5|                    similarBook3.isUserInteractionEnabled = true
  117|     90|                        
  118|     90|                    case 3: similarBook4.fetchImage(url: book.imageLink)
  119|      5|                    let tapGesture4 = UITapGestureRecognizer(target: self, action: #selector(NewDetailViewController.image4Tapped(gesture:)))
  120|      5|                    similarBook4.addGestureRecognizer(tapGesture4)
  121|      5|                    similarBook4.isUserInteractionEnabled = true
  122|     90|                        
  123|     90|                    default: break
  124|     90|                    }
  125|     20|                    count += 1
  126|     20|                
  127|  18.4E|            }
  128|  18.4E|        }
  129|  18.4E|    }
  130|       |    
  131|      1|    @objc func image1Tapped(gesture: UIGestureRecognizer) {
  132|      1|        if (gesture.view as? UIImageView) != nil {
  133|      1|            let book = newModel?.similarBooks[0]
  134|      1|            openSimilarBook(book: book)
  135|      1|        }
  136|      1|    }
  137|       |    
  138|      4|    func openSimilarBook(book: SimilarBook?) {
  139|      4|        if let title = book?.title {
  140|      4|            let bookModel = SearchModel(title: title, authors: book!.author, smallImageUrl: book!.imageLink, largeImageUrl: book!.imageLink, publishedDate: "", reviewInfo: book!.isbn, isbn: book!.isbn, pageNumbers: book!.pages, genres: nil, description: "", webLink: book!.bookLink)
  141|      4|            if let vControl = storyboard?.instantiateViewController(withIdentifier: "NewDetail") as? NewDetailViewController {
  142|      4|                vControl.bookModel = bookModel
  143|      4|                navigationController?.pushViewController(vControl, animated: true)
  144|      4|            }
  145|      4|        }
  146|      4|    }
  147|       |    
  148|      1|    @objc func image2Tapped(gesture: UIGestureRecognizer) {
  149|      1|        if (gesture.view as? UIImageView) != nil {
  150|      1|            let book = newModel?.similarBooks[1]
  151|      1|            openSimilarBook(book: book)
  152|      1|            
  153|      1|        }
  154|      1|    }
  155|       |    
  156|      1|    @objc func image3Tapped(gesture: UIGestureRecognizer) {
  157|      1|        if (gesture.view as? UIImageView) != nil {
  158|      1|            let book = newModel?.similarBooks[2]
  159|      1|            openSimilarBook(book: book)
  160|      1|            
  161|      1|        }
  162|      1|    }
  163|       |    
  164|      1|    @objc func image4Tapped(gesture: UIGestureRecognizer) {
  165|      1|        if (gesture.view as? UIImageView) != nil {
  166|      1|            let book = newModel?.similarBooks[3]
  167|      1|            openSimilarBook(book: book)
  168|      1|            
  169|      1|        }
  170|      1|    }
  171|       |    
  172|     12|    func setupView() {
  173|     12|        if let titleToLoad = bookModel?.title {
  174|     12|            self.bookTitle.text = titleToLoad
  175|     12|        }
  176|     12|        
  177|     12|        if let authorToLoad = bookModel?.authors {
  178|     12|            self.bookAuthor.text = authorToLoad
  179|     12|        }
  180|     12|        
  181|     12|        if let descriptionToLoad = bookModel?.description {
  182|     12|            self.bookSynopsis.text = descriptionToLoad
  183|     12|        }
  184|     12|        
  185|     12|        if let pagesToLoad = bookModel?.pageNumbers {
  186|     12|            self.bookPages.text = pagesToLoad
  187|     12|        }
  188|     12|        
  189|     12|        if let url = bookModel?.largeImageUrl {
  190|     12|            self.bookImage.fetchImage(url: url)
  191|     12|        }
  192|     12|        
  193|     12|        readingLink = bookModel?.webLink
  194|     12|        if readingLink == nil {
  195|      0|            self.bookLinkButton.isHidden = true
  196|     12|        }
  197|     12|        reviewDetailsToSend = bookModel?.reviewInfo
  198|     12|        
  199|     12|        if let reviewDetailsToSend = reviewDetailsToSend {
  200|     12|            model.checkIfInList(reviewDetailsToSend)
  201|     12|            model.checkReviews(reviewDetailsToSend)
  202|     12|        }
  203|     12|        
  204|     12|    }
  205|       |}
  206|       |extension NewDetailViewController: DetailViewControllable {
  207|       |    
  208|      8|    func setReadStatus(read: Bool) {
  209|      8|        secondLoadActivity.stopAnimating()
  210|      8|        if read {
  211|      5|            self.bookmarkButton.setImage(UIImage(named: "bookmarkFilled2"), for: .normal)
  212|      8|        } else {
  213|      3|            self.bookmarkButton.setImage(UIImage(named: "bookmark2"), for: .normal)
  214|      8|        }
  215|      8|    }
  216|       |    
  217|      8|    func setReviewVisibility(hasReviews: Bool) {
  218|      8|        if !hasReviews {
  219|      2|            self.reviewerTitle.text = ""
  220|      2|            self.reviewerRating.isHidden = true
  221|      2|            self.reviewText.text = "\n \t NO CRITIC REVIEWS FOUND"
  222|      2|            self.reviewText.font = UIFont(name: "Helvetica-Bold", size: 18)
  223|      2|            self.seeAllButton.isHidden = true
  224|      8|        }
  225|      8|    }
  226|       |    
  227|      1|    func displayErrorPopup(_ error: String, _ title: String) {
  228|      1|        let alert = UIAlertController(title: title, message: error, preferredStyle: .alert)
  229|      1|        alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
  230|      1|        self.present(alert, animated: true, completion: nil)
  231|      1|    }
  232|       |    
  233|      5|    func setNewModel(model: ExtraDetailsModel) {
  234|      5|        self.newModel = model
  235|      5|        doRemainingSetup()
  236|      5|    }
  237|       |    
  238|      6|    func setReviewInfo(review: ReviewModel) {
  239|      6|        self.reviewerTitle.text = review.reviewerName
  240|      6|        guard let convertedRating = Double(review.rating) else {
  241|      0|            return
  242|      6|        }
  243|      6|        self.reviewerRating.rating = convertedRating
  244|      6|        
  245|      6|        if review.reviewerImageLink != nil && review.reviewerImageLink != ""{
  246|      6|            if let imageLink = review.reviewerImageLink {
  247|      6|                self.reviewerImage.fetchImage(url: imageLink)
  248|      6|            }
  249|      6|        } else {
  250|      0|            self.reviewerImage.image = UIImage(named: "default")
  251|      6|        }
  252|      6|        
  253|      6|        self.reviewerImage.layer.borderWidth = 1
  254|      6|        self.reviewerImage.layer.masksToBounds = false
  255|      6|        self.reviewerImage.layer.borderColor = UIColor.black.cgColor
  256|      6|        self.reviewerImage.layer.cornerRadius = self.reviewerImage.frame.height / 2
  257|      6|        self.reviewerImage.clipsToBounds = true
  258|      6|        
  259|      6|        self.reviewText.text = review.review
  260|      6|    }
  261|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/BookDetails/ViewModel/DetailViewModel.swift:
    1|       |//
    2|       |//  DetailViewModel.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/04.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |class DetailViewModel: DetailViewModelling {
   12|       |    
   13|       |    weak var view: DetailViewControllable?
   14|       |    var repo: DetailRepositoring?
   15|       |    
   16|     12|    init(view: DetailViewControllable, repo: DetailRepositoring) {
   17|     12|        self.view = view
   18|     12|        self.repo = repo
   19|     12|        repo.setViewModel(vModel: self)
   20|     12|    }
   21|       |    
   22|       |    var bookId: String?
   23|       |    var reviewId: String?
   24|       |    var inList = false
   25|       |    
   26|     12|    func checkIfInList(_ reviewDetails: String) {
   27|     12|        repo?.getBookID(reviewDetails: reviewDetails)
   28|     12|    }
   29|       |    
   30|      7|    func compareList(_ books: [String], _ reviews: [String]) {
   31|      7|        var counter = 0
   32|    140|        for book in books {
   33|    140|            if self.bookId == book {
   34|      5|                self.inList = true
   35|      5|                self.reviewId = reviews[counter]
   36|    140|            }
   37|    140|            counter += 1
   38|    140|        }
   39|      7|        view?.setReadStatus(read: self.inList)
   40|      7|    }
   41|       |    
   42|     12|    func checkReviews(_ reviewDetails: String) {
   43|     12|        repo?.checkReviews(reviewDetails)
   44|     12|    }
   45|       |    
   46|      8|    func setReviewVisibility(hasReviews: Bool) {
   47|      8|        self.view?.setReviewVisibility(hasReviews: hasReviews)
   48|      8|    }
   49|       |    
   50|      7|    func setBookID (_ bookID: String?) {
   51|      7|        self.bookId = bookID
   52|      7|        repo?.checkIfInList()
   53|      7|    }
   54|       |    
   55|      1|    func getModel() -> DetailsModel {
   56|      1|        return DetailsModel(userId: (repo?.getUserId())!, bookId: self.bookId!, reviewId: self.reviewId)
   57|      1|    }
   58|       |    
   59|      5|    func setRemainingDetails(model: ExtraDetailsModel) {
   60|      5|        guard let number = Int(model.numReviews) else {
   61|      0|            errorAlert("error5")
   62|      0|            return
   63|      5|        }
   64|      5|        var newNumReviews = "\(number) ratings"
   65|      5|        if number > 999 {
   66|      5|            if number > 999999 {
   67|      5|                let roundedNum: Int = number / 1000000
   68|      5|                newNumReviews = "\(roundedNum)M ratings"
   69|      5|            } else {
   70|      0|                let roundedNum: Int = number / 1000
   71|      0|                newNumReviews = "\(roundedNum)K ratings"
   72|      5|            }
   73|      5|        }
   74|      5|        var similarBooksModel: [SimilarBook] = []
   75|     90|        for book in model.similarBooks {
   76|     90|            similarBooksModel.append(SimilarBook(bookId: book.bookId, imageLink: book.imageLink, title: book.title, author: "By: \(book.author)", bookLink: book.bookLink, pages: "Pages: \(book.pages)", isbn: book.isbn))
   77|     90|        }
   78|      5|        if let cleanedDetails = model.details.removingPercentEncoding?.replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression, range: nil) {
   79|      5|            let newModel = ExtraDetailsModel(avgRating: model.avgRating, numReviews: newNumReviews, yearPublished: model.yearPublished, publisher: model.publisher, details: cleanedDetails, similarBooks: similarBooksModel)
   80|      5|            view?.setNewModel(model: newModel)
   81|      5|        }        
   82|      5|    }
   83|       |    
   84|       |    //Add statements to unwrap bookId, searches if nil
   85|      1|    func modifyBookshelf() {
   86|      1|        guard let bookID = bookId else {
   87|      0|            errorAlert("error3")
   88|      0|            return
   89|      1|        }
   90|      1|        
   91|      1|        if !inList {
   92|      0|            let params: [String: Any] = [
   93|      0|                "name": "to-read",
   94|      0|                "book_id": bookID
   95|      0|            ]
   96|      0|            
   97|      0|            //Would cause problems if post failed
   98|      0|           self.inList = true
   99|      0|           repo?.postToShelf(params: params)
  100|      1|        } else {
  101|      1|            let params: [String: Any] = [
  102|      1|                "name": "to-read",
  103|      1|                "book_id": bookID,
  104|      1|                "a": "remove"
  105|      1|            ]
  106|      1|            
  107|      1|            //Would cause problems if post failed
  108|      1|            self.inList = false
  109|      1|            repo?.postToShelf(params: params)
  110|      1|        }
  111|      1|    }
  112|       |    
  113|      1|    func setBookmarkStatus() {
  114|      1|        view?.setReadStatus(read: inList)
  115|      1|    }
  116|       |    
  117|      6|    func setFirstReview(review: ReviewModel) {
  118|      6|        view?.setReviewInfo(review: review)
  119|      6|    }
  120|       |    
  121|      1|    func errorAlert(_ error: String) {
  122|      1|        if error == "error1" {
  123|      1|            view?.displayErrorPopup("Please check your internet connection and try again", "Network Error")
  124|      1|        } else if error == "error2" {
  125|      0|            view?.displayErrorPopup("Unable to add/remove item. Please try again later", "Unsuccessful Operation")
  126|      1|        } else if error == "error3" {
  127|      0|            view?.displayErrorPopup("Could not find matching book on server. Please ensure you have a valid book version", "Invalid Book")
  128|      1|        } else if error == "error4" {
  129|      0|            view?.displayErrorPopup("Unable to obtain login token. Please restart the app", "Authentication Error")
  130|      1|        } else if error == "error5" {
  131|      0|            view?.displayErrorPopup("Incorrect format of number of reviews received", "Data Retrieval Error")
  132|      1|        }
  133|      1|    }
  134|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Common/Extensions/ArrayExtension.swift:
    1|       |//
    2|       |//  ArrayExtension.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/26.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Array {
   12|       |
   13|      0|    subscript (randomPick ran: Int) -> [Element] {
   14|      0|        var indices = [Int](0..<count)
   15|      0|        var randoms = [Int]()
   16|      0|        for _ in 0..<ran {
   17|      0|            randoms.append(indices.remove(at: Int(arc4random_uniform(UInt32(indices.count)))))
   18|      0|        }
   19|      0|        return randoms.map { self[$0] }
   20|      0|    }
   21|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Common/Extensions/ImageExtension.swift:
    1|       |//
    2|       |//  ImageExtension.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/04.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |import AlamofireImage
   12|       |import Alamofire
   13|       |
   14|       |protocol ImageFetcher {
   15|       |    func fetchImage(url: String)
   16|       |    func fetchHighQualityImage(isbn: String)
   17|       |}
   18|       |
   19|       |extension UIImageView: ImageFetcher {
   20|      0|    func fetchHighQualityImage(isbn: String) {
   21|      0|        fetchHighQualityCoverFromOpenLibrary(isbn) { image, _ in
   22|      0|            self.image = image
   23|      0|        }
   24|      0|    }
   25|       |    
   26|      0|    func fetchHighQualityCoverFromOpenLibrary(_ isbn: String, completionHandler: @escaping (UIImage?, NetworkError) -> Void) {
   27|      0|        let imageUrl = "http://covers.openlibrary.org/b/isbn/\(isbn)-L.jpg"
   28|      0|        Alamofire.request(imageUrl, method: .get).responseImage { response in
   29|      0|            guard let image = response.result.value else {
   30|      0|                completionHandler(nil, .failure)
   31|      0|                return
   32|      0|            }
   33|      0|            completionHandler(image, .success)
   34|      0|        }
   35|      0|    }
   36|       |    
   37|    494|    func fetchImage(url: String) {
   38|    494|        fetchImageFromUrl(imageUrl: url) { image, _ in
   39|    493|            self.image = image
   40|    493|        }
   41|    494|    }
   42|       |
   43|    494|    func fetchImageFromUrl(imageUrl: String, completionHandler: @escaping (UIImage?, NetworkError) -> Void) {
   44|    494|        Alamofire.request(imageUrl, method: .get).responseImage { response in
   45|    493|            guard let image = response.result.value else {
   46|     21|                completionHandler(nil, .failure)
   47|     21|                return
   48|    472|            }
   49|    472|            completionHandler(image, .success)
   50|    472|        }
   51|    494|    }
   52|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/CriticReviews/Repository/CriticReviewsRepository.swift:
    1|       |//
    2|       |//  CriticReviewsRepository.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/05.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import SwiftyJSON
   11|       |import Alamofire
   12|       |
   13|       |class CriticReviewsRepository: CriticReviewsRepositoring {
   14|       |    
   15|       |    weak var vModel: CriticReviewsViewModelling?
   16|       |    
   17|      1|    func setViewModel(vModel: CriticReviewsViewModelling) {
   18|      1|        self.vModel = vModel
   19|      1|    }
   20|       |    
   21|       |    //Fetch reviews given some kind of search data, we use book title as it's the most accurate
   22|      1|    func fetchReviews(reviewData: String) {
   23|      1|        guard let iDreamKey = Bundle.main.object(forInfoDictionaryKey: "iDreamBooks_Key") else {
   24|      0|            return
   25|      1|        }
   26|      1|        let urlWithSpaces = "https://idreambooks.com/api/books/reviews.json?q=\(reviewData)&key=\(iDreamKey)"
   27|      1|        
   28|      1|        guard let url = urlWithSpaces.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
   29|      0|            return
   30|      1|        }
   31|      1|        
   32|      1|        Alamofire.request(url).responseJSON { response in
   33|      1|            guard let data = response.data else {
   34|      0|                self.vModel?.errorAlert("Network")
   35|      0|                return
   36|      1|            }
   37|      1|            
   38|      1|            let json = try? JSON(data: data)
   39|      1|            let results = json?["book"]["critic_reviews"].arrayValue
   40|      1|            guard let empty = results?.isEmpty, !empty else {
   41|      0|                //No results found for book
   42|      0|                self.vModel?.errorAlert("Empty")
   43|      0|                return
   44|      1|            }
   45|      1|            
   46|      1|            var reviews: [ReviewModel] = []
   47|      1|            guard let safeResults = results else {
   48|      0|                //Error case already handled
   49|      0|                return
   50|      1|            }
   51|      1|            
   52|      5|            for result in safeResults {
   53|      5|                let imageLink = result["source_logo"].stringValue
   54|      5|                let name = result["source"].stringValue
   55|      5|                let stars = result["star_rating"].stringValue
   56|      5|                let text = result["snippet"].stringValue
   57|      5|                reviews.append(ReviewModel(reviewerImageLink: imageLink, reviewerName: name, rating: stars, review: text))
   58|      5|            }
   59|      1|            self.vModel?.setResults(reviews)
   60|      1|        }
   61|      1|    }
   62|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/CriticReviews/View/CustomView/ReviewsTableViewCell.swift:
    1|       |//
    2|       |//  ReviewsTableViewCell.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/15.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class ReviewsTableViewCell: UITableViewCell {
   12|       |    
   13|       |    @IBOutlet weak var reviewText: UILabel!
   14|       |    @IBOutlet weak var reviewerImage: UIImageView!
   15|       |    @IBOutlet weak var reviewerName: UILabel!
   16|       |    @IBOutlet weak var rating: CosmosView!
   17|       |    
   18|      5|    override func awakeFromNib() {
   19|      5|        super.awakeFromNib()
   20|      5|        // Initialization code
   21|      5|    }
   22|       |    
   23|      5|    override func setSelected(_ selected: Bool, animated: Bool) {
   24|      5|        super.setSelected(selected, animated: animated)
   25|      5|        // Configure the view for the selected state
   26|      5|    }
   27|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/CriticReviews/View/ViewController/ReviewsTableViewController.swift:
    1|       |//
    2|       |//  ReviewsTableViewController.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/15.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class ReviewsTableViewController: UITableViewController {
   12|       |    
   13|       |    var reviewDetails: String?
   14|       |    
   15|      1|    lazy var vModel: CriticReviewsViewModelling = { return CriticReviewsViewModel(view: self, repo: CriticReviewsRepository()) }()
   16|       |    
   17|      1|    override func viewDidLoad() {
   18|      1|        super.viewDidLoad()
   19|      1|        tableView.estimatedRowHeight = 150
   20|      1|        tableView.rowHeight = UITableView.automaticDimension
   21|      1|        
   22|      1|        if let reviewData = reviewDetails {
   23|      1|            vModel.fetchResults(for: reviewData)
   24|      1|        }
   25|      1|        let refreshControl = UIRefreshControl()
   26|      1|        refreshControl.addTarget(self, action: #selector(doSomething), for: .valueChanged)
   27|      1|        tableView.refreshControl = refreshControl
   28|      1|    }
   29|       |    
   30|      0|    @objc func doSomething(refreshControl: UIRefreshControl) {
   31|      0|        if let reviewData = reviewDetails {
   32|      0|            vModel.fetchResults(for: reviewData)
   33|      0|        }
   34|      0|        
   35|      0|        // somewhere in your code you might need to call:
   36|      0|        refreshControl.endRefreshing()
   37|      0|    }
   38|       |    
   39|      5|    override func numberOfSections(in tableView: UITableView) -> Int {
   40|      5|        // #warning Incomplete implementation, return the number of sections
   41|      5|        return 1
   42|      5|    }
   43|       |    
   44|     10|    override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
   45|     10|        return UITableView.automaticDimension
   46|     10|    }
   47|       |    
   48|      3|    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   49|      3|        // #warning Incomplete implementation, return the number of rows
   50|      3|        return vModel.countResults()
   51|      3|    }
   52|       |
   53|      5|    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   54|      5|        let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath) as! ReviewsTableViewCell
   55|      5|        let italicFont = UIFont.italicSystemFont(ofSize: 16)
   56|      5|        let cellInfo =  vModel.getReview(index: indexPath.row)
   57|      5|        cell.reviewText.text = cellInfo.review
   58|      5|        if let convertedRating = Double(cellInfo.rating) {
   59|      5|            cell.rating.rating = convertedRating
   60|      5|        }
   61|      5|        cell.reviewerName.text = cellInfo.reviewerName
   62|      5|        if cellInfo.reviewerImageLink != "" {
   63|      1|            if let imageLink = cellInfo.reviewerImageLink {
   64|      1|                cell.reviewerImage.fetchImage(url: imageLink)
   65|      1|            }
   66|      5|        } else {
   67|      4|            cell.reviewerImage.image = UIImage(named: "default")
   68|      5|        }
   69|      5|        cell.reviewText.font = italicFont
   70|      5|        cell.reviewerImage.layer.borderWidth = 1
   71|      5|        cell.reviewerImage.layer.masksToBounds = false
   72|      5|        cell.reviewerImage.layer.borderColor = UIColor.black.cgColor
   73|      5|        cell.reviewerImage.layer.cornerRadius = cell.reviewerImage.frame.height / 2
   74|      5|        cell.reviewerImage.clipsToBounds = true
   75|      5|        return cell
   76|      5|    }
   77|       |}
   78|       |
   79|       |extension ReviewsTableViewController: ReviewsControllable {
   80|       |    
   81|      1|    func reloadTable() {
   82|      1|        tableView.reloadData()
   83|      1|    }
   84|       |
   85|      0|    func displayErrorPopup(_ error: String, _ title: String) {
   86|      0|        let alert = UIAlertController(title: title, message: error, preferredStyle: .alert)
   87|      0|        alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
   88|      0|        self.present(alert, animated: true, completion: nil)
   89|      0|    }
   90|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/CriticReviews/ViewModel/CriticReviewsViewModel.swift:
    1|       |//
    2|       |//  CriticReviewsViewModel.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/05.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |class CriticReviewsViewModel: CriticReviewsViewModelling {
   12|       |    
   13|       |    private var reviewResults = [ReviewModel]() {
   14|      1|        didSet {
   15|      1|            view?.reloadTable()
   16|      1|        }
   17|       |    }
   18|       |    
   19|       |    private var repo: CriticReviewsRepositoring?
   20|       |    weak var view: ReviewsControllable?
   21|       |    
   22|      1|    init(view: ReviewsControllable, repo: CriticReviewsRepositoring) {
   23|      1|        self.view = view
   24|      1|        self.repo = repo
   25|      1|        repo.setViewModel(vModel: self)
   26|      1|    }
   27|       |    
   28|      3|    func countResults() -> Int {
   29|      3|        return reviewResults.count
   30|      3|    }
   31|       |    
   32|      5|    func getReview(index: Int) -> ReviewModel {
   33|      5|        return reviewResults[index]
   34|      5|    }
   35|       |    
   36|      1|    func fetchResults(for text: String) {
   37|      1|        repo?.fetchReviews(reviewData: text)
   38|      1|    }
   39|       |    
   40|      1|    func setResults(_ results: [ReviewModel]) {
   41|      1|        self.reviewResults = results
   42|      1|    }
   43|       |    
   44|      0|    func errorAlert(_ error: String) {
   45|      0|        if error == "Network" {
   46|      0|            view?.displayErrorPopup("Please check your internet connection and refresh", "Network Error")
   47|      0|        } else {
   48|      0|            view?.displayErrorPopup("Bad version of book selected. Look for an alternative version", "No Results Found")
   49|      0|        }
   50|      0|    }
   51|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/MyReview/Repository/MyReviewRepository.swift:
    1|       |//
    2|       |//  MyReviewRepository.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/05.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import OAuthSwift
   11|       |import SWXMLHash
   12|       |
   13|       |class MyReviewRepository: MyReviewRepositoring {
   14|       |    
   15|       |    var oauthswift: OAuthSwift?
   16|       |    weak var vModel: MyReviewViewModelling?
   17|       |    
   18|      1|    func setViewModel(vModel: MyReviewViewModelling) {
   19|      1|        self.vModel = vModel
   20|      1|    }
   21|       |    
   22|       |    //**needs to do something on failure
   23|      0|    func postReview(params: [String: Any]) {
   24|      0|        storedDetailsCheck()
   25|      0|        let oauthSwift: OAuth1Swift = oauthswift as! OAuth1Swift
   26|      0|        _ = oauthSwift.client.post("https://www.goodreads.com/review.xml", parameters: params,
   27|      0|                                   success: { _ in
   28|      0|                                    self.vModel?.closePage() },
   29|      0|                                   failure: {_ in
   30|      0|                                    self.vModel?.errorBuilder("error2")})
   31|      0|    }
   32|       |    
   33|      0|    func editReview(params: [String: Any], _ reviewId: String) {
   34|      0|        storedDetailsCheck()
   35|      0|        let oauthSwift: OAuth1Swift = oauthswift as! OAuth1Swift
   36|      0|        _ = oauthSwift.client.post("https://www.goodreads.com/review/\(reviewId).xml", parameters: params,
   37|      0|                                   success: { _ in
   38|      0|                                    self.vModel?.closePage() },
   39|      0|                                   failure: {_ in
   40|      0|                                    self.vModel?.errorBuilder("error2") })
   41|      0|    }
   42|       |    
   43|      1|    func getReview(reviewId: String) {
   44|      1|         let uiTesting = ProcessInfo.processInfo.arguments.contains("Testing")
   45|      1|        
   46|      1|        if !uiTesting {
   47|      0|            storedDetailsCheck()
   48|      0|            let oauthSwift: OAuth1Swift = oauthswift as! OAuth1Swift
   49|      0|            guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
   50|      0|                return
   51|      0|            }
   52|      0|            _ = oauthSwift.client.get(
   53|      0|                "https://www.goodreads.com/review/show.xml?id=\(reviewId)&key=\(goodreadsKey)",
   54|      0|                success: { response in
   55|      0|                    
   56|      0|                    /** parse the returned xml to read user id **/
   57|      0|                    guard let dataString = response.string else {
   58|      0|                        self.vModel?.errorBuilder("error3")
   59|      0|                        return
   60|      0|                    }
   61|      0|                    let xml = SWXMLHash.parse(dataString)
   62|      0|                    let review =  (xml["GoodreadsResponse"]["review"]["body"].element?.text)
   63|      0|                    let rating = (xml["GoodreadsResponse"]["review"]["rating"].element?.text)
   64|      0|                    
   65|      0|                    guard let safeReview = review else {
   66|      0|                        self.vModel?.errorBuilder("error3")
   67|      0|                        return
   68|      0|                    }
   69|      0|                    guard let safeRating = rating else {
   70|      0|                        self.vModel?.errorBuilder("error3")
   71|      0|                        return
   72|      0|                    }
   73|      0|                    self.vModel?.setReview(safeReview, safeRating)
   74|      0|                    
   75|      0|            }, failure: { _ in
   76|      0|                self.vModel?.errorBuilder("error1")
   77|      0|            }
   78|      0|            )
   79|      1|        }
   80|      1|    }
   81|       |    
   82|      0|    func storedDetailsCheck() {
   83|      0|        let preferences = UserDefaults.standard
   84|      0|        let currentOauthKey = "oauth"
   85|      0|
   86|      0|        if preferences.object(forKey: currentOauthKey) != nil {
   87|      0|            let decoded  = preferences.object(forKey: currentOauthKey) as! Data
   88|      0|            guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
   89|      0|                return
   90|      0|            }
   91|      0|            guard let goodreadsSecret = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Secret") as? String else {
   92|      0|                return
   93|      0|            }
   94|      0|            if let credential = NSKeyedUnarchiver.unarchiveObject(with: decoded) as? OAuthSwiftCredential {
   95|      0|                let oauthS = OAuth1Swift(consumerKey: goodreadsKey,
   96|      0|                                         consumerSecret: goodreadsSecret)
   97|      0|                oauthS.client.credential.oauthToken = credential.oauthToken
   98|      0|                oauthS.client.credential.oauthTokenSecret = credential.oauthTokenSecret
   99|      0|                oauthswift = oauthS
  100|      0|            }
  101|      0|        }
  102|      0|    }
  103|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/MyReview/View/ViewController/MyReviewViewController.swift:
    1|       |//
    2|       |//  MyReviewViewController.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/25.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import OAuthSwift
   11|       |
   12|       |class MyReviewViewController: UIViewController {
   13|       |
   14|       |    @IBOutlet weak var textReview: UITextView!
   15|       |    @IBOutlet weak var cosmosView: CosmosView!
   16|       |    @IBOutlet weak var buttonPost: UIButton!
   17|       |    
   18|      1|    lazy var vModel: MyReviewViewModelling = { return MyReviewViewModel(view: self, repo: MyReviewRepository()) }()
   19|       |    
   20|       |    var oauthswift: OAuthSwift?
   21|       |    var bookId: String?
   22|       |    var reviewId: String?
   23|       |    
   24|       |    var detailModel: DetailsModel?
   25|       |    
   26|      1|    override func viewDidLoad() {
   27|      1|        super.viewDidLoad()
   28|      1|        
   29|      1|        if let revId = detailModel?.reviewId {
   30|      1|            vModel.getReview(reviewId: revId)
   31|      1|        }
   32|      1|    }
   33|       |
   34|      0|    @IBAction func postReview(_ sender: UIBarButtonItem) {
   35|      0|        let review = textReview.text.trimmingCharacters(in: .whitespacesAndNewlines)
   36|      0|        let rating = cosmosView.rating
   37|      0|        guard let model: DetailsModel = detailModel else {
   38|      0|            return
   39|      0|        }
   40|      0|        vModel.postReview(review, rating, model)
   41|      0|    }
   42|       |    
   43|       |}
   44|       |
   45|       |extension MyReviewViewController: MyReviewViewControllable {
   46|      0|    func returnToPrevScreen() {
   47|      0|        self.navigationController?.popViewController(animated: true)
   48|      0|    }
   49|       |
   50|      0|    func setReviewInfo(_ review: String, _ rating: Double) {
   51|      0|        //Had to write code badly like this or it wasnt working weirdly
   52|      0|        if review != "" && review != "\n"{
   53|      0|           self.textReview.text = review
   54|      0|        }
   55|      0|        self.cosmosView.rating = rating
   56|      0|    }
   57|       |    
   58|      0|    func displayErrorPopup(_ error: String, _ title: String) {
   59|      0|        let alert = UIAlertController(title: title, message: error, preferredStyle: .alert)
   60|      0|        alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
   61|      0|        self.present(alert, animated: true, completion: nil)
   62|      0|    }
   63|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/MyReview/View/ViewElements/CosmosDistrib.swift:
    1|       |//
    2|       |//  CosmosDistrib.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/25.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |//
   10|       |// Star rating control written in Swift for iOS and tvOS.
   11|       |//
   12|       |// https://github.com/evgenyneu/Cosmos
   13|       |//
   14|       |// This file was automatically generated by combining multiple Swift source files.
   15|       |//
   16|       |import Foundation
   17|       |
   18|       |/**
   19|       | Defines how the star is filled when the rating is not an integer number. For example, if rating is 4.6 and the fill more is Half, the star will appear to be half filled.
   20|       | */
   21|       |public enum StarFillMode: Int {
   22|       |    /// Show only fully filled stars. For example, fourth star will be empty for 3.2.
   23|       |    case full = 0
   24|       |    
   25|       |    /// Show fully filled and half-filled stars. For example, fourth star will be half filled for 3.6.
   26|       |    case half = 1
   27|       |    
   28|       |    /// Fill star according to decimal rating. For example, fourth star will be 20% filled for 3.2.
   29|       |    case precise = 2
   30|       |}
   31|       |// ----------------------------
   32|       |//
   33|       |// StarLayer.swift
   34|       |//
   35|       |// ----------------------------
   36|       |import UIKit
   37|       |
   38|       |/**
   39|       | Creates a layer with a single star in it.
   40|       | */
   41|       |struct StarLayer {
   42|       |    /**
   43|       |     
   44|       |     Creates a square layer with given size and draws the star shape in it.
   45|       |     
   46|       |     - parameter starPoints: Array of points for drawing a closed shape. The size of enclosing rectangle is 100 by 100.
   47|       |     
   48|       |     - parameter size: The width and height of the layer. The star shape is scaled to fill the size of the layer.
   49|       |     
   50|       |     - parameter lineWidth: The width of the star stroke.
   51|       |     
   52|       |     - parameter fillColor: Star shape fill color. Fill color is invisible if it is a clear color.
   53|       |     
   54|       |     - parameter strokeColor: Star shape stroke color. Stroke is invisible if it is a clear color.
   55|       |     
   56|       |     - returns: New layer containing the star shape.
   57|       |     
   58|       |     */
   59|       |    static func create(_ starPoints: [CGPoint], size: Double,
   60|  1.38k|                       lineWidth: Double, fillColor: UIColor, strokeColor: UIColor) -> CALayer {
   61|  1.38k|        
   62|  1.38k|        let containerLayer = createContainerLayer(size)
   63|  1.38k|        let path = createStarPath(starPoints, size: size, lineWidth: lineWidth)
   64|  1.38k|        
   65|  1.38k|        let shapeLayer = createShapeLayer(path.cgPath, lineWidth: lineWidth,
   66|  1.38k|                                          fillColor: fillColor, strokeColor: strokeColor, size: size)
   67|  1.38k|        
   68|  1.38k|        containerLayer.addSublayer(shapeLayer)
   69|  1.38k|        
   70|  1.38k|        return containerLayer
   71|  1.38k|    }
   72|       |    
   73|       |    /**
   74|       |     Creates the star layer from an image
   75|       |     - parameter image: a star image to be shown.
   76|       |     - parameter size: The width and height of the layer. The image is scaled to fit the layer.
   77|       |     */
   78|      0|    static func create(image: UIImage, size: Double) -> CALayer {
   79|      0|        let containerLayer = createContainerLayer(size)
   80|      0|        let imageLayer = createContainerLayer(size)
   81|      0|        
   82|      0|        containerLayer.addSublayer(imageLayer)
   83|      0|        imageLayer.contents = image.cgImage
   84|      0|        imageLayer.contentsGravity = CALayerContentsGravity.resizeAspect
   85|      0|        
   86|      0|        return containerLayer
   87|      0|    }
   88|       |    
   89|       |    /**
   90|       |     
   91|       |     Creates the star shape layer.
   92|       |     
   93|       |     - parameter path: The star shape path.
   94|       |     
   95|       |     - parameter lineWidth: The width of the star stroke.
   96|       |     
   97|       |     - parameter fillColor: Star shape fill color. Fill color is invisible if it is a clear color.
   98|       |     
   99|       |     - parameter strokeColor: Star shape stroke color. Stroke is invisible if it is a clear color.
  100|       |     
  101|       |     - returns: New shape layer.
  102|       |     
  103|       |     */
  104|       |    static func createShapeLayer(_ path: CGPath, lineWidth: Double, fillColor: UIColor,
  105|  1.38k|                                 strokeColor: UIColor, size: Double) -> CALayer {
  106|  1.38k|        
  107|  1.38k|        let layer = CAShapeLayer()
  108|  1.38k|        layer.anchorPoint = CGPoint()
  109|  1.38k|        layer.contentsScale = UIScreen.main.scale
  110|  1.38k|        layer.strokeColor = strokeColor.cgColor
  111|  1.38k|        layer.fillColor = fillColor.cgColor
  112|  1.38k|        layer.lineWidth = CGFloat(lineWidth)
  113|  1.38k|        layer.bounds.size = CGSize(width: size, height: size)
  114|  1.38k|        layer.masksToBounds = true
  115|  1.38k|        layer.path = path
  116|  1.38k|        layer.isOpaque = true
  117|  1.38k|        return layer
  118|  1.38k|    }
  119|       |    
  120|       |    /**
  121|       |     
  122|       |     Creates a layer that will contain the shape layer.
  123|       |     
  124|       |     - returns: New container layer.
  125|       |     
  126|       |     */
  127|  1.38k|    static func createContainerLayer(_ size: Double) -> CALayer {
  128|  1.38k|        let layer = CALayer()
  129|  1.38k|        layer.contentsScale = UIScreen.main.scale
  130|  1.38k|        layer.anchorPoint = CGPoint()
  131|  1.38k|        layer.masksToBounds = true
  132|  1.38k|        layer.bounds.size = CGSize(width: size, height: size)
  133|  1.38k|        layer.isOpaque = true
  134|  1.38k|        return layer
  135|  1.38k|    }
  136|       |    
  137|       |    /**
  138|       |     
  139|       |     Creates a path for the given star points and size. The star points specify a shape of size 100 by 100. The star shape will be scaled if the size parameter is not 100. For exampe, if size parameter is 200 the shape will be scaled by 2.
  140|       |     
  141|       |     - parameter starPoints: Array of points for drawing a closed shape. The size of enclosing rectangle is 100 by 100.
  142|       |     
  143|       |     - parameter size: Specifies the size of the shape to return.
  144|       |     
  145|       |     - returns: New shape path.
  146|       |     
  147|       |     */
  148|       |    static func createStarPath(_ starPoints: [CGPoint], size: Double,
  149|  1.38k|                               lineWidth: Double) -> UIBezierPath {
  150|  1.38k|        
  151|  1.38k|        let lineWidthLocal = lineWidth + ceil(lineWidth * 0.3)
  152|  1.38k|        let sizeWithoutLineWidth = size - lineWidthLocal * 2
  153|  1.38k|        
  154|  1.38k|        let points = scaleStar(starPoints, factor: sizeWithoutLineWidth / 100,
  155|  1.38k|                               lineWidth: lineWidthLocal)
  156|  1.38k|        
  157|  1.38k|        let path = UIBezierPath()
  158|  1.38k|        path.move(to: points[0])
  159|  1.38k|        let remainingPoints = Array(points[1..<points.count])
  160|  1.38k|        
  161|  12.4k|        for point in remainingPoints {
  162|  12.4k|            path.addLine(to: point)
  163|  12.4k|        }
  164|  1.38k|        
  165|  1.38k|        path.close()
  166|  1.38k|        return path
  167|  1.38k|    }
  168|       |    
  169|       |    /**
  170|       |     
  171|       |     Scale the star points by the given factor.
  172|       |     
  173|       |     - parameter starPoints: Array of points for drawing a closed shape. The size of enclosing rectangle is 100 by 100.
  174|       |     
  175|       |     - parameter factor: The factor by which the star points are scaled. For example, if it is 0.5 the output points will define the shape twice as small as the original.
  176|       |     
  177|       |     - returns: The scaled shape.
  178|       |     
  179|       |     */
  180|  1.38k|    static func scaleStar(_ starPoints: [CGPoint], factor: Double, lineWidth: Double) -> [CGPoint] {
  181|  13.8k|        return starPoints.map { point in
  182|  13.8k|            return CGPoint(
  183|  13.8k|                x: point.x * CGFloat(factor) + CGFloat(lineWidth),
  184|  13.8k|                y: point.y * CGFloat(factor) + CGFloat(lineWidth)
  185|  13.8k|            )
  186|  13.8k|        }
  187|  1.38k|    }
  188|       |}
  189|       |
  190|       |
  191|       |// ----------------------------
  192|       |//
  193|       |// CosmosAccessibility.swift
  194|       |//
  195|       |// ----------------------------
  196|       |import UIKit
  197|       |
  198|       |/**
  199|       | Functions for making cosmos view accessible.
  200|       | */
  201|       |struct CosmosAccessibility {
  202|       |    /**
  203|       |     
  204|       |     Makes the view accesible by settings its label and using rating as value.
  205|       |     
  206|       |     */
  207|       |    
  208|    277|    static func update(_ view: UIView, rating: Double, text: String?, settings: CosmosSettings) {
  209|    277|        view.isAccessibilityElement = true
  210|    277|        
  211|    277|        view.accessibilityTraits = settings.updateOnTouch ?
  212|    277|            UIAccessibilityTraits.adjustable :UIAccessibilityTraits.none
  213|    277|        
  214|    277|        var accessibilityLabel = CosmosLocalizedRating.ratingTranslation
  215|    277|        
  216|    277|        if let text = text, text != "" {
  217|      0|            accessibilityLabel += " \(text)"
  218|    277|        }
  219|    277|        
  220|    277|        view.accessibilityLabel = accessibilityLabel
  221|    277|        
  222|    277|        view.accessibilityValue = accessibilityValue(view, rating: rating, settings: settings)
  223|    277|    }
  224|       |    
  225|       |    /**
  226|       |     
  227|       |     Returns the rating that is used as accessibility value.
  228|       |     The accessibility value depends on the star fill mode.
  229|       |     For example, if rating is 4.6 and fill mode is .half the value will be 4.5. And if the fill mode
  230|       |     if .full the value will be 5.
  231|       |     
  232|       |     */
  233|    277|    static func accessibilityValue(_ view: UIView, rating: Double, settings: CosmosSettings) -> String {
  234|    277|        let accessibilityRating = CosmosRating.displayedRatingFromPreciseRating(rating,
  235|    277|                                                                                fillMode: settings.fillMode, totalStars: settings.totalStars)
  236|    277|        
  237|    277|        // Omit decimals if the value is an integer
  238|    277|        let isInteger = (accessibilityRating * 10).truncatingRemainder(dividingBy: 10) == 0
  239|    277|        
  240|    277|        if isInteger {
  241|    277|            return "\(Int(accessibilityRating))"
  242|    277|        } else {
  243|      0|            // Only show a single decimal place
  244|      0|            let roundedToFirstDecimalPlace = Double( round(10 * accessibilityRating) / 10 )
  245|      0|            return "\(roundedToFirstDecimalPlace)"
  246|      0|        }
  247|      0|    }
  248|       |    
  249|       |    /**
  250|       |     Returns the amount of increment for the rating. When .half and .precise fill modes are used the
  251|       |     rating is incremented by 0.5.
  252|       |     
  253|       |     */
  254|      0|    static func accessibilityIncrement(_ rating: Double, settings: CosmosSettings) -> Double {
  255|      0|        var increment: Double = 0
  256|      0|        
  257|      0|        switch settings.fillMode {
  258|      0|        case .full:
  259|      0|            increment = ceil(rating) - rating
  260|      0|            if increment == 0 { increment = 1 }
  261|      0|            
  262|      0|        case .half, .precise:
  263|      0|            increment = (ceil(rating * 2) - rating * 2) / 2
  264|      0|            if increment == 0 { increment = 0.5 }
  265|      0|        }
  266|      0|        
  267|      0|        if rating >= Double(settings.totalStars) { increment = 0 }
  268|      0|        
  269|      0|        let roundedToFirstDecimalPlace = Double( round(10 * increment) / 10 )
  270|      0|        return roundedToFirstDecimalPlace
  271|      0|    }
  272|       |    
  273|      0|    static func accessibilityDecrement(_ rating: Double, settings: CosmosSettings) -> Double {
  274|      0|        var increment: Double = 0
  275|      0|        
  276|      0|        switch settings.fillMode {
  277|      0|        case .full:
  278|      0|            increment = rating - floor(rating)
  279|      0|            if increment == 0 { increment = 1 }
  280|      0|            
  281|      0|        case .half, .precise:
  282|      0|            increment = (rating * 2 - floor(rating * 2)) / 2
  283|      0|            if increment == 0 { increment = 0.5 }
  284|      0|        }
  285|      0|        
  286|      0|        if rating <= settings.minTouchRating { increment = 0 }
  287|      0|        
  288|      0|        let roundedToFirstDecimalPlace = Double( round(10 * increment) / 10 )
  289|      0|        return roundedToFirstDecimalPlace
  290|      0|    }
  291|       |}
  292|       |
  293|       |
  294|       |// ----------------------------
  295|       |//
  296|       |// CosmosText.swift
  297|       |//
  298|       |// ----------------------------
  299|       |
  300|       |
  301|       |import UIKit
  302|       |
  303|       |/**
  304|       | Positions the text layer to the right of the stars.
  305|       | */
  306|       |class CosmosText {
  307|       |    /**
  308|       |     
  309|       |     Positions the text layer to the right from the stars. Text is aligned to the center of the star superview vertically.
  310|       |     
  311|       |     - parameter layer: The text layer to be positioned.
  312|       |     - parameter starsSize: The size of the star superview.
  313|       |     - parameter textMargin: The distance between the stars and the text.
  314|       |     
  315|       |     */
  316|      0|    class func position(_ layer: CALayer, starsSize: CGSize, textMargin: Double) {
  317|      0|        layer.position.x = starsSize.width + CGFloat(textMargin)
  318|      0|        let yOffset = (starsSize.height - layer.bounds.height) / 2
  319|      0|        layer.position.y = yOffset
  320|      0|    }
  321|       |}
  322|       |
  323|       |
  324|       |// ----------------------------
  325|       |//
  326|       |// CosmosDefaultSettings.swift
  327|       |//
  328|       |// ----------------------------
  329|       |import UIKit
  330|       |
  331|       |/**
  332|       | Defaults setting values.
  333|       | */
  334|       |struct CosmosDefaultSettings {
  335|      0|    init() {}
  336|       |    
  337|       |    static let defaultColor = UIColor(red: 1, green: 149/255, blue: 0, alpha: 1)
  338|       |    
  339|       |    
  340|       |    // MARK: - Star settings
  341|       |    // -----------------------------
  342|       |    /// Border color of an empty star.
  343|       |    static let emptyBorderColor = defaultColor
  344|       |    
  345|       |    /// Width of the border for the empty star.
  346|       |    static let emptyBorderWidth: Double = 1 / Double(UIScreen.main.scale)
  347|       |    
  348|       |    /// Border color of a filled star.
  349|       |    static let filledBorderColor = defaultColor
  350|       |    
  351|       |    /// Width of the border for a filled star.
  352|       |    static let filledBorderWidth: Double = 1 / Double(UIScreen.main.scale)
  353|       |    
  354|       |    /// Background color of an empty star.
  355|       |    static let emptyColor = UIColor.clear
  356|       |    
  357|       |    /// Background color of a filled star.
  358|       |    static let filledColor = defaultColor
  359|       |    
  360|       |    /**
  361|       |     Defines how the star is filled when the rating value is not an integer value. It can either show full stars, half stars or stars partially filled according to the rating value.
  362|       |     */
  363|       |    static let fillMode = StarFillMode.full
  364|       |    
  365|       |    /// Rating value that is shown in the storyboard by default.
  366|       |    static let rating: Double = 2.718281828
  367|       |    
  368|       |    /// Distance between stars.
  369|       |    static let starMargin: Double = 5
  370|       |    
  371|       |    /**
  372|       |     
  373|       |     Array of points for drawing the star with size of 100 by 100 pixels. Supply your points if you need to draw a different shape.
  374|       |     
  375|       |     */
  376|       |    static let starPoints: [CGPoint] = [
  377|       |        CGPoint(x: 49.5,  y: 0.0),
  378|       |        CGPoint(x: 60.5,  y: 35.0),
  379|       |        CGPoint(x: 99.0, y: 35.0),
  380|       |        CGPoint(x: 67.5,  y: 58.0),
  381|       |        CGPoint(x: 78.5,  y: 92.0),
  382|       |        CGPoint(x: 49.5,    y: 71.0),
  383|       |        CGPoint(x: 20.5,  y: 92.0),
  384|       |        CGPoint(x: 31.5,  y: 58.0),
  385|       |        CGPoint(x: 0.0,   y: 35.0),
  386|       |        CGPoint(x: 38.5,  y: 35.0)
  387|       |    ]
  388|       |    
  389|       |    /// Size of a single star.
  390|       |    static var starSize: Double = 20
  391|       |    
  392|       |    /// The total number of stars to be shown.
  393|       |    static let totalStars = 5
  394|       |    
  395|       |    
  396|       |    // MARK: - Text settings
  397|       |    // -----------------------------
  398|       |    
  399|       |    
  400|       |    /// Color of the text.
  401|       |    static let textColor = UIColor(red: 127/255, green: 127/255, blue: 127/255, alpha: 1)
  402|       |    
  403|       |    /// Font for the text.
  404|       |    static let textFont = UIFont.preferredFont(forTextStyle: UIFont.TextStyle.footnote)
  405|       |    
  406|       |    /// Distance between the text and the stars.
  407|       |    static let textMargin: Double = 5
  408|       |    
  409|       |    /// Calculates the size of the default text font. It is used for making the text size configurable from the storyboard.
  410|       |    static var textSize: Double {
  411|     30|        get {
  412|     30|            return Double(textFont.pointSize)
  413|     30|        }
  414|       |    }
  415|       |    
  416|       |    
  417|       |    // MARK: - Touch settings
  418|       |    // -----------------------------
  419|       |    /// The lowest rating that user can set by touching the stars.
  420|       |    static let minTouchRating: Double = 1
  421|       |    
  422|       |    /// Set to `false` if you don't want to pass touches to superview (can be useful in a table view).
  423|       |    static let passTouchesToSuperview = true
  424|       |    
  425|       |    /// When `true` the star fill level is updated when user touches the cosmos view. When `false` the Cosmos view only shows the rating and does not act as the input control.
  426|       |    static let updateOnTouch = true
  427|       |}
  428|       |
  429|       |
  430|       |// ----------------------------
  431|       |//
  432|       |// CosmosSize.swift
  433|       |//
  434|       |// ----------------------------
  435|       |import UIKit
  436|       |
  437|       |/**
  438|       | Helper class for calculating size for the cosmos view.
  439|       | */
  440|       |class CosmosSize {
  441|       |    /**
  442|       |     
  443|       |     Calculates the size of the cosmos view. It goes through all the star and text layers and makes size the view size is large enough to show all of them.
  444|       |     
  445|       |     */
  446|    277|    class func calculateSizeToFitLayers(_ layers: [CALayer]) -> CGSize {
  447|    277|        var size = CGSize()
  448|    277|        
  449|  1.38k|        for layer in layers {
  450|  1.38k|            if layer.frame.maxX > size.width {
  451|  1.38k|                size.width = layer.frame.maxX
  452|  1.38k|            }
  453|  1.38k|            
  454|  1.38k|            if layer.frame.maxY > size.height {
  455|    277|                size.height = layer.frame.maxY
  456|  1.38k|            }
  457|  1.38k|        }
  458|    277|        
  459|    277|        return size
  460|    277|    }
  461|       |}
  462|       |
  463|       |
  464|       |// ----------------------------
  465|       |//
  466|       |// CosmosLayers.swift
  467|       |//
  468|       |// ----------------------------
  469|       |import UIKit
  470|       |
  471|       |
  472|       |/**
  473|       | Colection of helper functions for creating star layers.
  474|       | */
  475|       |class CosmosLayers {
  476|       |    /**
  477|       |     
  478|       |     Creates the layers for the stars.
  479|       |     
  480|       |     - parameter rating: The decimal number representing the rating. Usually a number between 1 and 5
  481|       |     - parameter settings: Star view settings.
  482|       |     - returns: Array of star layers.
  483|       |     
  484|       |     */
  485|    277|    class func createStarLayers(_ rating: Double, settings: CosmosSettings, isRightToLeft: Bool) -> [CALayer] {
  486|    277|        
  487|    277|        var ratingRemander = CosmosRating.numberOfFilledStars(rating,
  488|    277|                                                              totalNumberOfStars: settings.totalStars)
  489|    277|        
  490|    277|        var starLayers = [CALayer]()
  491|    277|        
  492|  1.38k|        for _ in (0..<settings.totalStars) {
  493|  1.38k|            
  494|  1.38k|            let fillLevel = CosmosRating.starFillLevel(ratingRemainder: ratingRemander,
  495|  1.38k|                                                       fillMode: settings.fillMode)
  496|  1.38k|            
  497|  1.38k|            let starLayer = createCompositeStarLayer(fillLevel, settings: settings, isRightToLeft: isRightToLeft)
  498|  1.38k|            starLayers.append(starLayer)
  499|  1.38k|            ratingRemander -= 1
  500|  1.38k|        }
  501|    277|        
  502|    277|        if isRightToLeft { starLayers.reverse() }
  503|    277|        positionStarLayers(starLayers, starMargin: settings.starMargin)
  504|    277|        return starLayers
  505|    277|    }
  506|       |    
  507|       |    
  508|       |    /**
  509|       |     
  510|       |     Creates an layer that shows a star that can look empty, fully filled or partially filled.
  511|       |     Partially filled layer contains two sublayers.
  512|       |     
  513|       |     - parameter starFillLevel: Decimal number between 0 and 1 describing the star fill level.
  514|       |     - parameter settings: Star view settings.
  515|       |     - returns: Layer that shows the star. The layer is displayed in the cosmos view.
  516|       |     
  517|       |     */
  518|       |    class func createCompositeStarLayer(_ starFillLevel: Double,
  519|  1.38k|                                        settings: CosmosSettings, isRightToLeft: Bool) -> CALayer {
  520|  1.38k|        
  521|  1.38k|        if starFillLevel >= 1 {
  522|  1.01k|            return createStarLayer(true, settings: settings)
  523|  1.01k|        }
  524|    371|        
  525|    371|        if starFillLevel == 0 {
  526|    371|            return createStarLayer(false, settings: settings)
  527|    371|        }
  528|      0|        
  529|      0|        return createPartialStar(starFillLevel, settings: settings, isRightToLeft: isRightToLeft)
  530|    371|    }
  531|       |    
  532|       |    /**
  533|       |     
  534|       |     Creates a partially filled star layer with two sub-layers:
  535|       |     
  536|       |     1. The layer for the filled star on top. The fill level parameter determines the width of this layer.
  537|       |     2. The layer for the empty star below.
  538|       |     
  539|       |     - parameter starFillLevel: Decimal number between 0 and 1 describing the star fill level.
  540|       |     - parameter settings: Star view settings.
  541|       |     - returns: Layer that contains the partially filled star.
  542|       |     
  543|       |     */
  544|      0|    class func createPartialStar(_ starFillLevel: Double, settings: CosmosSettings, isRightToLeft: Bool) -> CALayer {
  545|      0|        let filledStar = createStarLayer(true, settings: settings)
  546|      0|        let emptyStar = createStarLayer(false, settings: settings)
  547|      0|        
  548|      0|        
  549|      0|        let parentLayer = CALayer()
  550|      0|        parentLayer.contentsScale = UIScreen.main.scale
  551|      0|        parentLayer.bounds = CGRect(origin: CGPoint(), size: filledStar.bounds.size)
  552|      0|        parentLayer.anchorPoint = CGPoint()
  553|      0|        parentLayer.addSublayer(emptyStar)
  554|      0|        parentLayer.addSublayer(filledStar)
  555|      0|        
  556|      0|        if isRightToLeft {
  557|      0|            // Flip the star horizontally for a right-to-left language
  558|      0|            let rotation = CATransform3DMakeRotation(CGFloat(Double.pi), 0, 1, 0)
  559|      0|            filledStar.transform = CATransform3DTranslate(rotation, -filledStar.bounds.size.width, 0, 0)
  560|      0|        }
  561|      0|        
  562|      0|        // Make filled layer width smaller according to the fill level
  563|      0|        filledStar.bounds.size.width *= CGFloat(starFillLevel)
  564|      0|        
  565|      0|        return parentLayer
  566|      0|    }
  567|       |    
  568|  1.38k|    private class func createStarLayer(_ isFilled: Bool, settings: CosmosSettings) -> CALayer {
  569|  1.38k|        if let image = isFilled ? settings.filledImage : settings.emptyImage {
  570|      0|            // Create a layer that shows a star from an image
  571|      0|            return StarLayer.create(image: image, size: settings.starSize)
  572|  1.38k|        }
  573|  1.38k|        
  574|  1.38k|        // Create a layer that draws a star from an array of points
  575|  1.38k|        
  576|  1.38k|        let fillColor = isFilled ? settings.filledColor : settings.emptyColor
  577|  1.38k|        let strokeColor = isFilled ? settings.filledBorderColor : settings.emptyBorderColor
  578|  1.38k|        
  579|  1.38k|        return StarLayer.create(settings.starPoints,
  580|  1.38k|                                size: settings.starSize,
  581|  1.38k|                                lineWidth: isFilled ? settings.filledBorderWidth : settings.emptyBorderWidth,
  582|  1.38k|                                fillColor: fillColor,
  583|  1.38k|                                strokeColor: strokeColor)
  584|  1.38k|    }
  585|       |    
  586|       |    /**
  587|       |     
  588|       |     Positions the star layers one after another with a margin in between.
  589|       |     
  590|       |     - parameter layers: The star layers array.
  591|       |     - parameter starMargin: Margin between stars.
  592|       |     */
  593|    277|    class func positionStarLayers(_ layers: [CALayer], starMargin: Double) {
  594|    277|        var positionX:CGFloat = 0
  595|    277|        
  596|  1.38k|        for layer in layers {
  597|  1.38k|            layer.position.x = positionX
  598|  1.38k|            positionX += layer.bounds.width + CGFloat(starMargin)
  599|  1.38k|        }
  600|    277|    }
  601|       |}
  602|       |
  603|       |
  604|       |// ----------------------------
  605|       |//
  606|       |// CosmosLocalizedRating.swift
  607|       |//
  608|       |// ----------------------------
  609|       |import Foundation
  610|       |
  611|       |/**
  612|       | Returns the word "Rating" in user's language. It is used for voice-over  in accessibility mode.
  613|       | */
  614|       |struct CosmosLocalizedRating {
  615|       |    static var defaultText = "Rating"
  616|       |    
  617|       |    static var localizedRatings = [
  618|       |        "ar": "تصنيف",
  619|       |        "bg": "Рейтинг",
  620|       |        "cy": "Sgôr",
  621|       |        "da": "Rating",
  622|       |        "de": "Bewertung",
  623|       |        "el": "Βαθμολογία",
  624|       |        "en": defaultText,
  625|       |        "es": "Valorar",
  626|       |        "et": "Reiting",
  627|       |        "fi": "Luokitus",
  628|       |        "fr": "De note",
  629|       |        "he": "דירוג",
  630|       |        "hi": "रेटिंग",
  631|       |        "hr": "Ocjena",
  632|       |        "hu": "Értékelés",
  633|       |        "id": "Peringkat",
  634|       |        "it": "Voto",
  635|       |        "ko": "등급",
  636|       |        "lt": "Reitingas",
  637|       |        "lv": "Vērtējums",
  638|       |        "nl": "Rating",
  639|       |        "no": "Vurdering",
  640|       |        "pl": "Ocena",
  641|       |        "pt": "Classificação",
  642|       |        "ro": "Evaluare",
  643|       |        "ru": "Рейтинг",
  644|       |        "sk": "Hodnotenie",
  645|       |        "sl": "Ocena",
  646|       |        "sr": "Рејтинг",
  647|       |        "sw": "Rating",
  648|       |        "th": "การจัดอันดับ",
  649|       |        "tr": "Oy verin",
  650|       |        "cs": "Hodnocení",
  651|       |        "uk": "Рейтинг",
  652|       |        "vi": "Đánh giá",
  653|       |        "zh": "评分"
  654|       |    ]
  655|       |    
  656|    277|    static var ratingTranslation: String {
  657|    277|        let languages = preferredLanguages(Locale.preferredLanguages)
  658|    277|        return ratingInPreferredLanguage(languages)
  659|    277|    }
  660|       |    
  661|       |    /**
  662|       |     Returns the word "Rating" in user's language.
  663|       |     
  664|       |     - parameter language: ISO 639-1 language code. Example: 'en'.
  665|       |     
  666|       |     */
  667|    277|    static func translation(_ language: String) -> String? {
  668|    277|        return localizedRatings[language]
  669|    277|    }
  670|       |    
  671|       |    /**
  672|       |     
  673|       |     Returns translation using the preferred language.
  674|       |     
  675|       |     - parameter preferredLanguages: Array of preferred language codes (ISO 639-1). The first element is most preferred.
  676|       |     
  677|       |     - parameter localizedText: Dictionary with translations for the languages. The keys are ISO 639-1 language codes and values are the text.
  678|       |     
  679|       |     - parameter fallbackTranslation: The translation text used if no translation found for the preferred languages.
  680|       |     
  681|       |     - returns: Translation for the preferred language.
  682|       |     
  683|       |     */
  684|       |    static func translationInPreferredLanguage(_ preferredLanguages: [String],
  685|       |                                               localizedText: [String: String],
  686|    277|                                               fallbackTranslation: String) -> String {
  687|    277|        
  688|    277|        for language in preferredLanguages {
  689|    277|            if let translatedText = translation(language) {
  690|    277|                return translatedText
  691|    277|            }
  692|      0|        }
  693|      0|        
  694|      0|        return fallbackTranslation
  695|    277|    }
  696|       |    
  697|    277|    static func ratingInPreferredLanguage(_ preferredLanguages: [String]) -> String {
  698|    277|        return translationInPreferredLanguage(preferredLanguages,
  699|    277|                                              localizedText: localizedRatings,
  700|    277|                                              fallbackTranslation: defaultText)
  701|    277|    }
  702|       |    
  703|    277|    static func preferredLanguages(_ preferredLocales: [String]) -> [String] {
  704|    277|        return preferredLocales.map { element in
  705|    277|            
  706|    277|            let dashSeparated = element.components(separatedBy: "-")
  707|    277|            if dashSeparated.count > 1 { return dashSeparated[0] }
  708|    277|            
  709|    277|            let underscoreSeparated = element.components(separatedBy: "_")
  710|    277|            if underscoreSeparated.count > 1 { return underscoreSeparated[0] }
  711|    277|            
  712|    277|            return element
  713|    277|        }
  714|    277|    }
  715|       |}
  716|       |
  717|       |
  718|       |// ----------------------------
  719|       |//
  720|       |// CosmosLayerHelper.swift
  721|       |//
  722|       |// ----------------------------
  723|       |import UIKit
  724|       |
  725|       |/// Helper class for creating CALayer objects.
  726|       |class CosmosLayerHelper {
  727|       |    /**
  728|       |     Creates a text layer for the given text string and font.
  729|       |     
  730|       |     - parameter text: The text shown in the layer.
  731|       |     - parameter font: The text font. It is also used to calculate the layer bounds.
  732|       |     - parameter color: Text color.
  733|       |     
  734|       |     - returns: New text layer.
  735|       |     
  736|       |     */
  737|      0|    class func createTextLayer(_ text: String, font: UIFont, color: UIColor) -> CATextLayer {
  738|      0|        let size = NSString(string: text).size(withAttributes: [NSAttributedString.Key.font: font])
  739|      0|        
  740|      0|        let layer = CATextLayer()
  741|      0|        layer.bounds = CGRect(origin: CGPoint(), size: size)
  742|      0|        layer.anchorPoint = CGPoint()
  743|      0|        
  744|      0|        layer.string = text
  745|      0|        layer.font = CGFont(font.fontName as CFString)
  746|      0|        layer.fontSize = font.pointSize
  747|      0|        layer.foregroundColor = color.cgColor
  748|      0|        layer.contentsScale = UIScreen.main.scale
  749|      0|        
  750|      0|        return layer
  751|      0|    }
  752|       |}
  753|       |
  754|       |
  755|       |// ----------------------------
  756|       |//
  757|       |// CosmosTouch.swift
  758|       |//
  759|       |// ----------------------------
  760|       |import UIKit
  761|       |
  762|       |/**
  763|       | Functions for working with touch input.
  764|       | */
  765|       |struct CosmosTouch {
  766|       |    /**
  767|       |     
  768|       |     Calculates the rating based on the touch location.
  769|       |     
  770|       |     - parameter position: The horizontal location of the touch relative to the width of the stars.
  771|       |     
  772|       |     - returns: The rating representing the touch location.
  773|       |     
  774|       |     */
  775|      0|    static func touchRating(_ position: CGFloat, settings: CosmosSettings) -> Double {
  776|      0|        var rating = preciseRating(
  777|      0|            position: Double(position),
  778|      0|            numberOfStars: settings.totalStars,
  779|      0|            starSize: settings.starSize,
  780|      0|            starMargin: settings.starMargin)
  781|      0|        
  782|      0|        if settings.fillMode == .half {
  783|      0|            rating += 0.20
  784|      0|        }
  785|      0|        
  786|      0|        if settings.fillMode == .full {
  787|      0|            rating += 0.45
  788|      0|        }
  789|      0|        
  790|      0|        rating = CosmosRating.displayedRatingFromPreciseRating(rating,
  791|      0|                                                               fillMode: settings.fillMode, totalStars: settings.totalStars)
  792|      0|        
  793|      0|        rating = max(settings.minTouchRating, rating) // Can't be less than min rating
  794|      0|        
  795|      0|        return rating
  796|      0|    }
  797|       |    
  798|       |    
  799|       |    /**
  800|       |     
  801|       |     Returns the precise rating based on the touch position.
  802|       |     
  803|       |     - parameter position: The horizontal location of the touch relative to the width of the stars.
  804|       |     - parameter numberOfStars: Total number of stars, filled and full.
  805|       |     - parameter starSize: The width of a star.
  806|       |     - parameter starSize: Margin between stars.
  807|       |     - returns: The precise rating.
  808|       |     
  809|       |     */
  810|       |    static func preciseRating(position: Double, numberOfStars: Int,
  811|      0|                              starSize: Double, starMargin: Double) -> Double {
  812|      0|        
  813|      0|        if position < 0 { return 0 }
  814|      0|        var positionRemainder = position;
  815|      0|        
  816|      0|        // Calculate the number of times the star with a margin fits the position
  817|      0|        // This will be the whole part of the rating
  818|      0|        var rating: Double = Double(Int(position / (starSize + starMargin)))
  819|      0|        
  820|      0|        // If rating is grater than total number of stars - return maximum rating
  821|      0|        if Int(rating) > numberOfStars { return Double(numberOfStars) }
  822|      0|        
  823|      0|        // Calculate what portion of the last star does the position correspond to
  824|      0|        // This will be the added partial part of the rating
  825|      0|        
  826|      0|        positionRemainder -= rating * (starSize + starMargin)
  827|      0|        
  828|      0|        if positionRemainder > starSize
  829|      0|        {
  830|      0|            rating += 1
  831|      0|        } else {
  832|      0|            rating += positionRemainder / starSize
  833|      0|        }
  834|      0|        
  835|      0|        return rating
  836|      0|    }
  837|       |}
  838|       |
  839|       |
  840|       |// ----------------------------
  841|       |//
  842|       |// CosmosRating.swift
  843|       |//
  844|       |// ----------------------------
  845|       |import UIKit
  846|       |
  847|       |/**
  848|       | Helper functions for calculating rating.
  849|       | */
  850|       |struct CosmosRating {
  851|       |    
  852|       |    /**
  853|       |     
  854|       |     Returns a decimal number between 0 and 1 describing the star fill level.
  855|       |     
  856|       |     - parameter ratingRemainder: This value is passed from the loop that creates star layers. The value starts with the rating value and decremented by 1 when each star is created. For example, suppose we want to display rating of 3.5. When the first star is created the ratingRemainder parameter will be 3.5. For the second star it will be 2.5. Third: 1.5. Fourth: 0.5. Fifth: -0.5.
  857|       |     
  858|       |     - parameter fillMode: Describe how stars should be filled: full, half or precise.
  859|       |     
  860|       |     - returns: Decimal value between 0 and 1 describing the star fill level. 1 is a fully filled star. 0 is an empty star. 0.5 is a half-star.
  861|       |     
  862|       |     */
  863|  1.66k|    static func starFillLevel(ratingRemainder: Double, fillMode: StarFillMode) -> Double {
  864|  1.66k|        
  865|  1.66k|        var result = ratingRemainder
  866|  1.66k|        
  867|  1.66k|        if result > 1 { result = 1 }
  868|  1.66k|        if result < 0 { result = 0 }
  869|  1.66k|        
  870|  1.66k|        return roundFillLevel(result, fillMode: fillMode)
  871|  1.66k|    }
  872|       |    
  873|       |    /**
  874|       |     
  875|       |     Rounds a single star's fill level according to the fill mode. "Full" mode returns 0 or 1 by using the standard decimal rounding. "Half" mode returns 0, 0.5 or 1 by rounding the decimal to closest of 3 values. "Precise" mode will return the fill level unchanged.
  876|       |     
  877|       |     - parameter starFillLevel: Decimal number between 0 and 1 describing the star fill level.
  878|       |     
  879|       |     - parameter fillMode: Fill mode that is used to round the fill level value.
  880|       |     
  881|       |     - returns: The rounded fill level.
  882|       |     
  883|       |     */
  884|  1.66k|    static func roundFillLevel(_ starFillLevel: Double, fillMode: StarFillMode) -> Double {
  885|  1.66k|        switch fillMode {
  886|  1.66k|        case .full:
  887|  1.66k|            return Double(round(starFillLevel))
  888|  1.66k|        case .half:
  889|      0|            return Double(round(starFillLevel * 2) / 2)
  890|  1.66k|        case .precise :
  891|      0|            return starFillLevel
  892|  1.66k|        }
  893|  1.66k|    }
  894|       |    
  895|       |    
  896|       |    /**
  897|       |     
  898|       |     Helper function for calculating the rating that is displayed to the user
  899|       |     taking into account the star fill mode. For example, if the fill mode is .half and precise rating is 4.6, the displayed rating will be 4.5. And if the fill mode is .full the displayed rating will be 5.
  900|       |     
  901|       |     - parameter preciseRating: Precise rating value, like 4.8237
  902|       |     
  903|       |     - parameter fillMode: Describe how stars should be filled: full, half or precise.
  904|       |     
  905|       |     - parameter totalStars: Total number of stars.
  906|       |     
  907|       |     - returns: Returns rating that is displayed to the user taking into account the star fill mode.
  908|       |     
  909|       |     */
  910|       |    static func displayedRatingFromPreciseRating(_ preciseRating: Double,
  911|    277|                                                 fillMode: StarFillMode, totalStars: Int) -> Double {
  912|    277|        
  913|    277|        let starFloorNumber = floor(preciseRating)
  914|    277|        let singleStarRemainder = preciseRating - starFloorNumber
  915|    277|        
  916|    277|        var displayedRating = starFloorNumber + starFillLevel(
  917|    277|            ratingRemainder: singleStarRemainder, fillMode: fillMode)
  918|    277|        
  919|    277|        displayedRating = min(Double(totalStars), displayedRating) // Can't go bigger than number of stars
  920|    277|        displayedRating = max(0, displayedRating) // Can't be less than zero
  921|    277|        
  922|    277|        return displayedRating
  923|    277|    }
  924|       |    
  925|       |    /**
  926|       |     
  927|       |     Returns the number of filled stars for given rating.
  928|       |     
  929|       |     - parameter rating: The rating to be displayed.
  930|       |     - parameter totalNumberOfStars: Total number of stars.
  931|       |     - returns: Number of filled stars. If rating is biggen than the total number of stars (usually 5) it returns the maximum number of stars.
  932|       |     
  933|       |     */
  934|    277|    static func numberOfFilledStars(_ rating: Double, totalNumberOfStars: Int) -> Double {
  935|    277|        if rating > Double(totalNumberOfStars) { return Double(totalNumberOfStars) }
  936|    277|        if rating < 0 { return 0 }
  937|    277|        
  938|    277|        return rating
  939|    277|    }
  940|       |}
  941|       |
  942|       |
  943|       |// ----------------------------
  944|       |//
  945|       |// CosmosSettings.swift
  946|       |//
  947|       |// ----------------------------
  948|       |import UIKit
  949|       |
  950|       |/**
  951|       | Settings that define the appearance of the star rating views.
  952|       | */
  953|       |public struct CosmosSettings {
  954|       |    
  955|       |    /// Returns default set of settings for CosmosView
  956|     30|    public static var `default`: CosmosSettings {
  957|     30|        return CosmosSettings()
  958|     30|    }
  959|       |    
  960|     30|    public init() {}
  961|       |    
  962|       |    // MARK: - Star settings
  963|       |    // -----------------------------
  964|       |    
  965|       |    /// Border color of an empty star.
  966|       |    public var emptyBorderColor = CosmosDefaultSettings.emptyBorderColor
  967|       |    
  968|       |    /// Width of the border for empty star.
  969|       |    public var emptyBorderWidth: Double = CosmosDefaultSettings.emptyBorderWidth
  970|       |    
  971|       |    /// Border color of a filled star.
  972|       |    public var filledBorderColor = CosmosDefaultSettings.filledBorderColor
  973|       |    
  974|       |    /// Width of the border for a filled star.
  975|       |    public var filledBorderWidth: Double = CosmosDefaultSettings.filledBorderWidth
  976|       |    
  977|       |    /// Background color of an empty star.
  978|       |    public var emptyColor = CosmosDefaultSettings.emptyColor
  979|       |    
  980|       |    /// Background color of a filled star.
  981|       |    public var filledColor = CosmosDefaultSettings.filledColor
  982|       |    
  983|       |    /**
  984|       |     
  985|       |     Defines how the star is filled when the rating value is not a whole integer. It can either show full stars, half stars or stars partially filled according to the rating value.
  986|       |     
  987|       |     */
  988|       |    public var fillMode = CosmosDefaultSettings.fillMode
  989|       |    
  990|       |    /// Distance between stars.
  991|       |    public var starMargin: Double = CosmosDefaultSettings.starMargin
  992|       |    
  993|       |    /**
  994|       |     
  995|       |     Array of points for drawing the star with size of 100 by 100 pixels. Supply your points if you need to draw a different shape.
  996|       |     
  997|       |     */
  998|       |    public var starPoints: [CGPoint] = CosmosDefaultSettings.starPoints
  999|       |    
 1000|       |    /// Size of a single star.
 1001|       |    public var starSize: Double = CosmosDefaultSettings.starSize
 1002|       |    
 1003|       |    /// The maximum number of stars to be shown.
 1004|       |    public var totalStars = CosmosDefaultSettings.totalStars
 1005|       |    
 1006|       |    // MARK: - Star image settings
 1007|       |    // -----------------------------
 1008|       |    
 1009|       |    /**
 1010|       |     
 1011|       |     Image used for the filled portion of the star. By default the star is drawn from the array of points unless an image is supplied.
 1012|       |     
 1013|       |     */
 1014|       |    public var filledImage: UIImage? = nil
 1015|       |    
 1016|       |    /**
 1017|       |     
 1018|       |     Image used for the empty portion of the star. By default the star is drawn from the array of points unless an image is supplied.
 1019|       |     
 1020|       |     */
 1021|       |    public var emptyImage: UIImage? = nil
 1022|       |    
 1023|       |    // MARK: - Text settings
 1024|       |    // -----------------------------
 1025|       |    
 1026|       |    /// Color of the text.
 1027|       |    public var textColor = CosmosDefaultSettings.textColor
 1028|       |    
 1029|       |    /// Font for the text.
 1030|       |    public var textFont = CosmosDefaultSettings.textFont
 1031|       |    
 1032|       |    /// Distance between the text and the stars.
 1033|       |    public var textMargin: Double = CosmosDefaultSettings.textMargin
 1034|       |    
 1035|       |    
 1036|       |    // MARK: - Touch settings
 1037|       |    // -----------------------------
 1038|       |    
 1039|       |    /// The lowest rating that user can set by touching the stars.
 1040|       |    public var minTouchRating: Double = CosmosDefaultSettings.minTouchRating
 1041|       |    
 1042|       |    /// Set to `false` if you don't want to pass touches to superview (can be useful in a table view).
 1043|       |    public var passTouchesToSuperview = CosmosDefaultSettings.passTouchesToSuperview
 1044|       |    
 1045|       |    /// When `true` the star fill level is updated when user touches the cosmos view. When `false` the Cosmos view only shows the rating and does not act as the input control.
 1046|       |    public var updateOnTouch = CosmosDefaultSettings.updateOnTouch
 1047|       |}
 1048|       |
 1049|       |
 1050|       |// ----------------------------
 1051|       |//
 1052|       |// CosmosTouchTarget.swift
 1053|       |//
 1054|       |// ----------------------------
 1055|       |import UIKit
 1056|       |
 1057|       |/**
 1058|       | Helper function to make sure bounds are big enought to be used as touch target.
 1059|       | The function is used in pointInside(point: CGPoint, withEvent event: UIEvent?) of UIImageView.
 1060|       | */
 1061|       |struct CosmosTouchTarget {
 1062|     40|    static func optimize(_ bounds: CGRect) -> CGRect {
 1063|     40|        let recommendedHitSize: CGFloat = 44
 1064|     40|        
 1065|     40|        var hitWidthIncrease:CGFloat = recommendedHitSize - bounds.width
 1066|     40|        var hitHeightIncrease:CGFloat = recommendedHitSize - bounds.height
 1067|     40|        
 1068|     40|        if hitWidthIncrease < 0 { hitWidthIncrease = 0 }
 1069|     40|        if hitHeightIncrease < 0 { hitHeightIncrease = 0 }
 1070|     40|        
 1071|     40|        let extendedBounds: CGRect = bounds.insetBy(dx: -hitWidthIncrease / 2,
 1072|     40|                                                    dy: -hitHeightIncrease / 2)
 1073|     40|        
 1074|     40|        return extendedBounds
 1075|     40|    }
 1076|       |}
 1077|       |
 1078|       |
 1079|       |// ----------------------------
 1080|       |//
 1081|       |// RightToLeft.swift
 1082|       |//
 1083|       |// ----------------------------
 1084|       |import UIKit
 1085|       |
 1086|       |/**
 1087|       | 
 1088|       | Helper functions for dealing with right-to-left languages.
 1089|       | 
 1090|       | */
 1091|       |struct RightToLeft {
 1092|    277|    static func isRightToLeft(_ view: UIView) -> Bool {
 1093|    277|        if #available(iOS 9.0, *) {
 1094|    277|            return UIView.userInterfaceLayoutDirection(
 1095|    277|                for: view.semanticContentAttribute) == .rightToLeft
 1096|    277|        } else {
 1097|      0|            return false
 1098|      0|        }
 1099|      0|    }
 1100|       |}
 1101|       |
 1102|       |
 1103|       |// ----------------------------
 1104|       |//
 1105|       |// CosmosView.swift
 1106|       |//
 1107|       |// ----------------------------
 1108|       |import UIKit
 1109|       |
 1110|       |/**
 1111|       | A star rating view that can be used to show customer rating for the products. On can select stars by tapping on them when updateOnTouch settings is true. An optional text can be supplied that is shown on the right side.
 1112|       | Example:
 1113|       | cosmosView.rating = 4
 1114|       | cosmosView.text = "(123)"
 1115|       | Shows: ★★★★☆ (123)
 1116|       | */
 1117|       |@IBDesignable open class CosmosView: UIView {
 1118|       |    
 1119|       |    /**
 1120|       |     
 1121|       |     The currently shown number of stars, usually between 1 and 5. If the value is decimal the stars will be shown according to the Fill Mode setting.
 1122|       |     */
 1123|       |    @IBInspectable open var rating: Double = CosmosDefaultSettings.rating {
 1124|     45|        didSet {
 1125|     45|            if oldValue != rating {
 1126|     38|                update()
 1127|     45|            }
 1128|     45|        }
 1129|       |    }
 1130|       |    
 1131|       |    /// Currently shown text. Set it to nil to display just the stars without text.
 1132|       |    @IBInspectable open var text: String? {
 1133|      0|        didSet {
 1134|      0|            if oldValue != text {
 1135|      0|                update()
 1136|      0|            }
 1137|      0|        }
 1138|       |    }
 1139|       |    
 1140|       |    /// Star rating settings.
 1141|       |    open var settings: CosmosSettings = .default {
 1142|    209|        didSet {
 1143|    209|            update()
 1144|    209|        }
 1145|       |    }
 1146|       |    
 1147|       |    /// Stores calculated size of the view. It is used as intrinsic content size.
 1148|       |    private var viewSize = CGSize()
 1149|       |    
 1150|       |    /// Draws the stars when the view comes out of storyboard with default settings
 1151|     30|    open override func awakeFromNib() {
 1152|     30|        super.awakeFromNib()
 1153|     30|        
 1154|     30|        update()
 1155|     30|    }
 1156|       |    
 1157|       |    /**
 1158|       |     Initializes and returns a newly allocated cosmos view object.
 1159|       |     
 1160|       |     */
 1161|      0|    public convenience init(settings: CosmosSettings = .default) {
 1162|      0|        self.init(frame: .zero, settings: settings)
 1163|      0|    }
 1164|       |    
 1165|       |    /**
 1166|       |     Initializes and returns a newly allocated cosmos view object with the specified frame rectangle.
 1167|       |     - parameter frame: The frame rectangle for the view.
 1168|       |     
 1169|       |     */
 1170|      0|    override public convenience init(frame: CGRect) {
 1171|      0|        self.init(frame: frame, settings: .default)
 1172|      0|    }
 1173|       |    
 1174|      0|    public init(frame: CGRect, settings: CosmosSettings) {
 1175|      0|        super.init(frame: frame)
 1176|      0|        self.settings = settings
 1177|      0|        update()
 1178|      0|        improvePerformance()
 1179|      0|    }
 1180|       |    
 1181|       |    /// Initializes and returns a newly allocated cosmos view object.
 1182|     30|    required public init?(coder aDecoder: NSCoder) {
 1183|     30|        super.init(coder: aDecoder)
 1184|     30|        
 1185|     30|        improvePerformance()
 1186|     30|    }
 1187|       |    
 1188|       |    /// Change view settings for faster drawing
 1189|     30|    private func improvePerformance() {
 1190|     30|        /// Cache the view into a bitmap instead of redrawing the stars each time
 1191|     30|        layer.shouldRasterize = true
 1192|     30|        layer.rasterizationScale = UIScreen.main.scale
 1193|     30|        
 1194|     30|        isOpaque = true
 1195|     30|    }
 1196|       |    
 1197|       |    /**
 1198|       |     
 1199|       |     Updates the stars and optional text based on current values of `rating` and `text` properties.
 1200|       |     
 1201|       |     */
 1202|    277|    open func update() {
 1203|    277|        
 1204|    277|        // Create star layers
 1205|    277|        // ------------
 1206|    277|        
 1207|    277|        var layers = CosmosLayers.createStarLayers(
 1208|    277|            rating,
 1209|    277|            settings: settings,
 1210|    277|            isRightToLeft: RightToLeft.isRightToLeft(self)
 1211|    277|        )
 1212|    277|        
 1213|    277|        // Create text layer
 1214|    277|        // ------------
 1215|    277|        if let text = text {
 1216|      0|            let textLayer = createTextLayer(text, layers: layers)
 1217|      0|            layers = addTextLayer(textLayer: textLayer, layers: layers)
 1218|    277|        }
 1219|    277|        
 1220|    277|        layer.sublayers = layers
 1221|    277|        
 1222|    277|        
 1223|    277|        // Update size
 1224|    277|        // ------------
 1225|    277|        updateSize(layers)
 1226|    277|        
 1227|    277|        // Update accesibility
 1228|    277|        // ------------
 1229|    277|        updateAccessibility()
 1230|    277|    }
 1231|       |    
 1232|       |    /**
 1233|       |     
 1234|       |     Creates the text layer for the given text string.
 1235|       |     
 1236|       |     - parameter text: Text string for the text layer.
 1237|       |     - parameter layers: Arrays of layers containing the stars.
 1238|       |     
 1239|       |     - returns: The newly created text layer.
 1240|       |     
 1241|       |     */
 1242|      0|    private func createTextLayer(_ text: String, layers: [CALayer]) -> CALayer {
 1243|      0|        let textLayer = CosmosLayerHelper.createTextLayer(text,
 1244|      0|                                                          font: settings.textFont, color: settings.textColor)
 1245|      0|        
 1246|      0|        let starsSize = CosmosSize.calculateSizeToFitLayers(layers)
 1247|      0|        
 1248|      0|        if RightToLeft.isRightToLeft(self) {
 1249|      0|            CosmosText.position(textLayer, starsSize: CGSize(width: 0, height: starsSize.height), textMargin: 0)
 1250|      0|        } else {
 1251|      0|            CosmosText.position(textLayer, starsSize: starsSize, textMargin: settings.textMargin)
 1252|      0|        }
 1253|      0|        
 1254|      0|        layer.addSublayer(textLayer)
 1255|      0|        
 1256|      0|        return textLayer
 1257|      0|    }
 1258|       |    
 1259|       |    /**
 1260|       |     
 1261|       |     Adds text layer to the array of layers
 1262|       |     
 1263|       |     - parameter textLayer: A text layer.
 1264|       |     - parameter layers: An array where the text layer will be added.
 1265|       |     - returns: An array of layer with the text layer.
 1266|       |     
 1267|       |     */
 1268|      0|    private func addTextLayer(textLayer: CALayer, layers: [CALayer]) -> [CALayer] {
 1269|      0|        var allLayers = layers
 1270|      0|        // Position stars after the text for right-to-left languages
 1271|      0|        if RightToLeft.isRightToLeft(self) {
 1272|      0|            for starLayer in layers {
 1273|      0|                starLayer.position.x += textLayer.bounds.width + CGFloat(settings.textMargin);
 1274|      0|            }
 1275|      0|            
 1276|      0|            allLayers.insert(textLayer, at: 0)
 1277|      0|        } else {
 1278|      0|            allLayers.append(textLayer)
 1279|      0|        }
 1280|      0|        
 1281|      0|        return allLayers
 1282|      0|    }
 1283|       |    
 1284|       |    /**
 1285|       |     Updates the size to fit all the layers containing stars and text.
 1286|       |     
 1287|       |     - parameter layers: Array of layers containing stars and the text.
 1288|       |     */
 1289|    277|    private func updateSize(_ layers: [CALayer]) {
 1290|    277|        viewSize = CosmosSize.calculateSizeToFitLayers(layers)
 1291|    277|        invalidateIntrinsicContentSize()
 1292|    277|        
 1293|    277|        // Stretch the view to include all stars and the text.
 1294|    277|        // Needed when used without Auto Layout to receive touches for all stars.
 1295|    277|        frame.size = intrinsicContentSize
 1296|    277|    }
 1297|       |    
 1298|       |    /// Returns the content size to fit all the star and text layers.
 1299|    307|    override open var intrinsicContentSize:CGSize {
 1300|    307|        return viewSize
 1301|    307|    }
 1302|       |    
 1303|       |    /**
 1304|       |     
 1305|       |     Prepares the Cosmos view for reuse in a table view cell.
 1306|       |     If the cosmos view is used in a table view cell, call this method after the
 1307|       |     cell is dequeued. Alternatively, override UITableViewCell's prepareForReuse method and call
 1308|       |     this method from there.
 1309|       |     
 1310|       |     */
 1311|      0|    open func prepareForReuse() {
 1312|      0|        previousRatingForDidTouchCallback = -123.192
 1313|      0|    }
 1314|       |    
 1315|       |    // MARK: - Accessibility
 1316|       |    
 1317|    277|    private func updateAccessibility() {
 1318|    277|        CosmosAccessibility.update(self, rating: rating, text: text, settings: settings)
 1319|    277|    }
 1320|       |    
 1321|       |    /// Called by the system in accessibility voice-over mode when the value is incremented by the user.
 1322|      0|    open override func accessibilityIncrement() {
 1323|      0|        super.accessibilityIncrement()
 1324|      0|        
 1325|      0|        rating += CosmosAccessibility.accessibilityIncrement(rating, settings: settings)
 1326|      0|        didTouchCosmos?(rating)
 1327|      0|        didFinishTouchingCosmos?(rating)
 1328|      0|    }
 1329|       |    
 1330|       |    /// Called by the system in accessibility voice-over mode when the value is decremented by the user.
 1331|      0|    open override func accessibilityDecrement() {
 1332|      0|        super.accessibilityDecrement()
 1333|      0|        
 1334|      0|        rating -= CosmosAccessibility.accessibilityDecrement(rating, settings: settings)
 1335|      0|        didTouchCosmos?(rating)
 1336|      0|        didFinishTouchingCosmos?(rating)
 1337|      0|    }
 1338|       |    
 1339|       |    // MARK: - Touch recognition
 1340|       |    
 1341|       |    /// Closure will be called when user touches the cosmos view. The touch rating argument is passed to the closure.
 1342|       |    open var didTouchCosmos: ((Double)->())?
 1343|       |    
 1344|       |    /// Closure will be called when the user lifts finger from the cosmos view. The touch rating argument is passed to the closure.
 1345|       |    open var didFinishTouchingCosmos: ((Double)->())?
 1346|       |    
 1347|       |    /// Overriding the function to detect the first touch gesture.
 1348|      0|    open override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
 1349|      0|        if settings.passTouchesToSuperview { super.touchesBegan(touches, with: event) }
 1350|      0|        guard let location = touchLocationFromBeginningOfRating(touches) else { return }
 1351|      0|        onDidTouch(location)
 1352|      0|    }
 1353|       |    
 1354|       |    /// Overriding the function to detect touch move.
 1355|      0|    open override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
 1356|      0|        if settings.passTouchesToSuperview { super.touchesMoved(touches, with: event) }
 1357|      0|        guard let location = touchLocationFromBeginningOfRating(touches) else { return }
 1358|      0|        onDidTouch(location)
 1359|      0|    }
 1360|       |    
 1361|       |    /// Returns the distance of the touch relative to the left edge of the first star
 1362|      0|    func touchLocationFromBeginningOfRating(_ touches: Set<UITouch>) -> CGFloat? {
 1363|      0|        guard let touch = touches.first else { return nil }
 1364|      0|        var location = touch.location(in: self).x
 1365|      0|        
 1366|      0|        // In right-to-left languages, the first star will be on the right
 1367|      0|        if RightToLeft.isRightToLeft(self) { location = bounds.width - location }
 1368|      0|        
 1369|      0|        return location
 1370|      0|    }
 1371|       |    
 1372|       |    /// Detecting event when the user lifts their finger.
 1373|      0|    open override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
 1374|      0|        if settings.passTouchesToSuperview { super.touchesEnded(touches, with: event) }
 1375|      0|        didFinishTouchingCosmos?(rating)
 1376|      0|    }
 1377|       |    
 1378|       |    /**
 1379|       |     
 1380|       |     Detecting event when the touches are cancelled (can happen in a scroll view).
 1381|       |     Behave as if user has lifted their finger.
 1382|       |     
 1383|       |     */
 1384|      0|    open override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {
 1385|      0|        if settings.passTouchesToSuperview { super.touchesCancelled(touches, with: event) }
 1386|      0|        didFinishTouchingCosmos?(rating)
 1387|      0|    }
 1388|       |    
 1389|       |    /**
 1390|       |     Called when the view is touched.
 1391|       |     - parameter locationX: The horizontal location of the touch relative to the width of the stars.
 1392|       |     
 1393|       |     - parameter starsWidth: The width of the stars excluding the text.
 1394|       |     
 1395|       |     */
 1396|      0|    func onDidTouch(_ locationX: CGFloat) {
 1397|      0|        let calculatedTouchRating = CosmosTouch.touchRating(locationX, settings: settings)
 1398|      0|        
 1399|      0|        if settings.updateOnTouch {
 1400|      0|            rating = calculatedTouchRating
 1401|      0|        }
 1402|      0|        
 1403|      0|        if calculatedTouchRating == previousRatingForDidTouchCallback {
 1404|      0|            // Do not call didTouchCosmos if rating has not changed
 1405|      0|            return
 1406|      0|        }
 1407|      0|        
 1408|      0|        didTouchCosmos?(calculatedTouchRating)
 1409|      0|        previousRatingForDidTouchCallback = calculatedTouchRating
 1410|      0|    }
 1411|       |    
 1412|       |    private var previousRatingForDidTouchCallback: Double = -123.192
 1413|       |    
 1414|       |    /// Increase the hitsize of the view if it's less than 44px for easier touching.
 1415|     40|    override open func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
 1416|     40|        let oprimizedBounds = CosmosTouchTarget.optimize(bounds)
 1417|     40|        return oprimizedBounds.contains(point)
 1418|     40|    }
 1419|       |    
 1420|       |    
 1421|       |    // MARK: - Properties inspectable from the storyboard
 1422|       |    
 1423|       |    @IBInspectable var totalStars: Int = CosmosDefaultSettings.totalStars {
 1424|     30|        didSet {
 1425|     30|            settings.totalStars = totalStars
 1426|     30|        }
 1427|       |    }
 1428|       |    
 1429|       |    @IBInspectable var starSize: Double = CosmosDefaultSettings.starSize {
 1430|     30|        didSet {
 1431|     30|            settings.starSize = starSize
 1432|     30|        }
 1433|       |    }
 1434|       |    
 1435|       |    @IBInspectable var filledColor: UIColor = CosmosDefaultSettings.filledColor {
 1436|     30|        didSet {
 1437|     30|            settings.filledColor = filledColor
 1438|     30|        }
 1439|       |    }
 1440|       |    
 1441|       |    @IBInspectable var emptyColor: UIColor = CosmosDefaultSettings.emptyColor {
 1442|     30|        didSet {
 1443|     30|            settings.emptyColor = emptyColor
 1444|     30|        }
 1445|       |    }
 1446|       |    
 1447|       |    @IBInspectable var emptyBorderColor: UIColor = CosmosDefaultSettings.emptyBorderColor {
 1448|     30|        didSet {
 1449|     30|            settings.emptyBorderColor = emptyBorderColor
 1450|     30|        }
 1451|       |    }
 1452|       |    
 1453|       |    @IBInspectable var emptyBorderWidth: Double = CosmosDefaultSettings.emptyBorderWidth {
 1454|      0|        didSet {
 1455|      0|            settings.emptyBorderWidth = emptyBorderWidth
 1456|      0|        }
 1457|       |    }
 1458|       |    
 1459|       |    @IBInspectable var filledBorderColor: UIColor = CosmosDefaultSettings.filledBorderColor {
 1460|     30|        didSet {
 1461|     30|            settings.filledBorderColor = filledBorderColor
 1462|     30|        }
 1463|       |    }
 1464|       |    
 1465|       |    @IBInspectable var filledBorderWidth: Double = CosmosDefaultSettings.filledBorderWidth {
 1466|      0|        didSet {
 1467|      0|            settings.filledBorderWidth = filledBorderWidth
 1468|      0|        }
 1469|       |    }
 1470|       |    
 1471|       |    @IBInspectable var starMargin: Double = CosmosDefaultSettings.starMargin {
 1472|      0|        didSet {
 1473|      0|            settings.starMargin = starMargin
 1474|      0|        }
 1475|       |    }
 1476|       |    
 1477|       |    @IBInspectable var fillMode: Int = CosmosDefaultSettings.fillMode.rawValue {
 1478|      0|        didSet {
 1479|      0|            settings.fillMode = StarFillMode(rawValue: fillMode) ?? CosmosDefaultSettings.fillMode
 1480|      0|        }
 1481|       |    }
 1482|       |    
 1483|       |    @IBInspectable var textSize: Double = CosmosDefaultSettings.textSize {
 1484|      0|        didSet {
 1485|      0|            settings.textFont = settings.textFont.withSize(CGFloat(textSize))
 1486|      0|        }
 1487|       |    }
 1488|       |    
 1489|       |    @IBInspectable var textMargin: Double = CosmosDefaultSettings.textMargin {
 1490|      0|        didSet {
 1491|      0|            settings.textMargin = textMargin
 1492|      0|        }
 1493|       |    }
 1494|       |    
 1495|       |    @IBInspectable var textColor: UIColor = CosmosDefaultSettings.textColor {
 1496|      0|        didSet {
 1497|      0|            settings.textColor = textColor
 1498|      0|        }
 1499|       |    }
 1500|       |    
 1501|       |    @IBInspectable var updateOnTouch: Bool = CosmosDefaultSettings.updateOnTouch {
 1502|     29|        didSet {
 1503|     29|            settings.updateOnTouch = updateOnTouch
 1504|     29|        }
 1505|       |    }
 1506|       |    
 1507|       |    @IBInspectable var minTouchRating: Double = CosmosDefaultSettings.minTouchRating {
 1508|      0|        didSet {
 1509|      0|            settings.minTouchRating = minTouchRating
 1510|      0|        }
 1511|       |    }
 1512|       |    
 1513|       |    @IBInspectable var filledImage: UIImage? {
 1514|      0|        didSet {
 1515|      0|            settings.filledImage = filledImage
 1516|      0|        }
 1517|       |    }
 1518|       |    
 1519|       |    @IBInspectable var emptyImage: UIImage? {
 1520|      0|        didSet {
 1521|      0|            settings.emptyImage = emptyImage
 1522|      0|        }
 1523|       |    }
 1524|       |    
 1525|       |    /// Draw the stars in interface buidler
 1526|      0|    open override func prepareForInterfaceBuilder() {
 1527|      0|        super.prepareForInterfaceBuilder()
 1528|      0|        
 1529|      0|        update()
 1530|      0|    }
 1531|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/MyReview/ViewModel/MyReviewViewModel.swift:
    1|       |//
    2|       |//  MyReviewViewModel.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/05.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |class MyReviewViewModel: MyReviewViewModelling {
   12|       |    
   13|       |    weak var view: MyReviewViewControllable?
   14|       |    var repo: MyReviewRepositoring?
   15|       |    
   16|      1|    init(view: MyReviewViewControllable, repo: MyReviewRepositoring) {
   17|      1|        self.view = view
   18|      1|        self.repo = repo
   19|      1|        repo.setViewModel(vModel: self)
   20|      1|    }
   21|       |    
   22|      1|    func getReview(reviewId: String) {
   23|      1|        repo?.getReview(reviewId: reviewId)
   24|      1|    }
   25|       |    
   26|      0|    func setReview(_ review: String, _ rating: String) {
   27|      0|        if let rating = Double(rating) {
   28|      0|           let trimmedReview = review.trimmingCharacters(in: .whitespacesAndNewlines)
   29|      0|           self.view?.setReviewInfo(trimmedReview, rating)
   30|      0|        }
   31|      0|    }
   32|       |    
   33|      0|    func postReview(_ review: String, _ rating: Double, _ model: DetailsModel) {
   34|      0|        if model.reviewId == nil {
   35|      0|            //Add further options later on (set read status)
   36|      0|            let params: [String: Any] = [
   37|      0|                "book_id": model.bookId,
   38|      0|                "review[review]": review,
   39|      0|                "review[rating]": rating
   40|      0|            ]
   41|      0|            repo?.postReview(params: params)
   42|      0|        } else {
   43|      0|            let params: [String: Any] = [
   44|      0|                "review[review]": review,
   45|      0|                "review[rating]": rating
   46|      0|            ]
   47|      0|            if let reviewId = model.reviewId {
   48|      0|                repo?.editReview(params: params, reviewId)
   49|      0|            }
   50|      0|        }
   51|      0|    }
   52|       |    
   53|      0|    func closePage() {
   54|      0|        view?.returnToPrevScreen()
   55|      0|    }
   56|       |    
   57|      0|    func errorBuilder(_ error: String) {
   58|      0|        if error == "error1" {
   59|      0|            view?.displayErrorPopup("Error fetching results. Please check your network conenction and try again", "Network Error")
   60|      0|        } else if error == "error2" {
   61|      0|            view?.displayErrorPopup("Error posting your review. Please check your network connection and try again", "Network Error")
   62|      0|        } else {
   63|      0|            view?.displayErrorPopup("No review found. You may have selected an alternative version of the book you reviewed", "Review not found")
   64|      0|        }
   65|      0|    }
   66|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Profile/Repository/ProfileRepository.swift:
    1|       |//
    2|       |//  ProfileRepository.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/04/29.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import SWXMLHash
   11|       |
   12|       |class ProfileRepository: ProfileRepositoring, ProfileRepositorable {
   13|       |    
   14|       |    weak var vModel: ProfileViewModelling?
   15|       |    var userId: String?
   16|      0|    lazy var goodreadsService: ProfileGoodreadsServicing = { return ProfileGoodreadsService(repo: self) }()
   17|       |    
   18|      0|    func fetchUserInfo() {
   19|      0|        storedDetailsCheck()
   20|      0|        guard let checkedUserId = userId else {
   21|      0|            //Show error
   22|      0|            return
   23|      0|        }
   24|      0|        goodreadsService.getGoodreadsUser(userId: checkedUserId)
   25|      0|    }
   26|       |    
   27|      0|    func parseUserInfo(_ xml: XMLIndexer) {
   28|      0|
   29|      0|        guard let name = xml["GoodreadsResponse"]["user"]["name"].element?.text else {
   30|      0|            errorAlert("error2")
   31|      0|            return
   32|      0|        }
   33|      0|        guard let imageUrl = xml["GoodreadsResponse"]["user"]["image_url"].element?.text else {
   34|      0|            errorAlert("error2")
   35|      0|            return
   36|      0|        }
   37|      0|        guard let datejoined = xml["GoodreadsResponse"]["user"]["joined"].element?.text else {
   38|      0|            errorAlert("error2")
   39|      0|            return
   40|      0|        }
   41|      0|        guard let numFriends = xml["GoodreadsResponse"]["user"]["friends_count"].element?.text else {
   42|      0|            errorAlert("error2")
   43|      0|            return
   44|      0|        }
   45|      0|        guard let numGroups = xml["GoodreadsResponse"]["user"]["groups_count"].element?.text else {
   46|      0|            errorAlert("error2")
   47|      0|            return
   48|      0|        }
   49|      0|        guard let numReviews = xml["GoodreadsResponse"]["user"]["reviews_count"].element?.text else {
   50|      0|            errorAlert("error2")
   51|      0|            return
   52|      0|        }
   53|      0|        
   54|      0|        let profile = ProfileModel(name: name, profileImageLink: imageUrl, joinDate: datejoined, numFriends: numFriends, numGroups: numGroups, numReviews: numReviews)
   55|      0|        vModel?.setUserInfo(userProfile: profile)
   56|      0|    }
   57|       |    
   58|      0|    func setViewModel(vModel: ProfileViewModelling) {
   59|      0|        self.vModel = vModel
   60|      0|    }
   61|       |    
   62|      0|    func errorAlert(_ error: String) {
   63|      0|        vModel?.errorAlert(error)
   64|      0|    }
   65|       |    
   66|      0|    func storedDetailsCheck() {
   67|      0|        let preferences = UserDefaults.standard
   68|      0|        let idKey = "userID"
   69|      0|        
   70|      0|        if preferences.object(forKey: idKey) != nil {
   71|      0|            if let userID = preferences.string(forKey: idKey) {
   72|      0|                userId = userID
   73|      0|            }
   74|      0|        }
   75|      0|    }
   76|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Profile/Services/ProfileGoodreadsService.swift:
    1|       |//
    2|       |//  ProfileGoodreadsService.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/04/29.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Alamofire
   11|       |import SWXMLHash
   12|       |
   13|       |class ProfileGoodreadsService: ProfileGoodreadsServicing {
   14|       |    
   15|       |     weak var repo: ProfileRepositorable?
   16|       |    
   17|      0|    init(repo: ProfileRepositorable) {
   18|      0|        self.repo = repo
   19|      0|    }
   20|       |    
   21|      0|    func getGoodreadsUser(userId: String) {
   22|      0|        guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") else {
   23|      0|            return
   24|      0|        }
   25|      0|        let url = "https://www.goodreads.com/user/show/\(userId).xml?key=\(goodreadsKey)"
   26|      0|        Alamofire.request(url, method: .get).response { response in
   27|      0|            
   28|      0|            guard let data = response.data else {
   29|      0|                self.repo?.errorAlert("error1")
   30|      0|                return
   31|      0|            }
   32|      0|
   33|      0|            let xml = SWXMLHash.parse(data)
   34|      0|            self.repo?.parseUserInfo(xml)
   35|      0|        }
   36|      0|    }
   37|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Profile/View Model/ProfileViewModel.swift:
    1|       |//
    2|       |//  ProfileViewModel.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/04/29.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |class ProfileViewModel: ProfileViewModelling {
   12|       |    
   13|       |    weak var view: ProfileViewControllable?
   14|       |    var repo: ProfileRepositoring?
   15|       |    
   16|      0|    init(view: ProfileViewControllable, repo: ProfileRepositoring) {
   17|      0|        self.view = view
   18|      0|        self.repo = repo
   19|      0|        repo.setViewModel(vModel: self)
   20|      0|    }
   21|       |    
   22|      0|    func getUserInfo() {
   23|      0|        repo?.fetchUserInfo()
   24|      0|    }
   25|       |    
   26|      0|    func errorAlert(_ error: String) {
   27|      0|        if error == "error1" {
   28|      0|            view?.displayErrorPopup("No user profile information found. Please try again", "No user data")
   29|      0|        } else if error == "error2" {
   30|      0|            view?.displayErrorPopup("Unable to parse user information", "Error fetching data")
   31|      0|        }
   32|      0|    }
   33|       |    
   34|      0|    func setUserInfo(userProfile: ProfileModel) {
   35|      0|        let newModel = ProfileModel(name: userProfile.name, profileImageLink: userProfile.profileImageLink, joinDate: "Joined: \(userProfile.joinDate)", numFriends: userProfile.numFriends, numGroups: userProfile.numGroups, numReviews: userProfile.numReviews)
   36|      0|        
   37|      0|        view?.setUserInfo(userProfile: newModel)
   38|      0|    }
   39|       |    
   40|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Profile/View/ProfileViewController.swift:
    1|       |//
    2|       |//  AccountViewController.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/04/29.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import SafariServices
   11|       |
   12|       |class ProfileViewController: UIViewController, SFSafariViewControllerDelegate {
   13|       |
   14|       |    @IBOutlet weak var profileImage: UIImageView!
   15|       |    @IBOutlet weak var userNameLabel: UILabel!
   16|       |    @IBOutlet weak var joinedDateLabel: UILabel!
   17|       |    @IBOutlet weak var numFriendsLabel: UILabel!
   18|       |    @IBOutlet weak var numGroupsLabel: UILabel!
   19|       |    @IBOutlet weak var numReviewsLabel: UILabel!
   20|       |    @IBOutlet weak var friendsView: UIView!
   21|       |    @IBOutlet weak var groupsView: UIView!
   22|       |    @IBOutlet weak var reviewsView: UIView!
   23|       |    @IBOutlet weak var loadingIndicator: UIActivityIndicatorView!
   24|       |    
   25|      0|    lazy var vModel: ProfileViewModelling = { return ProfileViewModel(view: self, repo: ProfileRepository()) }()
   26|       |    
   27|      0|    override func viewDidLoad() {
   28|      0|        super.viewDidLoad()
   29|      0|    }
   30|       |    
   31|      0|    override func viewWillAppear(_ animated: Bool) {
   32|      0|        vModel.getUserInfo()
   33|      0|        loadingIndicator.startAnimating()
   34|      0|        loadingIndicator.hidesWhenStopped = true
   35|      0|    }
   36|       |    
   37|      0|    @IBAction func btnLogout(_ sender: Any) {
   38|      0|        let preferences = UserDefaults.standard
   39|      0|        let idKey = "userID"
   40|      0|        let ouathKey = "oauth"
   41|      0|        
   42|      0|        preferences.removeObject(forKey: idKey)
   43|      0|        preferences.removeObject(forKey: ouathKey)
   44|      0|        
   45|      0|        let urlString = "https://www.goodreads.com/user/sign_out"
   46|      0|        
   47|      0|        let safariVC = SFSafariViewController(url: NSURL(string: urlString)! as URL)
   48|      0|        self.present(safariVC, animated: true, completion: nil)
   49|      0|        safariVC.delegate = self
   50|      0|    }
   51|       |    
   52|      0|    func safariViewControllerDidFinish(_ controller: SFSafariViewController) {
   53|      0|        closeApplication()
   54|      0|    }
   55|       |    
   56|      0|    func closeApplication () {
   57|      0|        let exitAppAlert = UIAlertController(title: "Restart is needed",
   58|      0|                                             message: "We need to restart to properly log you out.\n Please reopen the app after this.",
   59|      0|                                             preferredStyle: .alert)
   60|      0|        
   61|      0|        let resetApp = UIAlertAction(title: "Close Now", style: .destructive) { _ -> Void in
   62|      0|            // Throw app into background
   63|      0|            UIControl().sendAction(#selector(URLSessionTask.suspend), to: UIApplication.shared, for: nil)
   64|      0|            // terminaing app in background
   65|      0|            DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(1), execute: {
   66|      0|                exit(EXIT_SUCCESS)
   67|      0|            })
   68|      0|        }
   69|      0|        
   70|      0|        exitAppAlert.addAction(resetApp)
   71|      0|        present(exitAppAlert, animated: true, completion: nil)
   72|      0|    }
   73|       |    
   74|      0|    @objc func friendsButtonTapped(gesture: UIGestureRecognizer) {
   75|      0|        //Temporary code to show that buttons would be clickable
   76|      0|        self.friendsView.backgroundColor = .groupTableViewBackground
   77|      0|    }
   78|       |}
   79|       |
   80|       |extension ProfileViewController: ProfileViewControllable {
   81|       |    
   82|      0|    func setUserInfo(userProfile: ProfileModel) {
   83|      0|        self.profileImage.fetchImage(url: userProfile.profileImageLink)
   84|      0|        self.profileImage.layer.borderWidth = 1
   85|      0|        self.profileImage.layer.masksToBounds = false
   86|      0|        self.profileImage.layer.borderColor = UIColor.black.cgColor
   87|      0|        self.profileImage.layer.cornerRadius = self.profileImage.frame.height / 2
   88|      0|        self.profileImage.clipsToBounds = true
   89|      0|        
   90|      0|        self.userNameLabel.text = userProfile.name
   91|      0|        self.joinedDateLabel.text = userProfile.joinDate
   92|      0|        self.numFriendsLabel.text = userProfile.numFriends
   93|      0|        self.numGroupsLabel.text = userProfile.numGroups
   94|      0|        self.numReviewsLabel.text = userProfile.numReviews
   95|      0|        
   96|      0|         let friendTapGesture = UITapGestureRecognizer(target: self, action: #selector(ProfileViewController.friendsButtonTapped(gesture:)))
   97|      0|         self.friendsView.addGestureRecognizer(friendTapGesture)
   98|      0|        
   99|      0|        loadingIndicator.stopAnimating()
  100|      0|    }
  101|       |    
  102|      0|    func displayErrorPopup(_ error: String, _ title: String) {
  103|      0|        
  104|      0|    }
  105|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Recommendations/Repository/RecommendationsRepository.swift:
    1|       |//
    2|       |//  RecommendationsRepository.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/25.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import OAuthSwift
   11|       |import SWXMLHash
   12|       |import SwiftyJSON
   13|       |
   14|       |class RecommendationsRepository: RecommendationsRepositoring, RecommendationsRepositorable {
   15|       |    
   16|       |    var oauthswift: OAuthSwift?
   17|       |    
   18|       |    weak var vModel: RecommendationsViewModelling?
   19|      0|    lazy var goodreadsService: RecommendationsGoodreadsServicing = { return RecommendationsGoodreadsService(repo: self) }()
   20|      0|    lazy var tastediveService: RecommendationsTastediveServicing = {return RecommendationsTastediveService(repo: self) }()
   21|      0|    lazy var backendService: RecommendationsBackendServicing = {return RecommendationsBackendService(repo: self)}()
   22|       |    
   23|       |    //var recommendedList: [RecommendedBooksModel]?
   24|       |    
   25|      0|    func setViewModel(vModel: RecommendationsViewModelling) {
   26|      0|        self.vModel = vModel
   27|      0|    }
   28|       |    
   29|      0|    func getBookList() {
   30|      0|        goodreadsService.getBookList()
   31|      0|        backendService.getPopularBooks()
   32|      0|    }
   33|       |    
   34|      0|    func parseBooklist(_ xml: XMLIndexer) {
   35|      0|        var books: [RecommendationsModel] = []
   36|      0|        //Change this to include if statement inside for loop to speed up process
   37|      0|        for elem in xml["GoodreadsResponse"]["reviews"]["review"].all {
   38|      0|            let model = RecommendationsModel(bookName: elem["book"]["title"].element!.text, bookRating: Int(elem["rating"].element!.text)!)
   39|      0|            books.append(model)
   40|      0|        }
   41|      0|        if books.isEmpty {
   42|      0|            vModel?.errorAlert("error2")
   43|      0|        } else {
   44|      0|            vModel?.filterBooks(bookList: books)
   45|      0|        }
   46|      0|    }
   47|       |    
   48|      0|    func errorAlert(_ error: String) {
   49|      0|        vModel?.errorAlert(error)
   50|      0|    }
   51|       |    
   52|      0|    func getRecommendations(with list: [String]) {
   53|      0|        let stringList = list.joined(separator: ", ")
   54|      0|        tastediveService.getRecommendations(stringList)
   55|      0|    }
   56|       |    
   57|      0|    func decodeBackendPopularResults(json: JSON?) {
   58|      0|        guard let results = json?["isbnArray"].arrayValue else {
   59|      0|            return
   60|      0|        }
   61|      0|        var isbnArray: [String] = []
   62|      0|        for result in results {
   63|      0|            isbnArray.append(result.stringValue)
   64|      0|        }
   65|      0|        goodreadsService.searchBook(isbnArray: isbnArray)
   66|      0|    }
   67|       |    
   68|      0|    func sendPopularBooksList(_ books: [RecommendedBooksModel]) {
   69|      0|        vModel?.sendPopularBooksList(books)
   70|      0|    }
   71|       |    
   72|      0|    func sendBookList(_ books: [RecommendedBooksModel]) {
   73|      0|        vModel?.setBooksModel(books)
   74|      0|    }
   75|       |    
   76|      0|    func decodeResults(json: JSON?) {
   77|      0|        guard let results = json?["Similar"]["Results"].arrayValue else {
   78|      0|            return
   79|      0|        }
   80|      0|        
   81|      0|        var nameList: [String] = []
   82|      0|        for result in results {
   83|      0|            let bookName = result["Name"].stringValue
   84|      0|            nameList.append(bookName)
   85|      0|        }
   86|      0|        goodreadsService.searchBook(titleArray: nameList)
   87|      0|    }
   88|       |    
   89|      0|    func getToken() {
   90|      0|        let preferences = UserDefaults.standard
   91|      0|        let key = "oauth"
   92|      0|        if preferences.object(forKey: key) == nil {
   93|      0|            vModel?.errorAlert("error4")
   94|      0|        } else {
   95|      0|            let decoded  = preferences.object(forKey: key) as! Data
   96|      0|            guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
   97|      0|                return
   98|      0|            }
   99|      0|            guard let goodreadsSecret = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Secret") as? String else {
  100|      0|                return
  101|      0|            }
  102|      0|            if let credential = NSKeyedUnarchiver.unarchiveObject(with: decoded) as? OAuthSwiftCredential {
  103|      0|                let oauthS = OAuth1Swift(consumerKey: goodreadsKey,
  104|      0|                                         consumerSecret: goodreadsSecret)
  105|      0|                oauthS.client.credential.oauthToken = credential.oauthToken
  106|      0|                oauthS.client.credential.oauthTokenSecret = credential.oauthTokenSecret
  107|      0|                goodreadsService.setToken(oauthS)
  108|      0|            }
  109|      0|        }
  110|      0|        
  111|      0|        let idKey = "userID"
  112|      0|        if preferences.object(forKey: idKey) != nil {
  113|      0|            guard let safeId = preferences.string(forKey: idKey) else {
  114|      0|                return
  115|      0|            }
  116|      0|            goodreadsService.setUserId(safeId)
  117|      0|        }
  118|      0|    }
  119|       |    
  120|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Recommendations/Services/RecommendationsBackendService.swift:
    1|       |//
    2|       |//  RecommendationsBackendService.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/04/16.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Alamofire
   11|       |import SwiftyJSON
   12|       |
   13|       |class RecommendationsBackendService: RecommendationsBackendServicing {
   14|       |    
   15|       |    weak var repo: RecommendationsRepositorable?
   16|       |    
   17|      0|    init(repo: RecommendationsRepositorable) {
   18|      0|        self.repo = repo
   19|      0|    }
   20|       |    
   21|      0|    func getPopularBooks() {
   22|      0|        let urlToSearch = "https://bookwyrm-backend.vapor.cloud/popular"
   23|      0|        
   24|      0|        Alamofire.request(urlToSearch).responseJSON { response in
   25|      0|            guard let data = response.data else {
   26|      0|                self.repo?.errorAlert("error1")
   27|      0|                return
   28|      0|            }
   29|      0|            
   30|      0|            guard let json = try? JSON(data: data) else {
   31|      0|                return
   32|      0|            }
   33|      0|            self.repo?.decodeBackendPopularResults(json: json)
   34|      0|        }
   35|      0|    }
   36|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Recommendations/Services/RecommendationsGoodreadsService.swift:
    1|       |//
    2|       |//  RecommendationsOauthService.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/25.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import SWXMLHash
   11|       |import OAuthSwift
   12|       |import Alamofire
   13|       |
   14|       |class RecommendationsGoodreadsService: RecommendationsGoodreadsServicing {
   15|       |    
   16|       |    weak var repo: RecommendationsRepositorable?
   17|       |    var oauthswift: OAuthSwift?
   18|       |    var userId: String?
   19|       |    
   20|      0|    init(repo: RecommendationsRepositorable) {
   21|      0|        self.repo = repo
   22|      0|    }
   23|       |    
   24|      0|    func setToken(_ token: OAuthSwift) {
   25|      0|        oauthswift = token
   26|      0|    }
   27|       |    
   28|      0|    func setUserId(_ userId: String) {
   29|      0|        self.userId = userId
   30|      0|    }
   31|       |    
   32|      0|    func getBookList() {
   33|      0|        let uiTesting = ProcessInfo.processInfo.arguments.contains("Testing")
   34|      0|        
   35|      0|        if uiTesting {
   36|      0|            if let path = Bundle.main.path(forResource: "Book_List", ofType: "xml") {
   37|      0|                do {
   38|      0|                    let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .alwaysMapped)
   39|      0|                    let xml = SWXMLHash.parse(data)
   40|      0|                    repo?.parseBooklist(xml)
   41|      0|                } catch let error {
   42|      0|                    print("parse error: \(error.localizedDescription)")
   43|      0|                }
   44|      0|            } else {
   45|      0|                print("Invalid filename/path.")
   46|      0|            }
   47|      0|        } else {
   48|      0|            repo?.getToken()
   49|      0|            let oauthSwift: OAuth1Swift = oauthswift as! OAuth1Swift
   50|      0|            //Uses ID that was received to get a list of users books read
   51|      0|            guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") else {
   52|      0|                return
   53|      0|            }
   54|      0|            _ = oauthSwift.client.request(
   55|      0|                "https://www.goodreads.com/review/list/\(userId ?? "123").xml?key=9\(goodreadsKey)&v=2", method: .GET,
   56|      0|                success: { response in
   57|      0|                    
   58|      0|                    guard let dataString = response.string else {
   59|      0|                        return
   60|      0|                    }
   61|      0|                    let xml = SWXMLHash.parse(dataString)
   62|      0|                    self.repo?.parseBooklist(xml)
   63|      0|            }, failure: { _ in
   64|      0|                self.repo?.errorAlert("error1")
   65|      0|            }
   66|      0|            )
   67|      0|        }
   68|      0|    }
   69|       |    
   70|      0|    func searchBook(titleArray: [String]) {
   71|      0|        var recommendedModel: [RecommendedBooksModel] = []
   72|      0|        var count = 0
   73|      0|        guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") else {
   74|      0|            return
   75|      0|        }
   76|      0|        for title in titleArray {
   77|      0|            let urlWithSpaces = "https://www.goodreads.com/book/title.xml?title=\(title)&key=\(goodreadsKey)"
   78|      0|            guard let url = urlWithSpaces.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
   79|      0|                return
   80|      0|            }
   81|      0|            
   82|      0|            Alamofire.request(url, method: .get).response { response in
   83|      0|                
   84|      0|                //Check error message
   85|      0|                guard let data = response.data else {
   86|      0|                    self.repo?.errorAlert("error1")
   87|      0|                    return
   88|      0|                }
   89|      0|                //Add another guard
   90|      0|                let xml = SWXMLHash.parse(data)
   91|      0|                
   92|      0|                //return author as an array here and parse it in the view model
   93|      0|                let model = RecommendedBooksModel(title: xml["GoodreadsResponse"]["book"]["title"].element?.text ?? "",
   94|      0|                                                  authors: xml["GoodreadsResponse"]["book"]["authors"]["author"][0]["name"].element?.text ?? "",
   95|      0|                                                  largeImageUrl: xml["GoodreadsResponse"]["book"]["image_url"].element?.text ?? "",
   96|      0|                                                  bookId: xml["GoodreadsResponse"]["book"]["id"].element?.text ?? "",
   97|      0|                                                  isbn: xml["GoodreadsResponse"]["book"]["isbn13"].element?.text ?? "",
   98|      0|                                                  description: xml["GoodreadsResponse"]["book"]["description"].element?.text.removingPercentEncoding ?? "",
   99|      0|                                                  publishedDay: xml["GoodreadsResponse"]["book"]["publication_day"].element?.text ?? "01",
  100|      0|                                                  publishedMonth: xml["GoodreadsResponse"]["book"]["publication_month"].element?.text ?? "01",
  101|      0|                                                  publishedYear: xml["GoodreadsResponse"]["book"]["publication_year"].element?.text ?? "2000",
  102|      0|                                                  reviewInfo: xml["GoodreadsResponse"]["book"]["isbn13"].element?.text ?? "",
  103|      0|                                                  webLink: xml["GoodreadsResponse"]["book"]["link"].element?.text ?? "",
  104|      0|                                                  pageNumbers: xml["GoodreadsResponse"]["book"]["num_pages"].element?.text ?? "")
  105|      0|                
  106|      0|                count += 1
  107|      0|                recommendedModel.append(model)
  108|      0|                if count == titleArray.count {
  109|      0|                    self.repo?.sendBookList(recommendedModel)
  110|      0|                }
  111|      0|                
  112|      0|            }
  113|      0|        }
  114|      0|    }
  115|       |    
  116|      0|    func searchBook(isbnArray: [String]) {
  117|      0|        var recommendedModel: [RecommendedBooksModel] = []
  118|      0|        var count = 0
  119|      0|        guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
  120|      0|            return
  121|      0|        }
  122|      0|        for isbn in isbnArray {
  123|      0|            let url = "https://www.goodreads.com/book/isbn/\(isbn)?key=\(goodreadsKey)"
  124|      0|            Alamofire.request(url, method: .get).response { response in
  125|      0|                
  126|      0|                //Check error message
  127|      0|                guard let data = response.data else {
  128|      0|                    self.repo?.errorAlert("error1")
  129|      0|                    return
  130|      0|                }
  131|      0|                //Add another guard
  132|      0|                let xml = SWXMLHash.parse(data)
  133|      0|                
  134|      0|                //return author as an array here and parse it in the view model
  135|      0|                let model = RecommendedBooksModel(title: xml["GoodreadsResponse"]["book"]["title"].element?.text ?? "",
  136|      0|                                                  authors: xml["GoodreadsResponse"]["book"]["authors"]["author"][0]["name"].element?.text ?? "",
  137|      0|                                                  largeImageUrl: xml["GoodreadsResponse"]["book"]["image_url"].element?.text ?? "",
  138|      0|                                                  bookId: xml["GoodreadsResponse"]["book"]["id"].element?.text ?? "",
  139|      0|                                                  isbn: xml["GoodreadsResponse"]["book"]["isbn13"].element?.text ?? "",
  140|      0|                                                  description: xml["GoodreadsResponse"]["book"]["description"].element?.text.removingPercentEncoding ?? "",
  141|      0|                                                  publishedDay: xml["GoodreadsResponse"]["book"]["publication_day"].element?.text ?? "01",
  142|      0|                                                  publishedMonth: xml["GoodreadsResponse"]["book"]["publication_month"].element?.text ?? "01",
  143|      0|                                                  publishedYear: xml["GoodreadsResponse"]["book"]["publication_year"].element?.text ?? "2000",
  144|      0|                                                  reviewInfo: xml["GoodreadsResponse"]["book"]["isbn13"].element?.text ?? "",
  145|      0|                                                  webLink: xml["GoodreadsResponse"]["book"]["link"].element?.text ?? "",
  146|      0|                                                  pageNumbers: xml["GoodreadsResponse"]["book"]["num_pages"].element?.text ?? "")
  147|      0|                
  148|      0|                count += 1
  149|      0|                recommendedModel.append(model)
  150|      0|                if count == isbnArray.count {
  151|      0|                    self.repo?.sendPopularBooksList(recommendedModel)
  152|      0|                }
  153|      0|                
  154|      0|            }
  155|      0|        }
  156|      0|    }
  157|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Recommendations/Services/RecommendationsTastediveService.swift:
    1|       |//
    2|       |//  RecommendationsTastediveService.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/26.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Alamofire
   11|       |import SwiftyJSON
   12|       |
   13|       |class RecommendationsTastediveService: RecommendationsTastediveServicing {
   14|       |    
   15|       |    weak var repo: RecommendationsRepositorable?
   16|       |    
   17|      0|    init(repo: RecommendationsRepositorable) {
   18|      0|        self.repo = repo
   19|      0|    }
   20|       |    
   21|      0|    func getRecommendations(_ list: String) {
   22|      0|        guard let tastediveKey = Bundle.main.object(forInfoDictionaryKey: "Tastedive_Key") as? String else {
   23|      0|            return
   24|      0|        }
   25|      0|        let urlWithSpaces = "https://tastedive.com/api/similar?q=\(list)&type=books&k=\(tastediveKey)"
   26|      0|        guard let url = urlWithSpaces.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
   27|      0|            return
   28|      0|        }
   29|      0|        
   30|      0|        Alamofire.request(url).responseJSON { response in
   31|      0|            guard let data = response.data else {
   32|      0|                self.repo?.errorAlert("error1")
   33|      0|                return
   34|      0|            }
   35|      0|            
   36|      0|            let json = try? JSON(data: data)
   37|      0|            self.repo?.decodeResults(json: json)
   38|      0|        }
   39|      0|    }
   40|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Recommendations/View/RecommendationsViewController.swift:
    1|       |//
    2|       |//  RecommendationsViewController.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/06.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class RecommendationsViewController: UIViewController {
   12|       |    
   13|       |    @IBOutlet weak var booksCollectionView: UICollectionView!
   14|       |    
   15|       |    @IBOutlet weak var popularCollectionView: UICollectionView!
   16|       |    
   17|       |    @IBOutlet weak var fetchingActivity: UIActivityIndicatorView!
   18|       |    
   19|       |    @IBOutlet weak var secondFetchingActivity: UIActivityIndicatorView!
   20|       |    
   21|      0|    lazy var vModel: RecommendationsViewModelling = { return RecommendationsViewModel(view: self, repo: RecommendationsRepository()) }()
   22|       |    
   23|       |    private var books = [RecommendedBooksModel]() {
   24|      0|        didSet {
   25|      0|            self.booksCollectionView.reloadData()
   26|      0|            fetchingActivity.hidesWhenStopped = true
   27|      0|            fetchingActivity.stopAnimating()
   28|      0|        }
   29|       |    }
   30|       |    
   31|       |    private var popularBooks = [RecommendedBooksModel]() {
   32|      0|        didSet {
   33|      0|            self.popularCollectionView.reloadData()
   34|      0|            secondFetchingActivity.hidesWhenStopped = true
   35|      0|            secondFetchingActivity.stopAnimating()
   36|      0|        }
   37|       |    }
   38|       |
   39|      0|    override func viewDidLoad() {
   40|      0|        super.viewDidLoad()
   41|      0|        vModel.fetchBookList()
   42|      0|        fetchingActivity.startAnimating()
   43|      0|        secondFetchingActivity.startAnimating()
   44|      0|    }
   45|       |}
   46|       |
   47|       |extension RecommendationsViewController: UICollectionViewDataSource, UICollectionViewDelegate {
   48|       |    
   49|      0|    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   50|      0|        if collectionView == self.booksCollectionView {
   51|      0|        return books.count
   52|      0|        } else {
   53|      0|            return popularBooks.count
   54|      0|        }
   55|      0|    }
   56|      0|    func numberOfSections(in collectionView: UICollectionView) -> Int {
   57|      0|        return 1
   58|      0|    }
   59|       |    
   60|      0|    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   61|      0|        if collectionView == self.booksCollectionView {
   62|      0|            guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "bookCell", for: indexPath as IndexPath)
   63|      0|                as? CustomCollectionViewCell else {
   64|      0|                    return CustomCollectionViewCell()
   65|      0|            }
   66|      0|            //cell.bookImage.fetchHighQualityImage(isbn: books[indexPath.row].isbn)
   67|      0|            cell.bookImage.fetchImage(url: books[indexPath.row].largeImageUrl)
   68|      0|            cell.bookImage.layer.cornerRadius = 5.0
   69|      0|            cell.bookImage.layer.masksToBounds = true
   70|      0|            cell.titleLabel.text = books[indexPath.row].title
   71|      0|            cell.authorLabel.text = "By: \(books[indexPath.row].authors)"
   72|      0|            return cell
   73|      0|        } else {
   74|      0|            guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "smallBookCell", for: indexPath as IndexPath)
   75|      0|                as? SmallerCollectionViewCell else {
   76|      0|                    return SmallerCollectionViewCell()
   77|      0|            }
   78|      0|            cell.popularBookImage.fetchImage(url: popularBooks[indexPath.row].largeImageUrl)
   79|      0|            cell.popularBookImage.layer.cornerRadius = 5.0
   80|      0|            cell.popularBookImage.layer.masksToBounds = true
   81|      0|            cell.smallAuthorLabel.text = "By: \(popularBooks[indexPath.row].authors)"
   82|      0|            cell.smallTitleLabel.text = popularBooks[indexPath.row].title
   83|      0|            return cell
   84|      0|        }
   85|      0|    }
   86|       |    
   87|      0|    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
   88|      0|        if collectionView == self.booksCollectionView {
   89|      0|            vModel.setBook(books[indexPath.row])
   90|      0|        } else {
   91|      0|            vModel.setBook(popularBooks[indexPath.row])
   92|      0|        }
   93|      0|    }
   94|       |    
   95|       |}
   96|       |
   97|       |extension RecommendationsViewController: RecommendationsControllable {
   98|       |    
   99|      0|     func setBooksModel(_ books: [RecommendedBooksModel]) {
  100|      0|        self.books = books
  101|      0|    }
  102|       |    
  103|      0|    func setPopularBooksModel(_ books: [RecommendedBooksModel]) {
  104|      0|        self.popularBooks = books
  105|      0|    }
  106|       |    
  107|      0|    func moveToDetailsPage(_ bookInfo: SearchModel) {
  108|      0|        if let vControl = self.storyboard?.instantiateViewController(withIdentifier: "NewDetail") as? NewDetailViewController {
  109|      0|            vControl.bookModel = bookInfo
  110|      0|            navigationController?.pushViewController(vControl, animated: true)
  111|      0|        }
  112|      0|    }
  113|       |    
  114|      0|    func displayErrorPopup(_ error: String, _ title: String) {
  115|      0|        let alert = UIAlertController(title: title, message: error, preferredStyle: .alert)
  116|      0|        alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
  117|      0|        self.present(alert, animated: true, completion: nil)
  118|      0|    }
  119|       |    
  120|      0|    func displayNoRecommendations() {
  121|      0|        fetchingActivity.hidesWhenStopped = true
  122|      0|        fetchingActivity.stopAnimating()
  123|      0|        let alert = UIAlertController(title: "No books found", message: "Oops, we can't seem to find any recommendations for you. Try rating more books and adding them to your shelf", preferredStyle: .alert)
  124|      0|        alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
  125|      0|        self.present(alert, animated: true, completion: nil)
  126|      0|    }
  127|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Recommendations/ViewModel/RecommendationsViewModel.swift:
    1|       |//
    2|       |//  RecommendationsViewModel.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/25.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |class RecommendationsViewModel: RecommendationsViewModelling {
   12|       |    
   13|       |    weak var view: RecommendationsControllable?
   14|       |    var repo: RecommendationsRepositoring?
   15|       |    
   16|      0|    init(view: RecommendationsControllable, repo: RecommendationsRepositoring) {
   17|      0|        self.view = view
   18|      0|        self.repo = repo
   19|      0|        repo.setViewModel(vModel: self)
   20|      0|    }
   21|       |    
   22|      0|    func fetchBookList() {
   23|      0|        repo?.getBookList()
   24|      0|    }
   25|       |    
   26|      0|    func filterBooks(bookList: [RecommendationsModel]) {
   27|      0|        var highRatedBooks: [String] = []
   28|      0|        for book in bookList where book.bookRating > 3 {
   29|      0|                let name = book.bookName.replacingOccurrences(of: "\\s?\\([^)]*\\)", with: "", options: .regularExpression)
   30|      0|                highRatedBooks.append(name)
   31|      0|        }
   32|      0|        
   33|      0|        if !highRatedBooks.isEmpty {
   34|      0|            if highRatedBooks.count > 5 {
   35|      0|                let newBooks = highRatedBooks[randomPick: 5]
   36|      0|                repo?.getRecommendations(with: newBooks)
   37|      0|            } else {
   38|      0|                repo?.getRecommendations(with: highRatedBooks)
   39|      0|            }
   40|      0|        }
   41|      0|    }
   42|       |    
   43|      0|    func setBook(_ bookInfo: RecommendedBooksModel) {
   44|      0|        
   45|      0|        let modifiedModel = SearchModel(title: bookInfo.title,
   46|      0|                                        authors: "By: \(bookInfo.authors)",
   47|      0|            smallImageUrl: "",
   48|      0|            largeImageUrl: bookInfo.largeImageUrl,
   49|      0|            publishedDate: "Date Published: \(bookInfo.publishedDay)-\(bookInfo.publishedMonth)-\(bookInfo.publishedYear)",
   50|      0|            reviewInfo: bookInfo.reviewInfo,
   51|      0|            isbn: "ISBN_13: \(bookInfo.isbn)",
   52|      0|            pageNumbers: "Pages: \(bookInfo.pageNumbers)",
   53|      0|            genres: nil,
   54|      0|            description: bookInfo.description.replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression, range: nil),
   55|      0|            webLink: bookInfo.webLink)
   56|      0|        
   57|      0|        view?.moveToDetailsPage(modifiedModel)
   58|      0|    }
   59|       |    
   60|      0|    func errorAlert(_ error: String) {
   61|      0|        if error == "error1" {
   62|      0|            view?.displayErrorPopup("Please check your internet connection and try again", "Network Error")
   63|      0|        } else if error == "error2" {
   64|      0|            view?.displayNoRecommendations()
   65|      0|        } else if error == "error4" {
   66|      0|            view?.displayErrorPopup("Unable to obtain login token. Please restart the app", "Authentication Error")
   67|      0|        }
   68|      0|    }
   69|       |    
   70|      0|    func setBooksModel(_ books: [RecommendedBooksModel]) {
   71|      0|        view?.setBooksModel(books)
   72|      0|    }
   73|       |    
   74|      0|    func sendPopularBooksList(_ books: [RecommendedBooksModel]) {
   75|      0|        view?.setPopularBooksModel(books)
   76|      0|    }
   77|       |    
   78|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Search/Repository/SearchRepository.swift:
    1|       |//
    2|       |//  SearchRepository.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/28.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import SwiftyJSON
   11|       |import OAuthSwift
   12|       |import SWXMLHash
   13|       |import SafariServices
   14|       |
   15|       |class SearchRepository: SearchRepositoring, SearchRepositorable {
   16|       |    
   17|       |    var oauthswift: OAuthSwift?
   18|       |    
   19|       |    weak var vModel: SearchViewModelling?
   20|     14|    func setViewModel(vModel: SearchViewModelling) {
   21|     14|        self.vModel = vModel
   22|     14|    }
   23|       |    
   24|     12|    lazy var alamofireService: SearchAlamofireServicing = { return SearchAlamofireService(repo: self) }()
   25|       |    
   26|     68|    func search(searchText: String) {
   27|     68|        alamofireService.getSearchResults(searchText)
   28|     68|    }
   29|       |    
   30|     35|    func decodeResults(json: JSON?) {
   31|     35|        let results = json?["items"].arrayValue
   32|     35|        
   33|     35|        guard let safeResults = results else {
   34|      0|            return
   35|     35|        }
   36|     35|        
   37|     35|        var bookModel = [SearchModel]()
   38|    350|        for result in safeResults {
   39|    350|            let authors = result["volumeInfo"]["authors"].arrayValue
   40|    350|            var authorInfo = authors.first?.stringValue
   41|    350|            
   42|    350|            var skipFirst = true
   43|    448|            for author in authors {
   44|    448|                if skipFirst {
   45|    313|                    skipFirst = false
   46|    448|                } else {
   47|    135|                    authorInfo = "\(authorInfo ?? "") , \(author.stringValue)"
   48|    448|                }
   49|    448|            }
   50|    350|            
   51|    350|            let genres =  result["volumeInfo"]["categories"].arrayValue
   52|    350|            var genreInfo = genres.first?.stringValue
   53|    350|            skipFirst = true
   54|    350|            
   55|    350|            for genre in genres {
   56|    308|                if skipFirst {
   57|    308|                    skipFirst = false
   58|    308|                } else {
   59|      0|                    genreInfo = "\(genreInfo ?? "") , \(genre.stringValue)"
   60|    308|                }
   61|    350|            }
   62|    350|            
   63|    350|            bookModel.append(SearchModel(title: result["volumeInfo"]["title"].stringValue,
   64|    350|                                         authors: authorInfo ?? "",
   65|    350|                                         smallImageUrl: result["volumeInfo"]["imageLinks"]["smallThumbnail"].string ?? "",
   66|    350|                                         largeImageUrl: result["volumeInfo"]["imageLinks"]["thumbnail"].string ?? "",
   67|    350|                                         publishedDate: result["volumeInfo"]["publishedDate"].stringValue,
   68|    350|                                         reviewInfo: result["volumeInfo"]["title"].stringValue,
   69|    350|                                         isbn: result["volumeInfo"]["industryIdentifiers"].arrayValue.first?["identifier"].stringValue ?? "",
   70|    350|                                         pageNumbers: result["volumeInfo"]["pageCount"].stringValue,
   71|    350|                                         genres: genreInfo,
   72|    350|                                         description: result["volumeInfo"]["description"].stringValue.removingPercentEncoding ?? "",
   73|    350|                                         webLink: result["accessInfo"]["webReaderLink"].stringValue))
   74|    350|        }
   75|     35|        
   76|     35|        self.vModel?.setResults(bookModel)
   77|     35|    }
   78|       |    
   79|      1|    func errorBuilder(_ error: String) {
   80|      1|        vModel?.errorBuilder(error)
   81|      1|    }
   82|       |    
   83|      0|    func doOAuthGoodreads(callback: @escaping (_ token: OAuthSwift) -> Void) {
   84|      0|        /** 1 . create an instance of OAuth1 **/
   85|      0|        guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
   86|      0|            return
   87|      0|        }
   88|      0|        guard let goodreadsSecret = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Secret") as? String else {
   89|      0|            return
   90|      0|        }
   91|      0|        let oauthswift = OAuth1Swift(
   92|      0|            consumerKey: goodreadsKey,
   93|      0|            consumerSecret: goodreadsSecret,
   94|      0|            requestTokenUrl: "https://www.goodreads.com/oauth/request_token",
   95|      0|            authorizeUrl: "https://www.goodreads.com/oauth/authorize?mobile=1",
   96|      0|            accessTokenUrl: "https://www.goodreads.com/oauth/access_token"
   97|      0|        )
   98|      0|        
   99|      0|        self.oauthswift=oauthswift
  100|      0|        oauthswift.allowMissingOAuthVerifier = true
  101|      0|        oauthswift.authorizeURLHandler = getURLHandler()
  102|      0|        /** 2 . authorize with a redirect url **/
  103|      0|        _ = oauthswift.authorize(
  104|      0|            withCallbackURL: URL(string: "BookWyrm://oauth-callback/goodreads")!,
  105|      0|            success: { _, _, _ in //Credential is first param
  106|      0|                self.oauthswift = oauthswift
  107|      0|                callback(oauthswift)
  108|      0|        },
  109|      0|            failure: { error in
  110|      0|                self.vModel?.errorBuilder(error.localizedDescription)
  111|      0|        }
  112|      0|        )
  113|      0|    }
  114|       |    
  115|      0|    func storedDetailsCheck() {
  116|      0|        let preferences = UserDefaults.standard
  117|      0|        let currentOauthKey = "oauth"
  118|      0|        let idKey = "userID"
  119|      0|        
  120|      0|        if preferences.object(forKey: currentOauthKey) == nil {
  121|      0|            doOAuthGoodreads { token in
  122|      0|                let encodedData = NSKeyedArchiver.archivedData(withRootObject: token.client.credential)
  123|      0|                preferences.set(encodedData, forKey: currentOauthKey)
  124|      0|                self.storedDetailsCheck()
  125|      0|            }
  126|      0|        } else {
  127|      0|            let decoded  = preferences.object(forKey: currentOauthKey) as! Data
  128|      0|            guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
  129|      0|                return
  130|      0|            }
  131|      0|            guard let goodreadsSecret = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Secret") as? String else {
  132|      0|                return
  133|      0|            }
  134|      0|            if let credential = NSKeyedUnarchiver.unarchiveObject(with: decoded) as? OAuthSwiftCredential {
  135|      0|                let oauthS = OAuth1Swift(consumerKey: goodreadsKey,
  136|      0|                                         consumerSecret: goodreadsSecret)
  137|      0|                oauthS.client.credential.oauthToken = credential.oauthToken
  138|      0|                oauthS.client.credential.oauthTokenSecret = credential.oauthTokenSecret
  139|      0|                oauthswift = oauthS
  140|      0|            }
  141|      0|        }
  142|      0|        
  143|      0|        if preferences.object(forKey: idKey) == nil {
  144|      0|            getUserID { userId in
  145|      0|                preferences.set(userId, forKey: idKey)
  146|      0|            }
  147|      0|        }
  148|      0|    }
  149|       |    
  150|      0|    func getURLHandler() -> OAuthSwiftURLHandlerType {
  151|      0|        if #available(iOS 9.0, *) {
  152|      0|            let handler = SafariURLHandler(viewController: vModel?.fetchView() as! UIViewController, oauthSwift: self.oauthswift!)
  153|      0|            handler.factory = { url in
  154|      0|                let controller = SFSafariViewController(url: url)
  155|      0|                // Customize it, for instance
  156|      0|                if #available(iOS 10.0, *) {
  157|      0|                    // controller.preferredBarTintColor = UIColor.red
  158|      0|                }
  159|      0|                return controller
  160|      0|            }
  161|      0|            
  162|      0|            return handler
  163|      0|        }
  164|      0|        return OAuthSwiftOpenURLExternally.sharedInstance
  165|      0|    }
  166|       |    
  167|       |    //Runs an escaping method that fetches users ID
  168|      0|    func getUserID(_ callback: @escaping (_ id: String) -> Void) {
  169|      0|        let oauthswift = self.oauthswift as! OAuth1Swift
  170|      0|        
  171|      0|        _ = oauthswift.client.get(
  172|      0|            "https://www.goodreads.com/api/auth_user",
  173|      0|            success: { response in
  174|      0|                /** parse the returned xml to read user id **/
  175|      0|                guard let dataString = response.string else {
  176|      0|                    return
  177|      0|                }
  178|      0|                let xml = SWXMLHash.parse(dataString)
  179|      0|                guard let userID  =  (xml["GoodreadsResponse"]["user"].element?.attribute(by: "id")?.text) else {
  180|      0|                    return
  181|      0|                }
  182|      0|                callback(userID)
  183|      0|                }, failure: { error in
  184|      0|                    self.vModel?.errorBuilder(error.localizedDescription)
  185|      0|                }
  186|      0|        )
  187|      0|    }
  188|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Search/Services/SearchAlamofireService.swift:
    1|       |//
    2|       |//  SearchAlamofireService.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/18.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import SwiftyJSON
   11|       |import Alamofire
   12|       |
   13|       |class SearchAlamofireService: SearchAlamofireServicing {
   14|       |    weak var repo: SearchRepositorable?
   15|       |    
   16|     12|    init(repo: SearchRepositorable) {
   17|     12|        self.repo = repo
   18|     12|    }
   19|       |    
   20|     68|    func getSearchResults(_ searchText: String) {
   21|     68|        let uiTesting = ProcessInfo.processInfo.arguments.contains("Testing")
   22|     68|        
   23|     68|        if uiTesting {
   24|     68|            
   25|     68|            if searchText == "Error" {
   26|      1|                repo?.errorBuilder("error1")
   27|      1|                return
   28|     67|            }
   29|     67|            
   30|     67|            if let path = Bundle.main.path(forResource: "\(searchText)_Result", ofType: "json") {
   31|     35|                do {
   32|     35|                    let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .alwaysMapped)
   33|     35|                    let jsonObj = try JSON(data: data)
   34|     35|                    repo?.decodeResults(json: jsonObj)
   35|     35|                } catch let error {
   36|      0|                    print("parse error: \(error.localizedDescription)")
   37|     35|                }
   38|     67|            } else {
   39|     32|                print("Invalid filename/path.")
   40|     67|            }
   41|     67|        } else {
   42|      0|            guard let googleKey = Bundle.main.object(forInfoDictionaryKey: "Google_Key") as? String else {
   43|      0|                return
   44|      0|            }
   45|      0|            let urlToSearch = "https://www.googleapis.com/books/v1/volumes?q=\(searchText)&printType=books&\(googleKey)"
   46|      0|            //Clean url to avoid errors from spaces
   47|      0|            guard let encodedUrlToSearch = urlToSearch.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
   48|      0|                return
   49|      0|            }
   50|      0|            
   51|      0|            Alamofire.request(encodedUrlToSearch).responseJSON { response in
   52|      0|                guard let data = response.data else {
   53|      0|                    self.repo?.errorBuilder("error1")
   54|      0|                    return
   55|      0|                }
   56|      0|                
   57|      0|                let json = try? JSON(data: data)
   58|      0|                self.repo?.decodeResults(json: json)
   59|      0|            }
   60|     67|        }
   61|     67|    }
   62|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Search/View/CustomView/CustomTableViewCell.swift:
    1|       |//
    2|       |//  CustomTableViewCell.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/12.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class CustomTableViewCell: UITableViewCell {
   12|       |    
   13|       |    @IBOutlet weak var bookImage: UIImageView!
   14|       |    @IBOutlet weak var bookTitleLabel: UILabel!
   15|       |    @IBOutlet weak var bookAuthorLabel: UILabel!
   16|       |    
   17|    182|    override func awakeFromNib() {
   18|    182|        super.awakeFromNib()
   19|    182|    }
   20|       |    
   21|  1.19k|    override func setSelected(_ selected: Bool, animated: Bool) {
   22|  1.19k|        super.setSelected(selected, animated: animated)
   23|  1.19k|    }
   24|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Search/View/ViewController/SearchResultsTableViewController.swift:
    1|       |//
    2|       |//  SearchResultsTableViewController.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/12.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import SwiftyJSON
   11|       |import OAuthSwift
   12|       |import SafariServices
   13|       |
   14|       |class SearchResultsTableViewController: UITableViewController {
   15|       |    
   16|       |    private var searchResults = [SearchModel]() {
   17|    235|        didSet {
   18|    235|            tableView.reloadData()
   19|    235|        }
   20|       |    }
   21|       |    
   22|     14|    lazy var model: SearchViewModelling = { return SearchViewModel(view: self, repo: SearchRepository()) }()
   23|       |    
   24|       |    private let searchController = UISearchController(searchResultsController: nil)
   25|       |    
   26|     14|    override func viewDidLoad() {
   27|     14|        super.viewDidLoad()
   28|     14|        //tableView.estimatedRowHeight = 150
   29|     14|        //tableView.rowHeight = UITableView.automaticDimension
   30|     14|        tableView.tableFooterView = UIView()
   31|     14|        setupTableViewBackgroundView()
   32|     14|        setupSearchBar()
   33|     14|    }
   34|       |    
   35|    604|    override func numberOfSections(in tableView: UITableView) -> Int {
   36|    604|        return 1
   37|    604|    }
   38|       |    
   39|    382|    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   40|    382|        //***Change***
   41|    382|        return model.countResults(searchResults)
   42|    382|    }
   43|       |    
   44|       |    //Setting background view to display no books found, that way when there are no search results,
   45|       |    //it just shows the background
   46|       |    
   47|     14|    private func setupTableViewBackgroundView() {
   48|     14|        let backgroundViewLabel = UILabel(frame: .zero)
   49|     14|        backgroundViewLabel.numberOfLines = 0
   50|     14|        backgroundViewLabel.text = " Sorry, No books found "
   51|     14|        backgroundViewLabel.textAlignment = NSTextAlignment.center
   52|     14|        backgroundViewLabel.font.withSize(20)
   53|     14|        tableView.backgroundView = backgroundViewLabel
   54|     14|    }
   55|       |    
   56|       |    //Sets up the search bar element
   57|       |    
   58|     14|    private func setupSearchBar() {
   59|     14|        searchController.searchBar.delegate = self
   60|     14|        searchController.dimsBackgroundDuringPresentation = false
   61|     14|        searchController.hidesNavigationBarDuringPresentation = false
   62|     14|        searchController.searchBar.placeholder = "Search for a Book"
   63|     14|        definesPresentationContext = true
   64|     14|        tableView.tableHeaderView = searchController.searchBar
   65|     14|    }
   66|       |    
   67|       |    //Populates each cell of the table with data from the respective search results
   68|       |    //Work on making this code neater
   69|    455|    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   70|    455|        let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath) as! CustomTableViewCell
   71|    455|        
   72|    455|        let authors = model.detailsForCell(result: searchResults[indexPath.row]).authors
   73|    455|        
   74|    455|        cell.bookTitleLabel.text = searchResults[indexPath.row].title
   75|    455|        cell.bookAuthorLabel.text = authors
   76|    455|        cell.bookImage.fetchImage(url: searchResults[indexPath.row].smallImageUrl)
   77|    455|        cell.bookImage.layer.cornerRadius = 5.0
   78|    455|        cell.bookImage.layer.masksToBounds = true
   79|    455|        return cell
   80|    455|        
   81|    455|    }
   82|       |    
   83|  1.36k|    override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
   84|  1.36k|        return 120
   85|  1.36k|    }
   86|       |    
   87|       |    //When selecting an item on the list, before moving to detail page,
   88|       |    //copy out necessary details at that point and send it to the detail page to display there
   89|       |    //**Consider just sending the entire JSON object at this point to shorten code
   90|      8|    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
   91|      8|        // try loading the "Detail" view controller and typecasting it to be DetailViewController
   92|      8|            model.detailsForPage(result: searchResults[indexPath.row])
   93|      8|    }
   94|       |    
   95|       |}
   96|       |extension SearchResultsTableViewController: SearchResultsTableViewControllable {
   97|       |    
   98|     35|    func setResults(results: [SearchModel]) {
   99|     35|        searchResults = results
  100|     35|    }
  101|       |    
  102|      8|    func moveToDetailsPage(bookModel: SearchModel) {
  103|      8|        if let vControl = storyboard?.instantiateViewController(withIdentifier: "NewDetail") as? NewDetailViewController {
  104|      8|            vControl.bookModel = bookModel
  105|      8|            navigationController?.pushViewController(vControl, animated: true)
  106|      8|        }
  107|      8|    }
  108|       |    
  109|      1|    func displayErrorPopup(_ error: String, _ title: String) {
  110|      1|        let alert = UIAlertController(title: title, message: error, preferredStyle: .alert)
  111|      1|        alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
  112|      1|        self.present(alert, animated: true, completion: nil)
  113|      1|    }
  114|       |}
  115|       |
  116|       |extension SearchResultsTableViewController: UISearchBarDelegate {
  117|       |    
  118|       |    //Called whenever text changes, checks if minimum time interval has passed, and if so, calls fetchResults
  119|    199|    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
  120|    199|        searchResults.removeAll()
  121|    199|        guard let textToSearch = searchBar.text, !textToSearch.isEmpty else {
  122|      1|            return
  123|    198|        }
  124|    198|        model.searchText(textToSearch: textToSearch)
  125|    198|    }
  126|       |
  127|       |    //Empty out search results
  128|      1|    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
  129|      1|        searchResults.removeAll()
  130|      1|    }
  131|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Search/ViewModel/SearchViewModel.swift:
    1|       |//
    2|       |//  SearchViewModel.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/28.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import OAuthSwift
   11|       |
   12|       |class SearchViewModel: SearchViewModelling {
   13|       |    
   14|       |    weak var view: SearchResultsTableViewControllable?
   15|       |    var repo: SearchRepositoring?
   16|       |    
   17|     14|    init(view: SearchResultsTableViewControllable, repo: SearchRepositoring) {
   18|     14|        self.view = view
   19|     14|        self.repo = repo
   20|     14|        repo.setViewModel(vModel: self)
   21|     14|        let uiTesting = ProcessInfo.processInfo.arguments.contains("Testing")
   22|     14|        
   23|     14|        if !uiTesting {
   24|      0|        repo.storedDetailsCheck()
   25|     14|        }
   26|     14|    }
   27|       |    
   28|       |    //To avoid the search running constantly as we type
   29|       |    var previousRun = Date()
   30|       |
   31|    382|    func countResults(_ searchResults: [SearchModel]) -> Int {
   32|    382|        return searchResults.count
   33|    382|    }
   34|       |    
   35|    198|    func searchText(textToSearch: String) {
   36|    198|        let minInterval = 0.7
   37|    198|        if Date().timeIntervalSince(previousRun) > minInterval {
   38|     68|            previousRun = Date()
   39|     68|            fetchResults(for: textToSearch)
   40|    198|        }
   41|    198|    }
   42|       |    
   43|    455|    func detailsForCell(result: SearchModel) -> SearchModel {
   44|    455|        var model = result
   45|    455|        model.authors = "By: \(result.authors)"
   46|    455|        return model
   47|    455|    }
   48|       |    
   49|      8|    func detailsForPage(result: SearchModel) {
   50|      8|        var model = result
   51|      8|        model.authors = "By: \(model.authors)"
   52|      8|        model.publishedDate = "Date Published: \(model.publishedDate)"
   53|      8|        model.isbn = "ISBN_13: \(model.isbn)"
   54|      8|        model.pageNumbers = "Pages: \(model.pageNumbers)"
   55|      8|        model.genres = "Genres: \(model.genres ?? "None Found")"
   56|      8|        view?.moveToDetailsPage(bookModel: model)
   57|      8|    }
   58|       |    
   59|     68|    func fetchResults(for text: String) {
   60|     68|        repo?.search(searchText: text)
   61|     68|    }
   62|       |    
   63|     35|    func setResults(_ model: [SearchModel]) {
   64|     35|        self.view?.setResults(results: model)
   65|     35|    }
   66|       |    
   67|      0|    func fetchView() -> SearchResultsTableViewControllable {
   68|      0|        guard let view = view else {
   69|      0|            return SearchResultsTableViewController()
   70|      0|        }
   71|      0|        return view
   72|      0|    }
   73|       |    
   74|      1|    func errorBuilder(_ error: String) {
   75|      1|        if error == "error1" {
   76|      1|            view?.displayErrorPopup("Error fetching results. Please check your network connection and try again", "Network Error")
   77|      1|        } else {
   78|      0|            view?.displayErrorPopup(error, "Authentication Error")
   79|      1|        }
   80|      1|    }
   81|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Shelf/Repository/ShelfRepository.swift:
    1|       |//
    2|       |//  ShelfRepository.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/04.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import OAuthSwift
   11|       |import SWXMLHash
   12|       |import Alamofire
   13|       |import ShelfView
   14|       |
   15|       |class ShelfRepository: ShelfRepositoring {
   16|       |    
   17|       |    var oauthswift: OAuthSwift?
   18|       |    var userId: String?
   19|       |    
   20|       |    weak var vModel: ShelfViewModelling?
   21|       |    
   22|      0|    func setViewModel(vModel: ShelfViewModelling) {
   23|      0|        self.vModel = vModel
   24|      0|    }
   25|       |    
   26|      0|    func getBookModel() {
   27|      0|        storedDetailsCheck()
   28|      0|        guard let oauthSwift = self.oauthswift as? OAuth1Swift else {
   29|      0|            vModel?.errorBuilder("error1")
   30|      0|            return
   31|      0|        }
   32|      0|        
   33|      0|        guard let userID = userId else {
   34|      0|            vModel?.errorBuilder("error1")
   35|      0|            return
   36|      0|        }
   37|      0|        guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
   38|      0|            return
   39|      0|        }
   40|      0|        _ = oauthSwift.client.request(
   41|      0|            "https://www.goodreads.com/review/list/\(userID).xml?key=\(goodreadsKey)&v=2", method: .GET,
   42|      0|            success: { response in
   43|      0|                
   44|      0|                guard let dataString = response.string else {
   45|      0|                    self.vModel?.errorBuilder("error3")
   46|      0|                    return
   47|      0|                }
   48|      0|                
   49|      0|                let xml = SWXMLHash.parse(dataString)
   50|      0|                var books: [BookModel] = []
   51|      0|                
   52|      0|                //Iterate over books that user has read
   53|      0|                for elem in xml["GoodreadsResponse"]["reviews"]["review"].all {
   54|      0|                    //Add each book to books model
   55|      0|                    books.append(BookModel(bookCoverSource: elem["book"]["image_url"].element?.text ?? "",
   56|      0|                                           bookId: elem["book"]["id"].element?.text ?? "",
   57|      0|                                           bookTitle: elem["book"]["title"].element?.text ?? "error"))
   58|      0|                }
   59|      0|
   60|      0|                self.vModel?.setModel(books: books)
   61|      0|        }, failure: { _ in
   62|      0|            self.vModel?.errorBuilder("error2")
   63|      0|        }
   64|      0|        )
   65|      0|    }
   66|       |    
   67|      0|    func storedDetailsCheck() {
   68|      0|        let preferences = UserDefaults.standard
   69|      0|        let currentOauthKey = "oauth"
   70|      0|        let idKey = "userID"
   71|      0|        
   72|      0|        if preferences.object(forKey: currentOauthKey) == nil {
   73|      0|            //Maybe add auth check here too
   74|      0|        } else {
   75|      0|            let decoded  = preferences.object(forKey: currentOauthKey) as! Data
   76|      0|            guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
   77|      0|                return
   78|      0|            }
   79|      0|            guard let goodreadsSecret = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Secret") as? String else {
   80|      0|                return
   81|      0|            }
   82|      0|            if let credential = NSKeyedUnarchiver.unarchiveObject(with: decoded) as? OAuthSwiftCredential {
   83|      0|                let oauthS = OAuth1Swift(consumerKey: goodreadsKey,
   84|      0|                                         consumerSecret: goodreadsSecret)
   85|      0|                oauthS.client.credential.oauthToken = credential.oauthToken
   86|      0|                oauthS.client.credential.oauthTokenSecret = credential.oauthTokenSecret
   87|      0|                oauthswift = oauthS
   88|      0|            }
   89|      0|        }
   90|      0|        
   91|      0|        if preferences.object(forKey: idKey) != nil {
   92|      0|            if let userID = preferences.string(forKey: idKey) {
   93|      0|                userId = userID
   94|      0|            }
   95|      0|        }
   96|      0|    }
   97|       |    
   98|      0|    func searchBook(bookId: String) {
   99|      0|        guard let goodreadsKey = Bundle.main.object(forInfoDictionaryKey: "Goodreads_Key") as? String else {
  100|      0|            return
  101|      0|        }
  102|      0|        let url = "https://www.goodreads.com/book/show/\(bookId)?key=\(goodreadsKey)"
  103|      0|        Alamofire.request(url, method: .get).response { response in
  104|      0|            
  105|      0|            guard let data = response.data else {
  106|      0|                self.vModel?.errorBuilder("error4")
  107|      0|                return
  108|      0|            }
  109|      0|            //Add another guard
  110|      0|            let xml = SWXMLHash.parse(data)
  111|      0|            
  112|      0|            //return author as an array here and parse it in the view model
  113|      0|            let detailModel = ShelfModel(title: xml["GoodreadsResponse"]["book"]["title"].element?.text ?? "",
  114|      0|                                         authors: xml["GoodreadsResponse"]["book"]["authors"]["author"][0]["name"].element?.text ?? "",
  115|      0|                                         largeImageUrl: xml["GoodreadsResponse"]["book"]["image_url"].element?.text ?? "",
  116|      0|                                         publishedDay: xml["GoodreadsResponse"]["book"]["publication_day"].element?.text ?? "01",
  117|      0|                                         publishedMonth: xml["GoodreadsResponse"]["book"]["publication_month"].element?.text ?? "01",
  118|      0|                                         publishedYear: xml["GoodreadsResponse"]["book"]["publication_year"].element?.text ?? "2000",
  119|      0|                                         reviewInfo: xml["GoodreadsResponse"]["book"]["isbn13"].element?.text ?? "",
  120|      0|                                         isbn: xml["GoodreadsResponse"]["book"]["isbn13"].element?.text ?? "",
  121|      0|                                         pageNumbers: xml["GoodreadsResponse"]["book"]["num_pages"].element?.text ?? "",
  122|      0|                                         description: xml["GoodreadsResponse"]["book"]["description"].element?.text.removingPercentEncoding ?? "",
  123|      0|                                         webLink: xml["GoodreadsResponse"]["book"]["link"].element?.text ?? "")
  124|      0|            
  125|      0|            self.vModel?.setBook(detailModel)
  126|      0|        }
  127|      0|    }
  128|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Shelf/View/PlainShelfController.swift:
    1|       |//
    2|       |//  PlainShelfController.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/02/19.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import ShelfView
   10|       |
   11|       |class PlainShelfController: UIViewController, PlainShelfViewDelegate {
   12|       |    var shelfView: PlainShelfView!
   13|       |
   14|      0|    lazy var vModel: ShelfViewModelling = { return ShelfViewModel(view: self, repo: ShelfRepository()) }()
   15|       |
   16|      0|    override func viewDidLoad() {
   17|      0|        super.viewDidLoad()
   18|      0|        //Create shelfview
   19|      0|        shelfView = PlainShelfView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height),
   20|      0|                                   bookModel: vModel.getModel(), bookSource: PlainShelfView.BOOK_SOURCE_URL)
   21|      0|        shelfView.tag = 100
   22|      0|        shelfView.delegate = self
   23|      0|        self.view.addSubview(shelfView)
   24|      0|    }
   25|       |    
   26|       |//    override func viewWillAppear(_ animated: Bool) {
   27|       |//        super.viewWillAppear(animated)
   28|       |//        if let viewWithTag = self.view.viewWithTag(100) {
   29|       |//            viewWithTag.removeFromSuperview()
   30|       |//        }
   31|       |//        shelfView = PlainShelfView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height),
   32|       |//                                   bookModel: vModel.getModel(), bookSource: PlainShelfView.BOOK_SOURCE_URL)
   33|       |//        shelfView.tag = 100
   34|       |//        self.view.addSubview(shelfView)
   35|       |//    }
   36|       |    
   37|       |    //Will Add code here to animate clicking book
   38|      0|    func onBookClicked(_ shelfView: PlainShelfView, index: Int, bookId: String, bookTitle: String) {
   39|      0|            vModel.getBook(bookId)
   40|      0|    }
   41|       |
   42|       |    //Handles removing current subview and
   43|      0|    override func didRotate(from fromInterfaceOrientation: UIInterfaceOrientation) {
   44|      0|        if let viewWithTag = self.view.viewWithTag(100) {
   45|      0|            viewWithTag.removeFromSuperview()
   46|      0|        }
   47|      0|        shelfView = PlainShelfView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height),
   48|      0|                                   bookModel: vModel.getModel(), bookSource: PlainShelfView.BOOK_SOURCE_URL)
   49|      0|        shelfView.tag = 100
   50|      0|        self.view.addSubview(shelfView)
   51|      0|    }
   52|       |}
   53|       |
   54|       |extension PlainShelfController: PlainShelfControllable {
   55|      0|    func reloadData(_ bookModel: [BookModel]) {
   56|      0|        self.shelfView.reloadBooks(bookModel: bookModel)
   57|      0|    }
   58|       |    
   59|      0|    func moveToDetailsPage(_ bookInfo: SearchModel) {
   60|      0|        if let vControl = self.storyboard?.instantiateViewController(withIdentifier: "NewDetail") as? NewDetailViewController {
   61|      0|                vControl.bookModel = bookInfo
   62|      0|                navigationController?.pushViewController(vControl, animated: true)
   63|      0|        }
   64|      0|    }
   65|       |    
   66|      0|    func displayErrorPopup(_ error: String, _ title: String) {
   67|      0|        let alert = UIAlertController(title: title, message: error, preferredStyle: .alert)
   68|      0|        alert.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
   69|      0|        self.present(alert, animated: true, completion: nil)
   70|      0|    }
   71|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/BookWyrm/Shelf/ViewModel/ShelfViewModel.swift:
    1|       |//
    2|       |//  ShelfViewModel.swift
    3|       |//  BookWyrm
    4|       |//
    5|       |//  Created by Zaheer Moola on 2019/03/04.
    6|       |//  Copyright © 2019 DVT. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import ShelfView
   11|       |
   12|       |class ShelfViewModel: ShelfViewModelling {
   13|       |    
   14|       |    var books: [BookModel] = []
   15|       |    var repo: ShelfRepositoring?
   16|       |    
   17|       |    weak var view: PlainShelfControllable?
   18|       |    
   19|      0|    init(view: PlainShelfControllable, repo: ShelfRepositoring) {
   20|      0|        self.view = view
   21|      0|        self.repo = repo
   22|      0|        repo.setViewModel(vModel: self)
   23|      0|    }
   24|       |    
   25|      0|    func getModel() -> [BookModel] {
   26|      0|        if books.isEmpty {
   27|      0|            repo?.getBookModel()
   28|      0|        }
   29|      0|        return books
   30|      0|    }
   31|       |    
   32|      0|    func setModel(books: [BookModel]) {
   33|      0|        self.books = books
   34|      0|        self.view?.reloadData(self.books)
   35|      0|    }
   36|       |    
   37|      0|    func getBook(_ bookId: String) {
   38|      0|        repo?.searchBook(bookId: bookId)
   39|      0|    }
   40|       |    
   41|      0|    func setBook(_ bookInfo: ShelfModel) {
   42|      0|        
   43|      0|        let modifiedModel = SearchModel(title: bookInfo.title,
   44|      0|                                        authors: "By: \(bookInfo.authors)",
   45|      0|            smallImageUrl: "",
   46|      0|            largeImageUrl: bookInfo.largeImageUrl,
   47|      0|            publishedDate: "Date Published: \(bookInfo.publishedDay)-\(bookInfo.publishedMonth)-\(bookInfo.publishedYear)",
   48|      0|            reviewInfo: bookInfo.reviewInfo,
   49|      0|            isbn: "ISBN_13: \(bookInfo.isbn)",
   50|      0|            pageNumbers: "Pages: \(bookInfo.pageNumbers)",
   51|      0|            genres: nil,
   52|      0|            description: bookInfo.description.replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression, range: nil),
   53|      0|            webLink: bookInfo.webLink)
   54|      0|        
   55|      0|        view?.moveToDetailsPage(modifiedModel)
   56|      0|    }
   57|       |    
   58|       |    //Use enums
   59|      0|    func errorBuilder(_ error: String) {
   60|      0|        if error == "error1" {
   61|      0|            view?.displayErrorPopup("Error fetching token credentials. Please try restarting the app", "Credential Error")
   62|      0|        } else if error == "error2" {
   63|      0|            view?.displayErrorPopup("Error fetching book list. Please check your network connection and try again", "Network Error")
   64|      0|        } else if error == "error3"{
   65|      0|            view?.displayErrorPopup("No books found. Possible Server Error", "Empty Results")
   66|      0|        } else if error == "error4" {
   67|      0|             view?.displayErrorPopup("No book found for book in shelf. Check the version that you may have bookmarked", "No book found")
   68|      0|        }
   69|      0|    }
   70|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRAnalyticsConfiguration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FIRAnalyticsConfiguration.h"
   16|       |
   17|       |#import "Private/FIRAnalyticsConfiguration+Internal.h"
   18|       |
   19|       |#pragma clang diagnostic push
   20|       |#pragma clang diagnostic ignored "-Wdeprecated-implementations"
   21|       |@implementation FIRAnalyticsConfiguration
   22|       |#pragma clang diagnostic pop
   23|       |
   24|     14|+ (FIRAnalyticsConfiguration *)sharedInstance {
   25|     14|  static FIRAnalyticsConfiguration *sharedInstance = nil;
   26|     14|  static dispatch_once_t onceToken;
   27|     14|  dispatch_once(&onceToken, ^{
   28|     14|    sharedInstance = [[FIRAnalyticsConfiguration alloc] init];
   29|     14|  });
   30|     14|  return sharedInstance;
   31|     14|}
   32|       |
   33|      0|- (void)postNotificationName:(NSString *)name value:(id)value {
   34|      0|  if (!name.length || !value) {
   35|      0|    return;
   36|      0|  }
   37|      0|  [[NSNotificationCenter defaultCenter] postNotificationName:name
   38|      0|                                                      object:self
   39|      0|                                                    userInfo:@{name : value}];
   40|      0|}
   41|       |
   42|      0|- (void)setMinimumSessionInterval:(NSTimeInterval)minimumSessionInterval {
   43|      0|  [self postNotificationName:kFIRAnalyticsConfigurationSetMinimumSessionIntervalNotification
   44|      0|                       value:@(minimumSessionInterval)];
   45|      0|}
   46|       |
   47|      0|- (void)setSessionTimeoutInterval:(NSTimeInterval)sessionTimeoutInterval {
   48|      0|  [self postNotificationName:kFIRAnalyticsConfigurationSetSessionTimeoutIntervalNotification
   49|      0|                       value:@(sessionTimeoutInterval)];
   50|      0|}
   51|       |
   52|      0|- (void)setAnalyticsCollectionEnabled:(BOOL)analyticsCollectionEnabled {
   53|      0|  [self setAnalyticsCollectionEnabled:analyticsCollectionEnabled persistSetting:YES];
   54|      0|}
   55|       |
   56|       |- (void)setAnalyticsCollectionEnabled:(BOOL)analyticsCollectionEnabled
   57|      0|                       persistSetting:(BOOL)shouldPersist {
   58|      0|  // Persist the measurementEnabledState. Use FIRAnalyticsEnabledState values instead of YES/NO.
   59|      0|  FIRAnalyticsEnabledState analyticsEnabledState =
   60|      0|      analyticsCollectionEnabled ? kFIRAnalyticsEnabledStateSetYes : kFIRAnalyticsEnabledStateSetNo;
   61|      0|  if (shouldPersist) {
   62|      0|    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
   63|      0|    [userDefaults setObject:@(analyticsEnabledState)
   64|      0|                     forKey:kFIRAPersistedConfigMeasurementEnabledStateKey];
   65|      0|    [userDefaults synchronize];
   66|      0|  }
   67|      0|
   68|      0|  [self postNotificationName:kFIRAnalyticsConfigurationSetEnabledNotification
   69|      0|                       value:@(analyticsCollectionEnabled)];
   70|      0|}
   71|       |
   72|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRApp.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include <sys/utsname.h>
   16|       |
   17|       |#import "FIRApp.h"
   18|       |#import "FIRConfiguration.h"
   19|       |#import "Private/FIRAnalyticsConfiguration+Internal.h"
   20|       |#import "Private/FIRAppInternal.h"
   21|       |#import "Private/FIRBundleUtil.h"
   22|       |#import "Private/FIRComponentContainerInternal.h"
   23|       |#import "Private/FIRLibrary.h"
   24|       |#import "Private/FIRLogger.h"
   25|       |#import "Private/FIROptionsInternal.h"
   26|       |
   27|       |NSString *const kFIRServiceAdMob = @"AdMob";
   28|       |NSString *const kFIRServiceAuth = @"Auth";
   29|       |NSString *const kFIRServiceAuthUI = @"AuthUI";
   30|       |NSString *const kFIRServiceCrash = @"Crash";
   31|       |NSString *const kFIRServiceDatabase = @"Database";
   32|       |NSString *const kFIRServiceDynamicLinks = @"DynamicLinks";
   33|       |NSString *const kFIRServiceFirestore = @"Firestore";
   34|       |NSString *const kFIRServiceFunctions = @"Functions";
   35|       |NSString *const kFIRServiceInstanceID = @"InstanceID";
   36|       |NSString *const kFIRServiceInvites = @"Invites";
   37|       |NSString *const kFIRServiceMessaging = @"Messaging";
   38|       |NSString *const kFIRServiceMeasurement = @"Measurement";
   39|       |NSString *const kFIRServicePerformance = @"Performance";
   40|       |NSString *const kFIRServiceRemoteConfig = @"RemoteConfig";
   41|       |NSString *const kFIRServiceStorage = @"Storage";
   42|       |NSString *const kGGLServiceAnalytics = @"Analytics";
   43|       |NSString *const kGGLServiceSignIn = @"SignIn";
   44|       |
   45|       |NSString *const kFIRDefaultAppName = @"__FIRAPP_DEFAULT";
   46|       |NSString *const kFIRAppReadyToConfigureSDKNotification = @"FIRAppReadyToConfigureSDKNotification";
   47|       |NSString *const kFIRAppDeleteNotification = @"FIRAppDeleteNotification";
   48|       |NSString *const kFIRAppIsDefaultAppKey = @"FIRAppIsDefaultAppKey";
   49|       |NSString *const kFIRAppNameKey = @"FIRAppNameKey";
   50|       |NSString *const kFIRGoogleAppIDKey = @"FIRGoogleAppIDKey";
   51|       |
   52|       |NSString *const kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat =
   53|       |    @"/google/firebase/global_data_collection_enabled:%@";
   54|       |NSString *const kFIRGlobalAppDataCollectionEnabledPlistKey =
   55|       |    @"FirebaseDataCollectionDefaultEnabled";
   56|       |
   57|       |NSString *const kFIRAppDiagnosticsNotification = @"FIRAppDiagnosticsNotification";
   58|       |
   59|       |NSString *const kFIRAppDiagnosticsConfigurationTypeKey = @"ConfigType";
   60|       |NSString *const kFIRAppDiagnosticsErrorKey = @"Error";
   61|       |NSString *const kFIRAppDiagnosticsFIRAppKey = @"FIRApp";
   62|       |NSString *const kFIRAppDiagnosticsSDKNameKey = @"SDKName";
   63|       |NSString *const kFIRAppDiagnosticsSDKVersionKey = @"SDKVersion";
   64|       |
   65|       |// Auth internal notification notification and key.
   66|       |NSString *const FIRAuthStateDidChangeInternalNotification =
   67|       |    @"FIRAuthStateDidChangeInternalNotification";
   68|       |NSString *const FIRAuthStateDidChangeInternalNotificationAppKey =
   69|       |    @"FIRAuthStateDidChangeInternalNotificationAppKey";
   70|       |NSString *const FIRAuthStateDidChangeInternalNotificationTokenKey =
   71|       |    @"FIRAuthStateDidChangeInternalNotificationTokenKey";
   72|       |NSString *const FIRAuthStateDidChangeInternalNotificationUIDKey =
   73|       |    @"FIRAuthStateDidChangeInternalNotificationUIDKey";
   74|       |
   75|       |/**
   76|       | * The URL to download plist files.
   77|       | */
   78|       |static NSString *const kPlistURL = @"https://console.firebase.google.com/";
   79|       |
   80|       |/**
   81|       | * An array of all classes that registered as `FIRCoreConfigurable` in order to receive lifecycle
   82|       | * events from Core.
   83|       | */
   84|       |static NSMutableArray<Class<FIRLibrary>> *sRegisteredAsConfigurable;
   85|       |
   86|       |@interface FIRApp ()
   87|       |
   88|       |#ifdef DEBUG
   89|       |@property(nonatomic) BOOL alreadyOutputDataCollectionFlag;
   90|       |#endif  // DEBUG
   91|       |
   92|       |@end
   93|       |
   94|       |@implementation FIRApp
   95|       |
   96|       |// This is necessary since our custom getter prevents `_options` from being created.
   97|       |@synthesize options = _options;
   98|       |
   99|       |static NSMutableDictionary *sAllApps;
  100|       |static FIRApp *sDefaultApp;
  101|       |static NSMutableDictionary *sLibraryVersions;
  102|       |
  103|     14|+ (void)configure {
  104|     14|  FIROptions *options = [FIROptions defaultOptions];
  105|     14|  if (!options) {
  106|      0|    // Read the Info.plist to see if the flag is set. At this point we can't check any user defaults
  107|      0|    // since the app isn't configured at all, so only rely on the Info.plist value.
  108|      0|    NSNumber *collectionEnabledPlistValue = [[self class] readDataCollectionSwitchFromPlist];
  109|      0|    if (collectionEnabledPlistValue == nil || [collectionEnabledPlistValue boolValue]) {
  110|      0|      [[NSNotificationCenter defaultCenter]
  111|      0|          postNotificationName:kFIRAppDiagnosticsNotification
  112|      0|                        object:nil
  113|      0|                      userInfo:@{
  114|      0|                        kFIRAppDiagnosticsConfigurationTypeKey : @(FIRConfigTypeCore),
  115|      0|                        kFIRAppDiagnosticsErrorKey : [FIRApp errorForMissingOptions]
  116|      0|                      }];
  117|      0|    }
  118|      0|
  119|      0|    [NSException raise:kFirebaseCoreErrorDomain
  120|      0|                format:@"`[FIRApp configure];` (`FirebaseApp.configure()` in Swift) could not find "
  121|      0|                       @"a valid GoogleService-Info.plist in your project. Please download one "
  122|      0|                       @"from %@.",
  123|      0|                       kPlistURL];
  124|      0|  }
  125|     14|  [FIRApp configureWithOptions:options];
  126|       |#if TARGET_OS_OSX || TARGET_OS_TV
  127|       |  FIRLogNotice(kFIRLoggerCore, @"I-COR000028",
  128|       |               @"tvOS and macOS SDK support is not part of the official Firebase product. "
  129|       |               @"Instead they are community supported. Details at "
  130|       |               @"https://github.com/firebase/firebase-ios-sdk/blob/master/README.md.");
  131|       |#endif
  132|       |}
  133|       |
  134|     14|+ (void)configureWithOptions:(FIROptions *)options {
  135|     14|  if (!options) {
  136|      0|    [NSException raise:kFirebaseCoreErrorDomain
  137|      0|                format:@"Options is nil. Please pass a valid options."];
  138|      0|  }
  139|     14|  [FIRApp configureWithName:kFIRDefaultAppName options:options];
  140|     14|}
  141|       |
  142|     14|+ (void)configureWithName:(NSString *)name options:(FIROptions *)options {
  143|     14|  if (!name || !options) {
  144|      0|    [NSException raise:kFirebaseCoreErrorDomain format:@"Neither name nor options can be nil."];
  145|      0|  }
  146|     14|  if (name.length == 0) {
  147|      0|    [NSException raise:kFirebaseCoreErrorDomain format:@"Name cannot be empty."];
  148|      0|  }
  149|     14|
  150|     14|  if ([name isEqualToString:kFIRDefaultAppName]) {
  151|     14|    if (sDefaultApp) {
  152|      0|      [NSException raise:kFirebaseCoreErrorDomain
  153|      0|                  format:@"Default app has already been configured."];
  154|      0|    }
  155|     14|
  156|     14|    FIRLogDebug(kFIRLoggerCore, @"I-COR000001", @"Configuring the default app.");
  157|     14|  } else {
  158|      0|    // Validate the app name and ensure it hasn't been configured already.
  159|      0|    for (NSUInteger charIndex = 0; charIndex < name.length; charIndex++) {
  160|      0|      char character = [name characterAtIndex:charIndex];
  161|      0|      if (!((character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z') ||
  162|      0|            (character >= '0' && character <= '9') || character == '_' || character == '-')) {
  163|      0|        [NSException raise:kFirebaseCoreErrorDomain
  164|      0|                    format:@"App name can only contain alphanumeric (A-Z,a-z,0-9), "
  165|      0|                           @"hyphen (-), and underscore (_) characters"];
  166|      0|      }
  167|      0|    }
  168|      0|
  169|      0|    @synchronized(self) {
  170|      0|      if (sAllApps && sAllApps[name]) {
  171|      0|        [NSException raise:kFirebaseCoreErrorDomain
  172|      0|                    format:@"App named %@ has already been configured.", name];
  173|      0|      }
  174|      0|    }
  175|      0|
  176|      0|    FIRLogDebug(kFIRLoggerCore, @"I-COR000002", @"Configuring app named %@", name);
  177|      0|  }
  178|     14|
  179|     14|  @synchronized(self) {
  180|     14|    FIRApp *app = [[FIRApp alloc] initInstanceWithName:name options:options];
  181|     14|    if (app.isDefaultApp) {
  182|     14|      sDefaultApp = app;
  183|     14|    }
  184|     14|
  185|     14|    [FIRApp addAppToAppDictionary:app];
  186|     14|    [FIRApp sendNotificationsToSDKs:app];
  187|     14|  }
  188|     14|}
  189|       |
  190|    119|+ (FIRApp *)defaultApp {
  191|    119|  if (sDefaultApp) {
  192|    119|    return sDefaultApp;
  193|    119|  }
  194|      0|  FIRLogError(kFIRLoggerCore, @"I-COR000003",
  195|      0|              @"The default Firebase app has not yet been "
  196|      0|              @"configured. Add `[FIRApp configure];` (`FirebaseApp.configure()` in Swift) to your "
  197|      0|              @"application initialization. Read more: https://goo.gl/ctyzm8.");
  198|      0|  return nil;
  199|      0|}
  200|       |
  201|      0|+ (FIRApp *)appNamed:(NSString *)name {
  202|      0|  @synchronized(self) {
  203|      0|    if (sAllApps) {
  204|      0|      FIRApp *app = sAllApps[name];
  205|      0|      if (app) {
  206|      0|        return app;
  207|      0|      }
  208|      0|    }
  209|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000004", @"App with name %@ does not exist.", name);
  210|      0|    return nil;
  211|      0|  }
  212|      0|}
  213|       |
  214|     14|+ (NSDictionary *)allApps {
  215|     14|  @synchronized(self) {
  216|     14|    if (!sAllApps) {
  217|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000005", @"No app has been configured yet.");
  218|      0|    }
  219|     14|    return [sAllApps copy];
  220|     14|  }
  221|     14|}
  222|       |
  223|       |// Public only for tests
  224|      0|+ (void)resetApps {
  225|      0|  @synchronized(self) {
  226|      0|    sDefaultApp = nil;
  227|      0|    [sAllApps removeAllObjects];
  228|      0|    sAllApps = nil;
  229|      0|    [sLibraryVersions removeAllObjects];
  230|      0|    sLibraryVersions = nil;
  231|      0|  }
  232|      0|}
  233|       |
  234|      0|- (void)deleteApp:(FIRAppVoidBoolCallback)completion {
  235|      0|  @synchronized([self class]) {
  236|      0|    if (sAllApps && sAllApps[self.name]) {
  237|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000006", @"Deleting app named %@", self.name);
  238|      0|
  239|      0|      // Remove all cached instances from the container before deleting the app.
  240|      0|      [self.container removeAllCachedInstances];
  241|      0|
  242|      0|      [sAllApps removeObjectForKey:self.name];
  243|      0|      [self clearDataCollectionSwitchFromUserDefaults];
  244|      0|      if ([self.name isEqualToString:kFIRDefaultAppName]) {
  245|      0|        sDefaultApp = nil;
  246|      0|      }
  247|      0|      NSDictionary *appInfoDict = @{kFIRAppNameKey : self.name};
  248|      0|      [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppDeleteNotification
  249|      0|                                                          object:[self class]
  250|      0|                                                        userInfo:appInfoDict];
  251|      0|      completion(YES);
  252|      0|    } else {
  253|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000007", @"App does not exist.");
  254|      0|      completion(NO);
  255|      0|    }
  256|      0|  }
  257|      0|}
  258|       |
  259|     14|+ (void)addAppToAppDictionary:(FIRApp *)app {
  260|     14|  if (!sAllApps) {
  261|     14|    sAllApps = [NSMutableDictionary dictionary];
  262|     14|  }
  263|     14|  if ([app configureCore]) {
  264|     14|    sAllApps[app.name] = app;
  265|     14|  } else {
  266|      0|    [NSException raise:kFirebaseCoreErrorDomain
  267|      0|                format:@"Configuration fails. It may be caused by an invalid GOOGLE_APP_ID in "
  268|      0|                       @"GoogleService-Info.plist or set in the customized options."];
  269|      0|  }
  270|     14|}
  271|       |
  272|     14|- (instancetype)initInstanceWithName:(NSString *)name options:(FIROptions *)options {
  273|     14|  self = [super init];
  274|     14|  if (self) {
  275|     14|    _name = [name copy];
  276|     14|    _options = [options copy];
  277|     14|    _options.editingLocked = YES;
  278|     14|    _isDefaultApp = [name isEqualToString:kFIRDefaultAppName];
  279|     14|    _container = [[FIRComponentContainer alloc] initWithApp:self];
  280|     14|  }
  281|     14|  return self;
  282|     14|}
  283|       |
  284|     14|- (BOOL)configureCore {
  285|     14|  [self checkExpectedBundleID];
  286|     14|  if (![self isAppIDValid]) {
  287|      0|    if (_options.usingOptionsFromDefaultPlist && [self isDataCollectionDefaultEnabled]) {
  288|      0|      [[NSNotificationCenter defaultCenter]
  289|      0|          postNotificationName:kFIRAppDiagnosticsNotification
  290|      0|                        object:nil
  291|      0|                      userInfo:@{
  292|      0|                        kFIRAppDiagnosticsConfigurationTypeKey : @(FIRConfigTypeCore),
  293|      0|                        kFIRAppDiagnosticsErrorKey : [FIRApp errorForInvalidAppID],
  294|      0|                      }];
  295|      0|    }
  296|      0|    return NO;
  297|      0|  }
  298|     14|
  299|     14|  if ([self isDataCollectionDefaultEnabled]) {
  300|     14|    [[NSNotificationCenter defaultCenter]
  301|     14|        postNotificationName:kFIRAppDiagnosticsNotification
  302|     14|                      object:nil
  303|     14|                    userInfo:@{
  304|     14|                      kFIRAppDiagnosticsConfigurationTypeKey : @(FIRConfigTypeCore),
  305|     14|                      kFIRAppDiagnosticsFIRAppKey : self
  306|     14|                    }];
  307|     14|  }
  308|     14|
  309|     14|#if TARGET_OS_IOS
  310|     14|  // Initialize the Analytics once there is a valid options under default app. Analytics should
  311|     14|  // always initialize first by itself before the other SDKs.
  312|     14|  if ([self.name isEqualToString:kFIRDefaultAppName]) {
  313|     14|    Class firAnalyticsClass = NSClassFromString(@"FIRAnalytics");
  314|     14|    if (!firAnalyticsClass) {
  315|      0|      FIRLogWarning(kFIRLoggerCore, @"I-COR000022",
  316|      0|                    @"Firebase Analytics is not available. To add it, include Firebase/Core in the "
  317|      0|                    @"Podfile or add FirebaseAnalytics.framework to the Link Build Phase");
  318|     14|    } else {
  319|     14|#pragma clang diagnostic push
  320|     14|#pragma clang diagnostic ignored "-Wundeclared-selector"
  321|     14|      SEL startWithConfigurationSelector = @selector(startWithConfiguration:options:);
  322|     14|#pragma clang diagnostic pop
  323|     14|      if ([firAnalyticsClass respondsToSelector:startWithConfigurationSelector]) {
  324|     14|#pragma clang diagnostic push
  325|     14|#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
  326|     14|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  327|     14|        [firAnalyticsClass performSelector:startWithConfigurationSelector
  328|     14|                                withObject:[FIRConfiguration sharedInstance].analyticsConfiguration
  329|     14|                                withObject:_options];
  330|     14|#pragma clang diagnostic pop
  331|     14|      }
  332|     14|    }
  333|     14|  }
  334|     14|#endif
  335|     14|
  336|     14|  return YES;
  337|     14|}
  338|       |
  339|    140|- (FIROptions *)options {
  340|    140|  return [_options copy];
  341|    140|}
  342|       |
  343|      0|- (void)setDataCollectionDefaultEnabled:(BOOL)dataCollectionDefaultEnabled {
  344|      0|#ifdef DEBUG
  345|      0|  FIRLogDebug(kFIRLoggerCore, @"I-COR000034", @"Explicitly %@ data collection flag.",
  346|      0|              dataCollectionDefaultEnabled ? @"enabled" : @"disabled");
  347|      0|  self.alreadyOutputDataCollectionFlag = YES;
  348|      0|#endif  // DEBUG
  349|      0|
  350|      0|  NSString *key =
  351|      0|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, self.name];
  352|      0|  [[NSUserDefaults standardUserDefaults] setBool:dataCollectionDefaultEnabled forKey:key];
  353|      0|
  354|      0|  // Core also controls the FirebaseAnalytics flag, so check if the Analytics flags are set
  355|      0|  // within FIROptions and change the Analytics value if necessary. Analytics only works with the
  356|      0|  // default app, so return if this isn't the default app.
  357|      0|  if (!self.isDefaultApp) {
  358|      0|    return;
  359|      0|  }
  360|      0|
  361|      0|  // Check if the Analytics flag is explicitly set. If so, no further actions are necessary.
  362|      0|  if ([self.options isAnalyticsCollectionExpicitlySet]) {
  363|      0|    return;
  364|      0|  }
  365|      0|
  366|      0|  // The Analytics flag has not been explicitly set, so update with the value being set.
  367|      0|#pragma clang diagnostic push
  368|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  369|      0|  [[FIRAnalyticsConfiguration sharedInstance]
  370|      0|      setAnalyticsCollectionEnabled:dataCollectionDefaultEnabled
  371|      0|                     persistSetting:NO];
  372|      0|#pragma clang diagnostic pop
  373|      0|}
  374|       |
  375|     42|- (BOOL)isDataCollectionDefaultEnabled {
  376|     42|  // Check if it's been manually set before in code, and use that as the higher priority value.
  377|     42|  NSNumber *defaultsObject = [[self class] readDataCollectionSwitchFromUserDefaultsForApp:self];
  378|     42|  if (defaultsObject != nil) {
  379|      0|#ifdef DEBUG
  380|      0|    if (!self.alreadyOutputDataCollectionFlag) {
  381|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000031", @"Data Collection flag is %@ in user defaults.",
  382|      0|                  [defaultsObject boolValue] ? @"enabled" : @"disabled");
  383|      0|      self.alreadyOutputDataCollectionFlag = YES;
  384|      0|    }
  385|      0|#endif  // DEBUG
  386|      0|    return [defaultsObject boolValue];
  387|      0|  }
  388|     42|
  389|     42|  // Read the Info.plist to see if the flag is set. If it's not set, it should default to `YES`.
  390|     42|  // As per the implementation of `readDataCollectionSwitchFromPlist`, it's a cached value and has
  391|     42|  // no performance impact calling multiple times.
  392|     42|  NSNumber *collectionEnabledPlistValue = [[self class] readDataCollectionSwitchFromPlist];
  393|     42|  if (collectionEnabledPlistValue != nil) {
  394|      0|#ifdef DEBUG
  395|      0|    if (!self.alreadyOutputDataCollectionFlag) {
  396|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000032", @"Data Collection flag is %@ in plist.",
  397|      0|                  [collectionEnabledPlistValue boolValue] ? @"enabled" : @"disabled");
  398|      0|      self.alreadyOutputDataCollectionFlag = YES;
  399|      0|    }
  400|      0|#endif  // DEBUG
  401|      0|    return [collectionEnabledPlistValue boolValue];
  402|      0|  }
  403|     42|
  404|     42|#ifdef DEBUG
  405|     42|  if (!self.alreadyOutputDataCollectionFlag) {
  406|     14|    FIRLogDebug(kFIRLoggerCore, @"I-COR000033", @"Data Collection flag is not set.");
  407|     14|    self.alreadyOutputDataCollectionFlag = YES;
  408|     14|  }
  409|     42|#endif  // DEBUG
  410|     42|  return YES;
  411|     42|}
  412|       |
  413|       |#pragma mark - private
  414|       |
  415|     14|+ (void)sendNotificationsToSDKs:(FIRApp *)app {
  416|     14|  // TODO: Remove this notification once all SDKs are registered with `FIRCoreConfigurable`.
  417|     14|  NSNumber *isDefaultApp = [NSNumber numberWithBool:app.isDefaultApp];
  418|     14|  NSDictionary *appInfoDict = @{
  419|     14|    kFIRAppNameKey : app.name,
  420|     14|    kFIRAppIsDefaultAppKey : isDefaultApp,
  421|     14|    kFIRGoogleAppIDKey : app.options.googleAppID
  422|     14|  };
  423|     14|  [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppReadyToConfigureSDKNotification
  424|     14|                                                      object:self
  425|     14|                                                    userInfo:appInfoDict];
  426|     14|
  427|     14|  // This is the new way of sending information to SDKs.
  428|     14|  // TODO: Do we want this on a background thread, maybe?
  429|     14|  @synchronized(self) {
  430|     14|    for (Class<FIRLibrary> library in sRegisteredAsConfigurable) {
  431|     14|      [library configureWithApp:app];
  432|     14|    }
  433|     14|  }
  434|     14|}
  435|       |
  436|      0|+ (NSError *)errorForMissingOptions {
  437|      0|  NSDictionary *errorDict = @{
  438|      0|    NSLocalizedDescriptionKey :
  439|      0|        @"Unable to parse GoogleService-Info.plist in order to configure services.",
  440|      0|    NSLocalizedRecoverySuggestionErrorKey :
  441|      0|        @"Check formatting and location of GoogleService-Info.plist."
  442|      0|  };
  443|      0|  return [NSError errorWithDomain:kFirebaseCoreErrorDomain
  444|      0|                             code:FIRErrorCodeInvalidPlistFile
  445|      0|                         userInfo:errorDict];
  446|      0|}
  447|       |
  448|       |+ (NSError *)errorForSubspecConfigurationFailureWithDomain:(NSString *)domain
  449|       |                                                 errorCode:(FIRErrorCode)code
  450|       |                                                   service:(NSString *)service
  451|      0|                                                    reason:(NSString *)reason {
  452|      0|  NSString *description =
  453|      0|      [NSString stringWithFormat:@"Configuration failed for service %@.", service];
  454|      0|  NSDictionary *errorDict =
  455|      0|      @{NSLocalizedDescriptionKey : description, NSLocalizedFailureReasonErrorKey : reason};
  456|      0|  return [NSError errorWithDomain:domain code:code userInfo:errorDict];
  457|      0|}
  458|       |
  459|      0|+ (NSError *)errorForInvalidAppID {
  460|      0|  NSDictionary *errorDict = @{
  461|      0|    NSLocalizedDescriptionKey : @"Unable to validate Google App ID",
  462|      0|    NSLocalizedRecoverySuggestionErrorKey :
  463|      0|        @"Check formatting and location of GoogleService-Info.plist or GoogleAppID set in the "
  464|      0|        @"customized options."
  465|      0|  };
  466|      0|  return [NSError errorWithDomain:kFirebaseCoreErrorDomain
  467|      0|                             code:FIRErrorCodeInvalidAppID
  468|      0|                         userInfo:errorDict];
  469|      0|}
  470|       |
  471|     28|+ (BOOL)isDefaultAppConfigured {
  472|     28|  return (sDefaultApp != nil);
  473|     28|}
  474|       |
  475|     70|+ (void)registerLibrary:(nonnull NSString *)name withVersion:(nonnull NSString *)version {
  476|     70|  // Create the set of characters which aren't allowed, only if this feature is used.
  477|     70|  NSMutableCharacterSet *allowedSet = [NSMutableCharacterSet alphanumericCharacterSet];
  478|     70|  [allowedSet addCharactersInString:@"-_."];
  479|     70|  NSCharacterSet *disallowedSet = [allowedSet invertedSet];
  480|     70|  // Make sure the library name and version strings do not contain unexpected characters, and
  481|     70|  // add the name/version pair to the dictionary.
  482|     70|  if ([name rangeOfCharacterFromSet:disallowedSet].location == NSNotFound &&
  483|     70|      [version rangeOfCharacterFromSet:disallowedSet].location == NSNotFound) {
  484|     70|    @synchronized(self) {
  485|     70|      if (!sLibraryVersions) {
  486|     14|        sLibraryVersions = [[NSMutableDictionary alloc] init];
  487|     14|      }
  488|     70|      sLibraryVersions[name] = version;
  489|     70|    }
  490|     70|  } else {
  491|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000027",
  492|      0|                @"The library name (%@) or version number (%@) contain invalid characters. "
  493|      0|                @"Only alphanumeric, dash, underscore and period characters are allowed.",
  494|      0|                name, version);
  495|      0|  }
  496|     70|}
  497|       |
  498|       |+ (void)registerInternalLibrary:(nonnull Class<FIRLibrary>)library
  499|       |                       withName:(nonnull NSString *)name
  500|     28|                    withVersion:(nonnull NSString *)version {
  501|     28|  // This is called at +load time, keep the work to a minimum.
  502|     28|
  503|     28|  // Ensure the class given conforms to the proper protocol.
  504|     28|  if (![(Class)library conformsToProtocol:@protocol(FIRLibrary)] ||
  505|     28|      ![(Class)library respondsToSelector:@selector(componentsToRegister)]) {
  506|      0|    [NSException raise:NSInvalidArgumentException
  507|      0|                format:@"Class %@ attempted to register components, but it does not conform to "
  508|      0|                       @"`FIRLibrary or provide a `componentsToRegister:` method.",
  509|      0|                       library];
  510|      0|  }
  511|     28|
  512|     28|  [FIRComponentContainer registerAsComponentRegistrant:library];
  513|     28|  if ([(Class)library respondsToSelector:@selector(configureWithApp:)]) {
  514|     14|    static dispatch_once_t onceToken;
  515|     14|    dispatch_once(&onceToken, ^{
  516|     14|      sRegisteredAsConfigurable = [[NSMutableArray alloc] init];
  517|     14|    });
  518|     14|    @synchronized(self) {
  519|     14|      [sRegisteredAsConfigurable addObject:library];
  520|     14|    }
  521|     14|  }
  522|     28|  [self registerLibrary:name withVersion:version];
  523|     28|}
  524|       |
  525|     28|+ (NSString *)firebaseUserAgent {
  526|     28|  @synchronized(self) {
  527|     28|    NSMutableArray<NSString *> *libraries =
  528|     28|        [[NSMutableArray<NSString *> alloc] initWithCapacity:sLibraryVersions.count];
  529|    140|    for (NSString *libraryName in sLibraryVersions) {
  530|    140|      [libraries addObject:[NSString stringWithFormat:@"%@/%@", libraryName,
  531|    140|                                                      sLibraryVersions[libraryName]]];
  532|    140|    }
  533|     28|    [libraries sortUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
  534|     28|    return [libraries componentsJoinedByString:@" "];
  535|     28|  }
  536|     28|}
  537|       |
  538|     14|- (void)checkExpectedBundleID {
  539|     14|  NSArray *bundles = [FIRBundleUtil relevantBundles];
  540|     14|  NSString *expectedBundleID = [self expectedBundleID];
  541|     14|  // The checking is only done when the bundle ID is provided in the serviceInfo dictionary for
  542|     14|  // backward compatibility.
  543|     14|  if (expectedBundleID != nil && ![FIRBundleUtil hasBundleIdentifierPrefix:expectedBundleID
  544|     14|                                                                 inBundles:bundles]) {
  545|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000008",
  546|      0|                @"The project's Bundle ID is inconsistent with "
  547|      0|                @"either the Bundle ID in '%@.%@', or the Bundle ID in the options if you are "
  548|      0|                @"using a customized options. To ensure that everything can be configured "
  549|      0|                @"correctly, you may need to make the Bundle IDs consistent. To continue with this "
  550|      0|                @"plist file, you may change your app's bundle identifier to '%@'. Or you can "
  551|      0|                @"download a new configuration file that matches your bundle identifier from %@ "
  552|      0|                @"and replace the current one.",
  553|      0|                kServiceInfoFileName, kServiceInfoFileType, expectedBundleID, kPlistURL);
  554|      0|  }
  555|     14|}
  556|       |
  557|       |#pragma mark - private - App ID Validation
  558|       |
  559|       |/**
  560|       | * Validates the format and fingerprint of the app ID contained in GOOGLE_APP_ID in the plist file.
  561|       | * This is the main method for validating app ID.
  562|       | *
  563|       | * @return YES if the app ID fulfills the expected format and fingerprint, NO otherwise.
  564|       | */
  565|     14|- (BOOL)isAppIDValid {
  566|     14|  NSString *appID = _options.googleAppID;
  567|     14|  BOOL isValid = [FIRApp validateAppID:appID];
  568|     14|  if (!isValid) {
  569|      0|    NSString *expectedBundleID = [self expectedBundleID];
  570|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000009",
  571|      0|                @"The GOOGLE_APP_ID either in the plist file "
  572|      0|                @"'%@.%@' or the one set in the customized options is invalid. If you are using "
  573|      0|                @"the plist file, use the iOS version of bundle identifier to download the file, "
  574|      0|                @"and do not manually edit the GOOGLE_APP_ID. You may change your app's bundle "
  575|      0|                @"identifier to '%@'. Or you can download a new configuration file that matches "
  576|      0|                @"your bundle identifier from %@ and replace the current one.",
  577|      0|                kServiceInfoFileName, kServiceInfoFileType, expectedBundleID, kPlistURL);
  578|      0|  };
  579|     14|  return isValid;
  580|     14|}
  581|       |
  582|     14|+ (BOOL)validateAppID:(NSString *)appID {
  583|     14|  // Failing validation only occurs when we are sure we are looking at a V2 app ID and it does not
  584|     14|  // have a valid fingerprint, otherwise we just warn about the potential issue.
  585|     14|  if (!appID.length) {
  586|      0|    return NO;
  587|      0|  }
  588|     14|
  589|     14|  NSScanner *stringScanner = [NSScanner scannerWithString:appID];
  590|     14|  stringScanner.charactersToBeSkipped = nil;
  591|     14|
  592|     14|  NSString *appIDVersion;
  593|     14|  if (![stringScanner scanCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet]
  594|     14|                                 intoString:&appIDVersion]) {
  595|      0|    return NO;
  596|      0|  }
  597|     14|
  598|     14|  if (![stringScanner scanString:@":" intoString:NULL]) {
  599|      0|    // appIDVersion must be separated by ":"
  600|      0|    return NO;
  601|      0|  }
  602|     14|
  603|     14|  NSArray *knownVersions = @[ @"1" ];
  604|     14|  if (![knownVersions containsObject:appIDVersion]) {
  605|      0|    // Permit unknown yet properly formatted app ID versions.
  606|      0|    FIRLogInfo(kFIRLoggerCore, @"I-COR000010", @"Unknown GOOGLE_APP_ID version: %@", appIDVersion);
  607|      0|    return YES;
  608|      0|  }
  609|     14|
  610|     14|  if (![self validateAppIDFormat:appID withVersion:appIDVersion]) {
  611|      0|    return NO;
  612|      0|  }
  613|     14|
  614|     14|  if (![self validateAppIDFingerprint:appID withVersion:appIDVersion]) {
  615|      0|    return NO;
  616|      0|  }
  617|     14|
  618|     14|  return YES;
  619|     14|}
  620|       |
  621|      0|+ (NSString *)actualBundleID {
  622|      0|  return [[NSBundle mainBundle] bundleIdentifier];
  623|      0|}
  624|       |
  625|       |/**
  626|       | * Validates that the format of the app ID string is what is expected based on the supplied version.
  627|       | * The version must end in ":".
  628|       | *
  629|       | * For v1 app ids the format is expected to be
  630|       | * '<version #>:<project number>:ios:<fingerprint of bundle id>'.
  631|       | *
  632|       | * This method does not verify that the contents of the app id are correct, just that they fulfill
  633|       | * the expected format.
  634|       | *
  635|       | * @param appID Contents of GOOGLE_APP_ID from the plist file.
  636|       | * @param version Indicates what version of the app id format this string should be.
  637|       | * @return YES if provided string fufills the expected format, NO otherwise.
  638|       | */
  639|     14|+ (BOOL)validateAppIDFormat:(NSString *)appID withVersion:(NSString *)version {
  640|     14|  if (!appID.length || !version.length) {
  641|      0|    return NO;
  642|      0|  }
  643|     14|
  644|     14|  NSScanner *stringScanner = [NSScanner scannerWithString:appID];
  645|     14|  stringScanner.charactersToBeSkipped = nil;
  646|     14|
  647|     14|  // Skip version part
  648|     14|  // '*<version #>*:<project number>:ios:<fingerprint of bundle id>'
  649|     14|  if (![stringScanner scanString:version intoString:NULL]) {
  650|      0|    // The version part is missing or mismatched
  651|      0|    return NO;
  652|      0|  }
  653|     14|
  654|     14|  // Validate version part (see part between '*' symbols below)
  655|     14|  // '<version #>*:*<project number>:ios:<fingerprint of bundle id>'
  656|     14|  if (![stringScanner scanString:@":" intoString:NULL]) {
  657|      0|    // appIDVersion must be separated by ":"
  658|      0|    return NO;
  659|      0|  }
  660|     14|
  661|     14|  // Validate version part (see part between '*' symbols below)
  662|     14|  // '<version #>:*<project number>*:ios:<fingerprint of bundle id>'.
  663|     14|  NSInteger projectNumber = NSNotFound;
  664|     14|  if (![stringScanner scanInteger:&projectNumber]) {
  665|      0|    // NO project number found.
  666|      0|    return NO;
  667|      0|  }
  668|     14|
  669|     14|  // Validate version part (see part between '*' symbols below)
  670|     14|  // '<version #>:<project number>*:*ios:<fingerprint of bundle id>'.
  671|     14|  if (![stringScanner scanString:@":" intoString:NULL]) {
  672|      0|    // The project number must be separated by ":"
  673|      0|    return NO;
  674|      0|  }
  675|     14|
  676|     14|  // Validate version part (see part between '*' symbols below)
  677|     14|  // '<version #>:<project number>:*ios*:<fingerprint of bundle id>'.
  678|     14|  NSString *platform;
  679|     14|  if (![stringScanner scanUpToString:@":" intoString:&platform]) {
  680|      0|    return NO;
  681|      0|  }
  682|     14|
  683|     14|  if (![platform isEqualToString:@"ios"]) {
  684|      0|    // The platform must be @"ios"
  685|      0|    return NO;
  686|      0|  }
  687|     14|
  688|     14|  // Validate version part (see part between '*' symbols below)
  689|     14|  // '<version #>:<project number>:ios*:*<fingerprint of bundle id>'.
  690|     14|  if (![stringScanner scanString:@":" intoString:NULL]) {
  691|      0|    // The platform must be separated by ":"
  692|      0|    return NO;
  693|      0|  }
  694|     14|
  695|     14|  // Validate version part (see part between '*' symbols below)
  696|     14|  // '<version #>:<project number>:ios:*<fingerprint of bundle id>*'.
  697|     14|  unsigned long long fingerprint = NSNotFound;
  698|     14|  if (![stringScanner scanHexLongLong:&fingerprint]) {
  699|      0|    // Fingerprint part is missing
  700|      0|    return NO;
  701|      0|  }
  702|     14|
  703|     14|  if (!stringScanner.isAtEnd) {
  704|      0|    // There are not allowed characters in the fingerprint part
  705|      0|    return NO;
  706|      0|  }
  707|     14|
  708|     14|  return YES;
  709|     14|}
  710|       |
  711|       |/**
  712|       | * Validates that the fingerprint of the app ID string is what is expected based on the supplied
  713|       | * version.
  714|       | *
  715|       | * Note that the v1 hash algorithm is not permitted on the client and cannot be fully validated.
  716|       | *
  717|       | * @param appID Contents of GOOGLE_APP_ID from the plist file.
  718|       | * @param version Indicates what version of the app id format this string should be.
  719|       | * @return YES if provided string fufills the expected fingerprint and the version is known, NO
  720|       | *         otherwise.
  721|       | */
  722|     14|+ (BOOL)validateAppIDFingerprint:(NSString *)appID withVersion:(NSString *)version {
  723|     14|  // Extract the supplied fingerprint from the supplied app ID.
  724|     14|  // This assumes the app ID format is the same for all known versions below. If the app ID format
  725|     14|  // changes in future versions, the tokenizing of the app ID format will need to take into account
  726|     14|  // the version of the app ID.
  727|     14|  NSArray *components = [appID componentsSeparatedByString:@":"];
  728|     14|  if (components.count != 4) {
  729|      0|    return NO;
  730|      0|  }
  731|     14|
  732|     14|  NSString *suppliedFingerprintString = components[3];
  733|     14|  if (!suppliedFingerprintString.length) {
  734|      0|    return NO;
  735|      0|  }
  736|     14|
  737|     14|  uint64_t suppliedFingerprint;
  738|     14|  NSScanner *scanner = [NSScanner scannerWithString:suppliedFingerprintString];
  739|     14|  if (![scanner scanHexLongLong:&suppliedFingerprint]) {
  740|      0|    return NO;
  741|      0|  }
  742|     14|
  743|     14|  if ([version isEqual:@"1"]) {
  744|     14|    // The v1 hash algorithm is not permitted on the client so the actual hash cannot be validated.
  745|     14|    return YES;
  746|     14|  }
  747|      0|
  748|      0|  // Unknown version.
  749|      0|  return NO;
  750|      0|}
  751|       |
  752|     14|- (NSString *)expectedBundleID {
  753|     14|  return _options.bundleID;
  754|     14|}
  755|       |
  756|       |// end App ID validation
  757|       |
  758|       |#pragma mark - Reading From Plist & User Defaults
  759|       |
  760|       |/**
  761|       | * Clears the data collection switch from the standard NSUserDefaults for easier testing and
  762|       | * readability.
  763|       | */
  764|      0|- (void)clearDataCollectionSwitchFromUserDefaults {
  765|      0|  NSString *key =
  766|      0|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, self.name];
  767|      0|  [[NSUserDefaults standardUserDefaults] removeObjectForKey:key];
  768|      0|}
  769|       |
  770|       |/**
  771|       | * Reads the data collection switch from the standard NSUserDefaults for easier testing and
  772|       | * readability.
  773|       | */
  774|     42|+ (nullable NSNumber *)readDataCollectionSwitchFromUserDefaultsForApp:(FIRApp *)app {
  775|     42|  // Read the object in user defaults, and only return if it's an NSNumber.
  776|     42|  NSString *key =
  777|     42|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, app.name];
  778|     42|  id collectionEnabledDefaultsObject = [[NSUserDefaults standardUserDefaults] objectForKey:key];
  779|     42|  if ([collectionEnabledDefaultsObject isKindOfClass:[NSNumber class]]) {
  780|      0|    return collectionEnabledDefaultsObject;
  781|      0|  }
  782|     42|
  783|     42|  return nil;
  784|     42|}
  785|       |
  786|       |/**
  787|       | * Reads the data collection switch from the Info.plist for easier testing and readability. Will
  788|       | * only read once from the plist and return the cached value.
  789|       | */
  790|     42|+ (nullable NSNumber *)readDataCollectionSwitchFromPlist {
  791|     42|  static NSNumber *collectionEnabledPlistObject;
  792|     42|  static dispatch_once_t onceToken;
  793|     42|  dispatch_once(&onceToken, ^{
  794|     14|    // Read the data from the `Info.plist`, only assign it if it's there and an NSNumber.
  795|     14|    id plistValue = [[NSBundle mainBundle]
  796|     14|        objectForInfoDictionaryKey:kFIRGlobalAppDataCollectionEnabledPlistKey];
  797|     14|    if (plistValue && [plistValue isKindOfClass:[NSNumber class]]) {
  798|      0|      collectionEnabledPlistObject = (NSNumber *)plistValue;
  799|      0|    }
  800|     14|  });
  801|     42|
  802|     42|  return collectionEnabledPlistObject;
  803|     42|}
  804|       |
  805|       |#pragma mark - Sending Logs
  806|       |
  807|       |- (void)sendLogsWithServiceName:(NSString *)serviceName
  808|       |                        version:(NSString *)version
  809|      0|                          error:(NSError *)error {
  810|      0|  // If the user has manually turned off data collection, return and don't send logs.
  811|      0|  if (![self isDataCollectionDefaultEnabled]) {
  812|      0|    return;
  813|      0|  }
  814|      0|
  815|      0|  NSMutableDictionary *userInfo = [[NSMutableDictionary alloc] initWithDictionary:@{
  816|      0|    kFIRAppDiagnosticsConfigurationTypeKey : @(FIRConfigTypeSDK),
  817|      0|    kFIRAppDiagnosticsSDKNameKey : serviceName,
  818|      0|    kFIRAppDiagnosticsSDKVersionKey : version,
  819|      0|    kFIRAppDiagnosticsFIRAppKey : self
  820|      0|  }];
  821|      0|  if (error) {
  822|      0|    userInfo[kFIRAppDiagnosticsErrorKey] = error;
  823|      0|  }
  824|      0|  [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppDiagnosticsNotification
  825|      0|                                                      object:nil
  826|      0|                                                    userInfo:userInfo];
  827|      0|}
  828|       |
  829|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRAppAssociationRegistration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/FIRAppAssociationRegistration.h"
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |
   19|       |@implementation FIRAppAssociationRegistration
   20|       |
   21|       |+ (nullable id)registeredObjectWithHost:(id)host
   22|       |                                    key:(NSString *)key
   23|      0|                          creationBlock:(id _Nullable (^)(void))creationBlock {
   24|      0|  @synchronized(self) {
   25|      0|    SEL dictKey = @selector(registeredObjectWithHost:key:creationBlock:);
   26|      0|    NSMutableDictionary<NSString *, id> *objectsByKey = objc_getAssociatedObject(host, dictKey);
   27|      0|    if (!objectsByKey) {
   28|      0|      objectsByKey = [[NSMutableDictionary alloc] init];
   29|      0|      objc_setAssociatedObject(host, dictKey, objectsByKey, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
   30|      0|    }
   31|      0|    id obj = objectsByKey[key];
   32|      0|    NSValue *creationBlockBeingCalled = [NSValue valueWithPointer:dictKey];
   33|      0|    if (obj) {
   34|      0|      if ([creationBlockBeingCalled isEqual:obj]) {
   35|      0|        [NSException raise:@"Reentering registeredObjectWithHost:key:creationBlock: not allowed"
   36|      0|                    format:@"host: %@ key: %@", host, key];
   37|      0|      }
   38|      0|      return obj;
   39|      0|    }
   40|      0|    objectsByKey[key] = creationBlockBeingCalled;
   41|      0|    obj = creationBlock();
   42|      0|    objectsByKey[key] = obj;
   43|      0|    return obj;
   44|      0|  }
   45|      0|}
   46|       |
   47|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRBundleUtil.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/FIRBundleUtil.h"
   16|       |
   17|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   18|       |
   19|       |@implementation FIRBundleUtil
   20|       |
   21|     28|+ (NSArray *)relevantBundles {
   22|     28|  return @[ [NSBundle mainBundle], [NSBundle bundleForClass:[self class]] ];
   23|     28|}
   24|       |
   25|       |+ (NSString *)optionsDictionaryPathWithResourceName:(NSString *)resourceName
   26|       |                                        andFileType:(NSString *)fileType
   27|     14|                                          inBundles:(NSArray *)bundles {
   28|     14|  // Loop through all bundles to find the config dict.
   29|     14|  for (NSBundle *bundle in bundles) {
   30|     14|    NSString *path = [bundle pathForResource:resourceName ofType:fileType];
   31|     14|    // Use the first one we find.
   32|     14|    if (path) {
   33|     14|      return path;
   34|     14|    }
   35|     14|  }
   36|     14|  return nil;
   37|     14|}
   38|       |
   39|      0|+ (NSArray *)relevantURLSchemes {
   40|      0|  NSMutableArray *result = [[NSMutableArray alloc] init];
   41|      0|  for (NSBundle *bundle in [[self class] relevantBundles]) {
   42|      0|    NSArray *urlTypes = [bundle objectForInfoDictionaryKey:@"CFBundleURLTypes"];
   43|      0|    for (NSDictionary *urlType in urlTypes) {
   44|      0|      [result addObjectsFromArray:urlType[@"CFBundleURLSchemes"]];
   45|      0|    }
   46|      0|  }
   47|      0|  return result;
   48|      0|}
   49|       |
   50|     14|+ (BOOL)hasBundleIdentifierPrefix:(NSString *)bundleIdentifier inBundles:(NSArray *)bundles {
   51|     14|  for (NSBundle *bundle in bundles) {
   52|     14|    // This allows app extensions that have the app's bundle as their prefix to pass this test.
   53|     14|    NSString *applicationBundleIdentifier =
   54|     14|        [GULAppEnvironmentUtil isAppExtension]
   55|     14|            ? [self bundleIdentifierByRemovingLastPartFrom:bundleIdentifier]
   56|     14|            : bundleIdentifier;
   57|     14|
   58|     14|    if ([applicationBundleIdentifier isEqualToString:bundle.bundleIdentifier]) {
   59|     14|      return YES;
   60|     14|    }
   61|     14|  }
   62|     14|  return NO;
   63|     14|}
   64|       |
   65|      0|+ (NSString *)bundleIdentifierByRemovingLastPartFrom:(NSString *)bundleIdentifier {
   66|      0|  NSString *bundleIDComponentsSeparator = @".";
   67|      0|
   68|      0|  NSMutableArray<NSString *> *bundleIDComponents =
   69|      0|      [[bundleIdentifier componentsSeparatedByString:bundleIDComponentsSeparator] mutableCopy];
   70|      0|  [bundleIDComponents removeLastObject];
   71|      0|
   72|      0|  return [bundleIDComponents componentsJoinedByString:bundleIDComponentsSeparator];
   73|      0|}
   74|       |
   75|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRComponent.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "Private/FIRComponent.h"
   18|       |
   19|       |#import "Private/FIRComponentContainer.h"
   20|       |#import "Private/FIRDependency.h"
   21|       |
   22|       |@interface FIRComponent ()
   23|       |
   24|       |- (instancetype)initWithProtocol:(Protocol *)protocol
   25|       |             instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   26|       |                    dependencies:(NSArray<FIRDependency *> *)dependencies
   27|       |                   creationBlock:(FIRComponentCreationBlock)creationBlock;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FIRComponent
   32|       |
   33|       |+ (instancetype)componentWithProtocol:(Protocol *)protocol
   34|      0|                        creationBlock:(FIRComponentCreationBlock)creationBlock {
   35|      0|  return [[FIRComponent alloc] initWithProtocol:protocol
   36|      0|                            instantiationTiming:FIRInstantiationTimingLazy
   37|      0|                                   dependencies:@[]
   38|      0|                                  creationBlock:creationBlock];
   39|      0|}
   40|       |
   41|       |+ (instancetype)componentWithProtocol:(Protocol *)protocol
   42|       |                  instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   43|       |                         dependencies:(NSArray<FIRDependency *> *)dependencies
   44|     28|                        creationBlock:(FIRComponentCreationBlock)creationBlock {
   45|     28|  return [[FIRComponent alloc] initWithProtocol:protocol
   46|     28|                            instantiationTiming:instantiationTiming
   47|     28|                                   dependencies:dependencies
   48|     28|                                  creationBlock:creationBlock];
   49|     28|}
   50|       |
   51|       |- (instancetype)initWithProtocol:(Protocol *)protocol
   52|       |             instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   53|       |                    dependencies:(NSArray<FIRDependency *> *)dependencies
   54|     28|                   creationBlock:(FIRComponentCreationBlock)creationBlock {
   55|     28|  self = [super init];
   56|     28|  if (self) {
   57|     28|    _protocol = protocol;
   58|     28|    _instantiationTiming = instantiationTiming;
   59|     28|    _dependencies = [dependencies copy];
   60|     28|    _creationBlock = creationBlock;
   61|     28|  }
   62|     28|  return self;
   63|     28|}
   64|       |
   65|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRComponentContainer.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "Private/FIRComponentContainer.h"
   18|       |
   19|       |#import "Private/FIRAppInternal.h"
   20|       |#import "Private/FIRComponent.h"
   21|       |#import "Private/FIRLibrary.h"
   22|       |#import "Private/FIRLogger.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@interface FIRComponentContainer ()
   27|       |
   28|       |/// The dictionary of components that are registered for a particular app. The key is an NSString
   29|       |/// of the protocol.
   30|       |@property(nonatomic, strong) NSMutableDictionary<NSString *, FIRComponentCreationBlock> *components;
   31|       |
   32|       |/// Cached instances of components that requested to be cached.
   33|       |@property(nonatomic, strong) NSMutableDictionary<NSString *, id> *cachedInstances;
   34|       |
   35|       |@end
   36|       |
   37|       |@implementation FIRComponentContainer
   38|       |
   39|       |// Collection of all classes that register to provide components.
   40|       |static NSMutableSet<Class> *sFIRComponentRegistrants;
   41|       |
   42|       |#pragma mark - Public Registration
   43|       |
   44|     28|+ (void)registerAsComponentRegistrant:(Class<FIRLibrary>)klass {
   45|     28|  static dispatch_once_t onceToken;
   46|     28|  dispatch_once(&onceToken, ^{
   47|     14|    sFIRComponentRegistrants = [[NSMutableSet<Class> alloc] init];
   48|     14|  });
   49|     28|
   50|     28|  [self registerAsComponentRegistrant:klass inSet:sFIRComponentRegistrants];
   51|     28|}
   52|       |
   53|       |+ (void)registerAsComponentRegistrant:(Class<FIRLibrary>)klass
   54|     28|                                inSet:(NSMutableSet<Class> *)allRegistrants {
   55|     28|  [allRegistrants addObject:klass];
   56|     28|}
   57|       |
   58|       |#pragma mark - Internal Initialization
   59|       |
   60|     14|- (instancetype)initWithApp:(FIRApp *)app {
   61|     14|  return [self initWithApp:app registrants:sFIRComponentRegistrants];
   62|     14|}
   63|       |
   64|     14|- (instancetype)initWithApp:(FIRApp *)app registrants:(NSMutableSet<Class> *)allRegistrants {
   65|     14|  self = [super init];
   66|     14|  if (self) {
   67|     14|    _app = app;
   68|     14|    _cachedInstances = [NSMutableDictionary<NSString *, id> dictionary];
   69|     14|    _components = [NSMutableDictionary<NSString *, FIRComponentCreationBlock> dictionary];
   70|     14|
   71|     14|    [self populateComponentsFromRegisteredClasses:allRegistrants forApp:app];
   72|     14|  }
   73|     14|  return self;
   74|     14|}
   75|       |
   76|     14|- (void)populateComponentsFromRegisteredClasses:(NSSet<Class> *)classes forApp:(FIRApp *)app {
   77|     14|  // Loop through the verified component registrants and populate the components array.
   78|     28|  for (Class<FIRLibrary> klass in classes) {
   79|     28|    // Loop through all the components being registered and store them as appropriate.
   80|     28|    // Classes which do not provide functionality should use a dummy FIRComponentRegistrant
   81|     28|    // protocol.
   82|     28|    for (FIRComponent *component in [klass componentsToRegister]) {
   83|     28|      // Check if the component has been registered before, and error out if so.
   84|     28|      NSString *protocolName = NSStringFromProtocol(component.protocol);
   85|     28|      if (self.components[protocolName]) {
   86|      0|        FIRLogError(kFIRLoggerCore, @"I-COR000029",
   87|      0|                    @"Attempted to register protocol %@, but it already has an implementation.",
   88|      0|                    protocolName);
   89|      0|        continue;
   90|      0|      }
   91|     28|
   92|     28|      // Store the creation block for later usage.
   93|     28|      self.components[protocolName] = component.creationBlock;
   94|     28|
   95|     28|      // Instantiate the
   96|     28|      BOOL shouldInstantiateEager =
   97|     28|          (component.instantiationTiming == FIRInstantiationTimingAlwaysEager);
   98|     28|      BOOL shouldInstantiateDefaultEager =
   99|     28|          (component.instantiationTiming == FIRInstantiationTimingEagerInDefaultApp &&
  100|     28|           [app isDefaultApp]);
  101|     28|      if (shouldInstantiateEager || shouldInstantiateDefaultEager) {
  102|      0|        [self instantiateInstanceForProtocol:component.protocol withBlock:component.creationBlock];
  103|      0|      }
  104|     28|    }
  105|     28|  }
  106|     14|}
  107|       |
  108|       |#pragma mark - Instance Creation
  109|       |
  110|       |/// Instantiate an instance of a class that conforms to the specified protocol.
  111|       |/// This will:
  112|       |///   - Call the block to create an instance if possible,
  113|       |///   - Validate that the instance returned conforms to the protocol it claims to,
  114|       |///   - Cache the instance if the block requests it
  115|       |- (nullable id)instantiateInstanceForProtocol:(Protocol *)protocol
  116|     14|                                    withBlock:(FIRComponentCreationBlock)creationBlock {
  117|     14|  if (!creationBlock) {
  118|      0|    return nil;
  119|      0|  }
  120|     14|
  121|     14|  // Create an instance using the creation block.
  122|     14|  BOOL shouldCache = NO;
  123|     14|  id instance = creationBlock(self, &shouldCache);
  124|     14|  if (!instance) {
  125|      0|    return nil;
  126|      0|  }
  127|     14|
  128|     14|  // An instance was created, validate that it conforms to the protocol it claims to.
  129|     14|  NSString *protocolName = NSStringFromProtocol(protocol);
  130|     14|  if (![instance conformsToProtocol:protocol]) {
  131|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000030",
  132|      0|                @"An instance conforming to %@ was requested, but the instance provided does not "
  133|      0|                @"conform to the protocol",
  134|      0|                protocolName);
  135|      0|  }
  136|     14|
  137|     14|  // The instance is ready to be returned, but check if it should be cached first before returning.
  138|     14|  if (shouldCache) {
  139|     14|    self.cachedInstances[protocolName] = instance;
  140|     14|  }
  141|     14|
  142|     14|  return instance;
  143|     14|}
  144|       |
  145|       |#pragma mark - Internal Retrieval
  146|       |
  147|     91|- (nullable id)instanceForProtocol:(Protocol *)protocol {
  148|     91|  // Check if there is a cached instance, and return it if so.
  149|     91|  NSString *protocolName = NSStringFromProtocol(protocol);
  150|     91|  id cachedInstance = self.cachedInstances[protocolName];
  151|     91|  if (cachedInstance) {
  152|     77|    return cachedInstance;
  153|     77|  }
  154|     14|
  155|     14|  // Use the creation block to instantiate an instance and return it.
  156|     14|  FIRComponentCreationBlock creationBlock = self.components[protocolName];
  157|     14|  return [self instantiateInstanceForProtocol:protocol withBlock:creationBlock];
  158|     14|}
  159|       |
  160|       |#pragma mark - Lifecycle
  161|       |
  162|      0|- (void)removeAllCachedInstances {
  163|      0|  // Loop through the cache and notify each instance that is a maintainer to clean up after itself.
  164|      0|  for (id instance in self.cachedInstances.allValues) {
  165|      0|    if ([instance conformsToProtocol:@protocol(FIRComponentLifecycleMaintainer)] &&
  166|      0|        [instance respondsToSelector:@selector(appWillBeDeleted:)]) {
  167|      0|      [instance appWillBeDeleted:self.app];
  168|      0|    }
  169|      0|  }
  170|      0|
  171|      0|  [self.cachedInstances removeAllObjects];
  172|      0|}
  173|       |
  174|       |@end
  175|       |
  176|       |NS_ASSUME_NONNULL_END

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRComponentType.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "Private/FIRComponentType.h"
   18|       |
   19|       |#import "Private/FIRComponentContainerInternal.h"
   20|       |
   21|       |@implementation FIRComponentType
   22|       |
   23|     91|+ (id)instanceForProtocol:(Protocol *)protocol inContainer:(FIRComponentContainer *)container {
   24|     91|  // Forward the call to the container.
   25|     91|  return [container instanceForProtocol:protocol];
   26|     91|}
   27|       |
   28|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRConfiguration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FIRConfiguration.h"
   16|       |
   17|       |extern void FIRSetLoggerLevel(FIRLoggerLevel loggerLevel);
   18|       |
   19|       |@implementation FIRConfiguration
   20|       |
   21|     14|+ (instancetype)sharedInstance {
   22|     14|  static FIRConfiguration *sharedInstance = nil;
   23|     14|  static dispatch_once_t onceToken;
   24|     14|  dispatch_once(&onceToken, ^{
   25|     14|    sharedInstance = [[FIRConfiguration alloc] init];
   26|     14|  });
   27|     14|  return sharedInstance;
   28|     14|}
   29|       |
   30|     14|- (instancetype)init {
   31|     14|  self = [super init];
   32|     14|  if (self) {
   33|     14|#pragma clang diagnostic push
   34|     14|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   35|     14|    _analyticsConfiguration = [FIRAnalyticsConfiguration sharedInstance];
   36|     14|#pragma clang diagnostic pop
   37|     14|  }
   38|     14|  return self;
   39|     14|}
   40|       |
   41|      0|- (void)setLoggerLevel:(FIRLoggerLevel)loggerLevel {
   42|      0|  NSAssert(loggerLevel <= FIRLoggerLevelMax && loggerLevel >= FIRLoggerLevelMin,
   43|      0|           @"Invalid logger level, %ld", (long)loggerLevel);
   44|      0|  FIRSetLoggerLevel(loggerLevel);
   45|      0|}
   46|       |
   47|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRDependency.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "Private/FIRDependency.h"
   18|       |
   19|       |@interface FIRDependency ()
   20|       |
   21|       |- (instancetype)initWithProtocol:(Protocol *)protocol isRequired:(BOOL)required;
   22|       |
   23|       |@end
   24|       |
   25|       |@implementation FIRDependency
   26|       |
   27|      0|+ (instancetype)dependencyWithProtocol:(Protocol *)protocol {
   28|      0|  return [[self alloc] initWithProtocol:protocol isRequired:YES];
   29|      0|}
   30|       |
   31|      0|+ (instancetype)dependencyWithProtocol:(Protocol *)protocol isRequired:(BOOL)required {
   32|      0|  return [[self alloc] initWithProtocol:protocol isRequired:required];
   33|      0|}
   34|       |
   35|      0|- (instancetype)initWithProtocol:(Protocol *)protocol isRequired:(BOOL)required {
   36|      0|  self = [super init];
   37|      0|  if (self) {
   38|      0|    _protocol = protocol;
   39|      0|    _isRequired = required;
   40|      0|  }
   41|      0|  return self;
   42|      0|}
   43|       |
   44|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIRLogger.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/FIRLogger.h"
   16|       |
   17|       |#import <FirebaseCore/FIRLoggerLevel.h>
   18|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |
   21|       |#import "Private/FIRVersion.h"
   22|       |
   23|       |FIRLoggerService kFIRLoggerABTesting = @"[Firebase/ABTesting]";
   24|       |FIRLoggerService kFIRLoggerAdMob = @"[Firebase/AdMob]";
   25|       |FIRLoggerService kFIRLoggerAnalytics = @"[Firebase/Analytics]";
   26|       |FIRLoggerService kFIRLoggerAuth = @"[Firebase/Auth]";
   27|       |FIRLoggerService kFIRLoggerCore = @"[Firebase/Core]";
   28|       |FIRLoggerService kFIRLoggerCrash = @"[Firebase/Crash]";
   29|       |FIRLoggerService kFIRLoggerDatabase = @"[Firebase/Database]";
   30|       |FIRLoggerService kFIRLoggerDynamicLinks = @"[Firebase/DynamicLinks]";
   31|       |FIRLoggerService kFIRLoggerFirestore = @"[Firebase/Firestore]";
   32|       |FIRLoggerService kFIRLoggerInstanceID = @"[Firebase/InstanceID]";
   33|       |FIRLoggerService kFIRLoggerInvites = @"[Firebase/Invites]";
   34|       |FIRLoggerService kFIRLoggerMLKit = @"[Firebase/MLKit]";
   35|       |FIRLoggerService kFIRLoggerMessaging = @"[Firebase/Messaging]";
   36|       |FIRLoggerService kFIRLoggerPerf = @"[Firebase/Performance]";
   37|       |FIRLoggerService kFIRLoggerRemoteConfig = @"[Firebase/RemoteConfig]";
   38|       |FIRLoggerService kFIRLoggerStorage = @"[Firebase/Storage]";
   39|       |FIRLoggerService kFIRLoggerSwizzler = @"[FirebaseSwizzlingUtilities]";
   40|       |
   41|       |/// Arguments passed on launch.
   42|       |NSString *const kFIRDisableDebugModeApplicationArgument = @"-FIRDebugDisabled";
   43|       |NSString *const kFIREnableDebugModeApplicationArgument = @"-FIRDebugEnabled";
   44|       |NSString *const kFIRLoggerForceSDTERRApplicationArgument = @"-FIRLoggerForceSTDERR";
   45|       |
   46|       |/// Key for the debug mode bit in NSUserDefaults.
   47|       |NSString *const kFIRPersistedDebugModeKey = @"/google/firebase/debug_mode";
   48|       |
   49|       |/// NSUserDefaults that should be used to store and read variables. If nil, `standardUserDefaults`
   50|       |/// will be used.
   51|       |static NSUserDefaults *sFIRLoggerUserDefaults;
   52|       |
   53|       |static dispatch_once_t sFIRLoggerOnceToken;
   54|       |
   55|       |// The sFIRAnalyticsDebugMode flag is here to support the -FIRDebugEnabled/-FIRDebugDisabled
   56|       |// flags used by Analytics. Users who use those flags expect Analytics to log verbosely,
   57|       |// while the rest of Firebase logs at the default level. This flag is introduced to support
   58|       |// that behavior.
   59|       |static BOOL sFIRAnalyticsDebugMode;
   60|       |
   61|       |#ifdef DEBUG
   62|       |/// The regex pattern for the message code.
   63|       |static NSString *const kMessageCodePattern = @"^I-[A-Z]{3}[0-9]{6}$";
   64|       |static NSRegularExpression *sMessageCodeRegex;
   65|       |#endif
   66|       |
   67|    113|void FIRLoggerInitializeASL() {
   68|    113|  dispatch_once(&sFIRLoggerOnceToken, ^{
   69|     14|    // Register Firebase Version with GULLogger.
   70|     14|    GULLoggerRegisterVersion(FIRVersionString);
   71|     14|
   72|     14|    // Override the aslOptions to ASL_OPT_STDERR if the override argument is passed in.
   73|     14|    NSArray *arguments = [NSProcessInfo processInfo].arguments;
   74|     14|    BOOL overrideSTDERR = [arguments containsObject:kFIRLoggerForceSDTERRApplicationArgument];
   75|     14|
   76|     14|    // Use the standard NSUserDefaults if it hasn't been explicitly set.
   77|     14|    if (sFIRLoggerUserDefaults == nil) {
   78|     14|      sFIRLoggerUserDefaults = [NSUserDefaults standardUserDefaults];
   79|     14|    }
   80|     14|
   81|     14|    BOOL forceDebugMode = NO;
   82|     14|    BOOL debugMode = [sFIRLoggerUserDefaults boolForKey:kFIRPersistedDebugModeKey];
   83|     14|    if ([arguments containsObject:kFIRDisableDebugModeApplicationArgument]) {  // Default mode
   84|      0|      [sFIRLoggerUserDefaults removeObjectForKey:kFIRPersistedDebugModeKey];
   85|     14|    } else if ([arguments containsObject:kFIREnableDebugModeApplicationArgument] ||
   86|     14|               debugMode) {  // Debug mode
   87|      0|      [sFIRLoggerUserDefaults setBool:YES forKey:kFIRPersistedDebugModeKey];
   88|      0|      forceDebugMode = YES;
   89|      0|    }
   90|     14|    GULLoggerInitializeASL();
   91|     14|    if (overrideSTDERR) {
   92|      0|      GULLoggerEnableSTDERR();
   93|      0|    }
   94|     14|    if (forceDebugMode) {
   95|      0|      GULLoggerForceDebug();
   96|      0|    }
   97|     14|  });
   98|    113|}
   99|       |
  100|      0|__attribute__((no_sanitize("thread"))) void FIRSetAnalyticsDebugMode(BOOL analyticsDebugMode) {
  101|      0|  sFIRAnalyticsDebugMode = analyticsDebugMode;
  102|      0|}
  103|       |
  104|      0|void FIRSetLoggerLevel(FIRLoggerLevel loggerLevel) {
  105|      0|  FIRLoggerInitializeASL();
  106|      0|  GULSetLoggerLevel((GULLoggerLevel)loggerLevel);
  107|      0|}
  108|       |
  109|       |#ifdef DEBUG
  110|      0|void FIRResetLogger() {
  111|      0|  extern void GULResetLogger(void);
  112|      0|  sFIRLoggerOnceToken = 0;
  113|      0|  [sFIRLoggerUserDefaults removeObjectForKey:kFIRPersistedDebugModeKey];
  114|      0|  sFIRLoggerUserDefaults = nil;
  115|      0|  GULResetLogger();
  116|      0|}
  117|       |
  118|      0|void FIRSetLoggerUserDefaults(NSUserDefaults *defaults) {
  119|      0|  sFIRLoggerUserDefaults = defaults;
  120|      0|}
  121|       |#endif
  122|       |
  123|       |/**
  124|       | * Check if the level is high enough to be loggable.
  125|       | *
  126|       | * Analytics can override the log level with an intentional race condition.
  127|       | * Add the attribute to get a clean thread sanitizer run.
  128|       | */
  129|       |__attribute__((no_sanitize("thread"))) BOOL FIRIsLoggableLevel(FIRLoggerLevel loggerLevel,
  130|      0|                                                               BOOL analyticsComponent) {
  131|      0|  FIRLoggerInitializeASL();
  132|      0|  if (sFIRAnalyticsDebugMode && analyticsComponent) {
  133|      0|    return YES;
  134|      0|  }
  135|      0|  return GULIsLoggableLevel((GULLoggerLevel)loggerLevel);
  136|      0|}
  137|       |
  138|       |void FIRLogBasic(FIRLoggerLevel level,
  139|       |                 FIRLoggerService service,
  140|       |                 NSString *messageCode,
  141|       |                 NSString *message,
  142|    113|                 va_list args_ptr) {
  143|    113|  FIRLoggerInitializeASL();
  144|    113|  GULLogBasic((GULLoggerLevel)level, service,
  145|    113|              sFIRAnalyticsDebugMode && [kFIRLoggerAnalytics isEqualToString:service], messageCode,
  146|    113|              message, args_ptr);
  147|    113|}
  148|       |
  149|       |/**
  150|       | * Generates the logging functions using macros.
  151|       | *
  152|       | * Calling FIRLogError(kFIRLoggerCore, @"I-COR000001", @"Configure %@ failed.", @"blah") shows:
  153|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Error> [Firebase/Core][I-COR000001] Configure blah failed.
  154|       | * Calling FIRLogDebug(kFIRLoggerCore, @"I-COR000001", @"Configure succeed.") shows:
  155|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Debug> [Firebase/Core][I-COR000001] Configure succeed.
  156|       | */
  157|       |#define FIR_LOGGING_FUNCTION(level)                                                             \
  158|     28|  void FIRLog##level(FIRLoggerService service, NSString *messageCode, NSString *message, ...) { \
  159|     28|    va_list args_ptr;                                                                           \
  160|     28|    va_start(args_ptr, message);                                                                \
  161|     28|    FIRLogBasic(FIRLoggerLevel##level, service, messageCode, message, args_ptr);                \
  162|     28|    va_end(args_ptr);                                                                           \
  163|     28|  }
  ------------------
  | Unexecuted instantiation: FIRLogError
  ------------------
  | Unexecuted instantiation: FIRLogWarning
  ------------------
  | Unexecuted instantiation: FIRLogNotice
  ------------------
  | Unexecuted instantiation: FIRLogInfo
  ------------------
  | FIRLogDebug:
  |  158|     28|  void FIRLog##level(FIRLoggerService service, NSString *messageCode, NSString *message, ...) { \
  |  159|     28|    va_list args_ptr;                                                                           \
  |  160|     28|    va_start(args_ptr, message);                                                                \
  |  161|     28|    FIRLogBasic(FIRLoggerLevel##level, service, messageCode, message, args_ptr);                \
  |  162|     28|    va_end(args_ptr);                                                                           \
  |  163|     28|  }
  ------------------
  164|       |
  165|       |FIR_LOGGING_FUNCTION(Error)
  166|       |FIR_LOGGING_FUNCTION(Warning)
  167|       |FIR_LOGGING_FUNCTION(Notice)
  168|       |FIR_LOGGING_FUNCTION(Info)
  169|       |FIR_LOGGING_FUNCTION(Debug)
  170|       |
  171|       |#undef FIR_MAKE_LOGGER
  172|       |
  173|       |#pragma mark - FIRLoggerWrapper
  174|       |
  175|       |@implementation FIRLoggerWrapper
  176|       |
  177|       |+ (void)logWithLevel:(FIRLoggerLevel)level
  178|       |         withService:(FIRLoggerService)service
  179|       |            withCode:(NSString *)messageCode
  180|       |         withMessage:(NSString *)message
  181|      0|            withArgs:(va_list)args {
  182|      0|  FIRLogBasic(level, service, messageCode, message, args);
  183|      0|}
  184|       |
  185|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/FIROptions.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/FIRAppInternal.h"
   16|       |#import "Private/FIRBundleUtil.h"
   17|       |#import "Private/FIRErrors.h"
   18|       |#import "Private/FIRLogger.h"
   19|       |#import "Private/FIROptionsInternal.h"
   20|       |
   21|       |// Keys for the strings in the plist file.
   22|       |NSString *const kFIRAPIKey = @"API_KEY";
   23|       |NSString *const kFIRTrackingID = @"TRACKING_ID";
   24|       |NSString *const kFIRGoogleAppID = @"GOOGLE_APP_ID";
   25|       |NSString *const kFIRClientID = @"CLIENT_ID";
   26|       |NSString *const kFIRGCMSenderID = @"GCM_SENDER_ID";
   27|       |NSString *const kFIRAndroidClientID = @"ANDROID_CLIENT_ID";
   28|       |NSString *const kFIRDatabaseURL = @"DATABASE_URL";
   29|       |NSString *const kFIRStorageBucket = @"STORAGE_BUCKET";
   30|       |// The key to locate the expected bundle identifier in the plist file.
   31|       |NSString *const kFIRBundleID = @"BUNDLE_ID";
   32|       |// The key to locate the project identifier in the plist file.
   33|       |NSString *const kFIRProjectID = @"PROJECT_ID";
   34|       |
   35|       |NSString *const kFIRIsMeasurementEnabled = @"IS_MEASUREMENT_ENABLED";
   36|       |NSString *const kFIRIsAnalyticsCollectionEnabled = @"FIREBASE_ANALYTICS_COLLECTION_ENABLED";
   37|       |NSString *const kFIRIsAnalyticsCollectionDeactivated = @"FIREBASE_ANALYTICS_COLLECTION_DEACTIVATED";
   38|       |
   39|       |NSString *const kFIRIsAnalyticsEnabled = @"IS_ANALYTICS_ENABLED";
   40|       |NSString *const kFIRIsSignInEnabled = @"IS_SIGNIN_ENABLED";
   41|       |
   42|       |// Library version ID.
   43|       |NSString *const kFIRLibraryVersionID = @"5"     // Major version (one or more digits)
   44|       |                                       @"04"    // Minor version (exactly 2 digits)
   45|       |                                       @"01"    // Build number (exactly 2 digits)
   46|       |                                       @"000";  // Fixed "000"
   47|       |// Plist file name.
   48|       |NSString *const kServiceInfoFileName = @"GoogleService-Info";
   49|       |// Plist file type.
   50|       |NSString *const kServiceInfoFileType = @"plist";
   51|       |
   52|       |// Exception raised from attempting to modify a FIROptions after it's been copied to a FIRApp.
   53|       |NSString *const kFIRExceptionBadModification =
   54|       |    @"Attempted to modify options after it's set on FIRApp. Please modify all properties before "
   55|       |    @"initializing FIRApp.";
   56|       |
   57|       |@interface FIROptions ()
   58|       |
   59|       |/**
   60|       | * This property maintains the actual configuration key-value pairs.
   61|       | */
   62|       |@property(nonatomic, readwrite) NSMutableDictionary *optionsDictionary;
   63|       |
   64|       |/**
   65|       | * Calls `analyticsOptionsDictionaryWithInfoDictionary:` using [NSBundle mainBundle].infoDictionary.
   66|       | * It combines analytics options from both the infoDictionary and the GoogleService-Info.plist.
   67|       | * Values which are present in the main plist override values from the GoogleService-Info.plist.
   68|       | */
   69|       |@property(nonatomic, readonly) NSDictionary *analyticsOptionsDictionary;
   70|       |
   71|       |/**
   72|       | * Combination of analytics options from both the infoDictionary and the GoogleService-Info.plist.
   73|       | * Values which are present in the infoDictionary override values from the GoogleService-Info.plist.
   74|       | */
   75|       |- (NSDictionary *)analyticsOptionsDictionaryWithInfoDictionary:(NSDictionary *)infoDictionary;
   76|       |
   77|       |/**
   78|       | * Throw exception if editing is locked when attempting to modify an option.
   79|       | */
   80|       |- (void)checkEditingLocked;
   81|       |
   82|       |@end
   83|       |
   84|       |@implementation FIROptions {
   85|       |  /// Backing variable for self.analyticsOptionsDictionary.
   86|       |  NSDictionary *_analyticsOptionsDictionary;
   87|       |}
   88|       |
   89|       |static FIROptions *sDefaultOptions = nil;
   90|       |static NSDictionary *sDefaultOptionsDictionary = nil;
   91|       |
   92|       |#pragma mark - Public only for internal class methods
   93|       |
   94|     14|+ (FIROptions *)defaultOptions {
   95|     14|  if (sDefaultOptions != nil) {
   96|      0|    return sDefaultOptions;
   97|      0|  }
   98|     14|
   99|     14|  NSDictionary *defaultOptionsDictionary = [self defaultOptionsDictionary];
  100|     14|  if (defaultOptionsDictionary == nil) {
  101|      0|    return nil;
  102|      0|  }
  103|     14|
  104|     14|  sDefaultOptions = [[FIROptions alloc] initInternalWithOptionsDictionary:defaultOptionsDictionary];
  105|     14|  return sDefaultOptions;
  106|     14|}
  107|       |
  108|       |#pragma mark - Private class methods
  109|       |
  110|     14|+ (void)initialize {
  111|     14|  // Report FirebaseCore version for useragent string
  112|     14|  NSRange major = NSMakeRange(0, 1);
  113|     14|  NSRange minor = NSMakeRange(1, 2);
  114|     14|  NSRange patch = NSMakeRange(3, 2);
  115|     14|  [FIRApp
  116|     14|      registerLibrary:@"fire-ios"
  117|     14|          withVersion:[NSString stringWithFormat:@"%@.%d.%d",
  118|     14|                                                 [kFIRLibraryVersionID substringWithRange:major],
  119|     14|                                                 [[kFIRLibraryVersionID substringWithRange:minor]
  120|     14|                                                     intValue],
  121|     14|                                                 [[kFIRLibraryVersionID substringWithRange:patch]
  122|     14|                                                     intValue]]];
  123|     14|  NSDictionary<NSString *, id> *info = [[NSBundle mainBundle] infoDictionary];
  124|     14|  NSString *xcodeVersion = info[@"DTXcodeBuild"];
  125|     14|  NSString *sdkVersion = info[@"DTSDKBuild"];
  126|     14|  if (xcodeVersion) {
  127|     14|    [FIRApp registerLibrary:@"xcode" withVersion:xcodeVersion];
  128|     14|  }
  129|     14|  if (sdkVersion) {
  130|     14|    [FIRApp registerLibrary:@"apple-sdk" withVersion:sdkVersion];
  131|     14|  }
  132|     14|}
  133|       |
  134|     28|+ (NSDictionary *)defaultOptionsDictionary {
  135|     28|  if (sDefaultOptionsDictionary != nil) {
  136|     14|    return sDefaultOptionsDictionary;
  137|     14|  }
  138|     14|  NSString *plistFilePath = [FIROptions plistFilePathWithName:kServiceInfoFileName];
  139|     14|  if (plistFilePath == nil) {
  140|      0|    return nil;
  141|      0|  }
  142|     14|  sDefaultOptionsDictionary = [NSDictionary dictionaryWithContentsOfFile:plistFilePath];
  143|     14|  if (sDefaultOptionsDictionary == nil) {
  144|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000011",
  145|      0|                @"The configuration file is not a dictionary: "
  146|      0|                @"'%@.%@'.",
  147|      0|                kServiceInfoFileName, kServiceInfoFileType);
  148|      0|  }
  149|     14|  return sDefaultOptionsDictionary;
  150|     14|}
  151|       |
  152|       |// Returns the path of the plist file with a given file name.
  153|     14|+ (NSString *)plistFilePathWithName:(NSString *)fileName {
  154|     14|  NSArray *bundles = [FIRBundleUtil relevantBundles];
  155|     14|  NSString *plistFilePath =
  156|     14|      [FIRBundleUtil optionsDictionaryPathWithResourceName:fileName
  157|     14|                                               andFileType:kServiceInfoFileType
  158|     14|                                                 inBundles:bundles];
  159|     14|  if (plistFilePath == nil) {
  160|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000012", @"Could not locate configuration file: '%@.%@'.",
  161|      0|                fileName, kServiceInfoFileType);
  162|      0|  }
  163|     14|  return plistFilePath;
  164|     14|}
  165|       |
  166|      0|+ (void)resetDefaultOptions {
  167|      0|  sDefaultOptions = nil;
  168|      0|  sDefaultOptionsDictionary = nil;
  169|      0|}
  170|       |
  171|       |#pragma mark - Private instance methods
  172|       |
  173|     14|- (instancetype)initInternalWithOptionsDictionary:(NSDictionary *)optionsDictionary {
  174|     14|  self = [super init];
  175|     14|  if (self) {
  176|     14|    _optionsDictionary = [optionsDictionary mutableCopy];
  177|     14|    _usingOptionsFromDefaultPlist = YES;
  178|     14|  }
  179|     14|  return self;
  180|     14|}
  181|       |
  182|    154|- (id)copyWithZone:(NSZone *)zone {
  183|    154|  FIROptions *newOptions = [[[self class] allocWithZone:zone] init];
  184|    154|  if (newOptions) {
  185|    154|    newOptions.optionsDictionary = self.optionsDictionary;
  186|    154|    newOptions.deepLinkURLScheme = self.deepLinkURLScheme;
  187|    154|    newOptions.editingLocked = self.isEditingLocked;
  188|    154|    newOptions.usingOptionsFromDefaultPlist = self.usingOptionsFromDefaultPlist;
  189|    154|  }
  190|    154|  return newOptions;
  191|    154|}
  192|       |
  193|       |#pragma mark - Public instance methods
  194|       |
  195|      0|- (instancetype)initWithContentsOfFile:(NSString *)plistPath {
  196|      0|  self = [super init];
  197|      0|  if (self) {
  198|      0|    if (plistPath == nil) {
  199|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000013", @"The plist file path is nil.");
  200|      0|      return nil;
  201|      0|    }
  202|      0|    _optionsDictionary = [[NSDictionary dictionaryWithContentsOfFile:plistPath] mutableCopy];
  203|      0|    if (_optionsDictionary == nil) {
  204|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000014",
  205|      0|                  @"The configuration file at %@ does not exist or "
  206|      0|                  @"is not a well-formed plist file.",
  207|      0|                  plistPath);
  208|      0|      return nil;
  209|      0|    }
  210|      0|    // TODO: Do we want to validate the dictionary here? It says we do that already in
  211|      0|    // the public header.
  212|      0|  }
  213|      0|  return self;
  214|      0|}
  215|       |
  216|      0|- (instancetype)initWithGoogleAppID:(NSString *)googleAppID GCMSenderID:(NSString *)GCMSenderID {
  217|      0|  self = [super init];
  218|      0|  if (self) {
  219|      0|    NSMutableDictionary *mutableOptionsDict = [NSMutableDictionary dictionary];
  220|      0|    [mutableOptionsDict setValue:googleAppID forKey:kFIRGoogleAppID];
  221|      0|    [mutableOptionsDict setValue:GCMSenderID forKey:kFIRGCMSenderID];
  222|      0|    [mutableOptionsDict setValue:[[NSBundle mainBundle] bundleIdentifier] forKey:kFIRBundleID];
  223|      0|    self.optionsDictionary = mutableOptionsDict;
  224|      0|  }
  225|      0|  return self;
  226|      0|}
  227|       |
  228|      0|- (NSString *)APIKey {
  229|      0|  return self.optionsDictionary[kFIRAPIKey];
  230|      0|}
  231|       |
  232|    154|- (void)checkEditingLocked {
  233|    154|  if (self.isEditingLocked) {
  234|      0|    [NSException raise:kFirebaseCoreErrorDomain format:kFIRExceptionBadModification];
  235|      0|  }
  236|    154|}
  237|       |
  238|      0|- (void)setAPIKey:(NSString *)APIKey {
  239|      0|  [self checkEditingLocked];
  240|      0|  _optionsDictionary[kFIRAPIKey] = [APIKey copy];
  241|      0|}
  242|       |
  243|      0|- (NSString *)clientID {
  244|      0|  return self.optionsDictionary[kFIRClientID];
  245|      0|}
  246|       |
  247|      0|- (void)setClientID:(NSString *)clientID {
  248|      0|  [self checkEditingLocked];
  249|      0|  _optionsDictionary[kFIRClientID] = [clientID copy];
  250|      0|}
  251|       |
  252|      0|- (NSString *)trackingID {
  253|      0|  return self.optionsDictionary[kFIRTrackingID];
  254|      0|}
  255|       |
  256|      0|- (void)setTrackingID:(NSString *)trackingID {
  257|      0|  [self checkEditingLocked];
  258|      0|  _optionsDictionary[kFIRTrackingID] = [trackingID copy];
  259|      0|}
  260|       |
  261|     14|- (NSString *)GCMSenderID {
  262|     14|  return self.optionsDictionary[kFIRGCMSenderID];
  263|     14|}
  264|       |
  265|      0|- (void)setGCMSenderID:(NSString *)GCMSenderID {
  266|      0|  [self checkEditingLocked];
  267|      0|  _optionsDictionary[kFIRGCMSenderID] = [GCMSenderID copy];
  268|      0|}
  269|       |
  270|      0|- (NSString *)projectID {
  271|      0|  return self.optionsDictionary[kFIRProjectID];
  272|      0|}
  273|       |
  274|      0|- (void)setProjectID:(NSString *)projectID {
  275|      0|  [self checkEditingLocked];
  276|      0|  _optionsDictionary[kFIRProjectID] = [projectID copy];
  277|      0|}
  278|       |
  279|      0|- (NSString *)androidClientID {
  280|      0|  return self.optionsDictionary[kFIRAndroidClientID];
  281|      0|}
  282|       |
  283|      0|- (void)setAndroidClientID:(NSString *)androidClientID {
  284|      0|  [self checkEditingLocked];
  285|      0|  _optionsDictionary[kFIRAndroidClientID] = [androidClientID copy];
  286|      0|}
  287|       |
  288|     84|- (NSString *)googleAppID {
  289|     84|  return self.optionsDictionary[kFIRGoogleAppID];
  290|     84|}
  291|       |
  292|      0|- (void)setGoogleAppID:(NSString *)googleAppID {
  293|      0|  [self checkEditingLocked];
  294|      0|  _optionsDictionary[kFIRGoogleAppID] = [googleAppID copy];
  295|      0|}
  296|       |
  297|     14|- (NSString *)libraryVersionID {
  298|     14|  return kFIRLibraryVersionID;
  299|     14|}
  300|       |
  301|      0|- (void)setLibraryVersionID:(NSString *)libraryVersionID {
  302|      0|  _optionsDictionary[kFIRLibraryVersionID] = [libraryVersionID copy];
  303|      0|}
  304|       |
  305|      0|- (NSString *)databaseURL {
  306|      0|  return self.optionsDictionary[kFIRDatabaseURL];
  307|      0|}
  308|       |
  309|      0|- (void)setDatabaseURL:(NSString *)databaseURL {
  310|      0|  [self checkEditingLocked];
  311|      0|
  312|      0|  _optionsDictionary[kFIRDatabaseURL] = [databaseURL copy];
  313|      0|}
  314|       |
  315|      0|- (NSString *)storageBucket {
  316|      0|  return self.optionsDictionary[kFIRStorageBucket];
  317|      0|}
  318|       |
  319|      0|- (void)setStorageBucket:(NSString *)storageBucket {
  320|      0|  [self checkEditingLocked];
  321|      0|  _optionsDictionary[kFIRStorageBucket] = [storageBucket copy];
  322|      0|}
  323|       |
  324|    154|- (void)setDeepLinkURLScheme:(NSString *)deepLinkURLScheme {
  325|    154|  [self checkEditingLocked];
  326|    154|  _deepLinkURLScheme = [deepLinkURLScheme copy];
  327|    154|}
  328|       |
  329|     42|- (NSString *)bundleID {
  330|     42|  return self.optionsDictionary[kFIRBundleID];
  331|     42|}
  332|       |
  333|      0|- (void)setBundleID:(NSString *)bundleID {
  334|      0|  [self checkEditingLocked];
  335|      0|  _optionsDictionary[kFIRBundleID] = [bundleID copy];
  336|      0|}
  337|       |
  338|       |#pragma mark - Internal instance methods
  339|       |
  340|     70|- (NSDictionary *)analyticsOptionsDictionaryWithInfoDictionary:(NSDictionary *)infoDictionary {
  341|     70|  if (_analyticsOptionsDictionary == nil) {
  342|     14|    NSMutableDictionary *tempAnalyticsOptions = [[NSMutableDictionary alloc] init];
  343|     14|    NSArray *measurementKeys = @[
  344|     14|      kFIRIsMeasurementEnabled, kFIRIsAnalyticsCollectionEnabled,
  345|     14|      kFIRIsAnalyticsCollectionDeactivated
  346|     14|    ];
  347|     42|    for (NSString *key in measurementKeys) {
  348|     42|      id value = infoDictionary[key] ?: self.optionsDictionary[key] ?: nil;
  349|     42|      if (!value) {
  350|     42|        continue;
  351|     42|      }
  352|      0|      tempAnalyticsOptions[key] = value;
  353|      0|    }
  354|     14|    _analyticsOptionsDictionary = tempAnalyticsOptions;
  355|     14|  }
  356|     70|  return _analyticsOptionsDictionary;
  357|     70|}
  358|       |
  359|     70|- (NSDictionary *)analyticsOptionsDictionary {
  360|     70|  return [self analyticsOptionsDictionaryWithInfoDictionary:[NSBundle mainBundle].infoDictionary];
  361|     70|}
  362|       |
  363|       |/**
  364|       | * Whether or not Measurement was enabled. Measurement is enabled unless explicitly disabled in
  365|       | * GoogleService-Info.plist. This uses the old plist flag IS_MEASUREMENT_ENABLED, which should still
  366|       | * be supported.
  367|       | */
  368|     14|- (BOOL)isMeasurementEnabled {
  369|     14|  if (self.isAnalyticsCollectionDeactivated) {
  370|      0|    return NO;
  371|      0|  }
  372|     14|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsMeasurementEnabled];
  373|     14|  if (value == nil) {
  374|     14|    // TODO: This could probably be cleaned up since FIROptions shouldn't know about FIRApp or have
  375|     14|    //       to check if it's the default app. The FIROptions instance can't be modified after
  376|     14|    //       `+configure` is called, so it's not a good place to copy it either in case the flag is
  377|     14|    //       changed at runtime.
  378|     14|
  379|     14|    // If no values are set for Analytics, fall back to the global collection switch in FIRApp.
  380|     14|    // Analytics only supports the default FIRApp, so check that first.
  381|     14|    if (![FIRApp isDefaultAppConfigured]) {
  382|      0|      return NO;
  383|      0|    }
  384|     14|
  385|     14|    // Fall back to the default app's collection switch when the key is not in the dictionary.
  386|     14|    return [FIRApp defaultApp].isDataCollectionDefaultEnabled;
  387|     14|  }
  388|      0|  return [value boolValue];
  389|      0|}
  390|       |
  391|      0|- (BOOL)isAnalyticsCollectionExpicitlySet {
  392|      0|  // If it's de-activated, it classifies as explicity set. If not, it's not a good enough indication
  393|      0|  // that the developer wants FirebaseAnalytics enabled so continue checking.
  394|      0|  if (self.isAnalyticsCollectionDeactivated) {
  395|      0|    return YES;
  396|      0|  }
  397|      0|
  398|      0|  // Check if the current Analytics flag is set.
  399|      0|  id collectionEnabledObject = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionEnabled];
  400|      0|  if (collectionEnabledObject && [collectionEnabledObject isKindOfClass:[NSNumber class]]) {
  401|      0|    // It doesn't matter what the value is, it's explicitly set.
  402|      0|    return YES;
  403|      0|  }
  404|      0|
  405|      0|  // Check if the old measurement flag is set.
  406|      0|  id measurementEnabledObject = self.analyticsOptionsDictionary[kFIRIsMeasurementEnabled];
  407|      0|  if (measurementEnabledObject && [measurementEnabledObject isKindOfClass:[NSNumber class]]) {
  408|      0|    // It doesn't matter what the value is, it's explicitly set.
  409|      0|    return YES;
  410|      0|  }
  411|      0|
  412|      0|  // No flags are set to explicitly enable or disable FirebaseAnalytics.
  413|      0|  return NO;
  414|      0|}
  415|       |
  416|     14|- (BOOL)isAnalyticsCollectionEnabled {
  417|     14|  if (self.isAnalyticsCollectionDeactivated) {
  418|      0|    return NO;
  419|      0|  }
  420|     14|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionEnabled];
  421|     14|  if (value == nil) {
  422|     14|    return self.isMeasurementEnabled;  // Fall back to older plist flag.
  423|     14|  }
  424|      0|  return [value boolValue];
  425|      0|}
  426|       |
  427|     42|- (BOOL)isAnalyticsCollectionDeactivated {
  428|     42|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionDeactivated];
  429|     42|  if (value == nil) {
  430|     42|    return NO;  // Analytics Collection is not deactivated when the key is not in the dictionary.
  431|     42|  }
  432|      0|  return [value boolValue];
  433|      0|}
  434|       |
  435|      0|- (BOOL)isAnalyticsEnabled {
  436|      0|  return [self.optionsDictionary[kFIRIsAnalyticsEnabled] boolValue];
  437|      0|}
  438|       |
  439|      0|- (BOOL)isSignInEnabled {
  440|      0|  return [self.optionsDictionary[kFIRIsSignInEnabled] boolValue];
  441|      0|}
  442|       |
  443|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseCore/Firebase/Core/Private/FIRComponentContainer.h:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |#import <Foundation/Foundation.h>
   17|       |
   18|       |#import "FIRComponentType.h"
   19|       |#import "FIRLibrary.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/// A type-safe macro to retrieve a component from a container. This should be used to retrieve
   24|       |/// components instead of using the container directly.
   25|       |#define FIR_COMPONENT(type, container) \
   26|     91|  [FIRComponentType<id<type>> instanceForProtocol:@protocol(type) inContainer:container]
   27|       |
   28|       |@class FIRApp;
   29|       |
   30|       |/// A container that holds different components that are registered via the
   31|       |/// `registerAsComponentRegistrant:` call. These classes should conform to `FIRComponentRegistrant`
   32|       |/// in order to properly register components for Core.
   33|       |NS_SWIFT_NAME(FirebaseComponentContainer)
   34|       |@interface FIRComponentContainer : NSObject
   35|       |
   36|       |/// A weak reference to the app that an instance of the container belongs to.
   37|       |@property(nonatomic, weak, readonly) FIRApp *app;
   38|       |
   39|       |/// Unavailable. Use the `container` property on `FIRApp`.
   40|       |- (instancetype)init NS_UNAVAILABLE;
   41|       |
   42|       |@end
   43|       |
   44|       |NS_ASSUME_NONNULL_END

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceID+Private.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceID+Private.h"
   18|       |
   19|       |#import "FIRInstanceIDAuthService.h"
   20|       |#import "FIRInstanceIDKeyPairStore.h"
   21|       |#import "FIRInstanceIDTokenManager.h"
   22|       |
   23|       |@interface FIRInstanceID ()
   24|       |
   25|       |@property(nonatomic, readonly, strong) FIRInstanceIDTokenManager *tokenManager;
   26|       |@property(nonatomic, readonly, strong) FIRInstanceIDKeyPairStore *keyPairStore;
   27|       |
   28|       |@end
   29|       |
   30|       |@implementation FIRInstanceID (Private)
   31|       |
   32|      0|- (FIRInstanceIDCheckinPreferences *)cachedCheckinPreferences {
   33|      0|  return [self.tokenManager.authService checkinPreferences];
   34|      0|}
   35|       |
   36|       |// This method just wraps our pre-configured auth service to make the request.
   37|       |// This method is only needed by first-party users, like Remote Config.
   38|      0|- (void)fetchCheckinInfoWithHandler:(FIRInstanceIDDeviceCheckinCompletion)handler {
   39|      0|  [self.tokenManager.authService fetchCheckinInfoWithHandler:handler];
   40|      0|}
   41|       |
   42|     77|- (NSString *)appInstanceID:(NSError **)error {
   43|     77|  return [self.keyPairStore appIdentityWithError:error];
   44|     77|}
   45|       |
   46|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceID.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceID.h"
   18|       |
   19|       |#import <FirebaseCore/FIRAppInternal.h>
   20|       |#import <FirebaseCore/FIRComponent.h>
   21|       |#import <FirebaseCore/FIRComponentContainer.h>
   22|       |#import <FirebaseCore/FIRLibrary.h>
   23|       |#import <FirebaseCore/FIROptions.h>
   24|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   25|       |#import "FIRInstanceID+Private.h"
   26|       |#import "FIRInstanceIDAuthService.h"
   27|       |#import "FIRInstanceIDCombinedHandler.h"
   28|       |#import "FIRInstanceIDConstants.h"
   29|       |#import "FIRInstanceIDDefines.h"
   30|       |#import "FIRInstanceIDKeyPairStore.h"
   31|       |#import "FIRInstanceIDLogger.h"
   32|       |#import "FIRInstanceIDStore.h"
   33|       |#import "FIRInstanceIDTokenInfo.h"
   34|       |#import "FIRInstanceIDTokenManager.h"
   35|       |#import "FIRInstanceIDUtilities.h"
   36|       |#import "FIRInstanceIDVersionUtilities.h"
   37|       |#import "NSError+FIRInstanceID.h"
   38|       |
   39|       |// Public constants
   40|       |NSString *const kFIRInstanceIDScopeFirebaseMessaging = @"fcm";
   41|       |
   42|       |#if defined(__IPHONE_10_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_10_0
   43|       |const NSNotificationName kFIRInstanceIDTokenRefreshNotification =
   44|       |    @"com.firebase.iid.notif.refresh-token";
   45|       |#else
   46|       |NSString *const kFIRInstanceIDTokenRefreshNotification = @"com.firebase.iid.notif.refresh-token";
   47|       |#endif  // defined(__IPHONE_10_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_10_0
   48|       |
   49|       |NSString *const kFIRInstanceIDInvalidNilHandlerError = @"Invalid nil handler.";
   50|       |
   51|       |// Private constants
   52|       |int64_t const kMaxRetryIntervalForDefaultTokenInSeconds = 20 * 60;  // 20 minutes
   53|       |int64_t const kMinRetryIntervalForDefaultTokenInSeconds = 10;       // 10 seconds
   54|       |// we retry only a max 5 times.
   55|       |// TODO(chliangGoogle): If we still fail we should listen for the network change notification
   56|       |// since GCM would have started Reachability. We only start retrying after we see a configuration
   57|       |// change.
   58|       |NSInteger const kMaxRetryCountForDefaultToken = 5;
   59|       |
   60|       |static NSString *const kEntitlementsAPSEnvironmentKey = @"Entitlements.aps-environment";
   61|       |static NSString *const kAPSEnvironmentDevelopmentValue = @"development";
   62|       |/// FIRMessaging selector that returns the current FIRMessaging auto init
   63|       |/// enabled flag.
   64|       |static NSString *const kFIRInstanceIDFCMSelectorAutoInitEnabled = @"isAutoInitEnabled";
   65|       |static NSString *const kFIRInstanceIDFCMSelectorInstance = @"messaging";
   66|       |
   67|       |static NSString *const kFIRInstanceIDAPNSTokenType = @"APNSTokenType";
   68|       |static NSString *const kFIRIIDAppReadyToConfigureSDKNotification =
   69|       |    @"FIRAppReadyToConfigureSDKNotification";
   70|       |static NSString *const kFIRIIDAppNameKey = @"FIRAppNameKey";
   71|       |static NSString *const kFIRIIDErrorDomain = @"com.firebase.instanceid";
   72|       |static NSString *const kFIRIIDServiceInstanceID = @"InstanceID";
   73|       |
   74|       |// This should be the same value as FIRErrorCodeInstanceIDFailed, which we can't import directly
   75|       |static NSInteger const kFIRIIDErrorCodeInstanceIDFailed = -121;
   76|       |
   77|       |typedef void (^FIRInstanceIDKeyPairHandler)(FIRInstanceIDKeyPair *keyPair, NSError *error);
   78|       |
   79|       |/**
   80|       | *  The APNS token type for the app. If the token type is set to `UNKNOWN`
   81|       | *  InstanceID will implicitly try to figure out what the actual token type
   82|       | *  is from the provisioning profile.
   83|       | *  This must match FIRMessagingAPNSTokenType in FIRMessaging.h
   84|       | */
   85|       |typedef NS_ENUM(NSInteger, FIRInstanceIDAPNSTokenType) {
   86|       |  /// Unknown token type.
   87|       |  FIRInstanceIDAPNSTokenTypeUnknown,
   88|       |  /// Sandbox token type.
   89|       |  FIRInstanceIDAPNSTokenTypeSandbox,
   90|       |  /// Production token type.
   91|       |  FIRInstanceIDAPNSTokenTypeProd,
   92|       |} NS_SWIFT_NAME(InstanceIDAPNSTokenType);
   93|       |
   94|       |@interface FIRInstanceIDResult ()
   95|       |@property(nonatomic, readwrite, copy) NSString *instanceID;
   96|       |@property(nonatomic, readwrite, copy) NSString *token;
   97|       |@end
   98|       |
   99|       |@interface FIRInstanceID ()
  100|       |
  101|       |// FIRApp configuration objects.
  102|       |@property(nonatomic, readwrite, copy) NSString *fcmSenderID;
  103|       |@property(nonatomic, readwrite, copy) NSString *firebaseAppID;
  104|       |
  105|       |// Raw APNS token data
  106|       |@property(nonatomic, readwrite, strong) NSData *apnsTokenData;
  107|       |
  108|       |@property(nonatomic, readwrite) FIRInstanceIDAPNSTokenType apnsTokenType;
  109|       |// String-based, internal representation of APNS token
  110|       |@property(nonatomic, readwrite, copy) NSString *APNSTupleString;
  111|       |// Token fetched from the server automatically for the default app.
  112|       |@property(nonatomic, readwrite, copy) NSString *defaultFCMToken;
  113|       |
  114|       |@property(nonatomic, readwrite, strong) FIRInstanceIDTokenManager *tokenManager;
  115|       |@property(nonatomic, readwrite, strong) FIRInstanceIDKeyPairStore *keyPairStore;
  116|       |
  117|       |// backoff and retry for default token
  118|       |@property(nonatomic, readwrite, assign) NSInteger retryCountForDefaultToken;
  119|       |@property(atomic, strong, nullable)
  120|       |    FIRInstanceIDCombinedHandler<NSString *> *defaultTokenFetchHandler;
  121|       |
  122|       |@end
  123|       |
  124|       |// InstanceID doesn't provide any functionality to other components,
  125|       |// so it provides a private, empty protocol that it conforms to and use it for registration.
  126|       |
  127|       |@protocol FIRInstanceIDInstanceProvider
  128|       |@end
  129|       |
  130|       |@interface FIRInstanceID () <FIRInstanceIDInstanceProvider, FIRLibrary>
  131|       |@end
  132|       |
  133|       |@implementation FIRInstanceIDResult
  134|      0|- (id)copyWithZone:(NSZone *)zone {
  135|      0|  FIRInstanceIDResult *result = [[[self class] allocWithZone:zone] init];
  136|      0|  result.instanceID = self.instanceID;
  137|      0|  result.token = self.token;
  138|      0|  return result;
  139|      0|}
  140|       |@end
  141|       |
  142|       |@implementation FIRInstanceID
  143|       |
  144|       |// File static to support InstanceID tests that call [FIRInstanceID instanceID] after
  145|       |// [FIRInstanceID instanceIDForTests].
  146|       |static FIRInstanceID *gInstanceID;
  147|       |
  148|     91|+ (instancetype)instanceID {
  149|     91|  // If the static instance was created, return it. This should only be set in tests and we should
  150|     91|  // eventually use proper dependency injection for a better test structure.
  151|     91|  if (gInstanceID != nil) {
  152|      0|    return gInstanceID;
  153|      0|  }
  154|     91|  FIRApp *defaultApp = [FIRApp defaultApp];  // Missing configure will be logged here.
  155|     91|  FIRInstanceID *instanceID =
  156|     91|      (FIRInstanceID *)FIR_COMPONENT(FIRInstanceIDInstanceProvider, defaultApp.container);
  157|     91|  return instanceID;
  158|     91|}
  159|       |
  160|     14|- (instancetype)initPrivately {
  161|     14|  self = [super init];
  162|     14|  if (self != nil) {
  163|     14|    // Use automatic detection of sandbox, unless otherwise set by developer
  164|     14|    _apnsTokenType = FIRInstanceIDAPNSTokenTypeUnknown;
  165|     14|  }
  166|     14|  return self;
  167|     14|}
  168|       |
  169|      0|+ (FIRInstanceID *)instanceIDForTests {
  170|      0|  gInstanceID = [[FIRInstanceID alloc] initPrivately];
  171|      0|  [gInstanceID start];
  172|      0|  return gInstanceID;
  173|      0|}
  174|       |
  175|      0|- (void)dealloc {
  176|      0|  [[NSNotificationCenter defaultCenter] removeObserver:self];
  177|      0|}
  178|       |
  179|       |#pragma mark - Tokens
  180|       |
  181|      0|- (NSString *)token {
  182|      0|  if (!self.fcmSenderID.length) {
  183|      0|    return nil;
  184|      0|  }
  185|      0|
  186|      0|  NSString *cachedToken = [self cachedTokenIfAvailable];
  187|      0|
  188|      0|  if (cachedToken) {
  189|      0|    return cachedToken;
  190|      0|  } else {
  191|      0|    // If we've never had a cached default token, we should fetch one because unrelatedly,
  192|      0|    // this request will help us determine whether the locally-generated Instance ID keypair is not
  193|      0|    // unique, and therefore generate a new one.
  194|      0|    [self defaultTokenWithHandler:nil];
  195|      0|    return nil;
  196|      0|  }
  197|      0|}
  198|       |
  199|      0|- (void)instanceIDWithHandler:(FIRInstanceIDResultHandler)handler {
  200|      0|  FIRInstanceID_WEAKIFY(self);
  201|      0|  [self getIDWithHandler:^(NSString *identity, NSError *error) {
  202|      0|    FIRInstanceID_STRONGIFY(self);
  203|      0|    // This is in main queue already
  204|      0|    if (error) {
  205|      0|      if (handler) {
  206|      0|        handler(nil, error);
  207|      0|      }
  208|      0|      return;
  209|      0|    }
  210|      0|    FIRInstanceIDResult *result = [[FIRInstanceIDResult alloc] init];
  211|      0|    result.instanceID = identity;
  212|      0|    NSString *cachedToken = [self cachedTokenIfAvailable];
  213|      0|    if (cachedToken) {
  214|      0|      if (handler) {
  215|      0|        result.token = cachedToken;
  216|      0|        handler(result, nil);
  217|      0|      }
  218|      0|      // If no handler, simply return since client has generated iid and token.
  219|      0|      return;
  220|      0|    }
  221|      0|    [self defaultTokenWithHandler:^(NSString *_Nullable token, NSError *_Nullable error) {
  222|      0|      if (handler) {
  223|      0|        if (error) {
  224|      0|          handler(nil, error);
  225|      0|          return;
  226|      0|        }
  227|      0|        result.token = token;
  228|      0|        handler(result, nil);
  229|      0|      }
  230|      0|    }];
  231|      0|  }];
  232|      0|}
  233|       |
  234|     14|- (NSString *)cachedTokenIfAvailable {
  235|     14|  FIRInstanceIDTokenInfo *cachedTokenInfo =
  236|     14|      [self.tokenManager cachedTokenInfoWithAuthorizedEntity:self.fcmSenderID
  237|     14|                                                       scope:kFIRInstanceIDDefaultTokenScope];
  238|     14|  return cachedTokenInfo.token;
  239|     14|}
  240|       |
  241|      0|- (void)setDefaultFCMToken:(NSString *)defaultFCMToken {
  242|      0|  if (_defaultFCMToken && defaultFCMToken && [defaultFCMToken isEqualToString:_defaultFCMToken]) {
  243|      0|    return;
  244|      0|  }
  245|      0|
  246|      0|  _defaultFCMToken = defaultFCMToken;
  247|      0|
  248|      0|  // Sending this notification out will ensure that FIRMessaging has the updated
  249|      0|  // default FCM token.
  250|      0|  NSNotification *internalDefaultTokenNotification =
  251|      0|      [NSNotification notificationWithName:kFIRInstanceIDDefaultGCMTokenNotification
  252|      0|                                    object:_defaultFCMToken];
  253|      0|  [[NSNotificationQueue defaultQueue] enqueueNotification:internalDefaultTokenNotification
  254|      0|                                             postingStyle:NSPostASAP];
  255|      0|}
  256|       |
  257|       |- (void)tokenWithAuthorizedEntity:(NSString *)authorizedEntity
  258|       |                            scope:(NSString *)scope
  259|       |                          options:(NSDictionary *)options
  260|      0|                          handler:(FIRInstanceIDTokenHandler)handler {
  261|      0|  _FIRInstanceIDDevAssert(handler != nil && [authorizedEntity length] && [scope length],
  262|      0|                          @"Invalid authorizedEntity or scope to new token");
  263|      0|  if (!handler) {
  264|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeInstanceID000,
  265|      0|                             kFIRInstanceIDInvalidNilHandlerError);
  266|      0|    return;
  267|      0|  }
  268|      0|
  269|      0|  NSMutableDictionary *tokenOptions = [NSMutableDictionary dictionary];
  270|      0|  if (options.count) {
  271|      0|    [tokenOptions addEntriesFromDictionary:options];
  272|      0|  }
  273|      0|
  274|      0|  NSString *APNSKey = kFIRInstanceIDTokenOptionsAPNSKey;
  275|      0|  NSString *serverTypeKey = kFIRInstanceIDTokenOptionsAPNSIsSandboxKey;
  276|      0|
  277|      0|  if (tokenOptions[APNSKey] != nil && tokenOptions[serverTypeKey] == nil) {
  278|      0|    // APNS key was given, but server type is missing. Supply the server type with automatic
  279|      0|    // checking. This can happen when the token is requested from FCM, which does not include a
  280|      0|    // server type during its request.
  281|      0|    tokenOptions[serverTypeKey] = @([self isSandboxApp]);
  282|      0|  }
  283|      0|
  284|      0|  // comparing enums to ints directly throws a warning
  285|      0|  FIRInstanceIDErrorCode noError = INT_MAX;
  286|      0|  FIRInstanceIDErrorCode errorCode = noError;
  287|      0|  if (FIRInstanceIDIsValidGCMScope(scope) && !tokenOptions[APNSKey]) {
  288|      0|    errorCode = kFIRInstanceIDErrorCodeMissingAPNSToken;
  289|      0|  } else if (FIRInstanceIDIsValidGCMScope(scope) &&
  290|      0|             ![tokenOptions[APNSKey] isKindOfClass:[NSData class]]) {
  291|      0|    errorCode = kFIRInstanceIDErrorCodeInvalidRequest;
  292|      0|  } else if (![authorizedEntity length]) {
  293|      0|    errorCode = kFIRInstanceIDErrorCodeInvalidAuthorizedEntity;
  294|      0|  } else if (![scope length]) {
  295|      0|    errorCode = kFIRInstanceIDErrorCodeInvalidScope;
  296|      0|  } else if (!self.keyPairStore) {
  297|      0|    errorCode = kFIRInstanceIDErrorCodeInvalidStart;
  298|      0|  }
  299|      0|
  300|      0|  FIRInstanceIDTokenHandler newHandler = ^(NSString *token, NSError *error) {
  301|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  302|      0|      handler(token, error);
  303|      0|    });
  304|      0|  };
  305|      0|
  306|      0|  if (errorCode != noError) {
  307|      0|    newHandler(nil, [NSError errorWithFIRInstanceIDErrorCode:errorCode]);
  308|      0|    return;
  309|      0|  }
  310|      0|
  311|      0|  // TODO(chliangGoogle): Add some validation logic that the APNs token data and sandbox value are
  312|      0|  // supplied in the valid format (NSData and BOOL, respectively).
  313|      0|
  314|      0|  // Add internal options
  315|      0|  if (self.firebaseAppID) {
  316|      0|    tokenOptions[kFIRInstanceIDTokenOptionsFirebaseAppIDKey] = self.firebaseAppID;
  317|      0|  }
  318|      0|
  319|      0|  FIRInstanceID_WEAKIFY(self);
  320|      0|  FIRInstanceIDAuthService *authService = self.tokenManager.authService;
  321|      0|  [authService
  322|      0|      fetchCheckinInfoWithHandler:^(FIRInstanceIDCheckinPreferences *preferences, NSError *error) {
  323|      0|        FIRInstanceID_STRONGIFY(self);
  324|      0|        if (error) {
  325|      0|          newHandler(nil, error);
  326|      0|          return;
  327|      0|        }
  328|      0|
  329|      0|        // Only use the token in the cache if the APNSInfo matches what the request's options has.
  330|      0|        // It's possible for the request to be with a newer APNs device token, which should be
  331|      0|        // honored.
  332|      0|        FIRInstanceIDTokenInfo *cachedTokenInfo =
  333|      0|            [self.tokenManager cachedTokenInfoWithAuthorizedEntity:authorizedEntity scope:scope];
  334|      0|        if (cachedTokenInfo) {
  335|      0|          // Ensure that the cached token matches APNs data before returning it.
  336|      0|          FIRInstanceIDAPNSInfo *optionsAPNSInfo =
  337|      0|              [[FIRInstanceIDAPNSInfo alloc] initWithTokenOptionsDictionary:tokenOptions];
  338|      0|          // If either the APNs info is missing in both, or if they are an exact match, then we can
  339|      0|          // use this cached token.
  340|      0|          if ((!cachedTokenInfo.APNSInfo && !optionsAPNSInfo) ||
  341|      0|              [cachedTokenInfo.APNSInfo isEqualToAPNSInfo:optionsAPNSInfo]) {
  342|      0|            newHandler(cachedTokenInfo.token, nil);
  343|      0|            return;
  344|      0|          }
  345|      0|        }
  346|      0|
  347|      0|        FIRInstanceID_WEAKIFY(self);
  348|      0|        [self asyncLoadKeyPairWithHandler:^(FIRInstanceIDKeyPair *keyPair, NSError *error) {
  349|      0|          FIRInstanceID_STRONGIFY(self);
  350|      0|
  351|      0|          if (error) {
  352|      0|            NSError *newError =
  353|      0|                [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeInvalidKeyPair];
  354|      0|            newHandler(nil, newError);
  355|      0|
  356|      0|          } else {
  357|      0|            [self.tokenManager fetchNewTokenWithAuthorizedEntity:[authorizedEntity copy]
  358|      0|                                                           scope:[scope copy]
  359|      0|                                                         keyPair:keyPair
  360|      0|                                                         options:tokenOptions
  361|      0|                                                         handler:newHandler];
  362|      0|          }
  363|      0|        }];
  364|      0|      }];
  365|      0|}
  366|       |
  367|       |- (void)deleteTokenWithAuthorizedEntity:(NSString *)authorizedEntity
  368|       |                                  scope:(NSString *)scope
  369|      0|                                handler:(FIRInstanceIDDeleteTokenHandler)handler {
  370|      0|  _FIRInstanceIDDevAssert(handler != nil && [authorizedEntity length] && [scope length],
  371|      0|                          @"Invalid authorizedEntity or scope to delete token");
  372|      0|
  373|      0|  if (!handler) {
  374|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeInstanceID001,
  375|      0|                             kFIRInstanceIDInvalidNilHandlerError);
  376|      0|  }
  377|      0|
  378|      0|  // comparing enums to ints directly throws a warning
  379|      0|  FIRInstanceIDErrorCode noError = INT_MAX;
  380|      0|  FIRInstanceIDErrorCode errorCode = noError;
  381|      0|
  382|      0|  if (![authorizedEntity length]) {
  383|      0|    errorCode = kFIRInstanceIDErrorCodeInvalidAuthorizedEntity;
  384|      0|  } else if (![scope length]) {
  385|      0|    errorCode = kFIRInstanceIDErrorCodeInvalidScope;
  386|      0|  } else if (!self.keyPairStore) {
  387|      0|    errorCode = kFIRInstanceIDErrorCodeInvalidStart;
  388|      0|  }
  389|      0|
  390|      0|  FIRInstanceIDDeleteTokenHandler newHandler = ^(NSError *error) {
  391|      0|    // If a default token is deleted successfully, reset the defaultFCMToken too.
  392|      0|    if (!error && [authorizedEntity isEqualToString:self.fcmSenderID] &&
  393|      0|        [scope isEqualToString:kFIRInstanceIDDefaultTokenScope]) {
  394|      0|      self.defaultFCMToken = nil;
  395|      0|    }
  396|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  397|      0|      handler(error);
  398|      0|    });
  399|      0|  };
  400|      0|
  401|      0|  if (errorCode != noError) {
  402|      0|    newHandler([NSError errorWithFIRInstanceIDErrorCode:errorCode]);
  403|      0|    return;
  404|      0|  }
  405|      0|
  406|      0|  FIRInstanceID_WEAKIFY(self);
  407|      0|  FIRInstanceIDAuthService *authService = self.tokenManager.authService;
  408|      0|  [authService
  409|      0|      fetchCheckinInfoWithHandler:^(FIRInstanceIDCheckinPreferences *preferences, NSError *error) {
  410|      0|        FIRInstanceID_STRONGIFY(self);
  411|      0|        if (error) {
  412|      0|          newHandler(error);
  413|      0|          return;
  414|      0|        }
  415|      0|
  416|      0|        FIRInstanceID_WEAKIFY(self);
  417|      0|        [self asyncLoadKeyPairWithHandler:^(FIRInstanceIDKeyPair *keyPair, NSError *error) {
  418|      0|          FIRInstanceID_STRONGIFY(self);
  419|      0|          if (error) {
  420|      0|            NSError *newError =
  421|      0|                [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeInvalidKeyPair];
  422|      0|            newHandler(newError);
  423|      0|
  424|      0|          } else {
  425|      0|            [self.tokenManager deleteTokenWithAuthorizedEntity:authorizedEntity
  426|      0|                                                         scope:scope
  427|      0|                                                       keyPair:keyPair
  428|      0|                                                       handler:newHandler];
  429|      0|          }
  430|      0|        }];
  431|      0|      }];
  432|      0|}
  433|       |
  434|      0|- (void)asyncLoadKeyPairWithHandler:(FIRInstanceIDKeyPairHandler)handler {
  435|      0|  FIRInstanceID_WEAKIFY(self);
  436|      0|  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
  437|      0|    FIRInstanceID_STRONGIFY(self);
  438|      0|
  439|      0|    NSError *error = nil;
  440|      0|    FIRInstanceIDKeyPair *keyPair = [self.keyPairStore loadKeyPairWithError:&error];
  441|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  442|      0|      if (error) {
  443|      0|        FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeInstanceID002,
  444|      0|                                 @"Failed to retreieve keyPair %@", error);
  445|      0|        if (handler) {
  446|      0|          handler(nil, error);
  447|      0|        }
  448|      0|      } else if (!keyPair && !error) {
  449|      0|        if (handler) {
  450|      0|          handler(nil,
  451|      0|                  [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeInvalidKeyPair]);
  452|      0|        }
  453|      0|      } else {
  454|      0|        if (handler) {
  455|      0|          handler(keyPair, nil);
  456|      0|        }
  457|      0|      }
  458|      0|    });
  459|      0|  });
  460|      0|}
  461|       |
  462|       |#pragma mark - Identity
  463|       |
  464|      0|- (void)getIDWithHandler:(FIRInstanceIDHandler)handler {
  465|      0|  _FIRInstanceIDDevAssert(handler, @"Invalid nil handler to getIdentity");
  466|      0|
  467|      0|  if (!handler) {
  468|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeInstanceID003,
  469|      0|                             kFIRInstanceIDInvalidNilHandlerError);
  470|      0|    return;
  471|      0|  }
  472|      0|
  473|      0|  void (^callHandlerOnMainThread)(NSString *, NSError *) = ^(NSString *identity, NSError *error) {
  474|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  475|      0|      handler(identity, error);
  476|      0|    });
  477|      0|  };
  478|      0|
  479|      0|  if (!self.keyPairStore) {
  480|      0|    NSError *error = [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeInvalidStart];
  481|      0|    callHandlerOnMainThread(nil, error);
  482|      0|    return;
  483|      0|  }
  484|      0|
  485|      0|  FIRInstanceID_WEAKIFY(self);
  486|      0|  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
  487|      0|    FIRInstanceID_STRONGIFY(self);
  488|      0|    NSError *error;
  489|      0|    NSString *appIdentity = [self.keyPairStore appIdentityWithError:&error];
  490|      0|    // When getID is explicitly called, trigger getToken to make sure token always exists.
  491|      0|    // This is to avoid ID conflict (ID is not checked for conflict until we generate a token)
  492|      0|    if (appIdentity) {
  493|      0|#pragma clang diagnostic push
  494|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  495|      0|      [self token];
  496|      0|#pragma clang diagnostic pop
  497|      0|    }
  498|      0|    callHandlerOnMainThread(appIdentity, error);
  499|      0|  });
  500|      0|}
  501|       |
  502|      0|- (void)deleteIDWithHandler:(FIRInstanceIDDeleteHandler)handler {
  503|      0|  _FIRInstanceIDDevAssert(handler, @"Invalid nil handler to delete Identity");
  504|      0|
  505|      0|  if (!handler) {
  506|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeInstanceID004,
  507|      0|                             kFIRInstanceIDInvalidNilHandlerError);
  508|      0|    return;
  509|      0|  }
  510|      0|
  511|      0|  void (^callHandlerOnMainThread)(NSError *) = ^(NSError *error) {
  512|      0|    if ([NSThread isMainThread]) {
  513|      0|      handler(error);
  514|      0|      return;
  515|      0|    }
  516|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  517|      0|      handler(error);
  518|      0|    });
  519|      0|  };
  520|      0|
  521|      0|  if (!self.keyPairStore) {
  522|      0|    FIRInstanceIDErrorCode error = kFIRInstanceIDErrorCodeInvalidStart;
  523|      0|    callHandlerOnMainThread([NSError errorWithFIRInstanceIDErrorCode:error]);
  524|      0|    return;
  525|      0|  }
  526|      0|
  527|      0|  FIRInstanceID_WEAKIFY(self);
  528|      0|  void (^deleteTokensHandler)(NSError *) = ^void(NSError *error) {
  529|      0|    FIRInstanceID_STRONGIFY(self);
  530|      0|    if (error) {
  531|      0|      callHandlerOnMainThread(error);
  532|      0|      return;
  533|      0|    }
  534|      0|    [self deleteIdentityWithHandler:^(NSError *error) {
  535|      0|      callHandlerOnMainThread(error);
  536|      0|    }];
  537|      0|  };
  538|      0|
  539|      0|  [self asyncLoadKeyPairWithHandler:^(FIRInstanceIDKeyPair *keyPair, NSError *error) {
  540|      0|    FIRInstanceID_STRONGIFY(self);
  541|      0|    if (error) {
  542|      0|      NSError *newError =
  543|      0|          [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeInvalidKeyPair];
  544|      0|      callHandlerOnMainThread(newError);
  545|      0|    } else {
  546|      0|      [self.tokenManager deleteAllTokensWithKeyPair:keyPair handler:deleteTokensHandler];
  547|      0|    }
  548|      0|  }];
  549|      0|}
  550|       |
  551|      0|- (void)notifyIdentityReset {
  552|      0|  [self deleteIdentityWithHandler:nil];
  553|      0|}
  554|       |
  555|       |// Delete all the local cache checkin, IID and token.
  556|      0|- (void)deleteIdentityWithHandler:(FIRInstanceIDDeleteHandler)handler {
  557|      0|  // Delete tokens.
  558|      0|  [self.tokenManager deleteAllTokensLocallyWithHandler:^(NSError *deleteTokenError) {
  559|      0|    // Reset FCM token.
  560|      0|    self.defaultFCMToken = nil;
  561|      0|    if (deleteTokenError) {
  562|      0|      if (handler) {
  563|      0|        handler(deleteTokenError);
  564|      0|      }
  565|      0|      return;
  566|      0|    }
  567|      0|
  568|      0|    // Delete Instance ID.
  569|      0|    [self.keyPairStore
  570|      0|        deleteSavedKeyPairWithSubtype:kFIRInstanceIDKeyPairSubType
  571|      0|                              handler:^(NSError *error) {
  572|      0|                                NSError *deletePlistError;
  573|      0|                                [self.keyPairStore
  574|      0|                                    removeKeyPairCreationTimePlistWithError:&deletePlistError];
  575|      0|                                if (error || deletePlistError) {
  576|      0|                                  if (handler) {
  577|      0|                                    // Prefer to use the delete Instance ID error.
  578|      0|                                    error = [NSError
  579|      0|                                        errorWithFIRInstanceIDErrorCode:
  580|      0|                                            kFIRInstanceIDErrorCodeUnknown
  581|      0|                                                               userInfo:@{
  582|      0|                                                                 NSUnderlyingErrorKey : error
  583|      0|                                                                     ? error
  584|      0|                                                                     : deletePlistError
  585|      0|                                                               }];
  586|      0|                                    handler(error);
  587|      0|                                  }
  588|      0|                                  return;
  589|      0|                                }
  590|      0|                                // Delete checkin.
  591|      0|                                [self.tokenManager.authService
  592|      0|                                    resetCheckinWithHandler:^(NSError *error) {
  593|      0|                                      if (error) {
  594|      0|                                        if (handler) {
  595|      0|                                          handler(error);
  596|      0|                                        }
  597|      0|                                        return;
  598|      0|                                      }
  599|      0|                                      // Only request new token if FCM auto initialization is
  600|      0|                                      // enabled.
  601|      0|                                      if ([self isFCMAutoInitEnabled]) {
  602|      0|                                        // Deletion succeeds! Requesting new checkin, IID and token.
  603|      0|                                        // TODO(chliangGoogle) see if dispatch_after is necessary
  604|      0|                                        dispatch_after(dispatch_time(DISPATCH_TIME_NOW,
  605|      0|                                                                     (int64_t)(0.5 * NSEC_PER_SEC)),
  606|      0|                                                       dispatch_get_main_queue(), ^{
  607|      0|                                                         [self defaultTokenWithHandler:nil];
  608|      0|                                                       });
  609|      0|                                      }
  610|      0|                                      if (handler) {
  611|      0|                                        handler(nil);
  612|      0|                                      }
  613|      0|                                    }];
  614|      0|                              }];
  615|      0|  }];
  616|      0|}
  617|       |
  618|       |#pragma mark - Config
  619|       |
  620|     14|+ (void)load {
  621|     14|  [FIRApp registerInternalLibrary:(Class<FIRLibrary>)self
  622|     14|                         withName:@"fire-iid"
  623|     14|                      withVersion:FIRInstanceIDCurrentLibraryVersion()];
  624|     14|}
  625|       |
  626|     14|+ (nonnull NSArray<FIRComponent *> *)componentsToRegister {
  627|     14|  FIRComponentCreationBlock creationBlock =
  628|     14|      ^id _Nullable(FIRComponentContainer *container, BOOL *isCacheable) {
  629|     14|    // Ensure it's cached so it returns the same instance every time instanceID is called.
  630|     14|    *isCacheable = YES;
  631|     14|    FIRInstanceID *instanceID = [[FIRInstanceID alloc] initPrivately];
  632|     14|    [instanceID start];
  633|     14|    return instanceID;
  634|     14|  };
  635|     14|  FIRComponent *instanceIDProvider =
  636|     14|      [FIRComponent componentWithProtocol:@protocol(FIRInstanceIDInstanceProvider)
  637|     14|                      instantiationTiming:FIRInstantiationTimingLazy
  638|     14|                             dependencies:@[]
  639|     14|                            creationBlock:creationBlock];
  640|     14|  return @[ instanceIDProvider ];
  641|     14|}
  642|       |
  643|     14|+ (void)configureWithApp:(FIRApp *)app {
  644|     14|  if (!app.isDefaultApp) {
  645|      0|    // Only configure for the default FIRApp.
  646|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeFIRApp002,
  647|      0|                             @"Firebase Instance ID only works with the default app.");
  648|      0|    return;
  649|      0|  }
  650|     14|  [[FIRInstanceID instanceID] configureInstanceIDWithOptions:app.options app:app];
  651|     14|}
  652|       |
  653|     14|- (void)configureInstanceIDWithOptions:(FIROptions *)options app:(FIRApp *)firApp {
  654|     14|  NSString *GCMSenderID = options.GCMSenderID;
  655|     14|  if (!GCMSenderID.length) {
  656|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeFIRApp000,
  657|      0|                             @"Firebase not set up correctly, nil or empty senderID.");
  658|      0|    [FIRInstanceID exitWithReason:@"GCM_SENDER_ID must not be nil or empty." forFirebaseApp:firApp];
  659|      0|    return;
  660|      0|  }
  661|     14|
  662|     14|  self.fcmSenderID = GCMSenderID;
  663|     14|  self.firebaseAppID = firApp.options.googleAppID;
  664|     14|
  665|     14|  // FCM generates a FCM token during app start for sending push notification to device.
  666|     14|  // This is not needed for app extension.
  667|     14|  if (![GULAppEnvironmentUtil isAppExtension]) {
  668|     14|    [self didCompleteConfigure];
  669|     14|  }
  670|     14|}
  671|       |
  672|      0|+ (NSError *)configureErrorWithReason:(nonnull NSString *)reason {
  673|      0|  NSString *description =
  674|      0|      [NSString stringWithFormat:@"Configuration failed for service %@.", kFIRIIDServiceInstanceID];
  675|      0|  if (!reason.length) {
  676|      0|    reason = @"Unknown reason";
  677|      0|  }
  678|      0|
  679|      0|  NSDictionary *userInfo =
  680|      0|      @{NSLocalizedDescriptionKey : description, NSLocalizedFailureReasonErrorKey : reason};
  681|      0|
  682|      0|  return [NSError errorWithDomain:kFIRIIDErrorDomain
  683|      0|                             code:kFIRIIDErrorCodeInstanceIDFailed
  684|      0|                         userInfo:userInfo];
  685|      0|}
  686|       |
  687|       |// If the firebaseApp is available we should send logs for the error through it before
  688|       |// raising an exception.
  689|      0|+ (void)exitWithReason:(nonnull NSString *)reason forFirebaseApp:(FIRApp *)firebaseApp {
  690|      0|  [firebaseApp sendLogsWithServiceName:kFIRIIDServiceInstanceID
  691|      0|                               version:FIRInstanceIDCurrentLibraryVersion()
  692|      0|                                 error:[self configureErrorWithReason:reason]];
  693|      0|
  694|      0|  [NSException raise:kFIRIIDErrorDomain
  695|      0|              format:@"Could not configure Firebase InstanceID. %@", reason];
  696|      0|}
  697|       |
  698|       |// This is used to start any operations when we receive FirebaseSDK setup notification
  699|       |// from FIRCore.
  700|     14|- (void)didCompleteConfigure {
  701|     14|  NSString *cachedToken = [self cachedTokenIfAvailable];
  702|     14|  // When there is a cached token, do the token refresh.
  703|     14|  if (cachedToken) {
  704|      0|    // Clean up expired tokens by checking the token refresh policy.
  705|      0|    if ([self.tokenManager checkForTokenRefreshPolicy]) {
  706|      0|      // Default token is expired, fetch default token from server.
  707|      0|      [self defaultTokenWithHandler:nil];
  708|      0|    }
  709|      0|    // Notify FCM with the default token.
  710|      0|#pragma clang diagnostic push
  711|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  712|      0|    self.defaultFCMToken = [self token];
  713|      0|#pragma clang diagnostic pop
  714|     14|  } else if ([self isFCMAutoInitEnabled]) {
  715|      0|    // When there is no cached token, must check auto init is enabled.
  716|      0|    // If it's disabled, don't initiate token generation/refresh.
  717|      0|    // If no cache token and auto init is enabled, fetch a token from server.
  718|      0|    [self defaultTokenWithHandler:nil];
  719|      0|    // Notify FCM with the default token.
  720|      0|#pragma clang diagnostic push
  721|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  722|      0|    self.defaultFCMToken = [self token];
  723|      0|#pragma clang diagnostic pop
  724|      0|  }
  725|     14|  // ONLY checkin when auto data collection is turned on.
  726|     14|  if ([self isFCMAutoInitEnabled]) {
  727|      0|    [self.tokenManager.authService scheduleCheckin:YES];
  728|      0|  }
  729|     14|}
  730|       |
  731|     28|- (BOOL)isFCMAutoInitEnabled {
  732|     28|  Class messagingClass = NSClassFromString(kFIRInstanceIDFCMSDKClassString);
  733|     28|  // Firebase Messaging is not installed, auto init should be disabled since it's for FCM.
  734|     28|  if (!messagingClass) {
  735|     28|    return NO;
  736|     28|  }
  737|      0|
  738|      0|  // Messaging doesn't have the singleton method, auto init should be enabled since FCM exists.
  739|      0|  SEL instanceSelector = NSSelectorFromString(kFIRInstanceIDFCMSelectorInstance);
  740|      0|  if (![messagingClass respondsToSelector:instanceSelector]) {
  741|      0|    return YES;
  742|      0|  }
  743|      0|
  744|      0|  // Get FIRMessaging shared instance.
  745|      0|  IMP messagingInstanceIMP = [messagingClass methodForSelector:instanceSelector];
  746|      0|  id (*getMessagingInstance)(id, SEL) = (void *)messagingInstanceIMP;
  747|      0|  id messagingInstance = getMessagingInstance(messagingClass, instanceSelector);
  748|      0|
  749|      0|  // Messaging doesn't have the property, auto init should be enabled since FCM exists.
  750|      0|  SEL autoInitSelector = NSSelectorFromString(kFIRInstanceIDFCMSelectorAutoInitEnabled);
  751|      0|  if (![messagingInstance respondsToSelector:autoInitSelector]) {
  752|      0|    return YES;
  753|      0|  }
  754|      0|
  755|      0|  // Get autoInitEnabled method.
  756|      0|  IMP isAutoInitEnabledIMP = [messagingInstance methodForSelector:autoInitSelector];
  757|      0|  BOOL (*isAutoInitEnabled)(id, SEL) = (BOOL(*)(id, SEL))isAutoInitEnabledIMP;
  758|      0|
  759|      0|  // Check FCM's isAutoInitEnabled property.
  760|      0|  return isAutoInitEnabled(messagingInstance, autoInitSelector);
  761|      0|}
  762|       |
  763|       |// Actually makes InstanceID instantiate both the IID and Token-related subsystems.
  764|     14|- (void)start {
  765|     14|  if (![FIRInstanceIDStore hasSubDirectory:kFIRInstanceIDSubDirectoryName]) {
  766|      0|    [FIRInstanceIDStore createSubDirectory:kFIRInstanceIDSubDirectoryName];
  767|      0|  }
  768|     14|
  769|     14|  [self setupTokenManager];
  770|     14|  [self setupKeyPairManager];
  771|     14|  [self setupNotificationListeners];
  772|     14|}
  773|       |
  774|       |// Creates the token manager, which is used for fetching, caching, and retrieving tokens.
  775|     14|- (void)setupTokenManager {
  776|     14|  self.tokenManager = [[FIRInstanceIDTokenManager alloc] init];
  777|     14|}
  778|       |
  779|       |// Creates a key pair manager, which stores the public/private keys needed to generate an
  780|       |// application instance ID.
  781|     14|- (void)setupKeyPairManager {
  782|     14|  self.keyPairStore = [[FIRInstanceIDKeyPairStore alloc] init];
  783|     14|  if ([self.keyPairStore invalidateKeyPairsIfNeeded]) {
  784|      1|    // Reset tokens right away when keypair is deleted, otherwise async call can make first query
  785|      1|    // of token happens before reset old tokens during app start.
  786|      1|    // TODO(chliangGoogle): Delete all tokens on server too, using
  787|      1|    // deleteAllTokensWithKeyPair:handler:. This requires actually retrieving the invalid keypair
  788|      1|    // from Keychain, which is something that the key pair store does not currently do.
  789|      1|    [self.tokenManager deleteAllTokensLocallyWithHandler:nil];
  790|      1|  }
  791|     14|}
  792|       |
  793|     14|- (void)setupNotificationListeners {
  794|     14|  // To prevent double notifications remove observer from all events during setup.
  795|     14|  NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
  796|     14|  [center removeObserver:self];
  797|     14|  [center addObserver:self
  798|     14|             selector:@selector(notifyIdentityReset)
  799|     14|                 name:kFIRInstanceIDIdentityInvalidatedNotification
  800|     14|               object:nil];
  801|     14|  [center addObserver:self
  802|     14|             selector:@selector(notifyAPNSTokenIsSet:)
  803|     14|                 name:kFIRInstanceIDAPNSTokenNotification
  804|     14|               object:nil];
  805|     14|}
  806|       |
  807|       |#pragma mark - Private Helpers
  808|       |/// Maximum retry count to fetch the default token.
  809|      0|+ (int64_t)maxRetryCountForDefaultToken {
  810|      0|  return kMaxRetryCountForDefaultToken;
  811|      0|}
  812|       |
  813|       |/// Minimum interval in seconds between retries to fetch the default token.
  814|      0|+ (int64_t)minIntervalForDefaultTokenRetry {
  815|      0|  return kMinRetryIntervalForDefaultTokenInSeconds;
  816|      0|}
  817|       |
  818|       |/// Maximum retry interval between retries to fetch default token.
  819|      0|+ (int64_t)maxRetryIntervalForDefaultTokenInSeconds {
  820|      0|  return kMaxRetryIntervalForDefaultTokenInSeconds;
  821|      0|}
  822|       |
  823|      0|- (NSInteger)retryIntervalToFetchDefaultToken {
  824|      0|  if (self.retryCountForDefaultToken >= [[self class] maxRetryCountForDefaultToken]) {
  825|      0|    return (NSInteger)[[self class] maxRetryIntervalForDefaultTokenInSeconds];
  826|      0|  }
  827|      0|  // exponential backoff with a fixed initial retry time
  828|      0|  // 11s, 22s, 44s, 88s ...
  829|      0|  int64_t minInterval = [[self class] minIntervalForDefaultTokenRetry];
  830|      0|  return (NSInteger)MIN(
  831|      0|      (1 << self.retryCountForDefaultToken) + minInterval * self.retryCountForDefaultToken,
  832|      0|      kMaxRetryIntervalForDefaultTokenInSeconds);
  833|      0|}
  834|       |
  835|      0|- (void)defaultTokenWithHandler:(nullable FIRInstanceIDTokenHandler)aHandler {
  836|      0|  [self defaultTokenWithRetry:NO handler:aHandler];
  837|      0|}
  838|       |
  839|       |/**
  840|       | * @param retry Indicates if the method is called to perform a retry after a failed attempt.
  841|       | * If `YES`, then actual token request will be performed even if `self.defaultTokenFetchHandler !=
  842|       | * nil`
  843|       | */
  844|      0|- (void)defaultTokenWithRetry:(BOOL)retry handler:(nullable FIRInstanceIDTokenHandler)aHandler {
  845|      0|  BOOL shouldPerformRequest = retry || self.defaultTokenFetchHandler == nil;
  846|      0|
  847|      0|  if (!self.defaultTokenFetchHandler) {
  848|      0|    self.defaultTokenFetchHandler = [[FIRInstanceIDCombinedHandler<NSString *> alloc] init];
  849|      0|  }
  850|      0|
  851|      0|  if (aHandler) {
  852|      0|    [self.defaultTokenFetchHandler addHandler:aHandler];
  853|      0|  }
  854|      0|
  855|      0|  if (!shouldPerformRequest) {
  856|      0|    return;
  857|      0|  }
  858|      0|
  859|      0|  NSDictionary *instanceIDOptions = @{};
  860|      0|  BOOL hasFirebaseMessaging = NSClassFromString(kFIRInstanceIDFCMSDKClassString) != nil;
  861|      0|  if (hasFirebaseMessaging && self.apnsTokenData) {
  862|      0|    BOOL isSandboxApp = (self.apnsTokenType == FIRInstanceIDAPNSTokenTypeSandbox);
  863|      0|    if (self.apnsTokenType == FIRInstanceIDAPNSTokenTypeUnknown) {
  864|      0|      isSandboxApp = [self isSandboxApp];
  865|      0|    }
  866|      0|    instanceIDOptions = @{
  867|      0|      kFIRInstanceIDTokenOptionsAPNSKey : self.apnsTokenData,
  868|      0|      kFIRInstanceIDTokenOptionsAPNSIsSandboxKey : @(isSandboxApp),
  869|      0|    };
  870|      0|  }
  871|      0|
  872|      0|  FIRInstanceID_WEAKIFY(self);
  873|      0|  FIRInstanceIDTokenHandler newHandler = ^void(NSString *token, NSError *error) {
  874|      0|    FIRInstanceID_STRONGIFY(self);
  875|      0|
  876|      0|    if (error) {
  877|      0|      FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeInstanceID009,
  878|      0|                               @"Failed to fetch default token %@", error);
  879|      0|
  880|      0|      // This notification can be sent multiple times since we can't guarantee success at any point
  881|      0|      // of time.
  882|      0|      NSNotification *tokenFetchFailNotification =
  883|      0|          [NSNotification notificationWithName:kFIRInstanceIDDefaultGCMTokenFailNotification
  884|      0|                                        object:[error copy]];
  885|      0|      [[NSNotificationQueue defaultQueue] enqueueNotification:tokenFetchFailNotification
  886|      0|                                                 postingStyle:NSPostASAP];
  887|      0|
  888|      0|      self.retryCountForDefaultToken = (NSInteger)MIN(self.retryCountForDefaultToken + 1,
  889|      0|                                                      [[self class] maxRetryCountForDefaultToken]);
  890|      0|
  891|      0|      // Do not retry beyond the maximum limit.
  892|      0|      if (self.retryCountForDefaultToken < [[self class] maxRetryCountForDefaultToken]) {
  893|      0|        NSInteger retryInterval = [self retryIntervalToFetchDefaultToken];
  894|      0|        [self retryGetDefaultTokenAfter:retryInterval];
  895|      0|      } else {
  896|      0|        FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeInstanceID007,
  897|      0|                                 @"Failed to retrieve the default FCM token after %ld retries",
  898|      0|                                 (long)self.retryCountForDefaultToken);
  899|      0|        [self performDefaultTokenHandlerWithToken:nil error:error];
  900|      0|      }
  901|      0|    } else {
  902|      0|      // If somebody updated IID with APNS token while our initial request did not have it
  903|      0|      // set we need to update it on the server.
  904|      0|      NSData *deviceTokenInRequest = instanceIDOptions[kFIRInstanceIDTokenOptionsAPNSKey];
  905|      0|      BOOL isSandboxInRequest =
  906|      0|          [instanceIDOptions[kFIRInstanceIDTokenOptionsAPNSIsSandboxKey] boolValue];
  907|      0|      // Note that APNSTupleStringInRequest will be nil if deviceTokenInRequest is nil
  908|      0|      NSString *APNSTupleStringInRequest = FIRInstanceIDAPNSTupleStringForTokenAndServerType(
  909|      0|          deviceTokenInRequest, isSandboxInRequest);
  910|      0|      // If the APNs value either remained nil, or was the same non-nil value, the APNs value
  911|      0|      // did not change.
  912|      0|      BOOL APNSRemainedSameDuringFetch =
  913|      0|          (self.APNSTupleString == nil && APNSTupleStringInRequest == nil) ||
  914|      0|          ([self.APNSTupleString isEqualToString:APNSTupleStringInRequest]);
  915|      0|      if (!APNSRemainedSameDuringFetch && hasFirebaseMessaging) {
  916|      0|        // APNs value did change mid-fetch, so the token should be re-fetched with the current APNs
  917|      0|        // value.
  918|      0|        [self retryGetDefaultTokenAfter:0];
  919|      0|        FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeRefetchingTokenForAPNS,
  920|      0|                                 @"Received APNS token while fetching default token. "
  921|      0|                                 @"Refetching default token.");
  922|      0|        // Do not notify and handle completion handler since this is a retry.
  923|      0|        // Simply return.
  924|      0|        return;
  925|      0|      } else {
  926|      0|        FIRInstanceIDLoggerInfo(kFIRInstanceIDMessageCodeInstanceID010,
  927|      0|                                @"Successfully fetched default token.");
  928|      0|      }
  929|      0|      // Post the required notifications if somebody is waiting.
  930|      0|      FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeInstanceID008, @"Got default token %@",
  931|      0|                               token);
  932|      0|      NSString *previousFCMToken = self.defaultFCMToken;
  933|      0|      self.defaultFCMToken = token;
  934|      0|
  935|      0|      // Only notify of token refresh if we have a new valid token that's different than before
  936|      0|      if (self.defaultFCMToken.length && ![self.defaultFCMToken isEqualToString:previousFCMToken]) {
  937|      0|        NSNotification *tokenRefreshNotification =
  938|      0|            [NSNotification notificationWithName:kFIRInstanceIDTokenRefreshNotification
  939|      0|                                          object:[self.defaultFCMToken copy]];
  940|      0|        [[NSNotificationQueue defaultQueue] enqueueNotification:tokenRefreshNotification
  941|      0|                                                   postingStyle:NSPostASAP];
  942|      0|
  943|      0|        [self performDefaultTokenHandlerWithToken:token error:nil];
  944|      0|      }
  945|      0|    }
  946|      0|  };
  947|      0|
  948|      0|  [self tokenWithAuthorizedEntity:self.fcmSenderID
  949|      0|                            scope:kFIRInstanceIDDefaultTokenScope
  950|      0|                          options:instanceIDOptions
  951|      0|                          handler:newHandler];
  952|      0|}
  953|       |
  954|       |/**
  955|       | *
  956|       | */
  957|      0|- (void)performDefaultTokenHandlerWithToken:(NSString *)token error:(NSError *)error {
  958|      0|  if (!self.defaultTokenFetchHandler) {
  959|      0|    return;
  960|      0|  }
  961|      0|
  962|      0|  [self.defaultTokenFetchHandler combinedHandler](token, error);
  963|      0|  self.defaultTokenFetchHandler = nil;
  964|      0|}
  965|       |
  966|      0|- (void)retryGetDefaultTokenAfter:(NSTimeInterval)retryInterval {
  967|      0|  FIRInstanceID_WEAKIFY(self);
  968|      0|  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(retryInterval * NSEC_PER_SEC)),
  969|      0|                 dispatch_get_main_queue(), ^{
  970|      0|                   FIRInstanceID_STRONGIFY(self);
  971|      0|                   // Pass nil: no new handlers to be added, currently existing handlers
  972|      0|                   // will be called
  973|      0|                   [self defaultTokenWithRetry:YES handler:nil];
  974|      0|                 });
  975|      0|}
  976|       |
  977|       |#pragma mark - APNS Token
  978|       |// This should only be triggered from FCM.
  979|      0|- (void)notifyAPNSTokenIsSet:(NSNotification *)notification {
  980|      0|  NSData *token = notification.object;
  981|      0|  if (!token || ![token isKindOfClass:[NSData class]]) {
  982|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeInternal002, @"Invalid APNS token type %@",
  983|      0|                             NSStringFromClass([notification.object class]));
  984|      0|    return;
  985|      0|  }
  986|      0|  NSInteger type = [notification.userInfo[kFIRInstanceIDAPNSTokenType] integerValue];
  987|      0|
  988|      0|  // The APNS token is being added, or has changed (rare)
  989|      0|  if ([self.apnsTokenData isEqualToData:token]) {
  990|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeInstanceID011,
  991|      0|                             @"Trying to reset APNS token to the same value. Will return");
  992|      0|    return;
  993|      0|  }
  994|      0|  // Use this token type for when we have to automatically fetch tokens in the future
  995|      0|  self.apnsTokenType = type;
  996|      0|  BOOL isSandboxApp = (type == FIRInstanceIDAPNSTokenTypeSandbox);
  997|      0|  if (self.apnsTokenType == FIRInstanceIDAPNSTokenTypeUnknown) {
  998|      0|    isSandboxApp = [self isSandboxApp];
  999|      0|  }
 1000|      0|  self.apnsTokenData = [token copy];
 1001|      0|  self.APNSTupleString = FIRInstanceIDAPNSTupleStringForTokenAndServerType(token, isSandboxApp);
 1002|      0|
 1003|      0|  // Pro-actively invalidate the default token, if the APNs change makes it
 1004|      0|  // invalid. Previously, we invalidated just before fetching the token.
 1005|      0|  NSArray<FIRInstanceIDTokenInfo *> *invalidatedTokens =
 1006|      0|      [self.tokenManager updateTokensToAPNSDeviceToken:self.apnsTokenData isSandbox:isSandboxApp];
 1007|      0|
 1008|      0|  // Re-fetch any invalidated tokens automatically, this time with the current APNs token, so that
 1009|      0|  // they are up-to-date.
 1010|      0|  if (invalidatedTokens.count > 0) {
 1011|      0|    FIRInstanceID_WEAKIFY(self);
 1012|      0|    [self asyncLoadKeyPairWithHandler:^(FIRInstanceIDKeyPair *keyPair, NSError *error) {
 1013|      0|      FIRInstanceID_STRONGIFY(self);
 1014|      0|
 1015|      0|      NSMutableDictionary *tokenOptions = [@{
 1016|      0|        kFIRInstanceIDTokenOptionsAPNSKey : self.apnsTokenData,
 1017|      0|        kFIRInstanceIDTokenOptionsAPNSIsSandboxKey : @(isSandboxApp)
 1018|      0|      } mutableCopy];
 1019|      0|      if (self.firebaseAppID) {
 1020|      0|        tokenOptions[kFIRInstanceIDTokenOptionsFirebaseAppIDKey] = self.firebaseAppID;
 1021|      0|      }
 1022|      0|
 1023|      0|      for (FIRInstanceIDTokenInfo *tokenInfo in invalidatedTokens) {
 1024|      0|        if ([tokenInfo.token isEqualToString:self.defaultFCMToken]) {
 1025|      0|          // We will perform a special fetch for the default FCM token, so that the delegate methods
 1026|      0|          // are called. For all others, we will do an internal re-fetch.
 1027|      0|          [self defaultTokenWithHandler:nil];
 1028|      0|        } else {
 1029|      0|          [self.tokenManager fetchNewTokenWithAuthorizedEntity:tokenInfo.authorizedEntity
 1030|      0|                                                         scope:tokenInfo.scope
 1031|      0|                                                       keyPair:keyPair
 1032|      0|                                                       options:tokenOptions
 1033|      0|                                                       handler:^(NSString *_Nullable token,
 1034|      0|                                                                 NSError *_Nullable error){
 1035|      0|
 1036|      0|                                                       }];
 1037|      0|        }
 1038|      0|      }
 1039|      0|    }];
 1040|      0|  }
 1041|      0|}
 1042|       |
 1043|      0|- (BOOL)isSandboxApp {
 1044|      0|  static BOOL isSandboxApp = YES;
 1045|      0|  static dispatch_once_t onceToken;
 1046|      0|  dispatch_once(&onceToken, ^{
 1047|      0|    isSandboxApp = ![self isProductionApp];
 1048|      0|  });
 1049|      0|  return isSandboxApp;
 1050|      0|}
 1051|       |
 1052|      0|- (BOOL)isProductionApp {
 1053|      0|  const BOOL defaultAppTypeProd = YES;
 1054|      0|
 1055|      0|  NSError *error = nil;
 1056|      0|
 1057|      0|  Class envClass = NSClassFromString(@"FIRAppEnvironmentUtil");
 1058|      0|  SEL isSimulatorSelector = NSSelectorFromString(@"isSimulator");
 1059|      0|  if ([envClass respondsToSelector:isSimulatorSelector]) {
 1060|      0|#pragma clang diagnostic push
 1061|      0|#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
 1062|      0|    if ([envClass performSelector:isSimulatorSelector]) {
 1063|      0|#pragma clang diagnostic pop
 1064|      0|      [self logAPNSConfigurationError:@"Running InstanceID on a simulator doesn't have APNS. "
 1065|      0|                                      @"Use prod profile by default."];
 1066|      0|      return defaultAppTypeProd;
 1067|      0|    }
 1068|      0|  }
 1069|      0|
 1070|      0|  NSString *path = [[[NSBundle mainBundle] bundlePath]
 1071|      0|      stringByAppendingPathComponent:@"embedded.mobileprovision"];
 1072|      0|
 1073|      0|  // Apps distributed via AppStore or TestFlight use the Production APNS certificates.
 1074|      0|  SEL isFromAppStoreSelector = NSSelectorFromString(@"isFromAppStore");
 1075|      0|  if ([envClass respondsToSelector:isFromAppStoreSelector]) {
 1076|      0|#pragma clang diagnostic push
 1077|      0|#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
 1078|      0|    if ([envClass performSelector:isFromAppStoreSelector]) {
 1079|      0|#pragma clang diagnostic pop
 1080|      0|      return defaultAppTypeProd;
 1081|      0|    }
 1082|      0|  }
 1083|      0|
 1084|      0|  SEL isAppStoreReceiptSandboxSelector = NSSelectorFromString(@"isAppStoreReceiptSandbox");
 1085|      0|  if ([envClass respondsToSelector:isAppStoreReceiptSandboxSelector]) {
 1086|      0|#pragma clang diagnostic push
 1087|      0|#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
 1088|      0|    if ([envClass performSelector:isAppStoreReceiptSandboxSelector] && !path.length) {
 1089|      0|#pragma clang diagnostic pop
 1090|      0|      // Distributed via TestFlight
 1091|      0|      return defaultAppTypeProd;
 1092|      0|    }
 1093|      0|  }
 1094|      0|
 1095|      0|  NSMutableData *profileData = [NSMutableData dataWithContentsOfFile:path options:0 error:&error];
 1096|      0|
 1097|      0|  if (!profileData.length || error) {
 1098|      0|    NSString *errorString =
 1099|      0|        [NSString stringWithFormat:@"Error while reading embedded mobileprovision %@", error];
 1100|      0|    [self logAPNSConfigurationError:errorString];
 1101|      0|    return defaultAppTypeProd;
 1102|      0|  }
 1103|      0|
 1104|      0|  // The "embedded.mobileprovision" sometimes contains characters with value 0, which signals the
 1105|      0|  // end of a c-string and halts the ASCII parser, or with value > 127, which violates strict 7-bit
 1106|      0|  // ASCII. Replace any 0s or invalid characters in the input.
 1107|      0|  uint8_t *profileBytes = (uint8_t *)profileData.bytes;
 1108|      0|  for (int i = 0; i < profileData.length; i++) {
 1109|      0|    uint8_t currentByte = profileBytes[i];
 1110|      0|    if (!currentByte || currentByte > 127) {
 1111|      0|      profileBytes[i] = '.';
 1112|      0|    }
 1113|      0|  }
 1114|      0|
 1115|      0|  NSString *embeddedProfile = [[NSString alloc] initWithBytesNoCopy:profileBytes
 1116|      0|                                                             length:profileData.length
 1117|      0|                                                           encoding:NSASCIIStringEncoding
 1118|      0|                                                       freeWhenDone:NO];
 1119|      0|
 1120|      0|  if (error || !embeddedProfile.length) {
 1121|      0|    NSString *errorString =
 1122|      0|        [NSString stringWithFormat:@"Error while reading embedded mobileprovision %@", error];
 1123|      0|    [self logAPNSConfigurationError:errorString];
 1124|      0|    return defaultAppTypeProd;
 1125|      0|  }
 1126|      0|
 1127|      0|  NSScanner *scanner = [NSScanner scannerWithString:embeddedProfile];
 1128|      0|  NSString *plistContents;
 1129|      0|  if ([scanner scanUpToString:@"<plist" intoString:nil]) {
 1130|      0|    if ([scanner scanUpToString:@"</plist>" intoString:&plistContents]) {
 1131|      0|      plistContents = [plistContents stringByAppendingString:@"</plist>"];
 1132|      0|    }
 1133|      0|  }
 1134|      0|
 1135|      0|  if (!plistContents.length) {
 1136|      0|    return defaultAppTypeProd;
 1137|      0|  }
 1138|      0|
 1139|      0|  NSData *data = [plistContents dataUsingEncoding:NSUTF8StringEncoding];
 1140|      0|  if (!data.length) {
 1141|      0|    [self logAPNSConfigurationError:@"Couldn't read plist fetched from embedded mobileprovision"];
 1142|      0|    return defaultAppTypeProd;
 1143|      0|  }
 1144|      0|
 1145|      0|  NSError *plistMapError;
 1146|      0|  id plistData = [NSPropertyListSerialization propertyListWithData:data
 1147|      0|                                                           options:NSPropertyListImmutable
 1148|      0|                                                            format:nil
 1149|      0|                                                             error:&plistMapError];
 1150|      0|  if (plistMapError || ![plistData isKindOfClass:[NSDictionary class]]) {
 1151|      0|    NSString *errorString =
 1152|      0|        [NSString stringWithFormat:@"Error while converting assumed plist to dict %@",
 1153|      0|                                   plistMapError.localizedDescription];
 1154|      0|    [self logAPNSConfigurationError:errorString];
 1155|      0|    return defaultAppTypeProd;
 1156|      0|  }
 1157|      0|  NSDictionary *plistMap = (NSDictionary *)plistData;
 1158|      0|
 1159|      0|  if ([plistMap valueForKeyPath:@"ProvisionedDevices"]) {
 1160|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeInstanceID012,
 1161|      0|                             @"Provisioning profile has specifically provisioned devices, "
 1162|      0|                             @"most likely a Dev profile.");
 1163|      0|  }
 1164|      0|
 1165|      0|  NSString *apsEnvironment = [plistMap valueForKeyPath:kEntitlementsAPSEnvironmentKey];
 1166|      0|  NSString *debugString __unused =
 1167|      0|      [NSString stringWithFormat:@"APNS Environment in profile: %@", apsEnvironment];
 1168|      0|  FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeInstanceID013, @"%@", debugString);
 1169|      0|
 1170|      0|  // No aps-environment in the profile.
 1171|      0|  if (!apsEnvironment.length) {
 1172|      0|    [self logAPNSConfigurationError:@"No aps-environment set. If testing on a device APNS is not "
 1173|      0|                                    @"correctly configured. Please recheck your provisioning "
 1174|      0|                                    @"profiles. If testing on a simulator this is fine since APNS "
 1175|      0|                                    @"doesn't work on the simulator."];
 1176|      0|    return defaultAppTypeProd;
 1177|      0|  }
 1178|      0|
 1179|      0|  if ([apsEnvironment isEqualToString:kAPSEnvironmentDevelopmentValue]) {
 1180|      0|    return NO;
 1181|      0|  }
 1182|      0|
 1183|      0|  return defaultAppTypeProd;
 1184|      0|}
 1185|       |
 1186|       |/// Log error messages only when Messaging exists in the pod.
 1187|      0|- (void)logAPNSConfigurationError:(NSString *)errorString {
 1188|      0|  BOOL hasFirebaseMessaging = NSClassFromString(kFIRInstanceIDFCMSDKClassString) != nil;
 1189|      0|  if (hasFirebaseMessaging) {
 1190|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeInstanceID014, @"%@", errorString);
 1191|      0|  } else {
 1192|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeInstanceID015, @"%@", errorString);
 1193|      0|  }
 1194|      0|}
 1195|       |
 1196|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDAPNSInfo.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDAPNSInfo.h"
   18|       |
   19|       |#import "FIRInstanceIDConstants.h"
   20|       |
   21|       |/// The key used to find the APNs device token in an archive.
   22|       |NSString *const kFIRInstanceIDAPNSInfoTokenKey = @"device_token";
   23|       |/// The key used to find the sandbox value in an archive.
   24|       |NSString *const kFIRInstanceIDAPNSInfoSandboxKey = @"sandbox";
   25|       |
   26|       |@implementation FIRInstanceIDAPNSInfo
   27|       |
   28|      0|- (instancetype)initWithDeviceToken:(NSData *)deviceToken isSandbox:(BOOL)isSandbox {
   29|      0|  self = [super init];
   30|      0|  if (self) {
   31|      0|    _deviceToken = [deviceToken copy];
   32|      0|    _sandbox = isSandbox;
   33|      0|  }
   34|      0|  return self;
   35|      0|}
   36|       |
   37|      0|- (instancetype)initWithTokenOptionsDictionary:(NSDictionary *)dictionary {
   38|      0|  id deviceToken = dictionary[kFIRInstanceIDTokenOptionsAPNSKey];
   39|      0|  if (![deviceToken isKindOfClass:[NSData class]]) {
   40|      0|    return nil;
   41|      0|  }
   42|      0|
   43|      0|  id isSandbox = dictionary[kFIRInstanceIDTokenOptionsAPNSIsSandboxKey];
   44|      0|  if (![isSandbox isKindOfClass:[NSNumber class]]) {
   45|      0|    return nil;
   46|      0|  }
   47|      0|  self = [super init];
   48|      0|  if (self) {
   49|      0|    _deviceToken = (NSData *)deviceToken;
   50|      0|    _sandbox = ((NSNumber *)isSandbox).boolValue;
   51|      0|  }
   52|      0|  return self;
   53|      0|}
   54|       |
   55|       |#pragma mark - NSCoding
   56|       |
   57|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   58|      0|  id deviceToken = [aDecoder decodeObjectForKey:kFIRInstanceIDAPNSInfoTokenKey];
   59|      0|  if (![deviceToken isKindOfClass:[NSData class]]) {
   60|      0|    return nil;
   61|      0|  }
   62|      0|  BOOL isSandbox = [aDecoder decodeBoolForKey:kFIRInstanceIDAPNSInfoSandboxKey];
   63|      0|  return [self initWithDeviceToken:(NSData *)deviceToken isSandbox:isSandbox];
   64|      0|}
   65|       |
   66|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   67|      0|  [aCoder encodeObject:self.deviceToken forKey:kFIRInstanceIDAPNSInfoTokenKey];
   68|      0|  [aCoder encodeBool:self.sandbox forKey:kFIRInstanceIDAPNSInfoSandboxKey];
   69|      0|}
   70|       |
   71|      0|- (BOOL)isEqualToAPNSInfo:(FIRInstanceIDAPNSInfo *)otherInfo {
   72|      0|  if ([super isEqual:otherInfo]) {
   73|      0|    return YES;
   74|      0|  }
   75|      0|  return ([self.deviceToken isEqualToData:otherInfo.deviceToken] &&
   76|      0|          self.isSandbox == otherInfo.isSandbox);
   77|      0|}
   78|       |
   79|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDAuthKeyChain.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDAuthKeyChain.h"
   18|       |#import "FIRInstanceIDKeychain.h"
   19|       |#import "FIRInstanceIDLogger.h"
   20|       |
   21|       |/**
   22|       | *  The error type representing why we couldn't read data from the keychain.
   23|       | */
   24|       |typedef NS_ENUM(int, FIRInstanceIDKeychainErrorType) {
   25|       |  kFIRInstanceIDKeychainErrorBadArguments = -1301,
   26|       |};
   27|       |
   28|       |NSString *const kFIRInstanceIDKeychainWildcardIdentifier = @"*";
   29|       |
   30|       |@interface FIRInstanceIDAuthKeychain ()
   31|       |
   32|       |@property(nonatomic, copy) NSString *generic;
   33|       |// cachedKeychainData is keyed by service and account, the value is an array of NSData.
   34|       |// It is used to cache the tokens per service, per account, as well as checkin data per service,
   35|       |// per account inside the keychain.
   36|       |@property(nonatomic)
   37|       |    NSMutableDictionary<NSString *, NSMutableDictionary<NSString *, NSArray<NSData *> *> *>
   38|       |        *cachedKeychainData;
   39|       |
   40|       |@end
   41|       |
   42|       |@implementation FIRInstanceIDAuthKeychain
   43|       |
   44|     28|- (instancetype)initWithIdentifier:(NSString *)identifier {
   45|     28|  self = [super init];
   46|     28|  if (self) {
   47|     28|    _generic = [identifier copy];
   48|     28|    _cachedKeychainData = [[NSMutableDictionary alloc] init];
   49|     28|  }
   50|     28|  return self;
   51|     28|}
   52|       |
   53|       |+ (NSMutableDictionary *)keychainQueryForService:(NSString *)service
   54|       |                                         account:(NSString *)account
   55|     29|                                         generic:(NSString *)generic {
   56|     29|  NSDictionary *query = @{(__bridge id)kSecClass : (__bridge id)kSecClassGenericPassword};
   57|     29|
   58|     29|  NSMutableDictionary *finalQuery = [NSMutableDictionary dictionaryWithDictionary:query];
   59|     29|  if ([generic length] && ![kFIRInstanceIDKeychainWildcardIdentifier isEqualToString:generic]) {
   60|     29|    finalQuery[(__bridge NSString *)kSecAttrGeneric] = generic;
   61|     29|  }
   62|     29|  if ([account length] && ![kFIRInstanceIDKeychainWildcardIdentifier isEqualToString:account]) {
   63|     29|    finalQuery[(__bridge NSString *)kSecAttrAccount] = account;
   64|     29|  }
   65|     29|  if ([service length] && ![kFIRInstanceIDKeychainWildcardIdentifier isEqualToString:service]) {
   66|     28|    finalQuery[(__bridge NSString *)kSecAttrService] = service;
   67|     28|  }
   68|     29|  return finalQuery;
   69|     29|}
   70|       |
   71|     29|- (NSMutableDictionary *)keychainQueryForService:(NSString *)service account:(NSString *)account {
   72|     29|  return [[self class] keychainQueryForService:service account:account generic:self.generic];
   73|     29|}
   74|       |
   75|     42|- (NSArray<NSData *> *)itemsMatchingService:(NSString *)service account:(NSString *)account {
   76|     42|  // If query wildcard service, it asks for all the results, which always query from keychain.
   77|     42|  if (![service isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier] &&
   78|     42|      ![account isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier] &&
   79|     42|      _cachedKeychainData[service][account]) {
   80|     14|    // As long as service, account array exist, even it's empty, it means we've queried it before,
   81|     14|    // returns the cache value.
   82|     14|    return _cachedKeychainData[service][account];
   83|     14|  }
   84|     28|
   85|     28|  NSMutableDictionary *keychainQuery = [self keychainQueryForService:service account:account];
   86|     28|
   87|     28|  NSMutableArray<NSData *> *results;
   88|     28|  keychainQuery[(__bridge id)kSecReturnData] = (__bridge id)kCFBooleanTrue;
   89|     28|  keychainQuery[(__bridge id)kSecReturnAttributes] = (__bridge id)kCFBooleanTrue;
   90|     28|  keychainQuery[(__bridge id)kSecMatchLimit] = (__bridge id)kSecMatchLimitAll;
   91|     28|  // FIRInstanceIDKeychain should only take a query and return a result, will handle the query here.
   92|     28|  NSArray *passwordInfos =
   93|     28|      CFBridgingRelease([[FIRInstanceIDKeychain sharedInstance] itemWithQuery:keychainQuery]);
   94|     28|
   95|     28|  if (!passwordInfos) {
   96|     28|    // Nothing was found, simply return from this sync block.
   97|     28|    // Make sure to label the cache entry empty, signaling that we've queried this entry.
   98|     28|    if ([service isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier] ||
   99|     28|        [account isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier]) {
  100|      0|      // Do not update cache if it's wildcard query.
  101|      0|      return @[];
  102|     28|    } else if (_cachedKeychainData[service]) {
  103|      0|      [_cachedKeychainData[service] setObject:@[] forKey:account];
  104|     28|    } else {
  105|     28|      [_cachedKeychainData setObject:[@{account : @[]} mutableCopy] forKey:service];
  106|     28|    }
  107|     28|    return @[];
  108|      0|  }
  109|      0|  NSInteger numPasswords = passwordInfos.count;
  110|      0|  results = [[NSMutableArray alloc] init];
  111|      0|  for (NSUInteger i = 0; i < numPasswords; i++) {
  112|      0|    NSDictionary *passwordInfo = [passwordInfos objectAtIndex:i];
  113|      0|    if (passwordInfo[(__bridge id)kSecValueData]) {
  114|      0|      [results addObject:passwordInfo[(__bridge id)kSecValueData]];
  115|      0|    }
  116|      0|  }
  117|      0|
  118|      0|  // We query the keychain because it didn't exist in cache, now query is done, update the result in
  119|      0|  // the cache.
  120|      0|  if ([service isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier] ||
  121|      0|      [account isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier]) {
  122|      0|    // Do not update cache if it's wildcard query.
  123|      0|    return [results copy];
  124|      0|  } else if (_cachedKeychainData[service]) {
  125|      0|    [_cachedKeychainData[service] setObject:[results copy] forKey:account];
  126|      0|  } else {
  127|      0|    NSMutableDictionary *entry = [@{account : [results copy]} mutableCopy];
  128|      0|    [_cachedKeychainData setObject:entry forKey:service];
  129|      0|  }
  130|      0|  return [results copy];
  131|      0|}
  132|       |
  133|     42|- (NSData *)dataForService:(NSString *)service account:(NSString *)account {
  134|     42|  NSArray<NSData *> *items = [self itemsMatchingService:service account:account];
  135|     42|  // If items is nil or empty, nil will be returned.
  136|     42|  return items.firstObject;
  137|     42|}
  138|       |
  139|       |- (void)removeItemsMatchingService:(NSString *)service
  140|       |                           account:(NSString *)account
  141|      1|                           handler:(void (^)(NSError *error))handler {
  142|      1|  if ([service isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier]) {
  143|      1|    // Delete all keychain items.
  144|      1|    _cachedKeychainData = [[NSMutableDictionary alloc] init];
  145|      1|  } else if ([account isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier]) {
  146|      0|    // Delete all entries under service,
  147|      0|    if (_cachedKeychainData[service]) {
  148|      0|      _cachedKeychainData[service] = [[NSMutableDictionary alloc] init];
  149|      0|    }
  150|      0|  } else if (_cachedKeychainData[service]) {
  151|      0|    // We should keep the service/account entry instead of nil so we know
  152|      0|    // it's "empty entry" instead of "not query from keychain yet".
  153|      0|    [_cachedKeychainData[service] setObject:@[] forKey:account];
  154|      0|  } else {
  155|      0|    [_cachedKeychainData setObject:[@{account : @[]} mutableCopy] forKey:service];
  156|      0|  }
  157|      1|  NSMutableDictionary *keychainQuery = [self keychainQueryForService:service account:account];
  158|      1|  [[FIRInstanceIDKeychain sharedInstance] removeItemWithQuery:keychainQuery handler:handler];
  159|      1|}
  160|       |
  161|       |- (void)setData:(NSData *)data
  162|       |       forService:(NSString *)service
  163|       |    accessibility:(CFTypeRef)accessibility
  164|       |          account:(NSString *)account
  165|      0|          handler:(void (^)(NSError *))handler {
  166|      0|  if ([service isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier] ||
  167|      0|      [account isEqualToString:kFIRInstanceIDKeychainWildcardIdentifier]) {
  168|      0|    if (handler) {
  169|      0|      handler([NSError errorWithDomain:kFIRInstanceIDKeychainErrorDomain
  170|      0|                                  code:kFIRInstanceIDKeychainErrorBadArguments
  171|      0|                              userInfo:nil]);
  172|      0|    }
  173|      0|    return;
  174|      0|  }
  175|      0|  [self removeItemsMatchingService:service
  176|      0|                           account:account
  177|      0|                           handler:^(NSError *error) {
  178|      0|                             if (error) {
  179|      0|                               if (handler) {
  180|      0|                                 handler(error);
  181|      0|                               }
  182|      0|                               return;
  183|      0|                             }
  184|      0|                             if (data.length > 0) {
  185|      0|                               NSMutableDictionary *keychainQuery =
  186|      0|                                   [self keychainQueryForService:service account:account];
  187|      0|                               keychainQuery[(__bridge id)kSecValueData] = data;
  188|      0|
  189|      0|                               if (accessibility != NULL) {
  190|      0|                                 keychainQuery[(__bridge id)kSecAttrAccessible] =
  191|      0|                                     (__bridge id)accessibility;
  192|      0|                               } else {
  193|      0|                                 // Defaults to No backup
  194|      0|                                 keychainQuery[(__bridge id)kSecAttrAccessible] =
  195|      0|                                     (__bridge id)kSecAttrAccessibleAlwaysThisDeviceOnly;
  196|      0|                               }
  197|      0|                               [[FIRInstanceIDKeychain sharedInstance]
  198|      0|                                   addItemWithQuery:keychainQuery
  199|      0|                                            handler:handler];
  200|      0|                             }
  201|      0|                           }];
  202|      0|  // Set the cache value. This must happen after removeItemsMatchingService:account:handler was
  203|      0|  // called, so the cache value was reset before setting a new value.
  204|      0|  if (_cachedKeychainData[service]) {
  205|      0|    if (_cachedKeychainData[service][account]) {
  206|      0|      _cachedKeychainData[service][account] = @[ data ];
  207|      0|    } else {
  208|      0|      [_cachedKeychainData[service] setObject:@[ data ] forKey:account];
  209|      0|    }
  210|      0|  } else {
  211|      0|    [_cachedKeychainData setObject:[@{account : @[ data ]} mutableCopy] forKey:service];
  212|      0|  }
  213|      0|}
  214|       |
  215|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDAuthService.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDAuthService.h"
   18|       |
   19|       |#import "FIRInstanceIDCheckinPreferences+Internal.h"
   20|       |#import "FIRInstanceIDCheckinPreferences.h"
   21|       |#import "FIRInstanceIDCheckinPreferences_Private.h"
   22|       |#import "FIRInstanceIDConstants.h"
   23|       |#import "FIRInstanceIDDefines.h"
   24|       |#import "FIRInstanceIDLogger.h"
   25|       |#import "FIRInstanceIDStore.h"
   26|       |#import "NSError+FIRInstanceID.h"
   27|       |
   28|       |// Max time interval between checkin retry in seconds.
   29|       |static const int64_t kMaxCheckinRetryIntervalInSeconds = 1 << 5;
   30|       |
   31|       |@interface FIRInstanceIDAuthService ()
   32|       |
   33|       |// Used to retrieve and cache the checkin info to disk and Keychain.
   34|       |@property(nonatomic, readwrite, strong) FIRInstanceIDStore *store;
   35|       |// Used to perform single checkin fetches.
   36|       |@property(nonatomic, readwrite, strong) FIRInstanceIDCheckinService *checkinService;
   37|       |// The current checkin info. It will be compared to what is retrieved to determine whether it is
   38|       |// different than what is in the cache.
   39|       |@property(nonatomic, readwrite, strong) FIRInstanceIDCheckinPreferences *checkinPreferences;
   40|       |
   41|       |// This array will track multiple handlers waiting for checkin to be performed. When a checkin
   42|       |// request completes, all the handlers will be notified.
   43|       |// Changes to the checkinHandlers array should happen in a thread-safe manner.
   44|       |@property(nonatomic, readonly, strong)
   45|       |    NSMutableArray<FIRInstanceIDDeviceCheckinCompletion> *checkinHandlers;
   46|       |
   47|       |// This is set to true if there is a checkin request in-flight.
   48|       |@property(atomic, readwrite, assign) BOOL isCheckinInProgress;
   49|       |// This timer is used a perform checkin retries. It is cancellable.
   50|       |@property(atomic, readwrite, strong) NSTimer *scheduledCheckinTimer;
   51|       |// The number of times checkin has been retried during a scheduled checkin.
   52|       |@property(atomic, readwrite, assign) int checkinRetryCount;
   53|       |
   54|       |@end
   55|       |
   56|       |@implementation FIRInstanceIDAuthService
   57|       |
   58|       |- (instancetype)initWithCheckinService:(FIRInstanceIDCheckinService *)checkinService
   59|     14|                                 store:(FIRInstanceIDStore *)store {
   60|     14|  self = [super init];
   61|     14|  if (self) {
   62|     14|    _store = store;
   63|     14|    _checkinPreferences = [_store cachedCheckinPreferences];
   64|     14|    _checkinService = checkinService;
   65|     14|    _checkinHandlers = [NSMutableArray array];
   66|     14|  }
   67|     14|  return self;
   68|     14|}
   69|       |
   70|      0|- (void)dealloc {
   71|      0|  [_scheduledCheckinTimer invalidate];
   72|      0|}
   73|       |
   74|     14|- (instancetype)initWithStore:(FIRInstanceIDStore *)store {
   75|     14|  FIRInstanceIDCheckinService *checkinService = [[FIRInstanceIDCheckinService alloc] init];
   76|     14|  return [self initWithCheckinService:checkinService store:store];
   77|     14|}
   78|       |
   79|       |#pragma mark - Schedule Checkin
   80|       |
   81|      0|- (void)scheduleCheckin:(BOOL)immediately {
   82|      0|  // Checkin is still valid, so a remote checkin is not required.
   83|      0|  if ([self.checkinPreferences hasValidCheckinInfo]) {
   84|      0|    return;
   85|      0|  }
   86|      0|
   87|      0|  // Checkin is already scheduled, so this (non-immediate) request can be ignored.
   88|      0|  if (!immediately && [self.scheduledCheckinTimer isValid]) {
   89|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeAuthService000,
   90|      0|                             @"Checkin sync already scheduled. Will not schedule.");
   91|      0|    return;
   92|      0|  }
   93|      0|
   94|      0|  if (immediately) {
   95|      0|    [self performScheduledCheckin];
   96|      0|  } else {
   97|      0|    int64_t checkinRetryDuration = [self calculateNextCheckinRetryIntervalInSeconds];
   98|      0|    [self startCheckinTimerWithDuration:(NSTimeInterval)checkinRetryDuration];
   99|      0|  }
  100|      0|}
  101|       |
  102|      0|- (void)startCheckinTimerWithDuration:(NSTimeInterval)timerDuration {
  103|      0|  self.scheduledCheckinTimer =
  104|      0|      [NSTimer scheduledTimerWithTimeInterval:timerDuration
  105|      0|                                       target:self
  106|      0|                                     selector:@selector(onScheduledCheckinTimerFired:)
  107|      0|                                     userInfo:nil
  108|      0|                                      repeats:NO];
  109|      0|  // Add some tolerance to the timer, to allow iOS to be more flexible with this timer
  110|      0|  self.scheduledCheckinTimer.tolerance = 0.5;
  111|      0|}
  112|       |
  113|      0|- (void)clearScheduledCheckinTimer {
  114|      0|  [self.scheduledCheckinTimer invalidate];
  115|      0|  self.scheduledCheckinTimer = nil;
  116|      0|}
  117|       |
  118|      0|- (void)onScheduledCheckinTimerFired:(NSTimer *)timer {
  119|      0|  [self performScheduledCheckin];
  120|      0|}
  121|       |
  122|      0|- (void)performScheduledCheckin {
  123|      0|  // No checkin scheduled as of now.
  124|      0|  [self clearScheduledCheckinTimer];
  125|      0|
  126|      0|  // Checkin is still valid, so a remote checkin is not required.
  127|      0|  if ([self.checkinPreferences hasValidCheckinInfo]) {
  128|      0|    return;
  129|      0|  }
  130|      0|
  131|      0|  FIRInstanceID_WEAKIFY(self);
  132|      0|  [self
  133|      0|      fetchCheckinInfoWithHandler:^(FIRInstanceIDCheckinPreferences *preferences, NSError *error) {
  134|      0|        FIRInstanceID_STRONGIFY(self);
  135|      0|        self.checkinRetryCount++;
  136|      0|
  137|      0|        if (error) {
  138|      0|          FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeAuthService001, @"Checkin error %@.",
  139|      0|                                   error);
  140|      0|
  141|      0|          dispatch_async(dispatch_get_main_queue(), ^{
  142|      0|            // Schedule another checkin
  143|      0|            [self scheduleCheckin:NO];
  144|      0|          });
  145|      0|
  146|      0|        } else {
  147|      0|          FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeAuthService002, @"Checkin success.");
  148|      0|        }
  149|      0|      }];
  150|      0|}
  151|       |
  152|      0|- (int64_t)calculateNextCheckinRetryIntervalInSeconds {
  153|      0|  // persistent failures can lead to overflow prevent that.
  154|      0|  if (self.checkinRetryCount >= 10) {
  155|      0|    return kMaxCheckinRetryIntervalInSeconds;
  156|      0|  }
  157|      0|  return MIN(1 << self.checkinRetryCount, kMaxCheckinRetryIntervalInSeconds);
  158|      0|}
  159|       |
  160|       |#pragma mark - Checkin Service
  161|       |
  162|      0|- (BOOL)hasValidCheckinInfo {
  163|      0|  return [self.checkinPreferences hasValidCheckinInfo];
  164|      0|}
  165|       |
  166|      0|- (void)fetchCheckinInfoWithHandler:(nonnull FIRInstanceIDDeviceCheckinCompletion)handler {
  167|      0|  // Perform any changes to self.checkinHandlers and _isCheckinInProgress in a thread-safe way.
  168|      0|  @synchronized(self) {
  169|      0|    [self.checkinHandlers addObject:handler];
  170|      0|
  171|      0|    if (_isCheckinInProgress) {
  172|      0|      // Nothing more to do until our checkin request is done
  173|      0|      FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeAuthServiceCheckinInProgress,
  174|      0|                               @"Checkin is in progress\n");
  175|      0|      return;
  176|      0|    }
  177|      0|  }
  178|      0|
  179|      0|  // Checkin is still valid, so a remote checkin is not required.
  180|      0|  if ([self.checkinPreferences hasValidCheckinInfo]) {
  181|      0|    [self notifyCheckinHandlersWithCheckin:self.checkinPreferences error:nil];
  182|      0|    return;
  183|      0|  }
  184|      0|
  185|      0|  @synchronized(self) {
  186|      0|    _isCheckinInProgress = YES;
  187|      0|  }
  188|      0|  [self.checkinService
  189|      0|      checkinWithExistingCheckin:self.checkinPreferences
  190|      0|                      completion:^(FIRInstanceIDCheckinPreferences *checkinPreferences,
  191|      0|                                   NSError *error) {
  192|      0|                        @synchronized(self) {
  193|      0|                          self->_isCheckinInProgress = NO;
  194|      0|                        }
  195|      0|                        if (error) {
  196|      0|                          FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeAuthService003,
  197|      0|                                                   @"Failed to checkin device %@", error);
  198|      0|                          [self notifyCheckinHandlersWithCheckin:nil error:error];
  199|      0|                          return;
  200|      0|                        }
  201|      0|
  202|      0|                        FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeAuthService004,
  203|      0|                                                 @"Successfully got checkin credentials");
  204|      0|                        BOOL hasSameCachedPreferences =
  205|      0|                            [self cachedCheckinMatchesCheckin:checkinPreferences];
  206|      0|                        checkinPreferences.hasPreCachedAuthCredentials = hasSameCachedPreferences;
  207|      0|
  208|      0|                        // Update to the most recent checkin preferences
  209|      0|                        self.checkinPreferences = checkinPreferences;
  210|      0|
  211|      0|                        // Save the checkin info to disk
  212|      0|                        // Keychain might not be accessible, so confirm that checkin preferences can
  213|      0|                        // be saved
  214|      0|                        [self.store
  215|      0|                            saveCheckinPreferences:checkinPreferences
  216|      0|                                           handler:^(NSError *checkinSaveError) {
  217|      0|                                             if (checkinSaveError && !hasSameCachedPreferences) {
  218|      0|                                               // The checkin info was new, but it couldn't be
  219|      0|                                               // written to the Keychain. Delete any stuff that was
  220|      0|                                               // cached in memory. This doesn't delete any
  221|      0|                                               // previously persisted preferences.
  222|      0|                                               FIRInstanceIDLoggerError(
  223|      0|                                                   kFIRInstanceIDMessageCodeService004,
  224|      0|                                                   @"Unable to save checkin info, resetting "
  225|      0|                                                   @"checkin preferences "
  226|      0|                                                    "in memory.");
  227|      0|                                               [checkinPreferences reset];
  228|      0|                                               [self
  229|      0|                                                   notifyCheckinHandlersWithCheckin:nil
  230|      0|                                                                              error:
  231|      0|                                                                                  checkinSaveError];
  232|      0|                                             } else {
  233|      0|                                               // The checkin is either new, or it was the same (and
  234|      0|                                               // it couldn't be saved). Either way, report that the
  235|      0|                                               // checkin preferences were received successfully.
  236|      0|                                               [self notifyCheckinHandlersWithCheckin:
  237|      0|                                                         checkinPreferences
  238|      0|                                                                                error:nil];
  239|      0|                                               if (!hasSameCachedPreferences) {
  240|      0|                                                 // Checkin is new.
  241|      0|                                                 // Notify any listeners that might be waiting for
  242|      0|                                                 // checkin to be fetched, such as Firebase
  243|      0|                                                 // Messaging (for its MCS connection).
  244|      0|                                                 dispatch_async(dispatch_get_main_queue(), ^{
  245|      0|                                                   [[NSNotificationCenter defaultCenter]
  246|      0|                                                       postNotificationName:
  247|      0|                                                           kFIRInstanceIDCheckinFetchedNotification
  248|      0|                                                                     object:nil];
  249|      0|                                                 });
  250|      0|                                               }
  251|      0|                                             }
  252|      0|                                           }];
  253|      0|                      }];
  254|      0|}
  255|       |
  256|      0|- (FIRInstanceIDCheckinPreferences *)checkinPreferences {
  257|      0|  return _checkinPreferences;
  258|      0|}
  259|       |
  260|      0|- (void)stopCheckinRequest {
  261|      0|  [self.checkinService stopFetching];
  262|      0|}
  263|       |
  264|      0|- (void)resetCheckinWithHandler:(void (^)(NSError *error))handler {
  265|      0|  [self.store removeCheckinPreferencesWithHandler:^(NSError *error) {
  266|      0|    if (!error) {
  267|      0|      self.checkinPreferences = nil;
  268|      0|    }
  269|      0|    if (handler) {
  270|      0|      handler(error);
  271|      0|    }
  272|      0|  }];
  273|      0|}
  274|       |
  275|       |#pragma mark - Private
  276|       |
  277|       |/**
  278|       | *  Goes through the current list of checkin handlers and fires them with the same checkin and/or
  279|       | *  error info. The checkin handlers will get cleared after.
  280|       | */
  281|       |- (void)notifyCheckinHandlersWithCheckin:(nullable FIRInstanceIDCheckinPreferences *)checkin
  282|      0|                                   error:(nullable NSError *)error {
  283|      0|  @synchronized(self) {
  284|      0|    for (FIRInstanceIDDeviceCheckinCompletion handler in self.checkinHandlers) {
  285|      0|      handler(checkin, error);
  286|      0|    }
  287|      0|    [self.checkinHandlers removeAllObjects];
  288|      0|  }
  289|      0|}
  290|       |
  291|       |/**
  292|       | *  Given a |checkin|, it will compare it to the current checkinPreferences to see if the
  293|       | *  deviceID and secretToken are the same.
  294|       | */
  295|      0|- (BOOL)cachedCheckinMatchesCheckin:(FIRInstanceIDCheckinPreferences *)checkin {
  296|      0|  if (self.checkinPreferences && checkin) {
  297|      0|    return ([self.checkinPreferences.deviceID isEqualToString:checkin.deviceID] &&
  298|      0|            [self.checkinPreferences.secretToken isEqualToString:checkin.secretToken]);
  299|      0|  }
  300|      0|  return NO;
  301|      0|}
  302|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDBackupExcludedPlist.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDBackupExcludedPlist.h"
   18|       |
   19|       |#import "FIRInstanceIDDefines.h"
   20|       |#import "FIRInstanceIDLogger.h"
   21|       |
   22|       |typedef enum : NSUInteger {
   23|       |  FIRInstanceIDPlistDirectoryUnknown,
   24|       |  FIRInstanceIDPlistDirectoryDocuments,
   25|       |  FIRInstanceIDPlistDirectoryApplicationSupport,
   26|       |} FIRInstanceIDPlistDirectory;
   27|       |
   28|       |@interface FIRInstanceIDBackupExcludedPlist ()
   29|       |
   30|       |@property(nonatomic, readwrite, copy) NSString *fileName;
   31|       |@property(nonatomic, readwrite, copy) NSString *subDirectoryName;
   32|       |@property(nonatomic, readwrite, assign) BOOL fileInStandardDirectory;
   33|       |
   34|       |@property(nonatomic, readwrite, strong) NSDictionary *cachedPlistContents;
   35|       |
   36|       |@end
   37|       |
   38|       |@implementation FIRInstanceIDBackupExcludedPlist
   39|       |
   40|     28|- (instancetype)initWithFileName:(NSString *)fileName subDirectory:(NSString *)subDirectory {
   41|     28|  self = [super init];
   42|     28|  if (self) {
   43|     28|    _fileName = [fileName copy];
   44|     28|    _subDirectoryName = [subDirectory copy];
   45|     28|#if TARGET_OS_IOS
   46|     28|    _fileInStandardDirectory = [self moveToApplicationSupportSubDirectory:subDirectory];
   47|       |#else
   48|       |    // For tvOS and macOS, we never store the content in document folder, so
   49|       |    // the migration is unnecessary.
   50|       |    _fileInStandardDirectory = YES;
   51|       |#endif
   52|       |  }
   53|     28|  return self;
   54|     28|}
   55|       |
   56|      1|- (BOOL)writeDictionary:(NSDictionary *)dict error:(NSError **)error {
   57|      1|  NSString *path = [self plistPathInDirectory:[self plistDirectory]];
   58|      1|  if (![dict writeToFile:path atomically:YES]) {
   59|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeBackupExcludedPlist000,
   60|      0|                             @"Failed to write to %@.plist", self.fileName);
   61|      0|    return NO;
   62|      0|  }
   63|      1|
   64|      1|  // Successfully wrote contents -- change the in-memory contents
   65|      1|  self.cachedPlistContents = [dict copy];
   66|      1|
   67|      1|  _FIRInstanceIDDevAssert([[NSFileManager defaultManager] fileExistsAtPath:path],
   68|      1|                          @"Error writing data to non-backed up plist %@.plist", self.fileName);
   69|      1|
   70|      1|  NSURL *URL = [NSURL fileURLWithPath:path];
   71|      1|  if (error) {
   72|      1|    *error = nil;
   73|      1|  }
   74|      1|
   75|      1|  NSDictionary *preferences = [URL resourceValuesForKeys:@[ NSURLIsExcludedFromBackupKey ]
   76|      1|                                                   error:error];
   77|      1|  if ([preferences[NSURLIsExcludedFromBackupKey] boolValue]) {
   78|      0|    return YES;
   79|      0|  }
   80|      1|
   81|      1|  BOOL success = [URL setResourceValue:@(YES) forKey:NSURLIsExcludedFromBackupKey error:error];
   82|      1|  if (!success) {
   83|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeBackupExcludedPlist001,
   84|      0|                             @"Error excluding %@ from backup, %@", [URL lastPathComponent],
   85|      0|                             error ? *error : @"");
   86|      0|  }
   87|      1|  return success;
   88|      1|}
   89|       |
   90|      0|- (BOOL)deleteFile:(NSError **)error {
   91|      0|  BOOL success = YES;
   92|      0|  NSString *path = [self plistPathInDirectory:[self plistDirectory]];
   93|      0|  if ([[NSFileManager defaultManager] fileExistsAtPath:path]) {
   94|      0|    success = [[NSFileManager defaultManager] removeItemAtPath:path error:error];
   95|      0|  }
   96|      0|  // remove the in-memory contents
   97|      0|  self.cachedPlistContents = nil;
   98|      0|  return success;
   99|      0|}
  100|       |
  101|     44|- (NSDictionary *)contentAsDictionary {
  102|     44|  if (!self.cachedPlistContents) {
  103|     44|    NSString *path = [self plistPathInDirectory:[self plistDirectory]];
  104|     44|    if ([[NSFileManager defaultManager] fileExistsAtPath:path]) {
  105|     13|      self.cachedPlistContents = [[NSDictionary alloc] initWithContentsOfFile:path];
  106|     13|    }
  107|     44|  }
  108|     44|  return self.cachedPlistContents;
  109|     44|}
  110|       |
  111|     28|- (BOOL)moveToApplicationSupportSubDirectory:(NSString *)subDirectoryName {
  112|     28|  NSArray *directoryPaths =
  113|     28|      NSSearchPathForDirectoriesInDomains([self supportedDirectory], NSUserDomainMask, YES);
  114|     28|  // This only going to happen inside iOS so it is an applicationSupportDirectory.
  115|     28|  NSString *applicationSupportDirPath = directoryPaths.lastObject;
  116|     28|  NSArray *components = @[ applicationSupportDirPath, subDirectoryName ];
  117|     28|  NSString *subDirectoryPath = [NSString pathWithComponents:components];
  118|     28|  BOOL hasSubDirectory;
  119|     28|  if (![[NSFileManager defaultManager] fileExistsAtPath:subDirectoryPath
  120|     28|                                            isDirectory:&hasSubDirectory]) {
  121|      0|    // Cannot move to non-existent directory
  122|      0|    return NO;
  123|      0|  }
  124|     28|
  125|     28|  if ([self doesFileExistInDirectory:FIRInstanceIDPlistDirectoryDocuments]) {
  126|      0|    NSString *oldPlistPath = [self plistPathInDirectory:FIRInstanceIDPlistDirectoryDocuments];
  127|      0|    NSString *newPlistPath =
  128|      0|        [self plistPathInDirectory:FIRInstanceIDPlistDirectoryApplicationSupport];
  129|      0|    if ([self doesFileExistInDirectory:FIRInstanceIDPlistDirectoryApplicationSupport]) {
  130|      0|      // File exists in both Documents and ApplicationSupport
  131|      0|      return NO;
  132|      0|    }
  133|      0|    NSError *moveError;
  134|      0|    if (![[NSFileManager defaultManager] moveItemAtPath:oldPlistPath
  135|      0|                                                 toPath:newPlistPath
  136|      0|                                                  error:&moveError]) {
  137|      0|      FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeBackupExcludedPlist002,
  138|      0|                               @"Failed to move file %@ from %@ to %@. Error: %@", self.fileName,
  139|      0|                               oldPlistPath, newPlistPath, moveError);
  140|      0|      return NO;
  141|      0|    }
  142|     28|  }
  143|     28|  // We moved the file if it existed, otherwise we didn't need to do anything
  144|     28|  return YES;
  145|     28|}
  146|       |
  147|     28|- (BOOL)doesFileExist {
  148|     28|  return [self doesFileExistInDirectory:[self plistDirectory]];
  149|     28|}
  150|       |
  151|       |#pragma mark - Private
  152|       |
  153|     73|- (FIRInstanceIDPlistDirectory)plistDirectory {
  154|     73|  if (_fileInStandardDirectory) {
  155|     73|    return FIRInstanceIDPlistDirectoryApplicationSupport;
  156|     73|  } else {
  157|      0|    return FIRInstanceIDPlistDirectoryDocuments;
  158|      0|  };
  159|      0|}
  160|       |
  161|    101|- (NSString *)plistPathInDirectory:(FIRInstanceIDPlistDirectory)directory {
  162|    101|  return [self pathWithName:self.fileName inDirectory:directory];
  163|    101|}
  164|       |
  165|       |- (NSString *)pathWithName:(NSString *)plistName
  166|    101|               inDirectory:(FIRInstanceIDPlistDirectory)directory {
  167|    101|  NSArray *directoryPaths;
  168|    101|  NSArray *components = @[];
  169|    101|  NSString *plistNameWithExtension = [NSString stringWithFormat:@"%@.plist", plistName];
  170|    101|  switch (directory) {
  171|    101|    case FIRInstanceIDPlistDirectoryDocuments:
  172|     28|      directoryPaths =
  173|     28|          NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
  174|     28|      components = @[ directoryPaths.lastObject, plistNameWithExtension ];
  175|     28|      break;
  176|    101|
  177|    101|    case FIRInstanceIDPlistDirectoryApplicationSupport:
  178|     73|      directoryPaths =
  179|     73|          NSSearchPathForDirectoriesInDomains([self supportedDirectory], NSUserDomainMask, YES);
  180|     73|      components = @[ directoryPaths.lastObject, _subDirectoryName, plistNameWithExtension ];
  181|     73|      break;
  182|    101|
  183|    101|    default:
  184|      0|      FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeBackupExcludedPlistInvalidPlistEnum,
  185|      0|                               @"Invalid plist directory type: %lu", (unsigned long)directory);
  186|      0|      NSAssert(NO, @"Invalid plist directory type: %lu", (unsigned long)directory);
  187|      0|      break;
  188|    101|  }
  189|    101|
  190|    101|  return [NSString pathWithComponents:components];
  191|    101|}
  192|       |
  193|     56|- (BOOL)doesFileExistInDirectory:(FIRInstanceIDPlistDirectory)directory {
  194|     56|  NSString *path = [self plistPathInDirectory:directory];
  195|     56|  return [[NSFileManager defaultManager] fileExistsAtPath:path];
  196|     56|}
  197|       |
  198|    101|- (NSSearchPathDirectory)supportedDirectory {
  199|       |#if TARGET_OS_TV
  200|       |  return NSCachesDirectory;
  201|       |#else
  202|       |  return NSApplicationSupportDirectory;
  203|    101|#endif
  204|    101|}
  205|       |
  206|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDCheckinPreferences+Internal.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDCheckinPreferences+Internal.h"
   18|       |
   19|       |#import "FIRInstanceIDCheckinService.h"
   20|       |#import "FIRInstanceIDUtilities.h"
   21|       |
   22|       |static NSString *const kCheckinKeychainContentSeparatorString = @"|";
   23|       |
   24|       |@interface FIRInstanceIDCheckinPreferences ()
   25|       |
   26|       |@property(nonatomic, readwrite, copy) NSString *deviceID;
   27|       |@property(nonatomic, readwrite, copy) NSString *secretToken;
   28|       |@property(nonatomic, readwrite, copy) NSString *digest;
   29|       |@property(nonatomic, readwrite, copy) NSString *versionInfo;
   30|       |@property(nonatomic, readwrite, copy) NSString *deviceDataVersion;
   31|       |
   32|       |@property(nonatomic, readwrite, strong) NSMutableDictionary *gServicesData;
   33|       |@property(nonatomic, readwrite, assign) int64_t lastCheckinTimestampMillis;
   34|       |
   35|       |@end
   36|       |
   37|       |@implementation FIRInstanceIDCheckinPreferences (Internal)
   38|       |
   39|     28|+ (FIRInstanceIDCheckinPreferences *)preferencesFromKeychainContents:(NSString *)keychainContent {
   40|     28|  NSString *deviceID = [self checkinDeviceIDFromKeychainContent:keychainContent];
   41|     28|  NSString *secret = [self checkinSecretFromKeychainContent:keychainContent];
   42|     28|  if ([deviceID length] && [secret length]) {
   43|      0|    return [[FIRInstanceIDCheckinPreferences alloc] initWithDeviceID:deviceID secretToken:secret];
   44|     28|  } else {
   45|     28|    return nil;
   46|     28|  }
   47|     28|}
   48|       |
   49|      0|- (instancetype)initWithDeviceID:(NSString *)deviceID secretToken:(NSString *)secretToken {
   50|      0|  self = [super init];
   51|      0|  if (self) {
   52|      0|    self.deviceID = [deviceID copy];
   53|      0|    self.secretToken = [secretToken copy];
   54|      0|  }
   55|      0|  return self;
   56|      0|}
   57|       |
   58|      0|- (void)reset {
   59|      0|  self.deviceID = nil;
   60|      0|  self.secretToken = nil;
   61|      0|  self.digest = nil;
   62|      0|  self.versionInfo = nil;
   63|      0|  self.gServicesData = nil;
   64|      0|  self.deviceDataVersion = nil;
   65|      0|  self.lastCheckinTimestampMillis = 0;
   66|      0|}
   67|       |
   68|      0|- (void)updateWithCheckinPlistContents:(NSDictionary *)checkinPlistContent {
   69|      0|  for (NSString *key in checkinPlistContent) {
   70|      0|    if ([kFIRInstanceIDDigestStringKey isEqualToString:key]) {
   71|      0|      self.digest = [checkinPlistContent[key] copy];
   72|      0|    } else if ([kFIRInstanceIDVersionInfoStringKey isEqualToString:key]) {
   73|      0|      self.versionInfo = [checkinPlistContent[key] copy];
   74|      0|    } else if ([kFIRInstanceIDLastCheckinTimeKey isEqualToString:key]) {
   75|      0|      self.lastCheckinTimestampMillis = [checkinPlistContent[key] longLongValue];
   76|      0|    } else if ([kFIRInstanceIDGServicesDictionaryKey isEqualToString:key]) {
   77|      0|      self.gServicesData = [checkinPlistContent[key] mutableCopy];
   78|      0|    } else if ([kFIRInstanceIDDeviceDataVersionKey isEqualToString:key]) {
   79|      0|      self.deviceDataVersion = [checkinPlistContent[key] copy];
   80|      0|    }
   81|      0|    // Otherwise we have some keys we don't care about
   82|      0|  }
   83|      0|}
   84|       |
   85|      0|- (NSString *)checkinKeychainContent {
   86|      0|  if ([self.deviceID length] && [self.secretToken length]) {
   87|      0|    return [NSString stringWithFormat:@"%@%@%@", self.deviceID,
   88|      0|                                      kCheckinKeychainContentSeparatorString, self.secretToken];
   89|      0|  } else {
   90|      0|    return nil;
   91|      0|  }
   92|      0|}
   93|       |
   94|     28|+ (NSString *)checkinDeviceIDFromKeychainContent:(NSString *)keychainContent {
   95|     28|  return [self checkinKeychainContent:keychainContent forIndex:0];
   96|     28|}
   97|       |
   98|     28|+ (NSString *)checkinSecretFromKeychainContent:(NSString *)keychainContent {
   99|     28|  return [self checkinKeychainContent:keychainContent forIndex:1];
  100|     28|}
  101|       |
  102|     56|+ (NSString *)checkinKeychainContent:(NSString *)keychainContent forIndex:(int)index {
  103|     56|  NSArray *keychainComponents =
  104|     56|      [keychainContent componentsSeparatedByString:kCheckinKeychainContentSeparatorString];
  105|     56|  if (index >= 0 && index < 2 && [keychainComponents count] == 2) {
  106|      0|    return keychainComponents[index];
  107|     56|  } else {
  108|     56|    return nil;
  109|     56|  }
  110|     56|}
  111|       |
  112|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDCheckinPreferences.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDCheckinPreferences.h"
   18|       |
   19|       |#import <GoogleUtilities/GULUserDefaults.h>
   20|       |#import "FIRInstanceIDCheckinService.h"
   21|       |#import "FIRInstanceIDDefines.h"
   22|       |#import "FIRInstanceIDUtilities.h"
   23|       |
   24|       |const NSTimeInterval kFIRInstanceIDDefaultCheckinInterval = 7 * 24 * 60 * 60;  // 7 days.
   25|       |
   26|       |@interface FIRInstanceIDCheckinPreferences ()
   27|       |
   28|       |@property(nonatomic, readwrite, copy) NSString *deviceID;
   29|       |@property(nonatomic, readwrite, copy) NSString *secretToken;
   30|       |@property(nonatomic, readwrite, copy) NSString *digest;
   31|       |@property(nonatomic, readwrite, copy) NSString *versionInfo;
   32|       |@property(nonatomic, readwrite, copy) NSString *deviceDataVersion;
   33|       |
   34|       |@property(nonatomic, readwrite, strong) NSMutableDictionary *gServicesData;
   35|       |@property(nonatomic, readwrite, assign) int64_t lastCheckinTimestampMillis;
   36|       |
   37|       |// This flag indicates that we have already saved the above deviceID and secret
   38|       |// to our keychain and hence we don't need to save again. This is helpful since
   39|       |// on checkin refresh we can avoid writing to the Keychain which can sometimes
   40|       |// be very buggy. For info check this https://forums.developer.apple.com/thread/4743
   41|       |@property(nonatomic, readwrite, assign) BOOL hasPreCachedAuthCredentials;
   42|       |
   43|       |@end
   44|       |
   45|       |@implementation FIRInstanceIDCheckinPreferences
   46|       |
   47|      0|- (NSDictionary *)checkinPlistContents {
   48|      0|  NSMutableDictionary *checkinPlistContents = [NSMutableDictionary dictionary];
   49|      0|  checkinPlistContents[kFIRInstanceIDDigestStringKey] = self.digest ?: @"";
   50|      0|  checkinPlistContents[kFIRInstanceIDVersionInfoStringKey] = self.versionInfo ?: @"";
   51|      0|  checkinPlistContents[kFIRInstanceIDDeviceDataVersionKey] = self.deviceDataVersion ?: @"";
   52|      0|  checkinPlistContents[kFIRInstanceIDLastCheckinTimeKey] = @(self.lastCheckinTimestampMillis);
   53|      0|  checkinPlistContents[kFIRInstanceIDGServicesDictionaryKey] =
   54|      0|      [self.gServicesData count] ? self.gServicesData : @{};
   55|      0|  return checkinPlistContents;
   56|      0|}
   57|       |
   58|      0|- (BOOL)hasCheckinInfo {
   59|      0|  return (self.deviceID.length && self.secretToken.length);
   60|      0|}
   61|       |
   62|      0|- (BOOL)hasValidCheckinInfo {
   63|      0|  int64_t currentTimestampInMillis = FIRInstanceIDCurrentTimestampInMilliseconds();
   64|      0|  int64_t timeSinceLastCheckinInMillis = currentTimestampInMillis - self.lastCheckinTimestampMillis;
   65|      0|  _FIRInstanceIDDevAssert(timeSinceLastCheckinInMillis >= 0,
   66|      0|                          @"FCM error: cannot have last checkin timestamp in future");
   67|      0|  BOOL hasCheckinInfo = [self hasCheckinInfo];
   68|      0|  NSString *lastLocale =
   69|      0|      [[GULUserDefaults standardUserDefaults] stringForKey:kFIRInstanceIDUserDefaultsKeyLocale];
   70|      0|  // If it's app's first time open and checkin is already fetched and no locale information is
   71|      0|  // stored, then checkin info is valid. We should not checkin again because locale is considered
   72|      0|  // "changed".
   73|      0|  if (hasCheckinInfo && !lastLocale) {
   74|      0|    NSString *currentLocale = FIRInstanceIDCurrentLocale();
   75|      0|    [[GULUserDefaults standardUserDefaults] setObject:currentLocale
   76|      0|                                               forKey:kFIRInstanceIDUserDefaultsKeyLocale];
   77|      0|    return YES;
   78|      0|  }
   79|      0|
   80|      0|  // If locale has changed, checkin info is no longer valid.
   81|      0|  // Also update locale information if changed. (Only do it here not in token refresh)
   82|      0|  if (FIRInstanceIDHasLocaleChanged()) {
   83|      0|    NSString *currentLocale = FIRInstanceIDCurrentLocale();
   84|      0|    [[GULUserDefaults standardUserDefaults] setObject:currentLocale
   85|      0|                                               forKey:kFIRInstanceIDUserDefaultsKeyLocale];
   86|      0|    return NO;
   87|      0|  }
   88|      0|
   89|      0|  return (hasCheckinInfo &&
   90|      0|          (timeSinceLastCheckinInMillis / 1000.0 < kFIRInstanceIDDefaultCheckinInterval));
   91|      0|}
   92|       |
   93|      0|- (void)setHasPreCachedAuthCredentials:(BOOL)hasPreCachedAuthCredentials {
   94|      0|  _hasPreCachedAuthCredentials = hasPreCachedAuthCredentials;
   95|      0|}
   96|       |
   97|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDCheckinService.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDCheckinService.h"
   18|       |
   19|       |#import <FirebaseCore/FIRAppInternal.h>
   20|       |#import "FIRInstanceIDCheckinPreferences+Internal.h"
   21|       |#import "FIRInstanceIDCheckinPreferences_Private.h"
   22|       |#import "FIRInstanceIDDefines.h"
   23|       |#import "FIRInstanceIDLogger.h"
   24|       |#import "FIRInstanceIDStore.h"
   25|       |#import "FIRInstanceIDUtilities.h"
   26|       |#import "NSError+FIRInstanceID.h"
   27|       |
   28|       |static NSString *const kDeviceCheckinURL = @"https://device-provisioning.googleapis.com/checkin";
   29|       |
   30|       |// keys in Checkin preferences
   31|       |NSString *const kFIRInstanceIDDeviceAuthIdKey = @"GMSInstanceIDDeviceAuthIdKey";
   32|       |NSString *const kFIRInstanceIDSecretTokenKey = @"GMSInstanceIDSecretTokenKey";
   33|       |NSString *const kFIRInstanceIDDigestStringKey = @"GMSInstanceIDDigestKey";
   34|       |NSString *const kFIRInstanceIDLastCheckinTimeKey = @"GMSInstanceIDLastCheckinTimestampKey";
   35|       |NSString *const kFIRInstanceIDVersionInfoStringKey = @"GMSInstanceIDVersionInfo";
   36|       |NSString *const kFIRInstanceIDGServicesDictionaryKey = @"GMSInstanceIDGServicesData";
   37|       |NSString *const kFIRInstanceIDDeviceDataVersionKey = @"GMSInstanceIDDeviceDataVersion";
   38|       |NSString *const kFIRInstanceIDFirebaseUserAgentKey = @"X-firebase-client";
   39|       |
   40|       |static NSUInteger const kCheckinType = 2;  // DeviceType IOS in l/w/a/_checkin.proto
   41|       |static NSUInteger const kCheckinVersion = 2;
   42|       |static NSUInteger const kFragment = 0;
   43|       |
   44|       |static FIRInstanceIDURLRequestTestBlock testBlock;
   45|       |
   46|       |@interface FIRInstanceIDCheckinService ()
   47|       |
   48|       |@property(nonatomic, readwrite, strong) NSURLSession *session;
   49|       |
   50|       |@end
   51|       |
   52|       |@implementation FIRInstanceIDCheckinService
   53|       |;
   54|       |
   55|     14|- (instancetype)init {
   56|     14|  self = [super init];
   57|     14|  if (self) {
   58|     14|    // Create an URLSession once, even though checkin should happen about once a day
   59|     14|    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
   60|     14|    config.timeoutIntervalForResource = 60.0f;  // 1 minute
   61|     14|    config.allowsCellularAccess = YES;
   62|     14|    _session = [NSURLSession sessionWithConfiguration:config];
   63|     14|    _session.sessionDescription = @"com.google.iid-checkin";
   64|     14|  }
   65|     14|  return self;
   66|     14|}
   67|       |
   68|      0|- (void)dealloc {
   69|      0|  testBlock = nil;
   70|      0|  [self.session invalidateAndCancel];
   71|      0|}
   72|       |
   73|       |- (void)checkinWithExistingCheckin:(FIRInstanceIDCheckinPreferences *)existingCheckin
   74|      0|                        completion:(FIRInstanceIDDeviceCheckinCompletion)completion {
   75|      0|  _FIRInstanceIDDevAssert(completion != nil, @"completion required");
   76|      0|
   77|      0|  if (self.session == nil) {
   78|      0|    FIRInstanceIDLoggerError(kFIRIntsanceIDInvalidNetworkSession,
   79|      0|                             @"Inconsistent state: NSURLSession has been invalidated");
   80|      0|    NSError *error =
   81|      0|        [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeRegistrarFailedToCheckIn];
   82|      0|    completion(nil, error);
   83|      0|    return;
   84|      0|  }
   85|      0|
   86|      0|  NSURL *url = [NSURL URLWithString:kDeviceCheckinURL];
   87|      0|  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
   88|      0|
   89|      0|  [request setValue:@"application/json" forHTTPHeaderField:@"content-type"];
   90|      0|  [request setValue:[FIRApp firebaseUserAgent]
   91|      0|      forHTTPHeaderField:kFIRInstanceIDFirebaseUserAgentKey];
   92|      0|
   93|      0|  NSDictionary *checkinParameters = [self checkinParametersWithExistingCheckin:existingCheckin];
   94|      0|  NSData *checkinData = [NSJSONSerialization dataWithJSONObject:checkinParameters
   95|      0|                                                        options:0
   96|      0|                                                          error:nil];
   97|      0|  request.HTTPMethod = @"POST";
   98|      0|  request.HTTPBody = checkinData;
   99|      0|
  100|      0|  void (^handler)(NSData *, NSURLResponse *, NSError *) =
  101|      0|      ^(NSData *data, NSURLResponse *response, NSError *error) {
  102|      0|        if (error) {
  103|      0|          FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeService000,
  104|      0|                                   @"Device checkin HTTP fetch error. Error Code: %ld",
  105|      0|                                   (long)error.code);
  106|      0|          completion(nil, error);
  107|      0|          return;
  108|      0|        }
  109|      0|
  110|      0|        NSError *serializationError;
  111|      0|        NSDictionary *dataResponse = [NSJSONSerialization JSONObjectWithData:data
  112|      0|                                                                     options:0
  113|      0|                                                                       error:&serializationError];
  114|      0|        if (serializationError) {
  115|      0|          FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeService001,
  116|      0|                                   @"Error serializing json object. Error Code: %ld",
  117|      0|                                   _FIRInstanceID_L(serializationError.code));
  118|      0|          completion(nil, serializationError);
  119|      0|          return;
  120|      0|        }
  121|      0|
  122|      0|        NSString *deviceAuthID = [dataResponse[@"android_id"] stringValue];
  123|      0|        NSString *secretToken = [dataResponse[@"security_token"] stringValue];
  124|      0|        if ([deviceAuthID length] == 0) {
  125|      0|          NSError *error =
  126|      0|              [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeInvalidRequest];
  127|      0|          completion(nil, error);
  128|      0|          return;
  129|      0|        }
  130|      0|
  131|      0|        int64_t lastCheckinTimestampMillis = [dataResponse[@"time_msec"] longLongValue];
  132|      0|        int64_t currentTimestampMillis = FIRInstanceIDCurrentTimestampInMilliseconds();
  133|      0|        // Somehow the server clock gets out of sync with the device clock.
  134|      0|        // Reset the last checkin timestamp in case this happens.
  135|      0|        if (lastCheckinTimestampMillis > currentTimestampMillis) {
  136|      0|          FIRInstanceIDLoggerDebug(
  137|      0|              kFIRInstanceIDMessageCodeService002, @"Invalid last checkin timestamp %@ in future.",
  138|      0|              [NSDate dateWithTimeIntervalSince1970:lastCheckinTimestampMillis / 1000.0]);
  139|      0|          lastCheckinTimestampMillis = currentTimestampMillis;
  140|      0|        }
  141|      0|
  142|      0|        NSString *deviceDataVersionInfo = dataResponse[@"device_data_version_info"] ?: @"";
  143|      0|        NSString *digest = dataResponse[@"digest"] ?: @"";
  144|      0|
  145|      0|        FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeService003,
  146|      0|                                 @"Checkin successful with authId: %@, "
  147|      0|                                 @"digest: %@, "
  148|      0|                                 @"lastCheckinTimestamp: %lld",
  149|      0|                                 deviceAuthID, digest, lastCheckinTimestampMillis);
  150|      0|
  151|      0|        NSString *versionInfo = dataResponse[@"version_info"] ?: @"";
  152|      0|        NSMutableDictionary *gservicesData = [NSMutableDictionary dictionary];
  153|      0|
  154|      0|        // Read gServices data.
  155|      0|        NSArray *flatSettings = dataResponse[@"setting"];
  156|      0|        for (NSDictionary *dict in flatSettings) {
  157|      0|          if (dict[@"name"] && dict[@"value"]) {
  158|      0|            gservicesData[dict[@"name"]] = dict[@"value"];
  159|      0|          } else {
  160|      0|            _FIRInstanceIDDevAssert(NO, @"Invalid setting in checkin response: (%@: %@)",
  161|      0|                                    dict[@"name"], dict[@"value"]);
  162|      0|          }
  163|      0|        }
  164|      0|
  165|      0|        FIRInstanceIDCheckinPreferences *checkinPreferences =
  166|      0|            [[FIRInstanceIDCheckinPreferences alloc] initWithDeviceID:deviceAuthID
  167|      0|                                                          secretToken:secretToken];
  168|      0|        NSDictionary *preferences = @{
  169|      0|          kFIRInstanceIDDigestStringKey : digest,
  170|      0|          kFIRInstanceIDVersionInfoStringKey : versionInfo,
  171|      0|          kFIRInstanceIDLastCheckinTimeKey : @(lastCheckinTimestampMillis),
  172|      0|          kFIRInstanceIDGServicesDictionaryKey : gservicesData,
  173|      0|          kFIRInstanceIDDeviceDataVersionKey : deviceDataVersionInfo,
  174|      0|        };
  175|      0|        [checkinPreferences updateWithCheckinPlistContents:preferences];
  176|      0|        completion(checkinPreferences, nil);
  177|      0|      };
  178|      0|  // Test block
  179|      0|  if (testBlock) {
  180|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeService005,
  181|      0|                             @"Test block set, will not hit the server");
  182|      0|    testBlock(request, handler);
  183|      0|    return;
  184|      0|  }
  185|      0|
  186|      0|  NSURLSessionDataTask *task = [self.session dataTaskWithRequest:request completionHandler:handler];
  187|      0|  [task resume];
  188|      0|}
  189|       |
  190|      0|- (void)stopFetching {
  191|      0|  [self.session invalidateAndCancel];
  192|      0|  // The session cannot be reused after invalidation. Dispose it to prevent accident reusing.
  193|      0|  self.session = nil;
  194|      0|}
  195|       |
  196|       |#pragma mark - Private
  197|       |
  198|       |- (NSDictionary *)checkinParametersWithExistingCheckin:
  199|      0|    (nullable FIRInstanceIDCheckinPreferences *)checkinPreferences {
  200|      0|  NSString *deviceModel = FIRInstanceIDDeviceModel();
  201|      0|  NSString *systemVersion = FIRInstanceIDOperatingSystemVersion();
  202|      0|  NSString *osVersion = [NSString stringWithFormat:@"IOS_%@", systemVersion];
  203|      0|
  204|      0|  // Get locale from GCM if GCM exists else use system API.
  205|      0|  NSString *locale = FIRInstanceIDCurrentLocale();
  206|      0|
  207|      0|  NSInteger userNumber = 0;        // Multi Profile may change this.
  208|      0|  NSInteger userSerialNumber = 0;  // Multi Profile may change this
  209|      0|
  210|      0|  uint32_t loggingID = arc4random();
  211|      0|  NSString *timeZone = [NSTimeZone localTimeZone].name;
  212|      0|  int64_t lastCheckingTimestampMillis = checkinPreferences.lastCheckinTimestampMillis;
  213|      0|
  214|      0|  NSDictionary *checkinParameters = @{
  215|      0|    @"checkin" : @{
  216|      0|      @"iosbuild" : @{@"model" : deviceModel, @"os_version" : osVersion},
  217|      0|      @"type" : @(kCheckinType),
  218|      0|      @"user_number" : @(userNumber),
  219|      0|      @"last_checkin_msec" : @(lastCheckingTimestampMillis),
  220|      0|    },
  221|      0|    @"fragment" : @(kFragment),
  222|      0|    @"logging_id" : @(loggingID),
  223|      0|    @"locale" : locale,
  224|      0|    @"version" : @(kCheckinVersion),
  225|      0|    @"digest" : checkinPreferences.digest ?: @"",
  226|      0|    @"timezone" : timeZone,
  227|      0|    @"user_serial_number" : @(userSerialNumber),
  228|      0|    @"id" : @([checkinPreferences.deviceID longLongValue]),
  229|      0|    @"security_token" : @([checkinPreferences.secretToken longLongValue]),
  230|      0|  };
  231|      0|
  232|      0|  FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeService006, @"Checkin parameters: %@",
  233|      0|                           checkinParameters);
  234|      0|  return checkinParameters;
  235|      0|}
  236|       |
  237|      0|+ (void)setCheckinTestBlock:(FIRInstanceIDURLRequestTestBlock)block {
  238|      0|  testBlock = [block copy];
  239|      0|}
  240|       |
  241|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDCheckinStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDCheckinStore.h"
   18|       |
   19|       |#import "FIRInstanceIDAuthKeyChain.h"
   20|       |#import "FIRInstanceIDBackupExcludedPlist.h"
   21|       |#import "FIRInstanceIDCheckinPreferences+Internal.h"
   22|       |#import "FIRInstanceIDCheckinPreferences_Private.h"
   23|       |#import "FIRInstanceIDCheckinService.h"
   24|       |#import "FIRInstanceIDLogger.h"
   25|       |#import "FIRInstanceIDUtilities.h"
   26|       |#import "FIRInstanceIDVersionUtilities.h"
   27|       |#import "NSError+FIRInstanceID.h"
   28|       |
   29|       |static NSString *const kFIRInstanceIDCheckinKeychainGeneric = @"com.google.iid";
   30|       |
   31|       |NSString *const kFIRInstanceIDCheckinKeychainService = @"com.google.iid.checkin";
   32|       |NSString *const kFIRInstanceIDLegacyCheckinKeychainAccount = @"com.google.iid.checkin-account";
   33|       |NSString *const kFIRInstanceIDLegacyCheckinKeychainService = @"com.google.iid.checkin-service";
   34|       |
   35|       |// Checkin plist used to have the deviceID and secret stored in them and that's why they
   36|       |// had 6 items in it. Since the deviceID and secret have been moved to the keychain
   37|       |// there would only be 4 items.
   38|       |static const NSInteger kOldCheckinPlistCount = 6;
   39|       |
   40|       |@interface FIRInstanceIDCheckinStore ()
   41|       |
   42|       |@property(nonatomic, readwrite, strong) FIRInstanceIDBackupExcludedPlist *plist;
   43|       |@property(nonatomic, readwrite, strong) FIRInstanceIDAuthKeychain *keychain;
   44|       |// Checkin will store items under
   45|       |// Keychain account: <app bundle id>,
   46|       |// Keychain service: |kFIRInstanceIDCheckinKeychainService|
   47|       |@property(nonatomic, readonly) NSString *bundleIdentifierForKeychainAccount;
   48|       |
   49|       |@end
   50|       |
   51|       |@implementation FIRInstanceIDCheckinStore
   52|       |
   53|       |- (instancetype)initWithCheckinPlistFileName:(NSString *)checkinFilename
   54|     14|                            subDirectoryName:(NSString *)subDirectoryName {
   55|     14|  FIRInstanceIDBackupExcludedPlist *plist =
   56|     14|      [[FIRInstanceIDBackupExcludedPlist alloc] initWithFileName:checkinFilename
   57|     14|                                                    subDirectory:subDirectoryName];
   58|     14|
   59|     14|  FIRInstanceIDAuthKeychain *keychain =
   60|     14|      [[FIRInstanceIDAuthKeychain alloc] initWithIdentifier:kFIRInstanceIDCheckinKeychainGeneric];
   61|     14|  return [self initWithCheckinPlist:plist keychain:keychain];
   62|     14|}
   63|       |
   64|       |- (instancetype)initWithCheckinPlist:(FIRInstanceIDBackupExcludedPlist *)plist
   65|     14|                            keychain:(FIRInstanceIDAuthKeychain *)keychain {
   66|     14|  self = [super init];
   67|     14|  if (self) {
   68|     14|    _plist = plist;
   69|     14|    _keychain = keychain;
   70|     14|  }
   71|     14|  return self;
   72|     14|}
   73|       |
   74|     14|- (BOOL)hasCheckinPlist {
   75|     14|  return [self.plist doesFileExist];
   76|     14|}
   77|       |
   78|     28|- (NSString *)bundleIdentifierForKeychainAccount {
   79|     28|  static NSString *bundleIdentifier;
   80|     28|  static dispatch_once_t onceToken;
   81|     28|  dispatch_once(&onceToken, ^{
   82|     14|    bundleIdentifier = FIRInstanceIDAppIdentifier();
   83|     14|  });
   84|     28|  return bundleIdentifier;
   85|     28|}
   86|       |
   87|       |- (void)saveCheckinPreferences:(FIRInstanceIDCheckinPreferences *)preferences
   88|      0|                       handler:(void (^)(NSError *error))handler {
   89|      0|  NSDictionary *checkinPlistContents = [preferences checkinPlistContents];
   90|      0|  NSString *checkinKeychainContent = [preferences checkinKeychainContent];
   91|      0|
   92|      0|  if (![checkinKeychainContent length]) {
   93|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeCheckinStore000,
   94|      0|                             @"Failed to get checkin keychain content from memory.");
   95|      0|    if (handler) {
   96|      0|      handler([NSError
   97|      0|          errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeRegistrarFailedToCheckIn]);
   98|      0|    }
   99|      0|    return;
  100|      0|  }
  101|      0|  if (![checkinPlistContents count]) {
  102|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeCheckinStore001,
  103|      0|                             @"Failed to get checkin plist contents from memory.");
  104|      0|    if (handler) {
  105|      0|      handler([NSError
  106|      0|          errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeRegistrarFailedToCheckIn]);
  107|      0|    }
  108|      0|    return;
  109|      0|  }
  110|      0|
  111|      0|  // Save all other checkin preferences in a plist
  112|      0|  NSError *error;
  113|      0|  if (![self.plist writeDictionary:checkinPlistContents error:&error]) {
  114|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeCheckinStore003,
  115|      0|                             @"Failed to save checkin plist contents."
  116|      0|                             @"Will delete auth credentials");
  117|      0|    [self.keychain removeItemsMatchingService:kFIRInstanceIDCheckinKeychainService
  118|      0|                                      account:self.bundleIdentifierForKeychainAccount
  119|      0|                                      handler:nil];
  120|      0|    if (handler) {
  121|      0|      handler(error);
  122|      0|    }
  123|      0|    return;
  124|      0|  }
  125|      0|  // Save the deviceID and secret in the Keychain
  126|      0|  if (!preferences.hasPreCachedAuthCredentials) {
  127|      0|    NSData *data = [checkinKeychainContent dataUsingEncoding:NSUTF8StringEncoding];
  128|      0|    [self.keychain setData:data
  129|      0|                forService:kFIRInstanceIDCheckinKeychainService
  130|      0|             accessibility:nil
  131|      0|                   account:self.bundleIdentifierForKeychainAccount
  132|      0|                   handler:^(NSError *error) {
  133|      0|                     if (error) {
  134|      0|                       if (handler) {
  135|      0|                         handler(error);
  136|      0|                       }
  137|      0|                       return;
  138|      0|                     }
  139|      0|                     if (handler) {
  140|      0|                       handler(nil);
  141|      0|                     }
  142|      0|                   }];
  143|      0|  } else {
  144|      0|    handler(nil);
  145|      0|  }
  146|      0|}
  147|       |
  148|      0|- (void)removeCheckinPreferencesWithHandler:(void (^)(NSError *error))handler {
  149|      0|  // Remove deviceID and secret from Keychain
  150|      0|  [self.keychain
  151|      0|      removeItemsMatchingService:kFIRInstanceIDCheckinKeychainService
  152|      0|                         account:self.bundleIdentifierForKeychainAccount
  153|      0|                         handler:^(NSError *error) {
  154|      0|                           if (error) {
  155|      0|                             if (handler) {
  156|      0|                               handler(error);
  157|      0|                             }
  158|      0|                             return;
  159|      0|                           }
  160|      0|                           // Delete the checkin preferences plist
  161|      0|                           NSError *deletePlistError;
  162|      0|                           [self.plist deleteFile:&deletePlistError];
  163|      0|
  164|      0|                           // Try to remove from old location as well because migration
  165|      0|                           // is no longer needed. Consider this is either a fresh install
  166|      0|                           // or an identity wipe.
  167|      0|                           [self.keychain
  168|      0|                               removeItemsMatchingService:kFIRInstanceIDLegacyCheckinKeychainService
  169|      0|                                                  account:kFIRInstanceIDLegacyCheckinKeychainAccount
  170|      0|                                                  handler:nil];
  171|      0|                           handler(deletePlistError);
  172|      0|                         }];
  173|      0|}
  174|       |
  175|     28|- (FIRInstanceIDCheckinPreferences *)cachedCheckinPreferences {
  176|     28|  // Query the keychain for deviceID and secret
  177|     28|  NSData *item = [self.keychain dataForService:kFIRInstanceIDCheckinKeychainService
  178|     28|                                       account:self.bundleIdentifierForKeychainAccount];
  179|     28|
  180|     28|  // Check info found in keychain
  181|     28|  NSString *checkinKeychainContent = [[NSString alloc] initWithData:item
  182|     28|                                                           encoding:NSUTF8StringEncoding];
  183|     28|  FIRInstanceIDCheckinPreferences *checkinPreferences =
  184|     28|      [FIRInstanceIDCheckinPreferences preferencesFromKeychainContents:checkinKeychainContent];
  185|     28|
  186|     28|  NSDictionary *checkinPlistContents = [self.plist contentAsDictionary];
  187|     28|
  188|     28|  NSString *plistDeviceAuthID = checkinPlistContents[kFIRInstanceIDDeviceAuthIdKey];
  189|     28|  NSString *plistSecretToken = checkinPlistContents[kFIRInstanceIDSecretTokenKey];
  190|     28|
  191|     28|  // If deviceID and secret not found in the keychain verify that we don't have them in the
  192|     28|  // checkin preferences plist.
  193|     28|  if (![checkinPreferences.deviceID length] && ![checkinPreferences.secretToken length]) {
  194|     28|    if ([plistDeviceAuthID length] && [plistSecretToken length]) {
  195|      0|      // Couldn't find checkin credentials in keychain but found them in the plist.
  196|      0|      checkinPreferences =
  197|      0|          [[FIRInstanceIDCheckinPreferences alloc] initWithDeviceID:plistDeviceAuthID
  198|      0|                                                        secretToken:plistSecretToken];
  199|     28|    } else {
  200|     28|      // Couldn't find checkin credentials in keychain nor plist
  201|     28|      return nil;
  202|     28|    }
  203|      0|  } else if (kOldCheckinPlistCount == checkinPlistContents.count) {
  204|      0|    // same check as above but just to be extra sure that we cover all upgrade cases properly.
  205|      0|    // TODO(chliangGoogle): Remove this case, after verifying it's not needed
  206|      0|    if ([plistDeviceAuthID length] && [plistSecretToken length]) {
  207|      0|      checkinPreferences =
  208|      0|          [[FIRInstanceIDCheckinPreferences alloc] initWithDeviceID:plistDeviceAuthID
  209|      0|                                                        secretToken:plistSecretToken];
  210|      0|    }
  211|      0|  }
  212|     28|
  213|     28|  [checkinPreferences updateWithCheckinPlistContents:checkinPlistContents];
  214|      0|  return checkinPreferences;
  215|     28|}
  216|       |
  217|      0|- (void)migrateCheckinItemIfNeeded {
  218|      0|  // Check for checkin in the old location, using the legacy keys
  219|      0|  // Query the keychain for deviceID and secret
  220|      0|  NSData *dataInOldLocation =
  221|      0|      [self.keychain dataForService:kFIRInstanceIDLegacyCheckinKeychainService
  222|      0|                            account:kFIRInstanceIDLegacyCheckinKeychainAccount];
  223|      0|  if (dataInOldLocation) {
  224|      0|    // Save to new location
  225|      0|    [self.keychain setData:dataInOldLocation
  226|      0|                forService:kFIRInstanceIDCheckinKeychainService
  227|      0|             accessibility:NULL
  228|      0|                   account:self.bundleIdentifierForKeychainAccount
  229|      0|                   handler:nil];
  230|      0|    // Remove from old location
  231|      0|    [self.keychain removeItemsMatchingService:kFIRInstanceIDLegacyCheckinKeychainService
  232|      0|                                      account:kFIRInstanceIDLegacyCheckinKeychainAccount
  233|      0|                                      handler:nil];
  234|      0|  }
  235|      0|}
  236|       |
  237|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDCombinedHandler.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDCombinedHandler.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |typedef void (^FIRInstanseIDHandler)(id _Nullable result, NSError *_Nullable error);
   22|       |
   23|       |@interface FIRInstanceIDCombinedHandler <ResultType>()
   24|       |@property(atomic, readonly, strong) NSMutableArray<FIRInstanseIDHandler> *handlers;
   25|       |@end
   26|       |
   27|       |NS_ASSUME_NONNULL_END
   28|       |
   29|       |@implementation FIRInstanceIDCombinedHandler
   30|       |
   31|      0|- (instancetype)init {
   32|      0|  self = [super init];
   33|      0|  if (self) {
   34|      0|    _handlers = [NSMutableArray array];
   35|      0|  }
   36|      0|  return self;
   37|      0|}
   38|       |
   39|      0|- (void)addHandler:(FIRInstanseIDHandler)handler {
   40|      0|  if (!handler) {
   41|      0|    return;
   42|      0|  }
   43|      0|
   44|      0|  @synchronized(self) {
   45|      0|    [self.handlers addObject:handler];
   46|      0|  }
   47|      0|}
   48|       |
   49|      0|- (FIRInstanseIDHandler)combinedHandler {
   50|      0|  FIRInstanseIDHandler combinedHandler = nil;
   51|      0|
   52|      0|  @synchronized(self) {
   53|      0|    NSArray<FIRInstanseIDHandler> *handlers = [self.handlers copy];
   54|      0|    combinedHandler = ^(id result, NSError *error) {
   55|      0|      for (FIRInstanseIDHandler handler in handlers) {
   56|      0|        handler(result, error);
   57|      0|      }
   58|      0|    };
   59|      0|  }
   60|      0|
   61|      0|  return combinedHandler;
   62|      0|}
   63|       |
   64|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDDefines.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#ifndef FIRInstanceIDLib_FIRInstanceIDDefines_h
   18|       |#define FIRInstanceIDLib_FIRInstanceIDDefines_h
   19|       |
   20|       |#define _FIRInstanceID_VERBOSE_LOGGING 1
   21|       |
   22|       |// Verbose Logging
   23|       |#if (_FIRInstanceID_VERBOSE_LOGGING)
   24|       |#define FIRInstanceID_DEV_VERBOSE_LOG(...) NSLog(__VA_ARGS__)
   25|       |#else
   26|       |#define FIRInstanceID_DEV_VERBOSE_LOG(...) \
   27|       |  do {                                     \
   28|       |  } while (0)
   29|       |#endif  // VERBOSE_LOGGING
   30|       |
   31|       |// WEAKIFY & STRONGIFY
   32|       |// Helper macro.
   33|      0|#define _FIRInstanceID_WEAKNAME(VAR) VAR##_weak_
   34|       |
   35|      0|#define FIRInstanceID_WEAKIFY(VAR) __weak __typeof__(VAR) _FIRInstanceID_WEAKNAME(VAR) = (VAR);
   36|       |
   37|       |#define FIRInstanceID_STRONGIFY(VAR)                                                \
   38|      0|  _Pragma("clang diagnostic push") _Pragma("clang diagnostic ignored \"-Wshadow\"") \
   39|      0|      __strong __typeof__(VAR) VAR = _FIRInstanceID_WEAKNAME(VAR);                  \
   40|      0|  _Pragma("clang diagnostic pop")
   41|       |
   42|       |// Type Conversions (used for NSInteger etc)
   43|       |#ifndef _FIRInstanceID_L
   44|       |#define _FIRInstanceID_L(v) (long)(v)
   45|       |#endif
   46|       |
   47|       |#endif
   48|       |
   49|       |// Debug Assert
   50|       |#ifndef _FIRInstanceIDDevAssert
   51|       |// we directly invoke the NSAssert handler so we can pass on the varargs
   52|       |// (NSAssert doesn't have a macro we can use that takes varargs)
   53|       |#if !defined(NS_BLOCK_ASSERTIONS)
   54|       |#define _FIRInstanceIDDevAssert(condition, ...)                                                   \
   55|    210|  do {                                                                                            \
   56|    210|    if (!(condition)) {                                                                           \
   57|      0|      [[NSAssertionHandler currentHandler]                                                        \
   58|      0|          handleFailureInFunction:(NSString *)[NSString stringWithUTF8String:__PRETTY_FUNCTION__] \
   59|      0|                             file:(NSString *)[NSString stringWithUTF8String:__FILE__]            \
   60|      0|                       lineNumber:__LINE__                                                        \
   61|      0|                      description:__VA_ARGS__];                                                   \
   62|      0|    }                                                                                             \
   63|    210|  } while (0)
   64|       |#else  // !defined(NS_BLOCK_ASSERTIONS)
   65|       |#define _FIRInstanceIDDevAssert(condition, ...) \
   66|       |  do {                                          \
   67|       |  } while (0)
   68|       |#endif  // !defined(NS_BLOCK_ASSERTIONS)
   69|       |
   70|       |#endif  // _FIRInstanceIDDevAssert

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDKeyPair.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDKeyPair.h"
   18|       |
   19|       |#import <Security/Security.h>
   20|       |
   21|       |#import "FIRInstanceIDKeyPairUtilities.h"
   22|       |#import "FIRInstanceIDKeychain.h"
   23|       |#import "FIRInstanceIDLogger.h"
   24|       |#import "NSError+FIRInstanceID.h"
   25|       |
   26|       |@interface FIRInstanceIDKeyPair () {
   27|       |  SecKeyRef _privateKey;
   28|       |  SecKeyRef _publicKey;
   29|       |}
   30|       |
   31|       |@property(nonatomic, readwrite, strong) NSData *publicKeyData;
   32|       |@property(nonatomic, readwrite, strong) NSData *privateKeyData;
   33|       |@end
   34|       |
   35|       |@implementation FIRInstanceIDKeyPair
   36|       |- (instancetype)initWithPrivateKey:(SecKeyRef)privateKey
   37|       |                         publicKey:(SecKeyRef)publicKey
   38|       |                     publicKeyData:(NSData *)publicKeyData
   39|     14|                    privateKeyData:(NSData *)privateKeyData {
   40|     14|  self = [super init];
   41|     14|  if (self) {
   42|     14|    _privateKey = privateKey;
   43|     14|    _publicKey = publicKey;
   44|     14|    _publicKeyData = publicKeyData;
   45|     14|    _privateKeyData = privateKeyData;
   46|     14|  }
   47|     14|  return self;
   48|     14|}
   49|       |
   50|      0|- (void)dealloc {
   51|      0|  if (_privateKey) {
   52|      0|    CFRelease(_privateKey);
   53|      0|  }
   54|      0|  if (_publicKey) {
   55|      0|    CFRelease(_publicKey);
   56|      0|  }
   57|      0|}
   58|       |
   59|       |#pragma mark - Info
   60|       |
   61|     64|- (BOOL)isValid {
   62|     64|  return _privateKey != NULL && _publicKey != NULL;
   63|     64|}
   64|       |
   65|     77|- (SecKeyRef)publicKey {
   66|     77|  return _publicKey;
   67|     77|}
   68|       |
   69|      0|- (SecKeyRef)privateKey {
   70|      0|  return _privateKey;
   71|      0|}
   72|       |
   73|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDKeyPairStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDKeyPairStore.h"
   18|       |
   19|       |#import "FIRInstanceIDBackupExcludedPlist.h"
   20|       |#import "FIRInstanceIDConstants.h"
   21|       |#import "FIRInstanceIDDefines.h"
   22|       |#import "FIRInstanceIDKeyPair.h"
   23|       |#import "FIRInstanceIDKeyPairUtilities.h"
   24|       |#import "FIRInstanceIDKeychain.h"
   25|       |#import "FIRInstanceIDLogger.h"
   26|       |#import "FIRInstanceIDUtilities.h"
   27|       |#import "NSError+FIRInstanceID.h"
   28|       |
   29|       |// NOTE: These values should be in sync with what InstanceID saves in as.
   30|       |static NSString *const kFIRInstanceIDKeyPairStoreFileName = @"com.google.iid-keypair";
   31|       |
   32|       |static NSString *const kFIRInstanceIDStoreKeyGenerationTime = @"cre";
   33|       |
   34|       |static NSString *const kFIRInstanceIDStoreKeyPrefix = @"com.google.iid-";
   35|       |static NSString *const kFIRInstanceIDStoreKeyPublic = @"|P|";
   36|       |static NSString *const kFIRInstanceIDStoreKeyPrivate = @"|K|";
   37|       |static NSString *const kFIRInstanceIDStoreKeySubtype = @"|S|";
   38|       |
   39|       |static NSString *const kFIRInstanceIDKeyPairPublicTagPrefix = @"com.google.iid.keypair.public-";
   40|       |static NSString *const kFIRInstanceIDKeyPairPrivateTagPrefix = @"com.google.iid.keypair.private-";
   41|       |
   42|       |static const int kMaxMissingEntitlementErrorCount = 3;
   43|       |
   44|       |NSString *const kFIRInstanceIDKeyPairSubType = @"";
   45|       |
   46|       |// Query the key with NSData format
   47|     26|NSData *FIRInstanceIDKeyDataWithTag(NSString *tag) {
   48|     26|  _FIRInstanceIDDevAssert([tag length], @"Invalid tag for keychain specified");
   49|     26|  if (![tag length]) {
   50|      0|    return NULL;
   51|      0|  }
   52|     26|  NSDictionary *queryKey = FIRInstanceIDKeyPairQuery(tag, YES, YES);
   53|     26|  CFTypeRef result = [[FIRInstanceIDKeychain sharedInstance] itemWithQuery:queryKey];
   54|     26|  if (!result) {
   55|      0|    return NULL;
   56|      0|  }
   57|     26|  return (__bridge NSData *)result;
   58|     26|}
   59|       |
   60|       |// Query the key given a tag
   61|     52|SecKeyRef FIRInstanceIDCachedKeyRefWithTag(NSString *tag) {
   62|     52|  _FIRInstanceIDDevAssert([tag length], @"Invalid tag for keychain specified");
   63|     52|  if (!tag.length) {
   64|      0|    return NULL;
   65|      0|  }
   66|     52|  NSDictionary *queryKey = FIRInstanceIDKeyPairQuery(tag, YES, NO);
   67|     52|  CFTypeRef result = [[FIRInstanceIDKeychain sharedInstance] itemWithQuery:queryKey];
   68|     52|  return (SecKeyRef)result;
   69|     52|}
   70|       |
   71|       |// Check if keypair has been migrated from the legacy to the new version
   72|      0|BOOL FIRInstanceIDHasMigratedKeyPair(NSString *legacyPublicKeyTag, NSString *newPublicKeyTag) {
   73|      0|  NSData *oldPublicKeyData = FIRInstanceIDKeyDataWithTag(legacyPublicKeyTag);
   74|      0|  NSData *newPublicKeyData = FIRInstanceIDKeyDataWithTag(newPublicKeyTag);
   75|      0|  return [oldPublicKeyData isEqualToData:newPublicKeyData];
   76|      0|}
   77|       |
   78|       |// The legacy value is hardcoded to be the same key. This is a potential problem in shared keychain
   79|       |// environments.
   80|     14|NSString *FIRInstanceIDLegacyPublicTagWithSubtype(NSString *subtype) {
   81|     14|  NSString *prefix = kFIRInstanceIDStoreKeyPrefix;
   82|     14|  return [NSString stringWithFormat:@"%@%@%@", prefix, subtype, kFIRInstanceIDStoreKeyPublic];
   83|     14|}
   84|       |
   85|       |// The legacy value is hardcoded to be the same key. This is a potential problem in shared keychain
   86|       |// environments.
   87|     14|NSString *FIRInstanceIDLegacyPrivateTagWithSubtype(NSString *subtype) {
   88|     14|  NSString *prefix = kFIRInstanceIDStoreKeyPrefix;
   89|     14|  return [NSString stringWithFormat:@"%@%@%@", prefix, subtype, kFIRInstanceIDStoreKeyPrivate];
   90|     14|}
   91|       |
   92|     15|NSString *FIRInstanceIDPublicTagWithSubtype(NSString *subtype) {
   93|     15|  static NSString *publicTag;
   94|     15|  static dispatch_once_t onceToken;
   95|     15|  dispatch_once(&onceToken, ^{
   96|     14|    NSString *mainAppBundleID = FIRInstanceIDAppIdentifier();
   97|     14|    publicTag =
   98|     14|        [NSString stringWithFormat:@"%@%@", kFIRInstanceIDKeyPairPublicTagPrefix, mainAppBundleID];
   99|     14|  });
  100|     15|  return publicTag;
  101|     15|}
  102|       |
  103|     15|NSString *FIRInstanceIDPrivateTagWithSubtype(NSString *subtype) {
  104|     15|  static NSString *privateTag;
  105|     15|  static dispatch_once_t onceToken;
  106|     15|  dispatch_once(&onceToken, ^{
  107|     14|    NSString *mainAppBundleID = FIRInstanceIDAppIdentifier();
  108|     14|    privateTag =
  109|     14|        [NSString stringWithFormat:@"%@%@", kFIRInstanceIDKeyPairPrivateTagPrefix, mainAppBundleID];
  110|     14|  });
  111|     15|  return privateTag;
  112|     15|}
  113|       |
  114|     16|NSString *FIRInstanceIDCreationTimeKeyWithSubtype(NSString *subtype) {
  115|     16|  return [NSString stringWithFormat:@"%@%@%@", subtype, kFIRInstanceIDStoreKeySubtype,
  116|     16|                                    kFIRInstanceIDStoreKeyGenerationTime];
  117|     16|}
  118|       |
  119|       |@interface FIRInstanceIDKeyPairStore ()
  120|       |
  121|       |@property(nonatomic, readwrite, strong) FIRInstanceIDBackupExcludedPlist *plist;
  122|       |@property(nonatomic, readwrite, strong) FIRInstanceIDKeyPair *keyPair;
  123|       |@property(nonatomic, readwrite, assign) NSInteger keychainEntitlementsErrorCount;
  124|       |
  125|       |@end
  126|       |
  127|       |@implementation FIRInstanceIDKeyPairStore
  128|       |
  129|     14|- (instancetype)init {
  130|     14|  self = [super init];
  131|     14|  if (self) {
  132|     14|    NSString *fileName = [[self class] keyStoreFileName];
  133|     14|    _plist =
  134|     14|        [[FIRInstanceIDBackupExcludedPlist alloc] initWithFileName:fileName
  135|     14|                                                      subDirectory:kFIRInstanceIDSubDirectoryName];
  136|     14|  }
  137|     14|  return self;
  138|     14|}
  139|       |
  140|     14|- (BOOL)invalidateKeyPairsIfNeeded {
  141|     14|  // Currently keypairs are always invalidated if self.plist is missing. This normally indicates
  142|     14|  // a fresh install (or an uninstall/reinstall). In those situations the key pairs should be
  143|     14|  // deleted.
  144|     14|  // NOTE: Although this class refers to multiple key pairs, with different subtypes, in practice
  145|     14|  // only a single subtype is currently supported. (b/64906549)
  146|     14|  if (![self.plist doesFileExist]) {
  147|      1|    // A fresh install, clear all the key pairs in the key chain. Do not perform migration as all
  148|      1|    // key pairs are gone.
  149|      1|    [self deleteSavedKeyPairWithSubtype:kFIRInstanceIDKeyPairSubType handler:nil];
  150|      1|    return YES;
  151|      1|  }
  152|     13|  // Not a fresh install, perform migration at early state.
  153|     13|  [self migrateKeyPairCacheIfNeededWithHandler:nil];
  154|     13|  return NO;
  155|     13|}
  156|       |
  157|      0|- (BOOL)hasCachedKeyPairs {
  158|      0|  NSError *error;
  159|      0|  if ([self cachedKeyPairWithSubtype:kFIRInstanceIDKeyPairSubType error:&error] == nil) {
  160|      0|    if (error) {
  161|      0|      FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeKeyPairStore000,
  162|      0|                               @"Failed to get the cached keyPair %@", error);
  163|      0|    }
  164|      0|    error = nil;
  165|      0|    [self removeKeyPairCreationTimePlistWithError:&error];
  166|      0|    if (error) {
  167|      0|      FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeKeyPairStore001,
  168|      0|                               @"Failed to remove keyPair creationTime plist %@", error);
  169|      0|    }
  170|      0|    return NO;
  171|      0|  }
  172|      0|  return YES;
  173|      0|}
  174|       |
  175|     77|- (NSString *)appIdentityWithError:(NSError *__autoreleasing *)error {
  176|     77|  // Load the keyPair from Keychain (or generate a key pair, if this is the first run of the app).
  177|     77|  FIRInstanceIDKeyPair *keyPair = [self loadKeyPairWithError:error];
  178|     77|  if (!keyPair) {
  179|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeKeyPairStoreCouldNotLoadKeyPair,
  180|      0|                             @"Keypair could not be loaded from Keychain. Error: %@", (*error));
  181|      0|    return nil;
  182|      0|  }
  183|     77|
  184|     77|  if (error) {
  185|     77|    *error = nil;
  186|     77|  }
  187|     77|  NSString *appIdentity = FIRInstanceIDAppIdentity(keyPair);
  188|     77|  if (!appIdentity.length) {
  189|      0|    if (error) {
  190|      0|      *error = [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeUnknown];
  191|      0|    }
  192|      0|  }
  193|     77|  return appIdentity;
  194|     77|}
  195|       |
  196|     77|- (FIRInstanceIDKeyPair *)loadKeyPairWithError:(NSError **)error {
  197|     77|  // In case we call this from different threads we don't want to generate or fetch the
  198|     77|  // keyPair multiple times. Once we have a keyPair in the cache it would mostly be used
  199|     77|  // from there.
  200|     77|  @synchronized(self) {
  201|     77|    if ([self.keyPair isValid]) {
  202|     63|      return self.keyPair;
  203|     63|    }
  204|     14|
  205|     14|    if (self.keychainEntitlementsErrorCount >= kMaxMissingEntitlementErrorCount) {
  206|      0|      FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeKeyPairStore002,
  207|      0|                               @"Keychain not accessible, Entitlements missing error (-34018). "
  208|      0|                               @"Will not check token in cache.");
  209|      0|      return nil;
  210|      0|    }
  211|     14|
  212|     14|    if (!self.keyPair) {
  213|     14|      self.keyPair = [self validCachedKeyPairWithSubtype:kFIRInstanceIDKeyPairSubType error:error];
  214|     14|    }
  215|     14|
  216|     14|    if ((*error).code == kFIRInstanceIDSecMissingEntitlementErrorCode) {
  217|      0|      self.keychainEntitlementsErrorCount++;
  218|      0|    }
  219|     14|
  220|     14|    if (!self.keyPair) {
  221|      1|      self.keyPair = [self generateAndSaveKeyWithSubtype:kFIRInstanceIDKeyPairSubType
  222|      1|                                            creationTime:FIRInstanceIDCurrentTimestampInSeconds()
  223|      1|                                                   error:error];
  224|      1|    }
  225|     14|  }
  226|     14|  return self.keyPair;
  227|     14|}
  228|       |
  229|       |// TODO(chliangGoogle: Remove subtype support, as it's not being used.
  230|       |- (FIRInstanceIDKeyPair *)generateAndSaveKeyWithSubtype:(NSString *)subtype
  231|       |                                           creationTime:(int64_t)creationTime
  232|      1|                                                  error:(NSError **)error {
  233|      1|  NSString *publicKeyTag = FIRInstanceIDPublicTagWithSubtype(subtype);
  234|      1|  NSString *privateKeyTag = FIRInstanceIDPrivateTagWithSubtype(subtype);
  235|      1|  FIRInstanceIDKeyPair *keyPair =
  236|      1|      [[FIRInstanceIDKeychain sharedInstance] generateKeyPairWithPrivateTag:privateKeyTag
  237|      1|                                                                  publicTag:publicKeyTag];
  238|      1|
  239|      1|  if (![keyPair isValid]) {
  240|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeKeyPairStore003,
  241|      0|                             @"Unable to generate keypair.");
  242|      0|    return nil;
  243|      0|  }
  244|      1|
  245|      1|  NSString *creationTimeKey = FIRInstanceIDCreationTimeKeyWithSubtype(subtype);
  246|      1|  NSDictionary *keyPairData = @{creationTimeKey : @(creationTime)};
  247|      1|
  248|      1|  if (error) {
  249|      1|    *error = nil;
  250|      1|  }
  251|      1|  NSMutableDictionary *allKeyPairs = [[self.plist contentAsDictionary] mutableCopy];
  252|      1|  if (allKeyPairs.count) {
  253|      0|    [allKeyPairs addEntriesFromDictionary:keyPairData];
  254|      1|  } else {
  255|      1|    allKeyPairs = [keyPairData mutableCopy];
  256|      1|  }
  257|      1|  if (![self.plist writeDictionary:allKeyPairs error:error]) {
  258|      0|    [FIRInstanceIDKeyPairStore deleteKeyPairWithPrivateTag:privateKeyTag
  259|      0|                                                 publicTag:publicKeyTag
  260|      0|                                                   handler:nil];
  261|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeKeyPairStore004,
  262|      0|                             @"Failed to save keypair data to plist %@", error ? *error : @"");
  263|      0|    return nil;
  264|      0|  }
  265|      1|
  266|      1|  return keyPair;
  267|      1|}
  268|       |
  269|       |- (FIRInstanceIDKeyPair *)validCachedKeyPairWithSubtype:(NSString *)subtype
  270|     14|                                                  error:(NSError **)error {
  271|     14|  // On a new install (or if the ID was deleted), the plist will be missing, which should trigger
  272|     14|  // a reset of the key pairs in Keychain (if they exist).
  273|     14|  NSDictionary *allKeyPairs = [self.plist contentAsDictionary];
  274|     14|  NSString *creationTimeKey = FIRInstanceIDCreationTimeKeyWithSubtype(subtype);
  275|     14|
  276|     14|  if (allKeyPairs[creationTimeKey] > 0) {
  277|     13|    return [self cachedKeyPairWithSubtype:subtype error:error];
  278|     13|  } else {
  279|      1|    // There is no need to reset keypair again here as FIRInstanceID init call is always
  280|      1|    // going to be ahead of this call, which already trigger keypair reset if it's new install
  281|      1|    FIRInstanceIDErrorCode code = kFIRInstanceIDErrorCodeInvalidKeyPairCreationTime;
  282|      1|    if (error) {
  283|      1|      *error = [NSError errorWithFIRInstanceIDErrorCode:code];
  284|      1|    }
  285|      1|    return nil;
  286|      1|  }
  287|     14|}
  288|       |
  289|       |- (FIRInstanceIDKeyPair *)cachedKeyPairWithSubtype:(NSString *)subtype
  290|     13|                                             error:(NSError *__autoreleasing *)error {
  291|     13|  // base64 encoded keys
  292|     13|  NSString *publicKeyTag = FIRInstanceIDPublicTagWithSubtype(subtype);
  293|     13|  NSString *privateKeyTag = FIRInstanceIDPrivateTagWithSubtype(subtype);
  294|     13|  return [FIRInstanceIDKeyPairStore keyPairForPrivateKeyTag:privateKeyTag
  295|     13|                                               publicKeyTag:publicKeyTag
  296|     13|                                                      error:error];
  297|     13|}
  298|       |
  299|       |+ (FIRInstanceIDKeyPair *)keyPairForPrivateKeyTag:(NSString *)privateKeyTag
  300|       |                                     publicKeyTag:(NSString *)publicKeyTag
  301|     26|                                            error:(NSError *__autoreleasing *)error {
  302|     26|  _FIRInstanceIDDevAssert([privateKeyTag length] && [publicKeyTag length],
  303|     26|                          @"Invalid tags for keypair");
  304|     26|  if (![privateKeyTag length] || ![publicKeyTag length]) {
  305|      0|    if (error) {
  306|      0|      *error = [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeInvalidKeyPairTags];
  307|      0|    }
  308|      0|    return nil;
  309|      0|  }
  310|     26|
  311|     26|  SecKeyRef privateKeyRef = FIRInstanceIDCachedKeyRefWithTag(privateKeyTag);
  312|     26|  SecKeyRef publicKeyRef = FIRInstanceIDCachedKeyRefWithTag(publicKeyTag);
  313|     26|
  314|     26|  if (!privateKeyRef || !publicKeyRef) {
  315|     13|    if (error) {
  316|     13|      *error = [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeMissingKeyPair];
  317|     13|    }
  318|     13|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeKeyPair000,
  319|     13|                             @"No keypair info is found with tag %@", privateKeyTag);
  320|     13|    return nil;
  321|     13|  }
  322|     13|
  323|     13|  NSData *publicKeyData = FIRInstanceIDKeyDataWithTag(publicKeyTag);
  324|     13|  NSData *privateKeyData = FIRInstanceIDKeyDataWithTag(privateKeyTag);
  325|     13|
  326|     13|  FIRInstanceIDKeyPair *keyPair = [[FIRInstanceIDKeyPair alloc] initWithPrivateKey:privateKeyRef
  327|     13|                                                                         publicKey:publicKeyRef
  328|     13|                                                                     publicKeyData:publicKeyData
  329|     13|                                                                    privateKeyData:privateKeyData];
  330|     13|  return keyPair;
  331|     13|}
  332|       |
  333|       |// Migrates from keypair saved under legacy keys (hardcoded value) to dynamic keys (stable, but
  334|       |// unique for the app's bundle id
  335|     13|- (void)migrateKeyPairCacheIfNeededWithHandler:(void (^)(NSError *error))handler {
  336|     13|  // Attempt to load keypair using legacy keys
  337|     13|  NSString *legacyPublicKeyTag =
  338|     13|      FIRInstanceIDLegacyPublicTagWithSubtype(kFIRInstanceIDKeyPairSubType);
  339|     13|  NSString *legacyPrivateKeyTag =
  340|     13|      FIRInstanceIDLegacyPrivateTagWithSubtype(kFIRInstanceIDKeyPairSubType);
  341|     13|  NSError *error;
  342|     13|  FIRInstanceIDKeyPair *keyPair =
  343|     13|      [FIRInstanceIDKeyPairStore keyPairForPrivateKeyTag:legacyPrivateKeyTag
  344|     13|                                            publicKeyTag:legacyPublicKeyTag
  345|     13|                                                   error:&error];
  346|     13|  if (![keyPair isValid]) {
  347|     13|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeKeyPairNoLegacyKeyPair,
  348|     13|                             @"There's no legacy keypair so no need to do migration.");
  349|     13|    if (handler) {
  350|      0|      handler(nil);
  351|      0|    }
  352|     13|    return;
  353|     13|  }
  354|      0|
  355|      0|  // Check whether migration already done.
  356|      0|  NSString *publicKeyTag = FIRInstanceIDPublicTagWithSubtype(kFIRInstanceIDKeyPairSubType);
  357|      0|  if (FIRInstanceIDHasMigratedKeyPair(legacyPublicKeyTag, publicKeyTag)) {
  358|      0|    if (handler) {
  359|      0|      handler(nil);
  360|      0|    }
  361|      0|    return;
  362|      0|  }
  363|      0|
  364|      0|  // Also cache locally since we are sure to use the migrated key pair.
  365|      0|  self.keyPair = keyPair;
  366|      0|
  367|      0|  // Either new key pair doesn't exist or it's different than legacy key pair, start the migration.
  368|      0|  NSString *privateKeyTag = FIRInstanceIDPrivateTagWithSubtype(kFIRInstanceIDKeyPairSubType);
  369|      0|  [self updateKeyRef:keyPair.publicKey
  370|      0|             withTag:publicKeyTag
  371|      0|             handler:^(NSError *error) {
  372|      0|               if (error) {
  373|      0|                 FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeKeyPairMigrationError,
  374|      0|                                          @"Unable to migrate key pair from legacy ones.");
  375|      0|               }
  376|      0|               [self updateKeyRef:keyPair.privateKey
  377|      0|                          withTag:privateKeyTag
  378|      0|                          handler:^(NSError *error) {
  379|      0|                            if (error) {
  380|      0|                              FIRInstanceIDLoggerError(
  381|      0|                                  kFIRInstanceIDMessageCodeKeyPairMigrationError,
  382|      0|                                  @"Unable to migrate key pair from legacy ones.");
  383|      0|                              return;
  384|      0|                            }
  385|      0|                            FIRInstanceIDLoggerDebug(
  386|      0|                                kFIRInstanceIDMessageCodeKeyPairMigrationSuccess,
  387|      0|                                @"Successfully migrated the key pair from legacy ones.");
  388|      0|                            if (handler) {
  389|      0|                              handler(error);
  390|      0|                            }
  391|      0|                          }];
  392|      0|             }];
  393|      0|}
  394|       |
  395|       |// Used for migrating from legacy tags to updated tags. The legacy keychain is not deleted for
  396|       |// backward compatibility.
  397|       |// TODO(chliangGoogle) Delete the legacy keychain when GCM is fully deprecated.
  398|       |- (void)updateKeyRef:(SecKeyRef)keyRef
  399|       |             withTag:(NSString *)tag
  400|      0|             handler:(void (^)(NSError *error))handler {
  401|      0|  NSData *updatedTagData = [tag dataUsingEncoding:NSUTF8StringEncoding];
  402|      0|
  403|      0|  // Always delete the old keychain before adding a new one to avoid conflicts.
  404|      0|  NSDictionary *deleteQuery = @{
  405|      0|    (__bridge id)kSecAttrApplicationTag : updatedTagData,
  406|      0|    (__bridge id)kSecClass : (__bridge id)kSecClassKey,
  407|      0|    (__bridge id)kSecAttrKeyType : (__bridge id)kSecAttrKeyTypeRSA,
  408|      0|    (__bridge id)kSecReturnRef : @(YES),
  409|      0|  };
  410|      0|
  411|      0|  [[FIRInstanceIDKeychain sharedInstance]
  412|      0|      removeItemWithQuery:deleteQuery
  413|      0|                  handler:^(NSError *error) {
  414|      0|                    if (error) {
  415|      0|                      if (handler) {
  416|      0|                        handler(error);
  417|      0|                      }
  418|      0|                      return;
  419|      0|                    }
  420|      0|                    NSDictionary *addQuery = @{
  421|      0|                      (__bridge id)kSecAttrApplicationTag : updatedTagData,
  422|      0|                      (__bridge id)kSecClass : (__bridge id)kSecClassKey,
  423|      0|                      (__bridge id)kSecValueRef : (__bridge id)keyRef,
  424|      0|                      (__bridge id)
  425|      0|                      kSecAttrAccessible : (__bridge id)kSecAttrAccessibleAlwaysThisDeviceOnly,
  426|      0|                    };
  427|      0|                    [[FIRInstanceIDKeychain sharedInstance] addItemWithQuery:addQuery
  428|      0|                                                                     handler:^(NSError *addError) {
  429|      0|                                                                       if (handler) {
  430|      0|                                                                         handler(addError);
  431|      0|                                                                       }
  432|      0|                                                                     }];
  433|      0|                  }];
  434|      0|}
  435|       |
  436|       |- (void)deleteSavedKeyPairWithSubtype:(NSString *)subtype
  437|      1|                              handler:(void (^)(NSError *error))handler {
  438|      1|  NSDictionary *allKeyPairs = [self.plist contentAsDictionary];
  439|      1|
  440|      1|  NSString *publicKeyTag = FIRInstanceIDPublicTagWithSubtype(subtype);
  441|      1|  NSString *privateKeyTag = FIRInstanceIDPrivateTagWithSubtype(subtype);
  442|      1|  NSString *creationTimeKey = FIRInstanceIDCreationTimeKeyWithSubtype(subtype);
  443|      1|
  444|      1|  // remove the creation time
  445|      1|  if (allKeyPairs[creationTimeKey] > 0) {
  446|      0|    NSMutableDictionary *newKeyPairs = [NSMutableDictionary dictionaryWithDictionary:allKeyPairs];
  447|      0|    [newKeyPairs removeObjectForKey:creationTimeKey];
  448|      0|
  449|      0|    NSError *plistError;
  450|      0|    if (![self.plist writeDictionary:newKeyPairs error:&plistError]) {
  451|      0|      FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeKeyPairStore006,
  452|      0|                               @"Unable to remove keypair creation time from plist %@", plistError);
  453|      0|    }
  454|      0|  }
  455|      1|
  456|      1|  [FIRInstanceIDKeyPairStore
  457|      1|      deleteKeyPairWithPrivateTag:privateKeyTag
  458|      1|                        publicTag:publicKeyTag
  459|      1|                          handler:^(NSError *error) {
  460|      1|                            // Delete legacy key pairs from GCM/FCM If they exist. All key pairs
  461|      1|                            // should be deleted when app is newly installed.
  462|      1|                            NSString *legacyPublicKeyTag =
  463|      1|                                FIRInstanceIDLegacyPublicTagWithSubtype(subtype);
  464|      1|                            NSString *legacyPrivateKeyTag =
  465|      1|                                FIRInstanceIDLegacyPrivateTagWithSubtype(subtype);
  466|      1|                            [FIRInstanceIDKeyPairStore
  467|      1|                                deleteKeyPairWithPrivateTag:legacyPrivateKeyTag
  468|      1|                                                  publicTag:legacyPublicKeyTag
  469|      1|                                                    handler:nil];
  470|      1|                            if (error) {
  471|      0|                              FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeKeyPairStore007,
  472|      0|                                                       @"Unable to remove RSA keypair, error: %@",
  473|      0|                                                       error);
  474|      0|                              if (handler) {
  475|      0|                                handler(error);
  476|      0|                              }
  477|      1|                            } else {
  478|      1|                              self.keyPair = nil;
  479|      1|                              if (handler) {
  480|      0|                                handler(nil);
  481|      0|                              }
  482|      1|                            }
  483|      1|                          }];
  484|      1|}
  485|       |
  486|       |+ (void)deleteKeyPairWithPrivateTag:(NSString *)privateTag
  487|       |                          publicTag:(NSString *)publicTag
  488|      2|                            handler:(void (^)(NSError *))handler {
  489|      2|  NSDictionary *queryPublicKey = FIRInstanceIDKeyPairQuery(publicTag, NO, NO);
  490|      2|  NSDictionary *queryPrivateKey = FIRInstanceIDKeyPairQuery(privateTag, NO, NO);
  491|      2|
  492|      2|  // Always remove public key first because it is the key we generate IID.
  493|      2|  [[FIRInstanceIDKeychain sharedInstance] removeItemWithQuery:queryPublicKey
  494|      2|                                                      handler:^(NSError *error) {
  495|      2|                                                        if (error) {
  496|      0|                                                          if (handler) {
  497|      0|                                                            handler(error);
  498|      0|                                                          }
  499|      0|                                                          return;
  500|      0|                                                        }
  501|      2|                                                        [[FIRInstanceIDKeychain sharedInstance]
  502|      2|                                                            removeItemWithQuery:queryPrivateKey
  503|      2|                                                                        handler:^(NSError *error) {
  504|      2|                                                                          if (error) {
  505|      0|                                                                            if (handler) {
  506|      0|                                                                              handler(error);
  507|      0|                                                                            }
  508|      0|                                                                            return;
  509|      0|                                                                          }
  510|      2|                                                                          if (handler) {
  511|      1|                                                                            handler(nil);
  512|      1|                                                                          }
  513|      2|                                                                        }];
  514|      2|                                                      }];
  515|      2|}
  516|       |
  517|      0|- (BOOL)removeKeyPairCreationTimePlistWithError:(NSError *__autoreleasing *)error {
  518|      0|  if (![self.plist deleteFile:error]) {
  519|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeKeyPairStore008,
  520|      0|                             @"Unable to delete keypair creation times plist");
  521|      0|    return NO;
  522|      0|  }
  523|      0|  return YES;
  524|      0|}
  525|       |
  526|     14|+ (NSString *)keyStoreFileName {
  527|     14|  return kFIRInstanceIDKeyPairStoreFileName;
  528|     14|}
  529|       |
  530|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDKeyPairUtilities.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDKeyPairUtilities.h"
   18|       |
   19|       |#import <CommonCrypto/CommonDigest.h>
   20|       |
   21|       |#import "FIRInstanceIDDefines.h"
   22|       |#import "FIRInstanceIDKeyPair.h"
   23|       |#import "FIRInstanceIDLogger.h"
   24|       |#import "FIRInstanceIDStringEncoding.h"
   25|       |
   26|     77|NSString *FIRInstanceIDWebSafeBase64(NSData *data) {
   27|     77|  // Websafe encoding with no padding.
   28|     77|  FIRInstanceIDStringEncoding *encoding =
   29|     77|      [FIRInstanceIDStringEncoding rfc4648Base64WebsafeStringEncoding];
   30|     77|  [encoding setDoPad:NO];
   31|     77|  return [encoding encode:data];
   32|     77|}
   33|       |
   34|     77|NSData *FIRInstanceIDSHA1(NSData *data) {
   35|     77|  unsigned int outputLength = CC_SHA1_DIGEST_LENGTH;
   36|     77|  unsigned char output[outputLength];
   37|     77|  unsigned int length = (unsigned int)[data length];
   38|     77|
   39|     77|  CC_SHA1(data.bytes, length, output);
   40|     77|  return [NSMutableData dataWithBytes:output length:outputLength];
   41|     77|}
   42|       |
   43|     84|NSDictionary *FIRInstanceIDKeyPairQuery(NSString *tag, BOOL addReturnAttr, BOOL returnData) {
   44|     84|  NSMutableDictionary *queryKey = [NSMutableDictionary dictionary];
   45|     84|  NSData *tagData = [tag dataUsingEncoding:NSUTF8StringEncoding];
   46|     84|
   47|     84|  queryKey[(__bridge id)kSecClass] = (__bridge id)kSecClassKey;
   48|     84|  queryKey[(__bridge id)kSecAttrApplicationTag] = tagData;
   49|     84|  queryKey[(__bridge id)kSecAttrKeyType] = (__bridge id)kSecAttrKeyTypeRSA;
   50|     84|  if (addReturnAttr) {
   51|     80|    if (returnData) {
   52|     28|      queryKey[(__bridge id)kSecReturnData] = @(YES);
   53|     52|    } else {
   54|     52|      queryKey[(__bridge id)kSecReturnRef] = @(YES);
   55|     52|    }
   56|     80|  }
   57|     84|  return queryKey;
   58|     84|}
   59|       |
   60|     77|NSString *FIRInstanceIDAppIdentity(FIRInstanceIDKeyPair *keyPair) {
   61|     77|  // An Instance-ID is a 64 bit (8 byte) integer with a fixed 4-bit header of 0111 (=^ 0x7).
   62|     77|  // The variable 60 bits are obtained by truncating the SHA1 of the app-instance's public key.
   63|     77|  SecKeyRef publicKeyRef = [keyPair publicKey];
   64|     77|  if (!publicKeyRef) {
   65|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeKeyPair002,
   66|      0|                             @"Unable to create a valid asymmetric crypto key");
   67|      0|    return nil;
   68|      0|  }
   69|     77|  NSData *publicKeyData = keyPair.publicKeyData;
   70|     77|  NSData *publicKeySHA1 = FIRInstanceIDSHA1(publicKeyData);
   71|     77|
   72|     77|  const uint8_t *bytes = publicKeySHA1.bytes;
   73|     77|  NSMutableData *identityData = [NSMutableData dataWithData:publicKeySHA1];
   74|     77|
   75|     77|  uint8_t b0 = bytes[0];
   76|     77|  // Take the first byte and make the initial four 7 by initially making the initial 4 bits 0
   77|     77|  // and then adding 0x70 to it.
   78|     77|  b0 = 0x70 + (0xF & b0);
   79|     77|  // failsafe should give you back b0 itself
   80|     77|  b0 = (b0 & 0xFF);
   81|     77|  [identityData replaceBytesInRange:NSMakeRange(0, 1) withBytes:&b0];
   82|     77|  NSData *data = [identityData subdataWithRange:NSMakeRange(0, 8 * sizeof(Byte))];
   83|     77|  return FIRInstanceIDWebSafeBase64(data);
   84|     77|}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDKeychain.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDKeychain.h"
   18|       |
   19|       |#import "FIRInstanceIDKeyPair.h"
   20|       |#import "FIRInstanceIDKeyPairUtilities.h"
   21|       |#import "FIRInstanceIDLogger.h"
   22|       |
   23|       |NSString *const kFIRInstanceIDKeychainErrorDomain = @"com.google.iid";
   24|       |
   25|       |static const NSUInteger kRSA2048KeyPairSize = 2048;
   26|       |
   27|       |@interface FIRInstanceIDKeychain () {
   28|       |  dispatch_queue_t _keychainOperationQueue;
   29|       |}
   30|       |
   31|       |@end
   32|       |
   33|       |@implementation FIRInstanceIDKeychain
   34|       |
   35|    112|+ (instancetype)sharedInstance {
   36|    112|  static FIRInstanceIDKeychain *sharedInstance;
   37|    112|  static dispatch_once_t onceToken;
   38|    112|  dispatch_once(&onceToken, ^{
   39|     14|    sharedInstance = [[FIRInstanceIDKeychain alloc] init];
   40|     14|  });
   41|    112|  return sharedInstance;
   42|    112|}
   43|       |
   44|     14|- (instancetype)init {
   45|     14|  self = [super init];
   46|     14|  if (self) {
   47|     14|    _keychainOperationQueue =
   48|     14|        dispatch_queue_create("com.google.FirebaseInstanceID.Keychain", DISPATCH_QUEUE_SERIAL);
   49|     14|  }
   50|     14|  return self;
   51|     14|}
   52|       |
   53|    108|- (CFTypeRef)itemWithQuery:(NSDictionary *)keychainQuery {
   54|    108|  __block SecKeyRef keyRef = NULL;
   55|    108|  dispatch_sync(_keychainOperationQueue, ^{
   56|    108|    OSStatus status =
   57|    108|        SecItemCopyMatching((__bridge CFDictionaryRef)keychainQuery, (CFTypeRef *)&keyRef);
   58|    108|
   59|    108|    if (status != noErr) {
   60|     54|      if (keyRef) {
   61|      0|        CFRelease(keyRef);
   62|      0|      }
   63|     54|      FIRInstanceIDLoggerDebug(kFIRInstanceIDKeychainReadItemError,
   64|     54|                               @"Info is not found in Keychain. OSStatus: %d. Keychain query: %@",
   65|     54|                               (int)status, keychainQuery);
   66|     54|    }
   67|    108|  });
   68|    108|  return keyRef;
   69|    108|}
   70|       |
   71|       |- (void)removeItemWithQuery:(NSDictionary *)keychainQuery
   72|      5|                    handler:(void (^)(NSError *error))handler {
   73|      5|  dispatch_async(_keychainOperationQueue, ^{
   74|      5|    OSStatus status = SecItemDelete((__bridge CFDictionaryRef)keychainQuery);
   75|      5|    if (status != noErr) {
   76|      5|      FIRInstanceIDLoggerDebug(
   77|      5|          kFIRInstanceIDKeychainDeleteItemError,
   78|      5|          @"Couldn't delete item from Keychain OSStatus: %d with the keychain query %@",
   79|      5|          (int)status, keychainQuery);
   80|      5|    }
   81|      5|
   82|      5|    if (handler) {
   83|      4|      NSError *error;
   84|      4|      // When item is not found, it should NOT be considered as an error. The operation should
   85|      4|      // continue.
   86|      4|      if (status != noErr && status != errSecItemNotFound) {
   87|      0|        error = [NSError errorWithDomain:kFIRInstanceIDKeychainErrorDomain
   88|      0|                                    code:status
   89|      0|                                userInfo:nil];
   90|      0|      }
   91|      4|      dispatch_async(dispatch_get_main_queue(), ^{
   92|      4|        handler(error);
   93|      4|      });
   94|      4|    }
   95|      5|  });
   96|      5|}
   97|       |
   98|      0|- (void)addItemWithQuery:(NSDictionary *)keychainQuery handler:(void (^)(NSError *))handler {
   99|      0|  dispatch_async(_keychainOperationQueue, ^{
  100|      0|    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)keychainQuery, NULL);
  101|      0|
  102|      0|    if (handler) {
  103|      0|      NSError *error;
  104|      0|      if (status != noErr) {
  105|      0|        FIRInstanceIDLoggerWarning(kFIRInstanceIDKeychainAddItemError,
  106|      0|                                   @"Couldn't add item to Keychain OSStatus: %d", (int)status);
  107|      0|        error = [NSError errorWithDomain:kFIRInstanceIDKeychainErrorDomain
  108|      0|                                    code:status
  109|      0|                                userInfo:nil];
  110|      0|      }
  111|      0|      dispatch_async(dispatch_get_main_queue(), ^{
  112|      0|        handler(error);
  113|      0|      });
  114|      0|    }
  115|      0|  });
  116|      0|}
  117|       |
  118|       |- (FIRInstanceIDKeyPair *)generateKeyPairWithPrivateTag:(NSString *)privateTag
  119|      1|                                              publicTag:(NSString *)publicTag {
  120|      1|  // TODO(chliangGoogle) this is called by appInstanceID, which is an internal API used by other
  121|      1|  // Firebase teams, will see if we can make it async.
  122|      1|  NSData *publicTagData = [publicTag dataUsingEncoding:NSUTF8StringEncoding];
  123|      1|  NSData *privateTagData = [privateTag dataUsingEncoding:NSUTF8StringEncoding];
  124|      1|
  125|      1|  NSDictionary *privateKeyAttr = @{
  126|      1|    (__bridge id)kSecAttrIsPermanent : @YES,
  127|      1|    (__bridge id)kSecAttrApplicationTag : privateTagData,
  128|      1|    (__bridge id)kSecAttrLabel : @"Firebase InstanceID Key Pair Private Key",
  129|      1|    (__bridge id)kSecAttrAccessible : (__bridge id)kSecAttrAccessibleAlwaysThisDeviceOnly,
  130|      1|  };
  131|      1|
  132|      1|  NSDictionary *publicKeyAttr = @{
  133|      1|    (__bridge id)kSecAttrIsPermanent : @YES,
  134|      1|    (__bridge id)kSecAttrApplicationTag : publicTagData,
  135|      1|    (__bridge id)kSecAttrLabel : @"Firebase InstanceID Key Pair Public Key",
  136|      1|    (__bridge id)kSecAttrAccessible : (__bridge id)kSecAttrAccessibleAlwaysThisDeviceOnly,
  137|      1|  };
  138|      1|
  139|      1|  NSDictionary *keyPairAttributes = @{
  140|      1|    (__bridge id)kSecAttrKeyType : (__bridge id)kSecAttrKeyTypeRSA,
  141|      1|    (__bridge id)kSecAttrLabel : @"Firebase InstanceID Key Pair",
  142|      1|    (__bridge id)kSecAttrKeySizeInBits : @(kRSA2048KeyPairSize),
  143|      1|    (__bridge id)kSecPrivateKeyAttrs : privateKeyAttr,
  144|      1|    (__bridge id)kSecPublicKeyAttrs : publicKeyAttr,
  145|      1|  };
  146|      1|
  147|      1|  __block SecKeyRef privateKey = NULL;
  148|      1|  __block SecKeyRef publicKey = NULL;
  149|      1|  dispatch_sync(_keychainOperationQueue, ^{
  150|      1|    // SecKeyGeneratePair does not allow you to set kSetAttrAccessible on the keys. We need the keys
  151|      1|    // to be accessible even when the device is locked (i.e. app is woken up during a push
  152|      1|    // notification, or some background refresh).
  153|      1|    OSStatus status =
  154|      1|        SecKeyGeneratePair((__bridge CFDictionaryRef)keyPairAttributes, &publicKey, &privateKey);
  155|      1|    if (status != noErr || publicKey == NULL || privateKey == NULL) {
  156|      0|      FIRInstanceIDLoggerWarning(kFIRInstanceIDKeychainCreateKeyPairError,
  157|      0|                                 @"Couldn't create keypair from Keychain OSStatus: %d",
  158|      0|                                 (int)status);
  159|      0|    }
  160|      1|  });
  161|      1|  // Extract the actual public and private key data from the Keychain
  162|      1|  NSDictionary *publicKeyDataQuery = FIRInstanceIDKeyPairQuery(publicTag, YES, YES);
  163|      1|  NSDictionary *privateKeyDataQuery = FIRInstanceIDKeyPairQuery(privateTag, YES, YES);
  164|      1|
  165|      1|  NSData *publicKeyData = (__bridge NSData *)[self itemWithQuery:publicKeyDataQuery];
  166|      1|  NSData *privateKeyData = (__bridge NSData *)[self itemWithQuery:privateKeyDataQuery];
  167|      1|
  168|      1|  return [[FIRInstanceIDKeyPair alloc] initWithPrivateKey:privateKey
  169|      1|                                                publicKey:publicKey
  170|      1|                                            publicKeyData:publicKeyData
  171|      1|                                           privateKeyData:privateKeyData];
  172|      1|}
  173|       |
  174|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDLogger.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRIMessageCode.h"
   18|       |
   19|       |// The convenience macros are only defined if they haven't already been defined.
   20|       |#ifndef FIRInstanceIDLoggerInfo
   21|       |
   22|       |// Convenience macros that log to the shared GTMLogger instance. These macros
   23|       |// are how users should typically log to FIRInstanceIDLogger.
   24|       |#define FIRInstanceIDLoggerDebug(code, ...) \
   25|     85|  [FIRInstanceIDSharedLogger() logFuncDebug:__func__ messageCode:code msg:__VA_ARGS__]
   26|       |#define FIRInstanceIDLoggerInfo(code, ...) \
   27|      0|  [FIRInstanceIDSharedLogger() logFuncInfo:__func__ messageCode:code msg:__VA_ARGS__]
   28|       |#define FIRInstanceIDLoggerNotice(code, ...) \
   29|       |  [FIRInstanceIDSharedLogger() logFuncNotice:__func__ messageCode:code msg:__VA_ARGS__]
   30|       |#define FIRInstanceIDLoggerWarning(code, ...) \
   31|      0|  [FIRInstanceIDSharedLogger() logFuncWarning:__func__ messageCode:code msg:__VA_ARGS__]
   32|       |#define FIRInstanceIDLoggerError(code, ...) \
   33|      0|  [FIRInstanceIDSharedLogger() logFuncError:__func__ messageCode:code msg:__VA_ARGS__]
   34|       |
   35|       |#endif  // !defined(FIRInstanceIDLoggerInfo)
   36|       |
   37|       |@interface FIRInstanceIDLogger : NSObject
   38|       |
   39|       |- (void)logFuncDebug:(const char *)func
   40|       |         messageCode:(FIRInstanceIDMessageCode)messageCode
   41|       |                 msg:(NSString *)fmt, ... NS_FORMAT_FUNCTION(3, 4);
   42|       |
   43|       |- (void)logFuncInfo:(const char *)func
   44|       |        messageCode:(FIRInstanceIDMessageCode)messageCode
   45|       |                msg:(NSString *)fmt, ... NS_FORMAT_FUNCTION(3, 4);
   46|       |
   47|       |- (void)logFuncNotice:(const char *)func
   48|       |          messageCode:(FIRInstanceIDMessageCode)messageCode
   49|       |                  msg:(NSString *)fmt, ... NS_FORMAT_FUNCTION(3, 4);
   50|       |
   51|       |- (void)logFuncWarning:(const char *)func
   52|       |           messageCode:(FIRInstanceIDMessageCode)messageCode
   53|       |                   msg:(NSString *)fmt, ... NS_FORMAT_FUNCTION(3, 4);
   54|       |
   55|       |- (void)logFuncError:(const char *)func
   56|       |         messageCode:(FIRInstanceIDMessageCode)messageCode
   57|       |                 msg:(NSString *)fmt, ... NS_FORMAT_FUNCTION(3, 4);
   58|       |
   59|       |@end
   60|       |
   61|       |/**
   62|       | * Instantiates and/or returns a shared GTMLogger used exclusively
   63|       | * for InstanceID log messages.
   64|       | * @return the shared GTMLogger instance
   65|       | */
   66|       |FIRInstanceIDLogger *FIRInstanceIDSharedLogger(void);

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDLogger.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDLogger.h"
   18|       |
   19|       |#import <FirebaseCore/FIRLogger.h>
   20|       |
   21|       |// Re-definition of FIRLogger service, as it is not included in :FIRAppHeaders target
   22|       |NSString *const kFIRInstanceIDLoggerService = @"[Firebase/InstanceID]";
   23|       |
   24|       |@implementation FIRInstanceIDLogger
   25|       |
   26|       |#pragma mark - Log Helpers
   27|       |
   28|     85|+ (NSString *)formatMessageCode:(FIRInstanceIDMessageCode)messageCode {
   29|     85|  return [NSString stringWithFormat:@"I-IID%06ld", (long)messageCode];
   30|     85|}
   31|       |
   32|       |- (void)logFuncDebug:(const char *)func
   33|       |         messageCode:(FIRInstanceIDMessageCode)messageCode
   34|     85|                 msg:(NSString *)fmt, ... {
   35|     85|  va_list args;
   36|     85|  va_start(args, fmt);
   37|     85|  FIRLogBasic(FIRLoggerLevelDebug, kFIRInstanceIDLoggerService,
   38|     85|              [FIRInstanceIDLogger formatMessageCode:messageCode], fmt, args);
   39|     85|  va_end(args);
   40|     85|}
   41|       |
   42|       |- (void)logFuncInfo:(const char *)func
   43|       |        messageCode:(FIRInstanceIDMessageCode)messageCode
   44|      0|                msg:(NSString *)fmt, ... {
   45|      0|  va_list args;
   46|      0|  va_start(args, fmt);
   47|      0|  FIRLogBasic(FIRLoggerLevelInfo, kFIRInstanceIDLoggerService,
   48|      0|              [FIRInstanceIDLogger formatMessageCode:messageCode], fmt, args);
   49|      0|  va_end(args);
   50|      0|}
   51|       |
   52|       |- (void)logFuncNotice:(const char *)func
   53|       |          messageCode:(FIRInstanceIDMessageCode)messageCode
   54|      0|                  msg:(NSString *)fmt, ... {
   55|      0|  va_list args;
   56|      0|  va_start(args, fmt);
   57|      0|  FIRLogBasic(FIRLoggerLevelNotice, kFIRInstanceIDLoggerService,
   58|      0|              [FIRInstanceIDLogger formatMessageCode:messageCode], fmt, args);
   59|      0|  va_end(args);
   60|      0|}
   61|       |
   62|       |- (void)logFuncWarning:(const char *)func
   63|       |           messageCode:(FIRInstanceIDMessageCode)messageCode
   64|      0|                   msg:(NSString *)fmt, ... {
   65|      0|  va_list args;
   66|      0|  va_start(args, fmt);
   67|      0|  FIRLogBasic(FIRLoggerLevelWarning, kFIRInstanceIDLoggerService,
   68|      0|              [FIRInstanceIDLogger formatMessageCode:messageCode], fmt, args);
   69|      0|  va_end(args);
   70|      0|}
   71|       |
   72|       |- (void)logFuncError:(const char *)func
   73|       |         messageCode:(FIRInstanceIDMessageCode)messageCode
   74|      0|                 msg:(NSString *)fmt, ... {
   75|      0|  va_list args;
   76|      0|  va_start(args, fmt);
   77|      0|  FIRLogBasic(FIRLoggerLevelError, kFIRInstanceIDLoggerService,
   78|      0|              [FIRInstanceIDLogger formatMessageCode:messageCode], fmt, args);
   79|      0|  va_end(args);
   80|      0|}
   81|       |
   82|       |@end
   83|       |
   84|     85|FIRInstanceIDLogger *FIRInstanceIDSharedLogger() {
   85|     85|  static dispatch_once_t onceToken;
   86|     85|  static FIRInstanceIDLogger *logger;
   87|     85|  dispatch_once(&onceToken, ^{
   88|     14|    logger = [[FIRInstanceIDLogger alloc] init];
   89|     14|  });
   90|     85|
   91|     85|  return logger;
   92|     85|}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDStore.h"
   18|       |
   19|       |#import "FIRInstanceIDCheckinPreferences.h"
   20|       |#import "FIRInstanceIDCheckinStore.h"
   21|       |#import "FIRInstanceIDConstants.h"
   22|       |#import "FIRInstanceIDLogger.h"
   23|       |#import "FIRInstanceIDTokenStore.h"
   24|       |#import "FIRInstanceIDVersionUtilities.h"
   25|       |
   26|       |// NOTE: These values should be in sync with what InstanceID saves in as.
   27|       |static NSString *const kCheckinFileName = @"g-checkin";
   28|       |
   29|       |// APNS token (use the old key value i.e. with prefix GMS)
   30|       |static NSString *const kFIRInstanceIDLibraryVersion = @"GMSInstanceID-version";
   31|       |
   32|       |@interface FIRInstanceIDStore ()
   33|       |
   34|       |@property(nonatomic, readwrite, strong) FIRInstanceIDCheckinStore *checkinStore;
   35|       |@property(nonatomic, readwrite, strong) FIRInstanceIDTokenStore *tokenStore;
   36|       |
   37|       |@end
   38|       |
   39|       |@implementation FIRInstanceIDStore
   40|       |
   41|     14|- (instancetype)initWithDelegate:(NSObject<FIRInstanceIDStoreDelegate> *)delegate {
   42|     14|  FIRInstanceIDCheckinStore *checkinStore = [[FIRInstanceIDCheckinStore alloc]
   43|     14|      initWithCheckinPlistFileName:kCheckinFileName
   44|     14|                  subDirectoryName:kFIRInstanceIDSubDirectoryName];
   45|     14|
   46|     14|  FIRInstanceIDTokenStore *tokenStore = [FIRInstanceIDTokenStore defaultStore];
   47|     14|
   48|     14|  return [self initWithCheckinStore:checkinStore tokenStore:tokenStore delegate:delegate];
   49|     14|}
   50|       |
   51|       |- (instancetype)initWithCheckinStore:(FIRInstanceIDCheckinStore *)checkinStore
   52|       |                          tokenStore:(FIRInstanceIDTokenStore *)tokenStore
   53|     14|                            delegate:(NSObject<FIRInstanceIDStoreDelegate> *)delegate {
   54|     14|  self = [super init];
   55|     14|  if (self) {
   56|     14|    _checkinStore = checkinStore;
   57|     14|    _tokenStore = tokenStore;
   58|     14|    _delegate = delegate;
   59|     14|    [self resetCredentialsIfNeeded];
   60|     14|  }
   61|     14|  return self;
   62|     14|}
   63|       |
   64|       |#pragma mark - Upgrades
   65|       |
   66|     14|+ (BOOL)hasSubDirectory:(NSString *)subDirectoryName {
   67|     14|  NSString *subDirectoryPath = [self pathForSupportSubDirectory:subDirectoryName];
   68|     14|  BOOL isDirectory;
   69|     14|  if (![[NSFileManager defaultManager] fileExistsAtPath:subDirectoryPath
   70|     14|                                            isDirectory:&isDirectory]) {
   71|      0|    return NO;
   72|     14|  } else if (!isDirectory) {
   73|      0|    return NO;
   74|      0|  }
   75|     14|  return YES;
   76|     14|}
   77|       |
   78|     14|+ (NSSearchPathDirectory)supportedDirectory {
   79|       |#if TARGET_OS_TV
   80|       |  return NSCachesDirectory;
   81|       |#else
   82|       |  return NSApplicationSupportDirectory;
   83|     14|#endif
   84|     14|}
   85|       |
   86|     14|+ (NSString *)pathForSupportSubDirectory:(NSString *)subDirectoryName {
   87|     14|  NSArray *directoryPaths =
   88|     14|      NSSearchPathForDirectoriesInDomains([self supportedDirectory], NSUserDomainMask, YES);
   89|     14|  NSString *dirPath = directoryPaths.lastObject;
   90|     14|  NSArray *components = @[ dirPath, subDirectoryName ];
   91|     14|  return [NSString pathWithComponents:components];
   92|     14|}
   93|       |
   94|      0|+ (BOOL)createSubDirectory:(NSString *)subDirectoryName {
   95|      0|  NSString *subDirectoryPath = [self pathForSupportSubDirectory:subDirectoryName];
   96|      0|  BOOL hasSubDirectory;
   97|      0|
   98|      0|  if (![[NSFileManager defaultManager] fileExistsAtPath:subDirectoryPath
   99|      0|                                            isDirectory:&hasSubDirectory]) {
  100|      0|    NSError *error;
  101|      0|    [[NSFileManager defaultManager] createDirectoryAtPath:subDirectoryPath
  102|      0|                              withIntermediateDirectories:YES
  103|      0|                                               attributes:nil
  104|      0|                                                    error:&error];
  105|      0|    if (error) {
  106|      0|      FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeStore000,
  107|      0|                               @"Cannot create directory %@, error: %@", subDirectoryPath, error);
  108|      0|      return NO;
  109|      0|    }
  110|      0|  } else {
  111|      0|    if (!hasSubDirectory) {
  112|      0|      FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeStore001,
  113|      0|                               @"Found file instead of directory at %@", subDirectoryPath);
  114|      0|      return NO;
  115|      0|    }
  116|      0|  }
  117|      0|  return YES;
  118|      0|}
  119|       |
  120|      0|+ (BOOL)removeSubDirectory:(NSString *)subDirectoryName error:(NSError **)error {
  121|      0|  if ([self hasSubDirectory:subDirectoryName]) {
  122|      0|    NSString *subDirectoryPath = [self pathForSupportSubDirectory:subDirectoryName];
  123|      0|    BOOL isDirectory;
  124|      0|    if ([[NSFileManager defaultManager] fileExistsAtPath:subDirectoryPath
  125|      0|                                             isDirectory:&isDirectory]) {
  126|      0|      return [[NSFileManager defaultManager] removeItemAtPath:subDirectoryPath error:error];
  127|      0|    }
  128|      0|  }
  129|      0|  return YES;
  130|      0|}
  131|       |
  132|       |/**
  133|       | *  Reset the keychain preferences if the app had been deleted earlier and then reinstalled.
  134|       | *  Keychain preferences are not cleared in the above scenario so explicitly clear them.
  135|       | *
  136|       | *  In case of an iCloud backup and restore the Keychain preferences should already be empty
  137|       | *  since the Keychain items are marked with `*BackupThisDeviceOnly`.
  138|       | */
  139|     14|- (void)resetCredentialsIfNeeded {
  140|     14|  BOOL checkinPlistExists = [self.checkinStore hasCheckinPlist];
  141|     14|  // Checkin info existed in backup excluded plist. Should not be a fresh install.
  142|     14|  if (checkinPlistExists) {
  143|      0|    // FCM user can still have the old version of checkin, migration should only happen once.
  144|      0|    [self.checkinStore migrateCheckinItemIfNeeded];
  145|      0|    return;
  146|      0|  }
  147|     14|
  148|     14|  // reset checkin in keychain if a fresh install.
  149|     14|  // set the old checkin preferences to unregister pre-registered tokens
  150|     14|  FIRInstanceIDCheckinPreferences *oldCheckinPreferences =
  151|     14|      [self.checkinStore cachedCheckinPreferences];
  152|     14|
  153|     14|  if (oldCheckinPreferences) {
  154|      0|    [self.checkinStore removeCheckinPreferencesWithHandler:^(NSError *error) {
  155|      0|      if (!error) {
  156|      0|        FIRInstanceIDLoggerDebug(
  157|      0|            kFIRInstanceIDMessageCodeStore002,
  158|      0|            @"Removed cached checkin preferences from Keychain because this is a fresh install.");
  159|      0|      } else {
  160|      0|        FIRInstanceIDLoggerError(
  161|      0|            kFIRInstanceIDMessageCodeStore003,
  162|      0|            @"Couldn't remove cached checkin preferences for a fresh install. Error: %@", error);
  163|      0|      }
  164|      0|      if (oldCheckinPreferences.deviceID.length && oldCheckinPreferences.secretToken.length) {
  165|      0|        FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeStore006,
  166|      0|                                 @"App reset detected. Will delete server registrations.");
  167|      0|        // We don't really need to delete old FCM tokens created via IID auth tokens since
  168|      0|        // those tokens are already hashed by APNS token as the has so creating a new
  169|      0|        // token should automatically delete the old-token.
  170|      0|        [self.delegate store:self didDeleteFCMScopedTokensForCheckin:oldCheckinPreferences];
  171|      0|      } else {
  172|      0|        FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeStore009,
  173|      0|                                 @"App reset detected but no valid checkin auth preferences found."
  174|      0|                                 @" Will not delete server registrations.");
  175|      0|      }
  176|      0|    }];
  177|      0|  }
  178|     14|}
  179|       |
  180|       |#pragma mark - Get
  181|       |
  182|       |- (FIRInstanceIDTokenInfo *)tokenInfoWithAuthorizedEntity:(NSString *)authorizedEntity
  183|     14|                                                    scope:(NSString *)scope {
  184|     14|  // TODO(chliangGoogle): If we don't have the token plist we should delete all the tokens from
  185|     14|  // the keychain. This is because not having the plist signifies a backup and restore operation.
  186|     14|  // In case the keychain has any tokens these would now be stale and therefore should be
  187|     14|  // deleted.
  188|     14|  if (![authorizedEntity length] || ![scope length]) {
  189|      0|    return nil;
  190|      0|  }
  191|     14|  FIRInstanceIDTokenInfo *info = [self.tokenStore tokenInfoWithAuthorizedEntity:authorizedEntity
  192|     14|                                                                          scope:scope];
  193|     14|  return info;
  194|     14|}
  195|       |
  196|      0|- (NSArray<FIRInstanceIDTokenInfo *> *)cachedTokenInfos {
  197|      0|  return [self.tokenStore cachedTokenInfos];
  198|      0|}
  199|       |
  200|       |#pragma mark - Save
  201|       |
  202|       |- (void)saveTokenInfo:(FIRInstanceIDTokenInfo *)tokenInfo
  203|      0|              handler:(void (^)(NSError *error))handler {
  204|      0|  [self.tokenStore saveTokenInfo:tokenInfo handler:handler];
  205|      0|}
  206|       |
  207|       |#pragma mark - Delete
  208|       |
  209|      0|- (void)removeCachedTokenWithAuthorizedEntity:(NSString *)authorizedEntity scope:(NSString *)scope {
  210|      0|  if (![authorizedEntity length] || ![scope length]) {
  211|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeStore012,
  212|      0|                             @"Will not delete token with invalid entity: %@, scope: %@",
  213|      0|                             authorizedEntity, scope);
  214|      0|    return;
  215|      0|  }
  216|      0|  [self.tokenStore removeTokenWithAuthorizedEntity:authorizedEntity scope:scope];
  217|      0|}
  218|       |
  219|      1|- (void)removeAllCachedTokensWithHandler:(void (^)(NSError *error))handler {
  220|      1|  [self.tokenStore removeAllTokensWithHandler:handler];
  221|      1|}
  222|       |
  223|       |#pragma mark - FIRInstanceIDCheckinCache protocol
  224|       |
  225|       |- (void)saveCheckinPreferences:(FIRInstanceIDCheckinPreferences *)preferences
  226|      0|                       handler:(void (^)(NSError *error))handler {
  227|      0|  [self.checkinStore saveCheckinPreferences:preferences handler:handler];
  228|      0|}
  229|       |
  230|     14|- (FIRInstanceIDCheckinPreferences *)cachedCheckinPreferences {
  231|     14|  return [self.checkinStore cachedCheckinPreferences];
  232|     14|}
  233|       |
  234|      0|- (void)removeCheckinPreferencesWithHandler:(void (^)(NSError *))handler {
  235|      0|  [self.checkinStore removeCheckinPreferencesWithHandler:^(NSError *error) {
  236|      0|    if (handler) {
  237|      0|      handler(error);
  238|      0|    }
  239|      0|  }];
  240|      0|}
  241|       |
  242|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDStringEncoding.m:
    1|       |#import "FIRInstanceIDDefines.h"
    2|       |
    3|       |//
    4|       |//  FIRInstanceIDStringEncoding.m
    5|       |//
    6|       |//  Copyright 2009 Google Inc.
    7|       |//
    8|       |//  Licensed under the Apache License, Version 2.0 (the "License"); you may not
    9|       |//  use this file except in compliance with the License.  You may obtain a copy
   10|       |//  of the License at
   11|       |//
   12|       |//  http://www.apache.org/licenses/LICENSE-2.0
   13|       |//
   14|       |//  Unless required by applicable law or agreed to in writing, software
   15|       |//  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   16|       |//  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
   17|       |//  License for the specific language governing permissions and limitations under
   18|       |//  the License.
   19|       |//
   20|       |
   21|       |// This is a copy of GTMStringEncoding. FIRInstanceID wants to avoid
   22|       |// a CocoaPods GTM dependency. Hence we use our own version of StringEncoding.
   23|       |
   24|       |#import "FIRInstanceIDStringEncoding.h"
   25|       |
   26|       |enum { kUnknownChar = -1, kPaddingChar = -2, kIgnoreChar = -3 };
   27|       |
   28|       |@implementation FIRInstanceIDStringEncoding
   29|       |
   30|     77|+ (id)rfc4648Base64WebsafeStringEncoding {
   31|     77|  FIRInstanceIDStringEncoding *ret = [self
   32|     77|      stringEncodingWithString:@"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"];
   33|     77|
   34|     77|  [ret setPaddingChar:'='];
   35|     77|  [ret setDoPad:YES];
   36|     77|  return ret;
   37|     77|}
   38|       |
   39|     77|static inline int lcm(int a, int b) {
   40|    462|  for (int aa = a, bb = b;;) {
   41|    462|    if (aa == bb)
   42|     77|      return aa;
   43|    385|    else if (aa < bb)
   44|    154|      aa += a;
   45|    231|    else
   46|    231|      bb += b;
   47|    462|  }
   48|     77|}
   49|       |
   50|     77|+ (id)stringEncodingWithString:(NSString *)string {
   51|     77|  return [[FIRInstanceIDStringEncoding alloc] initWithString:string];
   52|     77|}
   53|       |
   54|     77|- (id)initWithString:(NSString *)string {
   55|     77|  if ((self = [super init])) {
   56|     77|    charMapData_ = [string dataUsingEncoding:NSASCIIStringEncoding];
   57|     77|    if (!charMapData_) {
   58|      0|      // Unable to convert string to ASCII
   59|      0|      return nil;
   60|      0|    }
   61|     77|    charMap_ = (char *)[charMapData_ bytes];
   62|     77|    NSUInteger length = [charMapData_ length];
   63|     77|    if (length < 2 || length > 128 || length & (length - 1)) {
   64|      0|      // Length not a power of 2 between 2 and 128
   65|      0|      return nil;
   66|      0|    }
   67|     77|
   68|     77|    memset(reverseCharMap_, kUnknownChar, sizeof(reverseCharMap_));
   69|  5.00k|    for (unsigned int i = 0; i < length; i++) {
   70|  4.92k|      if (reverseCharMap_[(int)charMap_[i]] != kUnknownChar) {
   71|      0|        // Duplicate character at |i|
   72|      0|        return nil;
   73|      0|      }
   74|  4.92k|      reverseCharMap_[(int)charMap_[i]] = i;
   75|  4.92k|    }
   76|     77|
   77|    539|    for (NSUInteger i = 1; i < length; i <<= 1) shift_++;
   78|     77|    mask_ = (1 << shift_) - 1;
   79|     77|    padLen_ = lcm(8, shift_) / shift_;
   80|     77|  }
   81|     77|  return self;
   82|     77|}
   83|       |
   84|      0|- (NSString *)description {
   85|      0|  return [NSString stringWithFormat:@"<Base%d StringEncoder: %@>", 1 << shift_, charMapData_];
   86|      0|}
   87|       |
   88|      0|- (BOOL)doPad {
   89|      0|  return doPad_;
   90|      0|}
   91|       |
   92|    154|- (void)setDoPad:(BOOL)doPad {
   93|    154|  doPad_ = doPad;
   94|    154|}
   95|       |
   96|     77|- (void)setPaddingChar:(char)c {
   97|     77|  paddingChar_ = c;
   98|     77|  reverseCharMap_[(int)c] = kPaddingChar;
   99|     77|}
  100|       |
  101|     77|- (NSString *)encode:(NSData *)inData {
  102|     77|  NSUInteger inLen = [inData length];
  103|     77|  if (inLen <= 0) {
  104|      0|    // Empty input
  105|      0|    return @"";
  106|      0|  }
  107|     77|  unsigned char *inBuf = (unsigned char *)[inData bytes];
  108|     77|  NSUInteger inPos = 0;
  109|     77|
  110|     77|  NSUInteger outLen = (inLen * 8 + shift_ - 1) / shift_;
  111|     77|  if (doPad_) {
  112|      0|    outLen = ((outLen + padLen_ - 1) / padLen_) * padLen_;
  113|      0|  }
  114|     77|  NSMutableData *outData = [NSMutableData dataWithLength:outLen];
  115|     77|  unsigned char *outBuf = (unsigned char *)[outData mutableBytes];
  116|     77|  NSUInteger outPos = 0;
  117|     77|
  118|     77|  unsigned int buffer = inBuf[inPos++];
  119|     77|  int bitsLeft = 8;
  120|    924|  while (bitsLeft > 0 || inPos < inLen) {
  121|    847|    if (bitsLeft < shift_) {
  122|    616|      if (inPos < inLen) {
  123|    539|        buffer <<= 8;
  124|    539|        buffer |= (inBuf[inPos++] & 0xff);
  125|    539|        bitsLeft += 8;
  126|    539|      } else {
  127|     77|        int pad = shift_ - bitsLeft;
  128|     77|        buffer <<= pad;
  129|     77|        bitsLeft += pad;
  130|     77|      }
  131|    616|    }
  132|    847|    unsigned int idx = (buffer >> (bitsLeft - shift_)) & mask_;
  133|    847|    bitsLeft -= shift_;
  134|    847|    outBuf[outPos++] = charMap_[idx];
  135|    847|  }
  136|     77|
  137|     77|  if (doPad_) {
  138|      0|    while (outPos < outLen) outBuf[outPos++] = paddingChar_;
  139|      0|  }
  140|     77|
  141|     77|  _FIRInstanceIDDevAssert(outPos == outLen, @"Underflowed output buffer");
  142|     77|  [outData setLength:outPos];
  143|     77|
  144|     77|  return [[NSString alloc] initWithData:outData encoding:NSASCIIStringEncoding];
  145|     77|}
  146|       |
  147|      0|- (NSData *)decode:(NSString *)inString {
  148|      0|  char *inBuf = (char *)[inString cStringUsingEncoding:NSASCIIStringEncoding];
  149|      0|  if (!inBuf) {
  150|      0|    // Unable to convert buffer to ASCII
  151|      0|    return nil;
  152|      0|  }
  153|      0|  NSUInteger inLen = strlen(inBuf);
  154|      0|
  155|      0|  NSUInteger outLen = inLen * shift_ / 8;
  156|      0|  NSMutableData *outData = [NSMutableData dataWithLength:outLen];
  157|      0|  unsigned char *outBuf = (unsigned char *)[outData mutableBytes];
  158|      0|  NSUInteger outPos = 0;
  159|      0|
  160|      0|  int buffer = 0;
  161|      0|  int bitsLeft = 0;
  162|      0|  BOOL expectPad = NO;
  163|      0|  for (NSUInteger i = 0; i < inLen; i++) {
  164|      0|    int val = reverseCharMap_[(int)inBuf[i]];
  165|      0|    switch (val) {
  166|      0|      case kIgnoreChar:
  167|      0|        break;
  168|      0|      case kPaddingChar:
  169|      0|        expectPad = YES;
  170|      0|        break;
  171|      0|      case kUnknownChar:
  172|      0|        // Unexpected data at input pos |i|
  173|      0|        return nil;
  174|      0|      default:
  175|      0|        if (expectPad) {
  176|      0|          // Expected further padding characters
  177|      0|          return nil;
  178|      0|        }
  179|      0|        buffer <<= shift_;
  180|      0|        buffer |= val & mask_;
  181|      0|        bitsLeft += shift_;
  182|      0|        if (bitsLeft >= 8) {
  183|      0|          outBuf[outPos++] = (unsigned char)(buffer >> (bitsLeft - 8));
  184|      0|          bitsLeft -= 8;
  185|      0|        }
  186|      0|        break;
  187|      0|    }
  188|      0|  }
  189|      0|
  190|      0|  if (bitsLeft && buffer & ((1 << bitsLeft) - 1)) {
  191|      0|    // Incomplete trailing data
  192|      0|    return nil;
  193|      0|  }
  194|      0|
  195|      0|  // Shorten buffer if needed due to padding chars
  196|      0|  _FIRInstanceIDDevAssert(outPos <= outLen, @"Overflowed buffer");
  197|      0|  [outData setLength:outPos];
  198|      0|
  199|      0|  return outData;
  200|      0|}
  201|       |
  202|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDTokenDeleteOperation.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDTokenDeleteOperation.h"
   18|       |
   19|       |#import "FIRInstanceIDCheckinPreferences.h"
   20|       |#import "FIRInstanceIDDefines.h"
   21|       |#import "FIRInstanceIDLogger.h"
   22|       |#import "FIRInstanceIDTokenOperation+Private.h"
   23|       |#import "FIRInstanceIDURLQueryItem.h"
   24|       |#import "FIRInstanceIDUtilities.h"
   25|       |#import "NSError+FIRInstanceID.h"
   26|       |
   27|       |@implementation FIRInstanceIDTokenDeleteOperation
   28|       |
   29|       |- (instancetype)initWithAuthorizedEntity:(NSString *)authorizedEntity
   30|       |                                   scope:(NSString *)scope
   31|       |                      checkinPreferences:(FIRInstanceIDCheckinPreferences *)checkinPreferences
   32|       |                                 keyPair:(FIRInstanceIDKeyPair *)keyPair
   33|      0|                                  action:(FIRInstanceIDTokenAction)action {
   34|      0|  self = [super initWithAction:action
   35|      0|           forAuthorizedEntity:authorizedEntity
   36|      0|                         scope:scope
   37|      0|                       options:nil
   38|      0|            checkinPreferences:checkinPreferences
   39|      0|                       keyPair:keyPair];
   40|      0|  if (self) {
   41|      0|  }
   42|      0|  return self;
   43|      0|}
   44|       |
   45|      0|- (void)performTokenOperation {
   46|      0|  NSString *authHeader =
   47|      0|      [FIRInstanceIDTokenOperation HTTPAuthHeaderFromCheckin:self.checkinPreferences];
   48|      0|  NSMutableURLRequest *request = [FIRInstanceIDTokenOperation requestWithAuthHeader:authHeader];
   49|      0|
   50|      0|  // Build form-encoded body
   51|      0|  NSString *deviceAuthID = self.checkinPreferences.deviceID;
   52|      0|  NSMutableArray<FIRInstanceIDURLQueryItem *> *queryItems =
   53|      0|      [FIRInstanceIDTokenOperation standardQueryItemsWithDeviceID:deviceAuthID scope:self.scope];
   54|      0|  [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"delete" value:@"true"]];
   55|      0|  if (self.action == FIRInstanceIDTokenActionDeleteTokenAndIID) {
   56|      0|    [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"iid-operation"
   57|      0|                                                                 value:@"delete"]];
   58|      0|  }
   59|      0|  if (self.authorizedEntity) {
   60|      0|    [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"sender"
   61|      0|                                                                 value:self.authorizedEntity]];
   62|      0|  }
   63|      0|  // Typically we include our public key-signed url items, but in some cases (like deleting all FCM
   64|      0|  // tokens), we don't.
   65|      0|  if (self.keyPair != nil) {
   66|      0|    [queryItems addObjectsFromArray:[self queryItemsWithKeyPair:self.keyPair]];
   67|      0|  }
   68|      0|
   69|      0|  NSString *content = FIRInstanceIDQueryFromQueryItems(queryItems);
   70|      0|  request.HTTPBody = [content dataUsingEncoding:NSUTF8StringEncoding];
   71|      0|  FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenDeleteOperationFetchRequest,
   72|      0|                           @"Unregister request to %@ content: %@", FIRInstanceIDRegisterServer(),
   73|      0|                           content);
   74|      0|
   75|      0|  FIRInstanceID_WEAKIFY(self);
   76|      0|  void (^requestHandler)(NSData *, NSURLResponse *, NSError *) =
   77|      0|      ^(NSData *data, NSURLResponse *response, NSError *error) {
   78|      0|        FIRInstanceID_STRONGIFY(self);
   79|      0|        [self handleResponseWithData:data response:response error:error];
   80|      0|      };
   81|      0|
   82|      0|  // Test block
   83|      0|  if (self.testBlock) {
   84|      0|    self.testBlock(request, requestHandler);
   85|      0|    return;
   86|      0|  }
   87|      0|
   88|      0|  NSURLSession *session = [FIRInstanceIDTokenOperation sharedURLSession];
   89|      0|  self.dataTask = [session dataTaskWithRequest:request completionHandler:requestHandler];
   90|      0|  [self.dataTask resume];
   91|      0|}
   92|       |
   93|       |- (void)handleResponseWithData:(NSData *)data
   94|       |                      response:(NSURLResponse *)response
   95|      0|                         error:(NSError *)error {
   96|      0|  if (error) {
   97|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenDeleteOperationRequestError,
   98|      0|                             @"Device unregister HTTP fetch error. Error code: %ld",
   99|      0|                             _FIRInstanceID_L(error.code));
  100|      0|    [self finishWithResult:FIRInstanceIDTokenOperationError token:nil error:error];
  101|      0|    return;
  102|      0|  }
  103|      0|
  104|      0|  NSString *dataResponse = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
  105|      0|  if (dataResponse.length == 0) {
  106|      0|    NSError *error = [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeUnknown];
  107|      0|    [self finishWithResult:FIRInstanceIDTokenOperationError token:nil error:error];
  108|      0|    return;
  109|      0|  }
  110|      0|
  111|      0|  if (![dataResponse hasPrefix:@"deleted="] && ![dataResponse hasPrefix:@"token="]) {
  112|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenDeleteOperationBadResponse,
  113|      0|                             @"Invalid unregister response %@", response);
  114|      0|    NSError *error = [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeUnknown];
  115|      0|    [self finishWithResult:FIRInstanceIDTokenOperationError token:nil error:error];
  116|      0|    return;
  117|      0|  }
  118|      0|  [self finishWithResult:FIRInstanceIDTokenOperationSucceeded token:nil error:nil];
  119|      0|}
  120|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDTokenFetchOperation.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDTokenFetchOperation.h"
   18|       |
   19|       |#import "FIRInstanceIDCheckinPreferences.h"
   20|       |#import "FIRInstanceIDConstants.h"
   21|       |#import "FIRInstanceIDDefines.h"
   22|       |#import "FIRInstanceIDLogger.h"
   23|       |#import "FIRInstanceIDTokenOperation+Private.h"
   24|       |#import "FIRInstanceIDURLQueryItem.h"
   25|       |#import "FIRInstanceIDUtilities.h"
   26|       |#import "NSError+FIRInstanceID.h"
   27|       |
   28|       |// We can have a static int since this error should theoretically only
   29|       |// happen once (for the first time). If it repeats there is something
   30|       |// else that is wrong.
   31|       |static int phoneRegistrationErrorRetryCount = 0;
   32|       |static const int kMaxPhoneRegistrationErrorRetryCount = 10;
   33|       |
   34|       |@implementation FIRInstanceIDTokenFetchOperation
   35|       |
   36|       |- (instancetype)initWithAuthorizedEntity:(NSString *)authorizedEntity
   37|       |                                   scope:(NSString *)scope
   38|       |                                 options:(nullable NSDictionary<NSString *, NSString *> *)options
   39|       |                      checkinPreferences:(FIRInstanceIDCheckinPreferences *)checkinPreferences
   40|      0|                                 keyPair:(FIRInstanceIDKeyPair *)keyPair {
   41|      0|  self = [super initWithAction:FIRInstanceIDTokenActionFetch
   42|      0|           forAuthorizedEntity:authorizedEntity
   43|      0|                         scope:scope
   44|      0|                       options:options
   45|      0|            checkinPreferences:checkinPreferences
   46|      0|                       keyPair:keyPair];
   47|      0|  if (self) {
   48|      0|  }
   49|      0|  return self;
   50|      0|}
   51|       |
   52|      0|- (void)performTokenOperation {
   53|      0|  NSString *authHeader =
   54|      0|      [FIRInstanceIDTokenOperation HTTPAuthHeaderFromCheckin:self.checkinPreferences];
   55|      0|  NSMutableURLRequest *request = [[self class] requestWithAuthHeader:authHeader];
   56|      0|  NSString *checkinVersionInfo = self.checkinPreferences.versionInfo;
   57|      0|  [request setValue:checkinVersionInfo forHTTPHeaderField:@"info"];
   58|      0|
   59|      0|  // Build form-encoded body
   60|      0|  NSString *deviceAuthID = self.checkinPreferences.deviceID;
   61|      0|  NSMutableArray<FIRInstanceIDURLQueryItem *> *queryItems =
   62|      0|      [[self class] standardQueryItemsWithDeviceID:deviceAuthID scope:self.scope];
   63|      0|  [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"sender"
   64|      0|                                                               value:self.authorizedEntity]];
   65|      0|  [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"X-subtype"
   66|      0|                                                               value:self.authorizedEntity]];
   67|      0|
   68|      0|  [queryItems addObjectsFromArray:[self queryItemsWithKeyPair:self.keyPair]];
   69|      0|
   70|      0|  // Create query items from passed-in options
   71|      0|  id apnsTokenData = self.options[kFIRInstanceIDTokenOptionsAPNSKey];
   72|      0|  id apnsSandboxValue = self.options[kFIRInstanceIDTokenOptionsAPNSIsSandboxKey];
   73|      0|  if ([apnsTokenData isKindOfClass:[NSData class]] &&
   74|      0|      [apnsSandboxValue isKindOfClass:[NSNumber class]]) {
   75|      0|    NSString *APNSString = FIRInstanceIDAPNSTupleStringForTokenAndServerType(
   76|      0|        apnsTokenData, ((NSNumber *)apnsSandboxValue).boolValue);
   77|      0|    // The name of the query item happens to be the same as the dictionary key
   78|      0|    FIRInstanceIDURLQueryItem *item =
   79|      0|        [FIRInstanceIDURLQueryItem queryItemWithName:kFIRInstanceIDTokenOptionsAPNSKey
   80|      0|                                               value:APNSString];
   81|      0|    [queryItems addObject:item];
   82|      0|  }
   83|      0|  id firebaseAppID = self.options[kFIRInstanceIDTokenOptionsFirebaseAppIDKey];
   84|      0|  if ([firebaseAppID isKindOfClass:[NSString class]]) {
   85|      0|    // The name of the query item happens to be the same as the dictionary key
   86|      0|    FIRInstanceIDURLQueryItem *item =
   87|      0|        [FIRInstanceIDURLQueryItem queryItemWithName:kFIRInstanceIDTokenOptionsFirebaseAppIDKey
   88|      0|                                               value:(NSString *)firebaseAppID];
   89|      0|    [queryItems addObject:item];
   90|      0|  }
   91|      0|
   92|      0|  NSString *content = FIRInstanceIDQueryFromQueryItems(queryItems);
   93|      0|  request.HTTPBody = [content dataUsingEncoding:NSUTF8StringEncoding];
   94|      0|  FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenFetchOperationFetchRequest,
   95|      0|                           @"Register request to %@ content: %@", FIRInstanceIDRegisterServer(),
   96|      0|                           content);
   97|      0|
   98|      0|  FIRInstanceID_WEAKIFY(self);
   99|      0|  void (^requestHandler)(NSData *, NSURLResponse *, NSError *) =
  100|      0|      ^(NSData *data, NSURLResponse *response, NSError *error) {
  101|      0|        FIRInstanceID_STRONGIFY(self);
  102|      0|        [self handleResponseWithData:data response:response error:error];
  103|      0|      };
  104|      0|
  105|      0|  // Test block
  106|      0|  if (self.testBlock) {
  107|      0|    self.testBlock(request, requestHandler);
  108|      0|    return;
  109|      0|  }
  110|      0|
  111|      0|  NSURLSession *session = [FIRInstanceIDTokenOperation sharedURLSession];
  112|      0|  self.dataTask = [session dataTaskWithRequest:request completionHandler:requestHandler];
  113|      0|  [self.dataTask resume];
  114|      0|}
  115|       |
  116|       |#pragma mark - Request Handling
  117|       |
  118|       |- (void)handleResponseWithData:(NSData *)data
  119|       |                      response:(NSURLResponse *)response
  120|      0|                         error:(NSError *)error {
  121|      0|  if (error) {
  122|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenFetchOperationRequestError,
  123|      0|                             @"Token fetch HTTP error. Error Code: %ld", (long)error.code);
  124|      0|    [self finishWithResult:FIRInstanceIDTokenOperationError token:nil error:error];
  125|      0|    return;
  126|      0|  }
  127|      0|  NSString *dataResponse = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
  128|      0|
  129|      0|  if (dataResponse.length == 0) {
  130|      0|    NSError *error = [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeUnknown];
  131|      0|    [self finishWithResult:FIRInstanceIDTokenOperationError token:nil error:error];
  132|      0|    return;
  133|      0|  }
  134|      0|  NSDictionary *parsedResponse = [self parseFetchTokenResponse:dataResponse];
  135|      0|  _FIRInstanceIDDevAssert(parsedResponse.count, @"Invalid registration response");
  136|      0|
  137|      0|  if ([parsedResponse[@"token"] length]) {
  138|      0|    [self finishWithResult:FIRInstanceIDTokenOperationSucceeded
  139|      0|                     token:parsedResponse[@"token"]
  140|      0|                     error:nil];
  141|      0|    return;
  142|      0|  }
  143|      0|
  144|      0|  NSString *errorValue = parsedResponse[@"Error"];
  145|      0|  NSError *responseError;
  146|      0|  if (errorValue.length) {
  147|      0|    NSArray *errorComponents = [errorValue componentsSeparatedByString:@":"];
  148|      0|    // HACK (Kansas replication delay), PHONE_REGISTRATION_ERROR on App
  149|      0|    // uninstall and reinstall.
  150|      0|    if ([errorComponents containsObject:@"PHONE_REGISTRATION_ERROR"]) {
  151|      0|      // Encountered issue http://b/27043795
  152|      0|      // Retry register until successful or another error encountered or a
  153|      0|      // certain number of tries are over.
  154|      0|
  155|      0|      if (phoneRegistrationErrorRetryCount < kMaxPhoneRegistrationErrorRetryCount) {
  156|      0|        const int nextRetryInterval = 1 << phoneRegistrationErrorRetryCount;
  157|      0|        FIRInstanceID_WEAKIFY(self);
  158|      0|
  159|      0|        dispatch_after(
  160|      0|            dispatch_time(DISPATCH_TIME_NOW, (int64_t)(nextRetryInterval * NSEC_PER_SEC)),
  161|      0|            dispatch_get_main_queue(), ^{
  162|      0|              FIRInstanceID_STRONGIFY(self);
  163|      0|              phoneRegistrationErrorRetryCount++;
  164|      0|              [self performTokenOperation];
  165|      0|            });
  166|      0|        return;
  167|      0|      }
  168|      0|    } else if ([errorComponents containsObject:kFIRInstanceID_CMD_RST]) {
  169|      0|      // Server detected the identity we use is no longer valid.
  170|      0|      NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
  171|      0|      [center postNotificationName:kFIRInstanceIDIdentityInvalidatedNotification object:nil];
  172|      0|
  173|      0|      FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeInternal001,
  174|      0|                               @"Identity is invalid. Server request identity reset.");
  175|      0|      responseError =
  176|      0|          [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeInvalidIdentity];
  177|      0|    }
  178|      0|  }
  179|      0|  if (!responseError) {
  180|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenFetchOperationBadResponse,
  181|      0|                             @"Invalid fetch response, expected 'token' or 'Error' key");
  182|      0|    responseError = [NSError errorWithFIRInstanceIDErrorCode:kFIRInstanceIDErrorCodeUnknown];
  183|      0|  }
  184|      0|  [self finishWithResult:FIRInstanceIDTokenOperationError token:nil error:responseError];
  185|      0|}
  186|       |
  187|       |// expect a response e.g. "token=<reg id>\nGOOG.ttl=123"
  188|      0|- (NSDictionary *)parseFetchTokenResponse:(NSString *)response {
  189|      0|  NSArray *lines = [response componentsSeparatedByString:@"\n"];
  190|      0|  NSMutableDictionary *parsedResponse = [NSMutableDictionary dictionary];
  191|      0|  for (NSString *line in lines) {
  192|      0|    NSArray *keyAndValue = [line componentsSeparatedByString:@"="];
  193|      0|    if ([keyAndValue count] > 1) {
  194|      0|      parsedResponse[keyAndValue[0]] = keyAndValue[1];
  195|      0|    }
  196|      0|  }
  197|      0|  return parsedResponse;
  198|      0|}
  199|       |
  200|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDTokenInfo.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDTokenInfo.h"
   18|       |
   19|       |#import "FIRInstanceIDLogger.h"
   20|       |#import "FIRInstanceIDUtilities.h"
   21|       |
   22|       |/**
   23|       | *  @enum Token Info Dictionary Key Constants
   24|       | *  @discussion The keys that are checked when a token info is
   25|       | *              created from a dictionary. The same keys are used
   26|       | *              when decoding/encoding an archive.
   27|       | */
   28|       |/// Specifies a dictonary key whose value represents the authorized entity, or
   29|       |/// Sender ID for the token.
   30|       |static NSString *const kFIRInstanceIDAuthorizedEntityKey = @"authorized_entity";
   31|       |/// Specifies a dictionary key whose value represents the scope of the token,
   32|       |/// typically "*".
   33|       |static NSString *const kFIRInstanceIDScopeKey = @"scope";
   34|       |/// Specifies a dictionary key which represents the token value itself.
   35|       |static NSString *const kFIRInstanceIDTokenKey = @"token";
   36|       |/// Specifies a dictionary key which represents the app version associated
   37|       |/// with the token.
   38|       |static NSString *const kFIRInstanceIDAppVersionKey = @"app_version";
   39|       |/// Specifies a dictionary key which represents the GMP App ID associated with
   40|       |/// the token.
   41|       |static NSString *const kFIRInstanceIDFirebaseAppIDKey = @"firebase_app_id";
   42|       |/// Specifies a dictionary key representing an archive for a
   43|       |/// `FIRInstanceIDAPNSInfo` object.
   44|       |static NSString *const kFIRInstanceIDAPNSInfoKey = @"apns_info";
   45|       |/// Specifies a dictionary key representing the "last cached" time for the token.
   46|       |static NSString *const kFIRInstanceIDCacheTimeKey = @"cache_time";
   47|       |/// Default interval that token stays fresh.
   48|       |const NSTimeInterval kDefaultFetchTokenInterval = 7 * 24 * 60 * 60;  // 7 days.
   49|       |
   50|       |@implementation FIRInstanceIDTokenInfo
   51|       |
   52|       |- (instancetype)initWithAuthorizedEntity:(NSString *)authorizedEntity
   53|       |                                   scope:(NSString *)scope
   54|       |                                   token:(NSString *)token
   55|       |                              appVersion:(NSString *)appVersion
   56|      0|                           firebaseAppID:(NSString *)firebaseAppID {
   57|      0|  self = [super init];
   58|      0|  if (self) {
   59|      0|    _authorizedEntity = [authorizedEntity copy];
   60|      0|    _scope = [scope copy];
   61|      0|    _token = [token copy];
   62|      0|    _appVersion = [appVersion copy];
   63|      0|    _firebaseAppID = [firebaseAppID copy];
   64|      0|  }
   65|      0|  return self;
   66|      0|}
   67|       |
   68|      0|- (BOOL)isFresh {
   69|      0|  // Last fetch token cache time could be null if token is from legacy storage format. Then token is
   70|      0|  // considered not fresh and should be refreshed and overwrite with the latest storage format.
   71|      0|  if (!_cacheTime) {
   72|      0|    return NO;
   73|      0|  }
   74|      0|
   75|      0|  // Check if app has just been updated to a new version.
   76|      0|  NSString *currentAppVersion = FIRInstanceIDCurrentAppVersion();
   77|      0|  if (!_appVersion || ![_appVersion isEqualToString:currentAppVersion]) {
   78|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenManager004,
   79|      0|                             @"Invalidating cached token for %@ (%@) due to app version change.",
   80|      0|                             _authorizedEntity, _scope);
   81|      0|    return NO;
   82|      0|  }
   83|      0|
   84|      0|  // Check if GMP App ID has changed
   85|      0|  NSString *currentFirebaseAppID = FIRInstanceIDFirebaseAppID();
   86|      0|  if (!_firebaseAppID || ![_firebaseAppID isEqualToString:currentFirebaseAppID]) {
   87|      0|    FIRInstanceIDLoggerDebug(
   88|      0|        kFIRInstanceIDMessageCodeTokenInfoFirebaseAppIDChanged,
   89|      0|        @"Invalidating cached token due to Firebase App IID change from %@ to %@", _firebaseAppID,
   90|      0|        currentFirebaseAppID);
   91|      0|    return NO;
   92|      0|  }
   93|      0|
   94|      0|  // Check whether locale has changed, if yes, token needs to be updated with server for locale
   95|      0|  // information.
   96|      0|  if (FIRInstanceIDHasLocaleChanged()) {
   97|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenInfoLocaleChanged,
   98|      0|                             @"Invalidating cached token due to locale change");
   99|      0|    return NO;
  100|      0|  }
  101|      0|
  102|      0|  // Locale is not changed, check whether token has been fetched within 7 days.
  103|      0|  NSTimeInterval lastFetchTokenTimestamp = [_cacheTime timeIntervalSince1970];
  104|      0|  NSTimeInterval currentTimestamp = FIRInstanceIDCurrentTimestampInSeconds();
  105|      0|  NSTimeInterval timeSinceLastFetchToken = currentTimestamp - lastFetchTokenTimestamp;
  106|      0|  return (timeSinceLastFetchToken < kDefaultFetchTokenInterval);
  107|      0|}
  108|       |#pragma mark - NSCoding
  109|       |
  110|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
  111|      0|  // These value cannot be nil
  112|      0|
  113|      0|  id authorizedEntity = [aDecoder decodeObjectForKey:kFIRInstanceIDAuthorizedEntityKey];
  114|      0|  if (![authorizedEntity isKindOfClass:[NSString class]]) {
  115|      0|    return nil;
  116|      0|  }
  117|      0|
  118|      0|  id scope = [aDecoder decodeObjectForKey:kFIRInstanceIDScopeKey];
  119|      0|  if (![scope isKindOfClass:[NSString class]]) {
  120|      0|    return nil;
  121|      0|  }
  122|      0|
  123|      0|  id token = [aDecoder decodeObjectForKey:kFIRInstanceIDTokenKey];
  124|      0|  if (![token isKindOfClass:[NSString class]]) {
  125|      0|    return nil;
  126|      0|  }
  127|      0|
  128|      0|  // These values are nullable, so only fail the decode if the type does not match
  129|      0|
  130|      0|  id appVersion = [aDecoder decodeObjectForKey:kFIRInstanceIDAppVersionKey];
  131|      0|  if (appVersion && ![appVersion isKindOfClass:[NSString class]]) {
  132|      0|    return nil;
  133|      0|  }
  134|      0|
  135|      0|  id firebaseAppID = [aDecoder decodeObjectForKey:kFIRInstanceIDFirebaseAppIDKey];
  136|      0|  if (firebaseAppID && ![firebaseAppID isKindOfClass:[NSString class]]) {
  137|      0|    return nil;
  138|      0|  }
  139|      0|
  140|      0|  id rawAPNSInfo = [aDecoder decodeObjectForKey:kFIRInstanceIDAPNSInfoKey];
  141|      0|  if (rawAPNSInfo && ![rawAPNSInfo isKindOfClass:[NSData class]]) {
  142|      0|    return nil;
  143|      0|  }
  144|      0|
  145|      0|  FIRInstanceIDAPNSInfo *APNSInfo = nil;
  146|      0|  if (rawAPNSInfo) {
  147|      0|    @try {
  148|      0|      APNSInfo = [NSKeyedUnarchiver unarchiveObjectWithData:rawAPNSInfo];
  149|      0|    } @catch (NSException *exception) {
  150|      0|      FIRInstanceIDLoggerInfo(kFIRInstanceIDMessageCodeTokenInfoBadAPNSInfo,
  151|      0|                              @"Could not parse raw APNS Info while parsing archived token info.");
  152|      0|      APNSInfo = nil;
  153|      0|    } @finally {
  154|      0|    }
  155|      0|  }
  156|      0|
  157|      0|  id cacheTime = [aDecoder decodeObjectForKey:kFIRInstanceIDCacheTimeKey];
  158|      0|  if (cacheTime && ![cacheTime isKindOfClass:[NSDate class]]) {
  159|      0|    return nil;
  160|      0|  }
  161|      0|
  162|      0|  self = [super init];
  163|      0|  if (self) {
  164|      0|    _authorizedEntity = authorizedEntity;
  165|      0|    _scope = scope;
  166|      0|    _token = token;
  167|      0|    _appVersion = appVersion;
  168|      0|    _firebaseAppID = firebaseAppID;
  169|      0|    _APNSInfo = APNSInfo;
  170|      0|    _cacheTime = cacheTime;
  171|      0|  }
  172|      0|  return self;
  173|      0|}
  174|       |
  175|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  176|      0|  [aCoder encodeObject:self.authorizedEntity forKey:kFIRInstanceIDAuthorizedEntityKey];
  177|      0|  [aCoder encodeObject:self.scope forKey:kFIRInstanceIDScopeKey];
  178|      0|  [aCoder encodeObject:self.token forKey:kFIRInstanceIDTokenKey];
  179|      0|  [aCoder encodeObject:self.appVersion forKey:kFIRInstanceIDAppVersionKey];
  180|      0|  [aCoder encodeObject:self.firebaseAppID forKey:kFIRInstanceIDFirebaseAppIDKey];
  181|      0|  if (self.APNSInfo) {
  182|      0|    NSData *rawAPNSInfo = [NSKeyedArchiver archivedDataWithRootObject:self.APNSInfo];
  183|      0|    [aCoder encodeObject:rawAPNSInfo forKey:kFIRInstanceIDAPNSInfoKey];
  184|      0|  }
  185|      0|  [aCoder encodeObject:self.cacheTime forKey:kFIRInstanceIDCacheTimeKey];
  186|      0|}
  187|       |
  188|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDTokenManager.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDTokenManager.h"
   18|       |
   19|       |#import "FIRInstanceIDAuthKeyChain.h"
   20|       |#import "FIRInstanceIDAuthService.h"
   21|       |#import "FIRInstanceIDCheckinPreferences.h"
   22|       |#import "FIRInstanceIDConstants.h"
   23|       |#import "FIRInstanceIDDefines.h"
   24|       |#import "FIRInstanceIDLogger.h"
   25|       |#import "FIRInstanceIDStore.h"
   26|       |#import "FIRInstanceIDTokenDeleteOperation.h"
   27|       |#import "FIRInstanceIDTokenFetchOperation.h"
   28|       |#import "FIRInstanceIDTokenInfo.h"
   29|       |#import "FIRInstanceIDTokenOperation.h"
   30|       |#import "NSError+FIRInstanceID.h"
   31|       |
   32|       |@interface FIRInstanceIDTokenManager () <FIRInstanceIDStoreDelegate>
   33|       |
   34|       |@property(nonatomic, readwrite, strong) FIRInstanceIDStore *instanceIDStore;
   35|       |@property(nonatomic, readwrite, strong) FIRInstanceIDAuthService *authService;
   36|       |@property(nonatomic, readonly, strong) NSOperationQueue *tokenOperations;
   37|       |
   38|       |@property(nonatomic, readwrite, strong) FIRInstanceIDAPNSInfo *currentAPNSInfo;
   39|       |
   40|       |@end
   41|       |
   42|       |@implementation FIRInstanceIDTokenManager
   43|       |
   44|     14|- (instancetype)init {
   45|     14|  self = [super init];
   46|     14|  if (self) {
   47|     14|    _instanceIDStore = [[FIRInstanceIDStore alloc] initWithDelegate:self];
   48|     14|    _authService = [[FIRInstanceIDAuthService alloc] initWithStore:_instanceIDStore];
   49|     14|    [self configureTokenOperations];
   50|     14|  }
   51|     14|  return self;
   52|     14|}
   53|       |
   54|      0|- (void)dealloc {
   55|      0|  [self stopAllTokenOperations];
   56|      0|}
   57|       |
   58|     14|- (void)configureTokenOperations {
   59|     14|  _tokenOperations = [[NSOperationQueue alloc] init];
   60|     14|  _tokenOperations.name = @"com.google.iid-token-operations";
   61|     14|  // For now, restrict the operations to be serial, because in some cases (like if the
   62|     14|  // authorized entity and scope are the same), order matters.
   63|     14|  // If we have to deal with several different token requests simultaneously, it would be a good
   64|     14|  // idea to add some better intelligence around this (performing unrelated token operations
   65|     14|  // simultaneously, etc.).
   66|     14|  _tokenOperations.maxConcurrentOperationCount = 1;
   67|     14|  if ([_tokenOperations respondsToSelector:@selector(qualityOfService)]) {
   68|     14|    _tokenOperations.qualityOfService = NSOperationQualityOfServiceUtility;
   69|     14|  }
   70|     14|}
   71|       |
   72|       |- (void)fetchNewTokenWithAuthorizedEntity:(NSString *)authorizedEntity
   73|       |                                    scope:(NSString *)scope
   74|       |                                  keyPair:(FIRInstanceIDKeyPair *)keyPair
   75|       |                                  options:(NSDictionary *)options
   76|      0|                                  handler:(FIRInstanceIDTokenHandler)handler {
   77|      0|  FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenManager000,
   78|      0|                           @"Fetch new token for authorizedEntity: %@, scope: %@", authorizedEntity,
   79|      0|                           scope);
   80|      0|  FIRInstanceIDTokenFetchOperation *operation =
   81|      0|      [self createFetchOperationWithAuthorizedEntity:authorizedEntity
   82|      0|                                               scope:scope
   83|      0|                                             options:options
   84|      0|                                             keyPair:keyPair];
   85|      0|  FIRInstanceID_WEAKIFY(self);
   86|      0|  FIRInstanceIDTokenOperationCompletion completion =
   87|      0|      ^(FIRInstanceIDTokenOperationResult result, NSString *_Nullable token,
   88|      0|        NSError *_Nullable error) {
   89|      0|        FIRInstanceID_STRONGIFY(self);
   90|      0|        if (error) {
   91|      0|          handler(nil, error);
   92|      0|          return;
   93|      0|        }
   94|      0|        NSString *firebaseAppID = options[kFIRInstanceIDTokenOptionsFirebaseAppIDKey];
   95|      0|        FIRInstanceIDTokenInfo *tokenInfo = [[FIRInstanceIDTokenInfo alloc]
   96|      0|            initWithAuthorizedEntity:authorizedEntity
   97|      0|                               scope:scope
   98|      0|                               token:token
   99|      0|                          appVersion:FIRInstanceIDCurrentAppVersion()
  100|      0|                       firebaseAppID:firebaseAppID];
  101|      0|        tokenInfo.APNSInfo = [[FIRInstanceIDAPNSInfo alloc] initWithTokenOptionsDictionary:options];
  102|      0|
  103|      0|        [self.instanceIDStore
  104|      0|            saveTokenInfo:tokenInfo
  105|      0|                  handler:^(NSError *error) {
  106|      0|                    if (!error) {
  107|      0|                      // Do not send the token back in case the save was unsuccessful. Since with
  108|      0|                      // the new asychronous fetch mechanism this can lead to infinite loops, for
  109|      0|                      // example, we will return a valid token even though we weren't able to store
  110|      0|                      // it in our cache. The first token will lead to a onTokenRefresh callback
  111|      0|                      // wherein the user again calls `getToken` but since we weren't able to save
  112|      0|                      // it we won't hit the cache but hit the server again leading to an infinite
  113|      0|                      // loop.
  114|      0|                      FIRInstanceIDLoggerDebug(
  115|      0|                          kFIRInstanceIDMessageCodeTokenManager001,
  116|      0|                          @"Token fetch successful, token: %@, authorizedEntity: %@, scope:%@",
  117|      0|                          token, authorizedEntity, scope);
  118|      0|
  119|      0|                      if (handler) {
  120|      0|                        handler(token, nil);
  121|      0|                      }
  122|      0|                    } else {
  123|      0|                      if (handler) {
  124|      0|                        handler(nil, error);
  125|      0|                      }
  126|      0|                    }
  127|      0|                  }];
  128|      0|      };
  129|      0|  // Add completion handler, and ensure it's called on the main queue
  130|      0|  [operation addCompletionHandler:^(FIRInstanceIDTokenOperationResult result,
  131|      0|                                    NSString *_Nullable token, NSError *_Nullable error) {
  132|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  133|      0|      completion(result, token, error);
  134|      0|    });
  135|      0|  }];
  136|      0|  [self.tokenOperations addOperation:operation];
  137|      0|}
  138|       |
  139|       |- (FIRInstanceIDTokenInfo *)cachedTokenInfoWithAuthorizedEntity:(NSString *)authorizedEntity
  140|     14|                                                          scope:(NSString *)scope {
  141|     14|  return [self.instanceIDStore tokenInfoWithAuthorizedEntity:authorizedEntity scope:scope];
  142|     14|}
  143|       |
  144|       |- (void)deleteTokenWithAuthorizedEntity:(NSString *)authorizedEntity
  145|       |                                  scope:(NSString *)scope
  146|       |                                keyPair:(FIRInstanceIDKeyPair *)keyPair
  147|      0|                                handler:(FIRInstanceIDDeleteTokenHandler)handler {
  148|      0|  if ([self.instanceIDStore tokenInfoWithAuthorizedEntity:authorizedEntity scope:scope]) {
  149|      0|    [self.instanceIDStore removeCachedTokenWithAuthorizedEntity:authorizedEntity scope:scope];
  150|      0|  }
  151|      0|  // Does not matter if we cannot find it in the cache. Still make an effort to unregister
  152|      0|  // from the server.
  153|      0|  FIRInstanceIDCheckinPreferences *checkinPreferences = self.authService.checkinPreferences;
  154|      0|  FIRInstanceIDTokenDeleteOperation *operation =
  155|      0|      [self createDeleteOperationWithAuthorizedEntity:authorizedEntity
  156|      0|                                                scope:scope
  157|      0|                                   checkinPreferences:checkinPreferences
  158|      0|                                              keyPair:keyPair
  159|      0|                                               action:FIRInstanceIDTokenActionDeleteToken];
  160|      0|
  161|      0|  if (handler) {
  162|      0|    [operation addCompletionHandler:^(FIRInstanceIDTokenOperationResult result,
  163|      0|                                      NSString *_Nullable token, NSError *_Nullable error) {
  164|      0|      dispatch_async(dispatch_get_main_queue(), ^{
  165|      0|        handler(error);
  166|      0|      });
  167|      0|    }];
  168|      0|  }
  169|      0|  [self.tokenOperations addOperation:operation];
  170|      0|}
  171|       |
  172|       |- (void)deleteAllTokensWithKeyPair:(FIRInstanceIDKeyPair *)keyPair
  173|      0|                           handler:(FIRInstanceIDDeleteHandler)handler {
  174|      0|  // delete all tokens
  175|      0|  FIRInstanceIDCheckinPreferences *checkinPreferences = self.authService.checkinPreferences;
  176|      0|  if (!checkinPreferences) {
  177|      0|    // The checkin is already deleted. No need to trigger the token delete operation as client no
  178|      0|    // longer has the checkin information for server to delete.
  179|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  180|      0|      handler(nil);
  181|      0|    });
  182|      0|    return;
  183|      0|  }
  184|      0|  FIRInstanceIDTokenDeleteOperation *operation =
  185|      0|      [self createDeleteOperationWithAuthorizedEntity:kFIRInstanceIDKeychainWildcardIdentifier
  186|      0|                                                scope:kFIRInstanceIDKeychainWildcardIdentifier
  187|      0|                                   checkinPreferences:checkinPreferences
  188|      0|                                              keyPair:keyPair
  189|      0|                                               action:FIRInstanceIDTokenActionDeleteTokenAndIID];
  190|      0|  if (handler) {
  191|      0|    [operation addCompletionHandler:^(FIRInstanceIDTokenOperationResult result,
  192|      0|                                      NSString *_Nullable token, NSError *_Nullable error) {
  193|      0|      dispatch_async(dispatch_get_main_queue(), ^{
  194|      0|        handler(error);
  195|      0|      });
  196|      0|    }];
  197|      0|  }
  198|      0|  [self.tokenOperations addOperation:operation];
  199|      0|}
  200|       |
  201|      1|- (void)deleteAllTokensLocallyWithHandler:(void (^)(NSError *error))handler {
  202|      1|  [self.instanceIDStore removeAllCachedTokensWithHandler:handler];
  203|      1|}
  204|       |
  205|      0|- (void)stopAllTokenOperations {
  206|      0|  [self.authService stopCheckinRequest];
  207|      0|  [self.tokenOperations cancelAllOperations];
  208|      0|}
  209|       |
  210|       |#pragma mark - FIRInstanceIDStoreDelegate
  211|       |
  212|       |- (void)store:(FIRInstanceIDStore *)store
  213|      0|    didDeleteFCMScopedTokensForCheckin:(FIRInstanceIDCheckinPreferences *)checkin {
  214|      0|  // Make a best effort try to delete the old client related state on the FCM server. This is
  215|      0|  // required to delete old pubusb registrations which weren't cleared when the app was deleted.
  216|      0|  //
  217|      0|  // This is only a one time effort. If this call fails the client would still receive duplicate
  218|      0|  // pubsub notifications if he is again subscribed to the same topic.
  219|      0|  //
  220|      0|  // The client state should be cleared on the server for the provided checkin preferences.
  221|      0|  FIRInstanceIDTokenDeleteOperation *operation =
  222|      0|      [self createDeleteOperationWithAuthorizedEntity:nil
  223|      0|                                                scope:nil
  224|      0|                                   checkinPreferences:checkin
  225|      0|                                              keyPair:nil
  226|      0|                                               action:FIRInstanceIDTokenActionDeleteToken];
  227|      0|  [operation addCompletionHandler:^(FIRInstanceIDTokenOperationResult result,
  228|      0|                                    NSString *_Nullable token, NSError *_Nullable error) {
  229|      0|    if (error) {
  230|      0|      FIRInstanceIDMessageCode code =
  231|      0|          kFIRInstanceIDMessageCodeTokenManagerErrorDeletingFCMTokensOnAppReset;
  232|      0|      FIRInstanceIDLoggerDebug(code, @"Failed to delete GCM server registrations on app reset.");
  233|      0|    } else {
  234|      0|      FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenManagerDeletedFCMTokensOnAppReset,
  235|      0|                               @"Successfully deleted GCM server registrations on app reset");
  236|      0|    }
  237|      0|  }];
  238|      0|
  239|      0|  [self.tokenOperations addOperation:operation];
  240|      0|}
  241|       |
  242|       |#pragma mark - Unit Testing Stub Helpers
  243|       |// We really have this method so that we can more easily stub it out for unit testing
  244|       |- (FIRInstanceIDTokenFetchOperation *)
  245|       |    createFetchOperationWithAuthorizedEntity:(NSString *)authorizedEntity
  246|       |                                       scope:(NSString *)scope
  247|       |                                     options:(NSDictionary<NSString *, NSString *> *)options
  248|      0|                                     keyPair:(FIRInstanceIDKeyPair *)keyPair {
  249|      0|  FIRInstanceIDCheckinPreferences *checkinPreferences = self.authService.checkinPreferences;
  250|      0|  FIRInstanceIDTokenFetchOperation *operation =
  251|      0|      [[FIRInstanceIDTokenFetchOperation alloc] initWithAuthorizedEntity:authorizedEntity
  252|      0|                                                                   scope:scope
  253|      0|                                                                 options:options
  254|      0|                                                      checkinPreferences:checkinPreferences
  255|      0|                                                                 keyPair:keyPair];
  256|      0|  return operation;
  257|      0|}
  258|       |
  259|       |// We really have this method so that we can more easily stub it out for unit testing
  260|       |- (FIRInstanceIDTokenDeleteOperation *)
  261|       |    createDeleteOperationWithAuthorizedEntity:(NSString *)authorizedEntity
  262|       |                                        scope:(NSString *)scope
  263|       |                           checkinPreferences:(FIRInstanceIDCheckinPreferences *)checkinPreferences
  264|       |                                      keyPair:(FIRInstanceIDKeyPair *)keyPair
  265|      0|                                       action:(FIRInstanceIDTokenAction)action {
  266|      0|  FIRInstanceIDTokenDeleteOperation *operation =
  267|      0|      [[FIRInstanceIDTokenDeleteOperation alloc] initWithAuthorizedEntity:authorizedEntity
  268|      0|                                                                    scope:scope
  269|      0|                                                       checkinPreferences:checkinPreferences
  270|      0|                                                                  keyPair:keyPair
  271|      0|                                                                   action:action];
  272|      0|  return operation;
  273|      0|}
  274|       |
  275|       |#pragma mark - Invalidating Cached Tokens
  276|      0|- (BOOL)checkForTokenRefreshPolicy {
  277|      0|  // We know at least one cached token exists.
  278|      0|  BOOL shouldFetchDefaultToken = NO;
  279|      0|  NSArray<FIRInstanceIDTokenInfo *> *tokenInfos = [self.instanceIDStore cachedTokenInfos];
  280|      0|
  281|      0|  NSMutableArray<FIRInstanceIDTokenInfo *> *tokenInfosToDelete =
  282|      0|      [NSMutableArray arrayWithCapacity:tokenInfos.count];
  283|      0|  for (FIRInstanceIDTokenInfo *tokenInfo in tokenInfos) {
  284|      0|    BOOL isTokenFresh = [tokenInfo isFresh];
  285|      0|    if (isTokenFresh) {
  286|      0|      // Token is fresh, do nothing.
  287|      0|      continue;
  288|      0|    }
  289|      0|    if ([tokenInfo.scope isEqualToString:kFIRInstanceIDDefaultTokenScope]) {
  290|      0|      // Default token is expired, do not mark for deletion. Fetch directly from server to
  291|      0|      // replace the current one.
  292|      0|      shouldFetchDefaultToken = YES;
  293|      0|    } else {
  294|      0|      // Non-default token is expired, mark for deletion.
  295|      0|      [tokenInfosToDelete addObject:tokenInfo];
  296|      0|    }
  297|      0|    FIRInstanceIDLoggerDebug(
  298|      0|        kFIRInstanceIDMessageCodeTokenManagerInvalidateStaleToken,
  299|      0|        @"Invalidating cached token for %@ (%@) due to token is no longer fresh.",
  300|      0|        tokenInfo.authorizedEntity, tokenInfo.scope);
  301|      0|  }
  302|      0|  for (FIRInstanceIDTokenInfo *tokenInfoToDelete in tokenInfosToDelete) {
  303|      0|    [self.instanceIDStore removeCachedTokenWithAuthorizedEntity:tokenInfoToDelete.authorizedEntity
  304|      0|                                                          scope:tokenInfoToDelete.scope];
  305|      0|  }
  306|      0|  return shouldFetchDefaultToken;
  307|      0|}
  308|       |
  309|       |- (NSArray<FIRInstanceIDTokenInfo *> *)updateTokensToAPNSDeviceToken:(NSData *)deviceToken
  310|      0|                                                           isSandbox:(BOOL)isSandbox {
  311|      0|  // Each cached IID token that is missing an APNSInfo, or has an APNSInfo associated should be
  312|      0|  // checked and invalidated if needed.
  313|      0|  FIRInstanceIDAPNSInfo *APNSInfo = [[FIRInstanceIDAPNSInfo alloc] initWithDeviceToken:deviceToken
  314|      0|                                                                             isSandbox:isSandbox];
  315|      0|  if ([self.currentAPNSInfo isEqualToAPNSInfo:APNSInfo]) {
  316|      0|    return @[];
  317|      0|  }
  318|      0|  self.currentAPNSInfo = APNSInfo;
  319|      0|
  320|      0|  NSArray<FIRInstanceIDTokenInfo *> *tokenInfos = [self.instanceIDStore cachedTokenInfos];
  321|      0|  NSMutableArray<FIRInstanceIDTokenInfo *> *tokenInfosToDelete =
  322|      0|      [NSMutableArray arrayWithCapacity:tokenInfos.count];
  323|      0|  for (FIRInstanceIDTokenInfo *cachedTokenInfo in tokenInfos) {
  324|      0|    // Check if the cached APNSInfo is nil, or if it is an old APNSInfo.
  325|      0|    if (!cachedTokenInfo.APNSInfo ||
  326|      0|        ![cachedTokenInfo.APNSInfo isEqualToAPNSInfo:self.currentAPNSInfo]) {
  327|      0|      // Mark for invalidation.
  328|      0|      [tokenInfosToDelete addObject:cachedTokenInfo];
  329|      0|    }
  330|      0|  }
  331|      0|  for (FIRInstanceIDTokenInfo *tokenInfoToDelete in tokenInfosToDelete) {
  332|      0|    FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenManagerAPNSChangedTokenInvalidated,
  333|      0|                             @"Invalidating cached token for %@ (%@) due to APNs token change.",
  334|      0|                             tokenInfoToDelete.authorizedEntity, tokenInfoToDelete.scope);
  335|      0|    [self.instanceIDStore removeCachedTokenWithAuthorizedEntity:tokenInfoToDelete.authorizedEntity
  336|      0|                                                          scope:tokenInfoToDelete.scope];
  337|      0|  }
  338|      0|  return tokenInfosToDelete;
  339|      0|}
  340|       |
  341|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDTokenOperation.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDTokenOperation.h"
   18|       |
   19|       |#import "FIRInstanceIDCheckinPreferences.h"
   20|       |#import "FIRInstanceIDDefines.h"
   21|       |#import "FIRInstanceIDKeyPair.h"
   22|       |#import "FIRInstanceIDKeyPairUtilities.h"
   23|       |#import "FIRInstanceIDLogger.h"
   24|       |#import "FIRInstanceIDURLQueryItem.h"
   25|       |#import "FIRInstanceIDUtilities.h"
   26|       |#import "NSError+FIRInstanceID.h"
   27|       |
   28|       |static const NSInteger kFIRInstanceIDPlatformVersionIOS = 2;
   29|       |
   30|       |static NSString *const kFIRInstanceIDParamInstanceID = @"appid";
   31|       |// Scope parameter that defines the service using the token
   32|       |static NSString *const kFIRInstanceIDParamScope = @"X-scope";
   33|       |// Defines the SDK version
   34|       |static NSString *const kFIRInstanceIDParamFCMLibVersion = @"X-cliv";
   35|       |
   36|       |@interface FIRInstanceIDTokenOperation () {
   37|       |  BOOL _isFinished;
   38|       |  BOOL _isExecuting;
   39|       |}
   40|       |
   41|       |@property(nonatomic, readwrite, strong) FIRInstanceIDCheckinPreferences *checkinPreferences;
   42|       |@property(nonatomic, readwrite, strong) FIRInstanceIDKeyPair *keyPair;
   43|       |
   44|       |@property(atomic, strong) NSURLSessionDataTask *dataTask;
   45|       |@property(readonly, strong)
   46|       |    NSMutableArray<FIRInstanceIDTokenOperationCompletion> *completionHandlers;
   47|       |
   48|       |// For testing only
   49|       |@property(nonatomic, readwrite, copy) FIRInstanceIDURLRequestTestBlock testBlock;
   50|       |
   51|       |@end
   52|       |
   53|       |@implementation FIRInstanceIDTokenOperation
   54|       |
   55|      0|+ (NSURLSession *)sharedURLSession {
   56|      0|  static NSURLSession *tokenOperationSharedSession;
   57|      0|  static dispatch_once_t onceToken;
   58|      0|  dispatch_once(&onceToken, ^{
   59|      0|    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
   60|      0|    config.timeoutIntervalForResource = 60.0f;  // 1 minute
   61|      0|    tokenOperationSharedSession = [NSURLSession sessionWithConfiguration:config];
   62|      0|    tokenOperationSharedSession.sessionDescription = @"com.google.iid.tokens.session";
   63|      0|  });
   64|      0|  return tokenOperationSharedSession;
   65|      0|}
   66|       |
   67|       |- (instancetype)initWithAction:(FIRInstanceIDTokenAction)action
   68|       |           forAuthorizedEntity:(NSString *)authorizedEntity
   69|       |                         scope:(NSString *)scope
   70|       |                       options:(NSDictionary<NSString *, NSString *> *)options
   71|       |            checkinPreferences:(FIRInstanceIDCheckinPreferences *)checkinPreferences
   72|      0|                       keyPair:(FIRInstanceIDKeyPair *)keyPair {
   73|      0|  self = [super init];
   74|      0|  if (self) {
   75|      0|    _action = action;
   76|      0|    _authorizedEntity = [authorizedEntity copy];
   77|      0|    _scope = [scope copy];
   78|      0|    _options = [options copy];
   79|      0|    _checkinPreferences = checkinPreferences;
   80|      0|    _keyPair = keyPair;
   81|      0|    _completionHandlers = [NSMutableArray array];
   82|      0|
   83|      0|    _isExecuting = NO;
   84|      0|    _isFinished = NO;
   85|      0|  }
   86|      0|  return self;
   87|      0|}
   88|       |
   89|      0|- (void)dealloc {
   90|      0|  _testBlock = nil;
   91|      0|  _authorizedEntity = nil;
   92|      0|  _scope = nil;
   93|      0|  _options = nil;
   94|      0|  _checkinPreferences = nil;
   95|      0|  _keyPair = nil;
   96|      0|  [_completionHandlers removeAllObjects];
   97|      0|  _completionHandlers = nil;
   98|      0|}
   99|       |
  100|      0|- (void)addCompletionHandler:(FIRInstanceIDTokenOperationCompletion)handler {
  101|      0|  [self.completionHandlers addObject:handler];
  102|      0|}
  103|       |
  104|      0|- (BOOL)isAsynchronous {
  105|      0|  return YES;
  106|      0|}
  107|       |
  108|      0|- (BOOL)isExecuting {
  109|      0|  return _isExecuting;
  110|      0|}
  111|       |
  112|      0|- (void)setExecuting:(BOOL)executing {
  113|      0|  [self willChangeValueForKey:@"isExecuting"];
  114|      0|  _isExecuting = executing;
  115|      0|  [self didChangeValueForKey:@"isExecuting"];
  116|      0|}
  117|       |
  118|      0|- (BOOL)isFinished {
  119|      0|  return _isFinished;
  120|      0|}
  121|       |
  122|      0|- (void)setFinished:(BOOL)finished {
  123|      0|  [self willChangeValueForKey:@"isFinished"];
  124|      0|  _isFinished = finished;
  125|      0|  [self didChangeValueForKey:@"isFinished"];
  126|      0|}
  127|       |
  128|      0|- (void)start {
  129|      0|  if (self.isCancelled) {
  130|      0|    [self finishWithResult:FIRInstanceIDTokenOperationCancelled token:nil error:nil];
  131|      0|    return;
  132|      0|  }
  133|      0|
  134|      0|  // Quickly validate whether or not the operation has all it needs to begin
  135|      0|  BOOL checkinfoAvailable = [self.checkinPreferences hasCheckinInfo];
  136|      0|  _FIRInstanceIDDevAssert(checkinfoAvailable, @"Cannot fetch token invalid checkin state");
  137|      0|  if (!checkinfoAvailable) {
  138|      0|    FIRInstanceIDErrorCode errorCode = kFIRInstanceIDErrorCodeRegistrarFailedToCheckIn;
  139|      0|    [self finishWithResult:FIRInstanceIDTokenOperationError
  140|      0|                     token:nil
  141|      0|                     error:[NSError errorWithFIRInstanceIDErrorCode:errorCode]];
  142|      0|    return;
  143|      0|  }
  144|      0|
  145|      0|  [self setExecuting:YES];
  146|      0|
  147|      0|  [self performTokenOperation];
  148|      0|}
  149|       |
  150|       |- (void)finishWithResult:(FIRInstanceIDTokenOperationResult)result
  151|       |                   token:(nullable NSString *)token
  152|      0|                   error:(nullable NSError *)error {
  153|      0|  // Add a check to prevent this finish from being called more than once.
  154|      0|  if (self.isFinished) {
  155|      0|    return;
  156|      0|  }
  157|      0|  self.dataTask = nil;
  158|      0|  _result = result;
  159|      0|  // TODO(chliangGoogle): Call these in the main thread?
  160|      0|  for (FIRInstanceIDTokenOperationCompletion completionHandler in self.completionHandlers) {
  161|      0|    completionHandler(result, token, error);
  162|      0|  }
  163|      0|
  164|      0|  [self setExecuting:NO];
  165|      0|  [self setFinished:YES];
  166|      0|}
  167|       |
  168|      0|- (void)cancel {
  169|      0|  [super cancel];
  170|      0|  [self.dataTask cancel];
  171|      0|  [self finishWithResult:FIRInstanceIDTokenOperationCancelled token:nil error:nil];
  172|      0|}
  173|       |
  174|      0|- (void)performTokenOperation {
  175|      0|}
  176|       |
  177|       |#pragma mark - Request Construction
  178|      0|+ (NSMutableURLRequest *)requestWithAuthHeader:(NSString *)authHeaderString {
  179|      0|  NSURL *url = [NSURL URLWithString:FIRInstanceIDRegisterServer()];
  180|      0|  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
  181|      0|
  182|      0|  // Add HTTP headers
  183|      0|  [request setValue:authHeaderString forHTTPHeaderField:@"Authorization"];
  184|      0|  [request setValue:FIRInstanceIDAppIdentifier() forHTTPHeaderField:@"app"];
  185|      0|  request.HTTPMethod = @"POST";
  186|      0|  return request;
  187|      0|}
  188|       |
  189|       |+ (NSMutableArray<FIRInstanceIDURLQueryItem *> *)standardQueryItemsWithDeviceID:(NSString *)deviceID
  190|      0|                                                                          scope:(NSString *)scope {
  191|      0|  NSMutableArray<FIRInstanceIDURLQueryItem *> *queryItems = [NSMutableArray arrayWithCapacity:8];
  192|      0|
  193|      0|  // E.g. X-osv=10.2.1
  194|      0|  NSString *systemVersion = FIRInstanceIDOperatingSystemVersion();
  195|      0|  [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"X-osv" value:systemVersion]];
  196|      0|  // E.g. device=
  197|      0|  if (deviceID) {
  198|      0|    [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"device" value:deviceID]];
  199|      0|  }
  200|      0|  // E.g. X-scope=fcm
  201|      0|  if (scope) {
  202|      0|    [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:kFIRInstanceIDParamScope
  203|      0|                                                                 value:scope]];
  204|      0|  }
  205|      0|  // E.g. plat=2
  206|      0|  NSString *platform = [NSString stringWithFormat:@"%ld", (long)kFIRInstanceIDPlatformVersionIOS];
  207|      0|  [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"plat" value:platform]];
  208|      0|  // E.g. app=com.myapp.foo
  209|      0|  NSString *appIdentifier = FIRInstanceIDAppIdentifier();
  210|      0|  [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"app" value:appIdentifier]];
  211|      0|  // E.g. app_ver=1.5
  212|      0|  NSString *appVersion = FIRInstanceIDCurrentAppVersion();
  213|      0|  [queryItems addObject:[FIRInstanceIDURLQueryItem queryItemWithName:@"app_ver" value:appVersion]];
  214|      0|  // E.g. X-cliv=fiid-1.2.3
  215|      0|  NSString *fcmLibraryVersion =
  216|      0|      [NSString stringWithFormat:@"fiid-%@", FIRInstanceIDCurrentGCMVersion()];
  217|      0|  if (fcmLibraryVersion.length) {
  218|      0|    FIRInstanceIDURLQueryItem *gcmLibVersion =
  219|      0|        [FIRInstanceIDURLQueryItem queryItemWithName:kFIRInstanceIDParamFCMLibVersion
  220|      0|                                               value:fcmLibraryVersion];
  221|      0|    [queryItems addObject:gcmLibVersion];
  222|      0|  }
  223|      0|
  224|      0|  return queryItems;
  225|      0|}
  226|       |
  227|      0|- (NSArray<FIRInstanceIDURLQueryItem *> *)queryItemsWithKeyPair:(FIRInstanceIDKeyPair *)keyPair {
  228|      0|  NSMutableArray<FIRInstanceIDURLQueryItem *> *items = [NSMutableArray arrayWithCapacity:3];
  229|      0|  // appid=
  230|      0|  NSString *instanceID = FIRInstanceIDAppIdentity(keyPair);
  231|      0|  [items addObject:[FIRInstanceIDURLQueryItem queryItemWithName:kFIRInstanceIDParamInstanceID
  232|      0|                                                          value:instanceID]];
  233|      0|  return items;
  234|      0|}
  235|       |
  236|       |#pragma mark - HTTP Header
  237|       |
  238|      0|+ (NSString *)HTTPAuthHeaderFromCheckin:(FIRInstanceIDCheckinPreferences *)checkin {
  239|      0|  NSString *deviceID = checkin.deviceID;
  240|      0|  NSString *secret = checkin.secretToken;
  241|      0|  return [NSString stringWithFormat:@"AidLogin %@:%@", deviceID, secret];
  242|      0|}
  243|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDTokenStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDTokenStore.h"
   18|       |
   19|       |#import "FIRInstanceIDAuthKeyChain.h"
   20|       |#import "FIRInstanceIDConstants.h"
   21|       |#import "FIRInstanceIDLogger.h"
   22|       |#import "FIRInstanceIDTokenInfo.h"
   23|       |#import "FIRInstanceIDUtilities.h"
   24|       |
   25|       |static NSString *const kFIRInstanceIDTokenKeychainId = @"com.google.iid-tokens";
   26|       |
   27|       |@interface FIRInstanceIDTokenStore ()
   28|       |
   29|       |@property(nonatomic, readwrite, strong) FIRInstanceIDAuthKeychain *keychain;
   30|       |
   31|       |@end
   32|       |
   33|       |@implementation FIRInstanceIDTokenStore
   34|       |
   35|     14|+ (instancetype)defaultStore {
   36|     14|  FIRInstanceIDAuthKeychain *tokenKeychain =
   37|     14|      [[FIRInstanceIDAuthKeychain alloc] initWithIdentifier:kFIRInstanceIDTokenKeychainId];
   38|     14|  return [[FIRInstanceIDTokenStore alloc] initWithKeychain:tokenKeychain];
   39|     14|}
   40|       |
   41|     14|- (instancetype)initWithKeychain:(FIRInstanceIDAuthKeychain *)keychain {
   42|     14|  self = [super init];
   43|     14|  if (self) {
   44|     14|    _keychain = keychain;
   45|     14|  }
   46|     14|  return self;
   47|     14|}
   48|       |
   49|       |#pragma mark - Get
   50|       |
   51|     14|+ (NSString *)serviceKeyForAuthorizedEntity:(NSString *)authorizedEntity scope:(NSString *)scope {
   52|     14|  return [NSString stringWithFormat:@"%@:%@", authorizedEntity, scope];
   53|     14|}
   54|       |
   55|       |- (nullable FIRInstanceIDTokenInfo *)tokenInfoWithAuthorizedEntity:(NSString *)authorizedEntity
   56|     14|                                                             scope:(NSString *)scope {
   57|     14|  NSString *account = FIRInstanceIDAppIdentifier();
   58|     14|  NSString *service = [[self class] serviceKeyForAuthorizedEntity:authorizedEntity scope:scope];
   59|     14|  NSData *item = [self.keychain dataForService:service account:account];
   60|     14|  if (!item) {
   61|     14|    return nil;
   62|     14|  }
   63|      0|  // Token infos created from legacy storage don't have appVersion, firebaseAppID, or APNSInfo.
   64|      0|  FIRInstanceIDTokenInfo *tokenInfo = [[self class] tokenInfoFromKeychainItem:item];
   65|      0|  return tokenInfo;
   66|      0|}
   67|       |
   68|      0|- (NSArray<FIRInstanceIDTokenInfo *> *)cachedTokenInfos {
   69|      0|  NSString *account = FIRInstanceIDAppIdentifier();
   70|      0|  NSArray<NSData *> *items =
   71|      0|      [self.keychain itemsMatchingService:kFIRInstanceIDKeychainWildcardIdentifier account:account];
   72|      0|  NSMutableArray<FIRInstanceIDTokenInfo *> *tokenInfos =
   73|      0|      [NSMutableArray arrayWithCapacity:items.count];
   74|      0|  for (NSData *item in items) {
   75|      0|    FIRInstanceIDTokenInfo *tokenInfo = [[self class] tokenInfoFromKeychainItem:item];
   76|      0|    if (tokenInfo) {
   77|      0|      [tokenInfos addObject:tokenInfo];
   78|      0|    }
   79|      0|  }
   80|      0|  return tokenInfos;
   81|      0|}
   82|       |
   83|      0|+ (nullable FIRInstanceIDTokenInfo *)tokenInfoFromKeychainItem:(NSData *)item {
   84|      0|  // Check if it is saved as an archived FIRInstanceIDTokenInfo, otherwise return nil.
   85|      0|  FIRInstanceIDTokenInfo *tokenInfo = nil;
   86|      0|  // NOTE: Passing in nil to unarchiveObjectWithData will result in an iOS error logged
   87|      0|  // in the console on iOS 10 and below. Avoid by checking item.data's existence.
   88|      0|  if (item) {
   89|      0|    @try {
   90|      0|      tokenInfo = [NSKeyedUnarchiver unarchiveObjectWithData:item];
   91|      0|    } @catch (NSException *exception) {
   92|      0|      FIRInstanceIDLoggerDebug(kFIRInstanceIDMessageCodeTokenStoreExceptionUnarchivingTokenInfo,
   93|      0|                               @"Unable to parse token info from Keychain item; item was in an "
   94|      0|                               @"invalid format");
   95|      0|      tokenInfo = nil;
   96|      0|    } @finally {
   97|      0|    }
   98|      0|  }
   99|      0|  return tokenInfo;
  100|      0|}
  101|       |
  102|       |#pragma mark - Save
  103|       |// Token Infos will be saved under these Keychain keys:
  104|       |// Account: <Main App Bundle ID> (e.g. com.mycompany.myapp)
  105|       |// Service: <Sender ID>:<Scope> (e.g. 1234567890:*)
  106|       |- (void)saveTokenInfo:(FIRInstanceIDTokenInfo *)tokenInfo
  107|      0|              handler:(void (^)(NSError *))handler {  // Keep the cachetime up-to-date.
  108|      0|  tokenInfo.cacheTime = [NSDate date];
  109|      0|  // Always write to the Keychain, so that the cacheTime is up-to-date.
  110|      0|  NSData *tokenInfoData = [NSKeyedArchiver archivedDataWithRootObject:tokenInfo];
  111|      0|  NSString *account = FIRInstanceIDAppIdentifier();
  112|      0|  NSString *service = [[self class] serviceKeyForAuthorizedEntity:tokenInfo.authorizedEntity
  113|      0|                                                            scope:tokenInfo.scope];
  114|      0|  [self.keychain setData:tokenInfoData
  115|      0|              forService:service
  116|      0|           accessibility:NULL
  117|      0|                 account:account
  118|      0|                 handler:handler];
  119|      0|}
  120|       |
  121|       |#pragma mark - Delete
  122|       |
  123|       |- (void)removeTokenWithAuthorizedEntity:(nonnull NSString *)authorizedEntity
  124|      0|                                  scope:(nonnull NSString *)scope {
  125|      0|  NSString *account = FIRInstanceIDAppIdentifier();
  126|      0|  NSString *service = [[self class] serviceKeyForAuthorizedEntity:authorizedEntity scope:scope];
  127|      0|  [self.keychain removeItemsMatchingService:service account:account handler:nil];
  128|      0|}
  129|       |
  130|      1|- (void)removeAllTokensWithHandler:(void (^)(NSError *error))handler {
  131|      1|  NSString *account = FIRInstanceIDAppIdentifier();
  132|      1|  [self.keychain removeItemsMatchingService:kFIRInstanceIDKeychainWildcardIdentifier
  133|      1|                                    account:account
  134|      1|                                    handler:handler];
  135|      1|}
  136|       |
  137|       |@end

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDURLQueryItem.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDURLQueryItem.h"
   18|       |
   19|       |@implementation FIRInstanceIDURLQueryItem
   20|       |
   21|      0|+ (instancetype)queryItemWithName:(NSString *)name value:(NSString *)value {
   22|      0|  return [[[self class] alloc] initWithName:name value:value];
   23|      0|}
   24|       |
   25|      0|- (instancetype)initWithName:(NSString *)name value:(NSString *)value {
   26|      0|  self = [super init];
   27|      0|  if (self) {
   28|      0|    _name = [name copy];
   29|      0|    _value = [value copy];
   30|      0|  }
   31|      0|  return self;
   32|      0|}
   33|       |@end
   34|       |
   35|      0|NSString *FIRInstanceIDQueryFromQueryItems(NSArray<FIRInstanceIDURLQueryItem *> *queryItems) {
   36|      0|  if ([NSURLQueryItem class]) {
   37|      0|    // We are iOS 8.0 and above. Convert to NSURLQueryItems and get query that way
   38|      0|    // to take advantage of any automatic encoding
   39|      0|    NSMutableArray<NSURLQueryItem *> *urlItems =
   40|      0|        [NSMutableArray arrayWithCapacity:queryItems.count];
   41|      0|    for (FIRInstanceIDURLQueryItem *queryItem in queryItems) {
   42|      0|      [urlItems addObject:[NSURLQueryItem queryItemWithName:queryItem.name value:queryItem.value]];
   43|      0|    }
   44|      0|    NSURLComponents *components = [[NSURLComponents alloc] init];
   45|      0|    components.queryItems = urlItems;
   46|      0|    return components.query;
   47|      0|  } else {
   48|      0|    // We are on iOS 7.0. Manually create the query string
   49|      0|    NSMutableArray<NSString *> *pairs = [NSMutableArray arrayWithCapacity:queryItems.count];
   50|      0|    for (FIRInstanceIDURLQueryItem *queryItem in queryItems) {
   51|      0|      [pairs addObject:[NSString stringWithFormat:@"%@=%@", queryItem.name, queryItem.value]];
   52|      0|    }
   53|      0|    return [pairs componentsJoinedByString:@"&"];
   54|      0|  }
   55|      0|}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDUtilities.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDUtilities.h"
   18|       |
   19|       |#import <UIKit/UIKit.h>
   20|       |#import <sys/utsname.h>
   21|       |
   22|       |#import <FirebaseCore/FIROptions.h>
   23|       |#import <GoogleUtilities/GULUserDefaults.h>
   24|       |#import "FIRInstanceID.h"
   25|       |#import "FIRInstanceIDConstants.h"
   26|       |#import "FIRInstanceIDDefines.h"
   27|       |#import "FIRInstanceIDLogger.h"
   28|       |
   29|       |// Convert the macro to a string
   30|       |#define STR_EXPAND(x) #x
   31|       |#define STR(x) STR_EXPAND(x)
   32|       |
   33|       |static NSString *const kFIRInstanceIDAPNSSandboxPrefix = @"s_";
   34|       |static NSString *const kFIRInstanceIDAPNSProdPrefix = @"p_";
   35|       |
   36|       |/// FIRMessaging Class that responds to the FIRMessaging SDK version selector.
   37|       |/// Verify at runtime if the class exists and implements the required method.
   38|       |NSString *const kFIRInstanceIDFCMSDKClassString = @"FIRMessaging";
   39|       |
   40|       |/// FIRMessaging selector that returns the current FIRMessaging library version.
   41|       |static NSString *const kFIRInstanceIDFCMSDKVersionSelectorString = @"FIRMessagingSDKVersion";
   42|       |
   43|       |/// FIRMessaging selector that returns the current device locale.
   44|       |static NSString *const kFIRInstanceIDFCMSDKLocaleSelectorString = @"FIRMessagingSDKCurrentLocale";
   45|       |
   46|       |NSString *const kFIRInstanceIDUserDefaultsKeyLocale =
   47|       |    @"com.firebase.instanceid.user_defaults.locale";  // locale key stored in GULUserDefaults
   48|       |
   49|       |/// Static values which will be populated once retrieved using
   50|       |/// |FIRInstanceIDRetrieveEnvironmentInfoFromFirebaseCore|.
   51|       |static NSString *operatingSystemVersion;
   52|       |static NSString *hardwareDeviceModel;
   53|       |
   54|       |#pragma mark - URL Helpers
   55|       |
   56|      0|NSString *FIRInstanceIDRegisterServer() {
   57|      0|  return @"https://fcmtoken.googleapis.com/register";
   58|      0|}
   59|       |
   60|       |#pragma mark - Time
   61|       |
   62|      1|int64_t FIRInstanceIDCurrentTimestampInSeconds() {
   63|      1|  return (int64_t)[[NSDate date] timeIntervalSince1970];
   64|      1|}
   65|       |
   66|      0|int64_t FIRInstanceIDCurrentTimestampInMilliseconds() {
   67|      0|  return (int64_t)(FIRInstanceIDCurrentTimestampInSeconds() * 1000.0);
   68|      0|}
   69|       |
   70|       |#pragma mark - App Info
   71|       |
   72|      0|NSString *FIRInstanceIDCurrentAppVersion() {
   73|      0|  NSString *version = [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"];
   74|      0|  if (![version length]) {
   75|      0|    return @"";
   76|      0|  }
   77|      0|  return version;
   78|      0|}
   79|       |
   80|     57|NSString *FIRInstanceIDAppIdentifier() {
   81|     57|  NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
   82|     57|  if (!bundleIdentifier.length) {
   83|      0|    FIRInstanceIDLoggerError(kFIRInstanceIDMessageCodeUtilitiesMissingBundleIdentifier,
   84|      0|                             @"The mainBundle's bundleIdentifier returned '%@'. Bundle identifier "
   85|      0|                             @"expected to be non-empty.",
   86|      0|                             bundleIdentifier);
   87|      0|    return @"";
   88|      0|  }
   89|     57|  return bundleIdentifier;
   90|     57|}
   91|       |
   92|      0|NSString *FIRInstanceIDFirebaseAppID() {
   93|      0|  return [FIROptions defaultOptions].googleAppID;
   94|      0|}
   95|       |
   96|       |#pragma mark - Device Info
   97|       |// Get the device model from Firebase Core's App Environment Util
   98|      0|NSString *FIRInstanceIDDeviceModel() {
   99|      0|  static dispatch_once_t once;
  100|      0|  dispatch_once(&once, ^{
  101|      0|    struct utsname systemInfo;
  102|      0|    if (uname(&systemInfo) == 0) {
  103|      0|      hardwareDeviceModel = [NSString stringWithUTF8String:systemInfo.machine];
  104|      0|    }
  105|      0|  });
  106|      0|  return hardwareDeviceModel;
  107|      0|}
  108|       |
  109|       |// Get the system version from Firebase Core's App Environment Util
  110|      0|NSString *FIRInstanceIDOperatingSystemVersion() {
  111|      0|#if TARGET_OS_IOS || TARGET_OS_TV
  112|      0|  return [UIDevice currentDevice].systemVersion;
  113|       |#elif TARGET_OS_OSX
  114|       |  return [NSProcessInfo processInfo].operatingSystemVersionString;
  115|       |#endif
  116|       |}
  117|       |
  118|      0|BOOL FIRInstanceIDHasLocaleChanged() {
  119|      0|  NSString *lastLocale =
  120|      0|      [[GULUserDefaults standardUserDefaults] stringForKey:kFIRInstanceIDUserDefaultsKeyLocale];
  121|      0|  NSString *currentLocale = FIRInstanceIDCurrentLocale();
  122|      0|  if (lastLocale) {
  123|      0|    if ([currentLocale isEqualToString:lastLocale]) {
  124|      0|      return NO;
  125|      0|    }
  126|      0|  }
  127|      0|  return YES;
  128|      0|}
  129|       |
  130|       |#pragma mark - Helpers
  131|       |
  132|      0|BOOL FIRInstanceIDIsValidGCMScope(NSString *scope) {
  133|      0|  return [scope compare:kFIRInstanceIDScopeFirebaseMessaging
  134|      0|                options:NSCaseInsensitiveSearch] == NSOrderedSame;
  135|      0|}
  136|       |
  137|      0|NSString *FIRInstanceIDStringForAPNSDeviceToken(NSData *deviceToken) {
  138|      0|  NSMutableString *APNSToken = [NSMutableString string];
  139|      0|  unsigned char *bytes = (unsigned char *)[deviceToken bytes];
  140|      0|  for (int i = 0; i < (int)deviceToken.length; i++) {
  141|      0|    [APNSToken appendFormat:@"%02x", bytes[i]];
  142|      0|  }
  143|      0|  return APNSToken;
  144|      0|}
  145|       |
  146|      0|NSString *FIRInstanceIDAPNSTupleStringForTokenAndServerType(NSData *deviceToken, BOOL isSandbox) {
  147|      0|  if (deviceToken == nil) {
  148|      0|    // A nil deviceToken leads to an invalid tuple string, so return nil.
  149|      0|    return nil;
  150|      0|  }
  151|      0|  NSString *prefix = isSandbox ? kFIRInstanceIDAPNSSandboxPrefix : kFIRInstanceIDAPNSProdPrefix;
  152|      0|  NSString *APNSString = FIRInstanceIDStringForAPNSDeviceToken(deviceToken);
  153|      0|  NSString *APNSTupleString = [NSString stringWithFormat:@"%@%@", prefix, APNSString];
  154|      0|
  155|      0|  return APNSTupleString;
  156|      0|}
  157|       |
  158|       |#pragma mark - GCM Helpers
  159|       |
  160|      0|NSString *FIRInstanceIDCurrentGCMVersion() {
  161|      0|  Class versionClass = NSClassFromString(kFIRInstanceIDFCMSDKClassString);
  162|      0|  SEL versionSelector = NSSelectorFromString(kFIRInstanceIDFCMSDKVersionSelectorString);
  163|      0|  if ([versionClass respondsToSelector:versionSelector]) {
  164|      0|    IMP getVersionIMP = [versionClass methodForSelector:versionSelector];
  165|      0|    NSString *(*getVersion)(id, SEL) = (void *)getVersionIMP;
  166|      0|    return getVersion(versionClass, versionSelector);
  167|      0|  }
  168|      0|  return nil;
  169|      0|}
  170|       |
  171|      0|NSString *FIRInstanceIDCurrentLocale() {
  172|      0|  Class localeClass = NSClassFromString(kFIRInstanceIDFCMSDKClassString);
  173|      0|  SEL localeSelector = NSSelectorFromString(kFIRInstanceIDFCMSDKLocaleSelectorString);
  174|      0|
  175|      0|  if ([localeClass respondsToSelector:localeSelector]) {
  176|      0|    IMP getLocaleIMP = [localeClass methodForSelector:localeSelector];
  177|      0|    NSString *(*getLocale)(id, SEL) = (void *)getLocaleIMP;
  178|      0|    NSString *fcmLocale = getLocale(localeClass, localeSelector);
  179|      0|    if (fcmLocale != nil) {
  180|      0|      return fcmLocale;
  181|      0|    }
  182|      0|  }
  183|      0|
  184|      0|  NSString *systemLanguage = [[NSLocale preferredLanguages] firstObject];
  185|      0|  if (systemLanguage != nil) {
  186|      0|    return systemLanguage;
  187|      0|  }
  188|      0|
  189|      0|  if (@available(iOS 10.0, *)) {
  190|      0|    return [NSLocale currentLocale].languageCode;
  191|      0|  } else {
  192|      0|    return nil;
  193|      0|  }
  194|      0|}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/FIRInstanceIDVersionUtilities.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstanceIDVersionUtilities.h"
   18|       |
   19|       |#import "FIRInstanceIDDefines.h"
   20|       |
   21|       |// Convert the macro to a string
   22|     14|#define STR(x) STR_EXPAND(x)
   23|     14|#define STR_EXPAND(x) #x
   24|       |
   25|       |static NSString *const kSemanticVersioningSeparator = @".";
   26|       |static NSString *const kBetaVersionPrefix = @"-beta";
   27|       |
   28|       |static NSString *libraryVersion;
   29|       |
   30|       |static int majorVersion;
   31|       |static int minorVersion;
   32|       |static int patchVersion;
   33|       |static int betaVersion;
   34|       |
   35|     14|void FIRInstanceIDParseCurrentLibraryVersion() {
   36|     14|  static NSArray *allVersions;
   37|     14|  static dispatch_once_t onceToken;
   38|     14|  dispatch_once(&onceToken, ^{
   39|     14|    NSMutableString *daylightVersion =
   40|     14|        [NSMutableString stringWithUTF8String:STR(FIRInstanceID_LIB_VERSION)];
   41|     14|    // Parse versions
   42|     14|    // major, minor, patch[-beta#]
   43|     14|    allVersions = [daylightVersion componentsSeparatedByString:kSemanticVersioningSeparator];
   44|     14|    _FIRInstanceIDDevAssert(allVersions.count == 3, @"Invalid versioning of FIRInstanceID library");
   45|     14|    if (allVersions.count == 3) {
   46|     14|      majorVersion = [allVersions[0] intValue];
   47|     14|      minorVersion = [allVersions[1] intValue];
   48|     14|
   49|     14|      // Parse patch and beta versions
   50|     14|      NSArray *patchAndBetaVersion =
   51|     14|          [allVersions[2] componentsSeparatedByString:kBetaVersionPrefix];
   52|     14|      _FIRInstanceIDDevAssert(patchAndBetaVersion.count <= 2,
   53|     14|                              @"Invalid versioning of FIRInstanceID library");
   54|     14|
   55|     14|      if (patchAndBetaVersion.count == 2) {
   56|      0|        patchVersion = [patchAndBetaVersion[0] intValue];
   57|      0|        betaVersion = [patchAndBetaVersion[1] intValue];
   58|     14|      } else if (patchAndBetaVersion.count == 1) {
   59|     14|        patchVersion = [patchAndBetaVersion[0] intValue];
   60|     14|      }
   61|     14|    }
   62|     14|
   63|     14|    // Copy library version
   64|     14|    libraryVersion = [daylightVersion copy];
   65|     14|  });
   66|     14|}
   67|       |
   68|     14|NSString *FIRInstanceIDCurrentLibraryVersion() {
   69|     14|  FIRInstanceIDParseCurrentLibraryVersion();
   70|     14|  return libraryVersion;
   71|     14|}
   72|       |
   73|      0|int FIRInstanceIDCurrentLibraryVersionMajor() {
   74|      0|  FIRInstanceIDParseCurrentLibraryVersion();
   75|      0|  return majorVersion;
   76|      0|}
   77|       |
   78|      0|int FIRInstanceIDCurrentLibraryVersionMinor() {
   79|      0|  FIRInstanceIDParseCurrentLibraryVersion();
   80|      0|  return minorVersion;
   81|      0|}
   82|       |
   83|      0|int FIRInstanceIDCurrentLibraryVersionPatch() {
   84|      0|  FIRInstanceIDParseCurrentLibraryVersion();
   85|      0|  return patchVersion;
   86|      0|}
   87|       |
   88|      0|BOOL FIRInstanceIDCurrentLibraryVersionIsBeta() {
   89|      0|  FIRInstanceIDParseCurrentLibraryVersion();
   90|      0|  return betaVersion > 0;
   91|      0|}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/FirebaseInstanceID/Firebase/InstanceID/NSError+FIRInstanceID.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "NSError+FIRInstanceID.h"
   18|       |
   19|       |NSString *const kFIRInstanceIDDomain = @"com.firebase.iid";
   20|       |
   21|       |@implementation NSError (FIRInstanceID)
   22|       |
   23|      0|- (FIRInstanceIDErrorCode)instanceIDErrorCode {
   24|      0|  return (FIRInstanceIDErrorCode)self.code;
   25|      0|}
   26|       |
   27|     14|+ (NSError *)errorWithFIRInstanceIDErrorCode:(FIRInstanceIDErrorCode)errorCode {
   28|     14|  return [NSError errorWithFIRInstanceIDErrorCode:errorCode userInfo:nil];
   29|     14|}
   30|       |
   31|       |+ (NSError *)errorWithFIRInstanceIDErrorCode:(FIRInstanceIDErrorCode)errorCode
   32|     14|                                    userInfo:(NSDictionary *)userInfo {
   33|     14|  return [NSError errorWithDomain:kFIRInstanceIDDomain code:errorCode userInfo:userInfo];
   34|     14|}
   35|       |
   36|      0|+ (NSError *)FIRInstanceIDErrorMissingCheckin {
   37|      0|  NSDictionary *userInfo = @{@"msg" : @"Missing device credentials. Retry later."};
   38|      0|
   39|      0|  return [NSError errorWithDomain:kFIRInstanceIDDomain
   40|      0|                             code:kFIRInstanceIDErrorCodeMissingDeviceID
   41|      0|                         userInfo:userInfo];
   42|      0|}
   43|       |
   44|       |@end

