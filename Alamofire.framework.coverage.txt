/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/AFError.swift:
    1|       |//
    2|       |//  AFError.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// `AFError` is the error type returned by Alamofire. It encompasses a few different types of errors, each with
   28|       |/// their own associated reasons.
   29|       |///
   30|       |/// - invalidURL:                  Returned when a `URLConvertible` type fails to create a valid `URL`.
   31|       |/// - parameterEncodingFailed:     Returned when a parameter encoding object throws an error during the encoding process.
   32|       |/// - multipartEncodingFailed:     Returned when some step in the multipart encoding process fails.
   33|       |/// - responseValidationFailed:    Returned when a `validate()` call fails.
   34|       |/// - responseSerializationFailed: Returned when a response serializer encounters an error in the serialization process.
   35|       |public enum AFError: Error {
   36|       |    /// The underlying reason the parameter encoding error occurred.
   37|       |    ///
   38|       |    /// - missingURL:                 The URL request did not have a URL to encode.
   39|       |    /// - jsonEncodingFailed:         JSON serialization failed with an underlying system error during the
   40|       |    ///                               encoding process.
   41|       |    /// - propertyListEncodingFailed: Property list serialization failed with an underlying system error during
   42|       |    ///                               encoding process.
   43|       |    public enum ParameterEncodingFailureReason {
   44|       |        case missingURL
   45|       |        case jsonEncodingFailed(error: Error)
   46|       |        case propertyListEncodingFailed(error: Error)
   47|       |    }
   48|       |
   49|       |    /// The underlying reason the multipart encoding error occurred.
   50|       |    ///
   51|       |    /// - bodyPartURLInvalid:                   The `fileURL` provided for reading an encodable body part isn't a
   52|       |    ///                                         file URL.
   53|       |    /// - bodyPartFilenameInvalid:              The filename of the `fileURL` provided has either an empty
   54|       |    ///                                         `lastPathComponent` or `pathExtension.
   55|       |    /// - bodyPartFileNotReachable:             The file at the `fileURL` provided was not reachable.
   56|       |    /// - bodyPartFileNotReachableWithError:    Attempting to check the reachability of the `fileURL` provided threw
   57|       |    ///                                         an error.
   58|       |    /// - bodyPartFileIsDirectory:              The file at the `fileURL` provided is actually a directory.
   59|       |    /// - bodyPartFileSizeNotAvailable:         The size of the file at the `fileURL` provided was not returned by
   60|       |    ///                                         the system.
   61|       |    /// - bodyPartFileSizeQueryFailedWithError: The attempt to find the size of the file at the `fileURL` provided
   62|       |    ///                                         threw an error.
   63|       |    /// - bodyPartInputStreamCreationFailed:    An `InputStream` could not be created for the provided `fileURL`.
   64|       |    /// - outputStreamCreationFailed:           An `OutputStream` could not be created when attempting to write the
   65|       |    ///                                         encoded data to disk.
   66|       |    /// - outputStreamFileAlreadyExists:        The encoded body data could not be writtent disk because a file
   67|       |    ///                                         already exists at the provided `fileURL`.
   68|       |    /// - outputStreamURLInvalid:               The `fileURL` provided for writing the encoded body data to disk is
   69|       |    ///                                         not a file URL.
   70|       |    /// - outputStreamWriteFailed:              The attempt to write the encoded body data to disk failed with an
   71|       |    ///                                         underlying error.
   72|       |    /// - inputStreamReadFailed:                The attempt to read an encoded body part `InputStream` failed with
   73|       |    ///                                         underlying system error.
   74|       |    public enum MultipartEncodingFailureReason {
   75|       |        case bodyPartURLInvalid(url: URL)
   76|       |        case bodyPartFilenameInvalid(in: URL)
   77|       |        case bodyPartFileNotReachable(at: URL)
   78|       |        case bodyPartFileNotReachableWithError(atURL: URL, error: Error)
   79|       |        case bodyPartFileIsDirectory(at: URL)
   80|       |        case bodyPartFileSizeNotAvailable(at: URL)
   81|       |        case bodyPartFileSizeQueryFailedWithError(forURL: URL, error: Error)
   82|       |        case bodyPartInputStreamCreationFailed(for: URL)
   83|       |
   84|       |        case outputStreamCreationFailed(for: URL)
   85|       |        case outputStreamFileAlreadyExists(at: URL)
   86|       |        case outputStreamURLInvalid(url: URL)
   87|       |        case outputStreamWriteFailed(error: Error)
   88|       |
   89|       |        case inputStreamReadFailed(error: Error)
   90|       |    }
   91|       |
   92|       |    /// The underlying reason the response validation error occurred.
   93|       |    ///
   94|       |    /// - dataFileNil:             The data file containing the server response did not exist.
   95|       |    /// - dataFileReadFailed:      The data file containing the server response could not be read.
   96|       |    /// - missingContentType:      The response did not contain a `Content-Type` and the `acceptableContentTypes`
   97|       |    ///                            provided did not contain wildcard type.
   98|       |    /// - unacceptableContentType: The response `Content-Type` did not match any type in the provided
   99|       |    ///                            `acceptableContentTypes`.
  100|       |    /// - unacceptableStatusCode:  The response status code was not acceptable.
  101|       |    public enum ResponseValidationFailureReason {
  102|       |        case dataFileNil
  103|       |        case dataFileReadFailed(at: URL)
  104|       |        case missingContentType(acceptableContentTypes: [String])
  105|       |        case unacceptableContentType(acceptableContentTypes: [String], responseContentType: String)
  106|       |        case unacceptableStatusCode(code: Int)
  107|       |    }
  108|       |
  109|       |    /// The underlying reason the response serialization error occurred.
  110|       |    ///
  111|       |    /// - inputDataNil:                    The server response contained no data.
  112|       |    /// - inputDataNilOrZeroLength:        The server response contained no data or the data was zero length.
  113|       |    /// - inputFileNil:                    The file containing the server response did not exist.
  114|       |    /// - inputFileReadFailed:             The file containing the server response could not be read.
  115|       |    /// - stringSerializationFailed:       String serialization failed using the provided `String.Encoding`.
  116|       |    /// - jsonSerializationFailed:         JSON serialization failed with an underlying system error.
  117|       |    /// - propertyListSerializationFailed: Property list serialization failed with an underlying system error.
  118|       |    public enum ResponseSerializationFailureReason {
  119|       |        case inputDataNil
  120|       |        case inputDataNilOrZeroLength
  121|       |        case inputFileNil
  122|       |        case inputFileReadFailed(at: URL)
  123|       |        case stringSerializationFailed(encoding: String.Encoding)
  124|       |        case jsonSerializationFailed(error: Error)
  125|       |        case propertyListSerializationFailed(error: Error)
  126|       |    }
  127|       |
  128|       |    case invalidURL(url: URLConvertible)
  129|       |    case parameterEncodingFailed(reason: ParameterEncodingFailureReason)
  130|       |    case multipartEncodingFailed(reason: MultipartEncodingFailureReason)
  131|       |    case responseValidationFailed(reason: ResponseValidationFailureReason)
  132|       |    case responseSerializationFailed(reason: ResponseSerializationFailureReason)
  133|       |}
  134|       |
  135|       |// MARK: - Adapt Error
  136|       |
  137|       |struct AdaptError: Error {
  138|       |    let error: Error
  139|       |}
  140|       |
  141|       |extension Error {
  142|     21|    var underlyingAdaptError: Error? { return (self as? AdaptError)?.error }
  143|       |}
  144|       |
  145|       |// MARK: - Error Booleans
  146|       |
  147|       |extension AFError {
  148|       |    /// Returns whether the AFError is an invalid URL error.
  149|      0|    public var isInvalidURLError: Bool {
  150|      0|        if case .invalidURL = self { return true }
  151|      0|        return false
  152|      0|    }
  153|       |
  154|       |    /// Returns whether the AFError is a parameter encoding error. When `true`, the `underlyingError` property will
  155|       |    /// contain the associated value.
  156|      0|    public var isParameterEncodingError: Bool {
  157|      0|        if case .parameterEncodingFailed = self { return true }
  158|      0|        return false
  159|      0|    }
  160|       |
  161|       |    /// Returns whether the AFError is a multipart encoding error. When `true`, the `url` and `underlyingError` properties
  162|       |    /// will contain the associated values.
  163|      0|    public var isMultipartEncodingError: Bool {
  164|      0|        if case .multipartEncodingFailed = self { return true }
  165|      0|        return false
  166|      0|    }
  167|       |
  168|       |    /// Returns whether the `AFError` is a response validation error. When `true`, the `acceptableContentTypes`,
  169|       |    /// `responseContentType`, and `responseCode` properties will contain the associated values.
  170|      0|    public var isResponseValidationError: Bool {
  171|      0|        if case .responseValidationFailed = self { return true }
  172|      0|        return false
  173|      0|    }
  174|       |
  175|       |    /// Returns whether the `AFError` is a response serialization error. When `true`, the `failedStringEncoding` and
  176|       |    /// `underlyingError` properties will contain the associated values.
  177|      0|    public var isResponseSerializationError: Bool {
  178|      0|        if case .responseSerializationFailed = self { return true }
  179|      0|        return false
  180|      0|    }
  181|       |}
  182|       |
  183|       |// MARK: - Convenience Properties
  184|       |
  185|       |extension AFError {
  186|       |    /// The `URLConvertible` associated with the error.
  187|      0|    public var urlConvertible: URLConvertible? {
  188|      0|        switch self {
  189|      0|        case .invalidURL(let url):
  190|      0|            return url
  191|      0|        default:
  192|      0|            return nil
  193|      0|        }
  194|      0|    }
  195|       |
  196|       |    /// The `URL` associated with the error.
  197|      0|    public var url: URL? {
  198|      0|        switch self {
  199|      0|        case .multipartEncodingFailed(let reason):
  200|      0|            return reason.url
  201|      0|        default:
  202|      0|            return nil
  203|      0|        }
  204|      0|    }
  205|       |
  206|       |    /// The `Error` returned by a system framework associated with a `.parameterEncodingFailed`,
  207|       |    /// `.multipartEncodingFailed` or `.responseSerializationFailed` error.
  208|      0|    public var underlyingError: Error? {
  209|      0|        switch self {
  210|      0|        case .parameterEncodingFailed(let reason):
  211|      0|            return reason.underlyingError
  212|      0|        case .multipartEncodingFailed(let reason):
  213|      0|            return reason.underlyingError
  214|      0|        case .responseSerializationFailed(let reason):
  215|      0|            return reason.underlyingError
  216|      0|        default:
  217|      0|            return nil
  218|      0|        }
  219|      0|    }
  220|       |
  221|       |    /// The acceptable `Content-Type`s of a `.responseValidationFailed` error.
  222|      0|    public var acceptableContentTypes: [String]? {
  223|      0|        switch self {
  224|      0|        case .responseValidationFailed(let reason):
  225|      0|            return reason.acceptableContentTypes
  226|      0|        default:
  227|      0|            return nil
  228|      0|        }
  229|      0|    }
  230|       |
  231|       |    /// The response `Content-Type` of a `.responseValidationFailed` error.
  232|      0|    public var responseContentType: String? {
  233|      0|        switch self {
  234|      0|        case .responseValidationFailed(let reason):
  235|      0|            return reason.responseContentType
  236|      0|        default:
  237|      0|            return nil
  238|      0|        }
  239|      0|    }
  240|       |
  241|       |    /// The response code of a `.responseValidationFailed` error.
  242|      0|    public var responseCode: Int? {
  243|      0|        switch self {
  244|      0|        case .responseValidationFailed(let reason):
  245|      0|            return reason.responseCode
  246|      0|        default:
  247|      0|            return nil
  248|      0|        }
  249|      0|    }
  250|       |
  251|       |    /// The `String.Encoding` associated with a failed `.stringResponse()` call.
  252|      0|    public var failedStringEncoding: String.Encoding? {
  253|      0|        switch self {
  254|      0|        case .responseSerializationFailed(let reason):
  255|      0|            return reason.failedStringEncoding
  256|      0|        default:
  257|      0|            return nil
  258|      0|        }
  259|      0|    }
  260|       |}
  261|       |
  262|       |extension AFError.ParameterEncodingFailureReason {
  263|      0|    var underlyingError: Error? {
  264|      0|        switch self {
  265|      0|        case .jsonEncodingFailed(let error), .propertyListEncodingFailed(let error):
  266|      0|            return error
  267|      0|        default:
  268|      0|            return nil
  269|      0|        }
  270|      0|    }
  271|       |}
  272|       |
  273|       |extension AFError.MultipartEncodingFailureReason {
  274|      0|    var url: URL? {
  275|      0|        switch self {
  276|      0|        case .bodyPartURLInvalid(let url), .bodyPartFilenameInvalid(let url), .bodyPartFileNotReachable(let url),
  277|      0|             .bodyPartFileIsDirectory(let url), .bodyPartFileSizeNotAvailable(let url),
  278|      0|             .bodyPartInputStreamCreationFailed(let url), .outputStreamCreationFailed(let url),
  279|      0|             .outputStreamFileAlreadyExists(let url), .outputStreamURLInvalid(let url),
  280|      0|             .bodyPartFileNotReachableWithError(let url, _), .bodyPartFileSizeQueryFailedWithError(let url, _):
  281|      0|            return url
  282|      0|        default:
  283|      0|            return nil
  284|      0|        }
  285|      0|    }
  286|       |
  287|      0|    var underlyingError: Error? {
  288|      0|        switch self {
  289|      0|        case .bodyPartFileNotReachableWithError(_, let error), .bodyPartFileSizeQueryFailedWithError(_, let error),
  290|      0|             .outputStreamWriteFailed(let error), .inputStreamReadFailed(let error):
  291|      0|            return error
  292|      0|        default:
  293|      0|            return nil
  294|      0|        }
  295|      0|    }
  296|       |}
  297|       |
  298|       |extension AFError.ResponseValidationFailureReason {
  299|      0|    var acceptableContentTypes: [String]? {
  300|      0|        switch self {
  301|      0|        case .missingContentType(let types), .unacceptableContentType(let types, _):
  302|      0|            return types
  303|      0|        default:
  304|      0|            return nil
  305|      0|        }
  306|      0|    }
  307|       |
  308|      0|    var responseContentType: String? {
  309|      0|        switch self {
  310|      0|        case .unacceptableContentType(_, let responseType):
  311|      0|            return responseType
  312|      0|        default:
  313|      0|            return nil
  314|      0|        }
  315|      0|    }
  316|       |
  317|      0|    var responseCode: Int? {
  318|      0|        switch self {
  319|      0|        case .unacceptableStatusCode(let code):
  320|      0|            return code
  321|      0|        default:
  322|      0|            return nil
  323|      0|        }
  324|      0|    }
  325|       |}
  326|       |
  327|       |extension AFError.ResponseSerializationFailureReason {
  328|      0|    var failedStringEncoding: String.Encoding? {
  329|      0|        switch self {
  330|      0|        case .stringSerializationFailed(let encoding):
  331|      0|            return encoding
  332|      0|        default:
  333|      0|            return nil
  334|      0|        }
  335|      0|    }
  336|       |
  337|      0|    var underlyingError: Error? {
  338|      0|        switch self {
  339|      0|        case .jsonSerializationFailed(let error), .propertyListSerializationFailed(let error):
  340|      0|            return error
  341|      0|        default:
  342|      0|            return nil
  343|      0|        }
  344|      0|    }
  345|       |}
  346|       |
  347|       |// MARK: - Error Descriptions
  348|       |
  349|       |extension AFError: LocalizedError {
  350|      0|    public var errorDescription: String? {
  351|      0|        switch self {
  352|      0|        case .invalidURL(let url):
  353|      0|            return "URL is not valid: \(url)"
  354|      0|        case .parameterEncodingFailed(let reason):
  355|      0|            return reason.localizedDescription
  356|      0|        case .multipartEncodingFailed(let reason):
  357|      0|            return reason.localizedDescription
  358|      0|        case .responseValidationFailed(let reason):
  359|      0|            return reason.localizedDescription
  360|      0|        case .responseSerializationFailed(let reason):
  361|      0|            return reason.localizedDescription
  362|      0|        }
  363|      0|    }
  364|       |}
  365|       |
  366|       |extension AFError.ParameterEncodingFailureReason {
  367|      0|    var localizedDescription: String {
  368|      0|        switch self {
  369|      0|        case .missingURL:
  370|      0|            return "URL request to encode was missing a URL"
  371|      0|        case .jsonEncodingFailed(let error):
  372|      0|            return "JSON could not be encoded because of error:\n\(error.localizedDescription)"
  373|      0|        case .propertyListEncodingFailed(let error):
  374|      0|            return "PropertyList could not be encoded because of error:\n\(error.localizedDescription)"
  375|      0|        }
  376|      0|    }
  377|       |}
  378|       |
  379|       |extension AFError.MultipartEncodingFailureReason {
  380|      0|    var localizedDescription: String {
  381|      0|        switch self {
  382|      0|        case .bodyPartURLInvalid(let url):
  383|      0|            return "The URL provided is not a file URL: \(url)"
  384|      0|        case .bodyPartFilenameInvalid(let url):
  385|      0|            return "The URL provided does not have a valid filename: \(url)"
  386|      0|        case .bodyPartFileNotReachable(let url):
  387|      0|            return "The URL provided is not reachable: \(url)"
  388|      0|        case .bodyPartFileNotReachableWithError(let url, let error):
  389|      0|            return (
  390|      0|                "The system returned an error while checking the provided URL for " +
  391|      0|                "reachability.\nURL: \(url)\nError: \(error)"
  392|      0|            )
  393|      0|        case .bodyPartFileIsDirectory(let url):
  394|      0|            return "The URL provided is a directory: \(url)"
  395|      0|        case .bodyPartFileSizeNotAvailable(let url):
  396|      0|            return "Could not fetch the file size from the provided URL: \(url)"
  397|      0|        case .bodyPartFileSizeQueryFailedWithError(let url, let error):
  398|      0|            return (
  399|      0|                "The system returned an error while attempting to fetch the file size from the " +
  400|      0|                "provided URL.\nURL: \(url)\nError: \(error)"
  401|      0|            )
  402|      0|        case .bodyPartInputStreamCreationFailed(let url):
  403|      0|            return "Failed to create an InputStream for the provided URL: \(url)"
  404|      0|        case .outputStreamCreationFailed(let url):
  405|      0|            return "Failed to create an OutputStream for URL: \(url)"
  406|      0|        case .outputStreamFileAlreadyExists(let url):
  407|      0|            return "A file already exists at the provided URL: \(url)"
  408|      0|        case .outputStreamURLInvalid(let url):
  409|      0|            return "The provided OutputStream URL is invalid: \(url)"
  410|      0|        case .outputStreamWriteFailed(let error):
  411|      0|            return "OutputStream write failed with error: \(error)"
  412|      0|        case .inputStreamReadFailed(let error):
  413|      0|            return "InputStream read failed with error: \(error)"
  414|      0|        }
  415|      0|    }
  416|       |}
  417|       |
  418|       |extension AFError.ResponseSerializationFailureReason {
  419|      0|    var localizedDescription: String {
  420|      0|        switch self {
  421|      0|        case .inputDataNil:
  422|      0|            return "Response could not be serialized, input data was nil."
  423|      0|        case .inputDataNilOrZeroLength:
  424|      0|            return "Response could not be serialized, input data was nil or zero length."
  425|      0|        case .inputFileNil:
  426|      0|            return "Response could not be serialized, input file was nil."
  427|      0|        case .inputFileReadFailed(let url):
  428|      0|            return "Response could not be serialized, input file could not be read: \(url)."
  429|      0|        case .stringSerializationFailed(let encoding):
  430|      0|            return "String could not be serialized with encoding: \(encoding)."
  431|      0|        case .jsonSerializationFailed(let error):
  432|      0|            return "JSON could not be serialized because of error:\n\(error.localizedDescription)"
  433|      0|        case .propertyListSerializationFailed(let error):
  434|      0|            return "PropertyList could not be serialized because of error:\n\(error.localizedDescription)"
  435|      0|        }
  436|      0|    }
  437|       |}
  438|       |
  439|       |extension AFError.ResponseValidationFailureReason {
  440|      0|    var localizedDescription: String {
  441|      0|        switch self {
  442|      0|        case .dataFileNil:
  443|      0|            return "Response could not be validated, data file was nil."
  444|      0|        case .dataFileReadFailed(let url):
  445|      0|            return "Response could not be validated, data file could not be read: \(url)."
  446|      0|        case .missingContentType(let types):
  447|      0|            return (
  448|      0|                "Response Content-Type was missing and acceptable content types " +
  449|      0|                "(\(types.joined(separator: ","))) do not match \"*/*\"."
  450|      0|            )
  451|      0|        case .unacceptableContentType(let acceptableTypes, let responseType):
  452|      0|            return (
  453|      0|                "Response Content-Type \"\(responseType)\" does not match any acceptable types: " +
  454|      0|                "\(acceptableTypes.joined(separator: ","))."
  455|      0|            )
  456|      0|        case .unacceptableStatusCode(let code):
  457|      0|            return "Response status code was unacceptable: \(code)."
  458|      0|        }
  459|      0|    }
  460|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/Alamofire.swift:
    1|       |//
    2|       |//  Alamofire.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Types adopting the `URLConvertible` protocol can be used to construct URLs, which are then used to construct
   28|       |/// URL requests.
   29|       |public protocol URLConvertible {
   30|       |    /// Returns a URL that conforms to RFC 2396 or throws an `Error`.
   31|       |    ///
   32|       |    /// - throws: An `Error` if the type cannot be converted to a `URL`.
   33|       |    ///
   34|       |    /// - returns: A URL or throws an `Error`.
   35|       |    func asURL() throws -> URL
   36|       |}
   37|       |
   38|       |extension String: URLConvertible {
   39|       |    /// Returns a URL if `self` represents a valid URL string that conforms to RFC 2396 or throws an `AFError`.
   40|       |    ///
   41|       |    /// - throws: An `AFError.invalidURL` if `self` is not a valid URL string.
   42|       |    ///
   43|       |    /// - returns: A URL or throws an `AFError`.
   44|    495|    public func asURL() throws -> URL {
   45|    495|        guard let url = URL(string: self) else { throw AFError.invalidURL(url: self) }
   46|    474|        return url
   47|    495|    }
   48|       |}
   49|       |
   50|       |extension URL: URLConvertible {
   51|       |    /// Returns self.
   52|      0|    public func asURL() throws -> URL { return self }
   53|       |}
   54|       |
   55|       |extension URLComponents: URLConvertible {
   56|       |    /// Returns a URL if `url` is not nil, otherwise throws an `Error`.
   57|       |    ///
   58|       |    /// - throws: An `AFError.invalidURL` if `url` is `nil`.
   59|       |    ///
   60|       |    /// - returns: A URL or throws an `AFError`.
   61|      0|    public func asURL() throws -> URL {
   62|      0|        guard let url = url else { throw AFError.invalidURL(url: self) }
   63|      0|        return url
   64|      0|    }
   65|       |}
   66|       |
   67|       |// MARK: -
   68|       |
   69|       |/// Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
   70|       |public protocol URLRequestConvertible {
   71|       |    /// Returns a URL request or throws if an `Error` was encountered.
   72|       |    ///
   73|       |    /// - throws: An `Error` if the underlying `URLRequest` is `nil`.
   74|       |    ///
   75|       |    /// - returns: A URL request.
   76|       |    func asURLRequest() throws -> URLRequest
   77|       |}
   78|       |
   79|       |extension URLRequestConvertible {
   80|       |    /// The URL request.
   81|      0|    public var urlRequest: URLRequest? { return try? asURLRequest() }
   82|       |}
   83|       |
   84|       |extension URLRequest: URLRequestConvertible {
   85|       |    /// Returns a URL request or throws if an `Error` was encountered.
   86|    948|    public func asURLRequest() throws -> URLRequest { return self }
   87|       |}
   88|       |
   89|       |// MARK: -
   90|       |
   91|       |extension URLRequest {
   92|       |    /// Creates an instance with the specified `method`, `urlString` and `headers`.
   93|       |    ///
   94|       |    /// - parameter url:     The URL.
   95|       |    /// - parameter method:  The HTTP method.
   96|       |    /// - parameter headers: The HTTP headers. `nil` by default.
   97|       |    ///
   98|       |    /// - returns: The new `URLRequest` instance.
   99|    495|    public init(url: URLConvertible, method: HTTPMethod, headers: HTTPHeaders? = nil) throws {
  100|    495|        let url = try url.asURL()
  101|    495|
  102|    495|        self.init(url: url)
  103|    495|
  104|    495|        httpMethod = method.rawValue
  105|    495|
  106|    495|        if let headers = headers {
  107|      0|            for (headerField, headerValue) in headers {
  108|      0|                setValue(headerValue, forHTTPHeaderField: headerField)
  109|      0|            }
  110|    495|        }
  111|    495|    }
  112|       |
  113|    474|    func adapt(using adapter: RequestAdapter?) throws -> URLRequest {
  114|    474|        guard let adapter = adapter else { return self }
  115|      0|        return try adapter.adapt(self)
  116|    474|    }
  117|       |}
  118|       |
  119|       |// MARK: - Data Request
  120|       |
  121|       |/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of the specified `url`,
  122|       |/// `method`, `parameters`, `encoding` and `headers`.
  123|       |///
  124|       |/// - parameter url:        The URL.
  125|       |/// - parameter method:     The HTTP method. `.get` by default.
  126|       |/// - parameter parameters: The parameters. `nil` by default.
  127|       |/// - parameter encoding:   The parameter encoding. `URLEncoding.default` by default.
  128|       |/// - parameter headers:    The HTTP headers. `nil` by default.
  129|       |///
  130|       |/// - returns: The created `DataRequest`.
  131|       |@discardableResult
  132|       |public func request(
  133|       |    _ url: URLConvertible,
  134|       |    method: HTTPMethod = .get,
  135|       |    parameters: Parameters? = nil,
  136|       |    encoding: ParameterEncoding = URLEncoding.default,
  137|       |    headers: HTTPHeaders? = nil)
  138|       |    -> DataRequest
  139|    495|{
  140|    495|    return SessionManager.default.request(
  141|    495|        url,
  142|    495|        method: method,
  143|    495|        parameters: parameters,
  144|    495|        encoding: encoding,
  145|    495|        headers: headers
  146|    495|    )
  147|    495|}
  148|       |
  149|       |/// Creates a `DataRequest` using the default `SessionManager` to retrieve the contents of a URL based on the
  150|       |/// specified `urlRequest`.
  151|       |///
  152|       |/// - parameter urlRequest: The URL request
  153|       |///
  154|       |/// - returns: The created `DataRequest`.
  155|       |@discardableResult
  156|      0|public func request(_ urlRequest: URLRequestConvertible) -> DataRequest {
  157|      0|    return SessionManager.default.request(urlRequest)
  158|      0|}
  159|       |
  160|       |// MARK: - Download Request
  161|       |
  162|       |// MARK: URL Request
  163|       |
  164|       |/// Creates a `DownloadRequest` using the default `SessionManager` to retrieve the contents of the specified `url`,
  165|       |/// `method`, `parameters`, `encoding`, `headers` and save them to the `destination`.
  166|       |///
  167|       |/// If `destination` is not specified, the contents will remain in the temporary location determined by the
  168|       |/// underlying URL session.
  169|       |///
  170|       |/// - parameter url:         The URL.
  171|       |/// - parameter method:      The HTTP method. `.get` by default.
  172|       |/// - parameter parameters:  The parameters. `nil` by default.
  173|       |/// - parameter encoding:    The parameter encoding. `URLEncoding.default` by default.
  174|       |/// - parameter headers:     The HTTP headers. `nil` by default.
  175|       |/// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.
  176|       |///
  177|       |/// - returns: The created `DownloadRequest`.
  178|       |@discardableResult
  179|       |public func download(
  180|       |    _ url: URLConvertible,
  181|       |    method: HTTPMethod = .get,
  182|       |    parameters: Parameters? = nil,
  183|       |    encoding: ParameterEncoding = URLEncoding.default,
  184|       |    headers: HTTPHeaders? = nil,
  185|       |    to destination: DownloadRequest.DownloadFileDestination? = nil)
  186|       |    -> DownloadRequest
  187|      0|{
  188|      0|    return SessionManager.default.download(
  189|      0|        url,
  190|      0|        method: method,
  191|      0|        parameters: parameters,
  192|      0|        encoding: encoding,
  193|      0|        headers: headers,
  194|      0|        to: destination
  195|      0|    )
  196|      0|}
  197|       |
  198|       |/// Creates a `DownloadRequest` using the default `SessionManager` to retrieve the contents of a URL based on the
  199|       |/// specified `urlRequest` and save them to the `destination`.
  200|       |///
  201|       |/// If `destination` is not specified, the contents will remain in the temporary location determined by the
  202|       |/// underlying URL session.
  203|       |///
  204|       |/// - parameter urlRequest:  The URL request.
  205|       |/// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.
  206|       |///
  207|       |/// - returns: The created `DownloadRequest`.
  208|       |@discardableResult
  209|       |public func download(
  210|       |    _ urlRequest: URLRequestConvertible,
  211|       |    to destination: DownloadRequest.DownloadFileDestination? = nil)
  212|       |    -> DownloadRequest
  213|      0|{
  214|      0|    return SessionManager.default.download(urlRequest, to: destination)
  215|      0|}
  216|       |
  217|       |// MARK: Resume Data
  218|       |
  219|       |/// Creates a `DownloadRequest` using the default `SessionManager` from the `resumeData` produced from a
  220|       |/// previous request cancellation to retrieve the contents of the original request and save them to the `destination`.
  221|       |///
  222|       |/// If `destination` is not specified, the contents will remain in the temporary location determined by the
  223|       |/// underlying URL session.
  224|       |///
  225|       |/// On the latest release of all the Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), `resumeData` is broken
  226|       |/// on background URL session configurations. There's an underlying bug in the `resumeData` generation logic where the
  227|       |/// data is written incorrectly and will always fail to resume the download. For more information about the bug and
  228|       |/// possible workarounds, please refer to the following Stack Overflow post:
  229|       |///
  230|       |///    - http://stackoverflow.com/a/39347461/1342462
  231|       |///
  232|       |/// - parameter resumeData:  The resume data. This is an opaque data blob produced by `URLSessionDownloadTask`
  233|       |///                          when a task is cancelled. See `URLSession -downloadTask(withResumeData:)` for additional
  234|       |///                          information.
  235|       |/// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.
  236|       |///
  237|       |/// - returns: The created `DownloadRequest`.
  238|       |@discardableResult
  239|       |public func download(
  240|       |    resumingWith resumeData: Data,
  241|       |    to destination: DownloadRequest.DownloadFileDestination? = nil)
  242|       |    -> DownloadRequest
  243|      0|{
  244|      0|    return SessionManager.default.download(resumingWith: resumeData, to: destination)
  245|      0|}
  246|       |
  247|       |// MARK: - Upload Request
  248|       |
  249|       |// MARK: File
  250|       |
  251|       |/// Creates an `UploadRequest` using the default `SessionManager` from the specified `url`, `method` and `headers`
  252|       |/// for uploading the `file`.
  253|       |///
  254|       |/// - parameter file:    The file to upload.
  255|       |/// - parameter url:     The URL.
  256|       |/// - parameter method:  The HTTP method. `.post` by default.
  257|       |/// - parameter headers: The HTTP headers. `nil` by default.
  258|       |///
  259|       |/// - returns: The created `UploadRequest`.
  260|       |@discardableResult
  261|       |public func upload(
  262|       |    _ fileURL: URL,
  263|       |    to url: URLConvertible,
  264|       |    method: HTTPMethod = .post,
  265|       |    headers: HTTPHeaders? = nil)
  266|       |    -> UploadRequest
  267|      0|{
  268|      0|    return SessionManager.default.upload(fileURL, to: url, method: method, headers: headers)
  269|      0|}
  270|       |
  271|       |/// Creates a `UploadRequest` using the default `SessionManager` from the specified `urlRequest` for
  272|       |/// uploading the `file`.
  273|       |///
  274|       |/// - parameter file:       The file to upload.
  275|       |/// - parameter urlRequest: The URL request.
  276|       |///
  277|       |/// - returns: The created `UploadRequest`.
  278|       |@discardableResult
  279|      0|public func upload(_ fileURL: URL, with urlRequest: URLRequestConvertible) -> UploadRequest {
  280|      0|    return SessionManager.default.upload(fileURL, with: urlRequest)
  281|      0|}
  282|       |
  283|       |// MARK: Data
  284|       |
  285|       |/// Creates an `UploadRequest` using the default `SessionManager` from the specified `url`, `method` and `headers`
  286|       |/// for uploading the `data`.
  287|       |///
  288|       |/// - parameter data:    The data to upload.
  289|       |/// - parameter url:     The URL.
  290|       |/// - parameter method:  The HTTP method. `.post` by default.
  291|       |/// - parameter headers: The HTTP headers. `nil` by default.
  292|       |///
  293|       |/// - returns: The created `UploadRequest`.
  294|       |@discardableResult
  295|       |public func upload(
  296|       |    _ data: Data,
  297|       |    to url: URLConvertible,
  298|       |    method: HTTPMethod = .post,
  299|       |    headers: HTTPHeaders? = nil)
  300|       |    -> UploadRequest
  301|      0|{
  302|      0|    return SessionManager.default.upload(data, to: url, method: method, headers: headers)
  303|      0|}
  304|       |
  305|       |/// Creates an `UploadRequest` using the default `SessionManager` from the specified `urlRequest` for
  306|       |/// uploading the `data`.
  307|       |///
  308|       |/// - parameter data:       The data to upload.
  309|       |/// - parameter urlRequest: The URL request.
  310|       |///
  311|       |/// - returns: The created `UploadRequest`.
  312|       |@discardableResult
  313|      0|public func upload(_ data: Data, with urlRequest: URLRequestConvertible) -> UploadRequest {
  314|      0|    return SessionManager.default.upload(data, with: urlRequest)
  315|      0|}
  316|       |
  317|       |// MARK: InputStream
  318|       |
  319|       |/// Creates an `UploadRequest` using the default `SessionManager` from the specified `url`, `method` and `headers`
  320|       |/// for uploading the `stream`.
  321|       |///
  322|       |/// - parameter stream:  The stream to upload.
  323|       |/// - parameter url:     The URL.
  324|       |/// - parameter method:  The HTTP method. `.post` by default.
  325|       |/// - parameter headers: The HTTP headers. `nil` by default.
  326|       |///
  327|       |/// - returns: The created `UploadRequest`.
  328|       |@discardableResult
  329|       |public func upload(
  330|       |    _ stream: InputStream,
  331|       |    to url: URLConvertible,
  332|       |    method: HTTPMethod = .post,
  333|       |    headers: HTTPHeaders? = nil)
  334|       |    -> UploadRequest
  335|      0|{
  336|      0|    return SessionManager.default.upload(stream, to: url, method: method, headers: headers)
  337|      0|}
  338|       |
  339|       |/// Creates an `UploadRequest` using the default `SessionManager` from the specified `urlRequest` for
  340|       |/// uploading the `stream`.
  341|       |///
  342|       |/// - parameter urlRequest: The URL request.
  343|       |/// - parameter stream:     The stream to upload.
  344|       |///
  345|       |/// - returns: The created `UploadRequest`.
  346|       |@discardableResult
  347|      0|public func upload(_ stream: InputStream, with urlRequest: URLRequestConvertible) -> UploadRequest {
  348|      0|    return SessionManager.default.upload(stream, with: urlRequest)
  349|      0|}
  350|       |
  351|       |// MARK: MultipartFormData
  352|       |
  353|       |/// Encodes `multipartFormData` using `encodingMemoryThreshold` with the default `SessionManager` and calls
  354|       |/// `encodingCompletion` with new `UploadRequest` using the `url`, `method` and `headers`.
  355|       |///
  356|       |/// It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
  357|       |/// payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
  358|       |/// efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
  359|       |/// be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
  360|       |/// footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
  361|       |/// used for larger payloads such as video content.
  362|       |///
  363|       |/// The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
  364|       |/// or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
  365|       |/// encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
  366|       |/// during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
  367|       |/// technique was used.
  368|       |///
  369|       |/// - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
  370|       |/// - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
  371|       |///                                      `multipartFormDataEncodingMemoryThreshold` by default.
  372|       |/// - parameter url:                     The URL.
  373|       |/// - parameter method:                  The HTTP method. `.post` by default.
  374|       |/// - parameter headers:                 The HTTP headers. `nil` by default.
  375|       |/// - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
  376|       |public func upload(
  377|       |    multipartFormData: @escaping (MultipartFormData) -> Void,
  378|       |    usingThreshold encodingMemoryThreshold: UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold,
  379|       |    to url: URLConvertible,
  380|       |    method: HTTPMethod = .post,
  381|       |    headers: HTTPHeaders? = nil,
  382|       |    encodingCompletion: ((SessionManager.MultipartFormDataEncodingResult) -> Void)?)
  383|      0|{
  384|      0|    return SessionManager.default.upload(
  385|      0|        multipartFormData: multipartFormData,
  386|      0|        usingThreshold: encodingMemoryThreshold,
  387|      0|        to: url,
  388|      0|        method: method,
  389|      0|        headers: headers,
  390|      0|        encodingCompletion: encodingCompletion
  391|      0|    )
  392|      0|}
  393|       |
  394|       |/// Encodes `multipartFormData` using `encodingMemoryThreshold` and the default `SessionManager` and
  395|       |/// calls `encodingCompletion` with new `UploadRequest` using the `urlRequest`.
  396|       |///
  397|       |/// It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
  398|       |/// payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
  399|       |/// efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
  400|       |/// be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
  401|       |/// footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
  402|       |/// used for larger payloads such as video content.
  403|       |///
  404|       |/// The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
  405|       |/// or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
  406|       |/// encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
  407|       |/// during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
  408|       |/// technique was used.
  409|       |///
  410|       |/// - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
  411|       |/// - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
  412|       |///                                      `multipartFormDataEncodingMemoryThreshold` by default.
  413|       |/// - parameter urlRequest:              The URL request.
  414|       |/// - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
  415|       |public func upload(
  416|       |    multipartFormData: @escaping (MultipartFormData) -> Void,
  417|       |    usingThreshold encodingMemoryThreshold: UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold,
  418|       |    with urlRequest: URLRequestConvertible,
  419|       |    encodingCompletion: ((SessionManager.MultipartFormDataEncodingResult) -> Void)?)
  420|      0|{
  421|      0|    return SessionManager.default.upload(
  422|      0|        multipartFormData: multipartFormData,
  423|      0|        usingThreshold: encodingMemoryThreshold,
  424|      0|        with: urlRequest,
  425|      0|        encodingCompletion: encodingCompletion
  426|      0|    )
  427|      0|}
  428|       |
  429|       |#if !os(watchOS)
  430|       |
  431|       |// MARK: - Stream Request
  432|       |
  433|       |// MARK: Hostname and Port
  434|       |
  435|       |/// Creates a `StreamRequest` using the default `SessionManager` for bidirectional streaming with the `hostname`
  436|       |/// and `port`.
  437|       |///
  438|       |/// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  439|       |///
  440|       |/// - parameter hostName: The hostname of the server to connect to.
  441|       |/// - parameter port:     The port of the server to connect to.
  442|       |///
  443|       |/// - returns: The created `StreamRequest`.
  444|       |@discardableResult
  445|       |@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  446|      0|public func stream(withHostName hostName: String, port: Int) -> StreamRequest {
  447|      0|    return SessionManager.default.stream(withHostName: hostName, port: port)
  448|      0|}
  449|       |
  450|       |// MARK: NetService
  451|       |
  452|       |/// Creates a `StreamRequest` using the default `SessionManager` for bidirectional streaming with the `netService`.
  453|       |///
  454|       |/// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  455|       |///
  456|       |/// - parameter netService: The net service used to identify the endpoint.
  457|       |///
  458|       |/// - returns: The created `StreamRequest`.
  459|       |@discardableResult
  460|       |@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  461|      0|public func stream(with netService: NetService) -> StreamRequest {
  462|      0|    return SessionManager.default.stream(with: netService)
  463|      0|}
  464|       |
  465|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/DispatchQueue+Alamofire.swift:
    1|       |//
    2|       |//  DispatchQueue+Alamofire.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Dispatch
   26|       |import Foundation
   27|       |
   28|       |extension DispatchQueue {
   29|      0|    static var userInteractive: DispatchQueue { return DispatchQueue.global(qos: .userInteractive) }
   30|      0|    static var userInitiated: DispatchQueue { return DispatchQueue.global(qos: .userInitiated) }
   31|      0|    static var utility: DispatchQueue { return DispatchQueue.global(qos: .utility) }
   32|      0|    static var background: DispatchQueue { return DispatchQueue.global(qos: .background) }
   33|       |
   34|      0|    func after(_ delay: TimeInterval, execute closure: @escaping () -> Void) {
   35|      0|        asyncAfter(deadline: .now() + delay, execute: closure)
   36|      0|    }
   37|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/MultipartFormData.swift:
    1|       |//
    2|       |//  MultipartFormData.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |#if os(iOS) || os(watchOS) || os(tvOS)
   28|       |import MobileCoreServices
   29|       |#elseif os(macOS)
   30|       |import CoreServices
   31|       |#endif
   32|       |
   33|       |/// Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode
   34|       |/// multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead
   35|       |/// to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the
   36|       |/// data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for
   37|       |/// larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
   38|       |///
   39|       |/// For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
   40|       |/// and the w3 form documentation.
   41|       |///
   42|       |/// - https://www.ietf.org/rfc/rfc2388.txt
   43|       |/// - https://www.ietf.org/rfc/rfc2045.txt
   44|       |/// - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
   45|       |open class MultipartFormData {
   46|       |
   47|       |    // MARK: - Helper Types
   48|       |
   49|       |    struct EncodingCharacters {
   50|       |        static let crlf = "\r\n"
   51|       |    }
   52|       |
   53|       |    struct BoundaryGenerator {
   54|       |        enum BoundaryType {
   55|       |            case initial, encapsulated, final
   56|       |        }
   57|       |
   58|      0|        static func randomBoundary() -> String {
   59|      0|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
   60|      0|        }
   61|       |
   62|      0|        static func boundaryData(forBoundaryType boundaryType: BoundaryType, boundary: String) -> Data {
   63|      0|            let boundaryText: String
   64|      0|
   65|      0|            switch boundaryType {
   66|      0|            case .initial:
   67|      0|                boundaryText = "--\(boundary)\(EncodingCharacters.crlf)"
   68|      0|            case .encapsulated:
   69|      0|                boundaryText = "\(EncodingCharacters.crlf)--\(boundary)\(EncodingCharacters.crlf)"
   70|      0|            case .final:
   71|      0|                boundaryText = "\(EncodingCharacters.crlf)--\(boundary)--\(EncodingCharacters.crlf)"
   72|      0|            }
   73|      0|
   74|      0|            return boundaryText.data(using: String.Encoding.utf8, allowLossyConversion: false)!
   75|      0|        }
   76|       |    }
   77|       |
   78|       |    class BodyPart {
   79|       |        let headers: HTTPHeaders
   80|       |        let bodyStream: InputStream
   81|       |        let bodyContentLength: UInt64
   82|       |        var hasInitialBoundary = false
   83|       |        var hasFinalBoundary = false
   84|       |
   85|      0|        init(headers: HTTPHeaders, bodyStream: InputStream, bodyContentLength: UInt64) {
   86|      0|            self.headers = headers
   87|      0|            self.bodyStream = bodyStream
   88|      0|            self.bodyContentLength = bodyContentLength
   89|      0|        }
   90|       |    }
   91|       |
   92|       |    // MARK: - Properties
   93|       |
   94|       |    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
   95|       |    open lazy var contentType: String = "multipart/form-data; boundary=\(self.boundary)"
   96|       |
   97|       |    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
   98|      0|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
   99|       |
  100|       |    /// The boundary used to separate the body parts in the encoded form data.
  101|       |    public let boundary: String
  102|       |
  103|       |    private var bodyParts: [BodyPart]
  104|       |    private var bodyPartError: AFError?
  105|       |    private let streamBufferSize: Int
  106|       |
  107|       |    // MARK: - Lifecycle
  108|       |
  109|       |    /// Creates a multipart form data object.
  110|       |    ///
  111|       |    /// - returns: The multipart form data object.
  112|      0|    public init() {
  113|      0|        self.boundary = BoundaryGenerator.randomBoundary()
  114|      0|        self.bodyParts = []
  115|      0|
  116|      0|        ///
  117|      0|        /// The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more
  118|      0|        /// information, please refer to the following article:
  119|      0|        ///   - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
  120|      0|        ///
  121|      0|
  122|      0|        self.streamBufferSize = 1024
  123|      0|    }
  124|       |
  125|       |    // MARK: - Body Parts
  126|       |
  127|       |    /// Creates a body part from the data and appends it to the multipart form data object.
  128|       |    ///
  129|       |    /// The body part data will be encoded using the following format:
  130|       |    ///
  131|       |    /// - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
  132|       |    /// - Encoded data
  133|       |    /// - Multipart form boundary
  134|       |    ///
  135|       |    /// - parameter data: The data to encode into the multipart form data.
  136|       |    /// - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
  137|      0|    public func append(_ data: Data, withName name: String) {
  138|      0|        let headers = contentHeaders(withName: name)
  139|      0|        let stream = InputStream(data: data)
  140|      0|        let length = UInt64(data.count)
  141|      0|
  142|      0|        append(stream, withLength: length, headers: headers)
  143|      0|    }
  144|       |
  145|       |    /// Creates a body part from the data and appends it to the multipart form data object.
  146|       |    ///
  147|       |    /// The body part data will be encoded using the following format:
  148|       |    ///
  149|       |    /// - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
  150|       |    /// - `Content-Type: #{generated mimeType}` (HTTP Header)
  151|       |    /// - Encoded data
  152|       |    /// - Multipart form boundary
  153|       |    ///
  154|       |    /// - parameter data:     The data to encode into the multipart form data.
  155|       |    /// - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
  156|       |    /// - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
  157|      0|    public func append(_ data: Data, withName name: String, mimeType: String) {
  158|      0|        let headers = contentHeaders(withName: name, mimeType: mimeType)
  159|      0|        let stream = InputStream(data: data)
  160|      0|        let length = UInt64(data.count)
  161|      0|
  162|      0|        append(stream, withLength: length, headers: headers)
  163|      0|    }
  164|       |
  165|       |    /// Creates a body part from the data and appends it to the multipart form data object.
  166|       |    ///
  167|       |    /// The body part data will be encoded using the following format:
  168|       |    ///
  169|       |    /// - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
  170|       |    /// - `Content-Type: #{mimeType}` (HTTP Header)
  171|       |    /// - Encoded file data
  172|       |    /// - Multipart form boundary
  173|       |    ///
  174|       |    /// - parameter data:     The data to encode into the multipart form data.
  175|       |    /// - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
  176|       |    /// - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
  177|       |    /// - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
  178|      0|    public func append(_ data: Data, withName name: String, fileName: String, mimeType: String) {
  179|      0|        let headers = contentHeaders(withName: name, fileName: fileName, mimeType: mimeType)
  180|      0|        let stream = InputStream(data: data)
  181|      0|        let length = UInt64(data.count)
  182|      0|
  183|      0|        append(stream, withLength: length, headers: headers)
  184|      0|    }
  185|       |
  186|       |    /// Creates a body part from the file and appends it to the multipart form data object.
  187|       |    ///
  188|       |    /// The body part data will be encoded using the following format:
  189|       |    ///
  190|       |    /// - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
  191|       |    /// - `Content-Type: #{generated mimeType}` (HTTP Header)
  192|       |    /// - Encoded file data
  193|       |    /// - Multipart form boundary
  194|       |    ///
  195|       |    /// The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
  196|       |    /// `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
  197|       |    /// system associated MIME type.
  198|       |    ///
  199|       |    /// - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
  200|       |    /// - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
  201|      0|    public func append(_ fileURL: URL, withName name: String) {
  202|      0|        let fileName = fileURL.lastPathComponent
  203|      0|        let pathExtension = fileURL.pathExtension
  204|      0|
  205|      0|        if !fileName.isEmpty && !pathExtension.isEmpty {
  206|      0|            let mime = mimeType(forPathExtension: pathExtension)
  207|      0|            append(fileURL, withName: name, fileName: fileName, mimeType: mime)
  208|      0|        } else {
  209|      0|            setBodyPartError(withReason: .bodyPartFilenameInvalid(in: fileURL))
  210|      0|        }
  211|      0|    }
  212|       |
  213|       |    /// Creates a body part from the file and appends it to the multipart form data object.
  214|       |    ///
  215|       |    /// The body part data will be encoded using the following format:
  216|       |    ///
  217|       |    /// - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
  218|       |    /// - Content-Type: #{mimeType} (HTTP Header)
  219|       |    /// - Encoded file data
  220|       |    /// - Multipart form boundary
  221|       |    ///
  222|       |    /// - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
  223|       |    /// - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
  224|       |    /// - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
  225|       |    /// - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
  226|      0|    public func append(_ fileURL: URL, withName name: String, fileName: String, mimeType: String) {
  227|      0|        let headers = contentHeaders(withName: name, fileName: fileName, mimeType: mimeType)
  228|      0|
  229|      0|        //============================================================
  230|      0|        //                 Check 1 - is file URL?
  231|      0|        //============================================================
  232|      0|
  233|      0|        guard fileURL.isFileURL else {
  234|      0|            setBodyPartError(withReason: .bodyPartURLInvalid(url: fileURL))
  235|      0|            return
  236|      0|        }
  237|      0|
  238|      0|        //============================================================
  239|      0|        //              Check 2 - is file URL reachable?
  240|      0|        //============================================================
  241|      0|
  242|      0|        do {
  243|      0|            let isReachable = try fileURL.checkPromisedItemIsReachable()
  244|      0|            guard isReachable else {
  245|      0|                setBodyPartError(withReason: .bodyPartFileNotReachable(at: fileURL))
  246|      0|                return
  247|      0|            }
  248|      0|        } catch {
  249|      0|            setBodyPartError(withReason: .bodyPartFileNotReachableWithError(atURL: fileURL, error: error))
  250|      0|            return
  251|      0|        }
  252|      0|
  253|      0|        //============================================================
  254|      0|        //            Check 3 - is file URL a directory?
  255|      0|        //============================================================
  256|      0|
  257|      0|        var isDirectory: ObjCBool = false
  258|      0|        let path = fileURL.path
  259|      0|
  260|      0|        guard FileManager.default.fileExists(atPath: path, isDirectory: &isDirectory) && !isDirectory.boolValue else {
  261|      0|            setBodyPartError(withReason: .bodyPartFileIsDirectory(at: fileURL))
  262|      0|            return
  263|      0|        }
  264|      0|
  265|      0|        //============================================================
  266|      0|        //          Check 4 - can the file size be extracted?
  267|      0|        //============================================================
  268|      0|
  269|      0|        let bodyContentLength: UInt64
  270|      0|
  271|      0|        do {
  272|      0|            guard let fileSize = try FileManager.default.attributesOfItem(atPath: path)[.size] as? NSNumber else {
  273|      0|                setBodyPartError(withReason: .bodyPartFileSizeNotAvailable(at: fileURL))
  274|      0|                return
  275|      0|            }
  276|      0|
  277|      0|            bodyContentLength = fileSize.uint64Value
  278|      0|        }
  279|      0|        catch {
  280|      0|            setBodyPartError(withReason: .bodyPartFileSizeQueryFailedWithError(forURL: fileURL, error: error))
  281|      0|            return
  282|      0|        }
  283|      0|
  284|      0|        //============================================================
  285|      0|        //       Check 5 - can a stream be created from file URL?
  286|      0|        //============================================================
  287|      0|
  288|      0|        guard let stream = InputStream(url: fileURL) else {
  289|      0|            setBodyPartError(withReason: .bodyPartInputStreamCreationFailed(for: fileURL))
  290|      0|            return
  291|      0|        }
  292|      0|
  293|      0|        append(stream, withLength: bodyContentLength, headers: headers)
  294|      0|    }
  295|       |
  296|       |    /// Creates a body part from the stream and appends it to the multipart form data object.
  297|       |    ///
  298|       |    /// The body part data will be encoded using the following format:
  299|       |    ///
  300|       |    /// - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
  301|       |    /// - `Content-Type: #{mimeType}` (HTTP Header)
  302|       |    /// - Encoded stream data
  303|       |    /// - Multipart form boundary
  304|       |    ///
  305|       |    /// - parameter stream:   The input stream to encode in the multipart form data.
  306|       |    /// - parameter length:   The content length of the stream.
  307|       |    /// - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
  308|       |    /// - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
  309|       |    /// - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
  310|       |    public func append(
  311|       |        _ stream: InputStream,
  312|       |        withLength length: UInt64,
  313|       |        name: String,
  314|       |        fileName: String,
  315|       |        mimeType: String)
  316|      0|    {
  317|      0|        let headers = contentHeaders(withName: name, fileName: fileName, mimeType: mimeType)
  318|      0|        append(stream, withLength: length, headers: headers)
  319|      0|    }
  320|       |
  321|       |    /// Creates a body part with the headers, stream and length and appends it to the multipart form data object.
  322|       |    ///
  323|       |    /// The body part data will be encoded using the following format:
  324|       |    ///
  325|       |    /// - HTTP headers
  326|       |    /// - Encoded stream data
  327|       |    /// - Multipart form boundary
  328|       |    ///
  329|       |    /// - parameter stream:  The input stream to encode in the multipart form data.
  330|       |    /// - parameter length:  The content length of the stream.
  331|       |    /// - parameter headers: The HTTP headers for the body part.
  332|      0|    public func append(_ stream: InputStream, withLength length: UInt64, headers: HTTPHeaders) {
  333|      0|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
  334|      0|        bodyParts.append(bodyPart)
  335|      0|    }
  336|       |
  337|       |    // MARK: - Data Encoding
  338|       |
  339|       |    /// Encodes all the appended body parts into a single `Data` value.
  340|       |    ///
  341|       |    /// It is important to note that this method will load all the appended body parts into memory all at the same
  342|       |    /// time. This method should only be used when the encoded data will have a small memory footprint. For large data
  343|       |    /// cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
  344|       |    ///
  345|       |    /// - throws: An `AFError` if encoding encounters an error.
  346|       |    ///
  347|       |    /// - returns: The encoded `Data` if encoding is successful.
  348|      0|    public func encode() throws -> Data {
  349|      0|        if let bodyPartError = bodyPartError {
  350|      0|            throw bodyPartError
  351|      0|        }
  352|      0|
  353|      0|        var encoded = Data()
  354|      0|
  355|      0|        bodyParts.first?.hasInitialBoundary = true
  356|      0|        bodyParts.last?.hasFinalBoundary = true
  357|      0|
  358|      0|        for bodyPart in bodyParts {
  359|      0|            let encodedData = try encode(bodyPart)
  360|      0|            encoded.append(encodedData)
  361|      0|        }
  362|      0|
  363|      0|        return encoded
  364|      0|    }
  365|       |
  366|       |    /// Writes the appended body parts into the given file URL.
  367|       |    ///
  368|       |    /// This process is facilitated by reading and writing with input and output streams, respectively. Thus,
  369|       |    /// this approach is very memory efficient and should be used for large body part data.
  370|       |    ///
  371|       |    /// - parameter fileURL: The file URL to write the multipart form data into.
  372|       |    ///
  373|       |    /// - throws: An `AFError` if encoding encounters an error.
  374|      0|    public func writeEncodedData(to fileURL: URL) throws {
  375|      0|        if let bodyPartError = bodyPartError {
  376|      0|            throw bodyPartError
  377|      0|        }
  378|      0|
  379|      0|        if FileManager.default.fileExists(atPath: fileURL.path) {
  380|      0|            throw AFError.multipartEncodingFailed(reason: .outputStreamFileAlreadyExists(at: fileURL))
  381|      0|        } else if !fileURL.isFileURL {
  382|      0|            throw AFError.multipartEncodingFailed(reason: .outputStreamURLInvalid(url: fileURL))
  383|      0|        }
  384|      0|
  385|      0|        guard let outputStream = OutputStream(url: fileURL, append: false) else {
  386|      0|            throw AFError.multipartEncodingFailed(reason: .outputStreamCreationFailed(for: fileURL))
  387|      0|        }
  388|      0|
  389|      0|        outputStream.open()
  390|      0|        defer { outputStream.close() }
  391|      0|
  392|      0|        self.bodyParts.first?.hasInitialBoundary = true
  393|      0|        self.bodyParts.last?.hasFinalBoundary = true
  394|      0|
  395|      0|        for bodyPart in self.bodyParts {
  396|      0|            try write(bodyPart, to: outputStream)
  397|      0|        }
  398|      0|    }
  399|       |
  400|       |    // MARK: - Private - Body Part Encoding
  401|       |
  402|      0|    private func encode(_ bodyPart: BodyPart) throws -> Data {
  403|      0|        var encoded = Data()
  404|      0|
  405|      0|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
  406|      0|        encoded.append(initialData)
  407|      0|
  408|      0|        let headerData = encodeHeaders(for: bodyPart)
  409|      0|        encoded.append(headerData)
  410|      0|
  411|      0|        let bodyStreamData = try encodeBodyStream(for: bodyPart)
  412|      0|        encoded.append(bodyStreamData)
  413|      0|
  414|      0|        if bodyPart.hasFinalBoundary {
  415|      0|            encoded.append(finalBoundaryData())
  416|      0|        }
  417|      0|
  418|      0|        return encoded
  419|      0|    }
  420|       |
  421|      0|    private func encodeHeaders(for bodyPart: BodyPart) -> Data {
  422|      0|        var headerText = ""
  423|      0|
  424|      0|        for (key, value) in bodyPart.headers {
  425|      0|            headerText += "\(key): \(value)\(EncodingCharacters.crlf)"
  426|      0|        }
  427|      0|        headerText += EncodingCharacters.crlf
  428|      0|
  429|      0|        return headerText.data(using: String.Encoding.utf8, allowLossyConversion: false)!
  430|      0|    }
  431|       |
  432|      0|    private func encodeBodyStream(for bodyPart: BodyPart) throws -> Data {
  433|      0|        let inputStream = bodyPart.bodyStream
  434|      0|        inputStream.open()
  435|      0|        defer { inputStream.close() }
  436|      0|
  437|      0|        var encoded = Data()
  438|      0|
  439|      0|        while inputStream.hasBytesAvailable {
  440|      0|            var buffer = [UInt8](repeating: 0, count: streamBufferSize)
  441|      0|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
  442|      0|
  443|      0|            if let error = inputStream.streamError {
  444|      0|                throw AFError.multipartEncodingFailed(reason: .inputStreamReadFailed(error: error))
  445|      0|            }
  446|      0|
  447|      0|            if bytesRead > 0 {
  448|      0|                encoded.append(buffer, count: bytesRead)
  449|      0|            } else {
  450|      0|                break
  451|      0|            }
  452|      0|        }
  453|      0|
  454|      0|        return encoded
  455|      0|    }
  456|       |
  457|       |    // MARK: - Private - Writing Body Part to Output Stream
  458|       |
  459|      0|    private func write(_ bodyPart: BodyPart, to outputStream: OutputStream) throws {
  460|      0|        try writeInitialBoundaryData(for: bodyPart, to: outputStream)
  461|      0|        try writeHeaderData(for: bodyPart, to: outputStream)
  462|      0|        try writeBodyStream(for: bodyPart, to: outputStream)
  463|      0|        try writeFinalBoundaryData(for: bodyPart, to: outputStream)
  464|      0|    }
  465|       |
  466|      0|    private func writeInitialBoundaryData(for bodyPart: BodyPart, to outputStream: OutputStream) throws {
  467|      0|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
  468|      0|        return try write(initialData, to: outputStream)
  469|      0|    }
  470|       |
  471|      0|    private func writeHeaderData(for bodyPart: BodyPart, to outputStream: OutputStream) throws {
  472|      0|        let headerData = encodeHeaders(for: bodyPart)
  473|      0|        return try write(headerData, to: outputStream)
  474|      0|    }
  475|       |
  476|      0|    private func writeBodyStream(for bodyPart: BodyPart, to outputStream: OutputStream) throws {
  477|      0|        let inputStream = bodyPart.bodyStream
  478|      0|
  479|      0|        inputStream.open()
  480|      0|        defer { inputStream.close() }
  481|      0|
  482|      0|        while inputStream.hasBytesAvailable {
  483|      0|            var buffer = [UInt8](repeating: 0, count: streamBufferSize)
  484|      0|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
  485|      0|
  486|      0|            if let streamError = inputStream.streamError {
  487|      0|                throw AFError.multipartEncodingFailed(reason: .inputStreamReadFailed(error: streamError))
  488|      0|            }
  489|      0|
  490|      0|            if bytesRead > 0 {
  491|      0|                if buffer.count != bytesRead {
  492|      0|                    buffer = Array(buffer[0..<bytesRead])
  493|      0|                }
  494|      0|
  495|      0|                try write(&buffer, to: outputStream)
  496|      0|            } else {
  497|      0|                break
  498|      0|            }
  499|      0|        }
  500|      0|    }
  501|       |
  502|      0|    private func writeFinalBoundaryData(for bodyPart: BodyPart, to outputStream: OutputStream) throws {
  503|      0|        if bodyPart.hasFinalBoundary {
  504|      0|            return try write(finalBoundaryData(), to: outputStream)
  505|      0|        }
  506|      0|    }
  507|       |
  508|       |    // MARK: - Private - Writing Buffered Data to Output Stream
  509|       |
  510|      0|    private func write(_ data: Data, to outputStream: OutputStream) throws {
  511|      0|        var buffer = [UInt8](repeating: 0, count: data.count)
  512|      0|        data.copyBytes(to: &buffer, count: data.count)
  513|      0|
  514|      0|        return try write(&buffer, to: outputStream)
  515|      0|    }
  516|       |
  517|      0|    private func write(_ buffer: inout [UInt8], to outputStream: OutputStream) throws {
  518|      0|        var bytesToWrite = buffer.count
  519|      0|
  520|      0|        while bytesToWrite > 0, outputStream.hasSpaceAvailable {
  521|      0|            let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
  522|      0|
  523|      0|            if let error = outputStream.streamError {
  524|      0|                throw AFError.multipartEncodingFailed(reason: .outputStreamWriteFailed(error: error))
  525|      0|            }
  526|      0|
  527|      0|            bytesToWrite -= bytesWritten
  528|      0|
  529|      0|            if bytesToWrite > 0 {
  530|      0|                buffer = Array(buffer[bytesWritten..<buffer.count])
  531|      0|            }
  532|      0|        }
  533|      0|    }
  534|       |
  535|       |    // MARK: - Private - Mime Type
  536|       |
  537|      0|    private func mimeType(forPathExtension pathExtension: String) -> String {
  538|      0|        if
  539|      0|            let id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension as CFString, nil)?.takeRetainedValue(),
  540|      0|            let contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
  541|      0|        {
  542|      0|            return contentType as String
  543|      0|        }
  544|      0|
  545|      0|        return "application/octet-stream"
  546|      0|    }
  547|       |
  548|       |    // MARK: - Private - Content Headers
  549|       |
  550|      0|    private func contentHeaders(withName name: String, fileName: String? = nil, mimeType: String? = nil) -> [String: String] {
  551|      0|        var disposition = "form-data; name=\"\(name)\""
  552|      0|        if let fileName = fileName { disposition += "; filename=\"\(fileName)\"" }
  553|      0|
  554|      0|        var headers = ["Content-Disposition": disposition]
  555|      0|        if let mimeType = mimeType { headers["Content-Type"] = mimeType }
  556|      0|
  557|      0|        return headers
  558|      0|    }
  559|       |
  560|       |    // MARK: - Private - Boundary Encoding
  561|       |
  562|      0|    private func initialBoundaryData() -> Data {
  563|      0|        return BoundaryGenerator.boundaryData(forBoundaryType: .initial, boundary: boundary)
  564|      0|    }
  565|       |
  566|      0|    private func encapsulatedBoundaryData() -> Data {
  567|      0|        return BoundaryGenerator.boundaryData(forBoundaryType: .encapsulated, boundary: boundary)
  568|      0|    }
  569|       |
  570|      0|    private func finalBoundaryData() -> Data {
  571|      0|        return BoundaryGenerator.boundaryData(forBoundaryType: .final, boundary: boundary)
  572|      0|    }
  573|       |
  574|       |    // MARK: - Private - Errors
  575|       |
  576|      0|    private func setBodyPartError(withReason reason: AFError.MultipartEncodingFailureReason) {
  577|      0|        guard bodyPartError == nil else { return }
  578|      0|        bodyPartError = AFError.multipartEncodingFailed(reason: reason)
  579|      0|    }
  580|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/NetworkReachabilityManager.swift:
    1|       |//
    2|       |//  NetworkReachabilityManager.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |#if !os(watchOS)
   26|       |
   27|       |import Foundation
   28|       |import SystemConfiguration
   29|       |
   30|       |/// The `NetworkReachabilityManager` class listens for reachability changes of hosts and addresses for both WWAN and
   31|       |/// WiFi network interfaces.
   32|       |///
   33|       |/// Reachability can be used to determine background information about why a network operation failed, or to retry
   34|       |/// network requests when a connection is established. It should not be used to prevent a user from initiating a network
   35|       |/// request, as it's possible that an initial request may be required to establish reachability.
   36|       |open class NetworkReachabilityManager {
   37|       |    /// Defines the various states of network reachability.
   38|       |    ///
   39|       |    /// - unknown:      It is unknown whether the network is reachable.
   40|       |    /// - notReachable: The network is not reachable.
   41|       |    /// - reachable:    The network is reachable.
   42|       |    public enum NetworkReachabilityStatus {
   43|       |        case unknown
   44|       |        case notReachable
   45|       |        case reachable(ConnectionType)
   46|       |    }
   47|       |
   48|       |    /// Defines the various connection types detected by reachability flags.
   49|       |    ///
   50|       |    /// - ethernetOrWiFi: The connection type is either over Ethernet or WiFi.
   51|       |    /// - wwan:           The connection type is a WWAN connection.
   52|       |    public enum ConnectionType {
   53|       |        case ethernetOrWiFi
   54|       |        case wwan
   55|       |    }
   56|       |
   57|       |    /// A closure executed when the network reachability status changes. The closure takes a single argument: the
   58|       |    /// network reachability status.
   59|       |    public typealias Listener = (NetworkReachabilityStatus) -> Void
   60|       |
   61|       |    // MARK: - Properties
   62|       |
   63|       |    /// Whether the network is currently reachable.
   64|      0|    open var isReachable: Bool { return isReachableOnWWAN || isReachableOnEthernetOrWiFi }
   65|       |
   66|       |    /// Whether the network is currently reachable over the WWAN interface.
   67|      0|    open var isReachableOnWWAN: Bool { return networkReachabilityStatus == .reachable(.wwan) }
   68|       |
   69|       |    /// Whether the network is currently reachable over Ethernet or WiFi interface.
   70|      0|    open var isReachableOnEthernetOrWiFi: Bool { return networkReachabilityStatus == .reachable(.ethernetOrWiFi) }
   71|       |
   72|       |    /// The current network reachability status.
   73|      0|    open var networkReachabilityStatus: NetworkReachabilityStatus {
   74|      0|        guard let flags = self.flags else { return .unknown }
   75|      0|        return networkReachabilityStatusForFlags(flags)
   76|      0|    }
   77|       |
   78|       |    /// The dispatch queue to execute the `listener` closure on.
   79|       |    open var listenerQueue: DispatchQueue = DispatchQueue.main
   80|       |
   81|       |    /// A closure executed when the network reachability status changes.
   82|       |    open var listener: Listener?
   83|       |
   84|      0|    open var flags: SCNetworkReachabilityFlags? {
   85|      0|        var flags = SCNetworkReachabilityFlags()
   86|      0|
   87|      0|        if SCNetworkReachabilityGetFlags(reachability, &flags) {
   88|      0|            return flags
   89|      0|        }
   90|      0|
   91|      0|        return nil
   92|      0|    }
   93|       |
   94|       |    private let reachability: SCNetworkReachability
   95|       |    open var previousFlags: SCNetworkReachabilityFlags
   96|       |
   97|       |    // MARK: - Initialization
   98|       |
   99|       |    /// Creates a `NetworkReachabilityManager` instance with the specified host.
  100|       |    ///
  101|       |    /// - parameter host: The host used to evaluate network reachability.
  102|       |    ///
  103|       |    /// - returns: The new `NetworkReachabilityManager` instance.
  104|      0|    public convenience init?(host: String) {
  105|      0|        guard let reachability = SCNetworkReachabilityCreateWithName(nil, host) else { return nil }
  106|      0|        self.init(reachability: reachability)
  107|      0|    }
  108|       |
  109|       |    /// Creates a `NetworkReachabilityManager` instance that monitors the address 0.0.0.0.
  110|       |    ///
  111|       |    /// Reachability treats the 0.0.0.0 address as a special token that causes it to monitor the general routing
  112|       |    /// status of the device, both IPv4 and IPv6.
  113|       |    ///
  114|       |    /// - returns: The new `NetworkReachabilityManager` instance.
  115|      0|    public convenience init?() {
  116|      0|        var address = sockaddr_in()
  117|      0|        address.sin_len = UInt8(MemoryLayout<sockaddr_in>.size)
  118|      0|        address.sin_family = sa_family_t(AF_INET)
  119|      0|
  120|      0|        guard let reachability = withUnsafePointer(to: &address, { pointer in
  121|      0|            return pointer.withMemoryRebound(to: sockaddr.self, capacity: MemoryLayout<sockaddr>.size) {
  122|      0|                return SCNetworkReachabilityCreateWithAddress(nil, $0)
  123|      0|            }
  124|      0|        }) else { return nil }
  125|      0|
  126|      0|        self.init(reachability: reachability)
  127|      0|    }
  128|       |
  129|      0|    private init(reachability: SCNetworkReachability) {
  130|      0|        self.reachability = reachability
  131|      0|
  132|      0|        // Set the previous flags to an unreserved value to represent unknown status
  133|      0|        self.previousFlags = SCNetworkReachabilityFlags(rawValue: 1 << 30)
  134|      0|    }
  135|       |
  136|      0|    deinit {
  137|      0|        stopListening()
  138|      0|    }
  139|       |
  140|       |    // MARK: - Listening
  141|       |
  142|       |    /// Starts listening for changes in network reachability status.
  143|       |    ///
  144|       |    /// - returns: `true` if listening was started successfully, `false` otherwise.
  145|       |    @discardableResult
  146|      0|    open func startListening() -> Bool {
  147|      0|        var context = SCNetworkReachabilityContext(version: 0, info: nil, retain: nil, release: nil, copyDescription: nil)
  148|      0|        context.info = Unmanaged.passUnretained(self).toOpaque()
  149|      0|
  150|      0|        let callbackEnabled = SCNetworkReachabilitySetCallback(
  151|      0|            reachability,
  152|      0|            { (_, flags, info) in
  153|      0|                let reachability = Unmanaged<NetworkReachabilityManager>.fromOpaque(info!).takeUnretainedValue()
  154|      0|                reachability.notifyListener(flags)
  155|      0|            },
  156|      0|            &context
  157|      0|        )
  158|      0|
  159|      0|        let queueEnabled = SCNetworkReachabilitySetDispatchQueue(reachability, listenerQueue)
  160|      0|
  161|      0|        listenerQueue.async {
  162|      0|            guard let flags = self.flags else { return }
  163|      0|            self.notifyListener(flags)
  164|      0|        }
  165|      0|
  166|      0|        return callbackEnabled && queueEnabled
  167|      0|    }
  168|       |
  169|       |    /// Stops listening for changes in network reachability status.
  170|      0|    open func stopListening() {
  171|      0|        SCNetworkReachabilitySetCallback(reachability, nil, nil)
  172|      0|        SCNetworkReachabilitySetDispatchQueue(reachability, nil)
  173|      0|    }
  174|       |
  175|       |    // MARK: - Internal - Listener Notification
  176|       |
  177|      0|    func notifyListener(_ flags: SCNetworkReachabilityFlags) {
  178|      0|        guard previousFlags != flags else { return }
  179|      0|        previousFlags = flags
  180|      0|
  181|      0|        listener?(networkReachabilityStatusForFlags(flags))
  182|      0|    }
  183|       |
  184|       |    // MARK: - Internal - Network Reachability Status
  185|       |
  186|      0|    func networkReachabilityStatusForFlags(_ flags: SCNetworkReachabilityFlags) -> NetworkReachabilityStatus {
  187|      0|        guard isNetworkReachable(with: flags) else { return .notReachable }
  188|      0|
  189|      0|        var networkStatus: NetworkReachabilityStatus = .reachable(.ethernetOrWiFi)
  190|      0|
  191|      0|    #if os(iOS)
  192|      0|        if flags.contains(.isWWAN) { networkStatus = .reachable(.wwan) }
  193|      0|    #endif
  194|      0|
  195|      0|        return networkStatus
  196|      0|    }
  197|       |
  198|      0|    func isNetworkReachable(with flags: SCNetworkReachabilityFlags) -> Bool {
  199|      0|        let isReachable = flags.contains(.reachable)
  200|      0|        let needsConnection = flags.contains(.connectionRequired)
  201|      0|        let canConnectAutomatically = flags.contains(.connectionOnDemand) || flags.contains(.connectionOnTraffic)
  202|      0|        let canConnectWithoutUserInteraction = canConnectAutomatically && !flags.contains(.interventionRequired)
  203|      0|
  204|      0|        return isReachable && (!needsConnection || canConnectWithoutUserInteraction)
  205|      0|    }
  206|       |}
  207|       |
  208|       |// MARK: -
  209|       |
  210|       |extension NetworkReachabilityManager.NetworkReachabilityStatus: Equatable {}
  211|       |
  212|       |/// Returns whether the two network reachability status values are equal.
  213|       |///
  214|       |/// - parameter lhs: The left-hand side value to compare.
  215|       |/// - parameter rhs: The right-hand side value to compare.
  216|       |///
  217|       |/// - returns: `true` if the two values are equal, `false` otherwise.
  218|       |public func ==(
  219|       |    lhs: NetworkReachabilityManager.NetworkReachabilityStatus,
  220|       |    rhs: NetworkReachabilityManager.NetworkReachabilityStatus)
  221|       |    -> Bool
  222|      0|{
  223|      0|    switch (lhs, rhs) {
  224|      0|    case (.unknown, .unknown):
  225|      0|        return true
  226|      0|    case (.notReachable, .notReachable):
  227|      0|        return true
  228|      0|    case let (.reachable(lhsConnectionType), .reachable(rhsConnectionType)):
  229|      0|        return lhsConnectionType == rhsConnectionType
  230|      0|    default:
  231|      0|        return false
  232|      0|    }
  233|      0|}
  234|       |
  235|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/ParameterEncoding.swift:
    1|       |//
    2|       |//  ParameterEncoding.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// HTTP method definitions.
   28|       |///
   29|       |/// See https://tools.ietf.org/html/rfc7231#section-4.3
   30|       |public enum HTTPMethod: String {
   31|       |    case options = "OPTIONS"
   32|       |    case get     = "GET"
   33|       |    case head    = "HEAD"
   34|       |    case post    = "POST"
   35|       |    case put     = "PUT"
   36|       |    case patch   = "PATCH"
   37|       |    case delete  = "DELETE"
   38|       |    case trace   = "TRACE"
   39|       |    case connect = "CONNECT"
   40|       |}
   41|       |
   42|       |// MARK: -
   43|       |
   44|       |/// A dictionary of parameters to apply to a `URLRequest`.
   45|       |public typealias Parameters = [String: Any]
   46|       |
   47|       |/// A type used to define how a set of parameters are applied to a `URLRequest`.
   48|       |public protocol ParameterEncoding {
   49|       |    /// Creates a URL request by encoding parameters and applying them onto an existing request.
   50|       |    ///
   51|       |    /// - parameter urlRequest: The request to have parameters applied.
   52|       |    /// - parameter parameters: The parameters to apply.
   53|       |    ///
   54|       |    /// - throws: An `AFError.parameterEncodingFailed` error if encoding fails.
   55|       |    ///
   56|       |    /// - returns: The encoded request.
   57|       |    func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest
   58|       |}
   59|       |
   60|       |// MARK: -
   61|       |
   62|       |/// Creates a url-encoded query string to be set as or appended to any existing URL query string or set as the HTTP
   63|       |/// body of the URL request. Whether the query string is set or appended to any existing URL query string or set as
   64|       |/// the HTTP body depends on the destination of the encoding.
   65|       |///
   66|       |/// The `Content-Type` HTTP header field of an encoded request with HTTP body is set to
   67|       |/// `application/x-www-form-urlencoded; charset=utf-8`.
   68|       |///
   69|       |/// There is no published specification for how to encode collection types. By default the convention of appending
   70|       |/// `[]` to the key for array values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for
   71|       |/// nested dictionary values (`foo[bar]=baz`) is used. Optionally, `ArrayEncoding` can be used to omit the
   72|       |/// square brackets appended to array keys.
   73|       |///
   74|       |/// `BoolEncoding` can be used to configure how boolean values are encoded. The default behavior is to encode
   75|       |/// `true` as 1 and `false` as 0.
   76|       |public struct URLEncoding: ParameterEncoding {
   77|       |
   78|       |    // MARK: Helper Types
   79|       |
   80|       |    /// Defines whether the url-encoded query string is applied to the existing query string or HTTP body of the
   81|       |    /// resulting URL request.
   82|       |    ///
   83|       |    /// - methodDependent: Applies encoded query string result to existing query string for `GET`, `HEAD` and `DELETE`
   84|       |    ///                    requests and sets as the HTTP body for requests with any other HTTP method.
   85|       |    /// - queryString:     Sets or appends encoded query string result to existing query string.
   86|       |    /// - httpBody:        Sets encoded query string result as the HTTP body of the URL request.
   87|       |    public enum Destination {
   88|       |        case methodDependent, queryString, httpBody
   89|       |    }
   90|       |
   91|       |    /// Configures how `Array` parameters are encoded.
   92|       |    ///
   93|       |    /// - brackets:        An empty set of square brackets is appended to the key for every value.
   94|       |    ///                    This is the default behavior.
   95|       |    /// - noBrackets:      No brackets are appended. The key is encoded as is.
   96|       |    public enum ArrayEncoding {
   97|       |        case brackets, noBrackets
   98|       |
   99|      0|        func encode(key: String) -> String {
  100|      0|            switch self {
  101|      0|            case .brackets:
  102|      0|                return "\(key)[]"
  103|      0|            case .noBrackets:
  104|      0|                return key
  105|      0|            }
  106|      0|        }
  107|       |    }
  108|       |
  109|       |    /// Configures how `Bool` parameters are encoded.
  110|       |    ///
  111|       |    /// - numeric:         Encode `true` as `1` and `false` as `0`. This is the default behavior.
  112|       |    /// - literal:         Encode `true` and `false` as string literals.
  113|       |    public enum BoolEncoding {
  114|       |        case numeric, literal
  115|       |
  116|      0|        func encode(value: Bool) -> String {
  117|      0|            switch self {
  118|      0|            case .numeric:
  119|      0|                return value ? "1" : "0"
  120|      0|            case .literal:
  121|      0|                return value ? "true" : "false"
  122|      0|            }
  123|      0|        }
  124|       |    }
  125|       |
  126|       |    // MARK: Properties
  127|       |
  128|       |    /// Returns a default `URLEncoding` instance.
  129|    495|    public static var `default`: URLEncoding { return URLEncoding() }
  130|       |
  131|       |    /// Returns a `URLEncoding` instance with a `.methodDependent` destination.
  132|      0|    public static var methodDependent: URLEncoding { return URLEncoding() }
  133|       |
  134|       |    /// Returns a `URLEncoding` instance with a `.queryString` destination.
  135|      0|    public static var queryString: URLEncoding { return URLEncoding(destination: .queryString) }
  136|       |
  137|       |    /// Returns a `URLEncoding` instance with an `.httpBody` destination.
  138|      0|    public static var httpBody: URLEncoding { return URLEncoding(destination: .httpBody) }
  139|       |
  140|       |    /// The destination defining where the encoded query string is to be applied to the URL request.
  141|       |    public let destination: Destination
  142|       |
  143|       |    /// The encoding to use for `Array` parameters.
  144|       |    public let arrayEncoding: ArrayEncoding
  145|       |
  146|       |    /// The encoding to use for `Bool` parameters.
  147|       |    public let boolEncoding: BoolEncoding
  148|       |
  149|       |    // MARK: Initialization
  150|       |
  151|       |    /// Creates a `URLEncoding` instance using the specified destination.
  152|       |    ///
  153|       |    /// - parameter destination: The destination defining where the encoded query string is to be applied.
  154|       |    /// - parameter arrayEncoding: The encoding to use for `Array` parameters.
  155|       |    /// - parameter boolEncoding: The encoding to use for `Bool` parameters.
  156|       |    ///
  157|       |    /// - returns: The new `URLEncoding` instance.
  158|    495|    public init(destination: Destination = .methodDependent, arrayEncoding: ArrayEncoding = .brackets, boolEncoding: BoolEncoding = .numeric) {
  159|    495|        self.destination = destination
  160|    495|        self.arrayEncoding = arrayEncoding
  161|    495|        self.boolEncoding = boolEncoding
  162|    495|    }
  163|       |
  164|       |    // MARK: Encoding
  165|       |
  166|       |    /// Creates a URL request by encoding parameters and applying them onto an existing request.
  167|       |    ///
  168|       |    /// - parameter urlRequest: The request to have parameters applied.
  169|       |    /// - parameter parameters: The parameters to apply.
  170|       |    ///
  171|       |    /// - throws: An `Error` if the encoding process encounters an error.
  172|       |    ///
  173|       |    /// - returns: The encoded request.
  174|    474|    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
  175|    474|        var urlRequest = try urlRequest.asURLRequest()
  176|    474|
  177|    474|        guard let parameters = parameters else { return urlRequest }
  178|      0|
  179|      0|        if let method = HTTPMethod(rawValue: urlRequest.httpMethod ?? "GET"), encodesParametersInURL(with: method) {
  180|      0|            guard let url = urlRequest.url else {
  181|      0|                throw AFError.parameterEncodingFailed(reason: .missingURL)
  182|      0|            }
  183|      0|
  184|      0|            if var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false), !parameters.isEmpty {
  185|      0|                let percentEncodedQuery = (urlComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
  186|      0|                urlComponents.percentEncodedQuery = percentEncodedQuery
  187|      0|                urlRequest.url = urlComponents.url
  188|      0|            }
  189|      0|        } else {
  190|      0|            if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil {
  191|      0|                urlRequest.setValue("application/x-www-form-urlencoded; charset=utf-8", forHTTPHeaderField: "Content-Type")
  192|      0|            }
  193|      0|
  194|      0|            urlRequest.httpBody = query(parameters).data(using: .utf8, allowLossyConversion: false)
  195|      0|        }
  196|      0|
  197|      0|        return urlRequest
  198|      0|    }
  199|       |
  200|       |    /// Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
  201|       |    ///
  202|       |    /// - parameter key:   The key of the query component.
  203|       |    /// - parameter value: The value of the query component.
  204|       |    ///
  205|       |    /// - returns: The percent-escaped, URL encoded query string components.
  206|      0|    public func queryComponents(fromKey key: String, value: Any) -> [(String, String)] {
  207|      0|        var components: [(String, String)] = []
  208|      0|
  209|      0|        if let dictionary = value as? [String: Any] {
  210|      0|            for (nestedKey, value) in dictionary {
  211|      0|                components += queryComponents(fromKey: "\(key)[\(nestedKey)]", value: value)
  212|      0|            }
  213|      0|        } else if let array = value as? [Any] {
  214|      0|            for value in array {
  215|      0|                components += queryComponents(fromKey: arrayEncoding.encode(key: key), value: value)
  216|      0|            }
  217|      0|        } else if let value = value as? NSNumber {
  218|      0|            if value.isBool {
  219|      0|                components.append((escape(key), escape(boolEncoding.encode(value: value.boolValue))))
  220|      0|            } else {
  221|      0|                components.append((escape(key), escape("\(value)")))
  222|      0|            }
  223|      0|        } else if let bool = value as? Bool {
  224|      0|            components.append((escape(key), escape(boolEncoding.encode(value: bool))))
  225|      0|        } else {
  226|      0|            components.append((escape(key), escape("\(value)")))
  227|      0|        }
  228|      0|
  229|      0|        return components
  230|      0|    }
  231|       |
  232|       |    /// Returns a percent-escaped string following RFC 3986 for a query string key or value.
  233|       |    ///
  234|       |    /// RFC 3986 states that the following characters are "reserved" characters.
  235|       |    ///
  236|       |    /// - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
  237|       |    /// - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
  238|       |    ///
  239|       |    /// In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
  240|       |    /// query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
  241|       |    /// should be percent-escaped in the query string.
  242|       |    ///
  243|       |    /// - parameter string: The string to be percent-escaped.
  244|       |    ///
  245|       |    /// - returns: The percent-escaped string.
  246|      0|    public func escape(_ string: String) -> String {
  247|      0|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
  248|      0|        let subDelimitersToEncode = "!$&'()*+,;="
  249|      0|
  250|      0|        var allowedCharacterSet = CharacterSet.urlQueryAllowed
  251|      0|        allowedCharacterSet.remove(charactersIn: "\(generalDelimitersToEncode)\(subDelimitersToEncode)")
  252|      0|
  253|      0|        var escaped = ""
  254|      0|
  255|      0|        //==========================================================================================================
  256|      0|        //
  257|      0|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
  258|      0|        //  hundred Chinese characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
  259|      0|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
  260|      0|        //  info, please refer to:
  261|      0|        //
  262|      0|        //      - https://github.com/Alamofire/Alamofire/issues/206
  263|      0|        //
  264|      0|        //==========================================================================================================
  265|      0|
  266|      0|        if #available(iOS 8.3, *) {
  267|      0|            escaped = string.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet) ?? string
  268|      0|        } else {
  269|      0|            let batchSize = 50
  270|      0|            var index = string.startIndex
  271|      0|
  272|      0|            while index != string.endIndex {
  273|      0|                let startIndex = index
  274|      0|                let endIndex = string.index(index, offsetBy: batchSize, limitedBy: string.endIndex) ?? string.endIndex
  275|      0|                let range = startIndex..<endIndex
  276|      0|
  277|      0|                let substring = string[range]
  278|      0|
  279|      0|                escaped += substring.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet) ?? String(substring)
  280|      0|
  281|      0|                index = endIndex
  282|      0|            }
  283|      0|        }
  284|      0|
  285|      0|        return escaped
  286|      0|    }
  287|       |
  288|      0|    private func query(_ parameters: [String: Any]) -> String {
  289|      0|        var components: [(String, String)] = []
  290|      0|
  291|      0|        for key in parameters.keys.sorted(by: <) {
  292|      0|            let value = parameters[key]!
  293|      0|            components += queryComponents(fromKey: key, value: value)
  294|      0|        }
  295|      0|        return components.map { "\($0)=\($1)" }.joined(separator: "&")
  296|      0|    }
  297|       |
  298|      0|    private func encodesParametersInURL(with method: HTTPMethod) -> Bool {
  299|      0|        switch destination {
  300|      0|        case .queryString:
  301|      0|            return true
  302|      0|        case .httpBody:
  303|      0|            return false
  304|      0|        default:
  305|      0|            break
  306|      0|        }
  307|      0|
  308|      0|        switch method {
  309|      0|        case .get, .head, .delete:
  310|      0|            return true
  311|      0|        default:
  312|      0|            return false
  313|      0|        }
  314|      0|    }
  315|       |}
  316|       |
  317|       |// MARK: -
  318|       |
  319|       |/// Uses `JSONSerialization` to create a JSON representation of the parameters object, which is set as the body of the
  320|       |/// request. The `Content-Type` HTTP header field of an encoded request is set to `application/json`.
  321|       |public struct JSONEncoding: ParameterEncoding {
  322|       |
  323|       |    // MARK: Properties
  324|       |
  325|       |    /// Returns a `JSONEncoding` instance with default writing options.
  326|      0|    public static var `default`: JSONEncoding { return JSONEncoding() }
  327|       |
  328|       |    /// Returns a `JSONEncoding` instance with `.prettyPrinted` writing options.
  329|      0|    public static var prettyPrinted: JSONEncoding { return JSONEncoding(options: .prettyPrinted) }
  330|       |
  331|       |    /// The options for writing the parameters as JSON data.
  332|       |    public let options: JSONSerialization.WritingOptions
  333|       |
  334|       |    // MARK: Initialization
  335|       |
  336|       |    /// Creates a `JSONEncoding` instance using the specified options.
  337|       |    ///
  338|       |    /// - parameter options: The options for writing the parameters as JSON data.
  339|       |    ///
  340|       |    /// - returns: The new `JSONEncoding` instance.
  341|      0|    public init(options: JSONSerialization.WritingOptions = []) {
  342|      0|        self.options = options
  343|      0|    }
  344|       |
  345|       |    // MARK: Encoding
  346|       |
  347|       |    /// Creates a URL request by encoding parameters and applying them onto an existing request.
  348|       |    ///
  349|       |    /// - parameter urlRequest: The request to have parameters applied.
  350|       |    /// - parameter parameters: The parameters to apply.
  351|       |    ///
  352|       |    /// - throws: An `Error` if the encoding process encounters an error.
  353|       |    ///
  354|       |    /// - returns: The encoded request.
  355|      0|    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
  356|      0|        var urlRequest = try urlRequest.asURLRequest()
  357|      0|
  358|      0|        guard let parameters = parameters else { return urlRequest }
  359|      0|
  360|      0|        do {
  361|      0|            let data = try JSONSerialization.data(withJSONObject: parameters, options: options)
  362|      0|
  363|      0|            if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil {
  364|      0|                urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
  365|      0|            }
  366|      0|
  367|      0|            urlRequest.httpBody = data
  368|      0|        } catch {
  369|      0|            throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
  370|      0|        }
  371|      0|
  372|      0|        return urlRequest
  373|      0|    }
  374|       |
  375|       |    /// Creates a URL request by encoding the JSON object and setting the resulting data on the HTTP body.
  376|       |    ///
  377|       |    /// - parameter urlRequest: The request to apply the JSON object to.
  378|       |    /// - parameter jsonObject: The JSON object to apply to the request.
  379|       |    ///
  380|       |    /// - throws: An `Error` if the encoding process encounters an error.
  381|       |    ///
  382|       |    /// - returns: The encoded request.
  383|      0|    public func encode(_ urlRequest: URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> URLRequest {
  384|      0|        var urlRequest = try urlRequest.asURLRequest()
  385|      0|
  386|      0|        guard let jsonObject = jsonObject else { return urlRequest }
  387|      0|
  388|      0|        do {
  389|      0|            let data = try JSONSerialization.data(withJSONObject: jsonObject, options: options)
  390|      0|
  391|      0|            if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil {
  392|      0|                urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
  393|      0|            }
  394|      0|
  395|      0|            urlRequest.httpBody = data
  396|      0|        } catch {
  397|      0|            throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error))
  398|      0|        }
  399|      0|
  400|      0|        return urlRequest
  401|      0|    }
  402|       |}
  403|       |
  404|       |// MARK: -
  405|       |
  406|       |/// Uses `PropertyListSerialization` to create a plist representation of the parameters object, according to the
  407|       |/// associated format and write options values, which is set as the body of the request. The `Content-Type` HTTP header
  408|       |/// field of an encoded request is set to `application/x-plist`.
  409|       |public struct PropertyListEncoding: ParameterEncoding {
  410|       |
  411|       |    // MARK: Properties
  412|       |
  413|       |    /// Returns a default `PropertyListEncoding` instance.
  414|      0|    public static var `default`: PropertyListEncoding { return PropertyListEncoding() }
  415|       |
  416|       |    /// Returns a `PropertyListEncoding` instance with xml formatting and default writing options.
  417|      0|    public static var xml: PropertyListEncoding { return PropertyListEncoding(format: .xml) }
  418|       |
  419|       |    /// Returns a `PropertyListEncoding` instance with binary formatting and default writing options.
  420|      0|    public static var binary: PropertyListEncoding { return PropertyListEncoding(format: .binary) }
  421|       |
  422|       |    /// The property list serialization format.
  423|       |    public let format: PropertyListSerialization.PropertyListFormat
  424|       |
  425|       |    /// The options for writing the parameters as plist data.
  426|       |    public let options: PropertyListSerialization.WriteOptions
  427|       |
  428|       |    // MARK: Initialization
  429|       |
  430|       |    /// Creates a `PropertyListEncoding` instance using the specified format and options.
  431|       |    ///
  432|       |    /// - parameter format:  The property list serialization format.
  433|       |    /// - parameter options: The options for writing the parameters as plist data.
  434|       |    ///
  435|       |    /// - returns: The new `PropertyListEncoding` instance.
  436|       |    public init(
  437|       |        format: PropertyListSerialization.PropertyListFormat = .xml,
  438|       |        options: PropertyListSerialization.WriteOptions = 0)
  439|      0|    {
  440|      0|        self.format = format
  441|      0|        self.options = options
  442|      0|    }
  443|       |
  444|       |    // MARK: Encoding
  445|       |
  446|       |    /// Creates a URL request by encoding parameters and applying them onto an existing request.
  447|       |    ///
  448|       |    /// - parameter urlRequest: The request to have parameters applied.
  449|       |    /// - parameter parameters: The parameters to apply.
  450|       |    ///
  451|       |    /// - throws: An `Error` if the encoding process encounters an error.
  452|       |    ///
  453|       |    /// - returns: The encoded request.
  454|      0|    public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -> URLRequest {
  455|      0|        var urlRequest = try urlRequest.asURLRequest()
  456|      0|
  457|      0|        guard let parameters = parameters else { return urlRequest }
  458|      0|
  459|      0|        do {
  460|      0|            let data = try PropertyListSerialization.data(
  461|      0|                fromPropertyList: parameters,
  462|      0|                format: format,
  463|      0|                options: options
  464|      0|            )
  465|      0|
  466|      0|            if urlRequest.value(forHTTPHeaderField: "Content-Type") == nil {
  467|      0|                urlRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
  468|      0|            }
  469|      0|
  470|      0|            urlRequest.httpBody = data
  471|      0|        } catch {
  472|      0|            throw AFError.parameterEncodingFailed(reason: .propertyListEncodingFailed(error: error))
  473|      0|        }
  474|      0|
  475|      0|        return urlRequest
  476|      0|    }
  477|       |}
  478|       |
  479|       |// MARK: -
  480|       |
  481|       |extension NSNumber {
  482|      0|    fileprivate var isBool: Bool { return CFBooleanGetTypeID() == CFGetTypeID(self) }
  483|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/Request.swift:
    1|       |//
    2|       |//  Request.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// A type that can inspect and optionally adapt a `URLRequest` in some manner if necessary.
   28|       |public protocol RequestAdapter {
   29|       |    /// Inspects and adapts the specified `URLRequest` in some manner if necessary and returns the result.
   30|       |    ///
   31|       |    /// - parameter urlRequest: The URL request to adapt.
   32|       |    ///
   33|       |    /// - throws: An `Error` if the adaptation encounters an error.
   34|       |    ///
   35|       |    /// - returns: The adapted `URLRequest`.
   36|       |    func adapt(_ urlRequest: URLRequest) throws -> URLRequest
   37|       |}
   38|       |
   39|       |// MARK: -
   40|       |
   41|       |/// A closure executed when the `RequestRetrier` determines whether a `Request` should be retried or not.
   42|       |public typealias RequestRetryCompletion = (_ shouldRetry: Bool, _ timeDelay: TimeInterval) -> Void
   43|       |
   44|       |/// A type that determines whether a request should be retried after being executed by the specified session manager
   45|       |/// and encountering an error.
   46|       |public protocol RequestRetrier {
   47|       |    /// Determines whether the `Request` should be retried by calling the `completion` closure.
   48|       |    ///
   49|       |    /// This operation is fully asynchronous. Any amount of time can be taken to determine whether the request needs
   50|       |    /// to be retried. The one requirement is that the completion closure is called to ensure the request is properly
   51|       |    /// cleaned up after.
   52|       |    ///
   53|       |    /// - parameter manager:    The session manager the request was executed on.
   54|       |    /// - parameter request:    The request that failed due to the encountered error.
   55|       |    /// - parameter error:      The error encountered when executing the request.
   56|       |    /// - parameter completion: The completion closure to be executed when retry decision has been determined.
   57|       |    func should(_ manager: SessionManager, retry request: Request, with error: Error, completion: @escaping RequestRetryCompletion)
   58|       |}
   59|       |
   60|       |// MARK: -
   61|       |
   62|       |protocol TaskConvertible {
   63|       |    func task(session: URLSession, adapter: RequestAdapter?, queue: DispatchQueue) throws -> URLSessionTask
   64|       |}
   65|       |
   66|       |/// A dictionary of headers to apply to a `URLRequest`.
   67|       |public typealias HTTPHeaders = [String: String]
   68|       |
   69|       |// MARK: -
   70|       |
   71|       |/// Responsible for sending a request and receiving the response and associated data from the server, as well as
   72|       |/// managing its underlying `URLSessionTask`.
   73|       |open class Request {
   74|       |
   75|       |    // MARK: Helper Types
   76|       |
   77|       |    /// A closure executed when monitoring upload or download progress of a request.
   78|       |    public typealias ProgressHandler = (Progress) -> Void
   79|       |
   80|       |    enum RequestTask {
   81|       |        case data(TaskConvertible?, URLSessionTask?)
   82|       |        case download(TaskConvertible?, URLSessionTask?)
   83|       |        case upload(TaskConvertible?, URLSessionTask?)
   84|       |        case stream(TaskConvertible?, URLSessionTask?)
   85|       |    }
   86|       |
   87|       |    // MARK: Properties
   88|       |
   89|       |    /// The delegate for the underlying task.
   90|       |    open internal(set) var delegate: TaskDelegate {
   91|  9.67k|        get {
   92|  9.67k|            taskDelegateLock.lock() ; defer { taskDelegateLock.unlock() }
   93|  9.67k|            return taskDelegate
   94|  9.67k|        }
   95|      0|        set {
   96|      0|            taskDelegateLock.lock() ; defer { taskDelegateLock.unlock() }
   97|      0|            taskDelegate = newValue
   98|      0|        }
   99|       |    }
  100|       |
  101|       |    /// The underlying task.
  102|  2.47k|    open var task: URLSessionTask? { return delegate.task }
  103|       |
  104|       |    /// The session belonging to the underlying task.
  105|       |    public let session: URLSession
  106|       |
  107|       |    /// The request sent or to be sent to the server.
  108|    988|    open var request: URLRequest? { return task?.originalRequest }
  109|       |
  110|       |    /// The response received from the server, if any.
  111|    988|    open var response: HTTPURLResponse? { return task?.response as? HTTPURLResponse }
  112|       |
  113|       |    /// The number of times the request has been retried.
  114|       |    open internal(set) var retryCount: UInt = 0
  115|       |
  116|       |    let originalTask: TaskConvertible?
  117|       |
  118|       |    var startTime: CFAbsoluteTime?
  119|       |    var endTime: CFAbsoluteTime?
  120|       |
  121|       |    var validations: [() -> Void] = []
  122|       |
  123|       |    private var taskDelegate: TaskDelegate
  124|       |    private var taskDelegateLock = NSLock()
  125|       |
  126|       |    // MARK: Lifecycle
  127|       |
  128|    495|    init(session: URLSession, requestTask: RequestTask, error: Error? = nil) {
  129|    495|        self.session = session
  130|    495|
  131|    495|        switch requestTask {
  132|    495|        case .data(let originalTask, let task):
  133|    495|            taskDelegate = DataTaskDelegate(task: task)
  134|    495|            self.originalTask = originalTask
  135|    495|        case .download(let originalTask, let task):
  136|      0|            taskDelegate = DownloadTaskDelegate(task: task)
  137|      0|            self.originalTask = originalTask
  138|    495|        case .upload(let originalTask, let task):
  139|      0|            taskDelegate = UploadTaskDelegate(task: task)
  140|      0|            self.originalTask = originalTask
  141|    495|        case .stream(let originalTask, let task):
  142|      0|            taskDelegate = TaskDelegate(task: task)
  143|      0|            self.originalTask = originalTask
  144|    495|        }
  145|    495|
  146|    495|        delegate.error = error
  147|    495|        delegate.queue.addOperation { self.endTime = CFAbsoluteTimeGetCurrent() }
  148|    495|    }
  149|       |
  150|       |    // MARK: Authentication
  151|       |
  152|       |    /// Associates an HTTP Basic credential with the request.
  153|       |    ///
  154|       |    /// - parameter user:        The user.
  155|       |    /// - parameter password:    The password.
  156|       |    /// - parameter persistence: The URL credential persistence. `.ForSession` by default.
  157|       |    ///
  158|       |    /// - returns: The request.
  159|       |    @discardableResult
  160|       |    open func authenticate(
  161|       |        user: String,
  162|       |        password: String,
  163|       |        persistence: URLCredential.Persistence = .forSession)
  164|       |        -> Self
  165|      0|    {
  166|      0|        let credential = URLCredential(user: user, password: password, persistence: persistence)
  167|      0|        return authenticate(usingCredential: credential)
  168|      0|    }
  169|       |
  170|       |    /// Associates a specified credential with the request.
  171|       |    ///
  172|       |    /// - parameter credential: The credential.
  173|       |    ///
  174|       |    /// - returns: The request.
  175|       |    @discardableResult
  176|      0|    open func authenticate(usingCredential credential: URLCredential) -> Self {
  177|      0|        delegate.credential = credential
  178|      0|        return self
  179|      0|    }
  180|       |
  181|       |    /// Returns a base64 encoded basic authentication credential as an authorization header tuple.
  182|       |    ///
  183|       |    /// - parameter user:     The user.
  184|       |    /// - parameter password: The password.
  185|       |    ///
  186|       |    /// - returns: A tuple with Authorization header and credential value if encoding succeeds, `nil` otherwise.
  187|      0|    open class func authorizationHeader(user: String, password: String) -> (key: String, value: String)? {
  188|      0|        guard let data = "\(user):\(password)".data(using: .utf8) else { return nil }
  189|      0|
  190|      0|        let credential = data.base64EncodedString(options: [])
  191|      0|
  192|      0|        return (key: "Authorization", value: "Basic \(credential)")
  193|      0|    }
  194|       |
  195|       |    // MARK: State
  196|       |
  197|       |    /// Resumes the request.
  198|    495|    open func resume() {
  199|    495|        guard let task = task else { delegate.queue.isSuspended = false ; return }
  200|    474|
  201|    474|        if startTime == nil { startTime = CFAbsoluteTimeGetCurrent() }
  202|    474|
  203|    474|        task.resume()
  204|    474|
  205|    474|        NotificationCenter.default.post(
  206|    474|            name: Notification.Name.Task.DidResume,
  207|    474|            object: self,
  208|    474|            userInfo: [Notification.Key.Task: task]
  209|    474|        )
  210|    474|    }
  211|       |
  212|       |    /// Suspends the request.
  213|      0|    open func suspend() {
  214|      0|        guard let task = task else { return }
  215|      0|
  216|      0|        task.suspend()
  217|      0|
  218|      0|        NotificationCenter.default.post(
  219|      0|            name: Notification.Name.Task.DidSuspend,
  220|      0|            object: self,
  221|      0|            userInfo: [Notification.Key.Task: task]
  222|      0|        )
  223|      0|    }
  224|       |
  225|       |    /// Cancels the request.
  226|      0|    open func cancel() {
  227|      0|        guard let task = task else { return }
  228|      0|
  229|      0|        task.cancel()
  230|      0|
  231|      0|        NotificationCenter.default.post(
  232|      0|            name: Notification.Name.Task.DidCancel,
  233|      0|            object: self,
  234|      0|            userInfo: [Notification.Key.Task: task]
  235|      0|        )
  236|      0|    }
  237|       |}
  238|       |
  239|       |// MARK: - CustomStringConvertible
  240|       |
  241|       |extension Request: CustomStringConvertible {
  242|       |    /// The textual representation used when written to an output stream, which includes the HTTP method and URL, as
  243|       |    /// well as the response status code if a response has been received.
  244|      0|    open var description: String {
  245|      0|        var components: [String] = []
  246|      0|
  247|      0|        if let HTTPMethod = request?.httpMethod {
  248|      0|            components.append(HTTPMethod)
  249|      0|        }
  250|      0|
  251|      0|        if let urlString = request?.url?.absoluteString {
  252|      0|            components.append(urlString)
  253|      0|        }
  254|      0|
  255|      0|        if let response = response {
  256|      0|            components.append("(\(response.statusCode))")
  257|      0|        }
  258|      0|
  259|      0|        return components.joined(separator: " ")
  260|      0|    }
  261|       |}
  262|       |
  263|       |// MARK: - CustomDebugStringConvertible
  264|       |
  265|       |extension Request: CustomDebugStringConvertible {
  266|       |    /// The textual representation used when written to an output stream, in the form of a cURL command.
  267|      0|    open var debugDescription: String {
  268|      0|        return cURLRepresentation()
  269|      0|    }
  270|       |
  271|      0|    func cURLRepresentation() -> String {
  272|      0|        var components = ["$ curl -v"]
  273|      0|
  274|      0|        guard let request = self.request,
  275|      0|              let url = request.url,
  276|      0|              let host = url.host
  277|      0|        else {
  278|      0|            return "$ curl command could not be created"
  279|      0|        }
  280|      0|
  281|      0|        if let httpMethod = request.httpMethod, httpMethod != "GET" {
  282|      0|            components.append("-X \(httpMethod)")
  283|      0|        }
  284|      0|
  285|      0|        if let credentialStorage = self.session.configuration.urlCredentialStorage {
  286|      0|            let protectionSpace = URLProtectionSpace(
  287|      0|                host: host,
  288|      0|                port: url.port ?? 0,
  289|      0|                protocol: url.scheme,
  290|      0|                realm: host,
  291|      0|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
  292|      0|            )
  293|      0|
  294|      0|            if let credentials = credentialStorage.credentials(for: protectionSpace)?.values {
  295|      0|                for credential in credentials {
  296|      0|                    guard let user = credential.user, let password = credential.password else { continue }
  297|      0|                    components.append("-u \(user):\(password)")
  298|      0|                }
  299|      0|            } else {
  300|      0|                if let credential = delegate.credential, let user = credential.user, let password = credential.password {
  301|      0|                    components.append("-u \(user):\(password)")
  302|      0|                }
  303|      0|            }
  304|      0|        }
  305|      0|
  306|      0|        if session.configuration.httpShouldSetCookies {
  307|      0|            if
  308|      0|                let cookieStorage = session.configuration.httpCookieStorage,
  309|      0|                let cookies = cookieStorage.cookies(for: url), !cookies.isEmpty
  310|      0|            {
  311|      0|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value);" }
  312|      0|
  313|      0|            #if swift(>=3.2)
  314|      0|                components.append("-b \"\(string[..<string.index(before: string.endIndex)])\"")
  315|      0|            #else
  316|      0|                components.append("-b \"\(string.substring(to: string.characters.index(before: string.endIndex)))\"")
  317|      0|            #endif
  318|      0|            }
  319|      0|        }
  320|      0|
  321|      0|        var headers: [AnyHashable: Any] = [:]
  322|      0|
  323|      0|        session.configuration.httpAdditionalHeaders?.filter {  $0.0 != AnyHashable("Cookie") }
  324|      0|                                                    .forEach { headers[$0.0] = $0.1 }
  325|      0|
  326|      0|        request.allHTTPHeaderFields?.filter { $0.0 != "Cookie" }
  327|      0|                                    .forEach { headers[$0.0] = $0.1 }
  328|      0|
  329|      0|        components += headers.map {
  330|      0|            let escapedValue = String(describing: $0.value).replacingOccurrences(of: "\"", with: "\\\"")
  331|      0|
  332|      0|            return "-H \"\($0.key): \(escapedValue)\""
  333|      0|        }
  334|      0|
  335|      0|        if let httpBodyData = request.httpBody, let httpBody = String(data: httpBodyData, encoding: .utf8) {
  336|      0|            var escapedBody = httpBody.replacingOccurrences(of: "\\\"", with: "\\\\\"")
  337|      0|            escapedBody = escapedBody.replacingOccurrences(of: "\"", with: "\\\"")
  338|      0|
  339|      0|            components.append("-d \"\(escapedBody)\"")
  340|      0|        }
  341|      0|
  342|      0|        components.append("\"\(url.absoluteString)\"")
  343|      0|
  344|      0|        return components.joined(separator: " \\\n\t")
  345|      0|    }
  346|       |}
  347|       |
  348|       |// MARK: -
  349|       |
  350|       |/// Specific type of `Request` that manages an underlying `URLSessionDataTask`.
  351|       |open class DataRequest: Request {
  352|       |
  353|       |    // MARK: Helper Types
  354|       |
  355|       |    struct Requestable: TaskConvertible {
  356|       |        let urlRequest: URLRequest
  357|       |
  358|    474|        func task(session: URLSession, adapter: RequestAdapter?, queue: DispatchQueue) throws -> URLSessionTask {
  359|    474|            do {
  360|    474|                let urlRequest = try self.urlRequest.adapt(using: adapter)
  361|    474|                return queue.sync { session.dataTask(with: urlRequest) }
  362|    474|            } catch {
  363|      0|                throw AdaptError(error: error)
  364|      0|            }
  365|      0|        }
  366|       |    }
  367|       |
  368|       |    // MARK: Properties
  369|       |
  370|       |    /// The request sent or to be sent to the server.
  371|    988|    open override var request: URLRequest? {
  372|    988|        if let request = super.request { return request }
  373|     42|        if let requestable = originalTask as? Requestable { return requestable.urlRequest }
  374|     42|
  375|     42|        return nil
  376|     42|    }
  377|       |
  378|       |    /// The progress of fetching the response data from the server for the request.
  379|      0|    open var progress: Progress { return dataDelegate.progress }
  380|       |
  381|      0|    var dataDelegate: DataTaskDelegate { return delegate as! DataTaskDelegate }
  382|       |
  383|       |    // MARK: Stream
  384|       |
  385|       |    /// Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
  386|       |    ///
  387|       |    /// This closure returns the bytes most recently received from the server, not including data from previous calls.
  388|       |    /// If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is
  389|       |    /// also important to note that the server data in any `Response` object will be `nil`.
  390|       |    ///
  391|       |    /// - parameter closure: The code to be executed periodically during the lifecycle of the request.
  392|       |    ///
  393|       |    /// - returns: The request.
  394|       |    @discardableResult
  395|      0|    open func stream(closure: ((Data) -> Void)? = nil) -> Self {
  396|      0|        dataDelegate.dataStream = closure
  397|      0|        return self
  398|      0|    }
  399|       |
  400|       |    // MARK: Progress
  401|       |
  402|       |    /// Sets a closure to be called periodically during the lifecycle of the `Request` as data is read from the server.
  403|       |    ///
  404|       |    /// - parameter queue:   The dispatch queue to execute the closure on.
  405|       |    /// - parameter closure: The code to be executed periodically as data is read from the server.
  406|       |    ///
  407|       |    /// - returns: The request.
  408|       |    @discardableResult
  409|      0|    open func downloadProgress(queue: DispatchQueue = DispatchQueue.main, closure: @escaping ProgressHandler) -> Self {
  410|      0|        dataDelegate.progressHandler = (closure, queue)
  411|      0|        return self
  412|      0|    }
  413|       |}
  414|       |
  415|       |// MARK: -
  416|       |
  417|       |/// Specific type of `Request` that manages an underlying `URLSessionDownloadTask`.
  418|       |open class DownloadRequest: Request {
  419|       |
  420|       |    // MARK: Helper Types
  421|       |
  422|       |    /// A collection of options to be executed prior to moving a downloaded file from the temporary URL to the
  423|       |    /// destination URL.
  424|       |    public struct DownloadOptions: OptionSet {
  425|       |        /// Returns the raw bitmask value of the option and satisfies the `RawRepresentable` protocol.
  426|       |        public let rawValue: UInt
  427|       |
  428|       |        /// A `DownloadOptions` flag that creates intermediate directories for the destination URL if specified.
  429|       |        public static let createIntermediateDirectories = DownloadOptions(rawValue: 1 << 0)
  430|       |
  431|       |        /// A `DownloadOptions` flag that removes a previous file from the destination URL if specified.
  432|       |        public static let removePreviousFile = DownloadOptions(rawValue: 1 << 1)
  433|       |
  434|       |        /// Creates a `DownloadFileDestinationOptions` instance with the specified raw value.
  435|       |        ///
  436|       |        /// - parameter rawValue: The raw bitmask value for the option.
  437|       |        ///
  438|       |        /// - returns: A new log level instance.
  439|      0|        public init(rawValue: UInt) {
  440|      0|            self.rawValue = rawValue
  441|      0|        }
  442|       |    }
  443|       |
  444|       |    /// A closure executed once a download request has successfully completed in order to determine where to move the
  445|       |    /// temporary file written to during the download process. The closure takes two arguments: the temporary file URL
  446|       |    /// and the URL response, and returns a two arguments: the file URL where the temporary file should be moved and
  447|       |    /// the options defining how the file should be moved.
  448|       |    public typealias DownloadFileDestination = (
  449|       |        _ temporaryURL: URL,
  450|       |        _ response: HTTPURLResponse)
  451|       |        -> (destinationURL: URL, options: DownloadOptions)
  452|       |
  453|       |    enum Downloadable: TaskConvertible {
  454|       |        case request(URLRequest)
  455|       |        case resumeData(Data)
  456|       |
  457|      0|        func task(session: URLSession, adapter: RequestAdapter?, queue: DispatchQueue) throws -> URLSessionTask {
  458|      0|            do {
  459|      0|                let task: URLSessionTask
  460|      0|
  461|      0|                switch self {
  462|      0|                case let .request(urlRequest):
  463|      0|                    let urlRequest = try urlRequest.adapt(using: adapter)
  464|      0|                    task = queue.sync { session.downloadTask(with: urlRequest) }
  465|      0|                case let .resumeData(resumeData):
  466|      0|                    task = queue.sync { session.downloadTask(withResumeData: resumeData) }
  467|      0|                }
  468|      0|
  469|      0|                return task
  470|      0|            } catch {
  471|      0|                throw AdaptError(error: error)
  472|      0|            }
  473|      0|        }
  474|       |    }
  475|       |
  476|       |    // MARK: Properties
  477|       |
  478|       |    /// The request sent or to be sent to the server.
  479|      0|    open override var request: URLRequest? {
  480|      0|        if let request = super.request { return request }
  481|      0|
  482|      0|        if let downloadable = originalTask as? Downloadable, case let .request(urlRequest) = downloadable {
  483|      0|            return urlRequest
  484|      0|        }
  485|      0|
  486|      0|        return nil
  487|      0|    }
  488|       |
  489|       |    /// The resume data of the underlying download task if available after a failure.
  490|      0|    open var resumeData: Data? { return downloadDelegate.resumeData }
  491|       |
  492|       |    /// The progress of downloading the response data from the server for the request.
  493|      0|    open var progress: Progress { return downloadDelegate.progress }
  494|       |
  495|      0|    var downloadDelegate: DownloadTaskDelegate { return delegate as! DownloadTaskDelegate }
  496|       |
  497|       |    // MARK: State
  498|       |
  499|       |    /// Cancels the request.
  500|      0|    open override func cancel() {
  501|      0|        downloadDelegate.downloadTask.cancel { self.downloadDelegate.resumeData = $0 }
  502|      0|
  503|      0|        NotificationCenter.default.post(
  504|      0|            name: Notification.Name.Task.DidCancel,
  505|      0|            object: self,
  506|      0|            userInfo: [Notification.Key.Task: task as Any]
  507|      0|        )
  508|      0|    }
  509|       |
  510|       |    // MARK: Progress
  511|       |
  512|       |    /// Sets a closure to be called periodically during the lifecycle of the `Request` as data is read from the server.
  513|       |    ///
  514|       |    /// - parameter queue:   The dispatch queue to execute the closure on.
  515|       |    /// - parameter closure: The code to be executed periodically as data is read from the server.
  516|       |    ///
  517|       |    /// - returns: The request.
  518|       |    @discardableResult
  519|      0|    open func downloadProgress(queue: DispatchQueue = DispatchQueue.main, closure: @escaping ProgressHandler) -> Self {
  520|      0|        downloadDelegate.progressHandler = (closure, queue)
  521|      0|        return self
  522|      0|    }
  523|       |
  524|       |    // MARK: Destination
  525|       |
  526|       |    /// Creates a download file destination closure which uses the default file manager to move the temporary file to a
  527|       |    /// file URL in the first available directory with the specified search path directory and search path domain mask.
  528|       |    ///
  529|       |    /// - parameter directory: The search path directory. `.DocumentDirectory` by default.
  530|       |    /// - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
  531|       |    ///
  532|       |    /// - returns: A download file destination closure.
  533|       |    open class func suggestedDownloadDestination(
  534|       |        for directory: FileManager.SearchPathDirectory = .documentDirectory,
  535|       |        in domain: FileManager.SearchPathDomainMask = .userDomainMask)
  536|       |        -> DownloadFileDestination
  537|      0|    {
  538|      0|        return { temporaryURL, response in
  539|      0|            let directoryURLs = FileManager.default.urls(for: directory, in: domain)
  540|      0|
  541|      0|            if !directoryURLs.isEmpty {
  542|      0|                return (directoryURLs[0].appendingPathComponent(response.suggestedFilename!), [])
  543|      0|            }
  544|      0|
  545|      0|            return (temporaryURL, [])
  546|      0|        }
  547|      0|    }
  548|       |}
  549|       |
  550|       |// MARK: -
  551|       |
  552|       |/// Specific type of `Request` that manages an underlying `URLSessionUploadTask`.
  553|       |open class UploadRequest: DataRequest {
  554|       |
  555|       |    // MARK: Helper Types
  556|       |
  557|       |    enum Uploadable: TaskConvertible {
  558|       |        case data(Data, URLRequest)
  559|       |        case file(URL, URLRequest)
  560|       |        case stream(InputStream, URLRequest)
  561|       |
  562|      0|        func task(session: URLSession, adapter: RequestAdapter?, queue: DispatchQueue) throws -> URLSessionTask {
  563|      0|            do {
  564|      0|                let task: URLSessionTask
  565|      0|
  566|      0|                switch self {
  567|      0|                case let .data(data, urlRequest):
  568|      0|                    let urlRequest = try urlRequest.adapt(using: adapter)
  569|      0|                    task = queue.sync { session.uploadTask(with: urlRequest, from: data) }
  570|      0|                case let .file(url, urlRequest):
  571|      0|                    let urlRequest = try urlRequest.adapt(using: adapter)
  572|      0|                    task = queue.sync { session.uploadTask(with: urlRequest, fromFile: url) }
  573|      0|                case let .stream(_, urlRequest):
  574|      0|                    let urlRequest = try urlRequest.adapt(using: adapter)
  575|      0|                    task = queue.sync { session.uploadTask(withStreamedRequest: urlRequest) }
  576|      0|                }
  577|      0|
  578|      0|                return task
  579|      0|            } catch {
  580|      0|                throw AdaptError(error: error)
  581|      0|            }
  582|      0|        }
  583|       |    }
  584|       |
  585|       |    // MARK: Properties
  586|       |
  587|       |    /// The request sent or to be sent to the server.
  588|      0|    open override var request: URLRequest? {
  589|      0|        if let request = super.request { return request }
  590|      0|
  591|      0|        guard let uploadable = originalTask as? Uploadable else { return nil }
  592|      0|
  593|      0|        switch uploadable {
  594|      0|        case .data(_, let urlRequest), .file(_, let urlRequest), .stream(_, let urlRequest):
  595|      0|            return urlRequest
  596|      0|        }
  597|      0|    }
  598|       |
  599|       |    /// The progress of uploading the payload to the server for the upload request.
  600|      0|    open var uploadProgress: Progress { return uploadDelegate.uploadProgress }
  601|       |
  602|      0|    var uploadDelegate: UploadTaskDelegate { return delegate as! UploadTaskDelegate }
  603|       |
  604|       |    // MARK: Upload Progress
  605|       |
  606|       |    /// Sets a closure to be called periodically during the lifecycle of the `UploadRequest` as data is sent to
  607|       |    /// the server.
  608|       |    ///
  609|       |    /// After the data is sent to the server, the `progress(queue:closure:)` APIs can be used to monitor the progress
  610|       |    /// of data being read from the server.
  611|       |    ///
  612|       |    /// - parameter queue:   The dispatch queue to execute the closure on.
  613|       |    /// - parameter closure: The code to be executed periodically as data is sent to the server.
  614|       |    ///
  615|       |    /// - returns: The request.
  616|       |    @discardableResult
  617|      0|    open func uploadProgress(queue: DispatchQueue = DispatchQueue.main, closure: @escaping ProgressHandler) -> Self {
  618|      0|        uploadDelegate.uploadProgressHandler = (closure, queue)
  619|      0|        return self
  620|      0|    }
  621|       |}
  622|       |
  623|       |// MARK: -
  624|       |
  625|       |#if !os(watchOS)
  626|       |
  627|       |/// Specific type of `Request` that manages an underlying `URLSessionStreamTask`.
  628|       |@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  629|       |open class StreamRequest: Request {
  630|       |    enum Streamable: TaskConvertible {
  631|       |        case stream(hostName: String, port: Int)
  632|       |        case netService(NetService)
  633|       |
  634|      0|        func task(session: URLSession, adapter: RequestAdapter?, queue: DispatchQueue) throws -> URLSessionTask {
  635|      0|            let task: URLSessionTask
  636|      0|
  637|      0|            switch self {
  638|      0|            case let .stream(hostName, port):
  639|      0|                task = queue.sync { session.streamTask(withHostName: hostName, port: port) }
  640|      0|            case let .netService(netService):
  641|      0|                task = queue.sync { session.streamTask(with: netService) }
  642|      0|            }
  643|      0|
  644|      0|            return task
  645|      0|        }
  646|       |    }
  647|       |}
  648|       |
  649|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/Response.swift:
    1|       |//
    2|       |//  Response.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Used to store all data associated with an non-serialized response of a data or upload request.
   28|       |public struct DefaultDataResponse {
   29|       |    /// The URL request sent to the server.
   30|       |    public let request: URLRequest?
   31|       |
   32|       |    /// The server's response to the URL request.
   33|       |    public let response: HTTPURLResponse?
   34|       |
   35|       |    /// The data returned by the server.
   36|       |    public let data: Data?
   37|       |
   38|       |    /// The error encountered while executing or validating the request.
   39|       |    public let error: Error?
   40|       |
   41|       |    /// The timeline of the complete lifecycle of the request.
   42|       |    public let timeline: Timeline
   43|       |
   44|       |    var _metrics: AnyObject?
   45|       |
   46|       |    /// Creates a `DefaultDataResponse` instance from the specified parameters.
   47|       |    ///
   48|       |    /// - Parameters:
   49|       |    ///   - request:  The URL request sent to the server.
   50|       |    ///   - response: The server's response to the URL request.
   51|       |    ///   - data:     The data returned by the server.
   52|       |    ///   - error:    The error encountered while executing or validating the request.
   53|       |    ///   - timeline: The timeline of the complete lifecycle of the request. `Timeline()` by default.
   54|       |    ///   - metrics:  The task metrics containing the request / response statistics. `nil` by default.
   55|       |    public init(
   56|       |        request: URLRequest?,
   57|       |        response: HTTPURLResponse?,
   58|       |        data: Data?,
   59|       |        error: Error?,
   60|       |        timeline: Timeline = Timeline(),
   61|       |        metrics: AnyObject? = nil)
   62|      0|    {
   63|      0|        self.request = request
   64|      0|        self.response = response
   65|      0|        self.data = data
   66|      0|        self.error = error
   67|      0|        self.timeline = timeline
   68|      0|    }
   69|       |}
   70|       |
   71|       |// MARK: -
   72|       |
   73|       |/// Used to store all data associated with a serialized response of a data or upload request.
   74|       |public struct DataResponse<Value> {
   75|       |    /// The URL request sent to the server.
   76|       |    public let request: URLRequest?
   77|       |
   78|       |    /// The server's response to the URL request.
   79|       |    public let response: HTTPURLResponse?
   80|       |
   81|       |    /// The data returned by the server.
   82|       |    public let data: Data?
   83|       |
   84|       |    /// The result of response serialization.
   85|       |    public let result: Result<Value>
   86|       |
   87|       |    /// The timeline of the complete lifecycle of the request.
   88|       |    public let timeline: Timeline
   89|       |
   90|       |    /// Returns the associated value of the result if it is a success, `nil` otherwise.
   91|      0|    public var value: Value? { return result.value }
   92|       |
   93|       |    /// Returns the associated error value if the result if it is a failure, `nil` otherwise.
   94|      0|    public var error: Error? { return result.error }
   95|       |
   96|       |    var _metrics: AnyObject?
   97|       |
   98|       |    /// Creates a `DataResponse` instance with the specified parameters derived from response serialization.
   99|       |    ///
  100|       |    /// - parameter request:  The URL request sent to the server.
  101|       |    /// - parameter response: The server's response to the URL request.
  102|       |    /// - parameter data:     The data returned by the server.
  103|       |    /// - parameter result:   The result of response serialization.
  104|       |    /// - parameter timeline: The timeline of the complete lifecycle of the `Request`. Defaults to `Timeline()`.
  105|       |    ///
  106|       |    /// - returns: The new `DataResponse` instance.
  107|       |    public init(
  108|       |        request: URLRequest?,
  109|       |        response: HTTPURLResponse?,
  110|       |        data: Data?,
  111|       |        result: Result<Value>,
  112|       |        timeline: Timeline = Timeline())
  113|    494|    {
  114|    494|        self.request = request
  115|    494|        self.response = response
  116|    494|        self.data = data
  117|    494|        self.result = result
  118|    494|        self.timeline = timeline
  119|    494|    }
  120|       |}
  121|       |
  122|       |// MARK: -
  123|       |
  124|       |extension DataResponse: CustomStringConvertible, CustomDebugStringConvertible {
  125|       |    /// The textual representation used when written to an output stream, which includes whether the result was a
  126|       |    /// success or failure.
  127|      0|    public var description: String {
  128|      0|        return result.debugDescription
  129|      0|    }
  130|       |
  131|       |    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
  132|       |    /// response, the server data, the response serialization result and the timeline.
  133|      0|    public var debugDescription: String {
  134|      0|        var output: [String] = []
  135|      0|
  136|      0|        output.append(request != nil ? "[Request]: \(request!.httpMethod ?? "GET") \(request!)" : "[Request]: nil")
  137|      0|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
  138|      0|        output.append("[Data]: \(data?.count ?? 0) bytes")
  139|      0|        output.append("[Result]: \(result.debugDescription)")
  140|      0|        output.append("[Timeline]: \(timeline.debugDescription)")
  141|      0|
  142|      0|        return output.joined(separator: "\n")
  143|      0|    }
  144|       |}
  145|       |
  146|       |// MARK: -
  147|       |
  148|       |extension DataResponse {
  149|       |    /// Evaluates the specified closure when the result of this `DataResponse` is a success, passing the unwrapped
  150|       |    /// result value as a parameter.
  151|       |    ///
  152|       |    /// Use the `map` method with a closure that does not throw. For example:
  153|       |    ///
  154|       |    ///     let possibleData: DataResponse<Data> = ...
  155|       |    ///     let possibleInt = possibleData.map { $0.count }
  156|       |    ///
  157|       |    /// - parameter transform: A closure that takes the success value of the instance's result.
  158|       |    ///
  159|       |    /// - returns: A `DataResponse` whose result wraps the value returned by the given closure. If this instance's
  160|       |    ///            result is a failure, returns a response wrapping the same failure.
  161|      0|    public func map<T>(_ transform: (Value) -> T) -> DataResponse<T> {
  162|      0|        var response = DataResponse<T>(
  163|      0|            request: request,
  164|      0|            response: self.response,
  165|      0|            data: data,
  166|      0|            result: result.map(transform),
  167|      0|            timeline: timeline
  168|      0|        )
  169|      0|
  170|      0|        response._metrics = _metrics
  171|      0|
  172|      0|        return response
  173|      0|    }
  174|       |
  175|       |    /// Evaluates the given closure when the result of this `DataResponse` is a success, passing the unwrapped result
  176|       |    /// value as a parameter.
  177|       |    ///
  178|       |    /// Use the `flatMap` method with a closure that may throw an error. For example:
  179|       |    ///
  180|       |    ///     let possibleData: DataResponse<Data> = ...
  181|       |    ///     let possibleObject = possibleData.flatMap {
  182|       |    ///         try JSONSerialization.jsonObject(with: $0)
  183|       |    ///     }
  184|       |    ///
  185|       |    /// - parameter transform: A closure that takes the success value of the instance's result.
  186|       |    ///
  187|       |    /// - returns: A success or failure `DataResponse` depending on the result of the given closure. If this instance's
  188|       |    ///            result is a failure, returns the same failure.
  189|      0|    public func flatMap<T>(_ transform: (Value) throws -> T) -> DataResponse<T> {
  190|      0|        var response = DataResponse<T>(
  191|      0|            request: request,
  192|      0|            response: self.response,
  193|      0|            data: data,
  194|      0|            result: result.flatMap(transform),
  195|      0|            timeline: timeline
  196|      0|        )
  197|      0|
  198|      0|        response._metrics = _metrics
  199|      0|
  200|      0|        return response
  201|      0|    }
  202|       |
  203|       |    /// Evaluates the specified closure when the `DataResponse` is a failure, passing the unwrapped error as a parameter.
  204|       |    ///
  205|       |    /// Use the `mapError` function with a closure that does not throw. For example:
  206|       |    ///
  207|       |    ///     let possibleData: DataResponse<Data> = ...
  208|       |    ///     let withMyError = possibleData.mapError { MyError.error($0) }
  209|       |    ///
  210|       |    /// - Parameter transform: A closure that takes the error of the instance.
  211|       |    /// - Returns: A `DataResponse` instance containing the result of the transform.
  212|      0|    public func mapError<E: Error>(_ transform: (Error) -> E) -> DataResponse {
  213|      0|        var response = DataResponse(
  214|      0|            request: request,
  215|      0|            response: self.response,
  216|      0|            data: data,
  217|      0|            result: result.mapError(transform),
  218|      0|            timeline: timeline
  219|      0|        )
  220|      0|
  221|      0|        response._metrics = _metrics
  222|      0|
  223|      0|        return response
  224|      0|    }
  225|       |
  226|       |    /// Evaluates the specified closure when the `DataResponse` is a failure, passing the unwrapped error as a parameter.
  227|       |    ///
  228|       |    /// Use the `flatMapError` function with a closure that may throw an error. For example:
  229|       |    ///
  230|       |    ///     let possibleData: DataResponse<Data> = ...
  231|       |    ///     let possibleObject = possibleData.flatMapError {
  232|       |    ///         try someFailableFunction(taking: $0)
  233|       |    ///     }
  234|       |    ///
  235|       |    /// - Parameter transform: A throwing closure that takes the error of the instance.
  236|       |    ///
  237|       |    /// - Returns: A `DataResponse` instance containing the result of the transform.
  238|      0|    public func flatMapError<E: Error>(_ transform: (Error) throws -> E) -> DataResponse {
  239|      0|        var response = DataResponse(
  240|      0|            request: request,
  241|      0|            response: self.response,
  242|      0|            data: data,
  243|      0|            result: result.flatMapError(transform),
  244|      0|            timeline: timeline
  245|      0|        )
  246|      0|
  247|      0|        response._metrics = _metrics
  248|      0|
  249|      0|        return response
  250|      0|    }
  251|       |}
  252|       |
  253|       |// MARK: -
  254|       |
  255|       |/// Used to store all data associated with an non-serialized response of a download request.
  256|       |public struct DefaultDownloadResponse {
  257|       |    /// The URL request sent to the server.
  258|       |    public let request: URLRequest?
  259|       |
  260|       |    /// The server's response to the URL request.
  261|       |    public let response: HTTPURLResponse?
  262|       |
  263|       |    /// The temporary destination URL of the data returned from the server.
  264|       |    public let temporaryURL: URL?
  265|       |
  266|       |    /// The final destination URL of the data returned from the server if it was moved.
  267|       |    public let destinationURL: URL?
  268|       |
  269|       |    /// The resume data generated if the request was cancelled.
  270|       |    public let resumeData: Data?
  271|       |
  272|       |    /// The error encountered while executing or validating the request.
  273|       |    public let error: Error?
  274|       |
  275|       |    /// The timeline of the complete lifecycle of the request.
  276|       |    public let timeline: Timeline
  277|       |
  278|       |    var _metrics: AnyObject?
  279|       |
  280|       |    /// Creates a `DefaultDownloadResponse` instance from the specified parameters.
  281|       |    ///
  282|       |    /// - Parameters:
  283|       |    ///   - request:        The URL request sent to the server.
  284|       |    ///   - response:       The server's response to the URL request.
  285|       |    ///   - temporaryURL:   The temporary destination URL of the data returned from the server.
  286|       |    ///   - destinationURL: The final destination URL of the data returned from the server if it was moved.
  287|       |    ///   - resumeData:     The resume data generated if the request was cancelled.
  288|       |    ///   - error:          The error encountered while executing or validating the request.
  289|       |    ///   - timeline:       The timeline of the complete lifecycle of the request. `Timeline()` by default.
  290|       |    ///   - metrics:        The task metrics containing the request / response statistics. `nil` by default.
  291|       |    public init(
  292|       |        request: URLRequest?,
  293|       |        response: HTTPURLResponse?,
  294|       |        temporaryURL: URL?,
  295|       |        destinationURL: URL?,
  296|       |        resumeData: Data?,
  297|       |        error: Error?,
  298|       |        timeline: Timeline = Timeline(),
  299|       |        metrics: AnyObject? = nil)
  300|      0|    {
  301|      0|        self.request = request
  302|      0|        self.response = response
  303|      0|        self.temporaryURL = temporaryURL
  304|      0|        self.destinationURL = destinationURL
  305|      0|        self.resumeData = resumeData
  306|      0|        self.error = error
  307|      0|        self.timeline = timeline
  308|      0|    }
  309|       |}
  310|       |
  311|       |// MARK: -
  312|       |
  313|       |/// Used to store all data associated with a serialized response of a download request.
  314|       |public struct DownloadResponse<Value> {
  315|       |    /// The URL request sent to the server.
  316|       |    public let request: URLRequest?
  317|       |
  318|       |    /// The server's response to the URL request.
  319|       |    public let response: HTTPURLResponse?
  320|       |
  321|       |    /// The temporary destination URL of the data returned from the server.
  322|       |    public let temporaryURL: URL?
  323|       |
  324|       |    /// The final destination URL of the data returned from the server if it was moved.
  325|       |    public let destinationURL: URL?
  326|       |
  327|       |    /// The resume data generated if the request was cancelled.
  328|       |    public let resumeData: Data?
  329|       |
  330|       |    /// The result of response serialization.
  331|       |    public let result: Result<Value>
  332|       |
  333|       |    /// The timeline of the complete lifecycle of the request.
  334|       |    public let timeline: Timeline
  335|       |
  336|       |    /// Returns the associated value of the result if it is a success, `nil` otherwise.
  337|      0|    public var value: Value? { return result.value }
  338|       |
  339|       |    /// Returns the associated error value if the result if it is a failure, `nil` otherwise.
  340|      0|    public var error: Error? { return result.error }
  341|       |
  342|       |    var _metrics: AnyObject?
  343|       |
  344|       |    /// Creates a `DownloadResponse` instance with the specified parameters derived from response serialization.
  345|       |    ///
  346|       |    /// - parameter request:        The URL request sent to the server.
  347|       |    /// - parameter response:       The server's response to the URL request.
  348|       |    /// - parameter temporaryURL:   The temporary destination URL of the data returned from the server.
  349|       |    /// - parameter destinationURL: The final destination URL of the data returned from the server if it was moved.
  350|       |    /// - parameter resumeData:     The resume data generated if the request was cancelled.
  351|       |    /// - parameter result:         The result of response serialization.
  352|       |    /// - parameter timeline:       The timeline of the complete lifecycle of the `Request`. Defaults to `Timeline()`.
  353|       |    ///
  354|       |    /// - returns: The new `DownloadResponse` instance.
  355|       |    public init(
  356|       |        request: URLRequest?,
  357|       |        response: HTTPURLResponse?,
  358|       |        temporaryURL: URL?,
  359|       |        destinationURL: URL?,
  360|       |        resumeData: Data?,
  361|       |        result: Result<Value>,
  362|       |        timeline: Timeline = Timeline())
  363|      0|    {
  364|      0|        self.request = request
  365|      0|        self.response = response
  366|      0|        self.temporaryURL = temporaryURL
  367|      0|        self.destinationURL = destinationURL
  368|      0|        self.resumeData = resumeData
  369|      0|        self.result = result
  370|      0|        self.timeline = timeline
  371|      0|    }
  372|       |}
  373|       |
  374|       |// MARK: -
  375|       |
  376|       |extension DownloadResponse: CustomStringConvertible, CustomDebugStringConvertible {
  377|       |    /// The textual representation used when written to an output stream, which includes whether the result was a
  378|       |    /// success or failure.
  379|      0|    public var description: String {
  380|      0|        return result.debugDescription
  381|      0|    }
  382|       |
  383|       |    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
  384|       |    /// response, the temporary and destination URLs, the resume data, the response serialization result and the
  385|       |    /// timeline.
  386|      0|    public var debugDescription: String {
  387|      0|        var output: [String] = []
  388|      0|
  389|      0|        output.append(request != nil ? "[Request]: \(request!.httpMethod ?? "GET") \(request!)" : "[Request]: nil")
  390|      0|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
  391|      0|        output.append("[TemporaryURL]: \(temporaryURL?.path ?? "nil")")
  392|      0|        output.append("[DestinationURL]: \(destinationURL?.path ?? "nil")")
  393|      0|        output.append("[ResumeData]: \(resumeData?.count ?? 0) bytes")
  394|      0|        output.append("[Result]: \(result.debugDescription)")
  395|      0|        output.append("[Timeline]: \(timeline.debugDescription)")
  396|      0|
  397|      0|        return output.joined(separator: "\n")
  398|      0|    }
  399|       |}
  400|       |
  401|       |// MARK: -
  402|       |
  403|       |extension DownloadResponse {
  404|       |    /// Evaluates the given closure when the result of this `DownloadResponse` is a success, passing the unwrapped
  405|       |    /// result value as a parameter.
  406|       |    ///
  407|       |    /// Use the `map` method with a closure that does not throw. For example:
  408|       |    ///
  409|       |    ///     let possibleData: DownloadResponse<Data> = ...
  410|       |    ///     let possibleInt = possibleData.map { $0.count }
  411|       |    ///
  412|       |    /// - parameter transform: A closure that takes the success value of the instance's result.
  413|       |    ///
  414|       |    /// - returns: A `DownloadResponse` whose result wraps the value returned by the given closure. If this instance's
  415|       |    ///            result is a failure, returns a response wrapping the same failure.
  416|      0|    public func map<T>(_ transform: (Value) -> T) -> DownloadResponse<T> {
  417|      0|        var response = DownloadResponse<T>(
  418|      0|            request: request,
  419|      0|            response: self.response,
  420|      0|            temporaryURL: temporaryURL,
  421|      0|            destinationURL: destinationURL,
  422|      0|            resumeData: resumeData,
  423|      0|            result: result.map(transform),
  424|      0|            timeline: timeline
  425|      0|        )
  426|      0|
  427|      0|        response._metrics = _metrics
  428|      0|
  429|      0|        return response
  430|      0|    }
  431|       |
  432|       |    /// Evaluates the given closure when the result of this `DownloadResponse` is a success, passing the unwrapped
  433|       |    /// result value as a parameter.
  434|       |    ///
  435|       |    /// Use the `flatMap` method with a closure that may throw an error. For example:
  436|       |    ///
  437|       |    ///     let possibleData: DownloadResponse<Data> = ...
  438|       |    ///     let possibleObject = possibleData.flatMap {
  439|       |    ///         try JSONSerialization.jsonObject(with: $0)
  440|       |    ///     }
  441|       |    ///
  442|       |    /// - parameter transform: A closure that takes the success value of the instance's result.
  443|       |    ///
  444|       |    /// - returns: A success or failure `DownloadResponse` depending on the result of the given closure. If this
  445|       |    /// instance's result is a failure, returns the same failure.
  446|      0|    public func flatMap<T>(_ transform: (Value) throws -> T) -> DownloadResponse<T> {
  447|      0|        var response = DownloadResponse<T>(
  448|      0|            request: request,
  449|      0|            response: self.response,
  450|      0|            temporaryURL: temporaryURL,
  451|      0|            destinationURL: destinationURL,
  452|      0|            resumeData: resumeData,
  453|      0|            result: result.flatMap(transform),
  454|      0|            timeline: timeline
  455|      0|        )
  456|      0|
  457|      0|        response._metrics = _metrics
  458|      0|
  459|      0|        return response
  460|      0|    }
  461|       |
  462|       |    /// Evaluates the specified closure when the `DownloadResponse` is a failure, passing the unwrapped error as a parameter.
  463|       |    ///
  464|       |    /// Use the `mapError` function with a closure that does not throw. For example:
  465|       |    ///
  466|       |    ///     let possibleData: DownloadResponse<Data> = ...
  467|       |    ///     let withMyError = possibleData.mapError { MyError.error($0) }
  468|       |    ///
  469|       |    /// - Parameter transform: A closure that takes the error of the instance.
  470|       |    /// - Returns: A `DownloadResponse` instance containing the result of the transform.
  471|      0|    public func mapError<E: Error>(_ transform: (Error) -> E) -> DownloadResponse {
  472|      0|        var response = DownloadResponse(
  473|      0|            request: request,
  474|      0|            response: self.response,
  475|      0|            temporaryURL: temporaryURL,
  476|      0|            destinationURL: destinationURL,
  477|      0|            resumeData: resumeData,
  478|      0|            result: result.mapError(transform),
  479|      0|            timeline: timeline
  480|      0|        )
  481|      0|
  482|      0|        response._metrics = _metrics
  483|      0|
  484|      0|        return response
  485|      0|    }
  486|       |
  487|       |    /// Evaluates the specified closure when the `DownloadResponse` is a failure, passing the unwrapped error as a parameter.
  488|       |    ///
  489|       |    /// Use the `flatMapError` function with a closure that may throw an error. For example:
  490|       |    ///
  491|       |    ///     let possibleData: DownloadResponse<Data> = ...
  492|       |    ///     let possibleObject = possibleData.flatMapError {
  493|       |    ///         try someFailableFunction(taking: $0)
  494|       |    ///     }
  495|       |    ///
  496|       |    /// - Parameter transform: A throwing closure that takes the error of the instance.
  497|       |    ///
  498|       |    /// - Returns: A `DownloadResponse` instance containing the result of the transform.
  499|      0|    public func flatMapError<E: Error>(_ transform: (Error) throws -> E) -> DownloadResponse {
  500|      0|        var response = DownloadResponse(
  501|      0|            request: request,
  502|      0|            response: self.response,
  503|      0|            temporaryURL: temporaryURL,
  504|      0|            destinationURL: destinationURL,
  505|      0|            resumeData: resumeData,
  506|      0|            result: result.flatMapError(transform),
  507|      0|            timeline: timeline
  508|      0|        )
  509|      0|
  510|      0|        response._metrics = _metrics
  511|      0|
  512|      0|        return response
  513|      0|    }
  514|       |}
  515|       |
  516|       |// MARK: -
  517|       |
  518|       |protocol Response {
  519|       |    /// The task metrics containing the request / response statistics.
  520|       |    var _metrics: AnyObject? { get set }
  521|       |    mutating func add(_ metrics: AnyObject?)
  522|       |}
  523|       |
  524|       |extension Response {
  525|    494|    mutating func add(_ metrics: AnyObject?) {
  526|    494|        #if !os(watchOS)
  527|    494|            guard #available(iOS 10.0, macOS 10.12, tvOS 10.0, *) else { return }
  528|    494|            guard let metrics = metrics as? URLSessionTaskMetrics else { return }
  529|    473|
  530|    473|            _metrics = metrics
  531|    473|        #endif
  532|    473|    }
  533|       |}
  534|       |
  535|       |// MARK: -
  536|       |
  537|       |@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
  538|       |extension DefaultDataResponse: Response {
  539|       |#if !os(watchOS)
  540|       |    /// The task metrics containing the request / response statistics.
  541|      0|    public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
  542|       |#endif
  543|       |}
  544|       |
  545|       |@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
  546|       |extension DataResponse: Response {
  547|       |#if !os(watchOS)
  548|       |    /// The task metrics containing the request / response statistics.
  549|      0|    public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
  550|       |#endif
  551|       |}
  552|       |
  553|       |@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
  554|       |extension DefaultDownloadResponse: Response {
  555|       |#if !os(watchOS)
  556|       |    /// The task metrics containing the request / response statistics.
  557|      0|    public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
  558|       |#endif
  559|       |}
  560|       |
  561|       |@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
  562|       |extension DownloadResponse: Response {
  563|       |#if !os(watchOS)
  564|       |    /// The task metrics containing the request / response statistics.
  565|      0|    public var metrics: URLSessionTaskMetrics? { return _metrics as? URLSessionTaskMetrics }
  566|       |#endif
  567|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/ResponseSerialization.swift:
    1|       |//
    2|       |//  ResponseSerialization.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// The type in which all data response serializers must conform to in order to serialize a response.
   28|       |public protocol DataResponseSerializerProtocol {
   29|       |    /// The type of serialized object to be created by this `DataResponseSerializerType`.
   30|       |    associatedtype SerializedObject
   31|       |
   32|       |    /// A closure used by response handlers that takes a request, response, data and error and returns a result.
   33|       |    var serializeResponse: (URLRequest?, HTTPURLResponse?, Data?, Error?) -> Result<SerializedObject> { get }
   34|       |}
   35|       |
   36|       |// MARK: -
   37|       |
   38|       |/// A generic `DataResponseSerializerType` used to serialize a request, response, and data into a serialized object.
   39|       |public struct DataResponseSerializer<Value>: DataResponseSerializerProtocol {
   40|       |    /// The type of serialized object to be created by this `DataResponseSerializer`.
   41|       |    public typealias SerializedObject = Value
   42|       |
   43|       |    /// A closure used by response handlers that takes a request, response, data and error and returns a result.
   44|       |    public var serializeResponse: (URLRequest?, HTTPURLResponse?, Data?, Error?) -> Result<Value>
   45|       |
   46|       |    /// Initializes the `ResponseSerializer` instance with the given serialize response closure.
   47|       |    ///
   48|       |    /// - parameter serializeResponse: The closure used to serialize the response.
   49|       |    ///
   50|       |    /// - returns: The new generic response serializer instance.
   51|    495|    public init(serializeResponse: @escaping (URLRequest?, HTTPURLResponse?, Data?, Error?) -> Result<Value>) {
   52|    495|        self.serializeResponse = serializeResponse
   53|    495|    }
   54|       |}
   55|       |
   56|       |// MARK: -
   57|       |
   58|       |/// The type in which all download response serializers must conform to in order to serialize a response.
   59|       |public protocol DownloadResponseSerializerProtocol {
   60|       |    /// The type of serialized object to be created by this `DownloadResponseSerializerType`.
   61|       |    associatedtype SerializedObject
   62|       |
   63|       |    /// A closure used by response handlers that takes a request, response, url and error and returns a result.
   64|       |    var serializeResponse: (URLRequest?, HTTPURLResponse?, URL?, Error?) -> Result<SerializedObject> { get }
   65|       |}
   66|       |
   67|       |// MARK: -
   68|       |
   69|       |/// A generic `DownloadResponseSerializerType` used to serialize a request, response, and data into a serialized object.
   70|       |public struct DownloadResponseSerializer<Value>: DownloadResponseSerializerProtocol {
   71|       |    /// The type of serialized object to be created by this `DownloadResponseSerializer`.
   72|       |    public typealias SerializedObject = Value
   73|       |
   74|       |    /// A closure used by response handlers that takes a request, response, url and error and returns a result.
   75|       |    public var serializeResponse: (URLRequest?, HTTPURLResponse?, URL?, Error?) -> Result<Value>
   76|       |
   77|       |    /// Initializes the `ResponseSerializer` instance with the given serialize response closure.
   78|       |    ///
   79|       |    /// - parameter serializeResponse: The closure used to serialize the response.
   80|       |    ///
   81|       |    /// - returns: The new generic response serializer instance.
   82|      0|    public init(serializeResponse: @escaping (URLRequest?, HTTPURLResponse?, URL?, Error?) -> Result<Value>) {
   83|      0|        self.serializeResponse = serializeResponse
   84|      0|    }
   85|       |}
   86|       |
   87|       |// MARK: - Timeline
   88|       |
   89|       |extension Request {
   90|    494|    var timeline: Timeline {
   91|    494|        let requestStartTime = self.startTime ?? CFAbsoluteTimeGetCurrent()
   92|    494|        let requestCompletedTime = self.endTime ?? CFAbsoluteTimeGetCurrent()
   93|    494|        let initialResponseTime = self.delegate.initialResponseTime ?? requestCompletedTime
   94|    494|
   95|    494|        return Timeline(
   96|    494|            requestStartTime: requestStartTime,
   97|    494|            initialResponseTime: initialResponseTime,
   98|    494|            requestCompletedTime: requestCompletedTime,
   99|    494|            serializationCompletedTime: CFAbsoluteTimeGetCurrent()
  100|    494|        )
  101|    494|    }
  102|       |}
  103|       |
  104|       |// MARK: - Default
  105|       |
  106|       |extension DataRequest {
  107|       |    /// Adds a handler to be called once the request has finished.
  108|       |    ///
  109|       |    /// - parameter queue:             The queue on which the completion handler is dispatched.
  110|       |    /// - parameter completionHandler: The code to be executed once the request has finished.
  111|       |    ///
  112|       |    /// - returns: The request.
  113|       |    @discardableResult
  114|      0|    public func response(queue: DispatchQueue? = nil, completionHandler: @escaping (DefaultDataResponse) -> Void) -> Self {
  115|      0|        delegate.queue.addOperation {
  116|      0|            (queue ?? DispatchQueue.main).async {
  117|      0|                var dataResponse = DefaultDataResponse(
  118|      0|                    request: self.request,
  119|      0|                    response: self.response,
  120|      0|                    data: self.delegate.data,
  121|      0|                    error: self.delegate.error,
  122|      0|                    timeline: self.timeline
  123|      0|                )
  124|      0|
  125|      0|                dataResponse.add(self.delegate.metrics)
  126|      0|
  127|      0|                completionHandler(dataResponse)
  128|      0|            }
  129|      0|        }
  130|      0|
  131|      0|        return self
  132|      0|    }
  133|       |
  134|       |    /// Adds a handler to be called once the request has finished.
  135|       |    ///
  136|       |    /// - parameter queue:              The queue on which the completion handler is dispatched.
  137|       |    /// - parameter responseSerializer: The response serializer responsible for serializing the request, response,
  138|       |    ///                                 and data.
  139|       |    /// - parameter completionHandler:  The code to be executed once the request has finished.
  140|       |    ///
  141|       |    /// - returns: The request.
  142|       |    @discardableResult
  143|       |    public func response<T: DataResponseSerializerProtocol>(
  144|       |        queue: DispatchQueue? = nil,
  145|       |        responseSerializer: T,
  146|       |        completionHandler: @escaping (DataResponse<T.SerializedObject>) -> Void)
  147|       |        -> Self
  148|    495|    {
  149|    495|        delegate.queue.addOperation {
  150|    494|            let result = responseSerializer.serializeResponse(
  151|    494|                self.request,
  152|    494|                self.response,
  153|    494|                self.delegate.data,
  154|    494|                self.delegate.error
  155|    494|            )
  156|    494|
  157|    494|            var dataResponse = DataResponse<T.SerializedObject>(
  158|    494|                request: self.request,
  159|    494|                response: self.response,
  160|    494|                data: self.delegate.data,
  161|    494|                result: result,
  162|    494|                timeline: self.timeline
  163|    494|            )
  164|    494|
  165|    494|            dataResponse.add(self.delegate.metrics)
  166|    494|
  167|    494|            (queue ?? DispatchQueue.main).async { completionHandler(dataResponse) }
  168|    494|        }
  169|    495|
  170|    495|        return self
  171|    495|    }
  172|       |}
  173|       |
  174|       |extension DownloadRequest {
  175|       |    /// Adds a handler to be called once the request has finished.
  176|       |    ///
  177|       |    /// - parameter queue:             The queue on which the completion handler is dispatched.
  178|       |    /// - parameter completionHandler: The code to be executed once the request has finished.
  179|       |    ///
  180|       |    /// - returns: The request.
  181|       |    @discardableResult
  182|       |    public func response(
  183|       |        queue: DispatchQueue? = nil,
  184|       |        completionHandler: @escaping (DefaultDownloadResponse) -> Void)
  185|       |        -> Self
  186|      0|    {
  187|      0|        delegate.queue.addOperation {
  188|      0|            (queue ?? DispatchQueue.main).async {
  189|      0|                var downloadResponse = DefaultDownloadResponse(
  190|      0|                    request: self.request,
  191|      0|                    response: self.response,
  192|      0|                    temporaryURL: self.downloadDelegate.temporaryURL,
  193|      0|                    destinationURL: self.downloadDelegate.destinationURL,
  194|      0|                    resumeData: self.downloadDelegate.resumeData,
  195|      0|                    error: self.downloadDelegate.error,
  196|      0|                    timeline: self.timeline
  197|      0|                )
  198|      0|
  199|      0|                downloadResponse.add(self.delegate.metrics)
  200|      0|
  201|      0|                completionHandler(downloadResponse)
  202|      0|            }
  203|      0|        }
  204|      0|
  205|      0|        return self
  206|      0|    }
  207|       |
  208|       |    /// Adds a handler to be called once the request has finished.
  209|       |    ///
  210|       |    /// - parameter queue:              The queue on which the completion handler is dispatched.
  211|       |    /// - parameter responseSerializer: The response serializer responsible for serializing the request, response,
  212|       |    ///                                 and data contained in the destination url.
  213|       |    /// - parameter completionHandler:  The code to be executed once the request has finished.
  214|       |    ///
  215|       |    /// - returns: The request.
  216|       |    @discardableResult
  217|       |    public func response<T: DownloadResponseSerializerProtocol>(
  218|       |        queue: DispatchQueue? = nil,
  219|       |        responseSerializer: T,
  220|       |        completionHandler: @escaping (DownloadResponse<T.SerializedObject>) -> Void)
  221|       |        -> Self
  222|      0|    {
  223|      0|        delegate.queue.addOperation {
  224|      0|            let result = responseSerializer.serializeResponse(
  225|      0|                self.request,
  226|      0|                self.response,
  227|      0|                self.downloadDelegate.fileURL,
  228|      0|                self.downloadDelegate.error
  229|      0|            )
  230|      0|
  231|      0|            var downloadResponse = DownloadResponse<T.SerializedObject>(
  232|      0|                request: self.request,
  233|      0|                response: self.response,
  234|      0|                temporaryURL: self.downloadDelegate.temporaryURL,
  235|      0|                destinationURL: self.downloadDelegate.destinationURL,
  236|      0|                resumeData: self.downloadDelegate.resumeData,
  237|      0|                result: result,
  238|      0|                timeline: self.timeline
  239|      0|            )
  240|      0|
  241|      0|            downloadResponse.add(self.delegate.metrics)
  242|      0|
  243|      0|            (queue ?? DispatchQueue.main).async { completionHandler(downloadResponse) }
  244|      0|        }
  245|      0|
  246|      0|        return self
  247|      0|    }
  248|       |}
  249|       |
  250|       |// MARK: - Data
  251|       |
  252|       |extension Request {
  253|       |    /// Returns a result data type that contains the response data as-is.
  254|       |    ///
  255|       |    /// - parameter response: The response from the server.
  256|       |    /// - parameter data:     The data returned from the server.
  257|       |    /// - parameter error:    The error already encountered if it exists.
  258|       |    ///
  259|       |    /// - returns: The result data type.
  260|    493|    public static func serializeResponseData(response: HTTPURLResponse?, data: Data?, error: Error?) -> Result<Data> {
  261|    493|        guard error == nil else { return .failure(error!) }
  262|    472|
  263|    472|        if let response = response, emptyDataStatusCodes.contains(response.statusCode) { return .success(Data()) }
  264|    472|
  265|    472|        guard let validData = data else {
  266|      0|            return .failure(AFError.responseSerializationFailed(reason: .inputDataNil))
  267|    472|        }
  268|    472|
  269|    472|        return .success(validData)
  270|    472|    }
  271|       |}
  272|       |
  273|       |extension DataRequest {
  274|       |    /// Creates a response serializer that returns the associated data as-is.
  275|       |    ///
  276|       |    /// - returns: A data response serializer.
  277|      0|    public static func dataResponseSerializer() -> DataResponseSerializer<Data> {
  278|      0|        return DataResponseSerializer { _, response, data, error in
  279|      0|            return Request.serializeResponseData(response: response, data: data, error: error)
  280|      0|        }
  281|      0|    }
  282|       |
  283|       |    /// Adds a handler to be called once the request has finished.
  284|       |    ///
  285|       |    /// - parameter completionHandler: The code to be executed once the request has finished.
  286|       |    ///
  287|       |    /// - returns: The request.
  288|       |    @discardableResult
  289|       |    public func responseData(
  290|       |        queue: DispatchQueue? = nil,
  291|       |        completionHandler: @escaping (DataResponse<Data>) -> Void)
  292|       |        -> Self
  293|      0|    {
  294|      0|        return response(
  295|      0|            queue: queue,
  296|      0|            responseSerializer: DataRequest.dataResponseSerializer(),
  297|      0|            completionHandler: completionHandler
  298|      0|        )
  299|      0|    }
  300|       |}
  301|       |
  302|       |extension DownloadRequest {
  303|       |    /// Creates a response serializer that returns the associated data as-is.
  304|       |    ///
  305|       |    /// - returns: A data response serializer.
  306|      0|    public static func dataResponseSerializer() -> DownloadResponseSerializer<Data> {
  307|      0|        return DownloadResponseSerializer { _, response, fileURL, error in
  308|      0|            guard error == nil else { return .failure(error!) }
  309|      0|
  310|      0|            guard let fileURL = fileURL else {
  311|      0|                return .failure(AFError.responseSerializationFailed(reason: .inputFileNil))
  312|      0|            }
  313|      0|
  314|      0|            do {
  315|      0|                let data = try Data(contentsOf: fileURL)
  316|      0|                return Request.serializeResponseData(response: response, data: data, error: error)
  317|      0|            } catch {
  318|      0|                return .failure(AFError.responseSerializationFailed(reason: .inputFileReadFailed(at: fileURL)))
  319|      0|            }
  320|      0|        }
  321|      0|    }
  322|       |
  323|       |    /// Adds a handler to be called once the request has finished.
  324|       |    ///
  325|       |    /// - parameter completionHandler: The code to be executed once the request has finished.
  326|       |    ///
  327|       |    /// - returns: The request.
  328|       |    @discardableResult
  329|       |    public func responseData(
  330|       |        queue: DispatchQueue? = nil,
  331|       |        completionHandler: @escaping (DownloadResponse<Data>) -> Void)
  332|       |        -> Self
  333|      0|    {
  334|      0|        return response(
  335|      0|            queue: queue,
  336|      0|            responseSerializer: DownloadRequest.dataResponseSerializer(),
  337|      0|            completionHandler: completionHandler
  338|      0|        )
  339|      0|    }
  340|       |}
  341|       |
  342|       |// MARK: - String
  343|       |
  344|       |extension Request {
  345|       |    /// Returns a result string type initialized from the response data with the specified string encoding.
  346|       |    ///
  347|       |    /// - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server
  348|       |    ///                       response, falling back to the default HTTP default character set, ISO-8859-1.
  349|       |    /// - parameter response: The response from the server.
  350|       |    /// - parameter data:     The data returned from the server.
  351|       |    /// - parameter error:    The error already encountered if it exists.
  352|       |    ///
  353|       |    /// - returns: The result data type.
  354|       |    public static func serializeResponseString(
  355|       |        encoding: String.Encoding?,
  356|       |        response: HTTPURLResponse?,
  357|       |        data: Data?,
  358|       |        error: Error?)
  359|       |        -> Result<String>
  360|      0|    {
  361|      0|        guard error == nil else { return .failure(error!) }
  362|      0|
  363|      0|        if let response = response, emptyDataStatusCodes.contains(response.statusCode) { return .success("") }
  364|      0|
  365|      0|        guard let validData = data else {
  366|      0|            return .failure(AFError.responseSerializationFailed(reason: .inputDataNil))
  367|      0|        }
  368|      0|
  369|      0|        var convertedEncoding = encoding
  370|      0|
  371|      0|        if let encodingName = response?.textEncodingName as CFString?, convertedEncoding == nil {
  372|      0|            convertedEncoding = String.Encoding(rawValue: CFStringConvertEncodingToNSStringEncoding(
  373|      0|                CFStringConvertIANACharSetNameToEncoding(encodingName))
  374|      0|            )
  375|      0|        }
  376|      0|
  377|      0|        let actualEncoding = convertedEncoding ?? .isoLatin1
  378|      0|
  379|      0|        if let string = String(data: validData, encoding: actualEncoding) {
  380|      0|            return .success(string)
  381|      0|        } else {
  382|      0|            return .failure(AFError.responseSerializationFailed(reason: .stringSerializationFailed(encoding: actualEncoding)))
  383|      0|        }
  384|      0|    }
  385|       |}
  386|       |
  387|       |extension DataRequest {
  388|       |    /// Creates a response serializer that returns a result string type initialized from the response data with
  389|       |    /// the specified string encoding.
  390|       |    ///
  391|       |    /// - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server
  392|       |    ///                       response, falling back to the default HTTP default character set, ISO-8859-1.
  393|       |    ///
  394|       |    /// - returns: A string response serializer.
  395|      0|    public static func stringResponseSerializer(encoding: String.Encoding? = nil) -> DataResponseSerializer<String> {
  396|      0|        return DataResponseSerializer { _, response, data, error in
  397|      0|            return Request.serializeResponseString(encoding: encoding, response: response, data: data, error: error)
  398|      0|        }
  399|      0|    }
  400|       |
  401|       |    /// Adds a handler to be called once the request has finished.
  402|       |    ///
  403|       |    /// - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the
  404|       |    ///                                server response, falling back to the default HTTP default character set,
  405|       |    ///                                ISO-8859-1.
  406|       |    /// - parameter completionHandler: A closure to be executed once the request has finished.
  407|       |    ///
  408|       |    /// - returns: The request.
  409|       |    @discardableResult
  410|       |    public func responseString(
  411|       |        queue: DispatchQueue? = nil,
  412|       |        encoding: String.Encoding? = nil,
  413|       |        completionHandler: @escaping (DataResponse<String>) -> Void)
  414|       |        -> Self
  415|      0|    {
  416|      0|        return response(
  417|      0|            queue: queue,
  418|      0|            responseSerializer: DataRequest.stringResponseSerializer(encoding: encoding),
  419|      0|            completionHandler: completionHandler
  420|      0|        )
  421|      0|    }
  422|       |}
  423|       |
  424|       |extension DownloadRequest {
  425|       |    /// Creates a response serializer that returns a result string type initialized from the response data with
  426|       |    /// the specified string encoding.
  427|       |    ///
  428|       |    /// - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server
  429|       |    ///                       response, falling back to the default HTTP default character set, ISO-8859-1.
  430|       |    ///
  431|       |    /// - returns: A string response serializer.
  432|      0|    public static func stringResponseSerializer(encoding: String.Encoding? = nil) -> DownloadResponseSerializer<String> {
  433|      0|        return DownloadResponseSerializer { _, response, fileURL, error in
  434|      0|            guard error == nil else { return .failure(error!) }
  435|      0|
  436|      0|            guard let fileURL = fileURL else {
  437|      0|                return .failure(AFError.responseSerializationFailed(reason: .inputFileNil))
  438|      0|            }
  439|      0|
  440|      0|            do {
  441|      0|                let data = try Data(contentsOf: fileURL)
  442|      0|                return Request.serializeResponseString(encoding: encoding, response: response, data: data, error: error)
  443|      0|            } catch {
  444|      0|                return .failure(AFError.responseSerializationFailed(reason: .inputFileReadFailed(at: fileURL)))
  445|      0|            }
  446|      0|        }
  447|      0|    }
  448|       |
  449|       |    /// Adds a handler to be called once the request has finished.
  450|       |    ///
  451|       |    /// - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the
  452|       |    ///                                server response, falling back to the default HTTP default character set,
  453|       |    ///                                ISO-8859-1.
  454|       |    /// - parameter completionHandler: A closure to be executed once the request has finished.
  455|       |    ///
  456|       |    /// - returns: The request.
  457|       |    @discardableResult
  458|       |    public func responseString(
  459|       |        queue: DispatchQueue? = nil,
  460|       |        encoding: String.Encoding? = nil,
  461|       |        completionHandler: @escaping (DownloadResponse<String>) -> Void)
  462|       |        -> Self
  463|      0|    {
  464|      0|        return response(
  465|      0|            queue: queue,
  466|      0|            responseSerializer: DownloadRequest.stringResponseSerializer(encoding: encoding),
  467|      0|            completionHandler: completionHandler
  468|      0|        )
  469|      0|    }
  470|       |}
  471|       |
  472|       |// MARK: - JSON
  473|       |
  474|       |extension Request {
  475|       |    /// Returns a JSON object contained in a result type constructed from the response data using `JSONSerialization`
  476|       |    /// with the specified reading options.
  477|       |    ///
  478|       |    /// - parameter options:  The JSON serialization reading options. Defaults to `.allowFragments`.
  479|       |    /// - parameter response: The response from the server.
  480|       |    /// - parameter data:     The data returned from the server.
  481|       |    /// - parameter error:    The error already encountered if it exists.
  482|       |    ///
  483|       |    /// - returns: The result data type.
  484|       |    public static func serializeResponseJSON(
  485|       |        options: JSONSerialization.ReadingOptions,
  486|       |        response: HTTPURLResponse?,
  487|       |        data: Data?,
  488|       |        error: Error?)
  489|       |        -> Result<Any>
  490|      1|    {
  491|      1|        guard error == nil else { return .failure(error!) }
  492|      1|
  493|      1|        if let response = response, emptyDataStatusCodes.contains(response.statusCode) { return .success(NSNull()) }
  494|      1|
  495|      1|        guard let validData = data, validData.count > 0 else {
  496|      0|            return .failure(AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength))
  497|      1|        }
  498|      1|
  499|      1|        do {
  500|      1|            let json = try JSONSerialization.jsonObject(with: validData, options: options)
  501|      1|            return .success(json)
  502|      1|        } catch {
  503|      0|            return .failure(AFError.responseSerializationFailed(reason: .jsonSerializationFailed(error: error)))
  504|      0|        }
  505|      0|    }
  506|       |}
  507|       |
  508|       |extension DataRequest {
  509|       |    /// Creates a response serializer that returns a JSON object result type constructed from the response data using
  510|       |    /// `JSONSerialization` with the specified reading options.
  511|       |    ///
  512|       |    /// - parameter options: The JSON serialization reading options. Defaults to `.allowFragments`.
  513|       |    ///
  514|       |    /// - returns: A JSON object response serializer.
  515|       |    public static func jsonResponseSerializer(
  516|       |        options: JSONSerialization.ReadingOptions = .allowFragments)
  517|       |        -> DataResponseSerializer<Any>
  518|      1|    {
  519|      1|        return DataResponseSerializer { _, response, data, error in
  520|      1|            return Request.serializeResponseJSON(options: options, response: response, data: data, error: error)
  521|      1|        }
  522|      1|    }
  523|       |
  524|       |    /// Adds a handler to be called once the request has finished.
  525|       |    ///
  526|       |    /// - parameter options:           The JSON serialization reading options. Defaults to `.allowFragments`.
  527|       |    /// - parameter completionHandler: A closure to be executed once the request has finished.
  528|       |    ///
  529|       |    /// - returns: The request.
  530|       |    @discardableResult
  531|       |    public func responseJSON(
  532|       |        queue: DispatchQueue? = nil,
  533|       |        options: JSONSerialization.ReadingOptions = .allowFragments,
  534|       |        completionHandler: @escaping (DataResponse<Any>) -> Void)
  535|       |        -> Self
  536|      1|    {
  537|      1|        return response(
  538|      1|            queue: queue,
  539|      1|            responseSerializer: DataRequest.jsonResponseSerializer(options: options),
  540|      1|            completionHandler: completionHandler
  541|      1|        )
  542|      1|    }
  543|       |}
  544|       |
  545|       |extension DownloadRequest {
  546|       |    /// Creates a response serializer that returns a JSON object result type constructed from the response data using
  547|       |    /// `JSONSerialization` with the specified reading options.
  548|       |    ///
  549|       |    /// - parameter options: The JSON serialization reading options. Defaults to `.allowFragments`.
  550|       |    ///
  551|       |    /// - returns: A JSON object response serializer.
  552|       |    public static func jsonResponseSerializer(
  553|       |        options: JSONSerialization.ReadingOptions = .allowFragments)
  554|       |        -> DownloadResponseSerializer<Any>
  555|      0|    {
  556|      0|        return DownloadResponseSerializer { _, response, fileURL, error in
  557|      0|            guard error == nil else { return .failure(error!) }
  558|      0|
  559|      0|            guard let fileURL = fileURL else {
  560|      0|                return .failure(AFError.responseSerializationFailed(reason: .inputFileNil))
  561|      0|            }
  562|      0|
  563|      0|            do {
  564|      0|                let data = try Data(contentsOf: fileURL)
  565|      0|                return Request.serializeResponseJSON(options: options, response: response, data: data, error: error)
  566|      0|            } catch {
  567|      0|                return .failure(AFError.responseSerializationFailed(reason: .inputFileReadFailed(at: fileURL)))
  568|      0|            }
  569|      0|        }
  570|      0|    }
  571|       |
  572|       |    /// Adds a handler to be called once the request has finished.
  573|       |    ///
  574|       |    /// - parameter options:           The JSON serialization reading options. Defaults to `.allowFragments`.
  575|       |    /// - parameter completionHandler: A closure to be executed once the request has finished.
  576|       |    ///
  577|       |    /// - returns: The request.
  578|       |    @discardableResult
  579|       |    public func responseJSON(
  580|       |        queue: DispatchQueue? = nil,
  581|       |        options: JSONSerialization.ReadingOptions = .allowFragments,
  582|       |        completionHandler: @escaping (DownloadResponse<Any>) -> Void)
  583|       |        -> Self
  584|      0|    {
  585|      0|        return response(
  586|      0|            queue: queue,
  587|      0|            responseSerializer: DownloadRequest.jsonResponseSerializer(options: options),
  588|      0|            completionHandler: completionHandler
  589|      0|        )
  590|      0|    }
  591|       |}
  592|       |
  593|       |// MARK: - Property List
  594|       |
  595|       |extension Request {
  596|       |    /// Returns a plist object contained in a result type constructed from the response data using
  597|       |    /// `PropertyListSerialization` with the specified reading options.
  598|       |    ///
  599|       |    /// - parameter options:  The property list reading options. Defaults to `[]`.
  600|       |    /// - parameter response: The response from the server.
  601|       |    /// - parameter data:     The data returned from the server.
  602|       |    /// - parameter error:    The error already encountered if it exists.
  603|       |    ///
  604|       |    /// - returns: The result data type.
  605|       |    public static func serializeResponsePropertyList(
  606|       |        options: PropertyListSerialization.ReadOptions,
  607|       |        response: HTTPURLResponse?,
  608|       |        data: Data?,
  609|       |        error: Error?)
  610|       |        -> Result<Any>
  611|      0|    {
  612|      0|        guard error == nil else { return .failure(error!) }
  613|      0|
  614|      0|        if let response = response, emptyDataStatusCodes.contains(response.statusCode) { return .success(NSNull()) }
  615|      0|
  616|      0|        guard let validData = data, validData.count > 0 else {
  617|      0|            return .failure(AFError.responseSerializationFailed(reason: .inputDataNilOrZeroLength))
  618|      0|        }
  619|      0|
  620|      0|        do {
  621|      0|            let plist = try PropertyListSerialization.propertyList(from: validData, options: options, format: nil)
  622|      0|            return .success(plist)
  623|      0|        } catch {
  624|      0|            return .failure(AFError.responseSerializationFailed(reason: .propertyListSerializationFailed(error: error)))
  625|      0|        }
  626|      0|    }
  627|       |}
  628|       |
  629|       |extension DataRequest {
  630|       |    /// Creates a response serializer that returns an object constructed from the response data using
  631|       |    /// `PropertyListSerialization` with the specified reading options.
  632|       |    ///
  633|       |    /// - parameter options: The property list reading options. Defaults to `[]`.
  634|       |    ///
  635|       |    /// - returns: A property list object response serializer.
  636|       |    public static func propertyListResponseSerializer(
  637|       |        options: PropertyListSerialization.ReadOptions = [])
  638|       |        -> DataResponseSerializer<Any>
  639|      0|    {
  640|      0|        return DataResponseSerializer { _, response, data, error in
  641|      0|            return Request.serializeResponsePropertyList(options: options, response: response, data: data, error: error)
  642|      0|        }
  643|      0|    }
  644|       |
  645|       |    /// Adds a handler to be called once the request has finished.
  646|       |    ///
  647|       |    /// - parameter options:           The property list reading options. Defaults to `[]`.
  648|       |    /// - parameter completionHandler: A closure to be executed once the request has finished.
  649|       |    ///
  650|       |    /// - returns: The request.
  651|       |    @discardableResult
  652|       |    public func responsePropertyList(
  653|       |        queue: DispatchQueue? = nil,
  654|       |        options: PropertyListSerialization.ReadOptions = [],
  655|       |        completionHandler: @escaping (DataResponse<Any>) -> Void)
  656|       |        -> Self
  657|      0|    {
  658|      0|        return response(
  659|      0|            queue: queue,
  660|      0|            responseSerializer: DataRequest.propertyListResponseSerializer(options: options),
  661|      0|            completionHandler: completionHandler
  662|      0|        )
  663|      0|    }
  664|       |}
  665|       |
  666|       |extension DownloadRequest {
  667|       |    /// Creates a response serializer that returns an object constructed from the response data using
  668|       |    /// `PropertyListSerialization` with the specified reading options.
  669|       |    ///
  670|       |    /// - parameter options: The property list reading options. Defaults to `[]`.
  671|       |    ///
  672|       |    /// - returns: A property list object response serializer.
  673|       |    public static func propertyListResponseSerializer(
  674|       |        options: PropertyListSerialization.ReadOptions = [])
  675|       |        -> DownloadResponseSerializer<Any>
  676|      0|    {
  677|      0|        return DownloadResponseSerializer { _, response, fileURL, error in
  678|      0|            guard error == nil else { return .failure(error!) }
  679|      0|
  680|      0|            guard let fileURL = fileURL else {
  681|      0|                return .failure(AFError.responseSerializationFailed(reason: .inputFileNil))
  682|      0|            }
  683|      0|
  684|      0|            do {
  685|      0|                let data = try Data(contentsOf: fileURL)
  686|      0|                return Request.serializeResponsePropertyList(options: options, response: response, data: data, error: error)
  687|      0|            } catch {
  688|      0|                return .failure(AFError.responseSerializationFailed(reason: .inputFileReadFailed(at: fileURL)))
  689|      0|            }
  690|      0|        }
  691|      0|    }
  692|       |
  693|       |    /// Adds a handler to be called once the request has finished.
  694|       |    ///
  695|       |    /// - parameter options:           The property list reading options. Defaults to `[]`.
  696|       |    /// - parameter completionHandler: A closure to be executed once the request has finished.
  697|       |    ///
  698|       |    /// - returns: The request.
  699|       |    @discardableResult
  700|       |    public func responsePropertyList(
  701|       |        queue: DispatchQueue? = nil,
  702|       |        options: PropertyListSerialization.ReadOptions = [],
  703|       |        completionHandler: @escaping (DownloadResponse<Any>) -> Void)
  704|       |        -> Self
  705|      0|    {
  706|      0|        return response(
  707|      0|            queue: queue,
  708|      0|            responseSerializer: DownloadRequest.propertyListResponseSerializer(options: options),
  709|      0|            completionHandler: completionHandler
  710|      0|        )
  711|      0|    }
  712|       |}
  713|       |
  714|       |/// A set of HTTP response status code that do not contain response data.
  715|       |private let emptyDataStatusCodes: Set<Int> = [204, 205]

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/Result.swift:
    1|       |//
    2|       |//  Result.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Used to represent whether a request was successful or encountered an error.
   28|       |///
   29|       |/// - success: The request and all post processing operations were successful resulting in the serialization of the
   30|       |///            provided associated value.
   31|       |///
   32|       |/// - failure: The request encountered an error resulting in a failure. The associated values are the original data
   33|       |///            provided by the server as well as the error that caused the failure.
   34|       |public enum Result<Value> {
   35|       |    case success(Value)
   36|       |    case failure(Error)
   37|       |
   38|       |    /// Returns `true` if the result is a success, `false` otherwise.
   39|      0|    public var isSuccess: Bool {
   40|      0|        switch self {
   41|      0|        case .success:
   42|      0|            return true
   43|      0|        case .failure:
   44|      0|            return false
   45|      0|        }
   46|      0|    }
   47|       |
   48|       |    /// Returns `true` if the result is a failure, `false` otherwise.
   49|      0|    public var isFailure: Bool {
   50|      0|        return !isSuccess
   51|      0|    }
   52|       |
   53|       |    /// Returns the associated value if the result is a success, `nil` otherwise.
   54|    493|    public var value: Value? {
   55|    493|        switch self {
   56|    493|        case .success(let value):
   57|    472|            return value
   58|    493|        case .failure:
   59|     21|            return nil
   60|    493|        }
   61|    493|    }
   62|       |
   63|       |    /// Returns the associated error value if the result is a failure, `nil` otherwise.
   64|     21|    public var error: Error? {
   65|     21|        switch self {
   66|     21|        case .success:
   67|      0|            return nil
   68|     21|        case .failure(let error):
   69|     21|            return error
   70|     21|        }
   71|     21|    }
   72|       |}
   73|       |
   74|       |// MARK: - CustomStringConvertible
   75|       |
   76|       |extension Result: CustomStringConvertible {
   77|       |    /// The textual representation used when written to an output stream, which includes whether the result was a
   78|       |    /// success or failure.
   79|      0|    public var description: String {
   80|      0|        switch self {
   81|      0|        case .success:
   82|      0|            return "SUCCESS"
   83|      0|        case .failure:
   84|      0|            return "FAILURE"
   85|      0|        }
   86|      0|    }
   87|       |}
   88|       |
   89|       |// MARK: - CustomDebugStringConvertible
   90|       |
   91|       |extension Result: CustomDebugStringConvertible {
   92|       |    /// The debug textual representation used when written to an output stream, which includes whether the result was a
   93|       |    /// success or failure in addition to the value or error.
   94|      0|    public var debugDescription: String {
   95|      0|        switch self {
   96|      0|        case .success(let value):
   97|      0|            return "SUCCESS: \(value)"
   98|      0|        case .failure(let error):
   99|      0|            return "FAILURE: \(error)"
  100|      0|        }
  101|      0|    }
  102|       |}
  103|       |
  104|       |// MARK: - Functional APIs
  105|       |
  106|       |extension Result {
  107|       |    /// Creates a `Result` instance from the result of a closure.
  108|       |    ///
  109|       |    /// A failure result is created when the closure throws, and a success result is created when the closure
  110|       |    /// succeeds without throwing an error.
  111|       |    ///
  112|       |    ///     func someString() throws -> String { ... }
  113|       |    ///
  114|       |    ///     let result = Result(value: {
  115|       |    ///         return try someString()
  116|       |    ///     })
  117|       |    ///
  118|       |    ///     // The type of result is Result<String>
  119|       |    ///
  120|       |    /// The trailing closure syntax is also supported:
  121|       |    ///
  122|       |    ///     let result = Result { try someString() }
  123|       |    ///
  124|       |    /// - parameter value: The closure to execute and create the result for.
  125|      0|    public init(value: () throws -> Value) {
  126|      0|        do {
  127|      0|            self = try .success(value())
  128|      0|        } catch {
  129|      0|            self = .failure(error)
  130|      0|        }
  131|      0|    }
  132|       |
  133|       |    /// Returns the success value, or throws the failure error.
  134|       |    ///
  135|       |    ///     let possibleString: Result<String> = .success("success")
  136|       |    ///     try print(possibleString.unwrap())
  137|       |    ///     // Prints "success"
  138|       |    ///
  139|       |    ///     let noString: Result<String> = .failure(error)
  140|       |    ///     try print(noString.unwrap())
  141|       |    ///     // Throws error
  142|      0|    public func unwrap() throws -> Value {
  143|      0|        switch self {
  144|      0|        case .success(let value):
  145|      0|            return value
  146|      0|        case .failure(let error):
  147|      0|            throw error
  148|      0|        }
  149|      0|    }
  150|       |
  151|       |    /// Evaluates the specified closure when the `Result` is a success, passing the unwrapped value as a parameter.
  152|       |    ///
  153|       |    /// Use the `map` method with a closure that does not throw. For example:
  154|       |    ///
  155|       |    ///     let possibleData: Result<Data> = .success(Data())
  156|       |    ///     let possibleInt = possibleData.map { $0.count }
  157|       |    ///     try print(possibleInt.unwrap())
  158|       |    ///     // Prints "0"
  159|       |    ///
  160|       |    ///     let noData: Result<Data> = .failure(error)
  161|       |    ///     let noInt = noData.map { $0.count }
  162|       |    ///     try print(noInt.unwrap())
  163|       |    ///     // Throws error
  164|       |    ///
  165|       |    /// - parameter transform: A closure that takes the success value of the `Result` instance.
  166|       |    ///
  167|       |    /// - returns: A `Result` containing the result of the given closure. If this instance is a failure, returns the
  168|       |    ///            same failure.
  169|      0|    public func map<T>(_ transform: (Value) -> T) -> Result<T> {
  170|      0|        switch self {
  171|      0|        case .success(let value):
  172|      0|            return .success(transform(value))
  173|      0|        case .failure(let error):
  174|      0|            return .failure(error)
  175|      0|        }
  176|      0|    }
  177|       |
  178|       |    /// Evaluates the specified closure when the `Result` is a success, passing the unwrapped value as a parameter.
  179|       |    ///
  180|       |    /// Use the `flatMap` method with a closure that may throw an error. For example:
  181|       |    ///
  182|       |    ///     let possibleData: Result<Data> = .success(Data(...))
  183|       |    ///     let possibleObject = possibleData.flatMap {
  184|       |    ///         try JSONSerialization.jsonObject(with: $0)
  185|       |    ///     }
  186|       |    ///
  187|       |    /// - parameter transform: A closure that takes the success value of the instance.
  188|       |    ///
  189|       |    /// - returns: A `Result` containing the result of the given closure. If this instance is a failure, returns the
  190|       |    ///            same failure.
  191|      0|    public func flatMap<T>(_ transform: (Value) throws -> T) -> Result<T> {
  192|      0|        switch self {
  193|      0|        case .success(let value):
  194|      0|            do {
  195|      0|                return try .success(transform(value))
  196|      0|            } catch {
  197|      0|                return .failure(error)
  198|      0|            }
  199|      0|        case .failure(let error):
  200|      0|            return .failure(error)
  201|      0|        }
  202|      0|    }
  203|       |
  204|       |    /// Evaluates the specified closure when the `Result` is a failure, passing the unwrapped error as a parameter.
  205|       |    ///
  206|       |    /// Use the `mapError` function with a closure that does not throw. For example:
  207|       |    ///
  208|       |    ///     let possibleData: Result<Data> = .failure(someError)
  209|       |    ///     let withMyError: Result<Data> = possibleData.mapError { MyError.error($0) }
  210|       |    ///
  211|       |    /// - Parameter transform: A closure that takes the error of the instance.
  212|       |    /// - Returns: A `Result` instance containing the result of the transform. If this instance is a success, returns
  213|       |    ///            the same instance.
  214|      0|    public func mapError<T: Error>(_ transform: (Error) -> T) -> Result {
  215|      0|        switch self {
  216|      0|        case .failure(let error):
  217|      0|            return .failure(transform(error))
  218|      0|        case .success:
  219|      0|            return self
  220|      0|        }
  221|      0|    }
  222|       |
  223|       |    /// Evaluates the specified closure when the `Result` is a failure, passing the unwrapped error as a parameter.
  224|       |    ///
  225|       |    /// Use the `flatMapError` function with a closure that may throw an error. For example:
  226|       |    ///
  227|       |    ///     let possibleData: Result<Data> = .success(Data(...))
  228|       |    ///     let possibleObject = possibleData.flatMapError {
  229|       |    ///         try someFailableFunction(taking: $0)
  230|       |    ///     }
  231|       |    ///
  232|       |    /// - Parameter transform: A throwing closure that takes the error of the instance.
  233|       |    ///
  234|       |    /// - Returns: A `Result` instance containing the result of the transform. If this instance is a success, returns
  235|       |    ///            the same instance.
  236|      0|    public func flatMapError<T: Error>(_ transform: (Error) throws -> T) -> Result {
  237|      0|        switch self {
  238|      0|        case .failure(let error):
  239|      0|            do {
  240|      0|                return try .failure(transform(error))
  241|      0|            } catch {
  242|      0|                return .failure(error)
  243|      0|            }
  244|      0|        case .success:
  245|      0|            return self
  246|      0|        }
  247|      0|    }
  248|       |
  249|       |    /// Evaluates the specified closure when the `Result` is a success, passing the unwrapped value as a parameter.
  250|       |    ///
  251|       |    /// Use the `withValue` function to evaluate the passed closure without modifying the `Result` instance.
  252|       |    ///
  253|       |    /// - Parameter closure: A closure that takes the success value of this instance.
  254|       |    /// - Returns: This `Result` instance, unmodified.
  255|       |    @discardableResult
  256|      0|    public func withValue(_ closure: (Value) throws -> Void) rethrows -> Result {
  257|      0|        if case let .success(value) = self { try closure(value) }
  258|      0|
  259|      0|        return self
  260|      0|    }
  261|       |
  262|       |    /// Evaluates the specified closure when the `Result` is a failure, passing the unwrapped error as a parameter.
  263|       |    ///
  264|       |    /// Use the `withError` function to evaluate the passed closure without modifying the `Result` instance.
  265|       |    ///
  266|       |    /// - Parameter closure: A closure that takes the success value of this instance.
  267|       |    /// - Returns: This `Result` instance, unmodified.
  268|       |    @discardableResult
  269|      0|    public func withError(_ closure: (Error) throws -> Void) rethrows -> Result {
  270|      0|        if case let .failure(error) = self { try closure(error) }
  271|      0|
  272|      0|        return self
  273|      0|    }
  274|       |
  275|       |    /// Evaluates the specified closure when the `Result` is a success.
  276|       |    ///
  277|       |    /// Use the `ifSuccess` function to evaluate the passed closure without modifying the `Result` instance.
  278|       |    ///
  279|       |    /// - Parameter closure: A `Void` closure.
  280|       |    /// - Returns: This `Result` instance, unmodified.
  281|       |    @discardableResult
  282|      0|    public func ifSuccess(_ closure: () throws -> Void) rethrows -> Result {
  283|      0|        if isSuccess { try closure() }
  284|      0|
  285|      0|        return self
  286|      0|    }
  287|       |
  288|       |    /// Evaluates the specified closure when the `Result` is a failure.
  289|       |    ///
  290|       |    /// Use the `ifFailure` function to evaluate the passed closure without modifying the `Result` instance.
  291|       |    ///
  292|       |    /// - Parameter closure: A `Void` closure.
  293|       |    /// - Returns: This `Result` instance, unmodified.
  294|       |    @discardableResult
  295|      0|    public func ifFailure(_ closure: () throws -> Void) rethrows -> Result {
  296|      0|        if isFailure { try closure() }
  297|      0|
  298|      0|        return self
  299|      0|    }
  300|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/ServerTrustPolicy.swift:
    1|       |//
    2|       |//  ServerTrustPolicy.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
   28|       |open class ServerTrustPolicyManager {
   29|       |    /// The dictionary of policies mapped to a particular host.
   30|       |    public let policies: [String: ServerTrustPolicy]
   31|       |
   32|       |    /// Initializes the `ServerTrustPolicyManager` instance with the given policies.
   33|       |    ///
   34|       |    /// Since different servers and web services can have different leaf certificates, intermediate and even root
   35|       |    /// certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This
   36|       |    /// allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key
   37|       |    /// pinning for host3 and disabling evaluation for host4.
   38|       |    ///
   39|       |    /// - parameter policies: A dictionary of all policies mapped to a particular host.
   40|       |    ///
   41|       |    /// - returns: The new `ServerTrustPolicyManager` instance.
   42|      0|    public init(policies: [String: ServerTrustPolicy]) {
   43|      0|        self.policies = policies
   44|      0|    }
   45|       |
   46|       |    /// Returns the `ServerTrustPolicy` for the given host if applicable.
   47|       |    ///
   48|       |    /// By default, this method will return the policy that perfectly matches the given host. Subclasses could override
   49|       |    /// this method and implement more complex mapping implementations such as wildcards.
   50|       |    ///
   51|       |    /// - parameter host: The host to use when searching for a matching policy.
   52|       |    ///
   53|       |    /// - returns: The server trust policy for the given host if found.
   54|      0|    open func serverTrustPolicy(forHost host: String) -> ServerTrustPolicy? {
   55|      0|        return policies[host]
   56|      0|    }
   57|       |}
   58|       |
   59|       |// MARK: -
   60|       |
   61|       |extension URLSession {
   62|       |    private struct AssociatedKeys {
   63|       |        static var managerKey = "URLSession.ServerTrustPolicyManager"
   64|       |    }
   65|       |
   66|       |    var serverTrustPolicyManager: ServerTrustPolicyManager? {
   67|      3|        get {
   68|      3|            return objc_getAssociatedObject(self, &AssociatedKeys.managerKey) as? ServerTrustPolicyManager
   69|      3|        }
   70|     11|        set (manager) {
   71|     11|            objc_setAssociatedObject(self, &AssociatedKeys.managerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
   72|     11|        }
   73|       |    }
   74|       |}
   75|       |
   76|       |// MARK: - ServerTrustPolicy
   77|       |
   78|       |/// The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when
   79|       |/// connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust
   80|       |/// with a given set of criteria to determine whether the server trust is valid and the connection should be made.
   81|       |///
   82|       |/// Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other
   83|       |/// vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged
   84|       |/// to route all communication over an HTTPS connection with pinning enabled.
   85|       |///
   86|       |/// - performDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to
   87|       |///                             validate the host provided by the challenge. Applications are encouraged to always
   88|       |///                             validate the host in production environments to guarantee the validity of the server's
   89|       |///                             certificate chain.
   90|       |///
   91|       |/// - performRevokedEvaluation: Uses the default and revoked server trust evaluations allowing you to control whether to
   92|       |///                             validate the host provided by the challenge as well as specify the revocation flags for
   93|       |///                             testing for revoked certificates. Apple platforms did not start testing for revoked
   94|       |///                             certificates automatically until iOS 10.1, macOS 10.12 and tvOS 10.1 which is
   95|       |///                             demonstrated in our TLS tests. Applications are encouraged to always validate the host
   96|       |///                             in production environments to guarantee the validity of the server's certificate chain.
   97|       |///
   98|       |/// - pinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
   99|       |///                             considered valid if one of the pinned certificates match one of the server certificates.
  100|       |///                             By validating both the certificate chain and host, certificate pinning provides a very
  101|       |///                             secure form of server trust validation mitigating most, if not all, MITM attacks.
  102|       |///                             Applications are encouraged to always validate the host and require a valid certificate
  103|       |///                             chain in production environments.
  104|       |///
  105|       |/// - pinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
  106|       |///                             valid if one of the pinned public keys match one of the server certificate public keys.
  107|       |///                             By validating both the certificate chain and host, public key pinning provides a very
  108|       |///                             secure form of server trust validation mitigating most, if not all, MITM attacks.
  109|       |///                             Applications are encouraged to always validate the host and require a valid certificate
  110|       |///                             chain in production environments.
  111|       |///
  112|       |/// - disableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
  113|       |///
  114|       |/// - customEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
  115|       |public enum ServerTrustPolicy {
  116|       |    case performDefaultEvaluation(validateHost: Bool)
  117|       |    case performRevokedEvaluation(validateHost: Bool, revocationFlags: CFOptionFlags)
  118|       |    case pinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
  119|       |    case pinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
  120|       |    case disableEvaluation
  121|       |    case customEvaluation((_ serverTrust: SecTrust, _ host: String) -> Bool)
  122|       |
  123|       |    // MARK: - Bundle Location
  124|       |
  125|       |    /// Returns all certificates within the given bundle with a `.cer` file extension.
  126|       |    ///
  127|       |    /// - parameter bundle: The bundle to search for all `.cer` files.
  128|       |    ///
  129|       |    /// - returns: All certificates within the given bundle.
  130|      0|    public static func certificates(in bundle: Bundle = Bundle.main) -> [SecCertificate] {
  131|      0|        var certificates: [SecCertificate] = []
  132|      0|
  133|      0|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
  134|      0|            bundle.paths(forResourcesOfType: fileExtension, inDirectory: nil)
  135|      0|        }.joined())
  136|      0|
  137|      0|        for path in paths {
  138|      0|            if
  139|      0|                let certificateData = try? Data(contentsOf: URL(fileURLWithPath: path)) as CFData,
  140|      0|                let certificate = SecCertificateCreateWithData(nil, certificateData)
  141|      0|            {
  142|      0|                certificates.append(certificate)
  143|      0|            }
  144|      0|        }
  145|      0|
  146|      0|        return certificates
  147|      0|    }
  148|       |
  149|       |    /// Returns all public keys within the given bundle with a `.cer` file extension.
  150|       |    ///
  151|       |    /// - parameter bundle: The bundle to search for all `*.cer` files.
  152|       |    ///
  153|       |    /// - returns: All public keys within the given bundle.
  154|      0|    public static func publicKeys(in bundle: Bundle = Bundle.main) -> [SecKey] {
  155|      0|        var publicKeys: [SecKey] = []
  156|      0|
  157|      0|        for certificate in certificates(in: bundle) {
  158|      0|            if let publicKey = publicKey(for: certificate) {
  159|      0|                publicKeys.append(publicKey)
  160|      0|            }
  161|      0|        }
  162|      0|
  163|      0|        return publicKeys
  164|      0|    }
  165|       |
  166|       |    // MARK: - Evaluation
  167|       |
  168|       |    /// Evaluates whether the server trust is valid for the given host.
  169|       |    ///
  170|       |    /// - parameter serverTrust: The server trust to evaluate.
  171|       |    /// - parameter host:        The host of the challenge protection space.
  172|       |    ///
  173|       |    /// - returns: Whether the server trust is valid.
  174|      0|    public func evaluate(_ serverTrust: SecTrust, forHost host: String) -> Bool {
  175|      0|        var serverTrustIsValid = false
  176|      0|
  177|      0|        switch self {
  178|      0|        case let .performDefaultEvaluation(validateHost):
  179|      0|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
  180|      0|            SecTrustSetPolicies(serverTrust, policy)
  181|      0|
  182|      0|            serverTrustIsValid = trustIsValid(serverTrust)
  183|      0|        case let .performRevokedEvaluation(validateHost, revocationFlags):
  184|      0|            let defaultPolicy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
  185|      0|            let revokedPolicy = SecPolicyCreateRevocation(revocationFlags)
  186|      0|            SecTrustSetPolicies(serverTrust, [defaultPolicy, revokedPolicy] as CFTypeRef)
  187|      0|
  188|      0|            serverTrustIsValid = trustIsValid(serverTrust)
  189|      0|        case let .pinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
  190|      0|            if validateCertificateChain {
  191|      0|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
  192|      0|                SecTrustSetPolicies(serverTrust, policy)
  193|      0|
  194|      0|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates as CFArray)
  195|      0|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
  196|      0|
  197|      0|                serverTrustIsValid = trustIsValid(serverTrust)
  198|      0|            } else {
  199|      0|                let serverCertificatesDataArray = certificateData(for: serverTrust)
  200|      0|                let pinnedCertificatesDataArray = certificateData(for: pinnedCertificates)
  201|      0|
  202|      0|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
  203|      0|                    for pinnedCertificateData in pinnedCertificatesDataArray {
  204|      0|                        if serverCertificateData == pinnedCertificateData {
  205|      0|                            serverTrustIsValid = true
  206|      0|                            break outerLoop
  207|      0|                        }
  208|      0|                    }
  209|      0|                }
  210|      0|            }
  211|      0|        case let .pinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
  212|      0|            var certificateChainEvaluationPassed = true
  213|      0|
  214|      0|            if validateCertificateChain {
  215|      0|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
  216|      0|                SecTrustSetPolicies(serverTrust, policy)
  217|      0|
  218|      0|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
  219|      0|            }
  220|      0|
  221|      0|            if certificateChainEvaluationPassed {
  222|      0|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeys(for: serverTrust) as [AnyObject] {
  223|      0|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
  224|      0|                        if serverPublicKey.isEqual(pinnedPublicKey) {
  225|      0|                            serverTrustIsValid = true
  226|      0|                            break outerLoop
  227|      0|                        }
  228|      0|                    }
  229|      0|                }
  230|      0|            }
  231|      0|        case .disableEvaluation:
  232|      0|            serverTrustIsValid = true
  233|      0|        case let .customEvaluation(closure):
  234|      0|            serverTrustIsValid = closure(serverTrust, host)
  235|      0|        }
  236|      0|
  237|      0|        return serverTrustIsValid
  238|      0|    }
  239|       |
  240|       |    // MARK: - Private - Trust Validation
  241|       |
  242|      0|    private func trustIsValid(_ trust: SecTrust) -> Bool {
  243|      0|        var isValid = false
  244|      0|
  245|      0|        var result = SecTrustResultType.invalid
  246|      0|        let status = SecTrustEvaluate(trust, &result)
  247|      0|
  248|      0|        if status == errSecSuccess {
  249|      0|            let unspecified = SecTrustResultType.unspecified
  250|      0|            let proceed = SecTrustResultType.proceed
  251|      0|
  252|      0|
  253|      0|            isValid = result == unspecified || result == proceed
  254|      0|        }
  255|      0|
  256|      0|        return isValid
  257|      0|    }
  258|       |
  259|       |    // MARK: - Private - Certificate Data
  260|       |
  261|      0|    private func certificateData(for trust: SecTrust) -> [Data] {
  262|      0|        var certificates: [SecCertificate] = []
  263|      0|
  264|      0|        for index in 0..<SecTrustGetCertificateCount(trust) {
  265|      0|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
  266|      0|                certificates.append(certificate)
  267|      0|            }
  268|      0|        }
  269|      0|
  270|      0|        return certificateData(for: certificates)
  271|      0|    }
  272|       |
  273|      0|    private func certificateData(for certificates: [SecCertificate]) -> [Data] {
  274|      0|        return certificates.map { SecCertificateCopyData($0) as Data }
  275|      0|    }
  276|       |
  277|       |    // MARK: - Private - Public Key Extraction
  278|       |
  279|      0|    private static func publicKeys(for trust: SecTrust) -> [SecKey] {
  280|      0|        var publicKeys: [SecKey] = []
  281|      0|
  282|      0|        for index in 0..<SecTrustGetCertificateCount(trust) {
  283|      0|            if
  284|      0|                let certificate = SecTrustGetCertificateAtIndex(trust, index),
  285|      0|                let publicKey = publicKey(for: certificate)
  286|      0|            {
  287|      0|                publicKeys.append(publicKey)
  288|      0|            }
  289|      0|        }
  290|      0|
  291|      0|        return publicKeys
  292|      0|    }
  293|       |
  294|      0|    private static func publicKey(for certificate: SecCertificate) -> SecKey? {
  295|      0|        var publicKey: SecKey?
  296|      0|
  297|      0|        let policy = SecPolicyCreateBasicX509()
  298|      0|        var trust: SecTrust?
  299|      0|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
  300|      0|
  301|      0|        if let trust = trust, trustCreationStatus == errSecSuccess {
  302|      0|            publicKey = SecTrustCopyPublicKey(trust)
  303|      0|        }
  304|      0|
  305|      0|        return publicKey
  306|      0|    }
  307|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/SessionDelegate.swift:
    1|       |//
    2|       |//  SessionDelegate.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Responsible for handling all delegate callbacks for the underlying session.
   28|       |open class SessionDelegate: NSObject {
   29|       |
   30|       |    // MARK: URLSessionDelegate Overrides
   31|       |
   32|       |    /// Overrides default behavior for URLSessionDelegate method `urlSession(_:didBecomeInvalidWithError:)`.
   33|       |    open var sessionDidBecomeInvalidWithError: ((URLSession, Error?) -> Void)?
   34|       |
   35|       |    /// Overrides default behavior for URLSessionDelegate method `urlSession(_:didReceive:completionHandler:)`.
   36|       |    open var sessionDidReceiveChallenge: ((URLSession, URLAuthenticationChallenge) -> (URLSession.AuthChallengeDisposition, URLCredential?))?
   37|       |
   38|       |    /// Overrides all behavior for URLSessionDelegate method `urlSession(_:didReceive:completionHandler:)` and requires the caller to call the `completionHandler`.
   39|       |    open var sessionDidReceiveChallengeWithCompletion: ((URLSession, URLAuthenticationChallenge, @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) -> Void)?
   40|       |
   41|       |    /// Overrides default behavior for URLSessionDelegate method `urlSessionDidFinishEvents(forBackgroundURLSession:)`.
   42|       |    open var sessionDidFinishEventsForBackgroundURLSession: ((URLSession) -> Void)?
   43|       |
   44|       |    // MARK: URLSessionTaskDelegate Overrides
   45|       |
   46|       |    /// Overrides default behavior for URLSessionTaskDelegate method `urlSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)`.
   47|       |    open var taskWillPerformHTTPRedirection: ((URLSession, URLSessionTask, HTTPURLResponse, URLRequest) -> URLRequest?)?
   48|       |
   49|       |    /// Overrides all behavior for URLSessionTaskDelegate method `urlSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)` and
   50|       |    /// requires the caller to call the `completionHandler`.
   51|       |    open var taskWillPerformHTTPRedirectionWithCompletion: ((URLSession, URLSessionTask, HTTPURLResponse, URLRequest, @escaping (URLRequest?) -> Void) -> Void)?
   52|       |
   53|       |    /// Overrides default behavior for URLSessionTaskDelegate method `urlSession(_:task:didReceive:completionHandler:)`.
   54|       |    open var taskDidReceiveChallenge: ((URLSession, URLSessionTask, URLAuthenticationChallenge) -> (URLSession.AuthChallengeDisposition, URLCredential?))?
   55|       |
   56|       |    /// Overrides all behavior for URLSessionTaskDelegate method `urlSession(_:task:didReceive:completionHandler:)` and
   57|       |    /// requires the caller to call the `completionHandler`.
   58|       |    open var taskDidReceiveChallengeWithCompletion: ((URLSession, URLSessionTask, URLAuthenticationChallenge, @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) -> Void)?
   59|       |
   60|       |    /// Overrides default behavior for URLSessionTaskDelegate method `urlSession(_:task:needNewBodyStream:)`.
   61|       |    open var taskNeedNewBodyStream: ((URLSession, URLSessionTask) -> InputStream?)?
   62|       |
   63|       |    /// Overrides all behavior for URLSessionTaskDelegate method `urlSession(_:task:needNewBodyStream:)` and
   64|       |    /// requires the caller to call the `completionHandler`.
   65|       |    open var taskNeedNewBodyStreamWithCompletion: ((URLSession, URLSessionTask, @escaping (InputStream?) -> Void) -> Void)?
   66|       |
   67|       |    /// Overrides default behavior for URLSessionTaskDelegate method `urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)`.
   68|       |    open var taskDidSendBodyData: ((URLSession, URLSessionTask, Int64, Int64, Int64) -> Void)?
   69|       |
   70|       |    /// Overrides default behavior for URLSessionTaskDelegate method `urlSession(_:task:didCompleteWithError:)`.
   71|       |    open var taskDidComplete: ((URLSession, URLSessionTask, Error?) -> Void)?
   72|       |
   73|       |    // MARK: URLSessionDataDelegate Overrides
   74|       |
   75|       |    /// Overrides default behavior for URLSessionDataDelegate method `urlSession(_:dataTask:didReceive:completionHandler:)`.
   76|       |    open var dataTaskDidReceiveResponse: ((URLSession, URLSessionDataTask, URLResponse) -> URLSession.ResponseDisposition)?
   77|       |
   78|       |    /// Overrides all behavior for URLSessionDataDelegate method `urlSession(_:dataTask:didReceive:completionHandler:)` and
   79|       |    /// requires caller to call the `completionHandler`.
   80|       |    open var dataTaskDidReceiveResponseWithCompletion: ((URLSession, URLSessionDataTask, URLResponse, @escaping (URLSession.ResponseDisposition) -> Void) -> Void)?
   81|       |
   82|       |    /// Overrides default behavior for URLSessionDataDelegate method `urlSession(_:dataTask:didBecome:)`.
   83|       |    open var dataTaskDidBecomeDownloadTask: ((URLSession, URLSessionDataTask, URLSessionDownloadTask) -> Void)?
   84|       |
   85|       |    /// Overrides default behavior for URLSessionDataDelegate method `urlSession(_:dataTask:didReceive:)`.
   86|       |    open var dataTaskDidReceiveData: ((URLSession, URLSessionDataTask, Data) -> Void)?
   87|       |
   88|       |    /// Overrides default behavior for URLSessionDataDelegate method `urlSession(_:dataTask:willCacheResponse:completionHandler:)`.
   89|       |    open var dataTaskWillCacheResponse: ((URLSession, URLSessionDataTask, CachedURLResponse) -> CachedURLResponse?)?
   90|       |
   91|       |    /// Overrides all behavior for URLSessionDataDelegate method `urlSession(_:dataTask:willCacheResponse:completionHandler:)` and
   92|       |    /// requires caller to call the `completionHandler`.
   93|       |    open var dataTaskWillCacheResponseWithCompletion: ((URLSession, URLSessionDataTask, CachedURLResponse, @escaping (CachedURLResponse?) -> Void) -> Void)?
   94|       |
   95|       |    // MARK: URLSessionDownloadDelegate Overrides
   96|       |
   97|       |    /// Overrides default behavior for URLSessionDownloadDelegate method `urlSession(_:downloadTask:didFinishDownloadingTo:)`.
   98|       |    open var downloadTaskDidFinishDownloadingToURL: ((URLSession, URLSessionDownloadTask, URL) -> Void)?
   99|       |
  100|       |    /// Overrides default behavior for URLSessionDownloadDelegate method `urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)`.
  101|       |    open var downloadTaskDidWriteData: ((URLSession, URLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
  102|       |
  103|       |    /// Overrides default behavior for URLSessionDownloadDelegate method `urlSession(_:downloadTask:didResumeAtOffset:expectedTotalBytes:)`.
  104|       |    open var downloadTaskDidResumeAtOffset: ((URLSession, URLSessionDownloadTask, Int64, Int64) -> Void)?
  105|       |
  106|       |    // MARK: URLSessionStreamDelegate Overrides
  107|       |
  108|       |#if !os(watchOS)
  109|       |
  110|       |    /// Overrides default behavior for URLSessionStreamDelegate method `urlSession(_:readClosedFor:)`.
  111|       |    @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  112|       |    open var streamTaskReadClosed: ((URLSession, URLSessionStreamTask) -> Void)? {
  113|      0|        get {
  114|      0|            return _streamTaskReadClosed as? (URLSession, URLSessionStreamTask) -> Void
  115|      0|        }
  116|      0|        set {
  117|      0|            _streamTaskReadClosed = newValue
  118|      0|        }
  119|       |    }
  120|       |
  121|       |    /// Overrides default behavior for URLSessionStreamDelegate method `urlSession(_:writeClosedFor:)`.
  122|       |    @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  123|       |    open var streamTaskWriteClosed: ((URLSession, URLSessionStreamTask) -> Void)? {
  124|      0|        get {
  125|      0|            return _streamTaskWriteClosed as? (URLSession, URLSessionStreamTask) -> Void
  126|      0|        }
  127|      0|        set {
  128|      0|            _streamTaskWriteClosed = newValue
  129|      0|        }
  130|       |    }
  131|       |
  132|       |    /// Overrides default behavior for URLSessionStreamDelegate method `urlSession(_:betterRouteDiscoveredFor:)`.
  133|       |    @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  134|       |    open var streamTaskBetterRouteDiscovered: ((URLSession, URLSessionStreamTask) -> Void)? {
  135|      0|        get {
  136|      0|            return _streamTaskBetterRouteDiscovered as? (URLSession, URLSessionStreamTask) -> Void
  137|      0|        }
  138|      0|        set {
  139|      0|            _streamTaskBetterRouteDiscovered = newValue
  140|      0|        }
  141|       |    }
  142|       |
  143|       |    /// Overrides default behavior for URLSessionStreamDelegate method `urlSession(_:streamTask:didBecome:outputStream:)`.
  144|       |    @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  145|       |    open var streamTaskDidBecomeInputAndOutputStreams: ((URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void)? {
  146|      0|        get {
  147|      0|            return _streamTaskDidBecomeInputStream as? (URLSession, URLSessionStreamTask, InputStream, OutputStream) -> Void
  148|      0|        }
  149|      0|        set {
  150|      0|            _streamTaskDidBecomeInputStream = newValue
  151|      0|        }
  152|       |    }
  153|       |
  154|       |    var _streamTaskReadClosed: Any?
  155|       |    var _streamTaskWriteClosed: Any?
  156|       |    var _streamTaskBetterRouteDiscovered: Any?
  157|       |    var _streamTaskDidBecomeInputStream: Any?
  158|       |
  159|       |#endif
  160|       |
  161|       |    // MARK: Properties
  162|       |
  163|       |    var retrier: RequestRetrier?
  164|       |    weak var sessionManager: SessionManager?
  165|       |
  166|       |    var requests: [Int: Request] = [:]
  167|       |    private let lock = NSLock()
  168|       |
  169|       |    /// Access the task delegate for the specified task in a thread-safe manner.
  170|       |    open subscript(task: URLSessionTask) -> Request? {
  171|  3.23k|        get {
  172|  3.23k|            lock.lock() ; defer { lock.unlock() }
  173|  3.23k|            return requests[task.taskIdentifier]
  174|  3.23k|        }
  175|    947|        set {
  176|    947|            lock.lock() ; defer { lock.unlock() }
  177|    947|            requests[task.taskIdentifier] = newValue
  178|    947|        }
  179|       |    }
  180|       |
  181|       |    // MARK: Lifecycle
  182|       |
  183|       |    /// Initializes the `SessionDelegate` instance.
  184|       |    ///
  185|       |    /// - returns: The new `SessionDelegate` instance.
  186|     11|    public override init() {
  187|     11|        super.init()
  188|     11|    }
  189|       |
  190|       |    // MARK: NSObject Overrides
  191|       |
  192|       |    /// Returns a `Bool` indicating whether the `SessionDelegate` implements or inherits a method that can respond
  193|       |    /// to a specified message.
  194|       |    ///
  195|       |    /// - parameter selector: A selector that identifies a message.
  196|       |    ///
  197|       |    /// - returns: `true` if the receiver implements or inherits a method that can respond to selector, otherwise `false`.
  198|  8.36k|    open override func responds(to selector: Selector) -> Bool {
  199|  8.36k|        #if !os(macOS)
  200|  8.36k|            if selector == #selector(URLSessionDelegate.urlSessionDidFinishEvents(forBackgroundURLSession:)) {
  201|      0|                return sessionDidFinishEventsForBackgroundURLSession != nil
  202|  8.36k|            }
  203|  8.36k|        #endif
  204|  8.36k|
  205|  8.36k|        #if !os(watchOS)
  206|  8.36k|            if #available(iOS 9.0, macOS 10.11, tvOS 9.0, *) {
  207|  8.36k|                switch selector {
  208|  8.36k|                case #selector(URLSessionStreamDelegate.urlSession(_:readClosedFor:)):
  209|      0|                    return streamTaskReadClosed != nil
  210|  8.36k|                case #selector(URLSessionStreamDelegate.urlSession(_:writeClosedFor:)):
  211|      0|                    return streamTaskWriteClosed != nil
  212|  8.36k|                case #selector(URLSessionStreamDelegate.urlSession(_:betterRouteDiscoveredFor:)):
  213|      0|                    return streamTaskBetterRouteDiscovered != nil
  214|  8.36k|                case #selector(URLSessionStreamDelegate.urlSession(_:streamTask:didBecome:outputStream:)):
  215|      0|                    return streamTaskDidBecomeInputAndOutputStreams != nil
  216|  8.36k|                default:
  217|  8.36k|                    break
  218|  8.36k|                }
  219|  8.36k|            }
  220|  8.36k|        #endif
  221|  8.36k|
  222|  8.36k|        switch selector {
  223|  8.36k|        case #selector(URLSessionDelegate.urlSession(_:didBecomeInvalidWithError:)):
  224|      0|            return sessionDidBecomeInvalidWithError != nil
  225|  8.36k|        case #selector(URLSessionDelegate.urlSession(_:didReceive:completionHandler:)):
  226|      3|            return (sessionDidReceiveChallenge != nil  || sessionDidReceiveChallengeWithCompletion != nil)
  227|  8.36k|        case #selector(URLSessionTaskDelegate.urlSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)):
  228|      0|            return (taskWillPerformHTTPRedirection != nil || taskWillPerformHTTPRedirectionWithCompletion != nil)
  229|  8.36k|        case #selector(URLSessionDataDelegate.urlSession(_:dataTask:didReceive:completionHandler:)):
  230|    473|            return (dataTaskDidReceiveResponse != nil || dataTaskDidReceiveResponseWithCompletion != nil)
  231|  8.36k|        default:
  232|  7.88k|            return type(of: self).instancesRespond(to: selector)
  233|  8.36k|        }
  234|  8.36k|    }
  235|       |}
  236|       |
  237|       |// MARK: - URLSessionDelegate
  238|       |
  239|       |extension SessionDelegate: URLSessionDelegate {
  240|       |    /// Tells the delegate that the session has been invalidated.
  241|       |    ///
  242|       |    /// - parameter session: The session object that was invalidated.
  243|       |    /// - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
  244|      0|    open func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) {
  245|      0|        sessionDidBecomeInvalidWithError?(session, error)
  246|      0|    }
  247|       |
  248|       |    /// Requests credentials from the delegate in response to a session-level authentication request from the
  249|       |    /// remote server.
  250|       |    ///
  251|       |    /// - parameter session:           The session containing the task that requested authentication.
  252|       |    /// - parameter challenge:         An object that contains the request for authentication.
  253|       |    /// - parameter completionHandler: A handler that your delegate method must call providing the disposition
  254|       |    ///                                and credential.
  255|       |    open func urlSession(
  256|       |        _ session: URLSession,
  257|       |        didReceive challenge: URLAuthenticationChallenge,
  258|       |        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  259|      0|    {
  260|      0|        guard sessionDidReceiveChallengeWithCompletion == nil else {
  261|      0|            sessionDidReceiveChallengeWithCompletion?(session, challenge, completionHandler)
  262|      0|            return
  263|      0|        }
  264|      0|
  265|      0|        var disposition: URLSession.AuthChallengeDisposition = .performDefaultHandling
  266|      0|        var credential: URLCredential?
  267|      0|
  268|      0|        if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
  269|      0|            (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
  270|      0|        } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
  271|      0|            let host = challenge.protectionSpace.host
  272|      0|
  273|      0|            if
  274|      0|                let serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicy(forHost: host),
  275|      0|                let serverTrust = challenge.protectionSpace.serverTrust
  276|      0|            {
  277|      0|                if serverTrustPolicy.evaluate(serverTrust, forHost: host) {
  278|      0|                    disposition = .useCredential
  279|      0|                    credential = URLCredential(trust: serverTrust)
  280|      0|                } else {
  281|      0|                    disposition = .cancelAuthenticationChallenge
  282|      0|                }
  283|      0|            }
  284|      0|        }
  285|      0|
  286|      0|        completionHandler(disposition, credential)
  287|      0|    }
  288|       |
  289|       |#if !os(macOS)
  290|       |
  291|       |    /// Tells the delegate that all messages enqueued for a session have been delivered.
  292|       |    ///
  293|       |    /// - parameter session: The session that no longer has any outstanding requests.
  294|      0|    open func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
  295|      0|        sessionDidFinishEventsForBackgroundURLSession?(session)
  296|      0|    }
  297|       |
  298|       |#endif
  299|       |}
  300|       |
  301|       |// MARK: - URLSessionTaskDelegate
  302|       |
  303|       |extension SessionDelegate: URLSessionTaskDelegate {
  304|       |    /// Tells the delegate that the remote server requested an HTTP redirect.
  305|       |    ///
  306|       |    /// - parameter session:           The session containing the task whose request resulted in a redirect.
  307|       |    /// - parameter task:              The task whose request resulted in a redirect.
  308|       |    /// - parameter response:          An object containing the server’s response to the original request.
  309|       |    /// - parameter request:           A URL request object filled out with the new location.
  310|       |    /// - parameter completionHandler: A closure that your handler should call with either the value of the request
  311|       |    ///                                parameter, a modified URL request object, or NULL to refuse the redirect and
  312|       |    ///                                return the body of the redirect response.
  313|       |    open func urlSession(
  314|       |        _ session: URLSession,
  315|       |        task: URLSessionTask,
  316|       |        willPerformHTTPRedirection response: HTTPURLResponse,
  317|       |        newRequest request: URLRequest,
  318|       |        completionHandler: @escaping (URLRequest?) -> Void)
  319|      0|    {
  320|      0|        guard taskWillPerformHTTPRedirectionWithCompletion == nil else {
  321|      0|            taskWillPerformHTTPRedirectionWithCompletion?(session, task, response, request, completionHandler)
  322|      0|            return
  323|      0|        }
  324|      0|
  325|      0|        var redirectRequest: URLRequest? = request
  326|      0|
  327|      0|        if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
  328|      0|            redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
  329|      0|        }
  330|      0|
  331|      0|        completionHandler(redirectRequest)
  332|      0|    }
  333|       |
  334|       |    /// Requests credentials from the delegate in response to an authentication request from the remote server.
  335|       |    ///
  336|       |    /// - parameter session:           The session containing the task whose request requires authentication.
  337|       |    /// - parameter task:              The task whose request requires authentication.
  338|       |    /// - parameter challenge:         An object that contains the request for authentication.
  339|       |    /// - parameter completionHandler: A handler that your delegate method must call providing the disposition
  340|       |    ///                                and credential.
  341|       |    open func urlSession(
  342|       |        _ session: URLSession,
  343|       |        task: URLSessionTask,
  344|       |        didReceive challenge: URLAuthenticationChallenge,
  345|       |        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  346|      3|    {
  347|      3|        guard taskDidReceiveChallengeWithCompletion == nil else {
  348|      0|            taskDidReceiveChallengeWithCompletion?(session, task, challenge, completionHandler)
  349|      0|            return
  350|      3|        }
  351|      3|
  352|      3|        if let taskDidReceiveChallenge = taskDidReceiveChallenge {
  353|      0|            let result = taskDidReceiveChallenge(session, task, challenge)
  354|      0|            completionHandler(result.0, result.1)
  355|      3|        } else if let delegate = self[task]?.delegate {
  356|      3|            delegate.urlSession(
  357|      3|                session,
  358|      3|                task: task,
  359|      3|                didReceive: challenge,
  360|      3|                completionHandler: completionHandler
  361|      3|            )
  362|      3|        } else {
  363|      0|            urlSession(session, didReceive: challenge, completionHandler: completionHandler)
  364|      3|        }
  365|      3|    }
  366|       |
  367|       |    /// Tells the delegate when a task requires a new request body stream to send to the remote server.
  368|       |    ///
  369|       |    /// - parameter session:           The session containing the task that needs a new body stream.
  370|       |    /// - parameter task:              The task that needs a new body stream.
  371|       |    /// - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  372|       |    open func urlSession(
  373|       |        _ session: URLSession,
  374|       |        task: URLSessionTask,
  375|       |        needNewBodyStream completionHandler: @escaping (InputStream?) -> Void)
  376|      0|    {
  377|      0|        guard taskNeedNewBodyStreamWithCompletion == nil else {
  378|      0|            taskNeedNewBodyStreamWithCompletion?(session, task, completionHandler)
  379|      0|            return
  380|      0|        }
  381|      0|
  382|      0|        if let taskNeedNewBodyStream = taskNeedNewBodyStream {
  383|      0|            completionHandler(taskNeedNewBodyStream(session, task))
  384|      0|        } else if let delegate = self[task]?.delegate {
  385|      0|            delegate.urlSession(session, task: task, needNewBodyStream: completionHandler)
  386|      0|        }
  387|      0|    }
  388|       |
  389|       |    /// Periodically informs the delegate of the progress of sending body content to the server.
  390|       |    ///
  391|       |    /// - parameter session:                  The session containing the data task.
  392|       |    /// - parameter task:                     The data task.
  393|       |    /// - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
  394|       |    /// - parameter totalBytesSent:           The total number of bytes sent so far.
  395|       |    /// - parameter totalBytesExpectedToSend: The expected length of the body data.
  396|       |    open func urlSession(
  397|       |        _ session: URLSession,
  398|       |        task: URLSessionTask,
  399|       |        didSendBodyData bytesSent: Int64,
  400|       |        totalBytesSent: Int64,
  401|       |        totalBytesExpectedToSend: Int64)
  402|      0|    {
  403|      0|        if let taskDidSendBodyData = taskDidSendBodyData {
  404|      0|            taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
  405|      0|        } else if let delegate = self[task]?.delegate as? UploadTaskDelegate {
  406|      0|            delegate.URLSession(
  407|      0|                session,
  408|      0|                task: task,
  409|      0|                didSendBodyData: bytesSent,
  410|      0|                totalBytesSent: totalBytesSent,
  411|      0|                totalBytesExpectedToSend: totalBytesExpectedToSend
  412|      0|            )
  413|      0|        }
  414|      0|    }
  415|       |
  416|       |#if !os(watchOS)
  417|       |
  418|       |    /// Tells the delegate that the session finished collecting metrics for the task.
  419|       |    ///
  420|       |    /// - parameter session: The session collecting the metrics.
  421|       |    /// - parameter task:    The task whose metrics have been collected.
  422|       |    /// - parameter metrics: The collected metrics.
  423|       |    @available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
  424|       |    @objc(URLSession:task:didFinishCollectingMetrics:)
  425|    473|    open func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) {
  426|    473|        self[task]?.delegate.metrics = metrics
  427|    473|    }
  428|       |
  429|       |#endif
  430|       |
  431|       |    /// Tells the delegate that the task finished transferring data.
  432|       |    ///
  433|       |    /// - parameter session: The session containing the task whose request finished transferring data.
  434|       |    /// - parameter task:    The task whose request finished transferring data.
  435|       |    /// - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
  436|    473|    open func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
  437|    473|        /// Executed after it is determined that the request is not going to be retried
  438|    473|        let completeTask: (URLSession, URLSessionTask, Error?) -> Void = { [weak self] session, task, error in
  439|    473|            guard let strongSelf = self else { return }
  440|    473|
  441|    473|            strongSelf.taskDidComplete?(session, task, error)
  442|    473|
  443|    473|            strongSelf[task]?.delegate.urlSession(session, task: task, didCompleteWithError: error)
  444|    473|
  445|    473|            var userInfo: [String: Any] = [Notification.Key.Task: task]
  446|    473|
  447|    473|            if let data = (strongSelf[task]?.delegate as? DataTaskDelegate)?.data {
  448|    473|                userInfo[Notification.Key.ResponseData] = data
  449|    473|            }
  450|    473|
  451|    473|            NotificationCenter.default.post(
  452|    473|                name: Notification.Name.Task.DidComplete,
  453|    473|                object: strongSelf,
  454|    473|                userInfo: userInfo
  455|    473|            )
  456|    473|
  457|    473|            strongSelf[task] = nil
  458|    473|        }
  459|    473|
  460|    473|        guard let request = self[task], let sessionManager = sessionManager else {
  461|      0|            completeTask(session, task, error)
  462|      0|            return
  463|    473|        }
  464|    473|
  465|    473|        // Run all validations on the request before checking if an error occurred
  466|    473|        request.validations.forEach { $0() }
  467|    473|
  468|    473|        // Determine whether an error has occurred
  469|    473|        var error: Error? = error
  470|    473|
  471|    473|        if request.delegate.error != nil {
  472|      0|            error = request.delegate.error
  473|    473|        }
  474|    473|
  475|    473|        /// If an error occurred and the retrier is set, asynchronously ask the retrier if the request
  476|    473|        /// should be retried. Otherwise, complete the task by notifying the task delegate.
  477|    473|        if let retrier = retrier, let error = error {
  478|      0|            retrier.should(sessionManager, retry: request, with: error) { [weak self] shouldRetry, timeDelay in
  479|      0|                guard shouldRetry else { completeTask(session, task, error) ; return }
  480|      0|
  481|      0|                DispatchQueue.utility.after(timeDelay) { [weak self] in
  482|      0|                    guard let strongSelf = self else { return }
  483|      0|
  484|      0|                    let retrySucceeded = strongSelf.sessionManager?.retry(request) ?? false
  485|      0|
  486|      0|                    if retrySucceeded, let task = request.task {
  487|      0|                        strongSelf[task] = request
  488|      0|                        return
  489|      0|                    } else {
  490|      0|                        completeTask(session, task, error)
  491|      0|                    }
  492|      0|                }
  493|      0|            }
  494|    473|        } else {
  495|    473|            completeTask(session, task, error)
  496|    473|        }
  497|    473|    }
  498|       |}
  499|       |
  500|       |// MARK: - URLSessionDataDelegate
  501|       |
  502|       |extension SessionDelegate: URLSessionDataDelegate {
  503|       |    /// Tells the delegate that the data task received the initial reply (headers) from the server.
  504|       |    ///
  505|       |    /// - parameter session:           The session containing the data task that received an initial reply.
  506|       |    /// - parameter dataTask:          The data task that received an initial reply.
  507|       |    /// - parameter response:          A URL response object populated with headers.
  508|       |    /// - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a
  509|       |    ///                                constant to indicate whether the transfer should continue as a data task or
  510|       |    ///                                should become a download task.
  511|       |    open func urlSession(
  512|       |        _ session: URLSession,
  513|       |        dataTask: URLSessionDataTask,
  514|       |        didReceive response: URLResponse,
  515|       |        completionHandler: @escaping (URLSession.ResponseDisposition) -> Void)
  516|      0|    {
  517|      0|        guard dataTaskDidReceiveResponseWithCompletion == nil else {
  518|      0|            dataTaskDidReceiveResponseWithCompletion?(session, dataTask, response, completionHandler)
  519|      0|            return
  520|      0|        }
  521|      0|
  522|      0|        var disposition: URLSession.ResponseDisposition = .allow
  523|      0|
  524|      0|        if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
  525|      0|            disposition = dataTaskDidReceiveResponse(session, dataTask, response)
  526|      0|        }
  527|      0|
  528|      0|        completionHandler(disposition)
  529|      0|    }
  530|       |
  531|       |    /// Tells the delegate that the data task was changed to a download task.
  532|       |    ///
  533|       |    /// - parameter session:      The session containing the task that was replaced by a download task.
  534|       |    /// - parameter dataTask:     The data task that was replaced by a download task.
  535|       |    /// - parameter downloadTask: The new download task that replaced the data task.
  536|       |    open func urlSession(
  537|       |        _ session: URLSession,
  538|       |        dataTask: URLSessionDataTask,
  539|       |        didBecome downloadTask: URLSessionDownloadTask)
  540|      0|    {
  541|      0|        if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
  542|      0|            dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
  543|      0|        } else {
  544|      0|            self[downloadTask]?.delegate = DownloadTaskDelegate(task: downloadTask)
  545|      0|        }
  546|      0|    }
  547|       |
  548|       |    /// Tells the delegate that the data task has received some of the expected data.
  549|       |    ///
  550|       |    /// - parameter session:  The session containing the data task that provided data.
  551|       |    /// - parameter dataTask: The data task that provided data.
  552|       |    /// - parameter data:     A data object containing the transferred data.
  553|    862|    open func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
  554|    862|        if let dataTaskDidReceiveData = dataTaskDidReceiveData {
  555|      0|            dataTaskDidReceiveData(session, dataTask, data)
  556|    862|        } else if let delegate = self[dataTask]?.delegate as? DataTaskDelegate {
  557|    862|            delegate.urlSession(session, dataTask: dataTask, didReceive: data)
  558|    862|        }
  559|    862|    }
  560|       |
  561|       |    /// Asks the delegate whether the data (or upload) task should store the response in the cache.
  562|       |    ///
  563|       |    /// - parameter session:           The session containing the data (or upload) task.
  564|       |    /// - parameter dataTask:          The data (or upload) task.
  565|       |    /// - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current
  566|       |    ///                                caching policy and the values of certain received headers, such as the Pragma
  567|       |    ///                                and Cache-Control headers.
  568|       |    /// - parameter completionHandler: A block that your handler must call, providing either the original proposed
  569|       |    ///                                response, a modified version of that response, or NULL to prevent caching the
  570|       |    ///                                response. If your delegate implements this method, it must call this completion
  571|       |    ///                                handler; otherwise, your app leaks memory.
  572|       |    open func urlSession(
  573|       |        _ session: URLSession,
  574|       |        dataTask: URLSessionDataTask,
  575|       |        willCacheResponse proposedResponse: CachedURLResponse,
  576|       |        completionHandler: @escaping (CachedURLResponse?) -> Void)
  577|    473|    {
  578|    473|        guard dataTaskWillCacheResponseWithCompletion == nil else {
  579|      0|            dataTaskWillCacheResponseWithCompletion?(session, dataTask, proposedResponse, completionHandler)
  580|      0|            return
  581|    473|        }
  582|    473|
  583|    473|        if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
  584|      0|            completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
  585|    473|        } else if let delegate = self[dataTask]?.delegate as? DataTaskDelegate {
  586|    473|            delegate.urlSession(
  587|    473|                session,
  588|    473|                dataTask: dataTask,
  589|    473|                willCacheResponse: proposedResponse,
  590|    473|                completionHandler: completionHandler
  591|    473|            )
  592|    473|        } else {
  593|      0|            completionHandler(proposedResponse)
  594|    473|        }
  595|    473|    }
  596|       |}
  597|       |
  598|       |// MARK: - URLSessionDownloadDelegate
  599|       |
  600|       |extension SessionDelegate: URLSessionDownloadDelegate {
  601|       |    /// Tells the delegate that a download task has finished downloading.
  602|       |    ///
  603|       |    /// - parameter session:      The session containing the download task that finished.
  604|       |    /// - parameter downloadTask: The download task that finished.
  605|       |    /// - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either
  606|       |    ///                           open the file for reading or move it to a permanent location in your app’s sandbox
  607|       |    ///                           container directory before returning from this delegate method.
  608|       |    open func urlSession(
  609|       |        _ session: URLSession,
  610|       |        downloadTask: URLSessionDownloadTask,
  611|       |        didFinishDownloadingTo location: URL)
  612|      0|    {
  613|      0|        if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
  614|      0|            downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
  615|      0|        } else if let delegate = self[downloadTask]?.delegate as? DownloadTaskDelegate {
  616|      0|            delegate.urlSession(session, downloadTask: downloadTask, didFinishDownloadingTo: location)
  617|      0|        }
  618|      0|    }
  619|       |
  620|       |    /// Periodically informs the delegate about the download’s progress.
  621|       |    ///
  622|       |    /// - parameter session:                   The session containing the download task.
  623|       |    /// - parameter downloadTask:              The download task.
  624|       |    /// - parameter bytesWritten:              The number of bytes transferred since the last time this delegate
  625|       |    ///                                        method was called.
  626|       |    /// - parameter totalBytesWritten:         The total number of bytes transferred so far.
  627|       |    /// - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length
  628|       |    ///                                        header. If this header was not provided, the value is
  629|       |    ///                                        `NSURLSessionTransferSizeUnknown`.
  630|       |    open func urlSession(
  631|       |        _ session: URLSession,
  632|       |        downloadTask: URLSessionDownloadTask,
  633|       |        didWriteData bytesWritten: Int64,
  634|       |        totalBytesWritten: Int64,
  635|       |        totalBytesExpectedToWrite: Int64)
  636|      0|    {
  637|      0|        if let downloadTaskDidWriteData = downloadTaskDidWriteData {
  638|      0|            downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
  639|      0|        } else if let delegate = self[downloadTask]?.delegate as? DownloadTaskDelegate {
  640|      0|            delegate.urlSession(
  641|      0|                session,
  642|      0|                downloadTask: downloadTask,
  643|      0|                didWriteData: bytesWritten,
  644|      0|                totalBytesWritten: totalBytesWritten,
  645|      0|                totalBytesExpectedToWrite: totalBytesExpectedToWrite
  646|      0|            )
  647|      0|        }
  648|      0|    }
  649|       |
  650|       |    /// Tells the delegate that the download task has resumed downloading.
  651|       |    ///
  652|       |    /// - parameter session:            The session containing the download task that finished.
  653|       |    /// - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
  654|       |    /// - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the
  655|       |    ///                                 existing content, then this value is zero. Otherwise, this value is an
  656|       |    ///                                 integer representing the number of bytes on disk that do not need to be
  657|       |    ///                                 retrieved again.
  658|       |    /// - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header.
  659|       |    ///                                 If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
  660|       |    open func urlSession(
  661|       |        _ session: URLSession,
  662|       |        downloadTask: URLSessionDownloadTask,
  663|       |        didResumeAtOffset fileOffset: Int64,
  664|       |        expectedTotalBytes: Int64)
  665|      0|    {
  666|      0|        if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
  667|      0|            downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
  668|      0|        } else if let delegate = self[downloadTask]?.delegate as? DownloadTaskDelegate {
  669|      0|            delegate.urlSession(
  670|      0|                session,
  671|      0|                downloadTask: downloadTask,
  672|      0|                didResumeAtOffset: fileOffset,
  673|      0|                expectedTotalBytes: expectedTotalBytes
  674|      0|            )
  675|      0|        }
  676|      0|    }
  677|       |}
  678|       |
  679|       |// MARK: - URLSessionStreamDelegate
  680|       |
  681|       |#if !os(watchOS)
  682|       |
  683|       |@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  684|       |extension SessionDelegate: URLSessionStreamDelegate {
  685|       |    /// Tells the delegate that the read side of the connection has been closed.
  686|       |    ///
  687|       |    /// - parameter session:    The session.
  688|       |    /// - parameter streamTask: The stream task.
  689|      0|    open func urlSession(_ session: URLSession, readClosedFor streamTask: URLSessionStreamTask) {
  690|      0|        streamTaskReadClosed?(session, streamTask)
  691|      0|    }
  692|       |
  693|       |    /// Tells the delegate that the write side of the connection has been closed.
  694|       |    ///
  695|       |    /// - parameter session:    The session.
  696|       |    /// - parameter streamTask: The stream task.
  697|      0|    open func urlSession(_ session: URLSession, writeClosedFor streamTask: URLSessionStreamTask) {
  698|      0|        streamTaskWriteClosed?(session, streamTask)
  699|      0|    }
  700|       |
  701|       |    /// Tells the delegate that the system has determined that a better route to the host is available.
  702|       |    ///
  703|       |    /// - parameter session:    The session.
  704|       |    /// - parameter streamTask: The stream task.
  705|      0|    open func urlSession(_ session: URLSession, betterRouteDiscoveredFor streamTask: URLSessionStreamTask) {
  706|      0|        streamTaskBetterRouteDiscovered?(session, streamTask)
  707|      0|    }
  708|       |
  709|       |    /// Tells the delegate that the stream task has been completed and provides the unopened stream objects.
  710|       |    ///
  711|       |    /// - parameter session:      The session.
  712|       |    /// - parameter streamTask:   The stream task.
  713|       |    /// - parameter inputStream:  The new input stream.
  714|       |    /// - parameter outputStream: The new output stream.
  715|       |    open func urlSession(
  716|       |        _ session: URLSession,
  717|       |        streamTask: URLSessionStreamTask,
  718|       |        didBecome inputStream: InputStream,
  719|       |        outputStream: OutputStream)
  720|      0|    {
  721|      0|        streamTaskDidBecomeInputAndOutputStreams?(session, streamTask, inputStream, outputStream)
  722|      0|    }
  723|       |}
  724|       |
  725|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/SessionManager.swift:
    1|       |//
    2|       |//  SessionManager.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
   28|       |open class SessionManager {
   29|       |
   30|       |    // MARK: - Helper Types
   31|       |
   32|       |    /// Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as
   33|       |    /// associated values.
   34|       |    ///
   35|       |    /// - Success: Represents a successful `MultipartFormData` encoding and contains the new `UploadRequest` along with
   36|       |    ///            streaming information.
   37|       |    /// - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding
   38|       |    ///            error.
   39|       |    public enum MultipartFormDataEncodingResult {
   40|       |        case success(request: UploadRequest, streamingFromDisk: Bool, streamFileURL: URL?)
   41|       |        case failure(Error)
   42|       |    }
   43|       |
   44|       |    // MARK: - Properties
   45|       |
   46|       |    /// A default instance of `SessionManager`, used by top-level Alamofire request methods, and suitable for use
   47|       |    /// directly for any ad hoc requests.
   48|     11|    public static let `default`: SessionManager = {
   49|     11|        let configuration = URLSessionConfiguration.default
   50|     11|        configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders
   51|     11|
   52|     11|        return SessionManager(configuration: configuration)
   53|     11|    }()
   54|       |
   55|       |    /// Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
   56|     11|    public static let defaultHTTPHeaders: HTTPHeaders = {
   57|     11|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
   58|     11|        let acceptEncoding: String = "gzip;q=1.0, compress;q=0.5"
   59|     11|
   60|     11|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
   61|     11|        let acceptLanguage = Locale.preferredLanguages.prefix(6).enumerated().map { index, languageCode in
   62|     11|            let quality = 1.0 - (Double(index) * 0.1)
   63|     11|            return "\(languageCode);q=\(quality)"
   64|     11|        }.joined(separator: ", ")
   65|     11|
   66|     11|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
   67|     11|        // Example: `iOS Example/1.0 (org.alamofire.iOS-Example; build:1; iOS 10.0.0) Alamofire/4.0.0`
   68|     11|        let userAgent: String = {
   69|     11|            if let info = Bundle.main.infoDictionary {
   70|     11|                let executable = info[kCFBundleExecutableKey as String] as? String ?? "Unknown"
   71|     11|                let bundle = info[kCFBundleIdentifierKey as String] as? String ?? "Unknown"
   72|     11|                let appVersion = info["CFBundleShortVersionString"] as? String ?? "Unknown"
   73|     11|                let appBuild = info[kCFBundleVersionKey as String] as? String ?? "Unknown"
   74|     11|
   75|     11|                let osNameVersion: String = {
   76|     11|                    let version = ProcessInfo.processInfo.operatingSystemVersion
   77|     11|                    let versionString = "\(version.majorVersion).\(version.minorVersion).\(version.patchVersion)"
   78|     11|
   79|     11|                    let osName: String = {
   80|     11|                        #if os(iOS)
   81|     11|                            return "iOS"
   82|     11|                        #elseif os(watchOS)
   83|     11|                            return "watchOS"
   84|     11|                        #elseif os(tvOS)
   85|     11|                            return "tvOS"
   86|     11|                        #elseif os(macOS)
   87|     11|                            return "OS X"
   88|     11|                        #elseif os(Linux)
   89|     11|                            return "Linux"
   90|     11|                        #else
   91|     11|                            return "Unknown"
   92|     11|                        #endif
   93|     11|                    }()
   94|     11|
   95|     11|                    return "\(osName) \(versionString)"
   96|     11|                }()
   97|     11|
   98|     11|                let alamofireVersion: String = {
   99|     11|                    guard
  100|     11|                        let afInfo = Bundle(for: SessionManager.self).infoDictionary,
  101|     11|                        let build = afInfo["CFBundleShortVersionString"]
  102|     11|                    else { return "Unknown" }
  103|     11|
  104|     11|                    return "Alamofire/\(build)"
  105|     11|                }()
  106|     11|
  107|     11|                return "\(executable)/\(appVersion) (\(bundle); build:\(appBuild); \(osNameVersion)) \(alamofireVersion)"
  108|     11|            }
  109|      0|
  110|      0|            return "Alamofire"
  111|     11|        }()
  112|     11|
  113|     11|        return [
  114|     11|            "Accept-Encoding": acceptEncoding,
  115|     11|            "Accept-Language": acceptLanguage,
  116|     11|            "User-Agent": userAgent
  117|     11|        ]
  118|     11|    }()
  119|       |
  120|       |    /// Default memory threshold used when encoding `MultipartFormData` in bytes.
  121|       |    public static let multipartFormDataEncodingMemoryThreshold: UInt64 = 10_000_000
  122|       |
  123|       |    /// The underlying session.
  124|       |    public let session: URLSession
  125|       |
  126|       |    /// The session delegate handling all the task and session delegate callbacks.
  127|       |    public let delegate: SessionDelegate
  128|       |
  129|       |    /// Whether to start requests immediately after being constructed. `true` by default.
  130|       |    open var startRequestsImmediately: Bool = true
  131|       |
  132|       |    /// The request adapter called each time a new request is created.
  133|       |    open var adapter: RequestAdapter?
  134|       |
  135|       |    /// The request retrier called each time a request encounters an error to determine whether to retry the request.
  136|       |    open var retrier: RequestRetrier? {
  137|     21|        get { return delegate.retrier }
  138|      0|        set { delegate.retrier = newValue }
  139|       |    }
  140|       |
  141|       |    /// The background completion handler closure provided by the UIApplicationDelegate
  142|       |    /// `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background
  143|       |    /// completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation
  144|       |    /// will automatically call the handler.
  145|       |    ///
  146|       |    /// If you need to handle your own events before the handler is called, then you need to override the
  147|       |    /// SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
  148|       |    ///
  149|       |    /// `nil` by default.
  150|       |    open var backgroundCompletionHandler: (() -> Void)?
  151|       |
  152|       |    let queue = DispatchQueue(label: "org.alamofire.session-manager." + UUID().uuidString)
  153|       |
  154|       |    // MARK: - Lifecycle
  155|       |
  156|       |    /// Creates an instance with the specified `configuration`, `delegate` and `serverTrustPolicyManager`.
  157|       |    ///
  158|       |    /// - parameter configuration:            The configuration used to construct the managed session.
  159|       |    ///                                       `URLSessionConfiguration.default` by default.
  160|       |    /// - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
  161|       |    ///                                       default.
  162|       |    /// - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
  163|       |    ///                                       challenges. `nil` by default.
  164|       |    ///
  165|       |    /// - returns: The new `SessionManager` instance.
  166|       |    public init(
  167|       |        configuration: URLSessionConfiguration = URLSessionConfiguration.default,
  168|       |        delegate: SessionDelegate = SessionDelegate(),
  169|       |        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
  170|     11|    {
  171|     11|        self.delegate = delegate
  172|     11|        self.session = URLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
  173|     11|
  174|     11|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
  175|     11|    }
  176|       |
  177|       |    /// Creates an instance with the specified `session`, `delegate` and `serverTrustPolicyManager`.
  178|       |    ///
  179|       |    /// - parameter session:                  The URL session.
  180|       |    /// - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
  181|       |    /// - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
  182|       |    ///                                       challenges. `nil` by default.
  183|       |    ///
  184|       |    /// - returns: The new `SessionManager` instance if the URL session's delegate matches; `nil` otherwise.
  185|       |    public init?(
  186|       |        session: URLSession,
  187|       |        delegate: SessionDelegate,
  188|       |        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
  189|      0|    {
  190|      0|        guard delegate === session.delegate else { return nil }
  191|      0|
  192|      0|        self.delegate = delegate
  193|      0|        self.session = session
  194|      0|
  195|      0|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
  196|      0|    }
  197|       |
  198|     11|    private func commonInit(serverTrustPolicyManager: ServerTrustPolicyManager?) {
  199|     11|        session.serverTrustPolicyManager = serverTrustPolicyManager
  200|     11|
  201|     11|        delegate.sessionManager = self
  202|     11|
  203|     11|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
  204|      0|            guard let strongSelf = self else { return }
  205|      0|            DispatchQueue.main.async { strongSelf.backgroundCompletionHandler?() }
  206|      0|        }
  207|     11|    }
  208|       |
  209|      0|    deinit {
  210|      0|        session.invalidateAndCancel()
  211|      0|    }
  212|       |
  213|       |    // MARK: - Data Request
  214|       |
  215|       |    /// Creates a `DataRequest` to retrieve the contents of the specified `url`, `method`, `parameters`, `encoding`
  216|       |    /// and `headers`.
  217|       |    ///
  218|       |    /// - parameter url:        The URL.
  219|       |    /// - parameter method:     The HTTP method. `.get` by default.
  220|       |    /// - parameter parameters: The parameters. `nil` by default.
  221|       |    /// - parameter encoding:   The parameter encoding. `URLEncoding.default` by default.
  222|       |    /// - parameter headers:    The HTTP headers. `nil` by default.
  223|       |    ///
  224|       |    /// - returns: The created `DataRequest`.
  225|       |    @discardableResult
  226|       |    open func request(
  227|       |        _ url: URLConvertible,
  228|       |        method: HTTPMethod = .get,
  229|       |        parameters: Parameters? = nil,
  230|       |        encoding: ParameterEncoding = URLEncoding.default,
  231|       |        headers: HTTPHeaders? = nil)
  232|       |        -> DataRequest
  233|    495|    {
  234|    495|        var originalRequest: URLRequest?
  235|    495|
  236|    495|        do {
  237|    495|            originalRequest = try URLRequest(url: url, method: method, headers: headers)
  238|    495|            let encodedURLRequest = try encoding.encode(originalRequest!, with: parameters)
  239|    495|            return request(encodedURLRequest)
  240|    495|        } catch {
  241|     21|            return request(originalRequest, failedWith: error)
  242|  18.4E|        }
  243|  18.4E|    }
  244|       |
  245|       |    /// Creates a `DataRequest` to retrieve the contents of a URL based on the specified `urlRequest`.
  246|       |    ///
  247|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  248|       |    ///
  249|       |    /// - parameter urlRequest: The URL request.
  250|       |    ///
  251|       |    /// - returns: The created `DataRequest`.
  252|       |    @discardableResult
  253|    474|    open func request(_ urlRequest: URLRequestConvertible) -> DataRequest {
  254|    474|        var originalRequest: URLRequest?
  255|    474|
  256|    474|        do {
  257|    474|            originalRequest = try urlRequest.asURLRequest()
  258|    474|            let originalTask = DataRequest.Requestable(urlRequest: originalRequest!)
  259|    474|
  260|    474|            let task = try originalTask.task(session: session, adapter: adapter, queue: queue)
  261|    474|            let request = DataRequest(session: session, requestTask: .data(originalTask, task))
  262|    474|
  263|    474|            delegate[task] = request
  264|    474|
  265|    474|            if startRequestsImmediately { request.resume() }
  266|    474|
  267|    474|            return request
  268|    474|        } catch {
  269|      0|            return request(originalRequest, failedWith: error)
  270|      0|        }
  271|      0|    }
  272|       |
  273|       |    // MARK: Private - Request Implementation
  274|       |
  275|     21|    private func request(_ urlRequest: URLRequest?, failedWith error: Error) -> DataRequest {
  276|     21|        var requestTask: Request.RequestTask = .data(nil, nil)
  277|     21|
  278|     21|        if let urlRequest = urlRequest {
  279|      0|            let originalTask = DataRequest.Requestable(urlRequest: urlRequest)
  280|      0|            requestTask = .data(originalTask, nil)
  281|     21|        }
  282|     21|
  283|     21|        let underlyingError = error.underlyingAdaptError ?? error
  284|     21|        let request = DataRequest(session: session, requestTask: requestTask, error: underlyingError)
  285|     21|
  286|     21|        if let retrier = retrier, error is AdaptError {
  287|      0|            allowRetrier(retrier, toRetry: request, with: underlyingError)
  288|     21|        } else {
  289|     21|            if startRequestsImmediately { request.resume() }
  290|     21|        }
  291|     21|
  292|     21|        return request
  293|     21|    }
  294|       |
  295|       |    // MARK: - Download Request
  296|       |
  297|       |    // MARK: URL Request
  298|       |
  299|       |    /// Creates a `DownloadRequest` to retrieve the contents the specified `url`, `method`, `parameters`, `encoding`,
  300|       |    /// `headers` and save them to the `destination`.
  301|       |    ///
  302|       |    /// If `destination` is not specified, the contents will remain in the temporary location determined by the
  303|       |    /// underlying URL session.
  304|       |    ///
  305|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  306|       |    ///
  307|       |    /// - parameter url:         The URL.
  308|       |    /// - parameter method:      The HTTP method. `.get` by default.
  309|       |    /// - parameter parameters:  The parameters. `nil` by default.
  310|       |    /// - parameter encoding:    The parameter encoding. `URLEncoding.default` by default.
  311|       |    /// - parameter headers:     The HTTP headers. `nil` by default.
  312|       |    /// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.
  313|       |    ///
  314|       |    /// - returns: The created `DownloadRequest`.
  315|       |    @discardableResult
  316|       |    open func download(
  317|       |        _ url: URLConvertible,
  318|       |        method: HTTPMethod = .get,
  319|       |        parameters: Parameters? = nil,
  320|       |        encoding: ParameterEncoding = URLEncoding.default,
  321|       |        headers: HTTPHeaders? = nil,
  322|       |        to destination: DownloadRequest.DownloadFileDestination? = nil)
  323|       |        -> DownloadRequest
  324|      0|    {
  325|      0|        do {
  326|      0|            let urlRequest = try URLRequest(url: url, method: method, headers: headers)
  327|      0|            let encodedURLRequest = try encoding.encode(urlRequest, with: parameters)
  328|      0|            return download(encodedURLRequest, to: destination)
  329|      0|        } catch {
  330|      0|            return download(nil, to: destination, failedWith: error)
  331|      0|        }
  332|      0|    }
  333|       |
  334|       |    /// Creates a `DownloadRequest` to retrieve the contents of a URL based on the specified `urlRequest` and save
  335|       |    /// them to the `destination`.
  336|       |    ///
  337|       |    /// If `destination` is not specified, the contents will remain in the temporary location determined by the
  338|       |    /// underlying URL session.
  339|       |    ///
  340|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  341|       |    ///
  342|       |    /// - parameter urlRequest:  The URL request
  343|       |    /// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.
  344|       |    ///
  345|       |    /// - returns: The created `DownloadRequest`.
  346|       |    @discardableResult
  347|       |    open func download(
  348|       |        _ urlRequest: URLRequestConvertible,
  349|       |        to destination: DownloadRequest.DownloadFileDestination? = nil)
  350|       |        -> DownloadRequest
  351|      0|    {
  352|      0|        do {
  353|      0|            let urlRequest = try urlRequest.asURLRequest()
  354|      0|            return download(.request(urlRequest), to: destination)
  355|      0|        } catch {
  356|      0|            return download(nil, to: destination, failedWith: error)
  357|      0|        }
  358|      0|    }
  359|       |
  360|       |    // MARK: Resume Data
  361|       |
  362|       |    /// Creates a `DownloadRequest` from the `resumeData` produced from a previous request cancellation to retrieve
  363|       |    /// the contents of the original request and save them to the `destination`.
  364|       |    ///
  365|       |    /// If `destination` is not specified, the contents will remain in the temporary location determined by the
  366|       |    /// underlying URL session.
  367|       |    ///
  368|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  369|       |    ///
  370|       |    /// On the latest release of all the Apple platforms (iOS 10, macOS 10.12, tvOS 10, watchOS 3), `resumeData` is broken
  371|       |    /// on background URL session configurations. There's an underlying bug in the `resumeData` generation logic where the
  372|       |    /// data is written incorrectly and will always fail to resume the download. For more information about the bug and
  373|       |    /// possible workarounds, please refer to the following Stack Overflow post:
  374|       |    ///
  375|       |    ///    - http://stackoverflow.com/a/39347461/1342462
  376|       |    ///
  377|       |    /// - parameter resumeData:  The resume data. This is an opaque data blob produced by `URLSessionDownloadTask`
  378|       |    ///                          when a task is cancelled. See `URLSession -downloadTask(withResumeData:)` for
  379|       |    ///                          additional information.
  380|       |    /// - parameter destination: The closure used to determine the destination of the downloaded file. `nil` by default.
  381|       |    ///
  382|       |    /// - returns: The created `DownloadRequest`.
  383|       |    @discardableResult
  384|       |    open func download(
  385|       |        resumingWith resumeData: Data,
  386|       |        to destination: DownloadRequest.DownloadFileDestination? = nil)
  387|       |        -> DownloadRequest
  388|      0|    {
  389|      0|        return download(.resumeData(resumeData), to: destination)
  390|      0|    }
  391|       |
  392|       |    // MARK: Private - Download Implementation
  393|       |
  394|       |    private func download(
  395|       |        _ downloadable: DownloadRequest.Downloadable,
  396|       |        to destination: DownloadRequest.DownloadFileDestination?)
  397|       |        -> DownloadRequest
  398|      0|    {
  399|      0|        do {
  400|      0|            let task = try downloadable.task(session: session, adapter: adapter, queue: queue)
  401|      0|            let download = DownloadRequest(session: session, requestTask: .download(downloadable, task))
  402|      0|
  403|      0|            download.downloadDelegate.destination = destination
  404|      0|
  405|      0|            delegate[task] = download
  406|      0|
  407|      0|            if startRequestsImmediately { download.resume() }
  408|      0|
  409|      0|            return download
  410|      0|        } catch {
  411|      0|            return download(downloadable, to: destination, failedWith: error)
  412|      0|        }
  413|      0|    }
  414|       |
  415|       |    private func download(
  416|       |        _ downloadable: DownloadRequest.Downloadable?,
  417|       |        to destination: DownloadRequest.DownloadFileDestination?,
  418|       |        failedWith error: Error)
  419|       |        -> DownloadRequest
  420|      0|    {
  421|      0|        var downloadTask: Request.RequestTask = .download(nil, nil)
  422|      0|
  423|      0|        if let downloadable = downloadable {
  424|      0|            downloadTask = .download(downloadable, nil)
  425|      0|        }
  426|      0|
  427|      0|        let underlyingError = error.underlyingAdaptError ?? error
  428|      0|
  429|      0|        let download = DownloadRequest(session: session, requestTask: downloadTask, error: underlyingError)
  430|      0|        download.downloadDelegate.destination = destination
  431|      0|
  432|      0|        if let retrier = retrier, error is AdaptError {
  433|      0|            allowRetrier(retrier, toRetry: download, with: underlyingError)
  434|      0|        } else {
  435|      0|            if startRequestsImmediately { download.resume() }
  436|      0|        }
  437|      0|
  438|      0|        return download
  439|      0|    }
  440|       |
  441|       |    // MARK: - Upload Request
  442|       |
  443|       |    // MARK: File
  444|       |
  445|       |    /// Creates an `UploadRequest` from the specified `url`, `method` and `headers` for uploading the `file`.
  446|       |    ///
  447|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  448|       |    ///
  449|       |    /// - parameter file:    The file to upload.
  450|       |    /// - parameter url:     The URL.
  451|       |    /// - parameter method:  The HTTP method. `.post` by default.
  452|       |    /// - parameter headers: The HTTP headers. `nil` by default.
  453|       |    ///
  454|       |    /// - returns: The created `UploadRequest`.
  455|       |    @discardableResult
  456|       |    open func upload(
  457|       |        _ fileURL: URL,
  458|       |        to url: URLConvertible,
  459|       |        method: HTTPMethod = .post,
  460|       |        headers: HTTPHeaders? = nil)
  461|       |        -> UploadRequest
  462|      0|    {
  463|      0|        do {
  464|      0|            let urlRequest = try URLRequest(url: url, method: method, headers: headers)
  465|      0|            return upload(fileURL, with: urlRequest)
  466|      0|        } catch {
  467|      0|            return upload(nil, failedWith: error)
  468|      0|        }
  469|      0|    }
  470|       |
  471|       |    /// Creates a `UploadRequest` from the specified `urlRequest` for uploading the `file`.
  472|       |    ///
  473|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  474|       |    ///
  475|       |    /// - parameter file:       The file to upload.
  476|       |    /// - parameter urlRequest: The URL request.
  477|       |    ///
  478|       |    /// - returns: The created `UploadRequest`.
  479|       |    @discardableResult
  480|      0|    open func upload(_ fileURL: URL, with urlRequest: URLRequestConvertible) -> UploadRequest {
  481|      0|        do {
  482|      0|            let urlRequest = try urlRequest.asURLRequest()
  483|      0|            return upload(.file(fileURL, urlRequest))
  484|      0|        } catch {
  485|      0|            return upload(nil, failedWith: error)
  486|      0|        }
  487|      0|    }
  488|       |
  489|       |    // MARK: Data
  490|       |
  491|       |    /// Creates an `UploadRequest` from the specified `url`, `method` and `headers` for uploading the `data`.
  492|       |    ///
  493|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  494|       |    ///
  495|       |    /// - parameter data:    The data to upload.
  496|       |    /// - parameter url:     The URL.
  497|       |    /// - parameter method:  The HTTP method. `.post` by default.
  498|       |    /// - parameter headers: The HTTP headers. `nil` by default.
  499|       |    ///
  500|       |    /// - returns: The created `UploadRequest`.
  501|       |    @discardableResult
  502|       |    open func upload(
  503|       |        _ data: Data,
  504|       |        to url: URLConvertible,
  505|       |        method: HTTPMethod = .post,
  506|       |        headers: HTTPHeaders? = nil)
  507|       |        -> UploadRequest
  508|      0|    {
  509|      0|        do {
  510|      0|            let urlRequest = try URLRequest(url: url, method: method, headers: headers)
  511|      0|            return upload(data, with: urlRequest)
  512|      0|        } catch {
  513|      0|            return upload(nil, failedWith: error)
  514|      0|        }
  515|      0|    }
  516|       |
  517|       |    /// Creates an `UploadRequest` from the specified `urlRequest` for uploading the `data`.
  518|       |    ///
  519|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  520|       |    ///
  521|       |    /// - parameter data:       The data to upload.
  522|       |    /// - parameter urlRequest: The URL request.
  523|       |    ///
  524|       |    /// - returns: The created `UploadRequest`.
  525|       |    @discardableResult
  526|      0|    open func upload(_ data: Data, with urlRequest: URLRequestConvertible) -> UploadRequest {
  527|      0|        do {
  528|      0|            let urlRequest = try urlRequest.asURLRequest()
  529|      0|            return upload(.data(data, urlRequest))
  530|      0|        } catch {
  531|      0|            return upload(nil, failedWith: error)
  532|      0|        }
  533|      0|    }
  534|       |
  535|       |    // MARK: InputStream
  536|       |
  537|       |    /// Creates an `UploadRequest` from the specified `url`, `method` and `headers` for uploading the `stream`.
  538|       |    ///
  539|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  540|       |    ///
  541|       |    /// - parameter stream:  The stream to upload.
  542|       |    /// - parameter url:     The URL.
  543|       |    /// - parameter method:  The HTTP method. `.post` by default.
  544|       |    /// - parameter headers: The HTTP headers. `nil` by default.
  545|       |    ///
  546|       |    /// - returns: The created `UploadRequest`.
  547|       |    @discardableResult
  548|       |    open func upload(
  549|       |        _ stream: InputStream,
  550|       |        to url: URLConvertible,
  551|       |        method: HTTPMethod = .post,
  552|       |        headers: HTTPHeaders? = nil)
  553|       |        -> UploadRequest
  554|      0|    {
  555|      0|        do {
  556|      0|            let urlRequest = try URLRequest(url: url, method: method, headers: headers)
  557|      0|            return upload(stream, with: urlRequest)
  558|      0|        } catch {
  559|      0|            return upload(nil, failedWith: error)
  560|      0|        }
  561|      0|    }
  562|       |
  563|       |    /// Creates an `UploadRequest` from the specified `urlRequest` for uploading the `stream`.
  564|       |    ///
  565|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  566|       |    ///
  567|       |    /// - parameter stream:     The stream to upload.
  568|       |    /// - parameter urlRequest: The URL request.
  569|       |    ///
  570|       |    /// - returns: The created `UploadRequest`.
  571|       |    @discardableResult
  572|      0|    open func upload(_ stream: InputStream, with urlRequest: URLRequestConvertible) -> UploadRequest {
  573|      0|        do {
  574|      0|            let urlRequest = try urlRequest.asURLRequest()
  575|      0|            return upload(.stream(stream, urlRequest))
  576|      0|        } catch {
  577|      0|            return upload(nil, failedWith: error)
  578|      0|        }
  579|      0|    }
  580|       |
  581|       |    // MARK: MultipartFormData
  582|       |
  583|       |    /// Encodes `multipartFormData` using `encodingMemoryThreshold` and calls `encodingCompletion` with new
  584|       |    /// `UploadRequest` using the `url`, `method` and `headers`.
  585|       |    ///
  586|       |    /// It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
  587|       |    /// payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
  588|       |    /// efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
  589|       |    /// be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
  590|       |    /// footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
  591|       |    /// used for larger payloads such as video content.
  592|       |    ///
  593|       |    /// The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
  594|       |    /// or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
  595|       |    /// encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
  596|       |    /// during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
  597|       |    /// technique was used.
  598|       |    ///
  599|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  600|       |    ///
  601|       |    /// - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
  602|       |    /// - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
  603|       |    ///                                      `multipartFormDataEncodingMemoryThreshold` by default.
  604|       |    /// - parameter url:                     The URL.
  605|       |    /// - parameter method:                  The HTTP method. `.post` by default.
  606|       |    /// - parameter headers:                 The HTTP headers. `nil` by default.
  607|       |    /// - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
  608|       |    open func upload(
  609|       |        multipartFormData: @escaping (MultipartFormData) -> Void,
  610|       |        usingThreshold encodingMemoryThreshold: UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold,
  611|       |        to url: URLConvertible,
  612|       |        method: HTTPMethod = .post,
  613|       |        headers: HTTPHeaders? = nil,
  614|       |        queue: DispatchQueue? = nil,
  615|       |        encodingCompletion: ((MultipartFormDataEncodingResult) -> Void)?)
  616|      0|    {
  617|      0|        do {
  618|      0|            let urlRequest = try URLRequest(url: url, method: method, headers: headers)
  619|      0|
  620|      0|            return upload(
  621|      0|                multipartFormData: multipartFormData,
  622|      0|                usingThreshold: encodingMemoryThreshold,
  623|      0|                with: urlRequest,
  624|      0|                queue: queue,
  625|      0|                encodingCompletion: encodingCompletion
  626|      0|            )
  627|      0|        } catch {
  628|      0|            (queue ?? DispatchQueue.main).async { encodingCompletion?(.failure(error)) }
  629|      0|        }
  630|      0|    }
  631|       |
  632|       |    /// Encodes `multipartFormData` using `encodingMemoryThreshold` and calls `encodingCompletion` with new
  633|       |    /// `UploadRequest` using the `urlRequest`.
  634|       |    ///
  635|       |    /// It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
  636|       |    /// payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
  637|       |    /// efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
  638|       |    /// be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
  639|       |    /// footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
  640|       |    /// used for larger payloads such as video content.
  641|       |    ///
  642|       |    /// The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
  643|       |    /// or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
  644|       |    /// encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
  645|       |    /// during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
  646|       |    /// technique was used.
  647|       |    ///
  648|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  649|       |    ///
  650|       |    /// - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
  651|       |    /// - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
  652|       |    ///                                      `multipartFormDataEncodingMemoryThreshold` by default.
  653|       |    /// - parameter urlRequest:              The URL request.
  654|       |    /// - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
  655|       |    open func upload(
  656|       |        multipartFormData: @escaping (MultipartFormData) -> Void,
  657|       |        usingThreshold encodingMemoryThreshold: UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold,
  658|       |        with urlRequest: URLRequestConvertible,
  659|       |        queue: DispatchQueue? = nil,
  660|       |        encodingCompletion: ((MultipartFormDataEncodingResult) -> Void)?)
  661|      0|    {
  662|      0|        DispatchQueue.global(qos: .utility).async {
  663|      0|            let formData = MultipartFormData()
  664|      0|            multipartFormData(formData)
  665|      0|
  666|      0|            var tempFileURL: URL?
  667|      0|
  668|      0|            do {
  669|      0|                var urlRequestWithContentType = try urlRequest.asURLRequest()
  670|      0|                urlRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
  671|      0|
  672|      0|                let isBackgroundSession = self.session.configuration.identifier != nil
  673|      0|
  674|      0|                if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
  675|      0|                    let data = try formData.encode()
  676|      0|
  677|      0|                    let encodingResult = MultipartFormDataEncodingResult.success(
  678|      0|                        request: self.upload(data, with: urlRequestWithContentType),
  679|      0|                        streamingFromDisk: false,
  680|      0|                        streamFileURL: nil
  681|      0|                    )
  682|      0|
  683|      0|                    (queue ?? DispatchQueue.main).async { encodingCompletion?(encodingResult) }
  684|      0|                } else {
  685|      0|                    let fileManager = FileManager.default
  686|      0|                    let tempDirectoryURL = URL(fileURLWithPath: NSTemporaryDirectory())
  687|      0|                    let directoryURL = tempDirectoryURL.appendingPathComponent("org.alamofire.manager/multipart.form.data")
  688|      0|                    let fileName = UUID().uuidString
  689|      0|                    let fileURL = directoryURL.appendingPathComponent(fileName)
  690|      0|
  691|      0|                    tempFileURL = fileURL
  692|      0|
  693|      0|                    var directoryError: Error?
  694|      0|
  695|      0|                    // Create directory inside serial queue to ensure two threads don't do this in parallel
  696|      0|                    self.queue.sync {
  697|      0|                        do {
  698|      0|                            try fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true, attributes: nil)
  699|      0|                        } catch {
  700|      0|                            directoryError = error
  701|      0|                        }
  702|      0|                    }
  703|      0|
  704|      0|                    if let directoryError = directoryError { throw directoryError }
  705|      0|
  706|      0|                    try formData.writeEncodedData(to: fileURL)
  707|      0|
  708|      0|                    let upload = self.upload(fileURL, with: urlRequestWithContentType)
  709|      0|
  710|      0|                    // Cleanup the temp file once the upload is complete
  711|      0|                    upload.delegate.queue.addOperation {
  712|      0|                        do {
  713|      0|                            try FileManager.default.removeItem(at: fileURL)
  714|      0|                        } catch {
  715|      0|                            // No-op
  716|      0|                        }
  717|      0|                    }
  718|      0|
  719|      0|                    (queue ?? DispatchQueue.main).async {
  720|      0|                        let encodingResult = MultipartFormDataEncodingResult.success(
  721|      0|                            request: upload,
  722|      0|                            streamingFromDisk: true,
  723|      0|                            streamFileURL: fileURL
  724|      0|                        )
  725|      0|
  726|      0|                        encodingCompletion?(encodingResult)
  727|      0|                    }
  728|      0|                }
  729|      0|            } catch {
  730|      0|                // Cleanup the temp file in the event that the multipart form data encoding failed
  731|      0|                if let tempFileURL = tempFileURL {
  732|      0|                    do {
  733|      0|                        try FileManager.default.removeItem(at: tempFileURL)
  734|      0|                    } catch {
  735|      0|                        // No-op
  736|      0|                    }
  737|      0|                }
  738|      0|
  739|      0|                (queue ?? DispatchQueue.main).async { encodingCompletion?(.failure(error)) }
  740|      0|            }
  741|      0|        }
  742|      0|    }
  743|       |
  744|       |    // MARK: Private - Upload Implementation
  745|       |
  746|      0|    private func upload(_ uploadable: UploadRequest.Uploadable) -> UploadRequest {
  747|      0|        do {
  748|      0|            let task = try uploadable.task(session: session, adapter: adapter, queue: queue)
  749|      0|            let upload = UploadRequest(session: session, requestTask: .upload(uploadable, task))
  750|      0|
  751|      0|            if case let .stream(inputStream, _) = uploadable {
  752|      0|                upload.delegate.taskNeedNewBodyStream = { _, _ in inputStream }
  753|      0|            }
  754|      0|
  755|      0|            delegate[task] = upload
  756|      0|
  757|      0|            if startRequestsImmediately { upload.resume() }
  758|      0|
  759|      0|            return upload
  760|      0|        } catch {
  761|      0|            return upload(uploadable, failedWith: error)
  762|      0|        }
  763|      0|    }
  764|       |
  765|      0|    private func upload(_ uploadable: UploadRequest.Uploadable?, failedWith error: Error) -> UploadRequest {
  766|      0|        var uploadTask: Request.RequestTask = .upload(nil, nil)
  767|      0|
  768|      0|        if let uploadable = uploadable {
  769|      0|            uploadTask = .upload(uploadable, nil)
  770|      0|        }
  771|      0|
  772|      0|        let underlyingError = error.underlyingAdaptError ?? error
  773|      0|        let upload = UploadRequest(session: session, requestTask: uploadTask, error: underlyingError)
  774|      0|
  775|      0|        if let retrier = retrier, error is AdaptError {
  776|      0|            allowRetrier(retrier, toRetry: upload, with: underlyingError)
  777|      0|        } else {
  778|      0|            if startRequestsImmediately { upload.resume() }
  779|      0|        }
  780|      0|
  781|      0|        return upload
  782|      0|    }
  783|       |
  784|       |#if !os(watchOS)
  785|       |
  786|       |    // MARK: - Stream Request
  787|       |
  788|       |    // MARK: Hostname and Port
  789|       |
  790|       |    /// Creates a `StreamRequest` for bidirectional streaming using the `hostname` and `port`.
  791|       |    ///
  792|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  793|       |    ///
  794|       |    /// - parameter hostName: The hostname of the server to connect to.
  795|       |    /// - parameter port:     The port of the server to connect to.
  796|       |    ///
  797|       |    /// - returns: The created `StreamRequest`.
  798|       |    @discardableResult
  799|       |    @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  800|      0|    open func stream(withHostName hostName: String, port: Int) -> StreamRequest {
  801|      0|        return stream(.stream(hostName: hostName, port: port))
  802|      0|    }
  803|       |
  804|       |    // MARK: NetService
  805|       |
  806|       |    /// Creates a `StreamRequest` for bidirectional streaming using the `netService`.
  807|       |    ///
  808|       |    /// If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
  809|       |    ///
  810|       |    /// - parameter netService: The net service used to identify the endpoint.
  811|       |    ///
  812|       |    /// - returns: The created `StreamRequest`.
  813|       |    @discardableResult
  814|       |    @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  815|      0|    open func stream(with netService: NetService) -> StreamRequest {
  816|      0|        return stream(.netService(netService))
  817|      0|    }
  818|       |
  819|       |    // MARK: Private - Stream Implementation
  820|       |
  821|       |    @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  822|      0|    private func stream(_ streamable: StreamRequest.Streamable) -> StreamRequest {
  823|      0|        do {
  824|      0|            let task = try streamable.task(session: session, adapter: adapter, queue: queue)
  825|      0|            let request = StreamRequest(session: session, requestTask: .stream(streamable, task))
  826|      0|
  827|      0|            delegate[task] = request
  828|      0|
  829|      0|            if startRequestsImmediately { request.resume() }
  830|      0|
  831|      0|            return request
  832|      0|        } catch {
  833|      0|            return stream(failedWith: error)
  834|      0|        }
  835|      0|    }
  836|       |
  837|       |    @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  838|      0|    private func stream(failedWith error: Error) -> StreamRequest {
  839|      0|        let stream = StreamRequest(session: session, requestTask: .stream(nil, nil), error: error)
  840|      0|        if startRequestsImmediately { stream.resume() }
  841|      0|        return stream
  842|      0|    }
  843|       |
  844|       |#endif
  845|       |
  846|       |    // MARK: - Internal - Retry Request
  847|       |
  848|      0|    func retry(_ request: Request) -> Bool {
  849|      0|        guard let originalTask = request.originalTask else { return false }
  850|      0|
  851|      0|        do {
  852|      0|            let task = try originalTask.task(session: session, adapter: adapter, queue: queue)
  853|      0|
  854|      0|            if let originalTask = request.task {
  855|      0|                delegate[originalTask] = nil // removes the old request to avoid endless growth
  856|      0|            }
  857|      0|
  858|      0|            request.delegate.task = task // resets all task delegate data
  859|      0|
  860|      0|            request.retryCount += 1
  861|      0|            request.startTime = CFAbsoluteTimeGetCurrent()
  862|      0|            request.endTime = nil
  863|      0|
  864|      0|            task.resume()
  865|      0|
  866|      0|            return true
  867|      0|        } catch {
  868|      0|            request.delegate.error = error.underlyingAdaptError ?? error
  869|      0|            return false
  870|      0|        }
  871|      0|    }
  872|       |
  873|      0|    private func allowRetrier(_ retrier: RequestRetrier, toRetry request: Request, with error: Error) {
  874|      0|        DispatchQueue.utility.async { [weak self] in
  875|      0|            guard let strongSelf = self else { return }
  876|      0|
  877|      0|            retrier.should(strongSelf, retry: request, with: error) { shouldRetry, timeDelay in
  878|      0|                guard let strongSelf = self else { return }
  879|      0|
  880|      0|                guard shouldRetry else {
  881|      0|                    if strongSelf.startRequestsImmediately { request.resume() }
  882|      0|                    return
  883|      0|                }
  884|      0|
  885|      0|                DispatchQueue.utility.after(timeDelay) {
  886|      0|                    guard let strongSelf = self else { return }
  887|      0|
  888|      0|                    let retrySucceeded = strongSelf.retry(request)
  889|      0|
  890|      0|                    if retrySucceeded, let task = request.task {
  891|      0|                        strongSelf.delegate[task] = request
  892|      0|                    } else {
  893|      0|                        if strongSelf.startRequestsImmediately { request.resume() }
  894|      0|                    }
  895|      0|                }
  896|      0|            }
  897|      0|        }
  898|      0|    }
  899|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/TaskDelegate.swift:
    1|       |//
    2|       |//  TaskDelegate.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// The task delegate is responsible for handling all delegate callbacks for the underlying task as well as
   28|       |/// executing all operations attached to the serial operation queue upon task completion.
   29|       |open class TaskDelegate: NSObject {
   30|       |
   31|       |    // MARK: Properties
   32|       |
   33|       |    /// The serial operation queue used to execute all operations after the task completes.
   34|       |    public let queue: OperationQueue
   35|       |
   36|       |    /// The data returned by the server.
   37|      0|    public var data: Data? { return nil }
   38|       |
   39|       |    /// The error generated throughout the lifecyle of the task.
   40|       |    public var error: Error?
   41|       |
   42|       |    var task: URLSessionTask? {
   43|      0|        set {
   44|      0|            taskLock.lock(); defer { taskLock.unlock() }
   45|      0|            _task = newValue
   46|      0|        }
   47|  2.47k|        get {
   48|  2.47k|            taskLock.lock(); defer { taskLock.unlock() }
   49|  2.47k|            return _task
   50|  2.47k|        }
   51|       |    }
   52|       |
   53|       |    var initialResponseTime: CFAbsoluteTime?
   54|       |    var credential: URLCredential?
   55|       |    var metrics: AnyObject? // URLSessionTaskMetrics
   56|       |
   57|       |    private var _task: URLSessionTask? {
   58|      0|        didSet { reset() }
   59|       |    }
   60|       |
   61|       |    private let taskLock = NSLock()
   62|       |
   63|       |    // MARK: Lifecycle
   64|       |
   65|    495|    init(task: URLSessionTask?) {
   66|    495|        _task = task
   67|    495|
   68|    495|        self.queue = {
   69|    495|            let operationQueue = OperationQueue()
   70|    495|
   71|    495|            operationQueue.maxConcurrentOperationCount = 1
   72|    495|            operationQueue.isSuspended = true
   73|    495|            operationQueue.qualityOfService = .utility
   74|    495|
   75|    495|            return operationQueue
   76|    495|        }()
   77|    495|    }
   78|       |
   79|      0|    func reset() {
   80|      0|        error = nil
   81|      0|        initialResponseTime = nil
   82|      0|    }
   83|       |
   84|       |    // MARK: URLSessionTaskDelegate
   85|       |
   86|       |    var taskWillPerformHTTPRedirection: ((URLSession, URLSessionTask, HTTPURLResponse, URLRequest) -> URLRequest?)?
   87|       |    var taskDidReceiveChallenge: ((URLSession, URLSessionTask, URLAuthenticationChallenge) -> (URLSession.AuthChallengeDisposition, URLCredential?))?
   88|       |    var taskNeedNewBodyStream: ((URLSession, URLSessionTask) -> InputStream?)?
   89|       |    var taskDidCompleteWithError: ((URLSession, URLSessionTask, Error?) -> Void)?
   90|       |
   91|       |    @objc(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)
   92|       |    func urlSession(
   93|       |        _ session: URLSession,
   94|       |        task: URLSessionTask,
   95|       |        willPerformHTTPRedirection response: HTTPURLResponse,
   96|       |        newRequest request: URLRequest,
   97|       |        completionHandler: @escaping (URLRequest?) -> Void)
   98|      0|    {
   99|      0|        var redirectRequest: URLRequest? = request
  100|      0|
  101|      0|        if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
  102|      0|            redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
  103|      0|        }
  104|      0|
  105|      0|        completionHandler(redirectRequest)
  106|      0|    }
  107|       |
  108|       |    @objc(URLSession:task:didReceiveChallenge:completionHandler:)
  109|       |    func urlSession(
  110|       |        _ session: URLSession,
  111|       |        task: URLSessionTask,
  112|       |        didReceive challenge: URLAuthenticationChallenge,
  113|       |        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  114|      3|    {
  115|      3|        var disposition: URLSession.AuthChallengeDisposition = .performDefaultHandling
  116|      3|        var credential: URLCredential?
  117|      3|
  118|      3|        if let taskDidReceiveChallenge = taskDidReceiveChallenge {
  119|      0|            (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
  120|      3|        } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
  121|      3|            let host = challenge.protectionSpace.host
  122|      3|
  123|      3|            if
  124|      3|                let serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicy(forHost: host),
  125|      3|                let serverTrust = challenge.protectionSpace.serverTrust
  126|      3|            {
  127|      0|                if serverTrustPolicy.evaluate(serverTrust, forHost: host) {
  128|      0|                    disposition = .useCredential
  129|      0|                    credential = URLCredential(trust: serverTrust)
  130|      0|                } else {
  131|      0|                    disposition = .cancelAuthenticationChallenge
  132|      0|                }
  133|      3|            }
  134|      3|        } else {
  135|      0|            if challenge.previousFailureCount > 0 {
  136|      0|                disposition = .rejectProtectionSpace
  137|      0|            } else {
  138|      0|                credential = self.credential ?? session.configuration.urlCredentialStorage?.defaultCredential(for: challenge.protectionSpace)
  139|      0|
  140|      0|                if credential != nil {
  141|      0|                    disposition = .useCredential
  142|      0|                }
  143|      0|            }
  144|      3|        }
  145|      3|
  146|      3|        completionHandler(disposition, credential)
  147|      3|    }
  148|       |
  149|       |    @objc(URLSession:task:needNewBodyStream:)
  150|       |    func urlSession(
  151|       |        _ session: URLSession,
  152|       |        task: URLSessionTask,
  153|       |        needNewBodyStream completionHandler: @escaping (InputStream?) -> Void)
  154|      0|    {
  155|      0|        var bodyStream: InputStream?
  156|      0|
  157|      0|        if let taskNeedNewBodyStream = taskNeedNewBodyStream {
  158|      0|            bodyStream = taskNeedNewBodyStream(session, task)
  159|      0|        }
  160|      0|
  161|      0|        completionHandler(bodyStream)
  162|      0|    }
  163|       |
  164|       |    @objc(URLSession:task:didCompleteWithError:)
  165|    473|    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
  166|    473|        if let taskDidCompleteWithError = taskDidCompleteWithError {
  167|      0|            taskDidCompleteWithError(session, task, error)
  168|    473|        } else {
  169|    473|            if let error = error {
  170|      0|                if self.error == nil { self.error = error }
  171|      0|
  172|      0|                if
  173|      0|                    let downloadDelegate = self as? DownloadTaskDelegate,
  174|      0|                    let resumeData = (error as NSError).userInfo[NSURLSessionDownloadTaskResumeData] as? Data
  175|      0|                {
  176|      0|                    downloadDelegate.resumeData = resumeData
  177|      0|                }
  178|    473|            }
  179|    473|
  180|    473|            queue.isSuspended = false
  181|    473|        }
  182|    473|    }
  183|       |}
  184|       |
  185|       |// MARK: -
  186|       |
  187|       |class DataTaskDelegate: TaskDelegate, URLSessionDataDelegate {
  188|       |
  189|       |    // MARK: Properties
  190|       |
  191|      0|    var dataTask: URLSessionDataTask { return task as! URLSessionDataTask }
  192|       |
  193|  1.46k|    override var data: Data? {
  194|  1.46k|        if dataStream != nil {
  195|      0|            return nil
  196|  1.46k|        } else {
  197|  1.46k|            return mutableData
  198|  1.46k|        }
  199|      0|    }
  200|       |
  201|       |    var progress: Progress
  202|       |    var progressHandler: (closure: Request.ProgressHandler, queue: DispatchQueue)?
  203|       |
  204|       |    var dataStream: ((_ data: Data) -> Void)?
  205|       |
  206|       |    private var totalBytesReceived: Int64 = 0
  207|       |    private var mutableData: Data
  208|       |
  209|       |    private var expectedContentLength: Int64?
  210|       |
  211|       |    // MARK: Lifecycle
  212|       |
  213|    495|    override init(task: URLSessionTask?) {
  214|    495|        mutableData = Data()
  215|    495|        progress = Progress(totalUnitCount: 0)
  216|    495|
  217|    495|        super.init(task: task)
  218|    495|    }
  219|       |
  220|      0|    override func reset() {
  221|      0|        super.reset()
  222|      0|
  223|      0|        progress = Progress(totalUnitCount: 0)
  224|      0|        totalBytesReceived = 0
  225|      0|        mutableData = Data()
  226|      0|        expectedContentLength = nil
  227|      0|    }
  228|       |
  229|       |    // MARK: URLSessionDataDelegate
  230|       |
  231|       |    var dataTaskDidReceiveResponse: ((URLSession, URLSessionDataTask, URLResponse) -> URLSession.ResponseDisposition)?
  232|       |    var dataTaskDidBecomeDownloadTask: ((URLSession, URLSessionDataTask, URLSessionDownloadTask) -> Void)?
  233|       |    var dataTaskDidReceiveData: ((URLSession, URLSessionDataTask, Data) -> Void)?
  234|       |    var dataTaskWillCacheResponse: ((URLSession, URLSessionDataTask, CachedURLResponse) -> CachedURLResponse?)?
  235|       |
  236|       |    func urlSession(
  237|       |        _ session: URLSession,
  238|       |        dataTask: URLSessionDataTask,
  239|       |        didReceive response: URLResponse,
  240|       |        completionHandler: @escaping (URLSession.ResponseDisposition) -> Void)
  241|      0|    {
  242|      0|        var disposition: URLSession.ResponseDisposition = .allow
  243|      0|
  244|      0|        expectedContentLength = response.expectedContentLength
  245|      0|
  246|      0|        if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
  247|      0|            disposition = dataTaskDidReceiveResponse(session, dataTask, response)
  248|      0|        }
  249|      0|
  250|      0|        completionHandler(disposition)
  251|      0|    }
  252|       |
  253|       |    func urlSession(
  254|       |        _ session: URLSession,
  255|       |        dataTask: URLSessionDataTask,
  256|       |        didBecome downloadTask: URLSessionDownloadTask)
  257|      0|    {
  258|      0|        dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
  259|      0|    }
  260|       |
  261|    862|    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
  262|    862|        if initialResponseTime == nil { initialResponseTime = CFAbsoluteTimeGetCurrent() }
  263|    862|
  264|    862|        if let dataTaskDidReceiveData = dataTaskDidReceiveData {
  265|      0|            dataTaskDidReceiveData(session, dataTask, data)
  266|    862|        } else {
  267|    862|            if let dataStream = dataStream {
  268|      0|                dataStream(data)
  269|    862|            } else {
  270|    862|                mutableData.append(data)
  271|    862|            }
  272|    862|
  273|    862|            let bytesReceived = Int64(data.count)
  274|    862|            totalBytesReceived += bytesReceived
  275|    862|            let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
  276|    862|
  277|    862|            progress.totalUnitCount = totalBytesExpected
  278|    862|            progress.completedUnitCount = totalBytesReceived
  279|    862|
  280|    862|            if let progressHandler = progressHandler {
  281|      0|                progressHandler.queue.async { progressHandler.closure(self.progress) }
  282|    862|            }
  283|    862|        }
  284|    862|    }
  285|       |
  286|       |    func urlSession(
  287|       |        _ session: URLSession,
  288|       |        dataTask: URLSessionDataTask,
  289|       |        willCacheResponse proposedResponse: CachedURLResponse,
  290|       |        completionHandler: @escaping (CachedURLResponse?) -> Void)
  291|    473|    {
  292|    473|        var cachedResponse: CachedURLResponse? = proposedResponse
  293|    473|
  294|    473|        if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
  295|      0|            cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
  296|    473|        }
  297|    473|
  298|    473|        completionHandler(cachedResponse)
  299|    473|    }
  300|       |}
  301|       |
  302|       |// MARK: -
  303|       |
  304|       |class DownloadTaskDelegate: TaskDelegate, URLSessionDownloadDelegate {
  305|       |
  306|       |    // MARK: Properties
  307|       |
  308|      0|    var downloadTask: URLSessionDownloadTask { return task as! URLSessionDownloadTask }
  309|       |
  310|       |    var progress: Progress
  311|       |    var progressHandler: (closure: Request.ProgressHandler, queue: DispatchQueue)?
  312|       |
  313|       |    var resumeData: Data?
  314|      0|    override var data: Data? { return resumeData }
  315|       |
  316|       |    var destination: DownloadRequest.DownloadFileDestination?
  317|       |
  318|       |    var temporaryURL: URL?
  319|       |    var destinationURL: URL?
  320|       |
  321|      0|    var fileURL: URL? { return destination != nil ? destinationURL : temporaryURL }
  322|       |
  323|       |    // MARK: Lifecycle
  324|       |
  325|      0|    override init(task: URLSessionTask?) {
  326|      0|        progress = Progress(totalUnitCount: 0)
  327|      0|        super.init(task: task)
  328|      0|    }
  329|       |
  330|      0|    override func reset() {
  331|      0|        super.reset()
  332|      0|
  333|      0|        progress = Progress(totalUnitCount: 0)
  334|      0|        resumeData = nil
  335|      0|    }
  336|       |
  337|       |    // MARK: URLSessionDownloadDelegate
  338|       |
  339|       |    var downloadTaskDidFinishDownloadingToURL: ((URLSession, URLSessionDownloadTask, URL) -> URL)?
  340|       |    var downloadTaskDidWriteData: ((URLSession, URLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
  341|       |    var downloadTaskDidResumeAtOffset: ((URLSession, URLSessionDownloadTask, Int64, Int64) -> Void)?
  342|       |
  343|       |    func urlSession(
  344|       |        _ session: URLSession,
  345|       |        downloadTask: URLSessionDownloadTask,
  346|       |        didFinishDownloadingTo location: URL)
  347|      0|    {
  348|      0|        temporaryURL = location
  349|      0|
  350|      0|        guard
  351|      0|            let destination = destination,
  352|      0|            let response = downloadTask.response as? HTTPURLResponse
  353|      0|        else { return }
  354|      0|
  355|      0|        let result = destination(location, response)
  356|      0|        let destinationURL = result.destinationURL
  357|      0|        let options = result.options
  358|      0|
  359|      0|        self.destinationURL = destinationURL
  360|      0|
  361|      0|        do {
  362|      0|            if options.contains(.removePreviousFile), FileManager.default.fileExists(atPath: destinationURL.path) {
  363|      0|                try FileManager.default.removeItem(at: destinationURL)
  364|      0|            }
  365|      0|
  366|      0|            if options.contains(.createIntermediateDirectories) {
  367|      0|                let directory = destinationURL.deletingLastPathComponent()
  368|      0|                try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true)
  369|      0|            }
  370|      0|
  371|      0|            try FileManager.default.moveItem(at: location, to: destinationURL)
  372|      0|        } catch {
  373|      0|            self.error = error
  374|      0|        }
  375|      0|    }
  376|       |
  377|       |    func urlSession(
  378|       |        _ session: URLSession,
  379|       |        downloadTask: URLSessionDownloadTask,
  380|       |        didWriteData bytesWritten: Int64,
  381|       |        totalBytesWritten: Int64,
  382|       |        totalBytesExpectedToWrite: Int64)
  383|      0|    {
  384|      0|        if initialResponseTime == nil { initialResponseTime = CFAbsoluteTimeGetCurrent() }
  385|      0|
  386|      0|        if let downloadTaskDidWriteData = downloadTaskDidWriteData {
  387|      0|            downloadTaskDidWriteData(
  388|      0|                session,
  389|      0|                downloadTask,
  390|      0|                bytesWritten,
  391|      0|                totalBytesWritten,
  392|      0|                totalBytesExpectedToWrite
  393|      0|            )
  394|      0|        } else {
  395|      0|            progress.totalUnitCount = totalBytesExpectedToWrite
  396|      0|            progress.completedUnitCount = totalBytesWritten
  397|      0|
  398|      0|            if let progressHandler = progressHandler {
  399|      0|                progressHandler.queue.async { progressHandler.closure(self.progress) }
  400|      0|            }
  401|      0|        }
  402|      0|    }
  403|       |
  404|       |    func urlSession(
  405|       |        _ session: URLSession,
  406|       |        downloadTask: URLSessionDownloadTask,
  407|       |        didResumeAtOffset fileOffset: Int64,
  408|       |        expectedTotalBytes: Int64)
  409|      0|    {
  410|      0|        if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
  411|      0|            downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
  412|      0|        } else {
  413|      0|            progress.totalUnitCount = expectedTotalBytes
  414|      0|            progress.completedUnitCount = fileOffset
  415|      0|        }
  416|      0|    }
  417|       |}
  418|       |
  419|       |// MARK: -
  420|       |
  421|       |class UploadTaskDelegate: DataTaskDelegate {
  422|       |
  423|       |    // MARK: Properties
  424|       |
  425|      0|    var uploadTask: URLSessionUploadTask { return task as! URLSessionUploadTask }
  426|       |
  427|       |    var uploadProgress: Progress
  428|       |    var uploadProgressHandler: (closure: Request.ProgressHandler, queue: DispatchQueue)?
  429|       |
  430|       |    // MARK: Lifecycle
  431|       |
  432|      0|    override init(task: URLSessionTask?) {
  433|      0|        uploadProgress = Progress(totalUnitCount: 0)
  434|      0|        super.init(task: task)
  435|      0|    }
  436|       |
  437|      0|    override func reset() {
  438|      0|        super.reset()
  439|      0|        uploadProgress = Progress(totalUnitCount: 0)
  440|      0|    }
  441|       |
  442|       |    // MARK: URLSessionTaskDelegate
  443|       |
  444|       |    var taskDidSendBodyData: ((URLSession, URLSessionTask, Int64, Int64, Int64) -> Void)?
  445|       |
  446|       |    func URLSession(
  447|       |        _ session: URLSession,
  448|       |        task: URLSessionTask,
  449|       |        didSendBodyData bytesSent: Int64,
  450|       |        totalBytesSent: Int64,
  451|       |        totalBytesExpectedToSend: Int64)
  452|      0|    {
  453|      0|        if initialResponseTime == nil { initialResponseTime = CFAbsoluteTimeGetCurrent() }
  454|      0|
  455|      0|        if let taskDidSendBodyData = taskDidSendBodyData {
  456|      0|            taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
  457|      0|        } else {
  458|      0|            uploadProgress.totalUnitCount = totalBytesExpectedToSend
  459|      0|            uploadProgress.completedUnitCount = totalBytesSent
  460|      0|
  461|      0|            if let uploadProgressHandler = uploadProgressHandler {
  462|      0|                uploadProgressHandler.queue.async { uploadProgressHandler.closure(self.uploadProgress) }
  463|      0|            }
  464|      0|        }
  465|      0|    }
  466|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/Timeline.swift:
    1|       |//
    2|       |//  Timeline.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |/// Responsible for computing the timing metrics for the complete lifecycle of a `Request`.
   28|       |public struct Timeline {
   29|       |    /// The time the request was initialized.
   30|       |    public let requestStartTime: CFAbsoluteTime
   31|       |
   32|       |    /// The time the first bytes were received from or sent to the server.
   33|       |    public let initialResponseTime: CFAbsoluteTime
   34|       |
   35|       |    /// The time when the request was completed.
   36|       |    public let requestCompletedTime: CFAbsoluteTime
   37|       |
   38|       |    /// The time when the response serialization was completed.
   39|       |    public let serializationCompletedTime: CFAbsoluteTime
   40|       |
   41|       |    /// The time interval in seconds from the time the request started to the initial response from the server.
   42|       |    public let latency: TimeInterval
   43|       |
   44|       |    /// The time interval in seconds from the time the request started to the time the request completed.
   45|       |    public let requestDuration: TimeInterval
   46|       |
   47|       |    /// The time interval in seconds from the time the request completed to the time response serialization completed.
   48|       |    public let serializationDuration: TimeInterval
   49|       |
   50|       |    /// The time interval in seconds from the time the request started to the time response serialization completed.
   51|       |    public let totalDuration: TimeInterval
   52|       |
   53|       |    /// Creates a new `Timeline` instance with the specified request times.
   54|       |    ///
   55|       |    /// - parameter requestStartTime:           The time the request was initialized. Defaults to `0.0`.
   56|       |    /// - parameter initialResponseTime:        The time the first bytes were received from or sent to the server.
   57|       |    ///                                         Defaults to `0.0`.
   58|       |    /// - parameter requestCompletedTime:       The time when the request was completed. Defaults to `0.0`.
   59|       |    /// - parameter serializationCompletedTime: The time when the response serialization was completed. Defaults
   60|       |    ///                                         to `0.0`.
   61|       |    ///
   62|       |    /// - returns: The new `Timeline` instance.
   63|       |    public init(
   64|       |        requestStartTime: CFAbsoluteTime = 0.0,
   65|       |        initialResponseTime: CFAbsoluteTime = 0.0,
   66|       |        requestCompletedTime: CFAbsoluteTime = 0.0,
   67|       |        serializationCompletedTime: CFAbsoluteTime = 0.0)
   68|    494|    {
   69|    494|        self.requestStartTime = requestStartTime
   70|    494|        self.initialResponseTime = initialResponseTime
   71|    494|        self.requestCompletedTime = requestCompletedTime
   72|    494|        self.serializationCompletedTime = serializationCompletedTime
   73|    494|
   74|    494|        self.latency = initialResponseTime - requestStartTime
   75|    494|        self.requestDuration = requestCompletedTime - requestStartTime
   76|    494|        self.serializationDuration = serializationCompletedTime - requestCompletedTime
   77|    494|        self.totalDuration = serializationCompletedTime - requestStartTime
   78|    494|    }
   79|       |}
   80|       |
   81|       |// MARK: - CustomStringConvertible
   82|       |
   83|       |extension Timeline: CustomStringConvertible {
   84|       |    /// The textual representation used when written to an output stream, which includes the latency, the request
   85|       |    /// duration and the total duration.
   86|      0|    public var description: String {
   87|      0|        let latency = String(format: "%.3f", self.latency)
   88|      0|        let requestDuration = String(format: "%.3f", self.requestDuration)
   89|      0|        let serializationDuration = String(format: "%.3f", self.serializationDuration)
   90|      0|        let totalDuration = String(format: "%.3f", self.totalDuration)
   91|      0|
   92|      0|        // NOTE: Had to move to string concatenation due to memory leak filed as rdar://26761490. Once memory leak is
   93|      0|        // fixed, we should move back to string interpolation by reverting commit 7d4a43b1.
   94|      0|        let timings = [
   95|      0|            "\"Latency\": " + latency + " secs",
   96|      0|            "\"Request Duration\": " + requestDuration + " secs",
   97|      0|            "\"Serialization Duration\": " + serializationDuration + " secs",
   98|      0|            "\"Total Duration\": " + totalDuration + " secs"
   99|      0|        ]
  100|      0|
  101|      0|        return "Timeline: { " + timings.joined(separator: ", ") + " }"
  102|      0|    }
  103|       |}
  104|       |
  105|       |// MARK: - CustomDebugStringConvertible
  106|       |
  107|       |extension Timeline: CustomDebugStringConvertible {
  108|       |    /// The textual representation used when written to an output stream, which includes the request start time, the
  109|       |    /// initial response time, the request completed time, the serialization completed time, the latency, the request
  110|       |    /// duration and the total duration.
  111|      0|    public var debugDescription: String {
  112|      0|        let requestStartTime = String(format: "%.3f", self.requestStartTime)
  113|      0|        let initialResponseTime = String(format: "%.3f", self.initialResponseTime)
  114|      0|        let requestCompletedTime = String(format: "%.3f", self.requestCompletedTime)
  115|      0|        let serializationCompletedTime = String(format: "%.3f", self.serializationCompletedTime)
  116|      0|        let latency = String(format: "%.3f", self.latency)
  117|      0|        let requestDuration = String(format: "%.3f", self.requestDuration)
  118|      0|        let serializationDuration = String(format: "%.3f", self.serializationDuration)
  119|      0|        let totalDuration = String(format: "%.3f", self.totalDuration)
  120|      0|
  121|      0|        // NOTE: Had to move to string concatenation due to memory leak filed as rdar://26761490. Once memory leak is
  122|      0|        // fixed, we should move back to string interpolation by reverting commit 7d4a43b1.
  123|      0|        let timings = [
  124|      0|            "\"Request Start Time\": " + requestStartTime,
  125|      0|            "\"Initial Response Time\": " + initialResponseTime,
  126|      0|            "\"Request Completed Time\": " + requestCompletedTime,
  127|      0|            "\"Serialization Completed Time\": " + serializationCompletedTime,
  128|      0|            "\"Latency\": " + latency + " secs",
  129|      0|            "\"Request Duration\": " + requestDuration + " secs",
  130|      0|            "\"Serialization Duration\": " + serializationDuration + " secs",
  131|      0|            "\"Total Duration\": " + totalDuration + " secs"
  132|      0|        ]
  133|      0|
  134|      0|        return "Timeline: { " + timings.joined(separator: ", ") + " }"
  135|      0|    }
  136|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Alamofire/Source/Validation.swift:
    1|       |//
    2|       |//  Validation.swift
    3|       |//
    4|       |//  Copyright (c) 2014 Alamofire Software Foundation (http://alamofire.org/)
    5|       |//
    6|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    7|       |//  of this software and associated documentation files (the "Software"), to deal
    8|       |//  in the Software without restriction, including without limitation the rights
    9|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   10|       |//  copies of the Software, and to permit persons to whom the Software is
   11|       |//  furnished to do so, subject to the following conditions:
   12|       |//
   13|       |//  The above copyright notice and this permission notice shall be included in
   14|       |//  all copies or substantial portions of the Software.
   15|       |//
   16|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   17|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   18|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   19|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   20|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   21|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   22|       |//  THE SOFTWARE.
   23|       |//
   24|       |
   25|       |import Foundation
   26|       |
   27|       |extension Request {
   28|       |
   29|       |    // MARK: Helper Types
   30|       |
   31|       |    fileprivate typealias ErrorReason = AFError.ResponseValidationFailureReason
   32|       |
   33|       |    /// Used to represent whether validation was successful or encountered an error resulting in a failure.
   34|       |    ///
   35|       |    /// - success: The validation was successful.
   36|       |    /// - failure: The validation failed encountering the provided error.
   37|       |    public enum ValidationResult {
   38|       |        case success
   39|       |        case failure(Error)
   40|       |    }
   41|       |
   42|       |    fileprivate struct MIMEType {
   43|       |        let type: String
   44|       |        let subtype: String
   45|       |
   46|      0|        var isWildcard: Bool { return type == "*" && subtype == "*" }
   47|       |
   48|      0|        init?(_ string: String) {
   49|      0|            let components: [String] = {
   50|      0|                let stripped = string.trimmingCharacters(in: .whitespacesAndNewlines)
   51|      0|
   52|      0|            #if swift(>=3.2)
   53|      0|                let split = stripped[..<(stripped.range(of: ";")?.lowerBound ?? stripped.endIndex)]
   54|      0|            #else
   55|      0|                let split = stripped.substring(to: stripped.range(of: ";")?.lowerBound ?? stripped.endIndex)
   56|      0|            #endif
   57|      0|
   58|      0|                return split.components(separatedBy: "/")
   59|      0|            }()
   60|      0|
   61|      0|            if let type = components.first, let subtype = components.last {
   62|      0|                self.type = type
   63|      0|                self.subtype = subtype
   64|      0|            } else {
   65|      0|                return nil
   66|      0|            }
   67|      0|        }
   68|       |
   69|      0|        func matches(_ mime: MIMEType) -> Bool {
   70|      0|            switch (type, subtype) {
   71|      0|            case (mime.type, mime.subtype), (mime.type, "*"), ("*", mime.subtype), ("*", "*"):
   72|      0|                return true
   73|      0|            default:
   74|      0|                return false
   75|      0|            }
   76|      0|        }
   77|       |    }
   78|       |
   79|       |    // MARK: Properties
   80|       |
   81|      0|    fileprivate var acceptableStatusCodes: [Int] { return Array(200..<300) }
   82|       |
   83|      0|    fileprivate var acceptableContentTypes: [String] {
   84|      0|        if let accept = request?.value(forHTTPHeaderField: "Accept") {
   85|      0|            return accept.components(separatedBy: ",")
   86|      0|        }
   87|      0|
   88|      0|        return ["*/*"]
   89|      0|    }
   90|       |
   91|       |    // MARK: Status Code
   92|       |
   93|       |    fileprivate func validate<S: Sequence>(
   94|       |        statusCode acceptableStatusCodes: S,
   95|       |        response: HTTPURLResponse)
   96|       |        -> ValidationResult
   97|       |        where S.Iterator.Element == Int
   98|      0|    {
   99|      0|        if acceptableStatusCodes.contains(response.statusCode) {
  100|      0|            return .success
  101|      0|        } else {
  102|      0|            let reason: ErrorReason = .unacceptableStatusCode(code: response.statusCode)
  103|      0|            return .failure(AFError.responseValidationFailed(reason: reason))
  104|      0|        }
  105|      0|    }
  106|       |
  107|       |    // MARK: Content Type
  108|       |
  109|       |    fileprivate func validate<S: Sequence>(
  110|       |        contentType acceptableContentTypes: S,
  111|       |        response: HTTPURLResponse,
  112|       |        data: Data?)
  113|       |        -> ValidationResult
  114|       |        where S.Iterator.Element == String
  115|      0|    {
  116|      0|        guard let data = data, data.count > 0 else { return .success }
  117|      0|
  118|      0|        guard
  119|      0|            let responseContentType = response.mimeType,
  120|      0|            let responseMIMEType = MIMEType(responseContentType)
  121|      0|        else {
  122|      0|            for contentType in acceptableContentTypes {
  123|      0|                if let mimeType = MIMEType(contentType), mimeType.isWildcard {
  124|      0|                    return .success
  125|      0|                }
  126|      0|            }
  127|      0|
  128|      0|            let error: AFError = {
  129|      0|                let reason: ErrorReason = .missingContentType(acceptableContentTypes: Array(acceptableContentTypes))
  130|      0|                return AFError.responseValidationFailed(reason: reason)
  131|      0|            }()
  132|      0|
  133|      0|            return .failure(error)
  134|      0|        }
  135|      0|
  136|      0|        for contentType in acceptableContentTypes {
  137|      0|            if let acceptableMIMEType = MIMEType(contentType), acceptableMIMEType.matches(responseMIMEType) {
  138|      0|                return .success
  139|      0|            }
  140|      0|        }
  141|      0|
  142|      0|        let error: AFError = {
  143|      0|            let reason: ErrorReason = .unacceptableContentType(
  144|      0|                acceptableContentTypes: Array(acceptableContentTypes),
  145|      0|                responseContentType: responseContentType
  146|      0|            )
  147|      0|
  148|      0|            return AFError.responseValidationFailed(reason: reason)
  149|      0|        }()
  150|      0|
  151|      0|        return .failure(error)
  152|      0|    }
  153|       |}
  154|       |
  155|       |// MARK: -
  156|       |
  157|       |extension DataRequest {
  158|       |    /// A closure used to validate a request that takes a URL request, a URL response and data, and returns whether the
  159|       |    /// request was valid.
  160|       |    public typealias Validation = (URLRequest?, HTTPURLResponse, Data?) -> ValidationResult
  161|       |
  162|       |    /// Validates the request, using the specified closure.
  163|       |    ///
  164|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  165|       |    ///
  166|       |    /// - parameter validation: A closure to validate the request.
  167|       |    ///
  168|       |    /// - returns: The request.
  169|       |    @discardableResult
  170|      0|    public func validate(_ validation: @escaping Validation) -> Self {
  171|      0|        let validationExecution: () -> Void = { [unowned self] in
  172|      0|            if
  173|      0|                let response = self.response,
  174|      0|                self.delegate.error == nil,
  175|      0|                case let .failure(error) = validation(self.request, response, self.delegate.data)
  176|      0|            {
  177|      0|                self.delegate.error = error
  178|      0|            }
  179|      0|        }
  180|      0|
  181|      0|        validations.append(validationExecution)
  182|      0|
  183|      0|        return self
  184|      0|    }
  185|       |
  186|       |    /// Validates that the response has a status code in the specified sequence.
  187|       |    ///
  188|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  189|       |    ///
  190|       |    /// - parameter range: The range of acceptable status codes.
  191|       |    ///
  192|       |    /// - returns: The request.
  193|       |    @discardableResult
  194|      0|    public func validate<S: Sequence>(statusCode acceptableStatusCodes: S) -> Self where S.Iterator.Element == Int {
  195|      0|        return validate { [unowned self] _, response, _ in
  196|      0|            return self.validate(statusCode: acceptableStatusCodes, response: response)
  197|      0|        }
  198|      0|    }
  199|       |
  200|       |    /// Validates that the response has a content type in the specified sequence.
  201|       |    ///
  202|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  203|       |    ///
  204|       |    /// - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
  205|       |    ///
  206|       |    /// - returns: The request.
  207|       |    @discardableResult
  208|      0|    public func validate<S: Sequence>(contentType acceptableContentTypes: S) -> Self where S.Iterator.Element == String {
  209|      0|        return validate { [unowned self] _, response, data in
  210|      0|            return self.validate(contentType: acceptableContentTypes, response: response, data: data)
  211|      0|        }
  212|      0|    }
  213|       |
  214|       |    /// Validates that the response has a status code in the default acceptable range of 200...299, and that the content
  215|       |    /// type matches any specified in the Accept HTTP header field.
  216|       |    ///
  217|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  218|       |    ///
  219|       |    /// - returns: The request.
  220|       |    @discardableResult
  221|      0|    public func validate() -> Self {
  222|      0|        return validate(statusCode: self.acceptableStatusCodes).validate(contentType: self.acceptableContentTypes)
  223|      0|    }
  224|       |}
  225|       |
  226|       |// MARK: -
  227|       |
  228|       |extension DownloadRequest {
  229|       |    /// A closure used to validate a request that takes a URL request, a URL response, a temporary URL and a
  230|       |    /// destination URL, and returns whether the request was valid.
  231|       |    public typealias Validation = (
  232|       |        _ request: URLRequest?,
  233|       |        _ response: HTTPURLResponse,
  234|       |        _ temporaryURL: URL?,
  235|       |        _ destinationURL: URL?)
  236|       |        -> ValidationResult
  237|       |
  238|       |    /// Validates the request, using the specified closure.
  239|       |    ///
  240|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  241|       |    ///
  242|       |    /// - parameter validation: A closure to validate the request.
  243|       |    ///
  244|       |    /// - returns: The request.
  245|       |    @discardableResult
  246|      0|    public func validate(_ validation: @escaping Validation) -> Self {
  247|      0|        let validationExecution: () -> Void = { [unowned self] in
  248|      0|            let request = self.request
  249|      0|            let temporaryURL = self.downloadDelegate.temporaryURL
  250|      0|            let destinationURL = self.downloadDelegate.destinationURL
  251|      0|
  252|      0|            if
  253|      0|                let response = self.response,
  254|      0|                self.delegate.error == nil,
  255|      0|                case let .failure(error) = validation(request, response, temporaryURL, destinationURL)
  256|      0|            {
  257|      0|                self.delegate.error = error
  258|      0|            }
  259|      0|        }
  260|      0|
  261|      0|        validations.append(validationExecution)
  262|      0|
  263|      0|        return self
  264|      0|    }
  265|       |
  266|       |    /// Validates that the response has a status code in the specified sequence.
  267|       |    ///
  268|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  269|       |    ///
  270|       |    /// - parameter range: The range of acceptable status codes.
  271|       |    ///
  272|       |    /// - returns: The request.
  273|       |    @discardableResult
  274|      0|    public func validate<S: Sequence>(statusCode acceptableStatusCodes: S) -> Self where S.Iterator.Element == Int {
  275|      0|        return validate { [unowned self] _, response, _, _ in
  276|      0|            return self.validate(statusCode: acceptableStatusCodes, response: response)
  277|      0|        }
  278|      0|    }
  279|       |
  280|       |    /// Validates that the response has a content type in the specified sequence.
  281|       |    ///
  282|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  283|       |    ///
  284|       |    /// - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
  285|       |    ///
  286|       |    /// - returns: The request.
  287|       |    @discardableResult
  288|      0|    public func validate<S: Sequence>(contentType acceptableContentTypes: S) -> Self where S.Iterator.Element == String {
  289|      0|        return validate { [unowned self] _, response, _, _ in
  290|      0|            let fileURL = self.downloadDelegate.fileURL
  291|      0|
  292|      0|            guard let validFileURL = fileURL else {
  293|      0|                return .failure(AFError.responseValidationFailed(reason: .dataFileNil))
  294|      0|            }
  295|      0|
  296|      0|            do {
  297|      0|                let data = try Data(contentsOf: validFileURL)
  298|      0|                return self.validate(contentType: acceptableContentTypes, response: response, data: data)
  299|      0|            } catch {
  300|      0|                return .failure(AFError.responseValidationFailed(reason: .dataFileReadFailed(at: validFileURL)))
  301|      0|            }
  302|      0|        }
  303|      0|    }
  304|       |
  305|       |    /// Validates that the response has a status code in the default acceptable range of 200...299, and that the content
  306|       |    /// type matches any specified in the Accept HTTP header field.
  307|       |    ///
  308|       |    /// If validation fails, subsequent calls to response handlers will have an associated error.
  309|       |    ///
  310|       |    /// - returns: The request.
  311|       |    @discardableResult
  312|      0|    public func validate() -> Self {
  313|      0|        return validate(statusCode: self.acceptableStatusCodes).validate(contentType: self.acceptableContentTypes)
  314|      0|    }
  315|       |}

