/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Cache/CacheSerializer.swift:
    1|       |//
    2|       |//  CacheSerializer.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2016/09/02.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// An `CacheSerializer` is used to convert some data to an image object after
   30|       |/// retrieving it from disk storage, and vice versa, to convert an image to data object
   31|       |/// for storing to the disk storage.
   32|       |public protocol CacheSerializer {
   33|       |    
   34|       |    /// Gets the serialized data from a provided image
   35|       |    /// and optional original data for caching to disk.
   36|       |    ///
   37|       |    /// - Parameters:
   38|       |    ///   - image: The image needed to be serialized.
   39|       |    ///   - original: The original data which is just downloaded.
   40|       |    ///               If the image is retrieved from cache instead of
   41|       |    ///               downloaded, it will be `nil`.
   42|       |    /// - Returns: The data object for storing to disk, or `nil` when no valid
   43|       |    ///            data could be serialized.
   44|       |    func data(with image: Image, original: Data?) -> Data?
   45|       |
   46|       |    /// Gets an image from provided serialized data.
   47|       |    ///
   48|       |    /// - Parameters:
   49|       |    ///   - data: The data from which an image should be deserialized.
   50|       |    ///   - options: The parsed options for deserialization.
   51|       |    /// - Returns: An image deserialized or `nil` when no valid image
   52|       |    ///            could be deserialized.
   53|       |    func image(with data: Data, options: KingfisherParsedOptionsInfo) -> Image?
   54|       |    
   55|       |    /// Gets an image deserialized from provided data.
   56|       |    ///
   57|       |    /// - Parameters:
   58|       |    ///   - data: The data from which an image should be deserialized.
   59|       |    ///   - options: Options for deserialization.
   60|       |    /// - Returns: An image deserialized or `nil` when no valid image
   61|       |    ///            could be deserialized.
   62|       |    /// - Note:
   63|       |    /// This method is deprecated. Please implement the version with
   64|       |    /// `KingfisherParsedOptionsInfo` as parameter instead.
   65|       |    @available(*, deprecated,
   66|       |    message: "Deprecated. Implement the method with same name but with `KingfisherParsedOptionsInfo` instead.")
   67|       |    func image(with data: Data, options: KingfisherOptionsInfo?) -> Image?
   68|       |}
   69|       |
   70|       |extension CacheSerializer {
   71|      0|    public func image(with data: Data, options: KingfisherOptionsInfo?) -> Image? {
   72|      0|        return image(with: data, options: KingfisherParsedOptionsInfo(options))
   73|      0|    }
   74|       |}
   75|       |
   76|       |/// Represents a basic and default `CacheSerializer` used in Kingfisher disk cache system.
   77|       |/// It could serialize and deserialize images in PNG, JPEG and GIF format. For
   78|       |/// image other than these formats, a normalized `pngRepresentation` will be used.
   79|       |public struct DefaultCacheSerializer: CacheSerializer {
   80|       |    
   81|       |    /// The default general cache serializer used across Kingfisher's cache.
   82|       |    public static let `default` = DefaultCacheSerializer()
   83|      0|    private init() {}
   84|       |    
   85|       |    /// - Parameters:
   86|       |    ///   - image: The image needed to be serialized.
   87|       |    ///   - original: The original data which is just downloaded.
   88|       |    ///               If the image is retrieved from cache instead of
   89|       |    ///               downloaded, it will be `nil`.
   90|       |    /// - Returns: The data object for storing to disk, or `nil` when no valid
   91|       |    ///            data could be serialized.
   92|       |    ///
   93|       |    /// - Note:
   94|       |    /// Only when `original` contains valid PNG, JPEG and GIF format data, the `image` will be
   95|       |    /// converted to the corresponding data type. Otherwise, if the `original` is provided but it is not
   96|       |    /// a valid format, the `original` data will be used for cache.
   97|       |    ///
   98|       |    /// If `original` is `nil`, the input `image` will be encoded as PNG data.
   99|      0|    public func data(with image: Image, original: Data?) -> Data? {
  100|      0|        let imageFormat = original?.kf.imageFormat ?? .unknown
  101|      0|
  102|      0|        let data: Data?
  103|      0|        switch imageFormat {
  104|      0|        case .PNG: data = image.kf.pngRepresentation()
  105|      0|        case .JPEG: data = image.kf.jpegRepresentation(compressionQuality: 1.0)
  106|      0|        case .GIF: data = image.kf.gifRepresentation()
  107|      0|        case .unknown: data = original ?? image.kf.normalized.kf.pngRepresentation()
  108|      0|        }
  109|      0|
  110|      0|        return data
  111|      0|    }
  112|       |    
  113|       |    /// Gets an image deserialized from provided data.
  114|       |    ///
  115|       |    /// - Parameters:
  116|       |    ///   - data: The data from which an image should be deserialized.
  117|       |    ///   - options: Options for deserialization.
  118|       |    /// - Returns: An image deserialized or `nil` when no valid image
  119|       |    ///            could be deserialized.
  120|      0|    public func image(with data: Data, options: KingfisherParsedOptionsInfo) -> Image? {
  121|      0|        return KingfisherWrapper.image(data: data, options: options.imageCreatingOptions)
  122|      0|    }
  123|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Cache/DiskStorage.swift:
    1|       |//
    2|       |//  DiskStorage.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/10/15.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |
   30|       |/// Represents a set of conception related to storage which stores a certain type of value in disk.
   31|       |/// This is a namespace for the disk storage types. A `Backend` with a certain `Config` will be used to describe the
   32|       |/// storage. See these composed types for more information.
   33|       |public enum DiskStorage {
   34|       |
   35|       |    /// Represents a storage back-end for the `DiskStorage`. The value is serialized to data
   36|       |    /// and stored as file in the file system under a specified location.
   37|       |    ///
   38|       |    /// You can config a `DiskStorage.Backend` in its initializer by passing a `DiskStorage.Config` value.
   39|       |    /// or modifying the `config` property after it being created. `DiskStorage` will use file's attributes to keep
   40|       |    /// track of a file for its expiration or size limitation.
   41|       |    public class Backend<T: DataTransformable> {
   42|       |        /// The config used for this disk storage.
   43|       |        public var config: Config
   44|       |
   45|       |        // The final storage URL on disk, with `name` and `cachePathBlock` considered.
   46|       |        public let directoryURL: URL
   47|       |
   48|       |        let metaChangingQueue: DispatchQueue
   49|       |
   50|       |        /// Creates a disk storage with the given `DiskStorage.Config`.
   51|       |        ///
   52|       |        /// - Parameter config: The config used for this disk storage.
   53|       |        /// - Throws: An error if the folder for storage cannot be got or created.
   54|      0|        public init(config: Config) throws {
   55|      0|
   56|      0|            self.config = config
   57|      0|
   58|      0|            let url: URL
   59|      0|            if let directory = config.directory {
   60|      0|                url = directory
   61|      0|            } else {
   62|      0|                url = try config.fileManager.url(
   63|      0|                    for: .cachesDirectory,
   64|      0|                    in: .userDomainMask,
   65|      0|                    appropriateFor: nil,
   66|      0|                    create: true)
   67|      0|            }
   68|      0|
   69|      0|            let cacheName = "com.onevcat.Kingfisher.ImageCache.\(config.name)"
   70|      0|            directoryURL = config.cachePathBlock(url, cacheName)
   71|      0|
   72|      0|            metaChangingQueue = DispatchQueue(label: cacheName)
   73|      0|
   74|      0|            try prepareDirectory()
   75|      0|        }
   76|       |
   77|       |        // Creates the storage folder.
   78|      0|        func prepareDirectory() throws {
   79|      0|            let fileManager = config.fileManager
   80|      0|            let path = directoryURL.path
   81|      0|
   82|      0|            guard !fileManager.fileExists(atPath: path) else { return }
   83|      0|
   84|      0|            do {
   85|      0|                try fileManager.createDirectory(
   86|      0|                    atPath: path,
   87|      0|                    withIntermediateDirectories: true,
   88|      0|                    attributes: nil)
   89|      0|            } catch {
   90|      0|                throw KingfisherError.cacheError(reason: .cannotCreateDirectory(path: path, error: error))
   91|      0|            }
   92|      0|        }
   93|       |
   94|       |        func store(
   95|       |            value: T,
   96|       |            forKey key: String,
   97|       |            expiration: StorageExpiration? = nil) throws
   98|      0|        {
   99|      0|            let expiration = expiration ?? config.expiration
  100|      0|            // The expiration indicates that already expired, no need to store.
  101|      0|            guard !expiration.isExpired else { return }
  102|      0|            
  103|      0|            let data: Data
  104|      0|            do {
  105|      0|                data = try value.toData()
  106|      0|            } catch {
  107|      0|                throw KingfisherError.cacheError(reason: .cannotConvertToData(object: value, error: error))
  108|      0|            }
  109|      0|
  110|      0|            let fileURL = cacheFileURL(forKey: key)
  111|      0|
  112|      0|            let now = Date()
  113|      0|            let attributes: [FileAttributeKey : Any] = [
  114|      0|                // The last access date.
  115|      0|                .creationDate: now.fileAttributeDate,
  116|      0|                // The estimated expiration date.
  117|      0|                .modificationDate: expiration.estimatedExpirationSinceNow.fileAttributeDate
  118|      0|            ]
  119|      0|            config.fileManager.createFile(atPath: fileURL.path, contents: data, attributes: attributes)
  120|      0|        }
  121|       |
  122|      0|        func value(forKey key: String) throws -> T? {
  123|      0|            return try value(forKey: key, referenceDate: Date(), actuallyLoad: true)
  124|      0|        }
  125|       |
  126|      0|        func value(forKey key: String, referenceDate: Date, actuallyLoad: Bool) throws -> T? {
  127|      0|            let fileManager = config.fileManager
  128|      0|            let fileURL = cacheFileURL(forKey: key)
  129|      0|            let filePath = fileURL.path
  130|      0|            guard fileManager.fileExists(atPath: filePath) else {
  131|      0|                return nil
  132|      0|            }
  133|      0|
  134|      0|            let meta: FileMeta
  135|      0|            do {
  136|      0|                let resourceKeys: Set<URLResourceKey> = [.contentModificationDateKey, .creationDateKey]
  137|      0|                meta = try FileMeta(fileURL: fileURL, resourceKeys: resourceKeys)
  138|      0|            } catch {
  139|      0|                throw KingfisherError.cacheError(
  140|      0|                    reason: .invalidURLResource(error: error, key: key, url: fileURL))
  141|      0|            }
  142|      0|
  143|      0|            if meta.expired(referenceDate: referenceDate) {
  144|      0|                return nil
  145|      0|            }
  146|      0|            if !actuallyLoad { return T.empty }
  147|      0|
  148|      0|            do {
  149|      0|                let data = try Data(contentsOf: fileURL)
  150|      0|                let obj = try T.fromData(data)
  151|      0|                metaChangingQueue.async { meta.extendExpiration(with: fileManager) }
  152|      0|                return obj
  153|      0|            } catch {
  154|      0|                throw KingfisherError.cacheError(reason: .cannotLoadDataFromDisk(url: fileURL, error: error))
  155|      0|            }
  156|      0|        }
  157|       |
  158|      0|        func isCached(forKey key: String) -> Bool {
  159|      0|            return isCached(forKey: key, referenceDate: Date())
  160|      0|        }
  161|       |
  162|      0|        func isCached(forKey key: String, referenceDate: Date) -> Bool {
  163|      0|            do {
  164|      0|                guard let _ = try value(forKey: key, referenceDate: referenceDate, actuallyLoad: false) else {
  165|      0|                    return false
  166|      0|                }
  167|      0|                return true
  168|      0|            } catch {
  169|      0|                return false
  170|      0|            }
  171|      0|        }
  172|       |
  173|      0|        func remove(forKey key: String) throws {
  174|      0|            let fileURL = cacheFileURL(forKey: key)
  175|      0|            try removeFile(at: fileURL)
  176|      0|        }
  177|       |
  178|      0|        func removeFile(at url: URL) throws {
  179|      0|            try config.fileManager.removeItem(at: url)
  180|      0|        }
  181|       |
  182|      0|        func removeAll() throws {
  183|      0|            try removeAll(skipCreatingDirectory: false)
  184|      0|        }
  185|       |
  186|      0|        func removeAll(skipCreatingDirectory: Bool) throws {
  187|      0|            try config.fileManager.removeItem(at: directoryURL)
  188|      0|            if !skipCreatingDirectory {
  189|      0|                try prepareDirectory()
  190|      0|            }
  191|      0|        }
  192|       |
  193|      0|        func cacheFileURL(forKey key: String) -> URL {
  194|      0|            let fileName = cacheFileName(forKey: key)
  195|      0|            return directoryURL.appendingPathComponent(fileName)
  196|      0|        }
  197|       |
  198|      0|        func cacheFileName(forKey key: String) -> String {
  199|      0|            let hashedKey = key.kf.md5
  200|      0|            if let ext = config.pathExtension {
  201|      0|                return "\(hashedKey).\(ext)"
  202|      0|            }
  203|      0|            return hashedKey
  204|      0|        }
  205|       |
  206|      0|        func allFileURLs(for propertyKeys: [URLResourceKey]) throws -> [URL] {
  207|      0|            let fileManager = config.fileManager
  208|      0|
  209|      0|            guard let directoryEnumerator = fileManager.enumerator(
  210|      0|                at: directoryURL, includingPropertiesForKeys: propertyKeys, options: .skipsHiddenFiles) else
  211|      0|            {
  212|      0|                throw KingfisherError.cacheError(reason: .fileEnumeratorCreationFailed(url: directoryURL))
  213|      0|            }
  214|      0|
  215|      0|            guard let urls = directoryEnumerator.allObjects as? [URL] else {
  216|      0|                throw KingfisherError.cacheError(reason: .invalidFileEnumeratorContent(url: directoryURL))
  217|      0|            }
  218|      0|            return urls
  219|      0|        }
  220|       |
  221|      0|        func removeExpiredValues(referenceDate: Date = Date()) throws -> [URL] {
  222|      0|            let propertyKeys: [URLResourceKey] = [
  223|      0|                .isDirectoryKey,
  224|      0|                .contentModificationDateKey
  225|      0|            ]
  226|      0|
  227|      0|            let urls = try allFileURLs(for: propertyKeys)
  228|      0|            let keys = Set(propertyKeys)
  229|      0|            let expiredFiles = urls.filter { fileURL in
  230|      0|                do {
  231|      0|                    let meta = try FileMeta(fileURL: fileURL, resourceKeys: keys)
  232|      0|                    if meta.isDirectory {
  233|      0|                        return false
  234|      0|                    }
  235|      0|                    return meta.expired(referenceDate: referenceDate)
  236|      0|                } catch {
  237|      0|                    return true
  238|      0|                }
  239|      0|            }
  240|      0|            try expiredFiles.forEach { url in
  241|      0|                try removeFile(at: url)
  242|      0|            }
  243|      0|            return expiredFiles
  244|      0|        }
  245|       |
  246|      0|        func removeSizeExceededValues() throws -> [URL] {
  247|      0|
  248|      0|            if config.sizeLimit == 0 { return [] } // Back compatible. 0 means no limit.
  249|      0|
  250|      0|            var size = try totalSize()
  251|      0|            if size < config.sizeLimit { return [] }
  252|      0|
  253|      0|            let propertyKeys: [URLResourceKey] = [
  254|      0|                .isDirectoryKey,
  255|      0|                .creationDateKey,
  256|      0|                .fileSizeKey
  257|      0|            ]
  258|      0|            let keys = Set(propertyKeys)
  259|      0|
  260|      0|            let urls = try allFileURLs(for: propertyKeys)
  261|      0|            var pendings: [FileMeta] = urls.compactMap { fileURL in
  262|      0|                guard let meta = try? FileMeta(fileURL: fileURL, resourceKeys: keys) else {
  263|      0|                    return nil
  264|      0|                }
  265|      0|                return meta
  266|      0|            }
  267|      0|            // Sort by last access date. Most recent file first.
  268|      0|            pendings.sort(by: FileMeta.lastAccessDate)
  269|      0|
  270|      0|            var removed: [URL] = []
  271|      0|            let target = config.sizeLimit / 2
  272|      0|            while size > target, let meta = pendings.popLast() {
  273|      0|                size -= UInt(meta.fileSize)
  274|      0|                try removeFile(at: meta.url)
  275|      0|                removed.append(meta.url)
  276|      0|            }
  277|      0|            return removed
  278|      0|        }
  279|       |
  280|       |        /// Get the total file size of the folder in bytes.
  281|      0|        func totalSize() throws -> UInt {
  282|      0|            let propertyKeys: [URLResourceKey] = [.fileSizeKey]
  283|      0|            let urls = try allFileURLs(for: propertyKeys)
  284|      0|            let keys = Set(propertyKeys)
  285|      0|            let totalSize: UInt = urls.reduce(0) { size, fileURL in
  286|      0|                do {
  287|      0|                    let meta = try FileMeta(fileURL: fileURL, resourceKeys: keys)
  288|      0|                    return size + UInt(meta.fileSize)
  289|      0|                } catch {
  290|      0|                    return size
  291|      0|                }
  292|      0|            }
  293|      0|            return totalSize
  294|      0|        }
  295|       |    }
  296|       |}
  297|       |
  298|       |extension DiskStorage {
  299|       |    /// Represents the config used in a `DiskStorage`.
  300|       |    public struct Config {
  301|       |
  302|       |        /// The file size limit on disk of the storage in bytes. 0 means no limit.
  303|       |        public var sizeLimit: UInt
  304|       |
  305|       |        /// The `StorageExpiration` used in this disk storage. Default is `.days(7)`,
  306|       |        /// means that the disk cache would expire in one week.
  307|       |        public var expiration: StorageExpiration = .days(7)
  308|       |
  309|       |        /// The preferred extension of cache item. It will be appended to the file name as its extension.
  310|       |        /// Default is `nil`, means that the cache file does not contain a file extension.
  311|       |        public var pathExtension: String? = nil
  312|       |
  313|       |        let name: String
  314|       |        let fileManager: FileManager
  315|       |        let directory: URL?
  316|       |
  317|      0|        var cachePathBlock: ((_ directory: URL, _ cacheName: String) -> URL)! = {
  318|      0|            (directory, cacheName) in
  319|      0|            return directory.appendingPathComponent(cacheName, isDirectory: true)
  320|      0|        }
  321|       |
  322|       |        /// Creates a config value based on given parameters.
  323|       |        ///
  324|       |        /// - Parameters:
  325|       |        ///   - name: The name of cache. It is used as a part of storage folder. It is used to identify the disk
  326|       |        ///           storage. Two storages with the same `name` would share the same folder in disk, and it should
  327|       |        ///           be prevented.
  328|       |        ///   - sizeLimit: The size limit in bytes for all existing files in the disk storage.
  329|       |        ///   - fileManager: The `FileManager` used to manipulate files on disk. Default is `FileManager.default`.
  330|       |        ///   - directory: The URL where the disk storage should live. The storage will use this as the root folder,
  331|       |        ///                and append a path which is constructed by input `name`. Default is `nil`, indicates that
  332|       |        ///                the cache directory under user domain mask will be used.
  333|       |        public init(
  334|       |            name: String,
  335|       |            sizeLimit: UInt,
  336|       |            fileManager: FileManager = .default,
  337|       |            directory: URL? = nil)
  338|      0|        {
  339|      0|            self.name = name
  340|      0|            self.fileManager = fileManager
  341|      0|            self.directory = directory
  342|      0|            self.sizeLimit = sizeLimit
  343|      0|        }
  344|       |    }
  345|       |}
  346|       |
  347|       |extension DiskStorage {
  348|       |    struct FileMeta {
  349|       |    
  350|       |        let url: URL
  351|       |        
  352|       |        let lastAccessDate: Date?
  353|       |        let estimatedExpirationDate: Date?
  354|       |        let isDirectory: Bool
  355|       |        let fileSize: Int
  356|       |        
  357|      0|        static func lastAccessDate(lhs: FileMeta, rhs: FileMeta) -> Bool {
  358|      0|            return lhs.lastAccessDate ?? .distantPast > rhs.lastAccessDate ?? .distantPast
  359|      0|        }
  360|       |        
  361|      0|        init(fileURL: URL, resourceKeys: Set<URLResourceKey>) throws {
  362|      0|            let meta = try fileURL.resourceValues(forKeys: resourceKeys)
  363|      0|            self.init(
  364|      0|                fileURL: fileURL,
  365|      0|                lastAccessDate: meta.creationDate,
  366|      0|                estimatedExpirationDate: meta.contentModificationDate,
  367|      0|                isDirectory: meta.isDirectory ?? false,
  368|      0|                fileSize: meta.fileSize ?? 0)
  369|      0|        }
  370|       |        
  371|       |        init(
  372|       |            fileURL: URL,
  373|       |            lastAccessDate: Date?,
  374|       |            estimatedExpirationDate: Date?,
  375|       |            isDirectory: Bool,
  376|       |            fileSize: Int)
  377|      0|        {
  378|      0|            self.url = fileURL
  379|      0|            self.lastAccessDate = lastAccessDate
  380|      0|            self.estimatedExpirationDate = estimatedExpirationDate
  381|      0|            self.isDirectory = isDirectory
  382|      0|            self.fileSize = fileSize
  383|      0|        }
  384|       |
  385|      0|        func expired(referenceDate: Date) -> Bool {
  386|      0|            return estimatedExpirationDate?.isPast(referenceDate: referenceDate) ?? true
  387|      0|        }
  388|       |        
  389|      0|        func extendExpiration(with fileManager: FileManager) {
  390|      0|            guard let lastAccessDate = lastAccessDate,
  391|      0|                  let lastEstimatedExpiration = estimatedExpirationDate else
  392|      0|            {
  393|      0|                return
  394|      0|            }
  395|      0|            
  396|      0|            let originalExpiration: StorageExpiration =
  397|      0|                .seconds(lastEstimatedExpiration.timeIntervalSince(lastAccessDate))
  398|      0|            let attributes: [FileAttributeKey : Any] = [
  399|      0|                .creationDate: Date().fileAttributeDate,
  400|      0|                .modificationDate: originalExpiration.estimatedExpirationSinceNow.fileAttributeDate
  401|      0|            ]
  402|      0|
  403|      0|            try? fileManager.setAttributes(attributes, ofItemAtPath: url.path)
  404|      0|        }
  405|       |    }
  406|       |}
  407|       |

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Cache/FormatIndicatedCacheSerializer.swift:
    1|       |//
    2|       |//  RequestModifier.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Junyu Kuang on 5/28/17.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// `FormatIndicatedCacheSerializer` lets you indicate an image format for serialized caches.
   30|       |///
   31|       |/// It could serialize and deserialize PNG, JPEG and GIF images. For
   32|       |/// image other than these formats, a normalized `pngRepresentation` will be used.
   33|       |///
   34|       |/// Example:
   35|       |/// ````
   36|       |/// let profileImageSize = CGSize(width: 44, height: 44)
   37|       |///
   38|       |/// // A round corner image.
   39|       |/// let imageProcessor = RoundCornerImageProcessor(
   40|       |///     cornerRadius: profileImageSize.width / 2, targetSize: profileImageSize)
   41|       |///
   42|       |/// let optionsInfo: KingfisherOptionsInfo = [
   43|       |///     .cacheSerializer(FormatIndicatedCacheSerializer.png), 
   44|       |///     .processor(imageProcessor)]
   45|       |///
   46|       |/// A URL pointing to a JPEG image.
   47|       |/// let url = URL(string: "https://example.com/image.jpg")!
   48|       |///
   49|       |/// // Image will be always cached as PNG format to preserve alpha channel for round rectangle.
   50|       |/// // So when you load it from cache again later, it will be still round cornered.
   51|       |/// // Otherwise, the corner part would be filled by white color (since JPEG does not contain an alpha channel).
   52|       |/// imageView.kf.setImage(with: url, options: optionsInfo)
   53|       |/// ````
   54|       |public struct FormatIndicatedCacheSerializer: CacheSerializer {
   55|       |    
   56|       |    /// A `FormatIndicatedCacheSerializer` which converts image from and to PNG format. If the image cannot be
   57|       |    /// represented by PNG format, it will fallback to its real format which is determined by `original` data.
   58|       |    public static let png = FormatIndicatedCacheSerializer(imageFormat: .PNG)
   59|       |    
   60|       |    /// A `FormatIndicatedCacheSerializer` which converts image from and to JPEG format. If the image cannot be
   61|       |    /// represented by JPEG format, it will fallback to its real format which is determined by `original` data.
   62|       |    public static let jpeg = FormatIndicatedCacheSerializer(imageFormat: .JPEG)
   63|       |    
   64|       |    /// A `FormatIndicatedCacheSerializer` which converts image from and to GIF format. If the image cannot be
   65|       |    /// represented by GIF format, it will fallback to its real format which is determined by `original` data.
   66|       |    public static let gif = FormatIndicatedCacheSerializer(imageFormat: .GIF)
   67|       |    
   68|       |    /// The indicated image format.
   69|       |    private let imageFormat: ImageFormat
   70|       |    
   71|       |    /// Creates data which represents the given `image` under a format.
   72|      0|    public func data(with image: Image, original: Data?) -> Data? {
   73|      0|        
   74|      0|        func imageData(withFormat imageFormat: ImageFormat) -> Data? {
   75|      0|            switch imageFormat {
   76|      0|            case .PNG: return image.kf.pngRepresentation()
   77|      0|            case .JPEG: return image.kf.jpegRepresentation(compressionQuality: 1.0)
   78|      0|            case .GIF: return image.kf.gifRepresentation()
   79|      0|            case .unknown: return nil
   80|      0|            }
   81|      0|        }
   82|      0|        
   83|      0|        // generate data with indicated image format
   84|      0|        if let data = imageData(withFormat: imageFormat) {
   85|      0|            return data
   86|      0|        }
   87|      0|        
   88|      0|        let originalFormat = original?.kf.imageFormat ?? .unknown
   89|      0|        
   90|      0|        // generate data with original image's format
   91|      0|        if originalFormat != imageFormat, let data = imageData(withFormat: originalFormat) {
   92|      0|            return data
   93|      0|        }
   94|      0|        
   95|      0|        return original ?? image.kf.normalized.kf.pngRepresentation()
   96|      0|    }
   97|       |    
   98|       |    /// Same implementation as `DefaultCacheSerializer`.
   99|      0|    public func image(with data: Data, options: KingfisherParsedOptionsInfo) -> Image? {
  100|      0|        return KingfisherWrapper.image(data: data, options: options.imageCreatingOptions)
  101|      0|    }
  102|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Cache/ImageCache.swift:
    1|       |//
    2|       |//  ImageCache.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |import AppKit
   29|       |#else
   30|       |import UIKit
   31|       |#endif
   32|       |
   33|       |extension Notification.Name {
   34|       |    /// This notification will be sent when the disk cache got cleaned either there are cached files expired or the
   35|       |    /// total size exceeding the max allowed size. The manually invoking of `clearDiskCache` method will not trigger
   36|       |    /// this notification.
   37|       |    ///
   38|       |    /// The `object` of this notification is the `ImageCache` object which sends the notification.
   39|       |    /// A list of removed hashes (files) could be retrieved by accessing the array under
   40|       |    /// `KingfisherDiskCacheCleanedHashKey` key in `userInfo` of the notification object you received.
   41|       |    /// By checking the array, you could know the hash codes of files are removed.
   42|       |    public static let KingfisherDidCleanDiskCache =
   43|       |        Notification.Name("com.onevcat.Kingfisher.KingfisherDidCleanDiskCache")
   44|       |}
   45|       |
   46|       |/// Key for array of cleaned hashes in `userInfo` of `KingfisherDidCleanDiskCacheNotification`.
   47|       |public let KingfisherDiskCacheCleanedHashKey = "com.onevcat.Kingfisher.cleanedHash"
   48|       |
   49|       |/// Cache type of a cached image.
   50|       |/// - none: The image is not cached yet when retrieving it.
   51|       |/// - memory: The image is cached in memory.
   52|       |/// - disk: The image is cached in disk.
   53|       |public enum CacheType {
   54|       |    /// The image is not cached yet when retrieving it.
   55|       |    case none
   56|       |    /// The image is cached in memory.
   57|       |    case memory
   58|       |    /// The image is cached in disk.
   59|       |    case disk
   60|       |    
   61|       |    /// Whether the cache type represents the image is already cached or not.
   62|      0|    public var cached: Bool {
   63|      0|        switch self {
   64|      0|        case .memory, .disk: return true
   65|      0|        case .none: return false
   66|      0|        }
   67|      0|    }
   68|       |}
   69|       |
   70|       |/// Represents the caching operation result.
   71|       |public struct CacheStoreResult {
   72|       |    
   73|       |    /// The cache result for memory cache. Caching an image to memory will never fail.
   74|       |    public let memoryCacheResult: Result<(), Never>
   75|       |    
   76|       |    /// The cache result for disk cache. If an error happens during caching operation,
   77|       |    /// you can get it from `.failure` case of this `diskCacheResult`.
   78|       |    public let diskCacheResult: Result<(), KingfisherError>
   79|       |}
   80|       |
   81|       |extension Image: CacheCostCalculable {
   82|       |    /// Cost of an image
   83|      0|    public var cacheCost: Int { return kf.cost }
   84|       |}
   85|       |
   86|       |extension Data: DataTransformable {
   87|      0|    public func toData() throws -> Data {
   88|      0|        return self
   89|      0|    }
   90|       |
   91|      0|    public static func fromData(_ data: Data) throws -> Data {
   92|      0|        return data
   93|      0|    }
   94|       |
   95|       |    public static let empty = Data()
   96|       |}
   97|       |
   98|       |
   99|       |/// Represents the getting image operation from the cache.
  100|       |///
  101|       |/// - disk: The image can be retrieved from disk cache.
  102|       |/// - memory: The image can be retrieved memory cache.
  103|       |/// - none: The image does not exist in the cache.
  104|       |public enum ImageCacheResult {
  105|       |    
  106|       |    /// The image can be retrieved from disk cache.
  107|       |    case disk(Image)
  108|       |    
  109|       |    /// The image can be retrieved memory cache.
  110|       |    case memory(Image)
  111|       |    
  112|       |    /// The image does not exist in the cache.
  113|       |    case none
  114|       |    
  115|       |    /// Extracts the image from cache result. It returns the associated `Image` value for
  116|       |    /// `.disk` and `.memory` case. For `.none` case, `nil` is returned.
  117|      0|    public var image: Image? {
  118|      0|        switch self {
  119|      0|        case .disk(let image): return image
  120|      0|        case .memory(let image): return image
  121|      0|        case .none: return nil
  122|      0|        }
  123|      0|    }
  124|       |    
  125|       |    /// Returns the corresponding `CacheType` value based on the result type of `self`.
  126|      0|    public var cacheType: CacheType {
  127|      0|        switch self {
  128|      0|        case .disk: return .disk
  129|      0|        case .memory: return .memory
  130|      0|        case .none: return .none
  131|      0|        }
  132|      0|    }
  133|       |}
  134|       |
  135|       |/// Represents a hybrid caching system which is composed by a `MemoryStorage.Backend` and a `DiskStorage.Backend`.
  136|       |/// `ImageCache` is a high level abstract for storing an image as well as its data to disk memory and disk, and
  137|       |/// retrieving them back.
  138|       |///
  139|       |/// While a default image cache object will be used if you prefer the extension methods of Kingfisher, you can create
  140|       |/// your own cache object and configure its storages as your need. This class also provide an interface for you to set
  141|       |/// the memory and disk storage config.
  142|       |open class ImageCache {
  143|       |
  144|       |    // MARK: Singleton
  145|       |    /// The default `ImageCache` object. Kingfisher will use this cache for its related methods if there is no
  146|       |    /// other cache specified. The `name` of this default cache is "default", and you should not use this name
  147|       |    /// for any of your customize cache.
  148|       |    public static let `default` = ImageCache(name: "default")
  149|       |
  150|       |    // MARK: Public Properties
  151|       |    /// The `MemoryStorage.Backend` object used in this cache. This storage holds loaded images in memory with a
  152|       |    /// reasonable expire duration and a maximum memory usage. To modify the configuration of a storage, just set
  153|       |    /// the storage `config` and its properties.
  154|       |    public let memoryStorage: MemoryStorage.Backend<Image>
  155|       |    
  156|       |    /// The `DiskStorage.Backend` object used in this cache. This storage stores loaded images in disk with a
  157|       |    /// reasonable expire duration and a maximum disk usage. To modify the configuration of a storage, just set
  158|       |    /// the storage `config` and its properties.
  159|       |    public let diskStorage: DiskStorage.Backend<Data>
  160|       |    
  161|       |    private let ioQueue: DispatchQueue
  162|       |    
  163|       |    /// Closure that defines the disk cache path from a given path and cacheName.
  164|       |    public typealias DiskCachePathClosure = (URL, String) -> URL
  165|       |
  166|       |    // MARK: Initializers
  167|       |
  168|       |    /// Creates an `ImageCache` from a customized `MemoryStorage` and `DiskStorage`.
  169|       |    ///
  170|       |    /// - Parameters:
  171|       |    ///   - memoryStorage: The `MemoryStorage.Backend` object to use in the image cache.
  172|       |    ///   - diskStorage: The `DiskStorage.Backend` object to use in the image cache.
  173|       |    public init(
  174|       |        memoryStorage: MemoryStorage.Backend<Image>,
  175|       |        diskStorage: DiskStorage.Backend<Data>)
  176|      0|    {
  177|      0|        self.memoryStorage = memoryStorage
  178|      0|        self.diskStorage = diskStorage
  179|      0|        let ioQueueName = "com.onevcat.Kingfisher.ImageCache.ioQueue.\(UUID().uuidString)"
  180|      0|        ioQueue = DispatchQueue(label: ioQueueName)
  181|      0|
  182|      0|        let notifications: [(Notification.Name, Selector)]
  183|      0|        #if !os(macOS) && !os(watchOS)
  184|      0|        #if swift(>=4.2)
  185|      0|        notifications = [
  186|      0|            (UIApplication.didReceiveMemoryWarningNotification, #selector(clearMemoryCache)),
  187|      0|            (UIApplication.willTerminateNotification, #selector(cleanExpiredDiskCache)),
  188|      0|            (UIApplication.didEnterBackgroundNotification, #selector(backgroundCleanExpiredDiskCache))
  189|      0|        ]
  190|      0|        #else
  191|      0|        notifications = [
  192|      0|            (NSNotification.Name.UIApplicationDidReceiveMemoryWarning, #selector(clearMemoryCache)),
  193|      0|            (NSNotification.Name.UIApplicationWillTerminate, #selector(cleanExpiredDiskCache)),
  194|      0|            (NSNotification.Name.UIApplicationDidEnterBackground, #selector(backgroundCleanExpiredDiskCache))
  195|      0|        ]
  196|      0|        #endif
  197|      0|        #elseif os(macOS)
  198|      0|        notifications = [
  199|      0|            (NSApplication.willResignActiveNotification, #selector(cleanExpiredDiskCache)),
  200|      0|        ]
  201|      0|        #else
  202|      0|        notifications = []
  203|      0|        #endif
  204|      0|        notifications.forEach {
  205|      0|            NotificationCenter.default.addObserver(self, selector: $0.1, name: $0.0, object: nil)
  206|      0|        }
  207|      0|    }
  208|       |    
  209|       |    /// Creates an `ImageCache` with a given `name`. Both `MemoryStorage` and `DiskStorage` will be created
  210|       |    /// with a default config based on the `name`.
  211|       |    ///
  212|       |    /// - Parameter name: The name of cache object. It is used to setup disk cache directories and IO queue.
  213|       |    ///                   You should not use the same `name` for different caches, otherwise, the disk storage would
  214|       |    ///                   be conflicting to each other. The `name` should not be an empty string.
  215|      0|    public convenience init(name: String) {
  216|      0|        try! self.init(name: name, cacheDirectoryURL: nil, diskCachePathClosure: nil)
  217|      0|    }
  218|       |
  219|       |    /// Creates an `ImageCache` with a given `name`, cache directory `path`
  220|       |    /// and a closure to modify the cache directory.
  221|       |    ///
  222|       |    /// - Parameters:
  223|       |    ///   - name: The name of cache object. It is used to setup disk cache directories and IO queue.
  224|       |    ///           You should not use the same `name` for different caches, otherwise, the disk storage would
  225|       |    ///           be conflicting to each other.
  226|       |    ///   - cacheDirectoryURL: Location of cache directory URL on disk. It will be internally pass to the
  227|       |    ///                        initializer of `DiskStorage` as the disk cache directory. If `nil`, the cache
  228|       |    ///                        directory under user domain mask will be used.
  229|       |    ///   - diskCachePathClosure: Closure that takes in an optional initial path string and generates
  230|       |    ///                           the final disk cache path. You could use it to fully customize your cache path.
  231|       |    /// - Throws: An error that happens during image cache creating, such as unable to create a directory at the given
  232|       |    ///           path.
  233|       |    public convenience init(
  234|       |        name: String,
  235|       |        cacheDirectoryURL: URL?,
  236|       |        diskCachePathClosure: DiskCachePathClosure? = nil) throws
  237|      0|    {
  238|      0|        if name.isEmpty {
  239|      0|            fatalError("[Kingfisher] You should specify a name for the cache. A cache with empty name is not permitted.")
  240|      0|        }
  241|      0|
  242|      0|        let totalMemory = ProcessInfo.processInfo.physicalMemory
  243|      0|        let costLimit = totalMemory / 4
  244|      0|        let memoryStorage = MemoryStorage.Backend<Image>(config:
  245|      0|            .init(totalCostLimit: (costLimit > Int.max) ? Int.max : Int(costLimit)))
  246|      0|
  247|      0|        var diskConfig = DiskStorage.Config(
  248|      0|            name: name,
  249|      0|            sizeLimit: 0,
  250|      0|            directory: cacheDirectoryURL
  251|      0|        )
  252|      0|        if let closure = diskCachePathClosure {
  253|      0|            diskConfig.cachePathBlock = closure
  254|      0|        }
  255|      0|        let diskStorage = try DiskStorage.Backend<Data>(config: diskConfig)
  256|      0|        diskConfig.cachePathBlock = nil
  257|      0|
  258|      0|        self.init(memoryStorage: memoryStorage, diskStorage: diskStorage)
  259|      0|    }
  260|       |    
  261|      0|    deinit {
  262|      0|        NotificationCenter.default.removeObserver(self)
  263|      0|    }
  264|       |
  265|       |    // MARK: Storing Images
  266|       |
  267|       |    open func store(_ image: Image,
  268|       |                    original: Data? = nil,
  269|       |                    forKey key: String,
  270|       |                    options: KingfisherParsedOptionsInfo,
  271|       |                    toDisk: Bool = true,
  272|       |                    completionHandler: ((CacheStoreResult) -> Void)? = nil)
  273|      0|    {
  274|      0|        let identifier = options.processor.identifier
  275|      0|        let callbackQueue = options.callbackQueue
  276|      0|        
  277|      0|        let computedKey = key.computedKey(with: identifier)
  278|      0|        // Memory storage should not throw.
  279|      0|        memoryStorage.storeNoThrow(value: image, forKey: computedKey, expiration: options.memoryCacheExpiration)
  280|      0|        
  281|      0|        guard toDisk else {
  282|      0|            if let completionHandler = completionHandler {
  283|      0|                let result = CacheStoreResult(memoryCacheResult: .success(()), diskCacheResult: .success(()))
  284|      0|                callbackQueue.execute { completionHandler(result) }
  285|      0|            }
  286|      0|            return
  287|      0|        }
  288|      0|        
  289|      0|        ioQueue.async {
  290|      0|            let serializer = options.cacheSerializer
  291|      0|            if let data = serializer.data(with: image, original: original) {
  292|      0|                self.syncStoreToDisk(
  293|      0|                    data,
  294|      0|                    forKey: key,
  295|      0|                    processorIdentifier: identifier,
  296|      0|                    callbackQueue: callbackQueue,
  297|      0|                    expiration: options.diskCacheExpiration,
  298|      0|                    completionHandler: completionHandler)
  299|      0|            } else {
  300|      0|                guard let completionHandler = completionHandler else { return }
  301|      0|                
  302|      0|                let diskError = KingfisherError.cacheError(
  303|      0|                    reason: .cannotSerializeImage(image: image, original: original, serializer: serializer))
  304|      0|                let result = CacheStoreResult(
  305|      0|                    memoryCacheResult: .success(()),
  306|      0|                    diskCacheResult: .failure(diskError))
  307|      0|                callbackQueue.execute { completionHandler(result) }
  308|      0|            }
  309|      0|        }
  310|      0|    }
  311|       |
  312|       |    /// Stores an image to the cache.
  313|       |    ///
  314|       |    /// - Parameters:
  315|       |    ///   - image: The image to be stored.
  316|       |    ///   - original: The original data of the image. This value will be forwarded to the provided `serializer` for
  317|       |    ///               further use. By default, Kingfisher uses a `DefaultCacheSerializer` to serialize the image to
  318|       |    ///               data for caching in disk, it checks the image format based on `original` data to determine in
  319|       |    ///               which image format should be used. For other types of `serializer`, it depends on their
  320|       |    ///               implementation detail on how to use this original data.
  321|       |    ///   - key: The key used for caching the image.
  322|       |    ///   - identifier: The identifier of processor being used for caching. If you are using a processor for the
  323|       |    ///                 image, pass the identifier of processor to this parameter.
  324|       |    ///   - serializer: The `CacheSerializer`
  325|       |    ///   - toDisk: Whether this image should be cached to disk or not. If `false`, the image is only cached in memory.
  326|       |    ///             Otherwise, it is cached in both memory storage and disk storage. Default is `true`.
  327|       |    ///   - callbackQueue: The callback queue on which `completionHandler` is invoked. Default is `.untouch`. For case
  328|       |    ///                    that `toDisk` is `false`, a `.untouch` queue means `callbackQueue` will be invoked from the
  329|       |    ///                    caller queue of this method. If `toDisk` is `true`, the `completionHandler` will be called
  330|       |    ///                    from an internal file IO queue. To change this behavior, specify another `CallbackQueue`
  331|       |    ///                    value.
  332|       |    ///   - completionHandler: A closure which is invoked when the cache operation finishes.
  333|       |    open func store(_ image: Image,
  334|       |                      original: Data? = nil,
  335|       |                      forKey key: String,
  336|       |                      processorIdentifier identifier: String = "",
  337|       |                      cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,
  338|       |                      toDisk: Bool = true,
  339|       |                      callbackQueue: CallbackQueue = .untouch,
  340|       |                      completionHandler: ((CacheStoreResult) -> Void)? = nil)
  341|      0|    {
  342|      0|        struct TempProcessor: ImageProcessor {
  343|      0|            let identifier: String
  344|      0|            func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  345|      0|                return nil
  346|      0|            }
  347|      0|        }
  348|      0|        
  349|      0|        let options = KingfisherParsedOptionsInfo([
  350|      0|            .processor(TempProcessor(identifier: identifier)),
  351|      0|            .cacheSerializer(serializer),
  352|      0|            .callbackQueue(callbackQueue)
  353|      0|        ])
  354|      0|        store(image, original: original, forKey: key, options: options,
  355|      0|              toDisk: toDisk, completionHandler: completionHandler)
  356|      0|    }
  357|       |    
  358|       |    open func storeToDisk(
  359|       |        _ data: Data,
  360|       |        forKey key: String,
  361|       |        processorIdentifier identifier: String = "",
  362|       |        expiration: StorageExpiration? = nil,
  363|       |        callbackQueue: CallbackQueue = .untouch,
  364|       |        completionHandler: ((CacheStoreResult) -> Void)? = nil)
  365|      0|    {
  366|      0|        ioQueue.async {
  367|      0|            self.syncStoreToDisk(
  368|      0|                data,
  369|      0|                forKey: key,
  370|      0|                processorIdentifier: identifier,
  371|      0|                callbackQueue: callbackQueue,
  372|      0|                expiration: expiration,
  373|      0|                completionHandler: completionHandler)
  374|      0|        }
  375|      0|    }
  376|       |    
  377|       |    private func syncStoreToDisk(
  378|       |        _ data: Data,
  379|       |        forKey key: String,
  380|       |        processorIdentifier identifier: String = "",
  381|       |        callbackQueue: CallbackQueue = .untouch,
  382|       |        expiration: StorageExpiration? = nil,
  383|       |        completionHandler: ((CacheStoreResult) -> Void)? = nil)
  384|      0|    {
  385|      0|        let computedKey = key.computedKey(with: identifier)
  386|      0|        let result: CacheStoreResult
  387|      0|        do {
  388|      0|            try self.diskStorage.store(value: data, forKey: computedKey, expiration: expiration)
  389|      0|            result = CacheStoreResult(memoryCacheResult: .success(()), diskCacheResult: .success(()))
  390|      0|        } catch {
  391|      0|            let diskError: KingfisherError
  392|      0|            if let error = error as? KingfisherError {
  393|      0|                diskError = error
  394|      0|            } else {
  395|      0|                diskError = .cacheError(reason: .cannotConvertToData(object: data, error: error))
  396|      0|            }
  397|      0|            
  398|      0|            result = CacheStoreResult(
  399|      0|                memoryCacheResult: .success(()),
  400|      0|                diskCacheResult: .failure(diskError)
  401|      0|            )
  402|      0|        }
  403|      0|        if let completionHandler = completionHandler {
  404|      0|            callbackQueue.execute { completionHandler(result) }
  405|      0|        }
  406|      0|    }
  407|       |
  408|       |    // MARK: Removing Images
  409|       |
  410|       |    /// Removes the image for the given key from the cache.
  411|       |    ///
  412|       |    /// - Parameters:
  413|       |    ///   - key: The key used for caching the image.
  414|       |    ///   - identifier: The identifier of processor being used for caching. If you are using a processor for the
  415|       |    ///                 image, pass the identifier of processor to this parameter.
  416|       |    ///   - fromMemory: Whether this image should be removed from memory storage or not.
  417|       |    ///                 If `false`, the image won't be removed from the memory storage. Default is `true`.
  418|       |    ///   - fromDisk: Whether this image should be removed from disk storage or not.
  419|       |    ///               If `false`, the image won't be removed from the disk storage. Default is `true`.
  420|       |    ///   - callbackQueue: The callback queue on which `completionHandler` is invoked. Default is `.untouch`.
  421|       |    ///   - completionHandler: A closure which is invoked when the cache removing operation finishes.
  422|       |    open func removeImage(forKey key: String,
  423|       |                          processorIdentifier identifier: String = "",
  424|       |                          fromMemory: Bool = true,
  425|       |                          fromDisk: Bool = true,
  426|       |                          callbackQueue: CallbackQueue = .untouch,
  427|       |                          completionHandler: (() -> Void)? = nil)
  428|      0|    {
  429|      0|        let computedKey = key.computedKey(with: identifier)
  430|      0|
  431|      0|        if fromMemory {
  432|      0|            try? memoryStorage.remove(forKey: computedKey)
  433|      0|        }
  434|      0|        
  435|      0|        if fromDisk {
  436|      0|            ioQueue.async{
  437|      0|                try? self.diskStorage.remove(forKey: computedKey)
  438|      0|                if let completionHandler = completionHandler {
  439|      0|                    callbackQueue.execute { completionHandler() }
  440|      0|                }
  441|      0|            }
  442|      0|        } else {
  443|      0|            if let completionHandler = completionHandler {
  444|      0|                callbackQueue.execute { completionHandler() }
  445|      0|            }
  446|      0|        }
  447|      0|    }
  448|       |
  449|       |    func retrieveImage(forKey key: String,
  450|       |                       options: KingfisherParsedOptionsInfo,
  451|       |                       callbackQueue: CallbackQueue = .untouch,
  452|       |                       completionHandler: ((Result<ImageCacheResult, KingfisherError>) -> Void)?)
  453|      0|    {
  454|      0|        // No completion handler. No need to start working and early return.
  455|      0|        guard let completionHandler = completionHandler else { return }
  456|      0|
  457|      0|        // Try to check the image from memory cache first.
  458|      0|        if let image = retrieveImageInMemoryCache(forKey: key, options: options) {
  459|      0|            let image = options.imageModifier?.modify(image) ?? image
  460|      0|            callbackQueue.execute { completionHandler(.success(.memory(image))) }
  461|      0|        } else if options.fromMemoryCacheOrRefresh {
  462|      0|            callbackQueue.execute { completionHandler(.success(.none)) }
  463|      0|        } else {
  464|      0|            // Begin to disk search.
  465|      0|            self.retrieveImageInDiskCache(forKey: key, options: options, callbackQueue: callbackQueue) {
  466|      0|                result in
  467|      0|                // The callback queue is already correct in this closure.
  468|      0|                switch result {
  469|      0|                case .success(let image):
  470|      0|
  471|      0|                    guard let image = image else {
  472|      0|                        // No image found in disk storage.
  473|      0|                        completionHandler(.success(.none))
  474|      0|                        return
  475|      0|                    }
  476|      0|
  477|      0|                    let finalImage = options.imageModifier?.modify(image) ?? image
  478|      0|                    // Cache the disk image to memory.
  479|      0|                    // We are passing `false` to `toDisk`, the memory cache does not change
  480|      0|                    // callback queue, we can call `completionHandler` without another dispatch.
  481|      0|                    var cacheOptions = options
  482|      0|                    cacheOptions.callbackQueue = .untouch
  483|      0|                    self.store(
  484|      0|                        finalImage,
  485|      0|                        forKey: key,
  486|      0|                        options: cacheOptions,
  487|      0|                        toDisk: false)
  488|      0|                    {
  489|      0|                        _ in
  490|      0|                        completionHandler(.success(.disk(finalImage)))
  491|      0|                    }
  492|      0|                case .failure(let error):
  493|      0|                    completionHandler(.failure(error))
  494|      0|                }
  495|      0|            }
  496|      0|        }
  497|      0|    }
  498|       |
  499|       |    // MARK: Getting Images
  500|       |
  501|       |    /// Gets an image for a given key from the cache, either from memory storage or disk storage.
  502|       |    ///
  503|       |    /// - Parameters:
  504|       |    ///   - key: The key used for caching the image.
  505|       |    ///   - options: The `KingfisherOptionsInfo` options setting used for retrieving the image.
  506|       |    ///   - callbackQueue: The callback queue on which `completionHandler` is invoked. Default is `.untouch`.
  507|       |    ///   - completionHandler: A closure which is invoked when the image getting operation finishes. If the
  508|       |    ///                        image retrieving operation finishes without problem, an `ImageCacheResult` value
  509|       |    ///                        will be sent to this closure as result. Otherwise, a `KingfisherError` result
  510|       |    ///                        with detail failing reason will be sent.
  511|       |    open func retrieveImage(forKey key: String,
  512|       |                               options: KingfisherOptionsInfo? = nil,
  513|       |                        callbackQueue: CallbackQueue = .untouch,
  514|       |                     completionHandler: ((Result<ImageCacheResult, KingfisherError>) -> Void)?)
  515|      0|    {
  516|      0|        retrieveImage(
  517|      0|            forKey: key,
  518|      0|            options: KingfisherParsedOptionsInfo(options),
  519|      0|            callbackQueue: callbackQueue,
  520|      0|            completionHandler: completionHandler)
  521|      0|    }
  522|       |
  523|       |    func retrieveImageInMemoryCache(
  524|       |        forKey key: String,
  525|       |        options: KingfisherParsedOptionsInfo) -> Image?
  526|      0|    {
  527|      0|        let computedKey = key.computedKey(with: options.processor.identifier)
  528|      0|        do {
  529|      0|            return try memoryStorage.value(forKey: computedKey)
  530|      0|        } catch {
  531|      0|            return nil
  532|      0|        }
  533|      0|    }
  534|       |
  535|       |    /// Gets an image for a given key from the memory storage.
  536|       |    ///
  537|       |    /// - Parameters:
  538|       |    ///   - key: The key used for caching the image.
  539|       |    ///   - options: The `KingfisherOptionsInfo` options setting used for retrieving the image.
  540|       |    /// - Returns: The image stored in memory cache, if exists and valid. Otherwise, if the image does not exist or
  541|       |    ///            has already expired, `nil` is returned.
  542|       |    open func retrieveImageInMemoryCache(
  543|       |        forKey key: String,
  544|       |        options: KingfisherOptionsInfo? = nil) -> Image?
  545|      0|    {
  546|      0|        return retrieveImageInMemoryCache(forKey: key, options: KingfisherParsedOptionsInfo(options))
  547|      0|    }
  548|       |
  549|       |    func retrieveImageInDiskCache(
  550|       |        forKey key: String,
  551|       |        options: KingfisherParsedOptionsInfo,
  552|       |        callbackQueue: CallbackQueue = .untouch,
  553|       |        completionHandler: @escaping (Result<Image?, KingfisherError>) -> Void)
  554|      0|    {
  555|      0|        let computedKey = key.computedKey(with: options.processor.identifier)
  556|      0|        let loadingQueue: CallbackQueue = options.loadDiskFileSynchronously ? .untouch : .dispatch(ioQueue)
  557|      0|        loadingQueue.execute {
  558|      0|            do {
  559|      0|                var image: Image? = nil
  560|      0|                if let data = try self.diskStorage.value(forKey: computedKey) {
  561|      0|                    image = options.cacheSerializer.image(with: data, options: options)
  562|      0|                }
  563|      0|                callbackQueue.execute { completionHandler(.success(image)) }
  564|      0|            } catch {
  565|      0|                if let error = error as? KingfisherError {
  566|      0|                    callbackQueue.execute { completionHandler(.failure(error)) }
  567|      0|                } else {
  568|      0|                    assertionFailure("The internal thrown error should be a `KingfisherError`.")
  569|      0|                }
  570|      0|            }
  571|      0|        }
  572|      0|    }
  573|       |    
  574|       |    /// Gets an image for a given key from the disk storage.
  575|       |    ///
  576|       |    /// - Parameters:
  577|       |    ///   - key: The key used for caching the image.
  578|       |    ///   - options: The `KingfisherOptionsInfo` options setting used for retrieving the image.
  579|       |    ///   - callbackQueue: The callback queue on which `completionHandler` is invoked. Default is `.untouch`.
  580|       |    ///   - completionHandler: A closure which is invoked when the operation finishes.
  581|       |    open func retrieveImageInDiskCache(
  582|       |        forKey key: String,
  583|       |        options: KingfisherOptionsInfo? = nil,
  584|       |        callbackQueue: CallbackQueue = .untouch,
  585|       |        completionHandler: @escaping (Result<Image?, KingfisherError>) -> Void)
  586|      0|    {
  587|      0|        retrieveImageInDiskCache(
  588|      0|            forKey: key,
  589|      0|            options: KingfisherParsedOptionsInfo(options),
  590|      0|            callbackQueue: callbackQueue,
  591|      0|            completionHandler: completionHandler)
  592|      0|    }
  593|       |
  594|       |    // MARK: Cleaning
  595|       |    /// Clears the memory storage of this cache.
  596|      0|    @objc public func clearMemoryCache() {
  597|      0|        try? memoryStorage.removeAll()
  598|      0|    }
  599|       |    
  600|       |    /// Clears the disk storage of this cache. This is an async operation.
  601|       |    ///
  602|       |    /// - Parameter handler: A closure which is invoked when the cache clearing operation finishes.
  603|       |    ///                      This `handler` will be called from the main queue.
  604|      0|    open func clearDiskCache(completion handler: (()->())? = nil) {
  605|      0|        ioQueue.async {
  606|      0|            do {
  607|      0|                try self.diskStorage.removeAll()
  608|      0|            } catch _ { }
  609|      0|            if let handler = handler {
  610|      0|                DispatchQueue.main.async { handler() }
  611|      0|            }
  612|      0|        }
  613|      0|    }
  614|       |
  615|       |    /// Clears the expired images from disk storage. This is an async operation.
  616|      0|    open func cleanExpiredMemoryCache() {
  617|      0|        memoryStorage.removeExpired()
  618|      0|    }
  619|       |    
  620|       |    /// Clears the expired images from disk storage. This is an async operation.
  621|      0|    @objc func cleanExpiredDiskCache() {
  622|      0|        cleanExpiredDiskCache(completion: nil)
  623|      0|    }
  624|       |
  625|       |    /// Clears the expired images from disk storage. This is an async operation.
  626|       |    ///
  627|       |    /// - Parameter handler: A closure which is invoked when the cache clearing operation finishes.
  628|       |    ///                      This `handler` will be called from the main queue.
  629|      0|    open func cleanExpiredDiskCache(completion handler: (() -> Void)? = nil) {
  630|      0|        ioQueue.async {
  631|      0|            do {
  632|      0|                var removed: [URL] = []
  633|      0|                let removedExpired = try self.diskStorage.removeExpiredValues()
  634|      0|                removed.append(contentsOf: removedExpired)
  635|      0|
  636|      0|                let removedSizeExceeded = try self.diskStorage.removeSizeExceededValues()
  637|      0|                removed.append(contentsOf: removedSizeExceeded)
  638|      0|
  639|      0|                if !removed.isEmpty {
  640|      0|                    DispatchQueue.main.async {
  641|      0|                        let cleanedHashes = removed.map { $0.lastPathComponent }
  642|      0|                        NotificationCenter.default.post(
  643|      0|                            name: .KingfisherDidCleanDiskCache,
  644|      0|                            object: self,
  645|      0|                            userInfo: [KingfisherDiskCacheCleanedHashKey: cleanedHashes])
  646|      0|                    }
  647|      0|                }
  648|      0|
  649|      0|                if let handler = handler {
  650|      0|                    DispatchQueue.main.async { handler() }
  651|      0|                }
  652|      0|            } catch {}
  653|      0|        }
  654|      0|    }
  655|       |
  656|       |#if !os(macOS) && !os(watchOS)
  657|       |    /// Clears the expired images from disk storage when app is in background. This is an async operation.
  658|       |    /// In most cases, you should not call this method explicitly.
  659|       |    /// It will be called automatically when `UIApplicationDidEnterBackgroundNotification` received.
  660|      0|    @objc public func backgroundCleanExpiredDiskCache() {
  661|      0|        // if 'sharedApplication()' is unavailable, then return
  662|      0|        guard let sharedApplication = KingfisherWrapper<UIApplication>.shared else { return }
  663|      0|
  664|      0|        func endBackgroundTask(_ task: inout UIBackgroundTaskIdentifier) {
  665|      0|            sharedApplication.endBackgroundTask(task)
  666|      0|            #if swift(>=4.2)
  667|      0|            task = UIBackgroundTaskIdentifier.invalid
  668|      0|            #else
  669|      0|            task = UIBackgroundTaskInvalid
  670|      0|            #endif
  671|      0|        }
  672|      0|        
  673|      0|        var backgroundTask: UIBackgroundTaskIdentifier!
  674|      0|        backgroundTask = sharedApplication.beginBackgroundTask {
  675|      0|            endBackgroundTask(&backgroundTask!)
  676|      0|        }
  677|      0|        
  678|      0|        cleanExpiredDiskCache {
  679|      0|            endBackgroundTask(&backgroundTask!)
  680|      0|        }
  681|      0|    }
  682|       |#endif
  683|       |
  684|       |    // MARK: Image Cache State
  685|       |
  686|       |    /// Returns the cache type for a given `key` and `identifier` combination.
  687|       |    /// This method is used for checking whether an image is cached in current cache.
  688|       |    /// It also provides information on which kind of cache can it be found in the return value.
  689|       |    ///
  690|       |    /// - Parameters:
  691|       |    ///   - key: The key used for caching the image.
  692|       |    ///   - identifier: Processor identifier which used for this image. Default is the `identifier` of
  693|       |    ///                 `DefaultImageProcessor.default`.
  694|       |    /// - Returns: A `CacheType` instance which indicates the cache status.
  695|       |    ///            `.none` means the image is not in cache or it is already expired.
  696|       |    open func imageCachedType(
  697|       |        forKey key: String,
  698|       |        processorIdentifier identifier: String = DefaultImageProcessor.default.identifier) -> CacheType
  699|      0|    {
  700|      0|        let computedKey = key.computedKey(with: identifier)
  701|      0|        if memoryStorage.isCached(forKey: computedKey) { return .memory }
  702|      0|        if diskStorage.isCached(forKey: computedKey) { return .disk }
  703|      0|        return .none
  704|      0|    }
  705|       |    
  706|       |    /// Returns whether the file exists in cache for a given `key` and `identifier` combination.
  707|       |    ///
  708|       |    /// - Parameters:
  709|       |    ///   - key: The key used for caching the image.
  710|       |    ///   - identifier: Processor identifier which used for this image. Default is the `identifier` of
  711|       |    ///                 `DefaultImageProcessor.default`.
  712|       |    /// - Returns: A `Bool` which indicates whether a cache could match the given `key` and `identifier` combination.
  713|       |    ///
  714|       |    /// - Note:
  715|       |    /// The return value does not contain information about from which kind of storage the cache matches.
  716|       |    /// To get the information about cache type according `CacheType`,
  717|       |    /// use `imageCachedType(forKey:processorIdentifier:)` instead.
  718|       |    public func isCached(
  719|       |        forKey key: String,
  720|       |        processorIdentifier identifier: String = DefaultImageProcessor.default.identifier) -> Bool
  721|      0|    {
  722|      0|        return imageCachedType(forKey: key, processorIdentifier: identifier).cached
  723|      0|    }
  724|       |    
  725|       |    /// Gets the hash used as cache file name for the key.
  726|       |    ///
  727|       |    /// - Parameters:
  728|       |    ///   - key: The key used for caching the image.
  729|       |    ///   - identifier: Processor identifier which used for this image. Default is the `identifier` of
  730|       |    ///                 `DefaultImageProcessor.default`.
  731|       |    /// - Returns: The hash which is used as the cache file name.
  732|       |    ///
  733|       |    /// - Note:
  734|       |    /// By default, for a given combination of `key` and `identifier`, `ImageCache` will use the value
  735|       |    /// returned by this method as the cache file name. You can use this value to check and match cache file
  736|       |    /// if you need.
  737|       |    open func hash(
  738|       |        forKey key: String,
  739|       |        processorIdentifier identifier: String = DefaultImageProcessor.default.identifier) -> String
  740|      0|    {
  741|      0|        let computedKey = key.computedKey(with: identifier)
  742|      0|        return diskStorage.cacheFileName(forKey: computedKey)
  743|      0|    }
  744|       |    
  745|       |    /// Calculates the size taken by the disk storage.
  746|       |    /// It is the total file size of all cached files in the `diskStorage` on disk in bytes.
  747|       |    ///
  748|       |    /// - Parameter handler: Called with the size calculating finishes. This closure is invoked from the main queue.
  749|      0|    open func calculateDiskStorageSize(completion handler: @escaping ((Result<UInt, KingfisherError>) -> Void)) {
  750|      0|        ioQueue.async {
  751|      0|            do {
  752|      0|                let size = try self.diskStorage.totalSize()
  753|      0|                DispatchQueue.main.async { handler(.success(size)) }
  754|      0|            } catch {
  755|      0|                if let error = error as? KingfisherError {
  756|      0|                    DispatchQueue.main.async { handler(.failure(error)) }
  757|      0|                } else {
  758|      0|                    assertionFailure("The internal thrown error should be a `KingfisherError`.")
  759|      0|                }
  760|      0|                
  761|      0|            }
  762|      0|        }
  763|      0|    }
  764|       |    
  765|       |    /// Gets the cache path for the key.
  766|       |    /// It is useful for projects with web view or anyone that needs access to the local file path.
  767|       |    ///
  768|       |    /// i.e. Replacing the `<img src='path_for_key'>` tag in your HTML.
  769|       |    ///
  770|       |    /// - Parameters:
  771|       |    ///   - key: The key used for caching the image.
  772|       |    ///   - identifier: Processor identifier which used for this image. Default is the `identifier` of
  773|       |    ///                 `DefaultImageProcessor.default`.
  774|       |    /// - Returns: The disk path of cached image under the given `key` and `identifier`.
  775|       |    ///
  776|       |    /// - Note:
  777|       |    /// This method does not guarantee there is an image already cached in the returned path. It just gives your
  778|       |    /// the path that the image should be, if it exists in disk storage.
  779|       |    ///
  780|       |    /// You could use `isCached(forKey:)` method to check whether the image is cached under that key in disk.
  781|       |    open func cachePath(
  782|       |        forKey key: String,
  783|       |        processorIdentifier identifier: String = DefaultImageProcessor.default.identifier) -> String
  784|      0|    {
  785|      0|        let computedKey = key.computedKey(with: identifier)
  786|      0|        return diskStorage.cacheFileURL(forKey: computedKey).path
  787|      0|    }
  788|       |}
  789|       |
  790|       |extension Dictionary {
  791|      0|    func keysSortedByValue(_ isOrderedBefore: (Value, Value) -> Bool) -> [Key] {
  792|      0|        return Array(self).sorted{ isOrderedBefore($0.1, $1.1) }.map{ $0.0 }
  793|      0|    }
  794|       |}
  795|       |
  796|       |#if !os(macOS) && !os(watchOS)
  797|       |// MARK: - For App Extensions
  798|       |extension UIApplication: KingfisherCompatible { }
  799|       |extension KingfisherWrapper where Base: UIApplication {
  800|      0|    public static var shared: UIApplication? {
  801|      0|        let selector = NSSelectorFromString("sharedApplication")
  802|      0|        guard Base.responds(to: selector) else { return nil }
  803|      0|        return Base.perform(selector).takeUnretainedValue() as? UIApplication
  804|      0|    }
  805|       |}
  806|       |#endif
  807|       |
  808|       |extension String {
  809|      0|    func computedKey(with identifier: String) -> String {
  810|      0|        if identifier.isEmpty {
  811|      0|            return self
  812|      0|        } else {
  813|      0|            return appending("@\(identifier)")
  814|      0|        }
  815|      0|    }
  816|       |}
  817|       |
  818|       |extension ImageCache {
  819|       |
  820|       |    /// Creates an `ImageCache` with a given `name`, cache directory `path`
  821|       |    /// and a closure to modify the cache directory.
  822|       |    ///
  823|       |    /// - Parameters:
  824|       |    ///   - name: The name of cache object. It is used to setup disk cache directories and IO queue.
  825|       |    ///           You should not use the same `name` for different caches, otherwise, the disk storage would
  826|       |    ///           be conflicting to each other.
  827|       |    ///   - path: Location of cache URL on disk. It will be internally pass to the initializer of `DiskStorage` as the
  828|       |    ///           disk cache directory.
  829|       |    ///   - diskCachePathClosure: Closure that takes in an optional initial path string and generates
  830|       |    ///                           the final disk cache path. You could use it to fully customize your cache path.
  831|       |    /// - Throws: An error that happens during image cache creating, such as unable to create a directory at the given
  832|       |    ///           path.
  833|       |    @available(*, deprecated, message: "Use `init(name:cacheDirectoryURL:diskCachePathClosure:)` instead",
  834|       |    renamed: "init(name:cacheDirectoryURL:diskCachePathClosure:)")
  835|       |    public convenience init(
  836|       |        name: String,
  837|       |        path: String?,
  838|       |        diskCachePathClosure: DiskCachePathClosure? = nil) throws
  839|      0|    {
  840|      0|        let directoryURL = path.flatMap { URL(string: $0) }
  841|      0|        try self.init(name: name, cacheDirectoryURL: directoryURL, diskCachePathClosure: diskCachePathClosure)
  842|      0|    }
  843|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Cache/MemoryStorage.swift:
    1|       |//
    2|       |//  MemoryStorage.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/10/15.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents a set of conception related to storage which stores a certain type of value in memory.
   30|       |/// This is a namespace for the memory storage types. A `Backend` with a certain `Config` will be used to describe the
   31|       |/// storage. See these composed types for more information.
   32|       |public enum MemoryStorage {
   33|       |
   34|       |    /// Represents a storage which stores a certain type of value in memory. It provides fast access,
   35|       |    /// but limited storing size. The stored value type needs to conform to `CacheCostCalculable`,
   36|       |    /// and its `cacheCost` will be used to determine the cost of size for the cache item.
   37|       |    ///
   38|       |    /// You can config a `MemoryStorage.Backend` in its initializer by passing a `MemoryStorage.Config` value.
   39|       |    /// or modifying the `config` property after it being created. The backend of `MemoryStorage` has
   40|       |    /// upper limitation on cost size in memory and item count. All items in the storage has an expiration
   41|       |    /// date. When retrieved, if the target item is already expired, it will be recognized as it does not
   42|       |    /// exist in the storage. The `MemoryStorage` also contains a scheduled self clean task, to evict expired
   43|       |    /// items from memory.
   44|       |    public class Backend<T: CacheCostCalculable> {
   45|       |        let storage = NSCache<NSString, StorageObject<T>>()
   46|       |        var keys = Set<String>()
   47|       |
   48|       |        var cleanTimer: Timer? = nil
   49|       |        let lock = NSLock()
   50|       |
   51|       |        let cacheDelegate = CacheDelegate<StorageObject<T>>()
   52|       |
   53|       |        /// The config used in this storage. It is a value you can set and
   54|       |        /// use to config the storage in air.
   55|       |        public var config: Config {
   56|      0|            didSet {
   57|      0|                storage.totalCostLimit = config.totalCostLimit
   58|      0|                storage.countLimit = config.countLimit
   59|      0|            }
   60|       |        }
   61|       |
   62|       |        /// Creates a `MemoryStorage` with a given `config`.
   63|       |        ///
   64|       |        /// - Parameter config: The config used to create the storage. It determines the max size limitation,
   65|       |        ///                     default expiration setting and more.
   66|      0|        public init(config: Config) {
   67|      0|            self.config = config
   68|      0|            storage.totalCostLimit = config.totalCostLimit
   69|      0|            storage.countLimit = config.countLimit
   70|      0|            storage.delegate = cacheDelegate
   71|      0|            cacheDelegate.onObjectRemoved.delegate(on: self) { (self, obj) in
   72|      0|                self.keys.remove(obj.key)
   73|      0|            }
   74|      0|
   75|      0|            cleanTimer = .scheduledTimer(withTimeInterval: config.cleanInterval, repeats: true) { [weak self] _ in
   76|      0|                guard let self = self else { return }
   77|      0|                self.removeExpired()
   78|      0|            }
   79|      0|        }
   80|       |
   81|      0|        func removeExpired() {
   82|      0|            lock.lock()
   83|      0|            defer { lock.unlock() }
   84|      0|            for key in keys {
   85|      0|                let nsKey = key as NSString
   86|      0|                guard let object = storage.object(forKey: nsKey) else {
   87|      0|                    keys.remove(key)
   88|      0|                    continue
   89|      0|                }
   90|      0|                if object.estimatedExpiration.isPast {
   91|      0|                    storage.removeObject(forKey: nsKey)
   92|      0|                    keys.remove(key)
   93|      0|                }
   94|      0|            }
   95|      0|        }
   96|       |
   97|       |        // Storing in memory will not throw. It is just for meeting protocol requirement and
   98|       |        // forwarding to no throwing method.
   99|       |        func store(
  100|       |            value: T,
  101|       |            forKey key: String,
  102|       |            expiration: StorageExpiration? = nil) throws
  103|      0|        {
  104|      0|            storeNoThrow(value: value, forKey: key, expiration: expiration)
  105|      0|        }
  106|       |
  107|       |        // The no throw version for storing value in cache. Kingfisher knows the detail so it
  108|       |        // could use this version to make syntax simpler internally.
  109|       |        func storeNoThrow(
  110|       |            value: T,
  111|       |            forKey key: String,
  112|       |            expiration: StorageExpiration? = nil)
  113|      0|        {
  114|      0|            lock.lock()
  115|      0|            defer { lock.unlock() }
  116|      0|            let expiration = expiration ?? config.expiration
  117|      0|            // The expiration indicates that already expired, no need to store.
  118|      0|            guard !expiration.isExpired else { return }
  119|      0|            
  120|      0|            let object = StorageObject(value, key: key, expiration: expiration)
  121|      0|            storage.setObject(object, forKey: key as NSString, cost: value.cacheCost)
  122|      0|            keys.insert(key)
  123|      0|        }
  124|       |
  125|       |        // Use this when you actually access the memory cached item.
  126|       |        // This will extend the expired data for the accessed item.
  127|      0|        func value(forKey key: String) throws -> T? {
  128|      0|            return value(forKey: key, extendingExpiration: true)
  129|      0|        }
  130|       |
  131|      0|        func value(forKey key: String, extendingExpiration: Bool) -> T? {
  132|      0|            guard let object = storage.object(forKey: key as NSString) else {
  133|      0|                return nil
  134|      0|            }
  135|      0|            if object.expired {
  136|      0|                return nil
  137|      0|            }
  138|      0|            if extendingExpiration { object.extendExpiration() }
  139|      0|            return object.value
  140|      0|        }
  141|       |
  142|      0|        func isCached(forKey key: String) -> Bool {
  143|      0|            guard let _ = value(forKey: key, extendingExpiration: false) else {
  144|      0|                return false
  145|      0|            }
  146|      0|            return true
  147|      0|        }
  148|       |
  149|      0|        func remove(forKey key: String) throws {
  150|      0|            lock.lock()
  151|      0|            defer { lock.unlock() }
  152|      0|            storage.removeObject(forKey: key as NSString)
  153|      0|            keys.remove(key)
  154|      0|        }
  155|       |
  156|      0|        func removeAll() throws {
  157|      0|            lock.lock()
  158|      0|            defer { lock.unlock() }
  159|      0|            storage.removeAllObjects()
  160|      0|            keys.removeAll()
  161|      0|        }
  162|       |
  163|       |        class CacheDelegate<T>: NSObject, NSCacheDelegate {
  164|       |            let onObjectRemoved = Delegate<T, Void>()
  165|      0|            func cache(_ cache: NSCache<AnyObject, AnyObject>, willEvictObject obj: Any) {
  166|      0|                if let obj = obj as? T {
  167|      0|                    onObjectRemoved.call(obj)
  168|      0|                }
  169|      0|            }
  170|       |        }
  171|       |    }
  172|       |}
  173|       |
  174|       |extension MemoryStorage {
  175|       |    /// Represents the config used in a `MemoryStorage`.
  176|       |    public struct Config {
  177|       |
  178|       |        /// Total cost limit of the storage in bytes.
  179|       |        public var totalCostLimit: Int
  180|       |
  181|       |        /// The item count limit of the memory storage.
  182|       |        public var countLimit: Int = .max
  183|       |
  184|       |        /// The `StorageExpiration` used in this memory storage. Default is `.seconds(300)`,
  185|       |        /// means that the memory cache would expire in 5 minutes.
  186|       |        public var expiration: StorageExpiration = .seconds(300)
  187|       |
  188|       |        /// The time interval between the storage do clean work for swiping expired items.
  189|       |        public let cleanInterval: TimeInterval
  190|       |
  191|       |        /// Creates a config from a given `totalCostLimit` value.
  192|       |        ///
  193|       |        /// - Parameters:
  194|       |        ///   - totalCostLimit: Total cost limit of the storage in bytes.
  195|       |        ///   - cleanInterval: The time interval between the storage do clean work for swiping expired items.
  196|       |        ///                    Default is 120, means the auto eviction happens once per two minutes.
  197|       |        ///
  198|       |        /// - Note:
  199|       |        /// Other members of `MemoryStorage.Config` will use their default values when created.
  200|      0|        public init(totalCostLimit: Int, cleanInterval: TimeInterval = 120) {
  201|      0|            self.totalCostLimit = totalCostLimit
  202|      0|            self.cleanInterval = cleanInterval
  203|      0|        }
  204|       |    }
  205|       |}
  206|       |
  207|       |extension MemoryStorage {
  208|       |    class StorageObject<T> {
  209|       |        let value: T
  210|       |        let expiration: StorageExpiration
  211|       |        let key: String
  212|       |        
  213|       |        private(set) var estimatedExpiration: Date
  214|       |        
  215|      0|        init(_ value: T, key: String, expiration: StorageExpiration) {
  216|      0|            self.value = value
  217|      0|            self.key = key
  218|      0|            self.expiration = expiration
  219|      0|            
  220|      0|            self.estimatedExpiration = expiration.estimatedExpirationSinceNow
  221|      0|        }
  222|       |        
  223|      0|        func extendExpiration() {
  224|      0|            self.estimatedExpiration = expiration.estimatedExpirationSinceNow
  225|      0|        }
  226|       |        
  227|      0|        var expired: Bool {
  228|      0|            return estimatedExpiration.isPast
  229|      0|        }
  230|       |    }
  231|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Cache/Storage.swift:
    1|       |//
    2|       |//  Storage.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/10/15.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents the expiration strategy used in storage.
   30|       |///
   31|       |/// - never: The item never expires.
   32|       |/// - seconds: The item expires after a time duration of given seconds from now.
   33|       |/// - days: The item expires after a time duration of given days from now.
   34|       |/// - date: The item expires after a given date.
   35|       |public enum StorageExpiration {
   36|       |    /// The item never expires.
   37|       |    case never
   38|       |    /// The item expires after a time duration of given seconds from now.
   39|       |    case seconds(TimeInterval)
   40|       |    /// The item expires after a time duration of given days from now.
   41|       |    case days(Int)
   42|       |    /// The item expires after a given date.
   43|       |    case date(Date)
   44|       |    /// Indicates the item is already expired. Use this to skip cache.
   45|       |    case expired
   46|       |
   47|      0|    func estimatedExpirationSince(_ date: Date) -> Date {
   48|      0|        switch self {
   49|      0|        case .never: return .distantFuture
   50|      0|        case .seconds(let seconds): return date.addingTimeInterval(seconds)
   51|      0|        case .days(let days): return date.addingTimeInterval(TimeInterval(60 * 60 * 24 * days))
   52|      0|        case .date(let ref): return ref
   53|      0|        case .expired: return .distantPast
   54|      0|        }
   55|      0|    }
   56|       |    
   57|      0|    var estimatedExpirationSinceNow: Date {
   58|      0|        return estimatedExpirationSince(Date())
   59|      0|    }
   60|       |    
   61|      0|    var isExpired: Bool {
   62|      0|        return timeInterval <= 0
   63|      0|    }
   64|       |
   65|      0|    var timeInterval: TimeInterval {
   66|      0|        switch self {
   67|      0|        case .never: return .infinity
   68|      0|        case .seconds(let seconds): return seconds
   69|      0|        case .days(let days): return TimeInterval(60 * 60 * 24 * days)
   70|      0|        case .date(let ref): return ref.timeIntervalSinceNow
   71|      0|        case .expired: return -(.infinity)
   72|      0|        }
   73|      0|    }
   74|       |}
   75|       |
   76|       |/// Represents types which cost in memory can be calculated.
   77|       |public protocol CacheCostCalculable {
   78|       |    var cacheCost: Int { get }
   79|       |}
   80|       |
   81|       |/// Represents types which can be converted to and from data.
   82|       |public protocol DataTransformable {
   83|       |    func toData() throws -> Data
   84|       |    static func fromData(_ data: Data) throws -> Self
   85|       |    static var empty: Self { get }
   86|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Extensions/ImageView+Kingfisher.swift:
    1|       |//
    2|       |//  ImageView+Kingfisher.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |
   28|       |#if os(macOS)
   29|       |import AppKit
   30|       |#else
   31|       |import UIKit
   32|       |#endif
   33|       |
   34|       |extension KingfisherWrapper where Base: ImageView {
   35|       |
   36|       |    // MARK: Setting Image
   37|       |
   38|       |    /// Sets an image to the image view with a `Source`.
   39|       |    ///
   40|       |    /// - Parameters:
   41|       |    ///   - source: The `Source` object defines data information from network or a data provider.
   42|       |    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
   43|       |    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
   44|       |    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
   45|       |    ///                    `expectedContentLength`, this block will not be called.
   46|       |    ///   - completionHandler: Called when the image retrieved and set finished.
   47|       |    /// - Returns: A task represents the image downloading.
   48|       |    ///
   49|       |    /// - Note:
   50|       |    /// This is the easiest way to use Kingfisher to boost the image setting process from a source. Since all parameters
   51|       |    /// have a default value except the `source`, you can set an image from a certain URL to an image view like this:
   52|       |    ///
   53|       |    /// ```
   54|       |    /// // Set image from a network source.
   55|       |    /// let url = URL(string: "https://example.com/image.png")!
   56|       |    /// imageView.kf.setImage(with: .network(url))
   57|       |    ///
   58|       |    /// // Or set image from a data provider.
   59|       |    /// let provider = LocalFileImageDataProvider(fileURL: fileURL)
   60|       |    /// imageView.kf.setImage(with: .provider(provider))
   61|       |    /// ```
   62|       |    ///
   63|       |    /// For both `.network` and `.provider` source, there are corresponding view extension methods. So the code
   64|       |    /// above is equivalent to:
   65|       |    ///
   66|       |    /// ```
   67|       |    /// imageView.kf.setImage(with: url)
   68|       |    /// imageView.kf.setImage(with: provider)
   69|       |    /// ```
   70|       |    ///
   71|       |    /// Internally, this method will use `KingfisherManager` to get the source.
   72|       |    /// Since this method will perform UI changes, you must call it from the main thread.
   73|       |    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
   74|       |    ///
   75|       |    @discardableResult
   76|       |    public func setImage(
   77|       |        with source: Source?,
   78|       |        placeholder: Placeholder? = nil,
   79|       |        options: KingfisherOptionsInfo? = nil,
   80|       |        progressBlock: DownloadProgressBlock? = nil,
   81|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
   82|      0|    {
   83|      0|        var mutatingSelf = self
   84|      0|        guard let source = source else {
   85|      0|            mutatingSelf.placeholder = placeholder
   86|      0|            mutatingSelf.taskIdentifier = nil
   87|      0|            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
   88|      0|            return nil
   89|      0|        }
   90|      0|
   91|      0|        var options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
   92|      0|        let noImageOrPlaceholderSet = base.image == nil && self.placeholder == nil
   93|      0|        if !options.keepCurrentImageWhileLoading || noImageOrPlaceholderSet {
   94|      0|            // Always set placeholder while there is no image/placeholder yet.
   95|      0|            mutatingSelf.placeholder = placeholder
   96|      0|        }
   97|      0|
   98|      0|        let maybeIndicator = indicator
   99|      0|        maybeIndicator?.startAnimatingView()
  100|      0|
  101|      0|        let issuedIdentifier = Source.Identifier.next()
  102|      0|        mutatingSelf.taskIdentifier = issuedIdentifier
  103|      0|
  104|      0|        if base.shouldPreloadAllAnimation() {
  105|      0|            options.preloadAllAnimationData = true
  106|      0|        }
  107|      0|
  108|      0|        let task = KingfisherManager.shared.retrieveImage(
  109|      0|            with: source,
  110|      0|            options: options,
  111|      0|            progressBlock: { receivedSize, totalSize in
  112|      0|                guard issuedIdentifier == self.taskIdentifier else { return }
  113|      0|                if let progressBlock = progressBlock {
  114|      0|                    progressBlock(receivedSize, totalSize)
  115|      0|                }
  116|      0|            },
  117|      0|            completionHandler: { result in
  118|      0|                CallbackQueue.mainCurrentOrAsync.execute {
  119|      0|                    maybeIndicator?.stopAnimatingView()
  120|      0|                    guard issuedIdentifier == self.taskIdentifier else {
  121|      0|                        let error = KingfisherError.imageSettingError(
  122|      0|                            reason: .notCurrentSourceTask(result: result.value, error: result.error, source: source))
  123|      0|                        completionHandler?(.failure(error))
  124|      0|                        return
  125|      0|                    }
  126|      0|
  127|      0|                    mutatingSelf.imageTask = nil
  128|      0|
  129|      0|                    switch result {
  130|      0|                    case .success(let value):
  131|      0|                        guard self.needsTransition(options: options, cacheType: value.cacheType) else {
  132|      0|                            mutatingSelf.placeholder = nil
  133|      0|                            self.base.image = value.image
  134|      0|                            completionHandler?(result)
  135|      0|                            return
  136|      0|                        }
  137|      0|
  138|      0|                        self.makeTransition(image: value.image, transition: options.transition) {
  139|      0|                            completionHandler?(result)
  140|      0|                        }
  141|      0|                    case .failure:
  142|      0|                        if let image = options.onFailureImage {
  143|      0|                            self.base.image = image
  144|      0|                        }
  145|      0|                        completionHandler?(result)
  146|      0|                    }
  147|      0|                }
  148|      0|        })
  149|      0|
  150|      0|        mutatingSelf.imageTask = task
  151|      0|        return task
  152|      0|    }
  153|       |
  154|       |    /// Sets an image to the image view with a requested resource.
  155|       |    ///
  156|       |    /// - Parameters:
  157|       |    ///   - resource: The `Resource` object contains information about the resource.
  158|       |    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
  159|       |    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
  160|       |    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
  161|       |    ///                    `expectedContentLength`, this block will not be called.
  162|       |    ///   - completionHandler: Called when the image retrieved and set finished.
  163|       |    /// - Returns: A task represents the image downloading.
  164|       |    ///
  165|       |    /// - Note:
  166|       |    /// This is the easiest way to use Kingfisher to boost the image setting process from network. Since all parameters
  167|       |    /// have a default value except the `resource`, you can set an image from a certain URL to an image view like this:
  168|       |    ///
  169|       |    /// ```
  170|       |    /// let url = URL(string: "https://example.com/image.png")!
  171|       |    /// imageView.kf.setImage(with: url)
  172|       |    /// ```
  173|       |    ///
  174|       |    /// Internally, this method will use `KingfisherManager` to get the requested resource, from either cache
  175|       |    /// or network. Since this method will perform UI changes, you must call it from the main thread.
  176|       |    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
  177|       |    ///
  178|       |    @discardableResult
  179|       |    public func setImage(
  180|       |        with resource: Resource?,
  181|       |        placeholder: Placeholder? = nil,
  182|       |        options: KingfisherOptionsInfo? = nil,
  183|       |        progressBlock: DownloadProgressBlock? = nil,
  184|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
  185|      0|    {
  186|      0|        return setImage(
  187|      0|            with: resource.map { .network($0) },
  188|      0|            placeholder: placeholder,
  189|      0|            options: options,
  190|      0|            progressBlock: progressBlock,
  191|      0|            completionHandler: completionHandler)
  192|      0|    }
  193|       |
  194|       |    /// Sets an image to the image view with a data provider.
  195|       |    ///
  196|       |    /// - Parameters:
  197|       |    ///   - provider: The `ImageDataProvider` object contains information about the data.
  198|       |    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
  199|       |    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
  200|       |    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
  201|       |    ///                    `expectedContentLength`, this block will not be called.
  202|       |    ///   - completionHandler: Called when the image retrieved and set finished.
  203|       |    /// - Returns: A task represents the image downloading.
  204|       |    ///
  205|       |    /// Internally, this method will use `KingfisherManager` to get the image data, from either cache
  206|       |    /// or the data provider. Since this method will perform UI changes, you must call it from the main thread.
  207|       |    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
  208|       |    ///
  209|       |    @discardableResult
  210|       |    public func setImage(
  211|       |        with provider: ImageDataProvider?,
  212|       |        placeholder: Placeholder? = nil,
  213|       |        options: KingfisherOptionsInfo? = nil,
  214|       |        progressBlock: DownloadProgressBlock? = nil,
  215|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
  216|      0|    {
  217|      0|        return setImage(
  218|      0|            with: provider.map { .provider($0) },
  219|      0|            placeholder: placeholder,
  220|      0|            options: options,
  221|      0|            progressBlock: progressBlock,
  222|      0|            completionHandler: completionHandler)
  223|      0|    }
  224|       |
  225|       |    // MARK: Cancelling Downloading Task
  226|       |
  227|       |    /// Cancels the image download task of the image view if it is running.
  228|       |    /// Nothing will happen if the downloading has already finished.
  229|      0|    public func cancelDownloadTask() {
  230|      0|        imageTask?.cancel()
  231|      0|    }
  232|       |
  233|      0|    private func needsTransition(options: KingfisherParsedOptionsInfo, cacheType: CacheType) -> Bool {
  234|      0|        switch options.transition {
  235|      0|        case .none:
  236|      0|            return false
  237|      0|        #if !os(macOS)
  238|      0|        default:
  239|      0|            if options.forceTransition { return true }
  240|      0|            if cacheType == .none { return true }
  241|      0|            return false
  242|      0|        #endif
  243|      0|        }
  244|      0|    }
  245|       |
  246|      0|    private func makeTransition(image: Image, transition: ImageTransition, done: @escaping () -> Void) {
  247|      0|        #if !os(macOS)
  248|      0|        // Force hiding the indicator without transition first.
  249|      0|        UIView.transition(
  250|      0|            with: self.base,
  251|      0|            duration: 0.0,
  252|      0|            options: [],
  253|      0|            animations: { self.indicator?.stopAnimatingView() },
  254|      0|            completion: { _ in
  255|      0|                var mutatingSelf = self
  256|      0|                mutatingSelf.placeholder = nil
  257|      0|                UIView.transition(
  258|      0|                    with: self.base,
  259|      0|                    duration: transition.duration,
  260|      0|                    options: [transition.animationOptions, .allowUserInteraction],
  261|      0|                    animations: { transition.animations?(self.base, image) },
  262|      0|                    completion: { finished in
  263|      0|                        transition.completion?(finished)
  264|      0|                        done()
  265|      0|                    }
  266|      0|                )
  267|      0|            }
  268|      0|        )
  269|      0|        #else
  270|      0|        done()
  271|      0|        #endif
  272|      0|    }
  273|       |}
  274|       |
  275|       |// MARK: - Associated Object
  276|       |private var taskIdentifierKey: Void?
  277|       |private var indicatorKey: Void?
  278|       |private var indicatorTypeKey: Void?
  279|       |private var placeholderKey: Void?
  280|       |private var imageTaskKey: Void?
  281|       |
  282|       |extension KingfisherWrapper where Base: ImageView {
  283|       |
  284|       |    // MARK: Properties
  285|       |    public private(set) var taskIdentifier: Source.Identifier.Value? {
  286|      0|        get {
  287|      0|            let box: Box<Source.Identifier.Value>? = getAssociatedObject(base, &taskIdentifierKey)
  288|      0|            return box?.value
  289|      0|        }
  290|      0|        set {
  291|      0|            let box = newValue.map { Box($0) }
  292|      0|            setRetainedAssociatedObject(base, &taskIdentifierKey, box)
  293|      0|        }
  294|       |    }
  295|       |
  296|       |    /// Holds which indicator type is going to be used.
  297|       |    /// Default is `.none`, means no indicator will be shown while downloading.
  298|       |    public var indicatorType: IndicatorType {
  299|      0|        get {
  300|      0|            return getAssociatedObject(base, &indicatorTypeKey) ?? .none
  301|      0|        }
  302|       |        
  303|      0|        set {
  304|      0|            switch newValue {
  305|      0|            case .none: indicator = nil
  306|      0|            case .activity: indicator = ActivityIndicator()
  307|      0|            case .image(let data): indicator = ImageIndicator(imageData: data)
  308|      0|            case .custom(let anIndicator): indicator = anIndicator
  309|      0|            }
  310|      0|
  311|      0|            setRetainedAssociatedObject(base, &indicatorTypeKey, newValue)
  312|      0|        }
  313|       |    }
  314|       |    
  315|       |    /// Holds any type that conforms to the protocol `Indicator`.
  316|       |    /// The protocol `Indicator` has a `view` property that will be shown when loading an image.
  317|       |    /// It will be `nil` if `indicatorType` is `.none`.
  318|       |    public private(set) var indicator: Indicator? {
  319|      0|        get {
  320|      0|            let box: Box<Indicator>? = getAssociatedObject(base, &indicatorKey)
  321|      0|            return box?.value
  322|      0|        }
  323|       |        
  324|      0|        set {
  325|      0|            // Remove previous
  326|      0|            if let previousIndicator = indicator {
  327|      0|                previousIndicator.view.removeFromSuperview()
  328|      0|            }
  329|      0|            
  330|      0|            // Add new
  331|      0|            if let newIndicator = newValue {
  332|      0|                // Set default indicator layout
  333|      0|                let view = newIndicator.view
  334|      0|                
  335|      0|                base.addSubview(view)
  336|      0|                view.translatesAutoresizingMaskIntoConstraints = false
  337|      0|                view.centerXAnchor.constraint(
  338|      0|                    equalTo: base.centerXAnchor, constant: newIndicator.centerOffset.x).isActive = true
  339|      0|                view.centerYAnchor.constraint(
  340|      0|                    equalTo: base.centerYAnchor, constant: newIndicator.centerOffset.y).isActive = true
  341|      0|                
  342|      0|                newIndicator.view.isHidden = true
  343|      0|            }
  344|      0|
  345|      0|            // Save in associated object
  346|      0|            // Wrap newValue with Box to workaround an issue that Swift does not recognize
  347|      0|            // and casting protocol for associate object correctly. https://github.com/onevcat/Kingfisher/issues/872
  348|      0|            setRetainedAssociatedObject(base, &indicatorKey, newValue.map(Box.init))
  349|      0|        }
  350|       |    }
  351|       |    
  352|       |    private var imageTask: DownloadTask? {
  353|      0|        get { return getAssociatedObject(base, &imageTaskKey) }
  354|      0|        set { setRetainedAssociatedObject(base, &imageTaskKey, newValue)}
  355|       |    }
  356|       |
  357|       |    /// Represents the `Placeholder` used for this image view. A `Placeholder` will be shown in the view while
  358|       |    /// it is downloading an image.
  359|       |    public private(set) var placeholder: Placeholder? {
  360|      0|        get { return getAssociatedObject(base, &placeholderKey) }
  361|      0|        set {
  362|      0|            if let previousPlaceholder = placeholder {
  363|      0|                previousPlaceholder.remove(from: base)
  364|      0|            }
  365|      0|            
  366|      0|            if let newPlaceholder = newValue {
  367|      0|                newPlaceholder.add(to: base)
  368|      0|            } else {
  369|      0|                base.image = nil
  370|      0|            }
  371|      0|            setRetainedAssociatedObject(base, &placeholderKey, newValue)
  372|      0|        }
  373|       |    }
  374|       |}
  375|       |
  376|       |
  377|       |@objc extension ImageView {
  378|      0|    func shouldPreloadAllAnimation() -> Bool { return true }
  379|       |}
  380|       |
  381|       |extension KingfisherWrapper where Base: ImageView {
  382|       |    /// Gets the image URL bound to this image view.
  383|       |    @available(*, obsoleted: 5.0, message: "Use `taskIdentifier` instead to identify a setting task.")
  384|       |    public private(set) var webURL: URL? {
  385|      0|        get { return nil }
  386|      0|        set { }
  387|       |    }
  388|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Extensions/UIButton+Kingfisher.swift:
    1|       |//
    2|       |//  UIButton+Kingfisher.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/13.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import UIKit
   28|       |
   29|       |extension KingfisherWrapper where Base: UIButton {
   30|       |
   31|       |    // MARK: Setting Image
   32|       |    /// Sets an image to the button for a specified state with a source.
   33|       |    ///
   34|       |    /// - Parameters:
   35|       |    ///   - source: The `Source` object contains information about the image.
   36|       |    ///   - state: The button state to which the image should be set.
   37|       |    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
   38|       |    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
   39|       |    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
   40|       |    ///                    `expectedContentLength`, this block will not be called.
   41|       |    ///   - completionHandler: Called when the image retrieved and set finished.
   42|       |    /// - Returns: A task represents the image downloading.
   43|       |    ///
   44|       |    /// - Note:
   45|       |    /// Internally, this method will use `KingfisherManager` to get the requested source, from either cache
   46|       |    /// or network. Since this method will perform UI changes, you must call it from the main thread.
   47|       |    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
   48|       |    ///
   49|       |    @discardableResult
   50|       |    public func setImage(
   51|       |        with source: Source?,
   52|       |        for state: UIControl.State,
   53|       |        placeholder: UIImage? = nil,
   54|       |        options: KingfisherOptionsInfo? = nil,
   55|       |        progressBlock: DownloadProgressBlock? = nil,
   56|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
   57|      0|    {
   58|      0|        guard let source = source else {
   59|      0|            base.setImage(placeholder, for: state)
   60|      0|            setTaskIdentifier(nil, for: state)
   61|      0|            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
   62|      0|            return nil
   63|      0|        }
   64|      0|        
   65|      0|        let options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
   66|      0|        if !options.keepCurrentImageWhileLoading {
   67|      0|            base.setImage(placeholder, for: state)
   68|      0|        }
   69|      0|        
   70|      0|        var mutatingSelf = self
   71|      0|        let issuedTaskIdentifier = Source.Identifier.next()
   72|      0|        setTaskIdentifier(issuedTaskIdentifier, for: state)
   73|      0|        let task = KingfisherManager.shared.retrieveImage(
   74|      0|            with: source,
   75|      0|            options: options,
   76|      0|            progressBlock: { receivedSize, totalSize in
   77|      0|                guard issuedTaskIdentifier == self.taskIdentifier(for: state) else { return }
   78|      0|                progressBlock?(receivedSize, totalSize)
   79|      0|            },
   80|      0|            completionHandler: { result in
   81|      0|                CallbackQueue.mainCurrentOrAsync.execute {
   82|      0|                    guard issuedTaskIdentifier == self.taskIdentifier(for: state) else {
   83|      0|                        let error = KingfisherError.imageSettingError(
   84|      0|                            reason: .notCurrentSourceTask(result: result.value, error: result.error, source: source))
   85|      0|                        completionHandler?(.failure(error))
   86|      0|                        return
   87|      0|                    }
   88|      0|                    
   89|      0|                    mutatingSelf.imageTask = nil
   90|      0|                    
   91|      0|                    switch result {
   92|      0|                    case .success(let value):
   93|      0|                        self.base.setImage(value.image, for: state)
   94|      0|                        completionHandler?(result)
   95|      0|                    case .failure:
   96|      0|                        if let image = options.onFailureImage {
   97|      0|                            self.base.setImage(image, for: state)
   98|      0|                        }
   99|      0|                        completionHandler?(result)
  100|      0|                    }
  101|      0|                }
  102|      0|        })
  103|      0|        
  104|      0|        mutatingSelf.imageTask = task
  105|      0|        return task
  106|      0|    }
  107|       |    
  108|       |    /// Sets an image to the button for a specified state with a requested resource.
  109|       |    ///
  110|       |    /// - Parameters:
  111|       |    ///   - resource: The `Resource` object contains information about the resource.
  112|       |    ///   - state: The button state to which the image should be set.
  113|       |    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
  114|       |    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
  115|       |    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
  116|       |    ///                    `expectedContentLength`, this block will not be called.
  117|       |    ///   - completionHandler: Called when the image retrieved and set finished.
  118|       |    /// - Returns: A task represents the image downloading.
  119|       |    ///
  120|       |    /// - Note:
  121|       |    /// Internally, this method will use `KingfisherManager` to get the requested resource, from either cache
  122|       |    /// or network. Since this method will perform UI changes, you must call it from the main thread.
  123|       |    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
  124|       |    ///
  125|       |    @discardableResult
  126|       |    public func setImage(
  127|       |        with resource: Resource?,
  128|       |        for state: UIControl.State,
  129|       |        placeholder: UIImage? = nil,
  130|       |        options: KingfisherOptionsInfo? = nil,
  131|       |        progressBlock: DownloadProgressBlock? = nil,
  132|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
  133|      0|    {
  134|      0|        return setImage(
  135|      0|            with: resource.map { Source.network($0) },
  136|      0|            for: state,
  137|      0|            placeholder: placeholder,
  138|      0|            options: options,
  139|      0|            progressBlock: progressBlock,
  140|      0|            completionHandler: completionHandler)
  141|      0|    }
  142|       |
  143|       |    // MARK: Cancelling Downloading Task
  144|       |    
  145|       |    /// Cancels the image download task of the button if it is running.
  146|       |    /// Nothing will happen if the downloading has already finished.
  147|      0|    public func cancelImageDownloadTask() {
  148|      0|        imageTask?.cancel()
  149|      0|    }
  150|       |
  151|       |    // MARK: Setting Background Image
  152|       |
  153|       |    /// Sets a background image to the button for a specified state with a source.
  154|       |    ///
  155|       |    /// - Parameters:
  156|       |    ///   - source: The `Source` object contains information about the image.
  157|       |    ///   - state: The button state to which the image should be set.
  158|       |    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
  159|       |    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
  160|       |    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
  161|       |    ///                    `expectedContentLength`, this block will not be called.
  162|       |    ///   - completionHandler: Called when the image retrieved and set finished.
  163|       |    /// - Returns: A task represents the image downloading.
  164|       |    ///
  165|       |    /// - Note:
  166|       |    /// Internally, this method will use `KingfisherManager` to get the requested source
  167|       |    /// Since this method will perform UI changes, you must call it from the main thread.
  168|       |    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
  169|       |    ///
  170|       |    @discardableResult
  171|       |    public func setBackgroundImage(
  172|       |        with source: Source?,
  173|       |        for state: UIControl.State,
  174|       |        placeholder: UIImage? = nil,
  175|       |        options: KingfisherOptionsInfo? = nil,
  176|       |        progressBlock: DownloadProgressBlock? = nil,
  177|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
  178|      0|    {
  179|      0|        guard let source = source else {
  180|      0|            base.setBackgroundImage(placeholder, for: state)
  181|      0|            setBackgroundTaskIdentifier(nil, for: state)
  182|      0|            completionHandler?(.failure(KingfisherError.imageSettingError(reason: .emptySource)))
  183|      0|            return nil
  184|      0|        }
  185|      0|
  186|      0|        let options = KingfisherParsedOptionsInfo(KingfisherManager.shared.defaultOptions + (options ?? .empty))
  187|      0|        if !options.keepCurrentImageWhileLoading {
  188|      0|            base.setBackgroundImage(placeholder, for: state)
  189|      0|        }
  190|      0|        
  191|      0|        var mutatingSelf = self
  192|      0|        let issuedTaskIdentifier = Source.Identifier.next()
  193|      0|        setBackgroundTaskIdentifier(issuedTaskIdentifier, for: state)
  194|      0|        let task = KingfisherManager.shared.retrieveImage(
  195|      0|            with: source,
  196|      0|            options: options,
  197|      0|            progressBlock: { receivedSize, totalSize in
  198|      0|                guard issuedTaskIdentifier == self.backgroundTaskIdentifier(for: state) else {
  199|      0|                    return
  200|      0|                }
  201|      0|                if let progressBlock = progressBlock {
  202|      0|                    progressBlock(receivedSize, totalSize)
  203|      0|                }
  204|      0|            },
  205|      0|            completionHandler: { result in
  206|      0|                CallbackQueue.mainCurrentOrAsync.execute {
  207|      0|                    guard issuedTaskIdentifier == self.backgroundTaskIdentifier(for: state) else {
  208|      0|                        let error = KingfisherError.imageSettingError(
  209|      0|                            reason: .notCurrentSourceTask(result: result.value, error: result.error, source: source))
  210|      0|                        completionHandler?(.failure(error))
  211|      0|                        return
  212|      0|                    }
  213|      0|                    mutatingSelf.backgroundImageTask = nil
  214|      0|
  215|      0|                    switch result {
  216|      0|                    case .success(let value):
  217|      0|                        self.base.setBackgroundImage(value.image, for: state)
  218|      0|                        completionHandler?(result)
  219|      0|                    case .failure:
  220|      0|                        if let image = options.onFailureImage {
  221|      0|                            self.base.setBackgroundImage(image, for: state)
  222|      0|                        }
  223|      0|                        completionHandler?(result)
  224|      0|                    }
  225|      0|                }
  226|      0|        })
  227|      0|
  228|      0|        mutatingSelf.backgroundImageTask = task
  229|      0|        return task
  230|      0|    }
  231|       |
  232|       |    /// Sets a background image to the button for a specified state with a requested resource.
  233|       |    ///
  234|       |    /// - Parameters:
  235|       |    ///   - resource: The `Resource` object contains information about the resource.
  236|       |    ///   - state: The button state to which the image should be set.
  237|       |    ///   - placeholder: A placeholder to show while retrieving the image from the given `resource`.
  238|       |    ///   - options: An options set to define image setting behaviors. See `KingfisherOptionsInfo` for more.
  239|       |    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
  240|       |    ///                    `expectedContentLength`, this block will not be called.
  241|       |    ///   - completionHandler: Called when the image retrieved and set finished.
  242|       |    /// - Returns: A task represents the image downloading.
  243|       |    ///
  244|       |    /// - Note:
  245|       |    /// Internally, this method will use `KingfisherManager` to get the requested resource, from either cache
  246|       |    /// or network. Since this method will perform UI changes, you must call it from the main thread.
  247|       |    /// Both `progressBlock` and `completionHandler` will be also executed in the main thread.
  248|       |    ///
  249|       |    @discardableResult
  250|       |    public func setBackgroundImage(
  251|       |        with resource: Resource?,
  252|       |        for state: UIControl.State,
  253|       |        placeholder: UIImage? = nil,
  254|       |        options: KingfisherOptionsInfo? = nil,
  255|       |        progressBlock: DownloadProgressBlock? = nil,
  256|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
  257|      0|    {
  258|      0|        return setBackgroundImage(
  259|      0|            with: resource.map { .network($0) },
  260|      0|            for: state,
  261|      0|            placeholder: placeholder,
  262|      0|            options: options,
  263|      0|            progressBlock: progressBlock,
  264|      0|            completionHandler: completionHandler)
  265|      0|    }
  266|       |
  267|       |    // MARK: Cancelling Background Downloading Task
  268|       |    
  269|       |    /// Cancels the background image download task of the button if it is running.
  270|       |    /// Nothing will happen if the downloading has already finished.
  271|      0|    public func cancelBackgroundImageDownloadTask() {
  272|      0|        backgroundImageTask?.cancel()
  273|      0|    }
  274|       |}
  275|       |
  276|       |// MARK: - Associated Object
  277|       |private var taskIdentifierKey: Void?
  278|       |private var imageTaskKey: Void?
  279|       |
  280|       |// MARK: Properties
  281|       |extension KingfisherWrapper where Base: UIButton {
  282|       |
  283|      0|    public func taskIdentifier(for state: UIControl.State) -> Source.Identifier.Value? {
  284|      0|        return (taskIdentifierInfo[NSNumber(value:state.rawValue)] as? Box<Source.Identifier.Value>)?.value
  285|      0|    }
  286|       |
  287|      0|    private func setTaskIdentifier(_ identifier: Source.Identifier.Value?, for state: UIControl.State) {
  288|      0|        taskIdentifierInfo[NSNumber(value:state.rawValue)] = identifier.map { Box($0) }
  289|      0|    }
  290|       |    
  291|       |    private var taskIdentifierInfo: NSMutableDictionary {
  292|      0|        get {
  293|      0|            guard let dictionary: NSMutableDictionary = getAssociatedObject(base, &taskIdentifierKey) else {
  294|      0|                let dic = NSMutableDictionary()
  295|      0|                var mutatingSelf = self
  296|      0|                mutatingSelf.taskIdentifierInfo = dic
  297|      0|                return dic
  298|      0|            }
  299|      0|            return dictionary
  300|      0|        }
  301|      0|        set {
  302|      0|            setRetainedAssociatedObject(base, &taskIdentifierKey, newValue)
  303|      0|        }
  304|       |    }
  305|       |    
  306|       |    private var imageTask: DownloadTask? {
  307|      0|        get { return getAssociatedObject(base, &imageTaskKey) }
  308|      0|        set { setRetainedAssociatedObject(base, &imageTaskKey, newValue)}
  309|       |    }
  310|       |}
  311|       |
  312|       |
  313|       |private var backgroundTaskIdentifierKey: Void?
  314|       |private var backgroundImageTaskKey: Void?
  315|       |
  316|       |// MARK: Background Properties
  317|       |extension KingfisherWrapper where Base: UIButton {
  318|       |
  319|      0|    public func backgroundTaskIdentifier(for state: UIControl.State) -> Source.Identifier.Value? {
  320|      0|        return (backgroundTaskIdentifierInfo[NSNumber(value:state.rawValue)] as? Box<Source.Identifier.Value>)?.value
  321|      0|    }
  322|       |    
  323|      0|    private func setBackgroundTaskIdentifier(_ identifier: Source.Identifier.Value?, for state: UIControl.State) {
  324|      0|        backgroundTaskIdentifierInfo[NSNumber(value:state.rawValue)] = identifier.map { Box($0) }
  325|      0|    }
  326|       |    
  327|       |    private var backgroundTaskIdentifierInfo: NSMutableDictionary {
  328|      0|        get {
  329|      0|            guard let dictionary: NSMutableDictionary = getAssociatedObject(base, &backgroundTaskIdentifierKey) else {
  330|      0|                let dic = NSMutableDictionary()
  331|      0|                var mutatingSelf = self
  332|      0|                mutatingSelf.backgroundTaskIdentifierInfo = dic
  333|      0|                return dic
  334|      0|            }
  335|      0|            return dictionary
  336|      0|        }
  337|      0|        set {
  338|      0|            setRetainedAssociatedObject(base, &backgroundTaskIdentifierKey, newValue)
  339|      0|        }
  340|       |    }
  341|       |    
  342|       |    private var backgroundImageTask: DownloadTask? {
  343|      0|        get { return getAssociatedObject(base, &backgroundImageTaskKey) }
  344|      0|        mutating set { setRetainedAssociatedObject(base, &backgroundImageTaskKey, newValue) }
  345|       |    }
  346|       |}
  347|       |
  348|       |extension KingfisherWrapper where Base: UIButton {
  349|       |
  350|       |    /// Gets the image URL of this button for a specified state.
  351|       |    ///
  352|       |    /// - Parameter state: The state that uses the specified image.
  353|       |    /// - Returns: Current URL for image.
  354|       |    @available(*, obsoleted: 5.0, message: "Use `taskIdentifier` instead to identify a setting task.")
  355|      0|    public func webURL(for state: UIControl.State) -> URL? {
  356|      0|        return nil
  357|      0|    }
  358|       |
  359|       |    /// Gets the background image URL of this button for a specified state.
  360|       |    ///
  361|       |    /// - Parameter state: The state that uses the specified background image.
  362|       |    /// - Returns: Current URL for image.
  363|       |    @available(*, obsoleted: 5.0, message: "Use `backgroundTaskIdentifier` instead to identify a setting task.")
  364|      0|    public func backgroundWebURL(for state: UIControl.State) -> URL? {
  365|      0|        return nil
  366|      0|    }
  367|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/General/Deprecated.swift:
    1|       |//
    2|       |//  Deprecated.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/09/28.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if canImport(AppKit)
   28|       |import AppKit
   29|       |#elseif canImport(UIKit)
   30|       |import UIKit
   31|       |#endif
   32|       |
   33|       |// MARK: - Deprecated
   34|       |extension KingfisherWrapper where Base: Image {
   35|       |    @available(*, deprecated, message:
   36|       |    "Will be removed soon. Pass parameters with `ImageCreatingOptions`, use `image(with:options:)` instead.")
   37|       |    public static func image(
   38|       |        data: Data,
   39|       |        scale: CGFloat,
   40|       |        preloadAllAnimationData: Bool,
   41|       |        onlyFirstFrame: Bool) -> Image?
   42|      0|    {
   43|      0|        let options = ImageCreatingOptions(
   44|      0|            scale: scale,
   45|      0|            duration: 0.0,
   46|      0|            preloadAll: preloadAllAnimationData,
   47|      0|            onlyFirstFrame: onlyFirstFrame)
   48|      0|        return KingfisherWrapper.image(data: data, options: options)
   49|      0|    }
   50|       |    
   51|       |    @available(*, deprecated, message:
   52|       |    "Will be removed soon. Pass parameters with `ImageCreatingOptions`, use `animatedImage(with:options:)` instead.")
   53|       |    public static func animated(
   54|       |        with data: Data,
   55|       |        scale: CGFloat = 1.0,
   56|       |        duration: TimeInterval = 0.0,
   57|       |        preloadAll: Bool,
   58|       |        onlyFirstFrame: Bool = false) -> Image?
   59|      0|    {
   60|      0|        let options = ImageCreatingOptions(
   61|      0|            scale: scale, duration: duration, preloadAll: preloadAll, onlyFirstFrame: onlyFirstFrame)
   62|      0|        return animatedImage(data: data, options: options)
   63|      0|    }
   64|       |}
   65|       |
   66|       |@available(*, deprecated, message: "Will be removed soon. Use `Result<RetrieveImageResult>` based callback instead")
   67|       |public typealias CompletionHandler =
   68|       |    ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -> Void)
   69|       |
   70|       |@available(*, deprecated, message: "Will be removed soon. Use `Result<ImageLoadingResult>` based callback instead")
   71|       |public typealias ImageDownloaderCompletionHandler =
   72|       |    ((_ image: Image?, _ error: NSError?, _ url: URL?, _ originalData: Data?) -> Void)
   73|       |
   74|       |// MARK: - Deprecated
   75|       |@available(*, deprecated, message: "Will be removed soon. Use `DownloadTask` to cancel a task.")
   76|       |extension RetrieveImageTask {
   77|       |    @available(*, deprecated, message: "RetrieveImageTask.empty will be removed soon. Use `nil` to represent a no task.")
   78|       |    public static let empty = RetrieveImageTask()
   79|       |}
   80|       |
   81|       |// MARK: - Deprecated
   82|       |extension KingfisherManager {
   83|       |    /// Get an image with resource.
   84|       |    /// If `.empty` is used as `options`, Kingfisher will seek the image in memory and disk first.
   85|       |    /// If not found, it will download the image at `resource.downloadURL` and cache it with `resource.cacheKey`.
   86|       |    /// These default behaviors could be adjusted by passing different options. See `KingfisherOptions` for more.
   87|       |    ///
   88|       |    /// - Parameters:
   89|       |    ///   - resource: Resource object contains information such as `cacheKey` and `downloadURL`.
   90|       |    ///   - options: A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
   91|       |    ///   - progressBlock: Called every time downloaded data changed. This could be used as a progress UI.
   92|       |    ///   - completionHandler: Called when the whole retrieving process finished.
   93|       |    /// - Returns: A `RetrieveImageTask` task object. You can use this object to cancel the task.
   94|       |    @available(*, deprecated, message: "Use `Result` based callback instead.")
   95|       |    @discardableResult
   96|       |    public func retrieveImage(with resource: Resource,
   97|       |                              options: KingfisherOptionsInfo?,
   98|       |                              progressBlock: DownloadProgressBlock?,
   99|       |                              completionHandler: CompletionHandler?) -> DownloadTask?
  100|      0|    {
  101|      0|        return retrieveImage(with: resource, options: options, progressBlock: progressBlock) {
  102|      0|            result in
  103|      0|            switch result {
  104|      0|            case .success(let value): completionHandler?(value.image, nil, value.cacheType, value.source.url)
  105|      0|            case .failure(let error): completionHandler?(nil, error as NSError, .none, resource.downloadURL)
  106|      0|            }
  107|      0|        }
  108|      0|    }
  109|       |}
  110|       |
  111|       |// MARK: - Deprecated
  112|       |extension ImageDownloader {
  113|       |    @available(*, deprecated, message: "Use `Result` based callback instead.")
  114|       |    @discardableResult
  115|       |    open func downloadImage(with url: URL,
  116|       |                            retrieveImageTask: RetrieveImageTask? = nil,
  117|       |                            options: KingfisherOptionsInfo? = nil,
  118|       |                            progressBlock: ImageDownloaderProgressBlock? = nil,
  119|       |                            completionHandler: ImageDownloaderCompletionHandler?) -> DownloadTask?
  120|      0|    {
  121|      0|        return downloadImage(with: url, options: options, progressBlock: progressBlock) {
  122|      0|            result in
  123|      0|            switch result {
  124|      0|            case .success(let value): completionHandler?(value.image, nil, value.url, value.originalData)
  125|      0|            case .failure(let error): completionHandler?(nil, error as NSError, nil, nil)
  126|      0|            }
  127|      0|        }
  128|      0|    }
  129|       |}
  130|       |
  131|       |@available(*, deprecated, message: "RetrieveImageDownloadTask is removed. Use `DownloadTask` to cancel a task.")
  132|       |public struct RetrieveImageDownloadTask {
  133|       |}
  134|       |
  135|       |@available(*, deprecated, message: "RetrieveImageTask is removed. Use `DownloadTask` to cancel a task.")
  136|       |public final class RetrieveImageTask {
  137|       |}
  138|       |
  139|       |@available(*, deprecated, message: "Use `DownloadProgressBlock` instead.", renamed: "DownloadProgressBlock")
  140|       |public typealias ImageDownloaderProgressBlock = DownloadProgressBlock
  141|       |
  142|       |#if !os(watchOS)
  143|       |// MARK: - Deprecated
  144|       |extension KingfisherWrapper where Base: ImageView {
  145|       |    @available(*, deprecated, message: "Use `Result` based callback instead.")
  146|       |    @discardableResult
  147|       |    public func setImage(with resource: Resource?,
  148|       |                         placeholder: Placeholder? = nil,
  149|       |                         options: KingfisherOptionsInfo? = nil,
  150|       |                         progressBlock: DownloadProgressBlock? = nil,
  151|       |                         completionHandler: CompletionHandler?) -> DownloadTask?
  152|      0|    {
  153|      0|        return setImage(with: resource, placeholder: placeholder, options: options, progressBlock: progressBlock) {
  154|      0|            result in
  155|      0|            switch result {
  156|      0|            case .success(let value):
  157|      0|                completionHandler?(value.image, nil, value.cacheType, value.source.url)
  158|      0|            case .failure(let error):
  159|      0|                completionHandler?(nil, error as NSError, .none, nil)
  160|      0|            }
  161|      0|        }
  162|      0|    }
  163|       |}
  164|       |#endif
  165|       |
  166|       |#if canImport(UIKit) && !os(watchOS)
  167|       |// MARK: - Deprecated
  168|       |extension KingfisherWrapper where Base: UIButton {
  169|       |    @available(*, deprecated, message: "Use `Result` based callback instead.")
  170|       |    @discardableResult
  171|       |    public func setImage(
  172|       |        with resource: Resource?,
  173|       |        for state: UIControl.State,
  174|       |        placeholder: UIImage? = nil,
  175|       |        options: KingfisherOptionsInfo? = nil,
  176|       |        progressBlock: DownloadProgressBlock? = nil,
  177|       |        completionHandler: CompletionHandler?) -> DownloadTask?
  178|      0|    {
  179|      0|        return setImage(
  180|      0|            with: resource,
  181|      0|            for: state,
  182|      0|            placeholder: placeholder,
  183|      0|            options: options,
  184|      0|            progressBlock: progressBlock)
  185|      0|        {
  186|      0|            result in
  187|      0|            switch result {
  188|      0|            case .success(let value):
  189|      0|                completionHandler?(value.image, nil, value.cacheType, value.source.url)
  190|      0|            case .failure(let error):
  191|      0|                completionHandler?(nil, error as NSError, .none, nil)
  192|      0|            }
  193|      0|        }
  194|      0|    }
  195|       |    
  196|       |    @available(*, deprecated, message: "Use `Result` based callback instead.")
  197|       |    @discardableResult
  198|       |    public func setBackgroundImage(
  199|       |        with resource: Resource?,
  200|       |        for state: UIControl.State,
  201|       |        placeholder: UIImage? = nil,
  202|       |        options: KingfisherOptionsInfo? = nil,
  203|       |        progressBlock: DownloadProgressBlock? = nil,
  204|       |        completionHandler: CompletionHandler?) -> DownloadTask?
  205|      0|    {
  206|      0|        return setBackgroundImage(
  207|      0|            with: resource,
  208|      0|            for: state,
  209|      0|            placeholder: placeholder,
  210|      0|            options: options,
  211|      0|            progressBlock: progressBlock)
  212|      0|        {
  213|      0|            result in
  214|      0|            switch result {
  215|      0|            case .success(let value):
  216|      0|                completionHandler?(value.image, nil, value.cacheType, value.source.url)
  217|      0|            case .failure(let error):
  218|      0|                completionHandler?(nil, error as NSError, .none, nil)
  219|      0|            }
  220|      0|        }
  221|      0|    }
  222|       |}
  223|       |#endif
  224|       |
  225|       |#if os(watchOS)
  226|       |import WatchKit
  227|       |// MARK: - Deprecated
  228|       |extension KingfisherWrapper where Base: WKInterfaceImage {
  229|       |    @available(*, deprecated, message: "Use `Result` based callback instead.")
  230|       |    @discardableResult
  231|       |    public func setImage(_ resource: Resource?,
  232|       |                         placeholder: Image? = nil,
  233|       |                         options: KingfisherOptionsInfo? = nil,
  234|       |                         progressBlock: DownloadProgressBlock? = nil,
  235|       |                         completionHandler: CompletionHandler?) -> DownloadTask?
  236|       |    {
  237|       |        return setImage(
  238|       |            with: resource,
  239|       |            placeholder: placeholder,
  240|       |            options: options,
  241|       |            progressBlock: progressBlock)
  242|       |        {
  243|       |            result in
  244|       |            switch result {
  245|       |            case .success(let value):
  246|       |                completionHandler?(value.image, nil, value.cacheType, value.source.url)
  247|       |            case .failure(let error):
  248|       |                completionHandler?(nil, error as NSError, .none, nil)
  249|       |            }
  250|       |        }
  251|       |    }
  252|       |}
  253|       |#endif
  254|       |
  255|       |#if os(macOS)
  256|       |// MARK: - Deprecated
  257|       |extension KingfisherWrapper where Base: NSButton {
  258|       |    @discardableResult
  259|       |    @available(*, deprecated, message: "Use `Result` based callback instead.")
  260|       |    public func setImage(with resource: Resource?,
  261|       |                         placeholder: Image? = nil,
  262|       |                         options: KingfisherOptionsInfo? = nil,
  263|       |                         progressBlock: DownloadProgressBlock? = nil,
  264|       |                         completionHandler: CompletionHandler?) -> DownloadTask?
  265|       |    {
  266|       |        return setImage(
  267|       |            with: resource,
  268|       |            placeholder: placeholder,
  269|       |            options: options,
  270|       |            progressBlock: progressBlock)
  271|       |        {
  272|       |            result in
  273|       |            switch result {
  274|       |            case .success(let value):
  275|       |                completionHandler?(value.image, nil, value.cacheType, value.source.url)
  276|       |            case .failure(let error):
  277|       |                completionHandler?(nil, error as NSError, .none, nil)
  278|       |            }
  279|       |        }
  280|       |    }
  281|       |    
  282|       |    @discardableResult
  283|       |    @available(*, deprecated, message: "Use `Result` based callback instead.")
  284|       |    public func setAlternateImage(with resource: Resource?,
  285|       |                                  placeholder: Image? = nil,
  286|       |                                  options: KingfisherOptionsInfo? = nil,
  287|       |                                  progressBlock: DownloadProgressBlock? = nil,
  288|       |                                  completionHandler: CompletionHandler?) -> DownloadTask?
  289|       |    {
  290|       |        return setAlternateImage(
  291|       |            with: resource,
  292|       |            placeholder: placeholder,
  293|       |            options: options,
  294|       |            progressBlock: progressBlock)
  295|       |        {
  296|       |            result in
  297|       |            switch result {
  298|       |            case .success(let value):
  299|       |                completionHandler?(value.image, nil, value.cacheType, value.source.url)
  300|       |            case .failure(let error):
  301|       |                completionHandler?(nil, error as NSError, .none, nil)
  302|       |            }
  303|       |        }
  304|       |    }
  305|       |}
  306|       |#endif
  307|       |
  308|       |// MARK: - Deprecated
  309|       |extension ImageCache {
  310|       |    /// The largest cache cost of memory cache. The total cost is pixel count of
  311|       |    /// all cached images in memory.
  312|       |    /// Default is unlimited. Memory cache will be purged automatically when a
  313|       |    /// memory warning notification is received.
  314|       |    @available(*, deprecated, message: "Use `memoryStorage.config.totalCostLimit` instead.",
  315|       |    renamed: "memoryStorage.config.totalCostLimit")
  316|       |    open var maxMemoryCost: Int {
  317|      0|        get { return memoryStorage.config.totalCostLimit }
  318|      0|        set { memoryStorage.config.totalCostLimit = newValue }
  319|       |    }
  320|       |
  321|       |    /// The default DiskCachePathClosure
  322|       |    @available(*, deprecated, message: "Not needed anymore.")
  323|      0|    public final class func defaultDiskCachePathClosure(path: String?, cacheName: String) -> String {
  324|      0|        let dstPath = path ?? NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true).first!
  325|      0|        return (dstPath as NSString).appendingPathComponent(cacheName)
  326|      0|    }
  327|       |
  328|       |    /// The default file extension appended to cached files.
  329|       |    @available(*, deprecated, message: "Use `diskStorage.config.pathExtension` instead.",
  330|       |    renamed: "diskStorage.config.pathExtension")
  331|       |    open var pathExtension: String? {
  332|      0|        get { return diskStorage.config.pathExtension }
  333|      0|        set { diskStorage.config.pathExtension = newValue }
  334|       |    }
  335|       |    
  336|       |    ///The disk cache location.
  337|       |    @available(*, deprecated, message: "Use `diskStorage.directoryURL.absoluteString` instead.",
  338|       |    renamed: "diskStorage.directoryURL.absoluteString")
  339|      0|    public var diskCachePath: String {
  340|      0|        return diskStorage.directoryURL.absoluteString
  341|      0|    }
  342|       |    
  343|       |    /// The largest disk size can be taken for the cache. It is the total
  344|       |    /// allocated size of cached files in bytes.
  345|       |    /// Default is no limit.
  346|       |    @available(*, deprecated, message: "Use `diskStorage.config.sizeLimit` instead.",
  347|       |    renamed: "diskStorage.config.sizeLimit")
  348|       |    open var maxDiskCacheSize: UInt {
  349|      0|        get { return UInt(diskStorage.config.sizeLimit) }
  350|      0|        set { diskStorage.config.sizeLimit = newValue }
  351|       |    }
  352|       |    
  353|       |    @available(*, deprecated, message: "Use `diskStorage.cacheFileURL(forKey:).path` instead.",
  354|       |    renamed: "diskStorage.cacheFileURL(forKey:)")
  355|      0|    open func cachePath(forComputedKey key: String) -> String {
  356|      0|        return diskStorage.cacheFileURL(forKey: key).path
  357|      0|    }
  358|       |    
  359|       |    /**
  360|       |     Get an image for a key from disk.
  361|       |     
  362|       |     - parameter key:     Key for the image.
  363|       |     - parameter options: Options of retrieving image. If you need to retrieve an image which was
  364|       |     stored with a specified `ImageProcessor`, pass the processor in the option too.
  365|       |     
  366|       |     - returns: The image object if it is cached, or `nil` if there is no such key in the cache.
  367|       |     */
  368|       |    @available(*, deprecated,
  369|       |    message: "Use `Result` based `retrieveImageInDiskCache(forKey:options:callbackQueue:completionHandler:)` instead.",
  370|       |    renamed: "retrieveImageInDiskCache(forKey:options:callbackQueue:completionHandler:)")
  371|      0|    open func retrieveImageInDiskCache(forKey key: String, options: KingfisherOptionsInfo? = nil) -> Image? {
  372|      0|        let options = options ?? .empty
  373|      0|        let computedKey = key.computedKey(with: options.processor.identifier)
  374|      0|        do {
  375|      0|            if let data = try diskStorage.value(forKey: computedKey) {
  376|      0|                return options.cacheSerializer.image(with: data, options: options)
  377|      0|            }
  378|      0|        } catch {}
  379|      0|        return nil
  380|      0|    }
  381|       |
  382|       |    @available(*, deprecated,
  383|       |    message: "Use `Result` based `retrieveImage(forKey:options:callbackQueue:completionHandler:)` instead.",
  384|       |    renamed: "retrieveImage(forKey:options:callbackQueue:completionHandler:)")
  385|       |    open func retrieveImage(forKey key: String,
  386|       |                            options: KingfisherOptionsInfo?,
  387|       |                            completionHandler: ((Image?, CacheType) -> Void)?)
  388|      0|    {
  389|      0|        retrieveImage(
  390|      0|            forKey: key,
  391|      0|            options: options,
  392|      0|            callbackQueue: .dispatch((options ?? .empty).callbackDispatchQueue))
  393|      0|        {
  394|      0|            result in
  395|      0|            completionHandler?(result.value?.image, result.value?.cacheType ?? .none)
  396|      0|        }
  397|      0|    }
  398|       |
  399|       |    /// The longest time duration in second of the cache being stored in disk.
  400|       |    /// Default is 1 week (60 * 60 * 24 * 7 seconds).
  401|       |    /// Setting this to a negative value will make the disk cache never expiring.
  402|       |    @available(*, deprecated, message: "Deprecated. Use `diskStorage.config.expiration` instead")
  403|       |    open var maxCachePeriodInSecond: TimeInterval {
  404|      0|        get { return diskStorage.config.expiration.timeInterval }
  405|      0|        set { diskStorage.config.expiration = .seconds(newValue) }
  406|       |    }
  407|       |
  408|       |    @available(*, deprecated, message: "Use `Result` based callback instead.")
  409|       |    open func store(_ image: Image,
  410|       |                    original: Data? = nil,
  411|       |                    forKey key: String,
  412|       |                    processorIdentifier identifier: String = "",
  413|       |                    cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,
  414|       |                    toDisk: Bool = true,
  415|       |                    completionHandler: (() -> Void)?)
  416|      0|    {
  417|      0|        store(
  418|      0|            image,
  419|      0|            original: original,
  420|      0|            forKey: key,
  421|      0|            processorIdentifier: identifier,
  422|      0|            cacheSerializer: serializer,
  423|      0|            toDisk: toDisk)
  424|      0|        {
  425|      0|            _ in
  426|      0|            completionHandler?()
  427|      0|        }
  428|      0|    }
  429|       |
  430|       |    @available(*, deprecated, message: "Use the `Result`-based `calculateDiskStorageSize` instead.")
  431|      0|    open func calculateDiskCacheSize(completion handler: @escaping ((_ size: UInt) -> Void)) {
  432|      0|        calculateDiskStorageSize { result in
  433|      0|            handler(result.value ?? 0)
  434|      0|        }
  435|      0|    }
  436|       |}
  437|       |
  438|       |// MARK: - Deprecated
  439|       |public extension Collection where Iterator.Element == KingfisherOptionsInfoItem {
  440|       |    /// The queue of callbacks should happen from Kingfisher.
  441|       |    @available(*, deprecated, message: "Use `callbackQueue` instead.", renamed: "callbackQueue")
  442|      0|    public var callbackDispatchQueue: DispatchQueue {
  443|      0|        return KingfisherParsedOptionsInfo(Array(self)).callbackQueue.queue
  444|      0|    }
  445|       |}
  446|       |
  447|       |/// Error domain of Kingfisher
  448|       |@available(*, deprecated, message: "Use `KingfisherError.domain` instead.", renamed: "KingfisherError.domain")
  449|       |public let KingfisherErrorDomain = "com.onevcat.Kingfisher.Error"
  450|       |
  451|       |/// Key will be used in the `userInfo` of `.invalidStatusCode`
  452|       |@available(*, unavailable,
  453|       |message: "Use `.invalidHTTPStatusCode` or `isInvalidResponseStatusCode` of `KingfisherError` instead for the status code.")
  454|       |public let KingfisherErrorStatusCodeKey = "statusCode"
  455|       |
  456|       |// MARK: - Deprecated
  457|       |public extension Collection where Iterator.Element == KingfisherOptionsInfoItem {
  458|       |    /// The target `ImageCache` which is used.
  459|       |    @available(*, deprecated,
  460|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `targetCache` instead.")
  461|      0|    public var targetCache: ImageCache? {
  462|      0|        return KingfisherParsedOptionsInfo(Array(self)).targetCache
  463|      0|    }
  464|       |
  465|       |    /// The original `ImageCache` which is used.
  466|       |    @available(*, deprecated,
  467|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `originalCache` instead.")
  468|      0|    public var originalCache: ImageCache? {
  469|      0|        return KingfisherParsedOptionsInfo(Array(self)).originalCache
  470|      0|    }
  471|       |
  472|       |    /// The `ImageDownloader` which is specified.
  473|       |    @available(*, deprecated,
  474|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `downloader` instead.")
  475|      0|    public var downloader: ImageDownloader? {
  476|      0|        return KingfisherParsedOptionsInfo(Array(self)).downloader
  477|      0|    }
  478|       |
  479|       |    /// Member for animation transition when using UIImageView.
  480|       |    @available(*, deprecated,
  481|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `transition` instead.")
  482|      0|    public var transition: ImageTransition {
  483|      0|        return KingfisherParsedOptionsInfo(Array(self)).transition
  484|      0|    }
  485|       |
  486|       |    /// A `Float` value set as the priority of image download task. The value for it should be
  487|       |    /// between 0.0~1.0.
  488|       |    @available(*, deprecated,
  489|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `downloadPriority` instead.")
  490|      0|    public var downloadPriority: Float {
  491|      0|        return KingfisherParsedOptionsInfo(Array(self)).downloadPriority
  492|      0|    }
  493|       |
  494|       |    /// Whether an image will be always downloaded again or not.
  495|       |    @available(*, deprecated,
  496|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `forceRefresh` instead.")
  497|      0|    public var forceRefresh: Bool {
  498|      0|        return KingfisherParsedOptionsInfo(Array(self)).forceRefresh
  499|      0|    }
  500|       |
  501|       |    /// Whether an image should be got only from memory cache or download.
  502|       |    @available(*, deprecated,
  503|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `fromMemoryCacheOrRefresh` instead.")
  504|      0|    public var fromMemoryCacheOrRefresh: Bool {
  505|      0|        return KingfisherParsedOptionsInfo(Array(self)).fromMemoryCacheOrRefresh
  506|      0|    }
  507|       |
  508|       |    /// Whether the transition should always happen or not.
  509|       |    @available(*, deprecated,
  510|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `forceTransition` instead.")
  511|      0|    public var forceTransition: Bool {
  512|      0|        return KingfisherParsedOptionsInfo(Array(self)).forceTransition
  513|      0|    }
  514|       |
  515|       |    /// Whether cache the image only in memory or not.
  516|       |    @available(*, deprecated,
  517|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `cacheMemoryOnly` instead.")
  518|      0|    public var cacheMemoryOnly: Bool {
  519|      0|        return KingfisherParsedOptionsInfo(Array(self)).cacheMemoryOnly
  520|      0|    }
  521|       |
  522|       |    /// Whether the caching operation will be waited or not.
  523|       |    @available(*, deprecated,
  524|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `waitForCache` instead.")
  525|      0|    public var waitForCache: Bool {
  526|      0|        return KingfisherParsedOptionsInfo(Array(self)).waitForCache
  527|      0|    }
  528|       |
  529|       |    /// Whether only load the images from cache or not.
  530|       |    @available(*, deprecated,
  531|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `onlyFromCache` instead.")
  532|      0|    public var onlyFromCache: Bool {
  533|      0|        return KingfisherParsedOptionsInfo(Array(self)).onlyFromCache
  534|      0|    }
  535|       |
  536|       |    /// Whether the image should be decoded in background or not.
  537|       |    @available(*, deprecated,
  538|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `backgroundDecode` instead.")
  539|      0|    public var backgroundDecode: Bool {
  540|      0|        return KingfisherParsedOptionsInfo(Array(self)).backgroundDecode
  541|      0|    }
  542|       |
  543|       |    /// Whether the image data should be all loaded at once if it is an animated image.
  544|       |    @available(*, deprecated,
  545|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `preloadAllAnimationData` instead.")
  546|      0|    public var preloadAllAnimationData: Bool {
  547|      0|        return KingfisherParsedOptionsInfo(Array(self)).preloadAllAnimationData
  548|      0|    }
  549|       |
  550|       |    /// The `CallbackQueue` on which completion handler should be invoked.
  551|       |    /// If not set in the options, `.mainCurrentOrAsync` will be used.
  552|       |    @available(*, deprecated,
  553|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `callbackQueue` instead.")
  554|      0|    public var callbackQueue: CallbackQueue {
  555|      0|        return KingfisherParsedOptionsInfo(Array(self)).callbackQueue
  556|      0|    }
  557|       |
  558|       |    /// The scale factor which should be used for the image.
  559|       |    @available(*, deprecated,
  560|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `scaleFactor` instead.")
  561|      0|    public var scaleFactor: CGFloat {
  562|      0|        return KingfisherParsedOptionsInfo(Array(self)).scaleFactor
  563|      0|    }
  564|       |
  565|       |    /// The `ImageDownloadRequestModifier` will be used before sending a download request.
  566|       |    @available(*, deprecated,
  567|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `requestModifier` instead.")
  568|      0|    public var modifier: ImageDownloadRequestModifier? {
  569|      0|        return KingfisherParsedOptionsInfo(Array(self)).requestModifier
  570|      0|    }
  571|       |
  572|       |    /// `ImageProcessor` for processing when the downloading finishes.
  573|       |    @available(*, deprecated,
  574|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `processor` instead.")
  575|      0|    public var processor: ImageProcessor {
  576|      0|        return KingfisherParsedOptionsInfo(Array(self)).processor
  577|      0|    }
  578|       |
  579|       |    /// `ImageModifier` for modifying right before the image is displayed.
  580|       |    @available(*, deprecated,
  581|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `imageModifier` instead.")
  582|      0|    public var imageModifier: ImageModifier? {
  583|      0|        return KingfisherParsedOptionsInfo(Array(self)).imageModifier
  584|      0|    }
  585|       |
  586|       |    /// `CacheSerializer` to convert image to data for storing in cache.
  587|       |    @available(*, deprecated,
  588|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `cacheSerializer` instead.")
  589|      0|    public var cacheSerializer: CacheSerializer {
  590|      0|        return KingfisherParsedOptionsInfo(Array(self)).cacheSerializer
  591|      0|    }
  592|       |
  593|       |    /// Keep the existing image while setting another image to an image view.
  594|       |    /// Or the placeholder will be used while downloading.
  595|       |    @available(*, deprecated,
  596|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `keepCurrentImageWhileLoading` instead.")
  597|      0|    public var keepCurrentImageWhileLoading: Bool {
  598|      0|        return KingfisherParsedOptionsInfo(Array(self)).keepCurrentImageWhileLoading
  599|      0|    }
  600|       |
  601|       |    /// Whether the options contains `.onlyLoadFirstFrame`.
  602|       |    @available(*, deprecated,
  603|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `onlyLoadFirstFrame` instead.")
  604|      0|    public var onlyLoadFirstFrame: Bool {
  605|      0|        return KingfisherParsedOptionsInfo(Array(self)).onlyLoadFirstFrame
  606|      0|    }
  607|       |
  608|       |    /// Whether the options contains `.cacheOriginalImage`.
  609|       |    @available(*, deprecated,
  610|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `cacheOriginalImage` instead.")
  611|      0|    public var cacheOriginalImage: Bool {
  612|      0|        return KingfisherParsedOptionsInfo(Array(self)).cacheOriginalImage
  613|      0|    }
  614|       |
  615|       |    /// The image which should be used when download image request fails.
  616|       |    @available(*, deprecated,
  617|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `onFailureImage` instead.")
  618|      0|    public var onFailureImage: Optional<Image?> {
  619|      0|        return KingfisherParsedOptionsInfo(Array(self)).onFailureImage
  620|      0|    }
  621|       |
  622|       |    /// Whether the `ImagePrefetcher` should load images to memory in an aggressive way or not.
  623|       |    @available(*, deprecated,
  624|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `alsoPrefetchToMemory` instead.")
  625|      0|    public var alsoPrefetchToMemory: Bool {
  626|      0|        return KingfisherParsedOptionsInfo(Array(self)).alsoPrefetchToMemory
  627|      0|    }
  628|       |
  629|       |    /// Whether the disk storage file loading should happen in a synchronous behavior or not.
  630|       |    @available(*, deprecated,
  631|       |    message: "Create a `KingfisherParsedOptionsInfo` from `KingfisherOptionsInfo` and use `loadDiskFileSynchronously` instead.")
  632|      0|    public var loadDiskFileSynchronously: Bool {
  633|      0|        return KingfisherParsedOptionsInfo(Array(self)).loadDiskFileSynchronously
  634|      0|    }
  635|       |}
  636|       |
  637|       |/// The default modifier.
  638|       |/// It does nothing and returns the image as is.
  639|       |@available(*, deprecated, message: "Use `nil` in KingfisherOptionsInfo to indicate no modifier.")
  640|       |public struct DefaultImageModifier: ImageModifier {
  641|       |
  642|       |    /// A default `DefaultImageModifier` which can be used everywhere.
  643|       |    public static let `default` = DefaultImageModifier()
  644|      0|    private init() {}
  645|       |
  646|       |    /// Modifies an input `Image`. See `ImageModifier` protocol for more.
  647|      0|    public func modify(_ image: Image) -> Image { return image }
  648|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/General/ImageSource/ImageDataProvider.swift:
    1|       |//
    2|       |//  ImageDataProvider.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/11/13.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents a data provider to provide image data to Kingfisher when setting with
   30|       |/// `Source.provider` source. Compared to `Source.network` member, it gives a chance
   31|       |/// to load some image data in your own way, as long as you can provide the data
   32|       |/// representation for the image.
   33|       |public protocol ImageDataProvider {
   34|       |    
   35|       |    /// The key used in cache.
   36|       |    var cacheKey: String { get }
   37|       |    
   38|       |    /// Provides the data which represents image. Kingfisher uses the data you pass in the
   39|       |    /// handler to process images and caches it for later use.
   40|       |    ///
   41|       |    /// - Parameter handler: The handler you should call when you prepared your data.
   42|       |    ///                      If the data is loaded successfully, call the handler with
   43|       |    ///                      a `.success` with the data associated. Otherwise, call it
   44|       |    ///                      with a `.failure` and pass the error.
   45|       |    ///
   46|       |    /// - Note:
   47|       |    /// If the `handler` is called with a `.failure` with error, a `dataProviderError` of
   48|       |    /// `ImageSettingErrorReason` will be finally thrown out to you as the `KingfisherError`
   49|       |    /// from the framework.
   50|       |    func data(handler: @escaping (Result<Data, Error>) -> Void)
   51|       |}
   52|       |
   53|       |/// Represents an image data provider for loading from a local file URL on disk.
   54|       |/// Uses this type for adding a disk image to Kingfisher. Compared to loading it
   55|       |/// directly, you can get benefit of using Kingfisher's extension methods, as well
   56|       |/// as applying `ImageProcessor`s and storing the image to `ImageCache` of Kingfisher.
   57|       |public struct LocalFileImageDataProvider: ImageDataProvider {
   58|       |
   59|       |    // MARK: Public Properties
   60|       |
   61|       |    /// The file URL from which the image be loaded.
   62|       |    public let fileURL: URL
   63|       |
   64|       |    // MARK: Initializers
   65|       |
   66|       |    /// Creates an image data provider by supplying the target local file URL.
   67|       |    ///
   68|       |    /// - Parameters:
   69|       |    ///   - fileURL: The file URL from which the image be loaded.
   70|       |    ///   - cacheKey: The key is used for caching the image data. By default,
   71|       |    ///               the `absoluteString` of `fileURL` is used.
   72|      0|    public init(fileURL: URL, cacheKey: String? = nil) {
   73|      0|        self.fileURL = fileURL
   74|      0|        self.cacheKey = cacheKey ?? fileURL.absoluteString
   75|      0|    }
   76|       |
   77|       |    // MARK: Protocol Conforming
   78|       |
   79|       |    /// The key used in cache.
   80|       |    public var cacheKey: String
   81|       |
   82|      0|    public func data(handler: (Result<Data, Error>) -> Void) {
   83|      0|        handler( Result { try Data(contentsOf: fileURL) } )
   84|      0|    }
   85|       |}
   86|       |
   87|       |/// Represents an image data provider for loading image from a given Base64 encoded string.
   88|       |public struct Base64ImageDataProvider: ImageDataProvider {
   89|       |
   90|       |    // MARK: Public Properties
   91|       |    /// The encoded Base64 string for the image.
   92|       |    public let base64String: String
   93|       |
   94|       |    // MARK: Initializers
   95|       |
   96|       |    /// Creates an image data provider by supplying the Base64 encoded string.
   97|       |    ///
   98|       |    /// - Parameters:
   99|       |    ///   - base64String: The Base64 encoded string for an image.
  100|       |    ///   - cacheKey: The key is used for caching the image data. You need a different key for any different image.
  101|      0|    public init(base64String: String, cacheKey: String) {
  102|      0|        self.base64String = base64String
  103|      0|        self.cacheKey = cacheKey
  104|      0|    }
  105|       |
  106|       |    // MARK: Protocol Conforming
  107|       |
  108|       |    /// The key used in cache.
  109|       |    public var cacheKey: String
  110|       |
  111|      0|    public func data(handler: (Result<Data, Error>) -> Void) {
  112|      0|        let data = Data(base64Encoded: base64String)!
  113|      0|        handler(.success(data))
  114|      0|    }
  115|       |}
  116|       |
  117|       |/// Represents an image data provider for a raw data object.
  118|       |public struct RawImageDataProvider: ImageDataProvider {
  119|       |
  120|       |    // MARK: Public Properties
  121|       |
  122|       |    /// The raw data object to provide to Kingfisher image loader.
  123|       |    public let data: Data
  124|       |
  125|       |    // MARK: Initializers
  126|       |
  127|       |    /// Creates an image data provider by the given raw `data` value and a `cacheKey` be used in Kingfisher cache.
  128|       |    ///
  129|       |    /// - Parameters:
  130|       |    ///   - data: The raw data reprensents an image.
  131|       |    ///   - cacheKey: The key is used for caching the image data. You need a different key for any different image.
  132|      0|    public init(data: Data, cacheKey: String) {
  133|      0|        self.data = data
  134|      0|        self.cacheKey = cacheKey
  135|      0|    }
  136|       |
  137|       |    // MARK: Protocol Conforming
  138|       |    
  139|       |    /// The key used in cache.
  140|       |    public var cacheKey: String
  141|       |
  142|      0|    public func data(handler: @escaping (Result<Data, Error>) -> Void) {
  143|      0|        handler(.success(data))
  144|      0|    }
  145|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/General/ImageSource/Resource.swift:
    1|       |//
    2|       |//  Resource.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents an image resource at a certain url and a given cache key.
   30|       |/// Kingfisher will use a `Resource` to download a resource from network and cache it with the cache key when
   31|       |/// using `Source.network` as its image setting source.
   32|       |public protocol Resource {
   33|       |    
   34|       |    /// The key used in cache.
   35|       |    var cacheKey: String { get }
   36|       |    
   37|       |    /// The target image URL.
   38|       |    var downloadURL: URL { get }
   39|       |}
   40|       |
   41|       |/// ImageResource is a simple combination of `downloadURL` and `cacheKey`.
   42|       |/// When passed to image view set methods, Kingfisher will try to download the target
   43|       |/// image from the `downloadURL`, and then store it with the `cacheKey` as the key in cache.
   44|       |public struct ImageResource: Resource {
   45|       |
   46|       |    // MARK: - Initializers
   47|       |
   48|       |    /// Creates an image resource.
   49|       |    ///
   50|       |    /// - Parameters:
   51|       |    ///   - downloadURL: The target image URL from where the image can be downloaded.
   52|       |    ///   - cacheKey: The cache key. If `nil`, Kingfisher will use the `absoluteString` of `downloadURL` as the key.
   53|       |    ///               Default is `nil`.
   54|      0|    public init(downloadURL: URL, cacheKey: String? = nil) {
   55|      0|        self.downloadURL = downloadURL
   56|      0|        self.cacheKey = cacheKey ?? downloadURL.absoluteString
   57|      0|    }
   58|       |
   59|       |    // MARK: Protocol Conforming
   60|       |    
   61|       |    /// The key used in cache.
   62|       |    public let cacheKey: String
   63|       |
   64|       |    /// The target image URL.
   65|       |    public let downloadURL: URL
   66|       |}
   67|       |
   68|       |/// URL conforms to `Resource` in Kingfisher.
   69|       |/// The `absoluteString` of this URL is used as `cacheKey`. And the URL itself will be used as `downloadURL`.
   70|       |/// If you need customize the url and/or cache key, use `ImageResource` instead.
   71|       |extension URL: Resource {
   72|      0|    public var cacheKey: String { return absoluteString }
   73|      0|    public var downloadURL: URL { return self }
   74|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/General/ImageSource/Source.swift:
    1|       |//
    2|       |//  Source.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/11/17.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents an image setting source for Kingfisher methods.
   30|       |///
   31|       |/// A `Source` value indicates the way how the target image can be retrieved and cached.
   32|       |///
   33|       |/// - network: The target image should be got from network remotely. The associated `Resource`
   34|       |///            value defines detail information like image URL and cache key.
   35|       |/// - provider: The target image should be provided in a data format. Normally, it can be an image
   36|       |///             from local storage or in any other encoding format (like Base64).
   37|       |public enum Source {
   38|       |
   39|       |    /// Represents the source task identifier when setting an image to a view with extension methods.
   40|       |    public enum Identifier {
   41|       |
   42|       |        /// The underlying value type of source identifier.
   43|       |        public typealias Value = UInt
   44|       |        static var current: Value = 0
   45|      0|        static func next() -> Value {
   46|      0|            current += 1
   47|      0|            return current
   48|      0|        }
   49|       |    }
   50|       |
   51|       |    // MARK: Member Cases
   52|       |
   53|       |    /// The target image should be got from network remotely. The associated `Resource`
   54|       |    /// value defines detail information like image URL and cache key.
   55|       |    case network(Resource)
   56|       |    
   57|       |    /// The target image should be provided in a data format. Normally, it can be an image
   58|       |    /// from local storage or in any other encoding format (like Base64).
   59|       |    case provider(ImageDataProvider)
   60|       |
   61|       |    // MARK: Getting Properties
   62|       |
   63|       |    /// The cache key defined for this source value.
   64|      0|    public var cacheKey: String {
   65|      0|        switch self {
   66|      0|        case .network(let resource): return resource.cacheKey
   67|      0|        case .provider(let provider): return provider.cacheKey
   68|      0|        }
   69|      0|    }
   70|       |
   71|       |    /// The URL defined for this source value.
   72|       |    ///
   73|       |    /// For a `.network` source, it is the `downloadURL` of associated `Resource` instance.
   74|       |    /// For a `.provider` value, it is always `nil`.
   75|      0|    public var url: URL? {
   76|      0|        switch self {
   77|      0|        case .network(let resource): return resource.downloadURL
   78|      0|        // `ImageDataProvider` does not provide a URL. All it cares is how to get the data back.
   79|      0|        case .provider(_): return nil
   80|      0|        }
   81|      0|    }
   82|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/General/Kingfisher.swift:
    1|       |//
    2|       |//  Kingfisher.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 16/9/14.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |import ImageIO
   29|       |
   30|       |#if os(macOS)
   31|       |import AppKit
   32|       |public typealias Image = NSImage
   33|       |public typealias View = NSView
   34|       |public typealias Color = NSColor
   35|       |public typealias ImageView = NSImageView
   36|       |public typealias Button = NSButton
   37|       |#else
   38|       |import UIKit
   39|       |public typealias Image = UIImage
   40|       |public typealias Color = UIColor
   41|       |#if !os(watchOS)
   42|       |public typealias ImageView = UIImageView
   43|       |public typealias View = UIView
   44|       |public typealias Button = UIButton
   45|       |#else
   46|       |import WatchKit
   47|       |#endif
   48|       |#endif
   49|       |
   50|       |/// Wrapper for Kingfisher compatible types. This type provides an extension point for
   51|       |/// connivence methods in Kingfisher.
   52|       |public struct KingfisherWrapper<Base> {
   53|       |    public let base: Base
   54|      0|    public init(_ base: Base) {
   55|      0|        self.base = base
   56|      0|    }
   57|       |}
   58|       |
   59|       |/// Represents a type which is compatible with Kingfisher. You can use `kf` property to get a
   60|       |/// value in the namespace of Kingfisher.
   61|       |public protocol KingfisherCompatible { }
   62|       |
   63|       |public extension KingfisherCompatible {
   64|       |    
   65|       |    /// Gets a namespace holder for Kingfisher compatible types.
   66|       |    public var kf: KingfisherWrapper<Self> {
   67|      0|        get { return KingfisherWrapper(self) }
   68|      0|        set { }
   69|       |    }
   70|       |}
   71|       |
   72|       |extension Image: KingfisherCompatible { }
   73|       |#if !os(watchOS)
   74|       |extension ImageView: KingfisherCompatible { }
   75|       |extension Button: KingfisherCompatible { }
   76|       |#else
   77|       |extension WKInterfaceImage: KingfisherCompatible { }
   78|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/General/KingfisherError.swift:
    1|       |//
    2|       |//  KingfisherError.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/09/26.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |extension Never: Error {}
   30|       |
   31|       |/// Represents all the errors which can happen in Kingfisher framework.
   32|       |/// Kingfisher related methods always throw a `KingfisherError` or invoke the callback with `KingfisherError`
   33|       |/// as its error type. To handle errors from Kingfisher, you switch over the error to get a reason catalog,
   34|       |/// then switch over the reason to know error detail.
   35|       |public enum KingfisherError: Error {
   36|       |
   37|       |    // MARK: Error Reason Types
   38|       |
   39|       |    /// Represents the error reason during networking request phase.
   40|       |    ///
   41|       |    /// - emptyRequest: The request is empty. Code 1001.
   42|       |    /// - invalidURL: The URL of request is invalid. Code 1002.
   43|       |    /// - taskCancelled: The downloading task is cancelled by user. Code 1003.
   44|       |    public enum RequestErrorReason {
   45|       |        
   46|       |        /// The request is empty. Code 1001.
   47|       |        case emptyRequest
   48|       |        
   49|       |        /// The URL of request is invalid. Code 1002.
   50|       |        /// - request: The request is tend to be sent but its URL is invalid.
   51|       |        case invalidURL(request: URLRequest)
   52|       |        
   53|       |        /// The downloading task is cancelled by user. Code 1003.
   54|       |        /// - task: The session data task which is cancelled.
   55|       |        /// - token: The cancel token which is used for cancelling the task.
   56|       |        case taskCancelled(task: SessionDataTask, token: SessionDataTask.CancelToken)
   57|       |    }
   58|       |    
   59|       |    /// Represents the error reason during networking response phase.
   60|       |    ///
   61|       |    /// - invalidURLResponse: The response is not a valid URL response. Code 2001.
   62|       |    /// - invalidHTTPStatusCode: The response contains an invalid HTTP status code. Code 2002.
   63|       |    /// - URLSessionError: An error happens in the system URL session. Code 2003.
   64|       |    /// - dataModifyingFailed: Data modifying fails on returning a valid data. Code 2004.
   65|       |    /// - noURLResponse: The task is done but no URL response found. Code 2005.
   66|       |    public enum ResponseErrorReason {
   67|       |        
   68|       |        /// The response is not a valid URL response. Code 2001.
   69|       |        /// - response: The received invalid URL response.
   70|       |        ///             The response is expected to be an HTTP response, but it is not.
   71|       |        case invalidURLResponse(response: URLResponse)
   72|       |        
   73|       |        /// The response contains an invalid HTTP status code. Code 2002.
   74|       |        /// - Note:
   75|       |        ///   By default, status code 200..<400 is recognized as valid. You can override
   76|       |        ///   this behavior by conforming to the `ImageDownloaderDelegate`.
   77|       |        /// - response: The received response.
   78|       |        case invalidHTTPStatusCode(response: HTTPURLResponse)
   79|       |        
   80|       |        /// An error happens in the system URL session. Code 2003.
   81|       |        /// - error: The underlying URLSession error object.
   82|       |        case URLSessionError(error: Error)
   83|       |        
   84|       |        /// Data modifying fails on returning a valid data. Code 2004.
   85|       |        /// - task: The failed task.
   86|       |        case dataModifyingFailed(task: SessionDataTask)
   87|       |        
   88|       |        /// The task is done but no URL response found. Code 2005.
   89|       |        /// - task: The failed task.
   90|       |        case noURLResponse(task: SessionDataTask)
   91|       |    }
   92|       |    
   93|       |    /// Represents the error reason during Kingfisher caching system.
   94|       |    ///
   95|       |    /// - fileEnumeratorCreationFailed: Cannot create a file enumerator for a certain disk URL. Code 3001.
   96|       |    /// - invalidFileEnumeratorContent: Cannot get correct file contents from a file enumerator. Code 3002.
   97|       |    /// - invalidURLResource: The file at target URL exists, but its URL resource is unavailable. Code 3003.
   98|       |    /// - cannotLoadDataFromDisk: The file at target URL exists, but the data cannot be loaded from it. Code 3004.
   99|       |    /// - cannotCreateDirectory: Cannot create a folder at a given path. Code 3005.
  100|       |    /// - imageNotExisting: The requested image does not exist in cache. Code 3006.
  101|       |    /// - cannotConvertToData: Cannot convert an object to data for storing. Code 3007.
  102|       |    /// - cannotSerializeImage: Cannot serialize an image to data for storing. Code 3008.
  103|       |    public enum CacheErrorReason {
  104|       |        
  105|       |        /// Cannot create a file enumerator for a certain disk URL. Code 3001.
  106|       |        /// - url: The target disk URL from which the file enumerator should be created.
  107|       |        case fileEnumeratorCreationFailed(url: URL)
  108|       |        
  109|       |        /// Cannot get correct file contents from a file enumerator. Code 3002.
  110|       |        /// - url: The target disk URL from which the content of a file enumerator should be got.
  111|       |        case invalidFileEnumeratorContent(url: URL)
  112|       |        
  113|       |        /// The file at target URL exists, but its URL resource is unavailable. Code 3003.
  114|       |        /// - error: The underlying error thrown by file manager.
  115|       |        /// - key: The key used to getting the resource from cache.
  116|       |        /// - url: The disk URL where the target cached file exists.
  117|       |        case invalidURLResource(error: Error, key: String, url: URL)
  118|       |        
  119|       |        /// The file at target URL exists, but the data cannot be loaded from it. Code 3004.
  120|       |        /// - url: The disk URL where the target cached file exists.
  121|       |        /// - error: The underlying error which describes why this error happens.
  122|       |        case cannotLoadDataFromDisk(url: URL, error: Error)
  123|       |        
  124|       |        /// Cannot create a folder at a given path. Code 3005.
  125|       |        /// - path: The disk path where the directory creating operation fails.
  126|       |        /// - error: The underlying error which describes why this error happens.
  127|       |        case cannotCreateDirectory(path: String, error: Error)
  128|       |        
  129|       |        /// The requested image does not exist in cache. Code 3006.
  130|       |        /// - key: Key of the requested image in cache.
  131|       |        case imageNotExisting(key: String)
  132|       |        
  133|       |        /// Cannot convert an object to data for storing. Code 3007.
  134|       |        /// - object: The object which needs be convert to data.
  135|       |        case cannotConvertToData(object: Any, error: Error)
  136|       |        
  137|       |        /// Cannot serialize an image to data for storing. Code 3008.
  138|       |        /// - image: The input image needs to be serialized to cache.
  139|       |        /// - original: The original image data, if exists.
  140|       |        /// - serializer: The `CacheSerializer` used for the image serializing.
  141|       |        case cannotSerializeImage(image: Image?, original: Data?, serializer: CacheSerializer)
  142|       |    }
  143|       |    
  144|       |    
  145|       |    /// Represents the error reason during image processing phase.
  146|       |    ///
  147|       |    /// - processingFailed: Image processing fails. There is no valid output image from the processor. Code 4001.
  148|       |    public enum ProcessorErrorReason {
  149|       |        /// Image processing fails. There is no valid output image from the processor. Code 4001.
  150|       |        /// - processor: The `ImageProcessor` used to process the image or its data in `item`.
  151|       |        /// - item: The image or its data content.
  152|       |        case processingFailed(processor: ImageProcessor, item: ImageProcessItem)
  153|       |    }
  154|       |
  155|       |    /// Represents the error reason during image setting in a view related class.
  156|       |    ///
  157|       |    /// - emptySource: The input resource is empty or `nil`. Code 5001.
  158|       |    /// - notCurrentSourceTask: The source task is finished, but it is not the one expected now. Code 5002.
  159|       |    /// - dataProviderError: An error happens during getting data from an `ImageDataProvider`. Code 5003.
  160|       |    public enum ImageSettingErrorReason {
  161|       |        
  162|       |        /// The input resource is empty or `nil`. Code 5001.
  163|       |        case emptySource
  164|       |        
  165|       |        /// The resource task is finished, but it is not the one expected now. This usually happens when you set another
  166|       |        /// resource on the view without cancelling the current on-going one. The previous setting task will fail with
  167|       |        /// this `.notCurrentSourceTask` error when a result got, regardless of it being successful or not for that task.
  168|       |        /// The result of this original task is contained in the associated value.
  169|       |        /// Code 5002.
  170|       |        /// - result: The `RetrieveImageResult` if the source task is finished without problem. `nil` if an error
  171|       |        ///           happens.
  172|       |        /// - error: The `Error` if an issue happens during image setting task. `nil` if the task finishes without
  173|       |        ///          problem.
  174|       |        /// - source: The original source value of the taks.
  175|       |        case notCurrentSourceTask(result: RetrieveImageResult?, error: Error?, source: Source)
  176|       |
  177|       |        /// An error happens during getting data from an `ImageDataProvider`. Code 5003.
  178|       |        case dataProviderError(provider: ImageDataProvider, error: Error)
  179|       |    }
  180|       |
  181|       |    // MARK: Member Cases
  182|       |    
  183|       |    /// Represents the error reason during networking request phase.
  184|       |    case requestError(reason: RequestErrorReason)
  185|       |    /// Represents the error reason during networking response phase.
  186|       |    case responseError(reason: ResponseErrorReason)
  187|       |    /// Represents the error reason during Kingfisher caching system.
  188|       |    case cacheError(reason: CacheErrorReason)
  189|       |    /// Represents the error reason during image processing phase.
  190|       |    case processorError(reason: ProcessorErrorReason)
  191|       |    /// Represents the error reason during image setting in a view related class.
  192|       |    case imageSettingError(reason: ImageSettingErrorReason)
  193|       |
  194|       |    // MARK: Helper Properties & Methods
  195|       |
  196|       |    /// Helper property to check whether this error is a `RequestErrorReason.taskCancelled` or not.
  197|      0|    public var isTaskCancelled: Bool {
  198|      0|        if case .requestError(reason: .taskCancelled) = self {
  199|      0|            return true
  200|      0|        }
  201|      0|        return false
  202|      0|    }
  203|       |
  204|       |    /// Helper method to check whether this error is a `ResponseErrorReason.invalidHTTPStatusCode` and the
  205|       |    /// associated value is a given status code.
  206|       |    ///
  207|       |    /// - Parameter code: The given status code.
  208|       |    /// - Returns: If `self` is a `ResponseErrorReason.invalidHTTPStatusCode` error
  209|       |    ///            and its status code equals to `code`, `true` is returned. Otherwise, `false`.
  210|      0|    public func isInvalidResponseStatusCode(_ code: Int) -> Bool {
  211|      0|        if case .responseError(reason: .invalidHTTPStatusCode(let response)) = self {
  212|      0|            return response.statusCode == code
  213|      0|        }
  214|      0|        return false
  215|      0|    }
  216|       |
  217|      0|    public var isInvalidResponseStatusCode: Bool {
  218|      0|        if case .responseError(reason: .invalidHTTPStatusCode) = self {
  219|      0|            return true
  220|      0|        }
  221|      0|        return false
  222|      0|    }
  223|       |
  224|       |    /// Helper property to check whether this error is a `ImageSettingErrorReason.notCurrentSourceTask` or not.
  225|       |    /// When a new image setting task starts while the old one is still running, the new task identifier will be
  226|       |    /// set and the old one is overwritten. A `.notCurrentSourceTask` error will be raised when the old task finishes
  227|       |    /// to let you know the setting process finishes with a certain result, but the image view or button is not set.
  228|      0|    public var isNotCurrentTask: Bool {
  229|      0|        if case .imageSettingError(reason: .notCurrentSourceTask(_, _, _)) = self {
  230|      0|            return true
  231|      0|        }
  232|      0|        return false
  233|      0|    }
  234|       |}
  235|       |
  236|       |// MARK: - LocalizedError Conforming
  237|       |extension KingfisherError: LocalizedError {
  238|       |    
  239|       |    /// A localized message describing what error occurred.
  240|      0|    public var errorDescription: String? {
  241|      0|        switch self {
  242|      0|        case .requestError(let reason): return reason.errorDescription
  243|      0|        case .responseError(let reason): return reason.errorDescription
  244|      0|        case .cacheError(let reason): return reason.errorDescription
  245|      0|        case .processorError(let reason): return reason.errorDescription
  246|      0|        case .imageSettingError(let reason): return reason.errorDescription
  247|      0|        }
  248|      0|    }
  249|       |}
  250|       |
  251|       |
  252|       |// MARK: - CustomNSError Conforming
  253|       |extension KingfisherError: CustomNSError {
  254|       |
  255|       |    /// The error domain of `KingfisherError`. All errors from Kingfisher is under this domain.
  256|       |    public static let domain = "com.onevcat.Kingfisher.Error"
  257|       |
  258|       |    /// The error code within the given domain.
  259|      0|    public var errorCode: Int {
  260|      0|        switch self {
  261|      0|        case .requestError(let reason): return reason.errorCode
  262|      0|        case .responseError(let reason): return reason.errorCode
  263|      0|        case .cacheError(let reason): return reason.errorCode
  264|      0|        case .processorError(let reason): return reason.errorCode
  265|      0|        case .imageSettingError(let reason): return reason.errorCode
  266|      0|        }
  267|      0|    }
  268|       |}
  269|       |
  270|       |extension KingfisherError.RequestErrorReason {
  271|      0|    var errorDescription: String? {
  272|      0|        switch self {
  273|      0|        case .emptyRequest:
  274|      0|            return "The request is empty or `nil`."
  275|      0|        case .invalidURL(let request):
  276|      0|            return "The request contains an invalid or empty URL. Request: \(request)."
  277|      0|        case .taskCancelled(let task, let token):
  278|      0|            return "The session task was cancelled. Task: \(task), cancel token: \(token)."
  279|      0|        }
  280|      0|    }
  281|       |    
  282|      0|    var errorCode: Int {
  283|      0|        switch self {
  284|      0|        case .emptyRequest: return 1001
  285|      0|        case .invalidURL: return 1002
  286|      0|        case .taskCancelled: return 1003
  287|      0|        }
  288|      0|    }
  289|       |}
  290|       |
  291|       |extension KingfisherError.ResponseErrorReason {
  292|      0|    var errorDescription: String? {
  293|      0|        switch self {
  294|      0|        case .invalidURLResponse(let response):
  295|      0|            return "The URL response is invalid: \(response)"
  296|      0|        case .invalidHTTPStatusCode(let response):
  297|      0|            return "The HTTP status code in response is invalid. Code: \(response.statusCode), response: \(response)."
  298|      0|        case .URLSessionError(let error):
  299|      0|            return "A URL session error happened. The underlying error: \(error)"
  300|      0|        case .dataModifyingFailed(let task):
  301|      0|            return "The data modifying delegate returned `nil` for the downloaded data. Task: \(task)."
  302|      0|        case .noURLResponse(let task):
  303|      0|            return "No URL response received. Task: \(task),"
  304|      0|        }
  305|      0|    }
  306|       |    
  307|      0|    var errorCode: Int {
  308|      0|        switch self {
  309|      0|        case .invalidURLResponse: return 2001
  310|      0|        case .invalidHTTPStatusCode: return 2002
  311|      0|        case .URLSessionError: return 2003
  312|      0|        case .dataModifyingFailed: return 2004
  313|      0|        case .noURLResponse: return 2005
  314|      0|        }
  315|      0|    }
  316|       |}
  317|       |
  318|       |extension KingfisherError.CacheErrorReason {
  319|      0|    var errorDescription: String? {
  320|      0|        switch self {
  321|      0|        case .fileEnumeratorCreationFailed(let url):
  322|      0|            return "Cannot create file enumerator for URL: \(url)."
  323|      0|        case .invalidFileEnumeratorContent(let url):
  324|      0|            return "Cannot get contents from the file enumerator at URL: \(url)."
  325|      0|        case .invalidURLResource(let error, let key, let url):
  326|      0|            return "Cannot get URL resource values or data for the given URL: \(url). " +
  327|      0|                   "Cache key: \(key). Underlying error: \(error)"
  328|      0|        case .cannotLoadDataFromDisk(let url, let error):
  329|      0|            return "Cannot load data from disk at URL: \(url). Underlying error: \(error)"
  330|      0|        case .cannotCreateDirectory(let path, let error):
  331|      0|            return "Cannot create directory at given path: Path: \(path). Underlying error: \(error)"
  332|      0|        case .imageNotExisting(let key):
  333|      0|            return "The image is not in cache, but you requires it should only be " +
  334|      0|                   "from cache by enabling the `.onlyFromCache` option. Key: \(key)."
  335|      0|        case .cannotConvertToData(let object, let error):
  336|      0|            return "Cannot convert the input object to a `Data` object when storing it to disk cache. " +
  337|      0|                   "Object: \(object). Underlying error: \(error)"
  338|      0|        case .cannotSerializeImage(let image, let originalData, let serializer):
  339|      0|            return "Cannot serialize an image due to the cache serializer returning `nil`. " +
  340|      0|                   "Image: \(String(describing:image)), original data: \(String(describing: originalData)), serializer: \(serializer)."
  341|      0|        }
  342|      0|    }
  343|       |    
  344|      0|    var errorCode: Int {
  345|      0|        switch self {
  346|      0|        case .fileEnumeratorCreationFailed: return 3001
  347|      0|        case .invalidFileEnumeratorContent: return 3002
  348|      0|        case .invalidURLResource: return 3003
  349|      0|        case .cannotLoadDataFromDisk: return 3004
  350|      0|        case .cannotCreateDirectory: return 3005
  351|      0|        case .imageNotExisting: return 3006
  352|      0|        case .cannotConvertToData: return 3007
  353|      0|        case .cannotSerializeImage: return 3008
  354|      0|        }
  355|      0|    }
  356|       |}
  357|       |
  358|       |extension KingfisherError.ProcessorErrorReason {
  359|      0|    var errorDescription: String? {
  360|      0|        switch self {
  361|      0|        case .processingFailed(let processor, let item):
  362|      0|            return "Processing image failed. Processor: \(processor). Processing item: \(item)."
  363|      0|        }
  364|      0|    }
  365|       |    
  366|      0|    var errorCode: Int {
  367|      0|        switch self {
  368|      0|        case .processingFailed: return 4001
  369|      0|        }
  370|      0|    }
  371|       |}
  372|       |
  373|       |extension KingfisherError.ImageSettingErrorReason {
  374|      0|    var errorDescription: String? {
  375|      0|        switch self {
  376|      0|        case .emptySource:
  377|      0|            return "The input resource is empty."
  378|      0|        case .notCurrentSourceTask(let result, let error, let resource):
  379|      0|            if let result = result {
  380|      0|                return "Retrieving resource succeeded, but this source is " +
  381|      0|                       "not the one currently expected. Result: \(result). Resource: \(resource)."
  382|      0|            } else if let error = error {
  383|      0|                return "Retrieving resource failed, and this resource is " +
  384|      0|                       "not the one currently expected. Error: \(error). Resource: \(resource)."
  385|      0|            } else {
  386|      0|                return nil
  387|      0|            }
  388|      0|        case .dataProviderError(let provider, let error):
  389|      0|            return "Image data provider fails to provide data. Provider: \(provider), error: \(error)"
  390|      0|        }
  391|      0|    }
  392|       |    
  393|      0|    var errorCode: Int {
  394|      0|        switch self {
  395|      0|        case .emptySource: return 5001
  396|      0|        case .notCurrentSourceTask: return 5002
  397|      0|        case .dataProviderError: return 5003
  398|      0|        }
  399|      0|    }
  400|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/General/KingfisherManager.swift:
    1|       |//
    2|       |//  KingfisherManager.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |
   28|       |import Foundation
   29|       |
   30|       |/// The downloading progress block type.
   31|       |/// The parameter value is the `receivedSize` of current response.
   32|       |/// The second parameter is the total expected data length from response's "Content-Length" header.
   33|       |/// If the expected length is not available, this block will not be called.
   34|       |public typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -> Void)
   35|       |
   36|       |/// Represents the result of a Kingfisher retrieving image task.
   37|       |public struct RetrieveImageResult {
   38|       |
   39|       |    /// Gets the image object of this result.
   40|       |    public let image: Image
   41|       |
   42|       |    /// Gets the cache source of the image. It indicates from which layer of cache this image is retrieved.
   43|       |    /// If the image is just downloaded from network, `.none` will be returned.
   44|       |    public let cacheType: CacheType
   45|       |
   46|       |    /// The `Source` from which the retrieve task begins.
   47|       |    public let source: Source
   48|       |}
   49|       |
   50|       |/// Main manager class of Kingfisher. It connects Kingfisher downloader and cache,
   51|       |/// to provide a set of convenience methods to use Kingfisher for tasks.
   52|       |/// You can use this class to retrieve an image via a specified URL from web or cache.
   53|       |public class KingfisherManager {
   54|       |
   55|       |    /// Represents a shared manager used across Kingfisher.
   56|       |    /// Use this instance for getting or storing images with Kingfisher.
   57|       |    public static let shared = KingfisherManager()
   58|       |
   59|       |    // Mark: Public Properties
   60|       |    /// The `ImageCache` used by this manager. It is `ImageCache.default` by default.
   61|       |    /// If a cache is specified in `KingfisherManager.defaultOptions`, the value in `defaultOptions` will be
   62|       |    /// used instead.
   63|       |    public var cache: ImageCache
   64|       |    
   65|       |    /// The `ImageDownloader` used by this manager. It is `ImageDownloader.default` by default.
   66|       |    /// If a downloader is specified in `KingfisherManager.defaultOptions`, the value in `defaultOptions` will be
   67|       |    /// used instead.
   68|       |    public var downloader: ImageDownloader
   69|       |    
   70|       |    /// Default options used by the manager. This option will be used in
   71|       |    /// Kingfisher manager related methods, as well as all view extension methods.
   72|       |    /// You can also passing other options for each image task by sending an `options` parameter
   73|       |    /// to Kingfisher's APIs. The per image options will overwrite the default ones,
   74|       |    /// if the option exists in both.
   75|       |    public var defaultOptions = KingfisherOptionsInfo.empty
   76|       |    
   77|       |    // Use `defaultOptions` to overwrite the `downloader` and `cache`.
   78|      0|    private var currentDefaultOptions: KingfisherOptionsInfo {
   79|      0|        return [.downloader(downloader), .targetCache(cache)] + defaultOptions
   80|      0|    }
   81|       |
   82|       |    private let processingQueue: CallbackQueue
   83|       |    
   84|      0|    private convenience init() {
   85|      0|        self.init(downloader: .default, cache: .default)
   86|      0|    }
   87|       |    
   88|      0|    init(downloader: ImageDownloader, cache: ImageCache) {
   89|      0|        self.downloader = downloader
   90|      0|        self.cache = cache
   91|      0|
   92|      0|        let processQueueName = "com.onevcat.Kingfisher.KingfisherManager.processQueue.\(UUID().uuidString)"
   93|      0|        processingQueue = .dispatch(DispatchQueue(label: processQueueName))
   94|      0|    }
   95|       |
   96|       |    // Mark: Getting Images
   97|       |
   98|       |    /// Gets an image from a given resource.
   99|       |    ///
  100|       |    /// - Parameters:
  101|       |    ///   - resource: The `Resource` object defines data information like key or URL.
  102|       |    ///   - options: Options to use when creating the animated image.
  103|       |    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
  104|       |    ///                    `expectedContentLength`, this block will not be called. `progressBlock` is always called in
  105|       |    ///                    main queue.
  106|       |    ///   - completionHandler: Called when the image retrieved and set finished. This completion handler will be invoked
  107|       |    ///                        from the `options.callbackQueue`. If not specified, the main queue will be used.
  108|       |    /// - Returns: A task represents the image downloading. If there is a download task starts for `.network` resource,
  109|       |    ///            the started `DownloadTask` is returned. Otherwise, `nil` is returned.
  110|       |    ///
  111|       |    /// - Note:
  112|       |    ///    This method will first check whether the requested `resource` is already in cache or not. If cached,
  113|       |    ///    it returns `nil` and invoke the `completionHandler` after the cached image retrieved. Otherwise, it
  114|       |    ///    will download the `resource`, store it in cache, then call `completionHandler`.
  115|       |    ///
  116|       |    @discardableResult
  117|       |    public func retrieveImage(
  118|       |        with resource: Resource,
  119|       |        options: KingfisherOptionsInfo? = nil,
  120|       |        progressBlock: DownloadProgressBlock? = nil,
  121|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
  122|      0|    {
  123|      0|        let source = Source.network(resource)
  124|      0|        return retrieveImage(
  125|      0|            with: source, options: options, progressBlock: progressBlock, completionHandler: completionHandler
  126|      0|        )
  127|      0|    }
  128|       |
  129|       |    /// Gets an image from a given resource.
  130|       |    ///
  131|       |    /// - Parameters:
  132|       |    ///   - source: The `Source` object defines data information from network or a data provider.
  133|       |    ///   - options: Options to use when creating the animated image.
  134|       |    ///   - progressBlock: Called when the image downloading progress gets updated. If the response does not contain an
  135|       |    ///                    `expectedContentLength`, this block will not be called. `progressBlock` is always called in
  136|       |    ///                    main queue.
  137|       |    ///   - completionHandler: Called when the image retrieved and set finished. This completion handler will be invoked
  138|       |    ///                        from the `options.callbackQueue`. If not specified, the main queue will be used.
  139|       |    /// - Returns: A task represents the image downloading. If there is a download task starts for `.network` resource,
  140|       |    ///            the started `DownloadTask` is returned. Otherwise, `nil` is returned.
  141|       |    ///
  142|       |    /// - Note:
  143|       |    ///    This method will first check whether the requested `source` is already in cache or not. If cached,
  144|       |    ///    it returns `nil` and invoke the `completionHandler` after the cached image retrieved. Otherwise, it
  145|       |    ///    will try to load the `source`, store it in cache, then call `completionHandler`.
  146|       |    ///
  147|       |    public func retrieveImage(
  148|       |        with source: Source,
  149|       |        options: KingfisherOptionsInfo? = nil,
  150|       |        progressBlock: DownloadProgressBlock? = nil,
  151|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
  152|      0|    {
  153|      0|        let options = currentDefaultOptions + (options ?? .empty)
  154|      0|        return retrieveImage(
  155|      0|            with: source,
  156|      0|            options: KingfisherParsedOptionsInfo(options),
  157|      0|            progressBlock: progressBlock,
  158|      0|            completionHandler: completionHandler)
  159|      0|    }
  160|       |    
  161|       |    func retrieveImage(
  162|       |        with source: Source,
  163|       |        options: KingfisherParsedOptionsInfo,
  164|       |        progressBlock: DownloadProgressBlock? = nil,
  165|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
  166|      0|    {
  167|      0|        if options.forceRefresh {
  168|      0|            return loadAndCacheImage(
  169|      0|                source: source, options: options, progressBlock: progressBlock, completionHandler: completionHandler)
  170|      0|        } else {
  171|      0|            let loadedFromCache = retrieveImageFromCache(
  172|      0|                source: source,
  173|      0|                options: options,
  174|      0|                completionHandler: completionHandler)
  175|      0|            
  176|      0|            if loadedFromCache {
  177|      0|                return nil
  178|      0|            }
  179|      0|            
  180|      0|            if options.onlyFromCache {
  181|      0|                let error = KingfisherError.cacheError(reason: .imageNotExisting(key: source.cacheKey))
  182|      0|                completionHandler?(.failure(error))
  183|      0|                return nil
  184|      0|            }
  185|      0|            
  186|      0|            return loadAndCacheImage(
  187|      0|                source: source, options: options, progressBlock: progressBlock, completionHandler: completionHandler)
  188|      0|        }
  189|      0|    }
  190|       |
  191|       |    func provideImage(
  192|       |        provider: ImageDataProvider,
  193|       |        options: KingfisherParsedOptionsInfo,
  194|       |        completionHandler: ((Result<ImageLoadingResult, KingfisherError>) -> Void)?)
  195|      0|    {
  196|      0|        guard let  completionHandler = completionHandler else { return }
  197|      0|        provider.data { result in
  198|      0|            switch result {
  199|      0|            case .success(let data):
  200|      0|                (options.processingQueue ?? self.processingQueue).execute {
  201|      0|                    let processor = options.processor
  202|      0|                    let processingItem = ImageProcessItem.data(data)
  203|      0|                    guard let image = processor.process(item: processingItem, options: options) else {
  204|      0|                        options.callbackQueue.execute {
  205|      0|                            let error = KingfisherError.processorError(
  206|      0|                                reason: .processingFailed(processor: processor, item: processingItem))
  207|      0|                            completionHandler(.failure(error))
  208|      0|                        }
  209|      0|                        return
  210|      0|                    }
  211|      0|
  212|      0|                    options.callbackQueue.execute {
  213|      0|                        let result = ImageLoadingResult(image: image, url: nil, originalData: data)
  214|      0|                        completionHandler(.success(result))
  215|      0|                    }
  216|      0|                }
  217|      0|            case .failure(let error):
  218|      0|                options.callbackQueue.execute {
  219|      0|                    let error = KingfisherError.imageSettingError(
  220|      0|                        reason: .dataProviderError(provider: provider, error: error))
  221|      0|                    completionHandler(.failure(error))
  222|      0|                }
  223|      0|
  224|      0|            }
  225|      0|        }
  226|      0|    }
  227|       |
  228|       |    @discardableResult
  229|       |    func loadAndCacheImage(
  230|       |        source: Source,
  231|       |        options: KingfisherParsedOptionsInfo,
  232|       |        progressBlock: DownloadProgressBlock? = nil,
  233|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> DownloadTask?
  234|      0|    {
  235|      0|        func cacheImage(_ result: Result<ImageLoadingResult, KingfisherError>)
  236|      0|        {
  237|      0|            switch result {
  238|      0|            case .success(let value):
  239|      0|                // Add image to cache.
  240|      0|                let targetCache = options.targetCache ?? self.cache
  241|      0|                targetCache.store(
  242|      0|                    value.image,
  243|      0|                    original: value.originalData,
  244|      0|                    forKey: source.cacheKey,
  245|      0|                    options: options,
  246|      0|                    toDisk: !options.cacheMemoryOnly)
  247|      0|                {
  248|      0|                    _ in
  249|      0|                    if options.waitForCache {
  250|      0|                        let result = RetrieveImageResult(image: value.image, cacheType: .none, source: source)
  251|      0|                        completionHandler?(.success(result))
  252|      0|                    }
  253|      0|                }
  254|      0|
  255|      0|                // Add original image to cache if necessary.
  256|      0|                let needToCacheOriginalImage = options.cacheOriginalImage &&
  257|      0|                    options.processor != DefaultImageProcessor.default
  258|      0|                if needToCacheOriginalImage {
  259|      0|                    let originalCache = options.originalCache ?? targetCache
  260|      0|                    originalCache.storeToDisk(
  261|      0|                        value.originalData,
  262|      0|                        forKey: source.cacheKey,
  263|      0|                        processorIdentifier: DefaultImageProcessor.default.identifier,
  264|      0|                        expiration: options.diskCacheExpiration)
  265|      0|                }
  266|      0|
  267|      0|                if !options.waitForCache {
  268|      0|                    let result = RetrieveImageResult(image: value.image, cacheType: .none, source: source)
  269|      0|                    completionHandler?(.success(result))
  270|      0|                }
  271|      0|            case .failure(let error):
  272|      0|                completionHandler?(.failure(error))
  273|      0|            }
  274|      0|        }
  275|      0|
  276|      0|        switch source {
  277|      0|        case .network(let resource):
  278|      0|            let downloader = options.downloader ?? self.downloader
  279|      0|            return downloader.downloadImage(
  280|      0|                with: resource.downloadURL,
  281|      0|                options: options,
  282|      0|                progressBlock: progressBlock,
  283|      0|                completionHandler: cacheImage)
  284|      0|        case .provider(let provider):
  285|      0|            provideImage(provider: provider, options: options, completionHandler: cacheImage)
  286|      0|            return nil
  287|      0|        }
  288|      0|    }
  289|       |    
  290|       |    /// Retrieves image from memory or disk cache.
  291|       |    ///
  292|       |    /// - Parameters:
  293|       |    ///   - source: The target source from which to get image.
  294|       |    ///   - key: The key to use when caching the image.
  295|       |    ///   - url: Image request URL. This is not used when retrieving image from cache. It is just used for
  296|       |    ///          `RetrieveImageResult` callback compatibility.
  297|       |    ///   - options: Options on how to get the image from image cache.
  298|       |    ///   - completionHandler: Called when the image retrieving finishes, either with succeeded
  299|       |    ///                        `RetrieveImageResult` or an error.
  300|       |    /// - Returns: `true` if the requested image or the original image before being processed is existing in cache.
  301|       |    ///            Otherwise, this method returns `false`.
  302|       |    ///
  303|       |    /// - Note:
  304|       |    ///    The image retrieving could happen in either memory cache or disk cache. The `.processor` option in
  305|       |    ///    `options` will be considered when searching in the cache. If no processed image is found, Kingfisher
  306|       |    ///    will try to check whether an original version of that image is existing or not. If there is already an
  307|       |    ///    original, Kingfisher retrieves it from cache and processes it. Then, the processed image will be store
  308|       |    ///    back to cache for later use.
  309|       |    func retrieveImageFromCache(
  310|       |        source: Source,
  311|       |        options: KingfisherParsedOptionsInfo,
  312|       |        completionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void)?) -> Bool
  313|      0|    {
  314|      0|        // 1. Check whether the image was already in target cache. If so, just get it.
  315|      0|        let targetCache = options.targetCache ?? cache
  316|      0|        let key = source.cacheKey
  317|      0|        let targetImageCached = targetCache.imageCachedType(
  318|      0|            forKey: key, processorIdentifier: options.processor.identifier)
  319|      0|        
  320|      0|        let validCache = targetImageCached.cached &&
  321|      0|            (options.fromMemoryCacheOrRefresh == false || targetImageCached == .memory)
  322|      0|        if validCache {
  323|      0|            targetCache.retrieveImage(forKey: key, options: options) { result in
  324|      0|                guard let completionHandler = completionHandler else { return }
  325|      0|                options.callbackQueue.execute {
  326|      0|                    if let image = result.value?.image {
  327|      0|                        let value = result.map {
  328|      0|                            RetrieveImageResult(image: image, cacheType: $0.cacheType, source: source)
  329|      0|                        }
  330|      0|                        completionHandler(value)
  331|      0|                    } else {
  332|      0|                        completionHandler(.failure(KingfisherError.cacheError(reason: .imageNotExisting(key: key))))
  333|      0|                    }
  334|      0|                }
  335|      0|            }
  336|      0|            return true
  337|      0|        }
  338|      0|
  339|      0|        // 2. Check whether the original image exists. If so, get it, process it, save to storage and return.
  340|      0|        let originalCache = options.originalCache ?? targetCache
  341|      0|        // No need to store the same file in the same cache again.
  342|      0|        if originalCache === targetCache && options.processor == DefaultImageProcessor.default {
  343|      0|            return false
  344|      0|        }
  345|      0|
  346|      0|        // Check whether the unprocessed image existing or not.
  347|      0|        let originalImageCached = originalCache.imageCachedType(
  348|      0|            forKey: key, processorIdentifier: DefaultImageProcessor.default.identifier).cached
  349|      0|        if originalImageCached {
  350|      0|            // Now we are ready to get found the original image from cache. We need the unprocessed image, so remove
  351|      0|            // any processor from options first.
  352|      0|            var optionsWithoutProcessor = options
  353|      0|            optionsWithoutProcessor.processor = DefaultImageProcessor.default
  354|      0|            originalCache.retrieveImage(forKey: key, options: optionsWithoutProcessor) { result in
  355|      0|                if let image = result.value?.image {
  356|      0|                    let processor = options.processor
  357|      0|                    (options.processingQueue ?? self.processingQueue).execute {
  358|      0|                        let item = ImageProcessItem.image(image)
  359|      0|                        guard let processedImage = processor.process(item: item, options: options) else {
  360|      0|                            let error = KingfisherError.processorError(
  361|      0|                                            reason: .processingFailed(processor: processor, item: item))
  362|      0|                            options.callbackQueue.execute { completionHandler?(.failure(error)) }
  363|      0|                            return
  364|      0|                        }
  365|      0|
  366|      0|                        var cacheOptions = options
  367|      0|                        cacheOptions.callbackQueue = .untouch
  368|      0|                        targetCache.store(
  369|      0|                            processedImage,
  370|      0|                            forKey: key,
  371|      0|                            options: cacheOptions,
  372|      0|                            toDisk: !options.cacheMemoryOnly)
  373|      0|                        {
  374|      0|                            _ in
  375|      0|                            if options.waitForCache {
  376|      0|                                let value = RetrieveImageResult(image: processedImage, cacheType: .none, source: source)
  377|      0|                                options.callbackQueue.execute { completionHandler?(.success(value)) }
  378|      0|                            }
  379|      0|                        }
  380|      0|
  381|      0|                        if !options.waitForCache {
  382|      0|                            let value = RetrieveImageResult(image: processedImage, cacheType: .none, source: source)
  383|      0|                            options.callbackQueue.execute { completionHandler?(.success(value)) }
  384|      0|                        }
  385|      0|                    }
  386|      0|                } else {
  387|      0|                    // This should not happen actually, since we already confirmed `originalImageCached` is `true`.
  388|      0|                    // Just in case...
  389|      0|                    options.callbackQueue.execute {
  390|      0|                        completionHandler?(.failure(KingfisherError.cacheError(reason: .imageNotExisting(key: key))))
  391|      0|                    }
  392|      0|                }
  393|      0|            }
  394|      0|            return true
  395|      0|        }
  396|      0|
  397|      0|        return false
  398|      0|
  399|      0|    }
  400|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/General/KingfisherOptionsInfo.swift:
    1|       |//
    2|       |//  KingfisherOptionsInfo.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/23.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |import AppKit
   29|       |#else
   30|       |import UIKit
   31|       |#endif
   32|       |    
   33|       |
   34|       |/// KingfisherOptionsInfo is a typealias for [KingfisherOptionsInfoItem].
   35|       |/// You can use the enum of option item with value to control some behaviors of Kingfisher.
   36|       |public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]
   37|       |
   38|       |extension Array where Element == KingfisherOptionsInfoItem {
   39|       |    static let empty: KingfisherOptionsInfo = []
   40|       |}
   41|       |
   42|       |/// Represents the available option items could be used in `KingfisherOptionsInfo`.
   43|       |public enum KingfisherOptionsInfoItem {
   44|       |    
   45|       |    /// Kingfisher will use the associated `ImageCache` object when handling related operations,
   46|       |    /// including trying to retrieve the cached images and store the downloaded image to it.
   47|       |    case targetCache(ImageCache)
   48|       |    
   49|       |    /// The `ImageCache` for storing and retrieving original images. If `originalCache` is
   50|       |    /// contained in the options, it will be preferred for storing and retrieving original images.
   51|       |    /// If there is no `.originalCache` in the options, `.targetCache` will be used to store original images.
   52|       |    ///
   53|       |    /// When using KingfisherManager to download and store an image, if `cacheOriginalImage` is
   54|       |    /// applied in the option, the original image will be stored to this `originalCache`. At the
   55|       |    /// same time, if a requested final image (with processor applied) cannot be found in `targetCache`,
   56|       |    /// Kingfisher will try to search the original image to check whether it is already there. If found,
   57|       |    /// it will be used and applied with the given processor. It is an optimization for not downloading
   58|       |    /// the same image for multiple times.
   59|       |    case originalCache(ImageCache)
   60|       |    
   61|       |    /// Kingfisher will use the associated `ImageDownloader` object to download the requested images.
   62|       |    case downloader(ImageDownloader)
   63|       |
   64|       |    /// Member for animation transition when using `UIImageView`. Kingfisher will use the `ImageTransition` of
   65|       |    /// this enum to animate the image in if it is downloaded from web. The transition will not happen when the
   66|       |    /// image is retrieved from either memory or disk cache by default. If you need to do the transition even when
   67|       |    /// the image being retrieved from cache, set `.forceRefresh` as well.
   68|       |    case transition(ImageTransition)
   69|       |    
   70|       |    /// Associated `Float` value will be set as the priority of image download task. The value for it should be
   71|       |    /// between 0.0~1.0. If this option not set, the default value (`URLSessionTask.defaultPriority`) will be used.
   72|       |    case downloadPriority(Float)
   73|       |    
   74|       |    /// If set, Kingfisher will ignore the cache and try to fire a download task for the resource.
   75|       |    case forceRefresh
   76|       |
   77|       |    /// If set, Kingfisher will try to retrieve the image from memory cache first. If the image is not in memory
   78|       |    /// cache, then it will ignore the disk cache but download the image again from network. This is useful when
   79|       |    /// you want to display a changeable image behind the same url at the same app session, while avoiding download
   80|       |    /// it for multiple times.
   81|       |    case fromMemoryCacheOrRefresh
   82|       |    
   83|       |    /// If set, setting the image to an image view will happen with transition even when retrieved from cache.
   84|       |    /// See `.transition` option for more.
   85|       |    case forceTransition
   86|       |    
   87|       |    ///  If set, Kingfisher will only cache the value in memory but not in disk.
   88|       |    case cacheMemoryOnly
   89|       |    
   90|       |    ///  If set, Kingfisher will wait for caching operation to be completed before calling the completion block.
   91|       |    case waitForCache
   92|       |    
   93|       |    /// If set, Kingfisher will only try to retrieve the image from cache, but not from network. If the image is
   94|       |    /// not in cache, the image retrieving will fail with an error.
   95|       |    case onlyFromCache
   96|       |    
   97|       |    /// Decode the image in background thread before using. It will decode the downloaded image data and do a off-screen
   98|       |    /// rendering to extract pixel information in background. This can speed up display, but will cost more time to
   99|       |    /// prepare the image for using.
  100|       |    case backgroundDecode
  101|       |    
  102|       |    /// The associated value of this member will be used as the target queue of dispatch callbacks when
  103|       |    /// retrieving images from cache. If not set, Kingfisher will use main queue for callbacks.
  104|       |    @available(*, deprecated, message: "Use `.callbackQueue(CallbackQueue)` instead.")
  105|       |    case callbackDispatchQueue(DispatchQueue?)
  106|       |
  107|       |    /// The associated value will be used as the target queue of dispatch callbacks when retrieving images from
  108|       |    /// cache. If not set, Kingfisher will use `.mainCurrentOrAsync` for callbacks.
  109|       |    ///
  110|       |    /// - Note:
  111|       |    /// This option does not affect the callbacks for UI related extension methods. You will always get the
  112|       |    /// callbacks called from main queue.
  113|       |    case callbackQueue(CallbackQueue)
  114|       |    
  115|       |    /// The associated value will be used as the scale factor when converting retrieved data to an image.
  116|       |    /// Specify the image scale, instead of your screen scale. You may need to set the correct scale when you dealing
  117|       |    /// with 2x or 3x retina images. Otherwise, Kingfisher will convert the data to image object at `scale` 1.0.
  118|       |    case scaleFactor(CGFloat)
  119|       |
  120|       |    /// Whether all the animated image data should be preloaded. Default is `false`, which means only following frames
  121|       |    /// will be loaded on need. If `true`, all the animated image data will be loaded and decoded into memory.
  122|       |    ///
  123|       |    /// This option is mainly used for back compatibility internally. You should not set it directly. Instead,
  124|       |    /// you should choose the image view class to control the GIF data loading. There are two classes in Kingfisher
  125|       |    /// support to display a GIF image. `AnimatedImageView` does not preload all data, it takes much less memory, but
  126|       |    /// uses more CPU when display. While a normal image view (`UIImageView` or `NSImageView`) loads all data at once,
  127|       |    /// which uses more memory but only decode image frames once.
  128|       |    case preloadAllAnimationData
  129|       |    
  130|       |    /// The `ImageDownloadRequestModifier` contained will be used to change the request before it being sent.
  131|       |    /// This is the last chance you can modify the image download request. You can modify the request for some
  132|       |    /// customizing purpose, such as adding auth token to the header, do basic HTTP auth or something like url mapping.
  133|       |    /// The original request will be sent without any modification by default.
  134|       |    case requestModifier(ImageDownloadRequestModifier)
  135|       |    
  136|       |    /// The `ImageDownloadRedirectHandler` contained will be used to change the request before redirection.
  137|       |    /// This is the posibility you can modify the image download request during redirect. You can modify the request for
  138|       |    /// some customizing purpose, such as adding auth token to the header, do basic HTTP auth or something like url
  139|       |    /// mapping.
  140|       |    /// The original redirection request will be sent without any modification by default.
  141|       |    case redirectHandler(ImageDownloadRedirectHandler)
  142|       |    
  143|       |    /// Processor for processing when the downloading finishes, a processor will convert the downloaded data to an image
  144|       |    /// and/or apply some filter on it. If a cache is connected to the downloader (it happens when you are using
  145|       |    /// KingfisherManager or any of the view extension methods), the converted image will also be sent to cache as well.
  146|       |    /// If not set, the `DefaultImageProcessor.default` will be used.
  147|       |    case processor(ImageProcessor)
  148|       |    
  149|       |    /// Supplies a `CacheSerializer` to convert some data to an image object for
  150|       |    /// retrieving from disk cache or vice versa for storing to disk cache.
  151|       |    /// If not set, the `DefaultCacheSerializer.default` will be used.
  152|       |    case cacheSerializer(CacheSerializer)
  153|       |
  154|       |    /// An `ImageModifier` is for modifying an image as needed right before it is used. If the image was fetched
  155|       |    /// directly from the downloader, the modifier will run directly after the `ImageProcessor`. If the image is being
  156|       |    /// fetched from a cache, the modifier will run after the `CacheSerializer`.
  157|       |    ///
  158|       |    /// Use `ImageModifier` when you need to set properties that do not persist when caching the image on a concrete
  159|       |    /// type of `Image`, such as the `renderingMode` or the `alignmentInsets` of `UIImage`.
  160|       |    case imageModifier(ImageModifier)
  161|       |    
  162|       |    /// Keep the existing image of image view while setting another image to it.
  163|       |    /// By setting this option, the placeholder image parameter of image view extension method
  164|       |    /// will be ignored and the current image will be kept while loading or downloading the new image.
  165|       |    case keepCurrentImageWhileLoading
  166|       |    
  167|       |    /// If set, Kingfisher will only load the first frame from an animated image file as a single image.
  168|       |    /// Loading an animated images may take too much memory. It will be useful when you want to display a
  169|       |    /// static preview of the first frame from a animated image.
  170|       |    ///
  171|       |    /// This option will be ignored if the target image is not animated image data.
  172|       |    case onlyLoadFirstFrame
  173|       |    
  174|       |    /// If set and an `ImageProcessor` is used, Kingfisher will try to cache both the final result and original
  175|       |    /// image. Kingfisher will have a chance to use the original image when another processor is applied to the same
  176|       |    /// resource, instead of downloading it again. You can use `.originalCache` to specify a cache or the original
  177|       |    /// images if necessary.
  178|       |    ///
  179|       |    /// The original image will be only cached to disk storage.
  180|       |    case cacheOriginalImage
  181|       |    
  182|       |    /// If set and a downloading error occurred Kingfisher will set provided image (or empty)
  183|       |    /// in place of requested one. It's useful when you don't want to show placeholder
  184|       |    /// during loading time but wants to use some default image when requests will be failed.
  185|       |    case onFailureImage(Image?)
  186|       |    
  187|       |    /// If set and used in `ImagePrefetcher`, the prefetching operation will load the images into memory storage
  188|       |    /// aggressively. By default this is not contained in the options, that means if the requested image is already
  189|       |    /// in disk cache, Kingfisher will not try to load it to memory.
  190|       |    case alsoPrefetchToMemory
  191|       |    
  192|       |    /// If set, the disk storage loading will happen in the same calling queue. By default, disk storage file loading
  193|       |    /// happens in its own queue with an asynchronous dispatch behavior. Although it provides better non-blocking disk
  194|       |    /// loading performance, it also causes a flickering when you reload an image from disk, if the image view already
  195|       |    /// has an image set.
  196|       |    ///
  197|       |    /// Set this options will stop that flickering by keeping all loading in the same queue (typically the UI queue
  198|       |    /// if you are using Kingfisher's extension methods to set an image), with a tradeoff of loading performance.
  199|       |    case loadDiskFileSynchronously
  200|       |    
  201|       |    /// The expiration setting for memory cache. By default, the underlying `MemoryStorage.Backend` uses the
  202|       |    /// expiration in its config for all items. If set, the `MemoryStorage.Backend` will use this associated
  203|       |    /// value to overwrite the config setting for this caching item.
  204|       |    case memoryCacheExpiration(StorageExpiration)
  205|       |    
  206|       |    /// The expiration setting for memory cache. By default, the underlying `DiskStorage.Backend` uses the
  207|       |    /// expiration in its config for all items. If set, the `DiskStorage.Backend` will use this associated
  208|       |    /// value to overwrite the config setting for this caching item.
  209|       |    case diskCacheExpiration(StorageExpiration)
  210|       |    
  211|       |    /// Decides on which queue the image processing should happen. By default, Kingfisher uses a pre-defined serial
  212|       |    /// queue to process images. Use this option to change this behavior. For example, specify a `.mainCurrentOrAsync`
  213|       |    /// to let the image be processed in main queue to prevent a possible flickering (but with a possibility of
  214|       |    /// blocking the UI, especially if the processor needs a lot of time to run).
  215|       |    case processingQueue(CallbackQueue)
  216|       |}
  217|       |
  218|       |// Improve performance by parsing the input `KingfisherOptionsInfo` (self) first.
  219|       |// So we can prevent the iterating over the options array again and again.
  220|       |/// The parsed options info used across Kingfisher methods. Each property in this type corresponds a case member
  221|       |/// in `KingfisherOptionsInfoItem`. When a `KingfisherOptionsInfo` sent to Kingfisher related methods, it will be
  222|       |/// parsed and converted to a `KingfisherParsedOptionsInfo` first, and pass through the internal methods.
  223|       |public struct KingfisherParsedOptionsInfo {
  224|       |
  225|       |    public var targetCache: ImageCache? = nil
  226|       |    public var originalCache: ImageCache? = nil
  227|       |    public var downloader: ImageDownloader? = nil
  228|       |    public var transition: ImageTransition = .none
  229|       |    public var downloadPriority: Float = URLSessionTask.defaultPriority
  230|       |    public var forceRefresh = false
  231|       |    public var fromMemoryCacheOrRefresh = false
  232|       |    public var forceTransition = false
  233|       |    public var cacheMemoryOnly = false
  234|       |    public var waitForCache = false
  235|       |    public var onlyFromCache = false
  236|       |    public var backgroundDecode = false
  237|       |    public var preloadAllAnimationData = false
  238|       |    public var callbackQueue: CallbackQueue = .mainCurrentOrAsync
  239|       |    public var scaleFactor: CGFloat = 1.0
  240|       |    public var requestModifier: ImageDownloadRequestModifier? = nil
  241|       |    public var redirectHandler: ImageDownloadRedirectHandler? = nil
  242|       |    public var processor: ImageProcessor = DefaultImageProcessor.default
  243|       |    public var imageModifier: ImageModifier? = nil
  244|       |    public var cacheSerializer: CacheSerializer = DefaultCacheSerializer.default
  245|       |    public var keepCurrentImageWhileLoading = false
  246|       |    public var onlyLoadFirstFrame = false
  247|       |    public var cacheOriginalImage = false
  248|       |    public var onFailureImage: Optional<Image?> = .none
  249|       |    public var alsoPrefetchToMemory = false
  250|       |    public var loadDiskFileSynchronously = false
  251|       |    public var memoryCacheExpiration: StorageExpiration? = nil
  252|       |    public var diskCacheExpiration: StorageExpiration? = nil
  253|       |    public var processingQueue: CallbackQueue? = nil
  254|       |
  255|      0|    public init(_ info: KingfisherOptionsInfo?) {
  256|      0|        guard let info = info else { return }
  257|      0|        for option in info {
  258|      0|            switch option {
  259|      0|            case .targetCache(let value): targetCache = value
  260|      0|            case .originalCache(let value): originalCache = value
  261|      0|            case .downloader(let value): downloader = value
  262|      0|            case .transition(let value): transition = value
  263|      0|            case .downloadPriority(let value): downloadPriority = value
  264|      0|            case .forceRefresh: forceRefresh = true
  265|      0|            case .fromMemoryCacheOrRefresh: fromMemoryCacheOrRefresh = true
  266|      0|            case .forceTransition: forceTransition = true
  267|      0|            case .cacheMemoryOnly: cacheMemoryOnly = true
  268|      0|            case .waitForCache: waitForCache = true
  269|      0|            case .onlyFromCache: onlyFromCache = true
  270|      0|            case .backgroundDecode: backgroundDecode = true
  271|      0|            case .preloadAllAnimationData: preloadAllAnimationData = true
  272|      0|            case .callbackQueue(let value): callbackQueue = value
  273|      0|            case .scaleFactor(let value): scaleFactor = value
  274|      0|            case .requestModifier(let value): requestModifier = value
  275|      0|            case .redirectHandler(let value): redirectHandler = value
  276|      0|            case .processor(let value): processor = value
  277|      0|            case .imageModifier(let value): imageModifier = value
  278|      0|            case .cacheSerializer(let value): cacheSerializer = value
  279|      0|            case .keepCurrentImageWhileLoading: keepCurrentImageWhileLoading = true
  280|      0|            case .onlyLoadFirstFrame: onlyLoadFirstFrame = true
  281|      0|            case .cacheOriginalImage: cacheOriginalImage = true
  282|      0|            case .onFailureImage(let value): onFailureImage = .some(value)
  283|      0|            case .alsoPrefetchToMemory: alsoPrefetchToMemory = true
  284|      0|            case .loadDiskFileSynchronously: loadDiskFileSynchronously = true
  285|      0|            case .callbackDispatchQueue(let value): callbackQueue = value.map { .dispatch($0) } ?? .mainCurrentOrAsync
  286|      0|            case .memoryCacheExpiration(let expiration): memoryCacheExpiration = expiration
  287|      0|            case .diskCacheExpiration(let expiration): diskCacheExpiration = expiration
  288|      0|            case .processingQueue(let queue): processingQueue = queue
  289|      0|            }
  290|      0|        }
  291|      0|
  292|      0|        if originalCache == nil {
  293|      0|            originalCache = targetCache
  294|      0|        }
  295|      0|    }
  296|       |}
  297|       |
  298|       |extension KingfisherParsedOptionsInfo {
  299|      0|    var imageCreatingOptions: ImageCreatingOptions {
  300|      0|        return ImageCreatingOptions(
  301|      0|            scale: scaleFactor,
  302|      0|            duration: 0.0,
  303|      0|            preloadAll: preloadAllAnimationData,
  304|      0|            onlyFirstFrame: onlyLoadFirstFrame)
  305|      0|    }
  306|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Image/Filter.swift:
    1|       |//
    2|       |//  Filter.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2016/08/31.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import CoreImage
   28|       |
   29|       |// Reuse the same CI Context for all CI drawing.
   30|       |private let ciContext = CIContext(options: nil)
   31|       |
   32|       |/// Represents the type of transformer method, which will be used in to provide a `Filter`.
   33|       |public typealias Transformer = (CIImage) -> CIImage?
   34|       |
   35|       |/// Represents a processor based on a `CIImage` `Filter`.
   36|       |/// It requires a filter to create an `ImageProcessor`.
   37|       |public protocol CIImageProcessor: ImageProcessor {
   38|       |    var filter: Filter { get }
   39|       |}
   40|       |
   41|       |extension CIImageProcessor {
   42|       |    
   43|       |    /// Processes the input `ImageProcessItem` with this processor.
   44|       |    ///
   45|       |    /// - Parameters:
   46|       |    ///   - item: Input item which will be processed by `self`.
   47|       |    ///   - options: Options when processing the item.
   48|       |    /// - Returns: The processed image.
   49|       |    ///
   50|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
   51|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
   52|      0|        switch item {
   53|      0|        case .image(let image):
   54|      0|            return image.kf.apply(filter)
   55|      0|        case .data:
   56|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
   57|      0|        }
   58|      0|    }
   59|       |}
   60|       |
   61|       |/// A wrapper struct for a `Transformer` of CIImage filters. A `Filter`
   62|       |/// value could be used to create a `CIImage` processor.
   63|       |public struct Filter {
   64|       |    
   65|       |    let transform: Transformer
   66|       |
   67|      0|    public init(transform: @escaping Transformer) {
   68|      0|        self.transform = transform
   69|      0|    }
   70|       |    
   71|       |    /// Tint filter which will apply a tint color to images.
   72|      0|    public static var tint: (Color) -> Filter = {
   73|      0|        color in
   74|      0|        Filter {
   75|      0|            input in
   76|      0|            
   77|      0|            let colorFilter = CIFilter(name: "CIConstantColorGenerator")!
   78|      0|            colorFilter.setValue(CIColor(color: color), forKey: kCIInputColorKey)
   79|      0|            
   80|      0|            let filter = CIFilter(name: "CISourceOverCompositing")!
   81|      0|            
   82|      0|            let colorImage = colorFilter.outputImage
   83|      0|            filter.setValue(colorImage, forKey: kCIInputImageKey)
   84|      0|            filter.setValue(input, forKey: kCIInputBackgroundImageKey)
   85|      0|            
   86|      0|            return filter.outputImage?.cropped(to: input.extent)
   87|      0|        }
   88|      0|    }
   89|       |    
   90|       |    /// Represents color control elements. It is a tuple of
   91|       |    /// `(brightness, contrast, saturation, inputEV)`
   92|       |    public typealias ColorElement = (CGFloat, CGFloat, CGFloat, CGFloat)
   93|       |    
   94|       |    /// Color control filter which will apply color control change to images.
   95|      0|    public static var colorControl: (ColorElement) -> Filter = { arg -> Filter in
   96|      0|        let (brightness, contrast, saturation, inputEV) = arg
   97|      0|        return Filter { input in
   98|      0|            let paramsColor = [kCIInputBrightnessKey: brightness,
   99|      0|                               kCIInputContrastKey: contrast,
  100|      0|                               kCIInputSaturationKey: saturation]
  101|      0|            let blackAndWhite = input.applyingFilter("CIColorControls", parameters: paramsColor)
  102|      0|            let paramsExposure = [kCIInputEVKey: inputEV]
  103|      0|            return blackAndWhite.applyingFilter("CIExposureAdjust", parameters: paramsExposure)
  104|      0|        }
  105|      0|    }
  106|       |}
  107|       |
  108|       |extension KingfisherWrapper where Base: Image {
  109|       |
  110|       |    /// Applies a `Filter` containing `CIImage` transformer to `self`.
  111|       |    ///
  112|       |    /// - Parameter filter: The filter used to transform `self`.
  113|       |    /// - Returns: A transformed image by input `Filter`.
  114|       |    ///
  115|       |    /// - Note:
  116|       |    ///    Only CG-based images are supported. If any error happens
  117|       |    ///    during transforming, `self` will be returned.
  118|      0|    public func apply(_ filter: Filter) -> Image {
  119|      0|        
  120|      0|        guard let cgImage = cgImage else {
  121|      0|            assertionFailure("[Kingfisher] Tint image only works for CG-based image.")
  122|      0|            return base
  123|      0|        }
  124|      0|        
  125|      0|        let inputImage = CIImage(cgImage: cgImage)
  126|      0|        guard let outputImage = filter.transform(inputImage) else {
  127|      0|            return base
  128|      0|        }
  129|      0|
  130|      0|        guard let result = ciContext.createCGImage(outputImage, from: outputImage.extent) else {
  131|      0|            assertionFailure("[Kingfisher] Can not make an tint image within context.")
  132|      0|            return base
  133|      0|        }
  134|      0|        
  135|      0|        #if os(macOS)
  136|      0|            return fixedForRetinaPixel(cgImage: result, to: size)
  137|      0|        #else
  138|      0|            return Image(cgImage: result, scale: base.scale, orientation: base.imageOrientation)
  139|      0|        #endif
  140|      0|    }
  141|       |
  142|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Image/GIFAnimatedImage.swift:
    1|       |//
    2|       |//  AnimatedImage.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/09/26.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |import ImageIO
   29|       |
   30|       |/// Represents a set of image creating options used in Kingfisher.
   31|       |public struct ImageCreatingOptions {
   32|       |
   33|       |    /// The target scale of image needs to be created.
   34|       |    public let scale: CGFloat
   35|       |
   36|       |    /// The expected animation duration if an animated image being created.
   37|       |    public let duration: TimeInterval
   38|       |
   39|       |    /// For an animated image, whether or not all frames should be loaded before displaying.
   40|       |    public let preloadAll: Bool
   41|       |
   42|       |    /// For an animated image, whether or not only the first image should be
   43|       |    /// loaded as a static image. It is useful for preview purpose of an animated image.
   44|       |    public let onlyFirstFrame: Bool
   45|       |    
   46|       |    /// Creates an `ImageCreatingOptions` object.
   47|       |    ///
   48|       |    /// - Parameters:
   49|       |    ///   - scale: The target scale of image needs to be created. Default is `1.0`.
   50|       |    ///   - duration: The expected animation duration if an animated image being created.
   51|       |    ///               A value less or equal to `0.0` means the animated image duration will
   52|       |    ///               be determined by the frame data. Default is `0.0`.
   53|       |    ///   - preloadAll: For an animated image, whether or not all frames should be loaded before displaying.
   54|       |    ///                 Default is `false`.
   55|       |    ///   - onlyFirstFrame: For an animated image, whether or not only the first image should be
   56|       |    ///                     loaded as a static image. It is useful for preview purpose of an animated image.
   57|       |    ///                     Default is `false`.
   58|       |    public init(
   59|       |        scale: CGFloat = 1.0,
   60|       |        duration: TimeInterval = 0.0,
   61|       |        preloadAll: Bool = false,
   62|       |        onlyFirstFrame: Bool = false)
   63|      0|    {
   64|      0|        self.scale = scale
   65|      0|        self.duration = duration
   66|      0|        self.preloadAll = preloadAll
   67|      0|        self.onlyFirstFrame = onlyFirstFrame
   68|      0|    }
   69|       |}
   70|       |
   71|       |// Represents the decoding for a GIF image. This class extracts frames from an `imageSource`, then
   72|       |// hold the images for later use.
   73|       |class GIFAnimatedImage {
   74|       |    let images: [Image]
   75|       |    let duration: TimeInterval
   76|       |    
   77|      0|    init?(from imageSource: CGImageSource, for info: [String: Any], options: ImageCreatingOptions) {
   78|      0|        let frameCount = CGImageSourceGetCount(imageSource)
   79|      0|        var images = [Image]()
   80|      0|        var gifDuration = 0.0
   81|      0|        
   82|      0|        for i in 0 ..< frameCount {
   83|      0|            guard let imageRef = CGImageSourceCreateImageAtIndex(imageSource, i, info as CFDictionary) else {
   84|      0|                return nil
   85|      0|            }
   86|      0|            
   87|      0|            if frameCount == 1 {
   88|      0|                gifDuration = .infinity
   89|      0|            } else {
   90|      0|                // Get current animated GIF frame duration
   91|      0|                gifDuration += GIFAnimatedImage.getFrameDuration(from: imageSource, at: i)
   92|      0|            }
   93|      0|            images.append(KingfisherWrapper.image(cgImage: imageRef, scale: options.scale, refImage: nil))
   94|      0|            if options.onlyFirstFrame { break }
   95|      0|        }
   96|      0|        self.images = images
   97|      0|        self.duration = gifDuration
   98|      0|    }
   99|       |    
  100|       |    // Calculates frame duration for a gif frame out of the kCGImagePropertyGIFDictionary dictionary.
  101|      0|    static func getFrameDuration(from gifInfo: [String: Any]?) -> TimeInterval {
  102|      0|        let defaultFrameDuration = 0.1
  103|      0|        guard let gifInfo = gifInfo else { return defaultFrameDuration }
  104|      0|        
  105|      0|        let unclampedDelayTime = gifInfo[kCGImagePropertyGIFUnclampedDelayTime as String] as? NSNumber
  106|      0|        let delayTime = gifInfo[kCGImagePropertyGIFDelayTime as String] as? NSNumber
  107|      0|        let duration = unclampedDelayTime ?? delayTime
  108|      0|        
  109|      0|        guard let frameDuration = duration else { return defaultFrameDuration }
  110|      0|        return frameDuration.doubleValue > 0.011 ? frameDuration.doubleValue : defaultFrameDuration
  111|      0|    }
  112|       |
  113|       |    // Calculates frame duration at a specific index for a gif from an `imageSource`.
  114|      0|    static func getFrameDuration(from imageSource: CGImageSource, at index: Int) -> TimeInterval {
  115|      0|        guard let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, index, nil)
  116|      0|            as? [String: Any] else { return 0.0 }
  117|      0|
  118|      0|        let gifInfo = properties[kCGImagePropertyGIFDictionary as String] as? [String: Any]
  119|      0|        return getFrameDuration(from: gifInfo)
  120|      0|    }
  121|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Image/Image.swift:
    1|       |//
    2|       |//  Image.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 16/1/6.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |
   28|       |#if os(macOS)
   29|       |import AppKit
   30|       |private var imagesKey: Void?
   31|       |private var durationKey: Void?
   32|       |#else
   33|       |import UIKit
   34|       |import MobileCoreServices
   35|       |private var imageSourceKey: Void?
   36|       |#endif
   37|       |
   38|       |#if !os(watchOS)
   39|       |import CoreImage
   40|       |#endif
   41|       |
   42|       |import CoreGraphics
   43|       |import ImageIO
   44|       |
   45|       |private var animatedImageDataKey: Void?
   46|       |
   47|       |// MARK: - Image Properties
   48|       |extension KingfisherWrapper where Base: Image {
   49|       |    private(set) var animatedImageData: Data? {
   50|      0|        get { return getAssociatedObject(base, &animatedImageDataKey) }
   51|      0|        set { setRetainedAssociatedObject(base, &animatedImageDataKey, newValue) }
   52|       |    }
   53|       |    
   54|       |    #if os(macOS)
   55|       |    var cgImage: CGImage? {
   56|       |        return base.cgImage(forProposedRect: nil, context: nil, hints: nil)
   57|       |    }
   58|       |    
   59|       |    var scale: CGFloat {
   60|       |        return 1.0
   61|       |    }
   62|       |    
   63|       |    private(set) var images: [Image]? {
   64|       |        get { return getAssociatedObject(base, &imagesKey) }
   65|       |        set { setRetainedAssociatedObject(base, &imagesKey, newValue) }
   66|       |    }
   67|       |    
   68|       |    private(set) var duration: TimeInterval {
   69|       |        get { return getAssociatedObject(base, &durationKey) ?? 0.0 }
   70|       |        set { setRetainedAssociatedObject(base, &durationKey, newValue) }
   71|       |    }
   72|       |    
   73|       |    var size: CGSize {
   74|       |        return base.representations.reduce(.zero) { size, rep in
   75|       |            let width = max(size.width, CGFloat(rep.pixelsWide))
   76|       |            let height = max(size.height, CGFloat(rep.pixelsHigh))
   77|       |            return CGSize(width: width, height: height)
   78|       |        }
   79|       |    }
   80|       |    #else
   81|      0|    var cgImage: CGImage? { return base.cgImage }
   82|      0|    var scale: CGFloat { return base.scale }
   83|      0|    var images: [Image]? { return base.images }
   84|      0|    var duration: TimeInterval { return base.duration }
   85|      0|    var size: CGSize { return base.size }
   86|       |    
   87|       |    private(set) var imageSource: CGImageSource? {
   88|      0|        get { return getAssociatedObject(base, &imageSourceKey) }
   89|      0|        set { setRetainedAssociatedObject(base, &imageSourceKey, newValue) }
   90|       |    }
   91|       |    #endif
   92|       |
   93|       |    // Bitmap memory cost with bytes.
   94|      0|    var cost: Int {
   95|      0|        let pixel = Int(size.width * size.height * scale * scale)
   96|      0|        guard let cgImage = cgImage else {
   97|      0|            return pixel * 4
   98|      0|        }
   99|      0|        return pixel * cgImage.bitsPerPixel / 8
  100|      0|    }
  101|       |}
  102|       |
  103|       |// MARK: - Image Conversion
  104|       |extension KingfisherWrapper where Base: Image {
  105|       |    #if os(macOS)
  106|       |    static func image(cgImage: CGImage, scale: CGFloat, refImage: Image?) -> Image {
  107|       |        return Image(cgImage: cgImage, size: .zero)
  108|       |    }
  109|       |    
  110|       |    /// Normalize the image. This getter does nothing on macOS but return the image itself.
  111|       |    public var normalized: Image { return base }
  112|       |
  113|       |    #else
  114|       |    /// Creating an image from a give `CGImage` at scale and orientation for refImage. The method signature is for
  115|       |    /// compatibility of macOS version.
  116|      0|    static func image(cgImage: CGImage, scale: CGFloat, refImage: Image?) -> Image {
  117|      0|        return Image(cgImage: cgImage, scale: scale, orientation: refImage?.imageOrientation ?? .up)
  118|      0|    }
  119|       |    
  120|       |    /// Returns normalized image for current `base` image.
  121|       |    /// This method will try to redraw an image with orientation and scale considered.
  122|      0|    public var normalized: Image {
  123|      0|        // prevent animated image (GIF) lose it's images
  124|      0|        guard images == nil else { return base }
  125|      0|        // No need to do anything if already up
  126|      0|        guard base.imageOrientation != .up else { return base }
  127|      0|    
  128|      0|        return draw(to: size) { _ in
  129|      0|            base.draw(in: CGRect(origin: .zero, size: size))
  130|      0|        }
  131|      0|    }
  132|       |    #endif
  133|       |}
  134|       |
  135|       |// MARK: - Image Representation
  136|       |extension KingfisherWrapper where Base: Image {
  137|       |    /// Returns PNG representation of `base` image.
  138|       |    ///
  139|       |    /// - Returns: PNG data of image.
  140|      0|    public func pngRepresentation() -> Data? {
  141|      0|        #if os(macOS)
  142|      0|            guard let cgImage = cgImage else {
  143|      0|                return nil
  144|      0|            }
  145|      0|            let rep = NSBitmapImageRep(cgImage: cgImage)
  146|      0|            return rep.representation(using: .png, properties: [:])
  147|      0|        #else
  148|      0|            #if swift(>=4.2)
  149|      0|            return base.pngData()
  150|      0|            #else
  151|      0|            return UIImagePNGRepresentation(base)
  152|      0|            #endif
  153|      0|        #endif
  154|      0|    }
  155|       |
  156|       |    /// Returns JPEG representation of `base` image.
  157|       |    ///
  158|       |    /// - Parameter compressionQuality: The compression quality when converting image to JPEG data.
  159|       |    /// - Returns: JPEG data of image.
  160|      0|    public func jpegRepresentation(compressionQuality: CGFloat) -> Data? {
  161|      0|        #if os(macOS)
  162|      0|            guard let cgImage = cgImage else {
  163|      0|                return nil
  164|      0|            }
  165|      0|            let rep = NSBitmapImageRep(cgImage: cgImage)
  166|      0|            return rep.representation(using:.jpeg, properties: [.compressionFactor: compressionQuality])
  167|      0|        #else
  168|      0|            #if swift(>=4.2)
  169|      0|            return base.jpegData(compressionQuality: compressionQuality)
  170|      0|            #else
  171|      0|            return UIImageJPEGRepresentation(base, compressionQuality)
  172|      0|            #endif
  173|      0|        #endif
  174|      0|    }
  175|       |
  176|       |    /// Returns GIF representation of `base` image.
  177|       |    ///
  178|       |    /// - Returns: Original GIF data of image.
  179|      0|    public func gifRepresentation() -> Data? {
  180|      0|        return animatedImageData
  181|      0|    }
  182|       |}
  183|       |
  184|       |// MARK: - Creating Images
  185|       |extension KingfisherWrapper where Base: Image {
  186|       |
  187|       |    /// Creates an animated image from a given data and options. Currently only GIF data is supported.
  188|       |    ///
  189|       |    /// - Parameters:
  190|       |    ///   - data: The animated image data.
  191|       |    ///   - options: Options to use when creating the animated image.
  192|       |    /// - Returns: An `Image` object represents the animated image. It is in form of an array of image frames with a
  193|       |    ///            certain duration. `nil` if anything wrong when creating animated image.
  194|      0|    public static func animatedImage(data: Data, options: ImageCreatingOptions) -> Image? {
  195|      0|        let info: [String: Any] = [
  196|      0|            kCGImageSourceShouldCache as String: true,
  197|      0|            kCGImageSourceTypeIdentifierHint as String: kUTTypeGIF
  198|      0|        ]
  199|      0|        
  200|      0|        guard let imageSource = CGImageSourceCreateWithData(data as CFData, info as CFDictionary) else {
  201|      0|            return nil
  202|      0|        }
  203|      0|        
  204|      0|        #if os(macOS)
  205|      0|        guard let animatedImage = GIFAnimatedImage(from: imageSource, for: info, options: options) else {
  206|      0|            return nil
  207|      0|        }
  208|      0|        let image: Image?
  209|      0|        if options.onlyFirstFrame {
  210|      0|            image = animatedImage.images.first
  211|      0|        } else {
  212|      0|            image = Image(data: data)
  213|      0|            var kf = image?.kf
  214|      0|            kf?.images = animatedImage.images
  215|      0|            kf?.duration = animatedImage.duration
  216|      0|        }
  217|      0|        image?.kf.animatedImageData = data
  218|      0|        return image
  219|      0|        #else
  220|      0|        
  221|      0|        var image: Image?
  222|      0|        if options.preloadAll || options.onlyFirstFrame {
  223|      0|            // Use `images` image if you want to preload all animated data
  224|      0|            guard let animatedImage = GIFAnimatedImage(from: imageSource, for: info, options: options) else {
  225|      0|                return nil
  226|      0|            }
  227|      0|            if options.onlyFirstFrame {
  228|      0|                image = animatedImage.images.first
  229|      0|            } else {
  230|      0|                let duration = options.duration <= 0.0 ? animatedImage.duration : options.duration
  231|      0|                image = .animatedImage(with: animatedImage.images, duration: duration)
  232|      0|            }
  233|      0|            image?.kf.animatedImageData = data
  234|      0|        } else {
  235|      0|            image = Image(data: data, scale: options.scale)
  236|      0|            var kf = image?.kf
  237|      0|            kf?.imageSource = imageSource
  238|      0|            kf?.animatedImageData = data
  239|      0|        }
  240|      0|        
  241|      0|        return image
  242|      0|        #endif
  243|      0|    }
  244|       |
  245|       |    /// Creates an image from a given data and options. `.JPEG`, `.PNG` or `.GIF` is supported. For other
  246|       |    /// image format, image initializer from system will be used. If no image object could be created from
  247|       |    /// the given `data`, `nil` will be returned.
  248|       |    ///
  249|       |    /// - Parameters:
  250|       |    ///   - data: The image data representation.
  251|       |    ///   - options: Options to use when creating the image.
  252|       |    /// - Returns: An `Image` object represents the image if created. If the `data` is invalid or not supported, `nil`
  253|       |    ///            will be returned.
  254|      0|    public static func image(data: Data, options: ImageCreatingOptions) -> Image? {
  255|      0|        var image: Image?
  256|      0|        switch data.kf.imageFormat {
  257|      0|        case .JPEG:
  258|      0|            image = Image(data: data, scale: options.scale)
  259|      0|        case .PNG:
  260|      0|            image = Image(data: data, scale: options.scale)
  261|      0|        case .GIF:
  262|      0|            image = KingfisherWrapper.animatedImage(data: data, options: options)
  263|      0|        case .unknown:
  264|      0|            image = Image(data: data, scale: options.scale)
  265|      0|        }
  266|      0|        return image
  267|      0|    }
  268|       |    
  269|       |    /// Creates a downsampled image from given data to a certain size and scale.
  270|       |    ///
  271|       |    /// - Parameters:
  272|       |    ///   - data: The image data contains a JPEG or PNG image.
  273|       |    ///   - pointSize: The target size in point to which the image should be downsampled.
  274|       |    ///   - scale: The scale of result image.
  275|       |    /// - Returns: A downsampled `Image` object following the input conditions.
  276|       |    ///
  277|       |    /// - Note:
  278|       |    /// Different from image `resize` methods, downsampling will not render the original
  279|       |    /// input image in pixel format. It does downsampling from the image data, so it is much
  280|       |    /// more memory efficient and friendly. Choose to use downsampling as possible as you can.
  281|       |    ///
  282|       |    /// The input size should be smaller than the size of input image. If it is larger than the
  283|       |    /// original image size, the result image will be the same size of input without downsampling.
  284|      0|    public static func downsampledImage(data: Data, to pointSize: CGSize, scale: CGFloat) -> Image? {
  285|      0|        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary
  286|      0|        guard let imageSource = CGImageSourceCreateWithData(data as CFData, imageSourceOptions) else {
  287|      0|            return nil
  288|      0|        }
  289|      0|        
  290|      0|        let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale
  291|      0|        let downsampleOptions = [
  292|      0|            kCGImageSourceCreateThumbnailFromImageAlways: true,
  293|      0|            kCGImageSourceShouldCacheImmediately: true,
  294|      0|            kCGImageSourceCreateThumbnailWithTransform: true,
  295|      0|            kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] as CFDictionary
  296|      0|        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else {
  297|      0|            return nil
  298|      0|        }
  299|      0|        return KingfisherWrapper.image(cgImage: downsampledImage, scale: scale, refImage: nil)
  300|      0|    }
  301|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Image/ImageDrawing.swift:
    1|       |//
    2|       |//  ImageDrawing.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/09/28.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Accelerate
   28|       |
   29|       |#if canImport(AppKit)
   30|       |import AppKit
   31|       |#endif
   32|       |#if canImport(UIKit)
   33|       |import UIKit
   34|       |#endif
   35|       |
   36|       |// MARK: - Image Transforming
   37|       |extension KingfisherWrapper where Base: Image {
   38|       |    // MARK: Blend Mode
   39|       |    /// Create image from `base` image and apply blend mode.
   40|       |    ///
   41|       |    /// - parameter blendMode:       The blend mode of creating image.
   42|       |    /// - parameter alpha:           The alpha should be used for image.
   43|       |    /// - parameter backgroundColor: The background color for the output image.
   44|       |    ///
   45|       |    /// - returns: An image with blend mode applied.
   46|       |    ///
   47|       |    /// - Note: This method only works for CG-based image.
   48|       |    #if !os(macOS)
   49|       |    public func image(withBlendMode blendMode: CGBlendMode,
   50|       |                      alpha: CGFloat = 1.0,
   51|       |                      backgroundColor: Color? = nil) -> Image
   52|      0|    {
   53|      0|        guard let _ = cgImage else {
   54|      0|            assertionFailure("[Kingfisher] Blend mode image only works for CG-based image.")
   55|      0|            return base
   56|      0|        }
   57|      0|        
   58|      0|        let rect = CGRect(origin: .zero, size: size)
   59|      0|        return draw(to: rect.size) { _ in
   60|      0|            if let backgroundColor = backgroundColor {
   61|      0|                backgroundColor.setFill()
   62|      0|                UIRectFill(rect)
   63|      0|            }
   64|      0|            
   65|      0|            base.draw(in: rect, blendMode: blendMode, alpha: alpha)
   66|      0|        }
   67|      0|    }
   68|       |    #endif
   69|       |    
   70|       |    #if os(macOS)
   71|       |    // MARK: Compositing
   72|       |    /// Creates image from `base` image and apply compositing operation.
   73|       |    ///
   74|       |    /// - Parameters:
   75|       |    ///   - compositingOperation: The compositing operation of creating image.
   76|       |    ///   - alpha: The alpha should be used for image.
   77|       |    ///   - backgroundColor: The background color for the output image.
   78|       |    /// - Returns: An image with compositing operation applied.
   79|       |    ///
   80|       |    /// - Note: This method only works for CG-based image. For any non-CG-based image, `base` itself is returned.
   81|       |    public func image(withCompositingOperation compositingOperation: NSCompositingOperation,
   82|       |                      alpha: CGFloat = 1.0,
   83|       |                      backgroundColor: Color? = nil) -> Image
   84|       |    {
   85|       |        guard let _ = cgImage else {
   86|       |            assertionFailure("[Kingfisher] Compositing Operation image only works for CG-based image.")
   87|       |            return base
   88|       |        }
   89|       |        
   90|       |        let rect = CGRect(origin: .zero, size: size)
   91|       |        return draw(to: rect.size) { _ in
   92|       |            if let backgroundColor = backgroundColor {
   93|       |                backgroundColor.setFill()
   94|       |                rect.fill()
   95|       |            }
   96|       |            base.draw(in: rect, from: .zero, operation: compositingOperation, fraction: alpha)
   97|       |        }
   98|       |    }
   99|       |    #endif
  100|       |    
  101|       |    // MARK: Round Corner
  102|       |    /// Creates a round corner image from on `base` image.
  103|       |    ///
  104|       |    /// - Parameters:
  105|       |    ///   - radius: The round corner radius of creating image.
  106|       |    ///   - size: The target size of creating image.
  107|       |    ///   - corners: The target corners which will be applied rounding.
  108|       |    ///   - backgroundColor: The background color for the output image
  109|       |    /// - Returns: An image with round corner of `self`.
  110|       |    ///
  111|       |    /// - Note: This method only works for CG-based image. The current image scale is kept.
  112|       |    ///         For any non-CG-based image, `base` itself is returned.
  113|       |    public func image(withRoundRadius radius: CGFloat,
  114|       |                      fit size: CGSize,
  115|       |                      roundingCorners corners: RectCorner = .all,
  116|       |                      backgroundColor: Color? = nil) -> Image
  117|      0|    {
  118|      0|        guard let _ = cgImage else {
  119|      0|            assertionFailure("[Kingfisher] Round corner image only works for CG-based image.")
  120|      0|            return base
  121|      0|        }
  122|      0|        
  123|      0|        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: size)
  124|      0|        return draw(to: size) { _ in
  125|      0|            #if os(macOS)
  126|      0|            if let backgroundColor = backgroundColor {
  127|      0|                let rectPath = NSBezierPath(rect: rect)
  128|      0|                backgroundColor.setFill()
  129|      0|                rectPath.fill()
  130|      0|            }
  131|      0|            
  132|      0|            let path = NSBezierPath(roundedRect: rect, byRoundingCorners: corners, radius: radius)
  133|      0|            #if swift(>=4.2)
  134|      0|            path.windingRule = .evenOdd
  135|      0|            #else
  136|      0|            path.windingRule = .evenOddWindingRule
  137|      0|            #endif
  138|      0|            path.addClip()
  139|      0|            base.draw(in: rect)
  140|      0|            #else
  141|      0|            guard let context = UIGraphicsGetCurrentContext() else {
  142|      0|                assertionFailure("[Kingfisher] Failed to create CG context for image.")
  143|      0|                return
  144|      0|            }
  145|      0|            
  146|      0|            if let backgroundColor = backgroundColor {
  147|      0|                let rectPath = UIBezierPath(rect: rect)
  148|      0|                backgroundColor.setFill()
  149|      0|                rectPath.fill()
  150|      0|            }
  151|      0|            
  152|      0|            let path = UIBezierPath(roundedRect: rect,
  153|      0|                                    byRoundingCorners: corners.uiRectCorner,
  154|      0|                                    cornerRadii: CGSize(width: radius, height: radius)).cgPath
  155|      0|            context.addPath(path)
  156|      0|            context.clip()
  157|      0|            base.draw(in: rect)
  158|      0|            #endif
  159|      0|        }
  160|      0|    }
  161|       |    
  162|       |    #if os(iOS) || os(tvOS)
  163|      0|    func resize(to size: CGSize, for contentMode: UIView.ContentMode) -> Image {
  164|      0|        switch contentMode {
  165|      0|        case .scaleAspectFit:
  166|      0|            return resize(to: size, for: .aspectFit)
  167|      0|        case .scaleAspectFill:
  168|      0|            return resize(to: size, for: .aspectFill)
  169|      0|        default:
  170|      0|            return resize(to: size)
  171|      0|        }
  172|      0|    }
  173|       |    #endif
  174|       |    
  175|       |    // MARK: Resizing
  176|       |    /// Resizes `base` image to an image with new size.
  177|       |    ///
  178|       |    /// - Parameter size: The target size in point.
  179|       |    /// - Returns: An image with new size.
  180|       |    /// - Note: This method only works for CG-based image. The current image scale is kept.
  181|       |    ///         For any non-CG-based image, `base` itself is returned.
  182|      0|    public func resize(to size: CGSize) -> Image {
  183|      0|        guard let _ = cgImage else {
  184|      0|            assertionFailure("[Kingfisher] Resize only works for CG-based image.")
  185|      0|            return base
  186|      0|        }
  187|      0|        
  188|      0|        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: size)
  189|      0|        return draw(to: size) { _ in
  190|      0|            #if os(macOS)
  191|      0|            base.draw(in: rect, from: .zero, operation: .copy, fraction: 1.0)
  192|      0|            #else
  193|      0|            base.draw(in: rect)
  194|      0|            #endif
  195|      0|        }
  196|      0|    }
  197|       |    
  198|       |    /// Resizes `base` image to an image of new size, respecting the given content mode.
  199|       |    ///
  200|       |    /// - Parameters:
  201|       |    ///   - targetSize: The target size in point.
  202|       |    ///   - contentMode: Content mode of output image should be.
  203|       |    /// - Returns: An image with new size.
  204|       |    ///
  205|       |    /// - Note: This method only works for CG-based image. The current image scale is kept.
  206|       |    ///         For any non-CG-based image, `base` itself is returned.
  207|      0|    public func resize(to targetSize: CGSize, for contentMode: ContentMode) -> Image {
  208|      0|        let newSize = size.kf.resize(to: targetSize, for: contentMode)
  209|      0|        return resize(to: newSize)
  210|      0|    }
  211|       |
  212|       |    // MARK: Cropping
  213|       |    /// Crops `base` image to a new size with a given anchor.
  214|       |    ///
  215|       |    /// - Parameters:
  216|       |    ///   - size: The target size.
  217|       |    ///   - anchor: The anchor point from which the size should be calculated.
  218|       |    /// - Returns: An image with new size.
  219|       |    ///
  220|       |    /// - Note: This method only works for CG-based image. The current image scale is kept.
  221|       |    ///         For any non-CG-based image, `base` itself is returned.
  222|      0|    public func crop(to size: CGSize, anchorOn anchor: CGPoint) -> Image {
  223|      0|        guard let cgImage = cgImage else {
  224|      0|            assertionFailure("[Kingfisher] Crop only works for CG-based image.")
  225|      0|            return base
  226|      0|        }
  227|      0|        
  228|      0|        let rect = self.size.kf.constrainedRect(for: size, anchor: anchor)
  229|      0|        guard let image = cgImage.cropping(to: rect.scaled(scale)) else {
  230|      0|            assertionFailure("[Kingfisher] Cropping image failed.")
  231|      0|            return base
  232|      0|        }
  233|      0|        
  234|      0|        return KingfisherWrapper.image(cgImage: image, scale: scale, refImage: base)
  235|      0|    }
  236|       |    
  237|       |    // MARK: Blur
  238|       |    /// Creates an image with blur effect based on `base` image.
  239|       |    ///
  240|       |    /// - Parameter radius: The blur radius should be used when creating blur effect.
  241|       |    /// - Returns: An image with blur effect applied.
  242|       |    ///
  243|       |    /// - Note: This method only works for CG-based image. The current image scale is kept.
  244|       |    ///         For any non-CG-based image, `base` itself is returned.
  245|      0|    public func blurred(withRadius radius: CGFloat) -> Image {
  246|      0|        
  247|      0|        guard let cgImage = cgImage else {
  248|      0|            assertionFailure("[Kingfisher] Blur only works for CG-based image.")
  249|      0|            return base
  250|      0|        }
  251|      0|        
  252|      0|        // http://www.w3.org/TR/SVG/filters.html#feGaussianBlurElement
  253|      0|        // let d = floor(s * 3*sqrt(2*pi)/4 + 0.5)
  254|      0|        // if d is odd, use three box-blurs of size 'd', centered on the output pixel.
  255|      0|        let s = Float(max(radius, 2.0))
  256|      0|        // We will do blur on a resized image (*0.5), so the blur radius could be half as well.
  257|      0|        
  258|      0|        // Fix the slow compiling time for Swift 3.
  259|      0|        // See https://github.com/onevcat/Kingfisher/issues/611
  260|      0|        let pi2 = 2 * Float.pi
  261|      0|        let sqrtPi2 = sqrt(pi2)
  262|      0|        var targetRadius = floor(s * 3.0 * sqrtPi2 / 4.0 + 0.5)
  263|      0|        
  264|      0|        if targetRadius.isEven { targetRadius += 1 }
  265|      0|
  266|      0|        // Determine necessary iteration count by blur radius.
  267|      0|        let iterations: Int
  268|      0|        if radius < 0.5 {
  269|      0|            iterations = 1
  270|      0|        } else if radius < 1.5 {
  271|      0|            iterations = 2
  272|      0|        } else {
  273|      0|            iterations = 3
  274|      0|        }
  275|      0|        
  276|      0|        let w = Int(size.width)
  277|      0|        let h = Int(size.height)
  278|      0|        let rowBytes = Int(CGFloat(cgImage.bytesPerRow))
  279|      0|        
  280|      0|        func createEffectBuffer(_ context: CGContext) -> vImage_Buffer {
  281|      0|            let data = context.data
  282|      0|            let width = vImagePixelCount(context.width)
  283|      0|            let height = vImagePixelCount(context.height)
  284|      0|            let rowBytes = context.bytesPerRow
  285|      0|            
  286|      0|            return vImage_Buffer(data: data, height: height, width: width, rowBytes: rowBytes)
  287|      0|        }
  288|      0|        
  289|      0|        guard let context = beginContext(size: size, scale: scale, inverting: true) else {
  290|      0|            assertionFailure("[Kingfisher] Failed to create CG context for blurring image.")
  291|      0|            return base
  292|      0|        }
  293|      0|        context.draw(cgImage, in: CGRect(x: 0, y: 0, width: w, height: h))
  294|      0|        endContext()
  295|      0|        
  296|      0|        var inBuffer = createEffectBuffer(context)
  297|      0|        
  298|      0|        guard let outContext = beginContext(size: size, scale: scale, inverting: true) else {
  299|      0|            assertionFailure("[Kingfisher] Failed to create CG context for blurring image.")
  300|      0|            return base
  301|      0|        }
  302|      0|        defer { endContext() }
  303|      0|        var outBuffer = createEffectBuffer(outContext)
  304|      0|        
  305|      0|        for _ in 0 ..< iterations {
  306|      0|            let flag = vImage_Flags(kvImageEdgeExtend)
  307|      0|            vImageBoxConvolve_ARGB8888(
  308|      0|                &inBuffer, &outBuffer, nil, 0, 0, UInt32(targetRadius), UInt32(targetRadius), nil, flag)
  309|      0|            // Next inBuffer should be the outButter of current iteration
  310|      0|            (inBuffer, outBuffer) = (outBuffer, inBuffer)
  311|      0|        }
  312|      0|        
  313|      0|        #if os(macOS)
  314|      0|        let result = outContext.makeImage().flatMap {
  315|      0|            fixedForRetinaPixel(cgImage: $0, to: size)
  316|      0|        }
  317|      0|        #else
  318|      0|        let result = outContext.makeImage().flatMap {
  319|      0|            Image(cgImage: $0, scale: base.scale, orientation: base.imageOrientation)
  320|      0|        }
  321|      0|        #endif
  322|      0|        guard let blurredImage = result else {
  323|      0|            assertionFailure("[Kingfisher] Can not make an blurred image within this context.")
  324|      0|            return base
  325|      0|        }
  326|      0|        
  327|      0|        return blurredImage
  328|      0|    }
  329|       |    
  330|       |    // MARK: Overlay
  331|       |    /// Creates an image from `base` image with a color overlay layer.
  332|       |    ///
  333|       |    /// - Parameters:
  334|       |    ///   - color: The color should be use to overlay.
  335|       |    ///   - fraction: Fraction of input color. From 0.0 to 1.0. 0.0 means solid color,
  336|       |    ///               1.0 means transparent overlay.
  337|       |    /// - Returns: An image with a color overlay applied.
  338|       |    ///
  339|       |    /// - Note: This method only works for CG-based image. The current image scale is kept.
  340|       |    ///         For any non-CG-based image, `base` itself is returned.
  341|      0|    public func overlaying(with color: Color, fraction: CGFloat) -> Image {
  342|      0|        
  343|      0|        guard let _ = cgImage else {
  344|      0|            assertionFailure("[Kingfisher] Overlaying only works for CG-based image.")
  345|      0|            return base
  346|      0|        }
  347|      0|        
  348|      0|        let rect = CGRect(x: 0, y: 0, width: size.width, height: size.height)
  349|      0|        return draw(to: rect.size) { context in
  350|      0|            #if os(macOS)
  351|      0|            base.draw(in: rect)
  352|      0|            if fraction > 0 {
  353|      0|                color.withAlphaComponent(1 - fraction).set()
  354|      0|                rect.fill(using: .sourceAtop)
  355|      0|            }
  356|      0|            #else
  357|      0|            color.set()
  358|      0|            UIRectFill(rect)
  359|      0|            base.draw(in: rect, blendMode: .destinationIn, alpha: 1.0)
  360|      0|            
  361|      0|            if fraction > 0 {
  362|      0|                base.draw(in: rect, blendMode: .sourceAtop, alpha: fraction)
  363|      0|            }
  364|      0|            #endif
  365|      0|        }
  366|      0|    }
  367|       |    
  368|       |    // MARK: Tint
  369|       |    /// Creates an image from `base` image with a color tint.
  370|       |    ///
  371|       |    /// - Parameter color: The color should be used to tint `base`
  372|       |    /// - Returns: An image with a color tint applied.
  373|      0|    public func tinted(with color: Color) -> Image {
  374|      0|        #if os(watchOS)
  375|      0|        return base
  376|      0|        #else
  377|      0|        return apply(.tint(color))
  378|      0|        #endif
  379|      0|    }
  380|       |    
  381|       |    // MARK: Color Control
  382|       |    
  383|       |    /// Create an image from `self` with color control.
  384|       |    ///
  385|       |    /// - Parameters:
  386|       |    ///   - brightness: Brightness changing to image.
  387|       |    ///   - contrast: Contrast changing to image.
  388|       |    ///   - saturation: Saturation changing to image.
  389|       |    ///   - inputEV: InputEV changing to image.
  390|       |    /// - Returns:  An image with color control applied.
  391|      0|    public func adjusted(brightness: CGFloat, contrast: CGFloat, saturation: CGFloat, inputEV: CGFloat) -> Image {
  392|      0|        #if os(watchOS)
  393|      0|        return base
  394|      0|        #else
  395|      0|        return apply(.colorControl((brightness, contrast, saturation, inputEV)))
  396|      0|        #endif
  397|      0|    }
  398|       |    
  399|       |    /// Return an image with given scale.
  400|       |    ///
  401|       |    /// - Parameter scale: Target scale factor the new image should have.
  402|       |    /// - Returns: The image with target scale. If the base image is already in the scale, `base` will be returned.
  403|      0|    public func scaled(to scale: CGFloat) -> Image {
  404|      0|        guard scale != self.scale else {
  405|      0|            return base
  406|      0|        }
  407|      0|        guard let cgImage = cgImage else {
  408|      0|            assertionFailure("[Kingfisher] Scaling only works for CG-based image.")
  409|      0|            return base
  410|      0|        }
  411|      0|        return KingfisherWrapper.image(cgImage: cgImage, scale: scale, refImage: base)
  412|      0|    }
  413|       |}
  414|       |
  415|       |// MARK: - Decoding Image
  416|       |extension KingfisherWrapper where Base: Image {
  417|       |    
  418|       |    /// Returns the decoded image of the `base` image. It will draw the image in a plain context and return the data
  419|       |    /// from it. This could improve the drawing performance when an image is just created from data but not yet
  420|       |    /// displayed for the first time.
  421|       |    ///
  422|       |    /// - Note: This method only works for CG-based image. The current image scale is kept.
  423|       |    ///         For any non-CG-based image or animated image, `base` itself is returned.
  424|      0|    public var decoded: Image { return decoded(scale: scale) }
  425|       |    
  426|       |    /// Returns decoded image of the `base` image at a given scale. It will draw the image in a plain context and
  427|       |    /// return the data from it. This could improve the drawing performance when an image is just created from
  428|       |    /// data but not yet displayed for the first time.
  429|       |    ///
  430|       |    /// - Parameter scale: The given scale of target image should be.
  431|       |    /// - Returns: The decoded image ready to be displayed.
  432|       |    ///
  433|       |    /// - Note: This method only works for CG-based image. The current image scale is kept.
  434|       |    ///         For any non-CG-based image or animated image, `base` itself is returned.
  435|      0|    public func decoded(scale: CGFloat) -> Image {
  436|      0|        // Prevent animated image (GIF) losing it's images
  437|      0|        #if os(iOS)
  438|      0|        if imageSource != nil { return base }
  439|      0|        #else
  440|      0|        if images != nil { return base }
  441|      0|        #endif
  442|      0|
  443|      0|        guard let imageRef = cgImage else {
  444|      0|            assertionFailure("[Kingfisher] Decoding only works for CG-based image.")
  445|      0|            return base
  446|      0|        }
  447|      0|
  448|      0|        let size = CGSize(width: CGFloat(imageRef.width) / scale, height: CGFloat(imageRef.height) / scale)
  449|      0|        return draw(to: size, inverting: true, scale: scale) { context in
  450|      0|            context.draw(imageRef, in: CGRect(origin: .zero, size: size))
  451|      0|        }
  452|      0|    }
  453|       |}
  454|       |
  455|       |extension KingfisherWrapper where Base: Image {
  456|       |    
  457|      0|    func beginContext(size: CGSize, scale: CGFloat, inverting: Bool = false) -> CGContext? {
  458|      0|        #if os(macOS)
  459|      0|        guard let rep = NSBitmapImageRep(
  460|      0|            bitmapDataPlanes: nil,
  461|      0|            pixelsWide: Int(size.width),
  462|      0|            pixelsHigh: Int(size.height),
  463|      0|            bitsPerSample: cgImage?.bitsPerComponent ?? 8,
  464|      0|            samplesPerPixel: 4,
  465|      0|            hasAlpha: true,
  466|      0|            isPlanar: false,
  467|      0|            colorSpaceName: .calibratedRGB,
  468|      0|            bytesPerRow: 0,
  469|      0|            bitsPerPixel: 0) else
  470|      0|        {
  471|      0|            assertionFailure("[Kingfisher] Image representation cannot be created.")
  472|      0|            return nil
  473|      0|        }
  474|      0|        rep.size = size
  475|      0|        NSGraphicsContext.saveGraphicsState()
  476|      0|        guard let context = NSGraphicsContext(bitmapImageRep: rep) else {
  477|      0|            assertionFailure("[Kingfisher] Image context cannot be created.")
  478|      0|            return nil
  479|      0|        }
  480|      0|        
  481|      0|        NSGraphicsContext.current = context
  482|      0|        return context.cgContext
  483|      0|        #else
  484|      0|        UIGraphicsBeginImageContextWithOptions(size, false, scale)
  485|      0|        guard let context = UIGraphicsGetCurrentContext() else { return nil }
  486|      0|        if inverting { // If drawing a CGImage, we need to make context flipped.
  487|      0|            context.scaleBy(x: 1.0, y: -1.0)
  488|      0|            context.translateBy(x: 0, y: -size.height)
  489|      0|        }
  490|      0|        return context
  491|      0|        #endif
  492|      0|    }
  493|       |    
  494|      0|    func endContext() {
  495|      0|        #if os(macOS)
  496|      0|        NSGraphicsContext.restoreGraphicsState()
  497|      0|        #else
  498|      0|        UIGraphicsEndImageContext()
  499|      0|        #endif
  500|      0|    }
  501|       |    
  502|      0|    func draw(to size: CGSize, inverting: Bool = false, scale: CGFloat? = nil, draw: (CGContext) -> Void) -> Image {
  503|      0|        let targetScale = scale ?? self.scale
  504|      0|        guard let context = beginContext(size: size, scale: targetScale, inverting: inverting) else {
  505|      0|            assertionFailure("[Kingfisher] Failed to create CG context for blurring image.")
  506|      0|            return base
  507|      0|        }
  508|      0|        defer { endContext() }
  509|      0|        draw(context)
  510|      0|        guard let cgImage = context.makeImage() else {
  511|      0|            return base
  512|      0|        }
  513|      0|        return KingfisherWrapper.image(cgImage: cgImage, scale: targetScale, refImage: base)
  514|      0|    }
  515|       |    
  516|       |    #if os(macOS)
  517|       |    func fixedForRetinaPixel(cgImage: CGImage, to size: CGSize) -> Image {
  518|       |        
  519|       |        let image = Image(cgImage: cgImage, size: base.size)
  520|       |        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: size)
  521|       |        
  522|       |        return draw(to: self.size) { context in
  523|       |            image.draw(in: rect, from: .zero, operation: .copy, fraction: 1.0)
  524|       |        }
  525|       |    }
  526|       |    #endif
  527|       |}
  528|       |
  529|       |extension CGImage: KingfisherCompatible {}
  530|       |/// High Performance Image Resizing
  531|       |/// @see https://nshipster.com/image-resizing/
  532|       |extension KingfisherWrapper where Base: CGImage {
  533|      0|    var size: CGSize {
  534|      0|        return CGSize(width: CGFloat(base.width), height: CGFloat(base.height))
  535|      0|    }
  536|       |
  537|       |    /// Resizes `base` CGImage to a CGImage of new size, respecting the given content mode.
  538|       |    ///
  539|       |    /// - Parameters:
  540|       |    ///   - targetSize: The target size in point.
  541|       |    ///   - contentMode: Content mode of output image should be.
  542|       |    /// - Returns: A CGImage with new size.
  543|       |    #if os(iOS) || os(tvOS)
  544|      0|    public func resize(to size: CGSize, for contentMode: UIView.ContentMode) -> CGImage {
  545|      0|        switch contentMode {
  546|      0|        case .scaleAspectFit:
  547|      0|            return resize(to: size, for: .aspectFit)
  548|      0|        case .scaleAspectFill:
  549|      0|            return resize(to: size, for: .aspectFill)
  550|      0|        default:
  551|      0|            return resize(to: size)
  552|      0|        }
  553|      0|    }
  554|       |    #endif
  555|       |
  556|       |    // MARK: - Resize
  557|       |    /// Resizes `base` CGImage to a CGImage with new size.
  558|       |    ///
  559|       |    /// - Parameter size: The target size in point.
  560|       |    /// - Returns: A CGImage with new size.
  561|      0|    public func resize(to size: CGSize) -> CGImage {
  562|      0|        let alphaInfo = base.alphaInfo.rawValue & CGBitmapInfo.alphaInfoMask.rawValue
  563|      0|        var hasAlpha = false
  564|      0|        if alphaInfo == CGImageAlphaInfo.premultipliedLast.rawValue
  565|      0|            || alphaInfo == CGImageAlphaInfo.premultipliedFirst.rawValue
  566|      0|            || alphaInfo == CGImageAlphaInfo.first.rawValue
  567|      0|            || alphaInfo == CGImageAlphaInfo.last.rawValue {
  568|      0|            hasAlpha = true
  569|      0|        }
  570|      0|
  571|      0|        var bitmapInfo = CGImageByteOrderInfo.order32Little.rawValue
  572|      0|        bitmapInfo |= hasAlpha ? CGImageAlphaInfo.premultipliedFirst.rawValue : CGImageAlphaInfo.noneSkipFirst.rawValue
  573|      0|
  574|      0|        guard let context = CGContext(data: nil,
  575|      0|                                      width: Int(size.width),
  576|      0|                                      height: Int(size.height),
  577|      0|                                      bitsPerComponent: base.bitsPerComponent,
  578|      0|                                      bytesPerRow: base.bytesPerRow,
  579|      0|                                      space: base.colorSpace ?? CGColorSpaceCreateDeviceRGB(),
  580|      0|                                      bitmapInfo: bitmapInfo) else
  581|      0|        {
  582|      0|            return base
  583|      0|        }
  584|      0|
  585|      0|        let rect = CGRect(origin: .zero, size: size)
  586|      0|        context.interpolationQuality = .high
  587|      0|        context.draw(base, in: rect)
  588|      0|        return context.makeImage() ?? base
  589|      0|    }
  590|       |
  591|       |    /// Resizes `base` CGImage to a CGImage of new size, respecting the given content mode.
  592|       |    ///
  593|       |    /// - Parameters:
  594|       |    ///   - targetSize: The target size in point.
  595|       |    ///   - contentMode: Content mode of output image should be.
  596|       |    /// - Returns: A CGImage with new size.
  597|      0|    public func resize(to targetSize: CGSize, for contentMode: ContentMode) -> CGImage {
  598|      0|        let newSize = size.kf.resize(to: targetSize, for: contentMode)
  599|      0|        return resize(to: newSize)
  600|      0|    }
  601|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Image/ImageFormat.swift:
    1|       |//
    2|       |//  ImageFormat.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/09/28.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents image format.
   30|       |///
   31|       |/// - unknown: The format cannot be recognized or not supported yet.
   32|       |/// - PNG: PNG image format.
   33|       |/// - JPEG: JPEG image format.
   34|       |/// - GIF: GIF image format.
   35|       |public enum ImageFormat {
   36|       |    /// The format cannot be recognized or not supported yet.
   37|       |    case unknown
   38|       |    /// PNG image format.
   39|       |    case PNG
   40|       |    /// JPEG image format.
   41|       |    case JPEG
   42|       |    /// GIF image format.
   43|       |    case GIF
   44|       |    
   45|       |    struct HeaderData {
   46|       |        static var PNG: [UInt8] = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]
   47|       |        static var JPEG_SOI: [UInt8] = [0xFF, 0xD8]
   48|       |        static var JPEG_IF: [UInt8] = [0xFF]
   49|       |        static var GIF: [UInt8] = [0x47, 0x49, 0x46]
   50|       |    }
   51|       |}
   52|       |
   53|       |
   54|       |extension Data: KingfisherCompatible {}
   55|       |
   56|       |// MARK: - Misc Helpers
   57|       |extension KingfisherWrapper where Base == Data {
   58|       |    /// Gets the image format corresponding to the data.
   59|      0|    public var imageFormat: ImageFormat {
   60|      0|        var buffer = [UInt8](repeating: 0, count: 8)
   61|      0|        (base as NSData).getBytes(&buffer, length: 8)
   62|      0|        if buffer == ImageFormat.HeaderData.PNG {
   63|      0|            return .PNG
   64|      0|        } else if buffer[0] == ImageFormat.HeaderData.JPEG_SOI[0] &&
   65|      0|            buffer[1] == ImageFormat.HeaderData.JPEG_SOI[1] &&
   66|      0|            buffer[2] == ImageFormat.HeaderData.JPEG_IF[0]
   67|      0|        {
   68|      0|            return .JPEG
   69|      0|        } else if buffer[0] == ImageFormat.HeaderData.GIF[0] &&
   70|      0|            buffer[1] == ImageFormat.HeaderData.GIF[1] &&
   71|      0|            buffer[2] == ImageFormat.HeaderData.GIF[2]
   72|      0|        {
   73|      0|            return .GIF
   74|      0|        }
   75|      0|        
   76|      0|        return .unknown
   77|      0|    }
   78|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Image/ImageProcessor.swift:
    1|       |//
    2|       |//  ImageProcessor.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2016/08/26.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |import CoreGraphics
   29|       |
   30|       |#if canImport(AppKit)
   31|       |import AppKit
   32|       |#endif
   33|       |
   34|       |/// Represents an item which could be processed by an `ImageProcessor`.
   35|       |///
   36|       |/// - image: Input image. The processor should provide a way to apply
   37|       |///          processing on this `image` and return the result image.
   38|       |/// - data:  Input data. The processor should provide a way to apply
   39|       |///          processing on this `image` and return the result image.
   40|       |public enum ImageProcessItem {
   41|       |    
   42|       |    /// Input image. The processor should provide a way to apply
   43|       |    /// processing on this `image` and return the result image.
   44|       |    case image(Image)
   45|       |    
   46|       |    /// Input data. The processor should provide a way to apply
   47|       |    /// processing on this `image` and return the result image.
   48|       |    case data(Data)
   49|       |}
   50|       |
   51|       |/// An `ImageProcessor` would be used to convert some downloaded data to an image.
   52|       |public protocol ImageProcessor {
   53|       |    /// Identifier of the processor. It will be used to identify the processor when 
   54|       |    /// caching and retrieving an image. You might want to make sure that processors with
   55|       |    /// same properties/functionality have the same identifiers, so correct processed images
   56|       |    /// could be retrieved with proper key.
   57|       |    /// 
   58|       |    /// - Note: Do not supply an empty string for a customized processor, which is already reserved by
   59|       |    /// the `DefaultImageProcessor`. It is recommended to use a reverse domain name notation string of
   60|       |    /// your own for the identifier.
   61|       |    var identifier: String { get }
   62|       |    
   63|       |    /// Processes the input `ImageProcessItem` with this processor.
   64|       |    ///
   65|       |    /// - Parameters:
   66|       |    ///   - item: Input item which will be processed by `self`.
   67|       |    ///   - options: Options when processing the item.
   68|       |    /// - Returns: The processed image.
   69|       |    ///
   70|       |    /// - Note: The return value should be `nil` if processing failed while converting an input item to image.
   71|       |    ///         If `nil` received by the processing caller, an error will be reported and the process flow stops.
   72|       |    ///         If the processing flow is not critical for your flow, then when the input item is already an image
   73|       |    ///         (`.image` case) and there is any errors in the processing, you could return the input image itself
   74|       |    ///         to keep the processing pipeline continuing.
   75|       |    /// - Note: Most processor only supports CG-based images. watchOS is not supported for processors containing
   76|       |    ///         a filter, the input image will be returned directly on watchOS.
   77|       |    /// - Note:
   78|       |    /// This method is deprecated. Please implement the version with
   79|       |    /// `KingfisherParsedOptionsInfo` as parameter instead.
   80|       |    @available(*, deprecated,
   81|       |    message: "Deprecated. Implement the method with same name but with `KingfisherParsedOptionsInfo` instead.")
   82|       |    func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image?
   83|       |
   84|       |    /// Processes the input `ImageProcessItem` with this processor.
   85|       |    ///
   86|       |    /// - Parameters:
   87|       |    ///   - item: Input item which will be processed by `self`.
   88|       |    ///   - options: The parsed options when processing the item.
   89|       |    /// - Returns: The processed image.
   90|       |    ///
   91|       |    /// - Note: The return value should be `nil` if processing failed while converting an input item to image.
   92|       |    ///         If `nil` received by the processing caller, an error will be reported and the process flow stops.
   93|       |    ///         If the processing flow is not critical for your flow, then when the input item is already an image
   94|       |    ///         (`.image` case) and there is any errors in the processing, you could return the input image itself
   95|       |    ///         to keep the processing pipeline continuing.
   96|       |    /// - Note: Most processor only supports CG-based images. watchOS is not supported for processors containing
   97|       |    ///         a filter, the input image will be returned directly on watchOS.
   98|       |    func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image?
   99|       |}
  100|       |
  101|       |extension ImageProcessor {
  102|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  103|      0|        return process(item: item, options: KingfisherParsedOptionsInfo(options))
  104|      0|    }
  105|       |}
  106|       |
  107|       |public extension ImageProcessor {
  108|       |    
  109|       |    /// Appends an `ImageProcessor` to another. The identifier of the new `ImageProcessor`
  110|       |    /// will be "\(self.identifier)|>\(another.identifier)".
  111|       |    ///
  112|       |    /// - Parameter another: An `ImageProcessor` you want to append to `self`.
  113|       |    /// - Returns: The new `ImageProcessor` will process the image in the order
  114|       |    ///            of the two processors concatenated.
  115|      0|    public func append(another: ImageProcessor) -> ImageProcessor {
  116|      0|        let newIdentifier = identifier.appending("|>\(another.identifier)")
  117|      0|        return GeneralProcessor(identifier: newIdentifier) {
  118|      0|            item, options in
  119|      0|            if let image = self.process(item: item, options: options) {
  120|      0|                return another.process(item: .image(image), options: options)
  121|      0|            } else {
  122|      0|                return nil
  123|      0|            }
  124|      0|        }
  125|      0|    }
  126|       |}
  127|       |
  128|      0|func ==(left: ImageProcessor, right: ImageProcessor) -> Bool {
  129|      0|    return left.identifier == right.identifier
  130|      0|}
  131|       |
  132|      0|func !=(left: ImageProcessor, right: ImageProcessor) -> Bool {
  133|      0|    return !(left == right)
  134|      0|}
  135|       |
  136|       |typealias ProcessorImp = ((ImageProcessItem, KingfisherParsedOptionsInfo) -> Image?)
  137|       |struct GeneralProcessor: ImageProcessor {
  138|       |    let identifier: String
  139|       |    let p: ProcessorImp
  140|      0|    func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  141|      0|        return p(item, options)
  142|      0|    }
  143|       |}
  144|       |
  145|       |/// The default processor. It converts the input data to a valid image.
  146|       |/// Images of .PNG, .JPEG and .GIF format are supported.
  147|       |/// If an image item is given as `.image` case, `DefaultImageProcessor` will
  148|       |/// do nothing on it and return the associated image.
  149|       |public struct DefaultImageProcessor: ImageProcessor {
  150|       |    
  151|       |    /// A default `DefaultImageProcessor` could be used across.
  152|       |    public static let `default` = DefaultImageProcessor()
  153|       |    
  154|       |    /// Identifier of the processor.
  155|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  156|       |    public let identifier = ""
  157|       |    
  158|       |    /// Creates a `DefaultImageProcessor`. Use `DefaultImageProcessor.default` to get an instance,
  159|       |    /// if you do not have a good reason to create your own `DefaultImageProcessor`.
  160|      0|    public init() {}
  161|       |    
  162|       |    /// Processes the input `ImageProcessItem` with this processor.
  163|       |    ///
  164|       |    /// - Parameters:
  165|       |    ///   - item: Input item which will be processed by `self`.
  166|       |    ///   - options: Options when processing the item.
  167|       |    /// - Returns: The processed image.
  168|       |    ///
  169|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  170|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  171|      0|        switch item {
  172|      0|        case .image(let image):
  173|      0|            return image.kf.scaled(to: options.scaleFactor)
  174|      0|        case .data(let data):
  175|      0|            return KingfisherWrapper.image(data: data, options: options.imageCreatingOptions)
  176|      0|        }
  177|      0|    }
  178|       |}
  179|       |
  180|       |/// Represents the rect corner setting when processing a round corner image.
  181|       |public struct RectCorner: OptionSet {
  182|       |    
  183|       |    /// Raw value of the rect corner.
  184|       |    public let rawValue: Int
  185|       |    
  186|       |    /// Represents the top left corner.
  187|       |    public static let topLeft = RectCorner(rawValue: 1 << 0)
  188|       |    
  189|       |    /// Represents the top right corner.
  190|       |    public static let topRight = RectCorner(rawValue: 1 << 1)
  191|       |    
  192|       |    /// Represents the bottom left corner.
  193|       |    public static let bottomLeft = RectCorner(rawValue: 1 << 2)
  194|       |    
  195|       |    /// Represents the bottom right corner.
  196|       |    public static let bottomRight = RectCorner(rawValue: 1 << 3)
  197|       |    
  198|       |    /// Represents all corners.
  199|       |    public static let all: RectCorner = [.topLeft, .topRight, .bottomLeft, .bottomRight]
  200|       |    
  201|       |    /// Creates a `RectCorner` option set with a given value.
  202|       |    ///
  203|       |    /// - Parameter rawValue: The value represents a certain corner option.
  204|      0|    public init(rawValue: Int) {
  205|      0|        self.rawValue = rawValue
  206|      0|    }
  207|       |    
  208|      0|    var cornerIdentifier: String {
  209|      0|        if self == .all {
  210|      0|            return ""
  211|      0|        }
  212|      0|        return "_corner(\(rawValue))"
  213|      0|    }
  214|       |}
  215|       |
  216|       |#if !os(macOS)
  217|       |/// Processor for adding an blend mode to images. Only CG-based images are supported.
  218|       |public struct BlendImageProcessor: ImageProcessor {
  219|       |
  220|       |    /// Identifier of the processor.
  221|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  222|       |    public let identifier: String
  223|       |
  224|       |    /// Blend Mode will be used to blend the input image.
  225|       |    public let blendMode: CGBlendMode
  226|       |
  227|       |    /// Alpha will be used when blend image.
  228|       |    public let alpha: CGFloat
  229|       |
  230|       |    /// Background color of the output image. If `nil`, it will stay transparent.
  231|       |    public let backgroundColor: Color?
  232|       |
  233|       |    /// Creates a `BlendImageProcessor`.
  234|       |    ///
  235|       |    /// - Parameters:
  236|       |    ///   - blendMode: Blend Mode will be used to blend the input image.
  237|       |    ///   - alpha: Alpha will be used when blend image. From 0.0 to 1.0. 1.0 means solid image,
  238|       |    ///            0.0 means transparent image (not visible at all). Default is 1.0.
  239|       |    ///   - backgroundColor: Background color to apply for the output image. Default is `nil`.
  240|      0|    public init(blendMode: CGBlendMode, alpha: CGFloat = 1.0, backgroundColor: Color? = nil) {
  241|      0|        self.blendMode = blendMode
  242|      0|        self.alpha = alpha
  243|      0|        self.backgroundColor = backgroundColor
  244|      0|        var identifier = "com.onevcat.Kingfisher.BlendImageProcessor(\(blendMode.rawValue),\(alpha))"
  245|      0|        if let color = backgroundColor {
  246|      0|            identifier.append("_\(color.hex)")
  247|      0|        }
  248|      0|        self.identifier = identifier
  249|      0|    }
  250|       |
  251|       |    /// Processes the input `ImageProcessItem` with this processor.
  252|       |    ///
  253|       |    /// - Parameters:
  254|       |    ///   - item: Input item which will be processed by `self`.
  255|       |    ///   - options: Options when processing the item.
  256|       |    /// - Returns: The processed image.
  257|       |    ///
  258|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  259|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  260|      0|        switch item {
  261|      0|        case .image(let image):
  262|      0|            return image.kf.scaled(to: options.scaleFactor)
  263|      0|                        .kf.image(withBlendMode: blendMode, alpha: alpha, backgroundColor: backgroundColor)
  264|      0|        case .data:
  265|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  266|      0|        }
  267|      0|    }
  268|       |}
  269|       |#endif
  270|       |
  271|       |#if os(macOS)
  272|       |/// Processor for adding an compositing operation to images. Only CG-based images are supported in macOS.
  273|       |public struct CompositingImageProcessor: ImageProcessor {
  274|       |
  275|       |    /// Identifier of the processor.
  276|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  277|       |    public let identifier: String
  278|       |
  279|       |    /// Compositing operation will be used to the input image.
  280|       |    public let compositingOperation: NSCompositingOperation
  281|       |
  282|       |    /// Alpha will be used when compositing image.
  283|       |    public let alpha: CGFloat
  284|       |
  285|       |    /// Background color of the output image. If `nil`, it will stay transparent.
  286|       |    public let backgroundColor: Color?
  287|       |
  288|       |    /// Creates a `CompositingImageProcessor`
  289|       |    ///
  290|       |    /// - Parameters:
  291|       |    ///   - compositingOperation: Compositing operation will be used to the input image.
  292|       |    ///   - alpha: Alpha will be used when compositing image.
  293|       |    ///            From 0.0 to 1.0. 1.0 means solid image, 0.0 means transparent image.
  294|       |    ///            Default is 1.0.
  295|       |    ///   - backgroundColor: Background color to apply for the output image. Default is `nil`.
  296|       |    public init(compositingOperation: NSCompositingOperation,
  297|       |                alpha: CGFloat = 1.0,
  298|       |                backgroundColor: Color? = nil)
  299|       |    {
  300|       |        self.compositingOperation = compositingOperation
  301|       |        self.alpha = alpha
  302|       |        self.backgroundColor = backgroundColor
  303|       |        var identifier = "com.onevcat.Kingfisher.CompositingImageProcessor(\(compositingOperation.rawValue),\(alpha))"
  304|       |        if let color = backgroundColor {
  305|       |            identifier.append("_\(color.hex)")
  306|       |        }
  307|       |        self.identifier = identifier
  308|       |    }
  309|       |
  310|       |    /// Processes the input `ImageProcessItem` with this processor.
  311|       |    ///
  312|       |    /// - Parameters:
  313|       |    ///   - item: Input item which will be processed by `self`.
  314|       |    ///   - options: Options when processing the item.
  315|       |    /// - Returns: The processed image.
  316|       |    ///
  317|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  318|       |    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  319|       |        switch item {
  320|       |        case .image(let image):
  321|       |            return image.kf.scaled(to: options.scaleFactor)
  322|       |                        .kf.image(
  323|       |                            withCompositingOperation: compositingOperation,
  324|       |                            alpha: alpha,
  325|       |                            backgroundColor: backgroundColor)
  326|       |        case .data:
  327|       |            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  328|       |        }
  329|       |    }
  330|       |}
  331|       |#endif
  332|       |
  333|       |/// Processor for making round corner images. Only CG-based images are supported in macOS, 
  334|       |/// if a non-CG image passed in, the processor will do nothing.
  335|       |///
  336|       |/// Note: The input image will be rendered with round corner pixels removed. If the image itself does not contain
  337|       |/// alpha channel (for example, a JPEG image), the processed image will contain an alpha channel in memory in order
  338|       |/// to show correctly. However, when cached into disk, the image format will be respected and the alpha channel will
  339|       |/// be removed. That means when you load the processed image from cache again, you will lose transparent corner.
  340|       |/// You could use `FormatIndicatedCacheSerializer.png` to force Kingfisher to serialize the image to PNG format in this
  341|       |/// case.
  342|       |public struct RoundCornerImageProcessor: ImageProcessor {
  343|       |    
  344|       |    /// Identifier of the processor.
  345|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  346|       |    public let identifier: String
  347|       |
  348|       |    /// Corner radius will be applied in processing.
  349|       |    public let cornerRadius: CGFloat
  350|       |    
  351|       |    /// The target corners which will be applied rounding.
  352|       |    public let roundingCorners: RectCorner
  353|       |    
  354|       |    /// Target size of output image should be. If `nil`, the image will keep its original size after processing.
  355|       |    public let targetSize: CGSize?
  356|       |
  357|       |    /// Background color of the output image. If `nil`, it will use a transparent background.
  358|       |    public let backgroundColor: Color?
  359|       |
  360|       |    /// Creates a `RoundCornerImageProcessor`.
  361|       |    ///
  362|       |    /// - Parameters:
  363|       |    ///   - cornerRadius: Corner radius will be applied in processing.
  364|       |    ///   - targetSize: Target size of output image should be. If `nil`,
  365|       |    ///                 the image will keep its original size after processing.
  366|       |    ///                 Default is `nil`.
  367|       |    ///   - corners: The target corners which will be applied rounding. Default is `.all`.
  368|       |    ///   - backgroundColor: Background color to apply for the output image. Default is `nil`.
  369|       |    public init(
  370|       |        cornerRadius: CGFloat,
  371|       |        targetSize: CGSize? = nil,
  372|       |        roundingCorners corners: RectCorner = .all,
  373|       |        backgroundColor: Color? = nil)
  374|      0|    {
  375|      0|        self.cornerRadius = cornerRadius
  376|      0|        self.targetSize = targetSize
  377|      0|        self.roundingCorners = corners
  378|      0|        self.backgroundColor = backgroundColor
  379|      0|
  380|      0|        self.identifier = {
  381|      0|            var identifier = ""
  382|      0|
  383|      0|            if let size = targetSize {
  384|      0|                identifier = "com.onevcat.Kingfisher.RoundCornerImageProcessor" +
  385|      0|                             "(\(cornerRadius)_\(size)\(corners.cornerIdentifier))"
  386|      0|            } else {
  387|      0|                identifier = "com.onevcat.Kingfisher.RoundCornerImageProcessor" +
  388|      0|                             "(\(cornerRadius)\(corners.cornerIdentifier))"
  389|      0|            }
  390|      0|            if let backgroundColor = backgroundColor {
  391|      0|                identifier += "_\(backgroundColor)"
  392|      0|            }
  393|      0|
  394|      0|            return identifier
  395|      0|        }()
  396|      0|    }
  397|       |    
  398|       |    /// Processes the input `ImageProcessItem` with this processor.
  399|       |    ///
  400|       |    /// - Parameters:
  401|       |    ///   - item: Input item which will be processed by `self`.
  402|       |    ///   - options: Options when processing the item.
  403|       |    /// - Returns: The processed image.
  404|       |    ///
  405|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  406|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  407|      0|        switch item {
  408|      0|        case .image(let image):
  409|      0|            let size = targetSize ?? image.kf.size
  410|      0|            return image.kf.scaled(to: options.scaleFactor)
  411|      0|                        .kf.image(
  412|      0|                            withRoundRadius: cornerRadius,
  413|      0|                            fit: size,
  414|      0|                            roundingCorners: roundingCorners,
  415|      0|                            backgroundColor: backgroundColor)
  416|      0|        case .data:
  417|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  418|      0|        }
  419|      0|    }
  420|       |}
  421|       |
  422|       |
  423|       |/// Represents how a size adjusts itself to fit a target size.
  424|       |///
  425|       |/// - none: Not scale the content.
  426|       |/// - aspectFit: Scales the content to fit the size of the view by maintaining the aspect ratio.
  427|       |/// - aspectFill: Scales the content to fill the size of the view.
  428|       |public enum ContentMode {
  429|       |    /// Not scale the content.
  430|       |    case none
  431|       |    /// Scales the content to fit the size of the view by maintaining the aspect ratio.
  432|       |    case aspectFit
  433|       |    /// Scales the content to fill the size of the view.
  434|       |    case aspectFill
  435|       |}
  436|       |
  437|       |/// Processor for resizing images.
  438|       |/// If you need to resize a data represented image to a smaller size, use `DownsamplingImageProcessor`
  439|       |/// instead, which is more efficient and takes less memory.
  440|       |public struct ResizingImageProcessor: ImageProcessor {
  441|       |    
  442|       |    /// Identifier of the processor.
  443|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  444|       |    public let identifier: String
  445|       |    
  446|       |    /// The reference size for resizing operation in point.
  447|       |    public let referenceSize: CGSize
  448|       |    
  449|       |    /// Target content mode of output image should be.
  450|       |    /// Default is `.none`.
  451|       |    public let targetContentMode: ContentMode
  452|       |    
  453|       |    /// Creates a `ResizingImageProcessor`.
  454|       |    ///
  455|       |    /// - Parameters:
  456|       |    ///   - referenceSize: The reference size for resizing operation in point.
  457|       |    ///   - mode: Target content mode of output image should be.
  458|       |    ///
  459|       |    /// - Note:
  460|       |    ///   The instance of `ResizingImageProcessor` will follow its `mode` property
  461|       |    ///   and try to resizing the input images to fit or fill the `referenceSize`.
  462|       |    ///   That means if you are using a `mode` besides of `.none`, you may get an
  463|       |    ///   image with its size not be the same as the `referenceSize`.
  464|       |    ///
  465|       |    ///   **Example**: With input image size: {100, 200}, 
  466|       |    ///   `referenceSize`: {100, 100}, `mode`: `.aspectFit`,
  467|       |    ///   you will get an output image with size of {50, 100}, which "fit"s
  468|       |    ///   the `referenceSize`.
  469|       |    ///
  470|       |    ///   If you need an output image exactly to be a specified size, append or use
  471|       |    ///   a `CroppingImageProcessor`.
  472|      0|    public init(referenceSize: CGSize, mode: ContentMode = .none) {
  473|      0|        self.referenceSize = referenceSize
  474|      0|        self.targetContentMode = mode
  475|      0|        
  476|      0|        if mode == .none {
  477|      0|            self.identifier = "com.onevcat.Kingfisher.ResizingImageProcessor(\(referenceSize))"
  478|      0|        } else {
  479|      0|            self.identifier = "com.onevcat.Kingfisher.ResizingImageProcessor(\(referenceSize), \(mode))"
  480|      0|        }
  481|      0|    }
  482|       |    
  483|       |    /// Processes the input `ImageProcessItem` with this processor.
  484|       |    ///
  485|       |    /// - Parameters:
  486|       |    ///   - item: Input item which will be processed by `self`.
  487|       |    ///   - options: Options when processing the item.
  488|       |    /// - Returns: The processed image.
  489|       |    ///
  490|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  491|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  492|      0|        switch item {
  493|      0|        case .image(let image):
  494|      0|            return image.kf.scaled(to: options.scaleFactor)
  495|      0|                        .kf.resize(to: referenceSize, for: targetContentMode)
  496|      0|        case .data:
  497|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  498|      0|        }
  499|      0|    }
  500|       |}
  501|       |
  502|       |/// Processor for adding blur effect to images. `Accelerate.framework` is used underhood for 
  503|       |/// a better performance. A simulated Gaussian blur with specified blur radius will be applied.
  504|       |public struct BlurImageProcessor: ImageProcessor {
  505|       |    
  506|       |    /// Identifier of the processor.
  507|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  508|       |    public let identifier: String
  509|       |    
  510|       |    /// Blur radius for the simulated Gaussian blur.
  511|       |    public let blurRadius: CGFloat
  512|       |
  513|       |    /// Creates a `BlurImageProcessor`
  514|       |    ///
  515|       |    /// - parameter blurRadius: Blur radius for the simulated Gaussian blur.
  516|      0|    public init(blurRadius: CGFloat) {
  517|      0|        self.blurRadius = blurRadius
  518|      0|        self.identifier = "com.onevcat.Kingfisher.BlurImageProcessor(\(blurRadius))"
  519|      0|    }
  520|       |    
  521|       |    /// Processes the input `ImageProcessItem` with this processor.
  522|       |    ///
  523|       |    /// - Parameters:
  524|       |    ///   - item: Input item which will be processed by `self`.
  525|       |    ///   - options: Options when processing the item.
  526|       |    /// - Returns: The processed image.
  527|       |    ///
  528|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  529|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  530|      0|        switch item {
  531|      0|        case .image(let image):
  532|      0|            let radius = blurRadius * options.scaleFactor
  533|      0|            return image.kf.scaled(to: options.scaleFactor)
  534|      0|                        .kf.blurred(withRadius: radius)
  535|      0|        case .data:
  536|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  537|      0|        }
  538|      0|    }
  539|       |}
  540|       |
  541|       |/// Processor for adding an overlay to images. Only CG-based images are supported in macOS.
  542|       |public struct OverlayImageProcessor: ImageProcessor {
  543|       |    
  544|       |    /// Identifier of the processor.
  545|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  546|       |    public let identifier: String
  547|       |    
  548|       |    /// Overlay color will be used to overlay the input image.
  549|       |    public let overlay: Color
  550|       |    
  551|       |    /// Fraction will be used when overlay the color to image.
  552|       |    public let fraction: CGFloat
  553|       |    
  554|       |    /// Creates an `OverlayImageProcessor`
  555|       |    ///
  556|       |    /// - parameter overlay:  Overlay color will be used to overlay the input image.
  557|       |    /// - parameter fraction: Fraction will be used when overlay the color to image. 
  558|       |    ///                       From 0.0 to 1.0. 0.0 means solid color, 1.0 means transparent overlay.
  559|      0|    public init(overlay: Color, fraction: CGFloat = 0.5) {
  560|      0|        self.overlay = overlay
  561|      0|        self.fraction = fraction
  562|      0|        self.identifier = "com.onevcat.Kingfisher.OverlayImageProcessor(\(overlay.hex)_\(fraction))"
  563|      0|    }
  564|       |    
  565|       |    /// Processes the input `ImageProcessItem` with this processor.
  566|       |    ///
  567|       |    /// - Parameters:
  568|       |    ///   - item: Input item which will be processed by `self`.
  569|       |    ///   - options: Options when processing the item.
  570|       |    /// - Returns: The processed image.
  571|       |    ///
  572|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  573|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  574|      0|        switch item {
  575|      0|        case .image(let image):
  576|      0|            return image.kf.scaled(to: options.scaleFactor)
  577|      0|                        .kf.overlaying(with: overlay, fraction: fraction)
  578|      0|        case .data:
  579|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  580|      0|        }
  581|      0|    }
  582|       |}
  583|       |
  584|       |/// Processor for tint images with color. Only CG-based images are supported.
  585|       |public struct TintImageProcessor: ImageProcessor {
  586|       |    
  587|       |    /// Identifier of the processor.
  588|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  589|       |    public let identifier: String
  590|       |    
  591|       |    /// Tint color will be used to tint the input image.
  592|       |    public let tint: Color
  593|       |    
  594|       |    /// Creates a `TintImageProcessor`
  595|       |    ///
  596|       |    /// - parameter tint: Tint color will be used to tint the input image.
  597|      0|    public init(tint: Color) {
  598|      0|        self.tint = tint
  599|      0|        self.identifier = "com.onevcat.Kingfisher.TintImageProcessor(\(tint.hex))"
  600|      0|    }
  601|       |    
  602|       |    /// Processes the input `ImageProcessItem` with this processor.
  603|       |    ///
  604|       |    /// - Parameters:
  605|       |    ///   - item: Input item which will be processed by `self`.
  606|       |    ///   - options: Options when processing the item.
  607|       |    /// - Returns: The processed image.
  608|       |    ///
  609|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  610|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  611|      0|        switch item {
  612|      0|        case .image(let image):
  613|      0|            return image.kf.scaled(to: options.scaleFactor)
  614|      0|                        .kf.tinted(with: tint)
  615|      0|        case .data:
  616|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  617|      0|        }
  618|      0|    }
  619|       |}
  620|       |
  621|       |/// Processor for applying some color control to images. Only CG-based images are supported.
  622|       |/// watchOS is not supported.
  623|       |public struct ColorControlsProcessor: ImageProcessor {
  624|       |    
  625|       |    /// Identifier of the processor.
  626|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  627|       |    public let identifier: String
  628|       |    
  629|       |    /// Brightness changing to image.
  630|       |    public let brightness: CGFloat
  631|       |    
  632|       |    /// Contrast changing to image.
  633|       |    public let contrast: CGFloat
  634|       |    
  635|       |    /// Saturation changing to image.
  636|       |    public let saturation: CGFloat
  637|       |    
  638|       |    /// InputEV changing to image.
  639|       |    public let inputEV: CGFloat
  640|       |    
  641|       |    /// Creates a `ColorControlsProcessor`
  642|       |    ///
  643|       |    /// - Parameters:
  644|       |    ///   - brightness: Brightness changing to image.
  645|       |    ///   - contrast: Contrast changing to image.
  646|       |    ///   - saturation: Saturation changing to image.
  647|       |    ///   - inputEV: InputEV changing to image.
  648|      0|    public init(brightness: CGFloat, contrast: CGFloat, saturation: CGFloat, inputEV: CGFloat) {
  649|      0|        self.brightness = brightness
  650|      0|        self.contrast = contrast
  651|      0|        self.saturation = saturation
  652|      0|        self.inputEV = inputEV
  653|      0|        self.identifier = "com.onevcat.Kingfisher.ColorControlsProcessor(\(brightness)_\(contrast)_\(saturation)_\(inputEV))"
  654|      0|    }
  655|       |    
  656|       |    /// Processes the input `ImageProcessItem` with this processor.
  657|       |    ///
  658|       |    /// - Parameters:
  659|       |    ///   - item: Input item which will be processed by `self`.
  660|       |    ///   - options: Options when processing the item.
  661|       |    /// - Returns: The processed image.
  662|       |    ///
  663|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  664|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  665|      0|        switch item {
  666|      0|        case .image(let image):
  667|      0|            return image.kf.scaled(to: options.scaleFactor)
  668|      0|                        .kf.adjusted(brightness: brightness, contrast: contrast, saturation: saturation, inputEV: inputEV)
  669|      0|        case .data:
  670|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  671|      0|        }
  672|      0|    }
  673|       |}
  674|       |
  675|       |/// Processor for applying black and white effect to images. Only CG-based images are supported.
  676|       |/// watchOS is not supported.
  677|       |public struct BlackWhiteProcessor: ImageProcessor {
  678|       |    
  679|       |    /// Identifier of the processor.
  680|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  681|       |    public let identifier = "com.onevcat.Kingfisher.BlackWhiteProcessor"
  682|       |    
  683|       |    /// Creates a `BlackWhiteProcessor`
  684|      0|    public init() {}
  685|       |    
  686|       |    /// Processes the input `ImageProcessItem` with this processor.
  687|       |    ///
  688|       |    /// - Parameters:
  689|       |    ///   - item: Input item which will be processed by `self`.
  690|       |    ///   - options: Options when processing the item.
  691|       |    /// - Returns: The processed image.
  692|       |    ///
  693|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  694|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  695|      0|        return ColorControlsProcessor(brightness: 0.0, contrast: 1.0, saturation: 0.0, inputEV: 0.7)
  696|      0|            .process(item: item, options: options)
  697|      0|    }
  698|       |}
  699|       |
  700|       |/// Processor for cropping an image. Only CG-based images are supported.
  701|       |/// watchOS is not supported.
  702|       |public struct CroppingImageProcessor: ImageProcessor {
  703|       |    
  704|       |    /// Identifier of the processor.
  705|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  706|       |    public let identifier: String
  707|       |    
  708|       |    /// Target size of output image should be.
  709|       |    public let size: CGSize
  710|       |    
  711|       |    /// Anchor point from which the output size should be calculate.
  712|       |    /// The anchor point is consisted by two values between 0.0 and 1.0.
  713|       |    /// It indicates a related point in current image. 
  714|       |    /// See `CroppingImageProcessor.init(size:anchor:)` for more.
  715|       |    public let anchor: CGPoint
  716|       |    
  717|       |    /// Creates a `CroppingImageProcessor`.
  718|       |    ///
  719|       |    /// - Parameters:
  720|       |    ///   - size: Target size of output image should be.
  721|       |    ///   - anchor: The anchor point from which the size should be calculated.
  722|       |    ///             Default is `CGPoint(x: 0.5, y: 0.5)`, which means the center of input image.
  723|       |    /// - Note:
  724|       |    ///   The anchor point is consisted by two values between 0.0 and 1.0.
  725|       |    ///   It indicates a related point in current image, eg: (0.0, 0.0) for top-left
  726|       |    ///   corner, (0.5, 0.5) for center and (1.0, 1.0) for bottom-right corner.
  727|       |    ///   The `size` property of `CroppingImageProcessor` will be used along with
  728|       |    ///   `anchor` to calculate a target rectangle in the size of image.
  729|       |    ///    
  730|       |    ///   The target size will be automatically calculated with a reasonable behavior.
  731|       |    ///   For example, when you have an image size of `CGSize(width: 100, height: 100)`,
  732|       |    ///   and a target size of `CGSize(width: 20, height: 20)`: 
  733|       |    ///   - with a (0.0, 0.0) anchor (top-left), the crop rect will be `{0, 0, 20, 20}`; 
  734|       |    ///   - with a (0.5, 0.5) anchor (center), it will be `{40, 40, 20, 20}`
  735|       |    ///   - while with a (1.0, 1.0) anchor (bottom-right), it will be `{80, 80, 20, 20}`
  736|      0|    public init(size: CGSize, anchor: CGPoint = CGPoint(x: 0.5, y: 0.5)) {
  737|      0|        self.size = size
  738|      0|        self.anchor = anchor
  739|      0|        self.identifier = "com.onevcat.Kingfisher.CroppingImageProcessor(\(size)_\(anchor))"
  740|      0|    }
  741|       |    
  742|       |    /// Processes the input `ImageProcessItem` with this processor.
  743|       |    ///
  744|       |    /// - Parameters:
  745|       |    ///   - item: Input item which will be processed by `self`.
  746|       |    ///   - options: Options when processing the item.
  747|       |    /// - Returns: The processed image.
  748|       |    ///
  749|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  750|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  751|      0|        switch item {
  752|      0|        case .image(let image):
  753|      0|            return image.kf.scaled(to: options.scaleFactor)
  754|      0|                        .kf.crop(to: size, anchorOn: anchor)
  755|      0|        case .data: return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  756|      0|        }
  757|      0|    }
  758|       |}
  759|       |
  760|       |/// Processor for downsampling an image. Compared to `ResizingImageProcessor`, this processor
  761|       |/// does not render the images to resize. Instead, it downsample the input data directly to an
  762|       |/// image. It is a more efficient than `ResizingImageProcessor`.
  763|       |///
  764|       |/// - Note:
  765|       |/// Downsampling only happens when this processor used as the first processor in a processing
  766|       |/// pipeline, when the input `ImageProcessItem` is an `.data` value. If appending to any other
  767|       |/// processors, it falls back to use the normal rendering resizing behavior.
  768|       |///
  769|       |/// Only CG-based images are supported. Animated images (like GIF) is not supported.
  770|       |public struct DownsamplingImageProcessor: ImageProcessor {
  771|       |    
  772|       |    /// Target size of output image should be. It should be smaller than the size of
  773|       |    /// input image. If it is larger, the result image will be the same size of input
  774|       |    /// data without downsampling.
  775|       |    public let size: CGSize
  776|       |    
  777|       |    /// Identifier of the processor.
  778|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  779|       |    public let identifier: String
  780|       |    
  781|       |    /// Creates a `DownsamplingImageProcessor`.
  782|       |    ///
  783|       |    /// - Parameter size: The target size of the downsample operation.
  784|      0|    public init(size: CGSize) {
  785|      0|        self.size = size
  786|      0|        self.identifier = "com.onevcat.Kingfisher.DownsamplingImageProcessor(\(size))"
  787|      0|    }
  788|       |    
  789|       |    /// Processes the input `ImageProcessItem` with this processor.
  790|       |    ///
  791|       |    /// - Parameters:
  792|       |    ///   - item: Input item which will be processed by `self`.
  793|       |    ///   - options: Options when processing the item.
  794|       |    /// - Returns: The processed image.
  795|       |    ///
  796|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  797|      0|    public func process(item: ImageProcessItem, options: KingfisherParsedOptionsInfo) -> Image? {
  798|      0|        switch item {
  799|      0|        case .image(let image):
  800|      0|            return image.kf.scaled(to: options.scaleFactor)
  801|      0|                        .kf.resize(to: size, for: .none)
  802|      0|        case .data(let data):
  803|      0|            return KingfisherWrapper.downsampledImage(data: data, to: size, scale: options.scaleFactor)
  804|      0|        }
  805|      0|    }
  806|       |}
  807|       |
  808|       |/// Concatenates two `ImageProcessor`s. `ImageProcessor.append(another:)` is used internally.
  809|       |///
  810|       |/// - Parameters:
  811|       |///   - left: The first processor.
  812|       |///   - right: The second processor.
  813|       |/// - Returns: The concatenated processor.
  814|      0|public func >>(left: ImageProcessor, right: ImageProcessor) -> ImageProcessor {
  815|      0|    return left.append(another: right)
  816|      0|}
  817|       |
  818|       |extension Color {
  819|      0|    var hex: String {
  820|      0|        var r: CGFloat = 0
  821|      0|        var g: CGFloat = 0
  822|      0|        var b: CGFloat = 0
  823|      0|        var a: CGFloat = 0
  824|      0|
  825|      0|        #if os(macOS)
  826|      0|        (usingColorSpace(.sRGB) ?? self).getRed(&r, green: &g, blue: &b, alpha: &a)
  827|      0|        #else
  828|      0|        getRed(&r, green: &g, blue: &b, alpha: &a)
  829|      0|        #endif
  830|      0|
  831|      0|        let rInt = Int(r * 255) << 24
  832|      0|        let gInt = Int(g * 255) << 16
  833|      0|        let bInt = Int(b * 255) << 8
  834|      0|        let aInt = Int(a * 255)
  835|      0|        
  836|      0|        let rgba = rInt | gInt | bInt | aInt
  837|      0|        
  838|      0|        return String(format:"#%08x", rgba)
  839|      0|    }
  840|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Image/ImageTransition.swift:
    1|       |//
    2|       |//  ImageTransition.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/9/18.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(iOS) || os(tvOS)
   28|       |import UIKit
   29|       |
   30|       |/// Transition effect which will be used when an image downloaded and set by `UIImageView`
   31|       |/// extension API in Kingfisher. You can assign an enum value with transition duration as
   32|       |/// an item in `KingfisherOptionsInfo` to enable the animation transition.
   33|       |///
   34|       |/// Apple's UIViewAnimationOptions is used under the hood.
   35|       |/// For custom transition, you should specified your own transition options, animations and
   36|       |/// completion handler as well.
   37|       |///
   38|       |/// - none: No animation transition.
   39|       |/// - fade: Fade in the loaded image in a given duration.
   40|       |/// - flipFromLeft: Flip from left transition.
   41|       |/// - flipFromRight: Flip from right transition.
   42|       |/// - flipFromTop: Flip from top transition.
   43|       |/// - flipFromBottom: Flip from bottom transition.
   44|       |/// - custom: Custom transition.
   45|       |public enum ImageTransition {
   46|       |    /// No animation transition.
   47|       |    case none
   48|       |    /// Fade in the loaded image in a given duration.
   49|       |    case fade(TimeInterval)
   50|       |    /// Flip from left transition.
   51|       |    case flipFromLeft(TimeInterval)
   52|       |    /// Flip from right transition.
   53|       |    case flipFromRight(TimeInterval)
   54|       |    /// Flip from top transition.
   55|       |    case flipFromTop(TimeInterval)
   56|       |    /// Flip from bottom transition.
   57|       |    case flipFromBottom(TimeInterval)
   58|       |    /// Custom transition defined by a general animation block.
   59|       |    ///    - duration: The time duration of this custom transition.
   60|       |    ///    - options: `UIView.AnimationOptions` should be used in the transition.
   61|       |    ///    - animations: The animation block will be applied when setting image.
   62|       |    ///    - completion: A block called when the transition animation finishes.
   63|       |    case custom(duration: TimeInterval,
   64|       |                 options: UIView.AnimationOptions,
   65|       |              animations: ((UIImageView, UIImage) -> Void)?,
   66|       |              completion: ((Bool) -> Void)?)
   67|       |    
   68|      0|    var duration: TimeInterval {
   69|      0|        switch self {
   70|      0|        case .none:                          return 0
   71|      0|        case .fade(let duration):            return duration
   72|      0|            
   73|      0|        case .flipFromLeft(let duration):    return duration
   74|      0|        case .flipFromRight(let duration):   return duration
   75|      0|        case .flipFromTop(let duration):     return duration
   76|      0|        case .flipFromBottom(let duration):  return duration
   77|      0|            
   78|      0|        case .custom(let duration, _, _, _): return duration
   79|      0|        }
   80|      0|    }
   81|       |    
   82|      0|    var animationOptions: UIView.AnimationOptions {
   83|      0|        switch self {
   84|      0|        case .none:                         return []
   85|      0|        case .fade:                         return .transitionCrossDissolve
   86|      0|            
   87|      0|        case .flipFromLeft:                 return .transitionFlipFromLeft
   88|      0|        case .flipFromRight:                return .transitionFlipFromRight
   89|      0|        case .flipFromTop:                  return .transitionFlipFromTop
   90|      0|        case .flipFromBottom:               return .transitionFlipFromBottom
   91|      0|            
   92|      0|        case .custom(_, let options, _, _): return options
   93|      0|        }
   94|      0|    }
   95|       |    
   96|      0|    var animations: ((UIImageView, UIImage) -> Void)? {
   97|      0|        switch self {
   98|      0|        case .custom(_, _, let animations, _): return animations
   99|      0|        default: return { $0.image = $1 }
  100|      0|        }
  101|      0|    }
  102|       |    
  103|      0|    var completion: ((Bool) -> Void)? {
  104|      0|        switch self {
  105|      0|        case .custom(_, _, _, let completion): return completion
  106|      0|        default: return nil
  107|      0|        }
  108|      0|    }
  109|       |}
  110|       |#else
  111|       |// Just a placeholder for compiling on macOS.
  112|       |public enum ImageTransition {
  113|       |    case none
  114|       |}
  115|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Image/Placeholder.swift:
    1|       |//
    2|       |//  Placeholder.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Tieme van Veen on 28/08/2017.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |import AppKit
   29|       |#else
   30|       |import UIKit
   31|       |#endif
   32|       |
   33|       |/// Represents a placeholder type which could be set while loading as well as
   34|       |/// loading finished without getting an image.
   35|       |public protocol Placeholder {
   36|       |    
   37|       |    /// How the placeholder should be added to a given image view.
   38|       |    func add(to imageView: ImageView)
   39|       |    
   40|       |    /// How the placeholder should be removed from a given image view.
   41|       |    func remove(from imageView: ImageView)
   42|       |}
   43|       |
   44|       |/// Default implementation of an image placeholder. The image will be set or
   45|       |/// reset directly for `image` property of the image view.
   46|       |extension Image: Placeholder {
   47|       |    /// How the placeholder should be added to a given image view.
   48|      0|    public func add(to imageView: ImageView) { imageView.image = self }
   49|       |
   50|       |    /// How the placeholder should be removed from a given image view.
   51|      0|    public func remove(from imageView: ImageView) { imageView.image = nil }
   52|       |}
   53|       |
   54|       |/// Default implementation of an arbitrary view as placeholder. The view will be 
   55|       |/// added as a subview when adding and be removed from its super view when removing.
   56|       |///
   57|       |/// To use your customize View type as placeholder, simply let it conforming to 
   58|       |/// `Placeholder` by `extension MyView: Placeholder {}`.
   59|       |extension Placeholder where Self: View {
   60|       |    
   61|       |    /// How the placeholder should be added to a given image view.
   62|      0|    public func add(to imageView: ImageView) {
   63|      0|        imageView.addSubview(self)
   64|      0|        translatesAutoresizingMaskIntoConstraints = false
   65|      0|
   66|      0|        centerXAnchor.constraint(equalTo: imageView.centerXAnchor).isActive = true
   67|      0|        centerYAnchor.constraint(equalTo: imageView.centerYAnchor).isActive = true
   68|      0|        heightAnchor.constraint(equalTo: imageView.heightAnchor).isActive = true
   69|      0|        widthAnchor.constraint(equalTo: imageView.widthAnchor).isActive = true
   70|      0|    }
   71|       |
   72|       |    /// How the placeholder should be removed from a given image view.
   73|      0|    public func remove(from imageView: ImageView) {
   74|      0|        removeFromSuperview()
   75|      0|    }
   76|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/AuthenticationChallengeResponsable.swift:
    1|       |//
    2|       |//  AuthenticationChallengeResponsable.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/10/11.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Protocol indicates that an authentication challenge could be handled.
   30|       |public protocol AuthenticationChallengeResponsable: AnyObject {
   31|       |
   32|       |    /// Called when a session level authentication challenge is received.
   33|       |    /// This method provide a chance to handle and response to the authentication
   34|       |    /// challenge before downloading could start.
   35|       |    ///
   36|       |    /// - Parameters:
   37|       |    ///   - downloader: The downloader which receives this challenge.
   38|       |    ///   - challenge: An object that contains the request for authentication.
   39|       |    ///   - completionHandler: A handler that your delegate method must call.
   40|       |    ///
   41|       |    /// - Note: This method is a forward from `URLSessionDelegate.urlSession(:didReceiveChallenge:completionHandler:)`.
   42|       |    ///         Please refer to the document of it in `URLSessionDelegate`.
   43|       |    func downloader(
   44|       |        _ downloader: ImageDownloader,
   45|       |        didReceive challenge: URLAuthenticationChallenge,
   46|       |        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
   47|       |
   48|       |    /// Called when a task level authentication challenge is received.
   49|       |    /// This method provide a chance to handle and response to the authentication
   50|       |    /// challenge before downloading could start.
   51|       |    ///
   52|       |    /// - Parameters:
   53|       |    ///   - downloader: The downloader which receives this challenge.
   54|       |    ///   - task: The task whose request requires authentication.
   55|       |    ///   - challenge: An object that contains the request for authentication.
   56|       |    ///   - completionHandler: A handler that your delegate method must call.
   57|       |    func downloader(
   58|       |        _ downloader: ImageDownloader,
   59|       |        task: URLSessionTask,
   60|       |        didReceive challenge: URLAuthenticationChallenge,
   61|       |        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
   62|       |}
   63|       |
   64|       |extension AuthenticationChallengeResponsable {
   65|       |
   66|       |    public func downloader(
   67|       |        _ downloader: ImageDownloader,
   68|       |        didReceive challenge: URLAuthenticationChallenge,
   69|       |        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
   70|      0|    {
   71|      0|        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
   72|      0|            if let trustedHosts = downloader.trustedHosts, trustedHosts.contains(challenge.protectionSpace.host) {
   73|      0|                let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)
   74|      0|                completionHandler(.useCredential, credential)
   75|      0|                return
   76|      0|            }
   77|      0|        }
   78|      0|
   79|      0|        completionHandler(.performDefaultHandling, nil)
   80|      0|    }
   81|       |
   82|       |    public func downloader(
   83|       |        _ downloader: ImageDownloader,
   84|       |        task: URLSessionTask,
   85|       |        didReceive challenge: URLAuthenticationChallenge,
   86|       |        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
   87|      0|    {
   88|      0|        completionHandler(.performDefaultHandling, nil)
   89|      0|    }
   90|       |
   91|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/ImageDataProcessor.swift:
    1|       |//
    2|       |//  ImageDataProcessor.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/10/11.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |private let sharedProcessingQueue: CallbackQueue =
   30|       |    .dispatch(DispatchQueue(label: "com.onevcat.Kingfisher.ImageDownloader.Process"))
   31|       |
   32|       |// Handles image processing work on an own process queue.
   33|       |class ImageDataProcessor {
   34|       |    let data: Data
   35|       |    let callbacks: [SessionDataTask.TaskCallback]
   36|       |    let queue: CallbackQueue
   37|       |
   38|       |    // Note: We have an optimization choice there, to reduce queue dispatch by checking callback
   39|       |    // queue settings in each option...
   40|       |    let onImageProcessed = Delegate<(Result<Image, KingfisherError>, SessionDataTask.TaskCallback), Void>()
   41|       |
   42|      0|    init(data: Data, callbacks: [SessionDataTask.TaskCallback], processingQueue: CallbackQueue?) {
   43|      0|        self.data = data
   44|      0|        self.callbacks = callbacks
   45|      0|        self.queue = processingQueue ?? sharedProcessingQueue
   46|      0|    }
   47|       |
   48|      0|    func process() {
   49|      0|        queue.execute(doProcess)
   50|      0|    }
   51|       |
   52|      0|    private func doProcess() {
   53|      0|        var processedImages = [String: Image]()
   54|      0|        for callback in callbacks {
   55|      0|            let processor = callback.options.processor
   56|      0|            var image = processedImages[processor.identifier]
   57|      0|            if image == nil {
   58|      0|                image = processor.process(item: .data(data), options: callback.options)
   59|      0|                processedImages[processor.identifier] = image
   60|      0|            }
   61|      0|
   62|      0|            let result: Result<Image, KingfisherError>
   63|      0|            if let image = image {
   64|      0|                var finalImage = image
   65|      0|                if let imageModifier = callback.options.imageModifier {
   66|      0|                    finalImage = imageModifier.modify(image)
   67|      0|                }
   68|      0|                if callback.options.backgroundDecode {
   69|      0|                    finalImage = finalImage.kf.decoded
   70|      0|                }
   71|      0|                result = .success(finalImage)
   72|      0|            } else {
   73|      0|                let error = KingfisherError.processorError(
   74|      0|                    reason: .processingFailed(processor: processor, item: .data(data)))
   75|      0|                result = .failure(error)
   76|      0|            }
   77|      0|            onImageProcessed.call((result, callback))
   78|      0|        }
   79|      0|    }
   80|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/ImageDownloader.swift:
    1|       |//
    2|       |//  ImageDownloader.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |import AppKit
   29|       |#else
   30|       |import UIKit
   31|       |#endif
   32|       |
   33|       |/// Represents a success result of an image downloading progress.
   34|       |public struct ImageLoadingResult {
   35|       |
   36|       |    /// The downloaded image.
   37|       |    public let image: Image
   38|       |
   39|       |    /// Original URL of the image request.
   40|       |    public let url: URL?
   41|       |
   42|       |    /// The raw data received from downloader.
   43|       |    public let originalData: Data
   44|       |}
   45|       |
   46|       |/// Represents a task of an image downloading process.
   47|       |public struct DownloadTask {
   48|       |
   49|       |    /// The `SessionDataTask` object bounded to this download task. Multiple `DownloadTask`s could refer
   50|       |    /// to a same `sessionTask`. This is an optimization in Kingfisher to prevent multiple downloading task
   51|       |    /// for the same URL resource at the same time.
   52|       |    ///
   53|       |    /// When you `cancel` a `DownloadTask`, this `SessionDataTask` and its cancel token will be pass through.
   54|       |    /// You can use them to identify the cancelled task.
   55|       |    public let sessionTask: SessionDataTask
   56|       |
   57|       |    /// The cancel token which is used to cancel the task. This is only for identify the task when it is cancelled.
   58|       |    /// To cancel a `DownloadTask`, use `cancel` instead.
   59|       |    public let cancelToken: SessionDataTask.CancelToken
   60|       |
   61|       |    /// Cancel this task if it is running. It will do nothing if this task is not running.
   62|       |    ///
   63|       |    /// - Note:
   64|       |    /// In Kingfisher, there is an optimization to prevent starting another download task if the target URL is being
   65|       |    /// downloading. However, even when internally no new session task created, a `DownloadTask` will be still created
   66|       |    /// and returned when you call related methods, but it will share the session downloading task with a previous task.
   67|       |    /// In this case, if multiple `DownloadTask`s share a single session download task, cancelling a `DownloadTask`
   68|       |    /// does not affect other `DownloadTask`s.
   69|       |    ///
   70|       |    /// If you need to cancel all `DownloadTask`s of a url, use `ImageDownloader.cancel(url:)`. If you need to cancel
   71|       |    /// all downloading tasks of an `ImageDownloader`, use `ImageDownloader.cancelAll()`.
   72|      0|    public func cancel() {
   73|      0|        sessionTask.cancel(token: cancelToken)
   74|      0|    }
   75|       |}
   76|       |
   77|       |/// Represents a downloading manager for requesting the image with a URL from server.
   78|       |open class ImageDownloader {
   79|       |
   80|       |    // MARK: Singleton
   81|       |    /// The default downloader.
   82|       |    public static let `default` = ImageDownloader(name: "default")
   83|       |
   84|       |    // MARK: Public Properties
   85|       |    /// The duration before the downloading is timeout. Default is 15 seconds.
   86|       |    open var downloadTimeout: TimeInterval = 15.0
   87|       |    
   88|       |    /// A set of trusted hosts when receiving server trust challenges. A challenge with host name contained in this
   89|       |    /// set will be ignored. You can use this set to specify the self-signed site. It only will be used if you don't
   90|       |    /// specify the `authenticationChallengeResponder`.
   91|       |    ///
   92|       |    /// If `authenticationChallengeResponder` is set, this property will be ignored and the implementation of
   93|       |    /// `authenticationChallengeResponder` will be used instead.
   94|       |    open var trustedHosts: Set<String>?
   95|       |    
   96|       |    /// Use this to set supply a configuration for the downloader. By default,
   97|       |    /// NSURLSessionConfiguration.ephemeralSessionConfiguration() will be used.
   98|       |    ///
   99|       |    /// You could change the configuration before a downloading task starts.
  100|       |    /// A configuration without persistent storage for caches is requested for downloader working correctly.
  101|       |    open var sessionConfiguration = URLSessionConfiguration.ephemeral {
  102|      0|        didSet {
  103|      0|            session.invalidateAndCancel()
  104|      0|            session = URLSession(configuration: sessionConfiguration, delegate: sessionDelegate, delegateQueue: nil)
  105|      0|        }
  106|       |    }
  107|       |    
  108|       |    /// Whether the download requests should use pipeline or not. Default is false.
  109|       |    open var requestsUsePipelining = false
  110|       |
  111|       |    /// Delegate of this `ImageDownloader` object. See `ImageDownloaderDelegate` protocol for more.
  112|       |    open weak var delegate: ImageDownloaderDelegate?
  113|       |    
  114|       |    /// A responder for authentication challenge. 
  115|       |    /// Downloader will forward the received authentication challenge for the downloading session to this responder.
  116|       |    open weak var authenticationChallengeResponder: AuthenticationChallengeResponsable?
  117|       |
  118|       |    private let name: String
  119|       |    private let sessionDelegate: SessionDelegate
  120|       |    private var session: URLSession
  121|       |
  122|       |    // MARK: Initializers
  123|       |
  124|       |    /// Creates a downloader with name.
  125|       |    ///
  126|       |    /// - Parameter name: The name for the downloader. It should not be empty.
  127|      0|    public init(name: String) {
  128|      0|        if name.isEmpty {
  129|      0|            fatalError("[Kingfisher] You should specify a name for the downloader. "
  130|      0|                + "A downloader with empty name is not permitted.")
  131|      0|        }
  132|      0|
  133|      0|        self.name = name
  134|      0|
  135|      0|        sessionDelegate = SessionDelegate()
  136|      0|        session = URLSession(
  137|      0|            configuration: sessionConfiguration,
  138|      0|            delegate: sessionDelegate,
  139|      0|            delegateQueue: nil)
  140|      0|
  141|      0|        authenticationChallengeResponder = self
  142|      0|        setupSessionHandler()
  143|      0|    }
  144|       |
  145|      0|    deinit { session.invalidateAndCancel() }
  146|       |
  147|      0|    private func setupSessionHandler() {
  148|      0|        sessionDelegate.onReceiveSessionChallenge.delegate(on: self) { (self, invoke) in
  149|      0|            self.authenticationChallengeResponder?.downloader(self, didReceive: invoke.1, completionHandler: invoke.2)
  150|      0|        }
  151|      0|        sessionDelegate.onReceiveSessionTaskChallenge.delegate(on: self) { (self, invoke) in
  152|      0|            self.authenticationChallengeResponder?.downloader(
  153|      0|                self, task: invoke.1, didReceive: invoke.2, completionHandler: invoke.3)
  154|      0|        }
  155|      0|        sessionDelegate.onValidStatusCode.delegate(on: self) { (self, code) in
  156|      0|            return (self.delegate ?? self).isValidStatusCode(code, for: self)
  157|      0|        }
  158|      0|        sessionDelegate.onDownloadingFinished.delegate(on: self) { (self, value) in
  159|      0|            let (url, result) = value
  160|      0|            self.delegate?.imageDownloader(
  161|      0|                self, didFinishDownloadingImageForURL: url, with: result.value, error: result.error)
  162|      0|        }
  163|      0|        sessionDelegate.onDidDownloadData.delegate(on: self) { (self, task) in
  164|      0|            guard let url = task.task.originalRequest?.url else {
  165|      0|                return task.mutableData
  166|      0|            }
  167|      0|            return (self.delegate ?? self).imageDownloader(self, didDownload: task.mutableData, for: url)
  168|      0|        }
  169|      0|    }
  170|       |
  171|       |    @discardableResult
  172|       |    func downloadImage(
  173|       |        with url: URL,
  174|       |        options: KingfisherParsedOptionsInfo,
  175|       |        progressBlock: DownloadProgressBlock? = nil,
  176|       |        completionHandler: ((Result<ImageLoadingResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
  177|      0|    {
  178|      0|        // Creates default request.
  179|      0|        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: downloadTimeout)
  180|      0|        request.httpShouldUsePipelining = requestsUsePipelining
  181|      0|
  182|      0|        if let requestModifier = options.requestModifier {
  183|      0|            // Modifies request before sending.
  184|      0|            guard let r = requestModifier.modified(for: request) else {
  185|      0|                options.callbackQueue.execute {
  186|      0|                    completionHandler?(.failure(KingfisherError.requestError(reason: .emptyRequest)))
  187|      0|                }
  188|      0|                return nil
  189|      0|            }
  190|      0|            request = r
  191|      0|        }
  192|      0|        
  193|      0|        // There is a possibility that request modifier changed the url to `nil` or empty.
  194|      0|        // In this case, throw an error.
  195|      0|        guard let url = request.url, !url.absoluteString.isEmpty else {
  196|      0|            options.callbackQueue.execute {
  197|      0|                completionHandler?(.failure(KingfisherError.requestError(reason: .invalidURL(request: request))))
  198|      0|            }
  199|      0|            return nil
  200|      0|        }
  201|      0|
  202|      0|        // Wraps `progressBlock` and `completionHandler` to `onProgress` and `onCompleted` respectively.
  203|      0|        let onProgress = progressBlock.map {
  204|      0|            block -> Delegate<(Int64, Int64), Void> in
  205|      0|            let delegate = Delegate<(Int64, Int64), Void>()
  206|      0|            delegate.delegate(on: self) { (_, progress) in
  207|      0|                let (downloaded, total) = progress
  208|      0|                block(downloaded, total)
  209|      0|            }
  210|      0|            return delegate
  211|      0|        }
  212|      0|
  213|      0|        let onCompleted = completionHandler.map {
  214|      0|            block -> Delegate<Result<ImageLoadingResult, KingfisherError>, Void> in
  215|      0|            let delegate =  Delegate<Result<ImageLoadingResult, KingfisherError>, Void>()
  216|      0|            delegate.delegate(on: self) { (_, result) in
  217|      0|                block(result)
  218|      0|            }
  219|      0|            return delegate
  220|      0|        }
  221|      0|
  222|      0|        // SessionDataTask.TaskCallback is a wrapper for `onProgress`, `onCompleted` and `options` (for processor info)
  223|      0|        let callback = SessionDataTask.TaskCallback(
  224|      0|            onProgress: onProgress, onCompleted: onCompleted, options: options)
  225|      0|
  226|      0|        // Ready to start download. Add it to session task manager (`sessionHandler`)
  227|      0|
  228|      0|        let downloadTask: DownloadTask
  229|      0|        if let existingTask = sessionDelegate.task(for: url) {
  230|      0|            downloadTask = sessionDelegate.append(existingTask, url: url, callback: callback)
  231|      0|        } else {
  232|      0|            let sessionDataTask = session.dataTask(with: request)
  233|      0|            sessionDataTask.priority = options.downloadPriority
  234|      0|            downloadTask = sessionDelegate.add(sessionDataTask, url: url, callback: callback)
  235|      0|        }
  236|      0|
  237|      0|        let sessionTask = downloadTask.sessionTask
  238|      0|
  239|      0|        // Start the session task if not started yet.
  240|      0|        if !sessionTask.started {
  241|      0|            sessionTask.onTaskDone.delegate(on: self) { (self, done) in
  242|      0|                // Underlying downloading finishes.
  243|      0|                // result: Result<(Data, URLResponse?)>, callbacks: [TaskCallback]
  244|      0|                let (result, callbacks) = done
  245|      0|
  246|      0|                // Before processing the downloaded data.
  247|      0|                self.delegate?.imageDownloader(
  248|      0|                    self,
  249|      0|                    didFinishDownloadingImageForURL: url,
  250|      0|                    with: result.value?.1,
  251|      0|                    error: result.error)
  252|      0|
  253|      0|                switch result {
  254|      0|                // Download finished. Now process the data to an image.
  255|      0|                case .success(let (data, response)):
  256|      0|                    let processor = ImageDataProcessor(
  257|      0|                        data: data, callbacks: callbacks, processingQueue: options.processingQueue)
  258|      0|                    processor.onImageProcessed.delegate(on: self) { (self, result) in
  259|      0|                        // `onImageProcessed` will be called for `callbacks.count` times, with each
  260|      0|                        // `SessionDataTask.TaskCallback` as the input parameter.
  261|      0|                        // result: Result<Image>, callback: SessionDataTask.TaskCallback
  262|      0|                        let (result, callback) = result
  263|      0|
  264|      0|                        if let image = result.value {
  265|      0|                            self.delegate?.imageDownloader(self, didDownload: image, for: url, with: response)
  266|      0|                        }
  267|      0|
  268|      0|                        let imageResult = result.map { ImageLoadingResult(image: $0, url: url, originalData: data) }
  269|      0|                        let queue = callback.options.callbackQueue
  270|      0|                        queue.execute { callback.onCompleted?.call(imageResult) }
  271|      0|                    }
  272|      0|                    processor.process()
  273|      0|
  274|      0|                case .failure(let error):
  275|      0|                    callbacks.forEach { callback in
  276|      0|                        let queue = callback.options.callbackQueue
  277|      0|                        queue.execute { callback.onCompleted?.call(.failure(error)) }
  278|      0|                    }
  279|      0|                }
  280|      0|            }
  281|      0|            delegate?.imageDownloader(self, willDownloadImageForURL: url, with: request)
  282|      0|            sessionTask.resume()
  283|      0|        }
  284|      0|        return downloadTask
  285|      0|    }
  286|       |
  287|       |    // MARK: Dowloading Task
  288|       |    /// Downloads an image with a URL and option.
  289|       |    ///
  290|       |    /// - Parameters:
  291|       |    ///   - url: Target URL.
  292|       |    ///   - options: The options could control download behavior. See `KingfisherOptionsInfo`.
  293|       |    ///   - progressBlock: Called when the download progress updated. This block will be always be called in main queue.
  294|       |    ///   - completionHandler: Called when the download progress finishes. This block will be called in the queue
  295|       |    ///                        defined in `.callbackQueue` in `options` parameter.
  296|       |    /// - Returns: A downloading task. You could call `cancel` on it to stop the download task.
  297|       |    @discardableResult
  298|       |    open func downloadImage(
  299|       |        with url: URL,
  300|       |        options: KingfisherOptionsInfo? = nil,
  301|       |        progressBlock: DownloadProgressBlock? = nil,
  302|       |        completionHandler: ((Result<ImageLoadingResult, KingfisherError>) -> Void)? = nil) -> DownloadTask?
  303|      0|    {
  304|      0|        return downloadImage(
  305|      0|            with: url,
  306|      0|            options: KingfisherParsedOptionsInfo(options),
  307|      0|            progressBlock: progressBlock,
  308|      0|            completionHandler: completionHandler)
  309|      0|    }
  310|       |}
  311|       |
  312|       |// MARK: Cancelling Task
  313|       |extension ImageDownloader {
  314|       |
  315|       |    /// Cancel all downloading tasks for this `ImageDownloader`. It will trigger the completion handlers
  316|       |    /// for all not-yet-finished downloading tasks.
  317|       |    ///
  318|       |    /// If you need to only cancel a certain task, call `cancel()` on the `DownloadTask`
  319|       |    /// returned by the downloading methods. If you need to cancel all `DownloadTask`s of a certain url,
  320|       |    /// use `ImageDownloader.cancel(url:)`.
  321|      0|    public func cancelAll() {
  322|      0|        sessionDelegate.cancelAll()
  323|      0|    }
  324|       |
  325|       |    /// Cancel all downloading tasks for a given URL. It will trigger the completion handlers for
  326|       |    /// all not-yet-finished downloading tasks for the URL.
  327|       |    ///
  328|       |    /// - Parameter url: The URL which you want to cancel downloading.
  329|      0|    public func cancel(url: URL) {
  330|      0|        sessionDelegate.cancel(url: url)
  331|      0|    }
  332|       |}
  333|       |
  334|       |// Use the default implementation from extension of `AuthenticationChallengeResponsable`.
  335|       |extension ImageDownloader: AuthenticationChallengeResponsable {}
  336|       |
  337|       |// Use the default implementation from extension of `ImageDownloaderDelegate`.
  338|       |extension ImageDownloader: ImageDownloaderDelegate {}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/ImageDownloaderDelegate.swift:
    1|       |//
    2|       |//  ImageDownloaderDelegate.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/10/11.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Protocol of `ImageDownloader`. This protocol provides a set of methods which are related to image downloader
   30|       |/// working stages and rules.
   31|       |public protocol ImageDownloaderDelegate: AnyObject {
   32|       |
   33|       |    /// Called when the `ImageDownloader` object will start downloading an image from a specified URL.
   34|       |    ///
   35|       |    /// - Parameters:
   36|       |    ///   - downloader: The `ImageDownloader` object which is used for the downloading operation.
   37|       |    ///   - url: URL of the starting request.
   38|       |    ///   - request: The request object for the download process.
   39|       |    ///
   40|       |    func imageDownloader(_ downloader: ImageDownloader, willDownloadImageForURL url: URL, with request: URLRequest?)
   41|       |
   42|       |    /// Called when the `ImageDownloader` completes a downloading request with success or failure.
   43|       |    ///
   44|       |    /// - Parameters:
   45|       |    ///   - downloader: The `ImageDownloader` object which is used for the downloading operation.
   46|       |    ///   - url: URL of the original request URL.
   47|       |    ///   - response: The response object of the downloading process.
   48|       |    ///   - error: The error in case of failure.
   49|       |    ///
   50|       |    func imageDownloader(
   51|       |        _ downloader: ImageDownloader,
   52|       |        didFinishDownloadingImageForURL url: URL,
   53|       |        with response: URLResponse?,
   54|       |        error: Error?)
   55|       |
   56|       |    /// Called when the `ImageDownloader` object successfully downloaded image data from specified URL. This is
   57|       |    /// your last chance to verify or modify the downloaded data before Kingfisher tries to perform addition
   58|       |    /// processing on the image data.
   59|       |    ///
   60|       |    /// - Parameters:
   61|       |    ///   - downloader: The `ImageDownloader` object which is used for the downloading operation.
   62|       |    ///   - data: The original downloaded data.
   63|       |    ///   - url: The URL of the original request URL.
   64|       |    /// - Returns: The data from which Kingfisher should use to create an image. You need to provide valid data
   65|       |    ///            which content is one of the supported image file format. Kingfisher will perform process on this
   66|       |    ///            data and try to convert it to an image object.
   67|       |    /// - Note:
   68|       |    ///   This can be used to pre-process raw image data before creation of `Image` instance (i.e.
   69|       |    ///   decrypting or verification). If `nil` returned, the processing is interrupted and a `KingfisherError` with
   70|       |    ///   `ResponseErrorReason.dataModifyingFailed` will be raised. You could use this fact to stop the image
   71|       |    ///   processing flow if you find the data is corrupted or malformed.
   72|       |    func imageDownloader(_ downloader: ImageDownloader, didDownload data: Data, for url: URL) -> Data?
   73|       |
   74|       |    /// Called when the `ImageDownloader` object successfully downloads and processes an image from specified URL.
   75|       |    ///
   76|       |    /// - Parameters:
   77|       |    ///   - downloader: The `ImageDownloader` object which is used for the downloading operation.
   78|       |    ///   - image: The downloaded and processed image.
   79|       |    ///   - url: URL of the original request URL.
   80|       |    ///   - response: The original response object of the downloading process.
   81|       |    ///
   82|       |    func imageDownloader(
   83|       |        _ downloader: ImageDownloader,
   84|       |        didDownload image: Image,
   85|       |        for url: URL,
   86|       |        with response: URLResponse?)
   87|       |
   88|       |    /// Checks if a received HTTP status code is valid or not.
   89|       |    /// By default, a status code in range 200..<400 is considered as valid.
   90|       |    /// If an invalid code is received, the downloader will raise an `KingfisherError` with
   91|       |    /// `ResponseErrorReason.invalidHTTPStatusCode` as its reason.
   92|       |    ///
   93|       |    /// - Parameters:
   94|       |    ///   - code: The received HTTP status code.
   95|       |    ///   - downloader: The `ImageDownloader` object asks for validate status code.
   96|       |    /// - Returns: Returns a value to indicate whether this HTTP status code is valid or not.
   97|       |    /// - Note: If the default 200 to 400 valid code does not suit your need,
   98|       |    ///         you can implement this method to change that behavior.
   99|       |    func isValidStatusCode(_ code: Int, for downloader: ImageDownloader) -> Bool
  100|       |}
  101|       |
  102|       |// Default implementation for `ImageDownloaderDelegate`.
  103|       |extension ImageDownloaderDelegate {
  104|       |    public func imageDownloader(
  105|       |        _ downloader: ImageDownloader,
  106|       |        willDownloadImageForURL url: URL,
  107|      0|        with request: URLRequest?) {}
  108|       |
  109|       |    public func imageDownloader(
  110|       |        _ downloader: ImageDownloader,
  111|       |        didFinishDownloadingImageForURL url: URL,
  112|       |        with response: URLResponse?,
  113|      0|        error: Error?) {}
  114|       |
  115|       |    public func imageDownloader(
  116|       |        _ downloader: ImageDownloader,
  117|       |        didDownload image: Image,
  118|       |        for url: URL,
  119|      0|        with response: URLResponse?) {}
  120|       |
  121|      0|    public func isValidStatusCode(_ code: Int, for downloader: ImageDownloader) -> Bool {
  122|      0|        return (200..<400).contains(code)
  123|      0|    }
  124|      0|    public func imageDownloader(_ downloader: ImageDownloader, didDownload data: Data, for url: URL) -> Data? {
  125|      0|        return data
  126|      0|    }
  127|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/ImageModifier.swift:
    1|       |//
    2|       |//  ImageModifier.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Ethan Gill on 2017/11/28.
    6|       |//
    7|       |//  Copyright (c) 2019 Ethan Gill <ethan.gill@me.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// An `ImageModifier` can be used to change properties on an image in between
   30|       |/// cache serialization and use of the image. The modified returned image will be
   31|       |/// only used for current rendering purpose, the serialization data will not contain
   32|       |/// the changes applied by the `ImageModifier`.
   33|       |public protocol ImageModifier {
   34|       |    /// Modify an input `Image`.
   35|       |    ///
   36|       |    /// - parameter image:   Image which will be modified by `self`
   37|       |    ///
   38|       |    /// - returns: The modified image.
   39|       |    ///
   40|       |    /// - Note: The return value will be unmodified if modifying is not possible on
   41|       |    ///         the current platform.
   42|       |    /// - Note: Most modifiers support UIImage or NSImage, but not CGImage.
   43|       |    func modify(_ image: Image) -> Image
   44|       |}
   45|       |
   46|       |/// A wrapper for creating an `ImageModifier` easier.
   47|       |/// This type conforms to `ImageModifier` and wraps an image modify block.
   48|       |/// If the `block` throws an error, the original image will be used.
   49|       |public struct AnyImageModifier: ImageModifier {
   50|       |
   51|       |    /// A block which modifies images, or returns the original image
   52|       |    /// if modification cannot be performed with an error.
   53|       |    let block: (Image) throws -> Image
   54|       |
   55|       |    /// Creates an `AnyImageModifier` with a given `modify` block.
   56|      0|    public init(modify: @escaping (Image) throws -> Image) {
   57|      0|        block = modify
   58|      0|    }
   59|       |
   60|       |    /// Modify an input `Image`. See `ImageModifier` protocol for more.
   61|      0|    public func modify(_ image: Image) -> Image {
   62|      0|        return (try? block(image)) ?? image
   63|      0|    }
   64|       |}
   65|       |
   66|       |#if os(iOS) || os(tvOS) || os(watchOS)
   67|       |import UIKit
   68|       |
   69|       |/// Modifier for setting the rendering mode of images.
   70|       |public struct RenderingModeImageModifier: ImageModifier {
   71|       |
   72|       |    /// The rendering mode to apply to the image.
   73|       |    public let renderingMode: UIImage.RenderingMode
   74|       |
   75|       |    /// Creates a `RenderingModeImageModifier`.
   76|       |    ///
   77|       |    /// - Parameter renderingMode: The rendering mode to apply to the image. Default is `.automatic`.
   78|      0|    public init(renderingMode: UIImage.RenderingMode = .automatic) {
   79|      0|        self.renderingMode = renderingMode
   80|      0|    }
   81|       |
   82|       |    /// Modify an input `Image`. See `ImageModifier` protocol for more.
   83|      0|    public func modify(_ image: Image) -> Image {
   84|      0|        return image.withRenderingMode(renderingMode)
   85|      0|    }
   86|       |}
   87|       |
   88|       |/// Modifier for setting the `flipsForRightToLeftLayoutDirection` property of images.
   89|       |public struct FlipsForRightToLeftLayoutDirectionImageModifier: ImageModifier {
   90|       |
   91|       |    /// Creates a `FlipsForRightToLeftLayoutDirectionImageModifier`.
   92|      0|    public init() {}
   93|       |
   94|       |    /// Modify an input `Image`. See `ImageModifier` protocol for more.
   95|      0|    public func modify(_ image: Image) -> Image {
   96|      0|        return image.imageFlippedForRightToLeftLayoutDirection()
   97|      0|    }
   98|       |}
   99|       |
  100|       |/// Modifier for setting the `alignmentRectInsets` property of images.
  101|       |public struct AlignmentRectInsetsImageModifier: ImageModifier {
  102|       |
  103|       |    /// The alignment insets to apply to the image
  104|       |    public let alignmentInsets: UIEdgeInsets
  105|       |
  106|       |    /// Creates an `AlignmentRectInsetsImageModifier`.
  107|      0|    public init(alignmentInsets: UIEdgeInsets) {
  108|      0|        self.alignmentInsets = alignmentInsets
  109|      0|    }
  110|       |
  111|       |    /// Modify an input `Image`. See `ImageModifier` protocol for more.
  112|      0|    public func modify(_ image: Image) -> Image {
  113|      0|        return image.withAlignmentRectInsets(alignmentInsets)
  114|      0|    }
  115|       |}
  116|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/ImagePrefetcher.swift:
    1|       |//
    2|       |//  ImagePrefetcher.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Claire Knight <claire.knight@moggytech.co.uk> on 24/02/2016
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |
   28|       |#if os(macOS)
   29|       |import AppKit
   30|       |#else
   31|       |import UIKit
   32|       |#endif
   33|       |
   34|       |/// Progress update block of prefetcher. 
   35|       |///
   36|       |/// - `skippedResources`: An array of resources that are already cached before the prefetching starting.
   37|       |/// - `failedResources`: An array of resources that fail to be downloaded. It could because of being cancelled while
   38|       |///                      downloading, encountered an error when downloading or the download not being started at all.
   39|       |/// - `completedResources`: An array of resources that are downloaded and cached successfully.
   40|       |public typealias PrefetcherProgressBlock =
   41|       |    ((_ skippedResources: [Resource], _ failedResources: [Resource], _ completedResources: [Resource]) -> Void)
   42|       |
   43|       |/// Completion block of prefetcher.
   44|       |///
   45|       |/// - `skippedResources`: An array of resources that are already cached before the prefetching starting.
   46|       |/// - `failedResources`: An array of resources that fail to be downloaded. It could because of being cancelled while
   47|       |///                      downloading, encountered an error when downloading or the download not being started at all.
   48|       |/// - `completedResources`: An array of resources that are downloaded and cached successfully.
   49|       |public typealias PrefetcherCompletionHandler =
   50|       |    ((_ skippedResources: [Resource], _ failedResources: [Resource], _ completedResources: [Resource]) -> Void)
   51|       |
   52|       |/// `ImagePrefetcher` represents a downloading manager for requesting many images via URLs, then caching them.
   53|       |/// This is useful when you know a list of image resources and want to download them before showing. It also works with
   54|       |/// some Cocoa prefetching mechanism like table view or collection view `prefetchDataSource`, to start image downloading
   55|       |/// and caching before they display on screen.
   56|       |public class ImagePrefetcher {
   57|       |    
   58|       |    /// The maximum concurrent downloads to use when prefetching images. Default is 5.
   59|       |    public var maxConcurrentDownloads = 5
   60|       |
   61|       |    
   62|       |    private let prefetchResources: [Resource]
   63|       |    private let optionsInfo: KingfisherParsedOptionsInfo
   64|       |
   65|       |    private var progressBlock: PrefetcherProgressBlock?
   66|       |    private var completionHandler: PrefetcherCompletionHandler?
   67|       |    
   68|       |    private var tasks = [URL: DownloadTask]()
   69|       |    
   70|       |    private var pendingResources: ArraySlice<Resource>
   71|       |    private var skippedResources = [Resource]()
   72|       |    private var completedResources = [Resource]()
   73|       |    private var failedResources = [Resource]()
   74|       |    
   75|       |    private var stopped = false
   76|       |    
   77|       |    // A manager used for prefetching. We will use the helper methods in manager.
   78|       |    private let manager: KingfisherManager
   79|       |    
   80|      0|    private var finished: Bool {
   81|      0|        let totalFinished = failedResources.count + skippedResources.count + completedResources.count
   82|      0|        return totalFinished == prefetchResources.count && tasks.isEmpty
   83|      0|    }
   84|       |
   85|       |    /// Creates an image prefetcher with an array of URLs.
   86|       |    ///
   87|       |    /// The prefetcher should be initiated with a list of prefetching targets. The URLs list is immutable.
   88|       |    /// After you get a valid `ImagePrefetcher` object, you call `start()` on it to begin the prefetching process.
   89|       |    /// The images which are already cached will be skipped without downloading again.
   90|       |    ///
   91|       |    /// - Parameters:
   92|       |    ///   - urls: The URLs which should be prefetched.
   93|       |    ///   - options: A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
   94|       |    ///   - progressBlock: Called every time an resource is downloaded, skipped or cancelled.
   95|       |    ///   - completionHandler: Called when the whole prefetching process finished.
   96|       |    ///
   97|       |    /// - Note:
   98|       |    /// By default, the `ImageDownloader.defaultDownloader` and `ImageCache.defaultCache` will be used as
   99|       |    /// the downloader and cache target respectively. You can specify another downloader or cache by using
  100|       |    /// a customized `KingfisherOptionsInfo`. Both the progress and completion block will be invoked in
  101|       |    /// main thread. The `.callbackQueue` value in `optionsInfo` will be ignored in this method.
  102|       |
  103|       |    public convenience init(urls: [URL],
  104|       |                         options: KingfisherOptionsInfo? = nil,
  105|       |                   progressBlock: PrefetcherProgressBlock? = nil,
  106|       |               completionHandler: PrefetcherCompletionHandler? = nil)
  107|      0|    {
  108|      0|        let resources: [Resource] = urls.map { $0 }
  109|      0|        self.init(
  110|      0|            resources: resources,
  111|      0|            options: options,
  112|      0|            progressBlock: progressBlock,
  113|      0|            completionHandler: completionHandler)
  114|      0|    }
  115|       |
  116|       |    /// Creates an image prefetcher with an array of resources.
  117|       |    ///
  118|       |    /// - Parameters:
  119|       |    ///   - resources: The resources which should be prefetched. See `Resource` type for more.
  120|       |    ///   - options: A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
  121|       |    ///   - progressBlock: Called every time an resource is downloaded, skipped or cancelled.
  122|       |    ///   - completionHandler: Called when the whole prefetching process finished.
  123|       |    ///
  124|       |    /// - Note:
  125|       |    /// By default, the `ImageDownloader.defaultDownloader` and `ImageCache.defaultCache` will be used as
  126|       |    /// the downloader and cache target respectively. You can specify another downloader or cache by using
  127|       |    /// a customized `KingfisherOptionsInfo`. Both the progress and completion block will be invoked in
  128|       |    /// main thread. The `.callbackQueue` value in `optionsInfo` will be ignored in this method.
  129|       |    public init(resources: [Resource],
  130|       |                  options: KingfisherOptionsInfo? = nil,
  131|       |            progressBlock: PrefetcherProgressBlock? = nil,
  132|       |        completionHandler: PrefetcherCompletionHandler? = nil)
  133|      0|    {
  134|      0|        var options = KingfisherParsedOptionsInfo(options)
  135|      0|        prefetchResources = resources
  136|      0|        pendingResources = ArraySlice(resources)
  137|      0|        
  138|      0|        // We want all callbacks from our prefetch queue, so we should ignore the callback queue in options.
  139|      0|        // Add our own callback dispatch queue to make sure all internal callbacks are
  140|      0|        // coming back in our expected queue.
  141|      0|        options.callbackQueue = .untouch
  142|      0|        optionsInfo = options
  143|      0|        
  144|      0|        let cache = optionsInfo.targetCache ?? .default
  145|      0|        let downloader = optionsInfo.downloader ?? .default
  146|      0|        manager = KingfisherManager(downloader: downloader, cache: cache)
  147|      0|        
  148|      0|        self.progressBlock = progressBlock
  149|      0|        self.completionHandler = completionHandler
  150|      0|    }
  151|       |
  152|       |    /// Starts to download the resources and cache them. This can be useful for background downloading
  153|       |    /// of assets that are required for later use in an app. This code will not try and update any UI
  154|       |    /// with the results of the process.
  155|      0|    public func start() {
  156|      0|        guard !stopped else {
  157|      0|            assertionFailure("You can not restart the same prefetcher. Try to create a new prefetcher.")
  158|      0|            handleComplete()
  159|      0|            return
  160|      0|        }
  161|      0|
  162|      0|        guard maxConcurrentDownloads > 0 else {
  163|      0|            assertionFailure("There should be concurrent downloads value should be at least 1.")
  164|      0|            handleComplete()
  165|      0|            return
  166|      0|        }
  167|      0|
  168|      0|        // Empty case.
  169|      0|        guard prefetchResources.count > 0 else {
  170|      0|            handleComplete()
  171|      0|            return
  172|      0|        }
  173|      0|
  174|      0|        let initialConcurrentDownloads = min(prefetchResources.count, maxConcurrentDownloads)
  175|      0|        for _ in 0 ..< initialConcurrentDownloads {
  176|      0|            if let resource = self.pendingResources.popFirst() {
  177|      0|                self.startPrefetching(resource)
  178|      0|            }
  179|      0|        }
  180|      0|    }
  181|       |
  182|       |    /// Stops current downloading progress, and cancel any future prefetching activity that might be occuring.
  183|      0|    public func stop() {
  184|      0|        if finished { return }
  185|      0|        stopped = true
  186|      0|        tasks.values.forEach { $0.cancel() }
  187|      0|    }
  188|       |    
  189|      0|    func downloadAndCache(_ resource: Resource) {
  190|      0|
  191|      0|        let downloadTaskCompletionHandler: ((Result<RetrieveImageResult, KingfisherError>) -> Void) = { result in
  192|      0|            self.tasks.removeValue(forKey: resource.downloadURL)
  193|      0|            if let _ = result.error {
  194|      0|                self.failedResources.append(resource)
  195|      0|            } else {
  196|      0|                self.completedResources.append(resource)
  197|      0|            }
  198|      0|            
  199|      0|            self.reportProgress()
  200|      0|            if self.stopped {
  201|      0|                if self.tasks.isEmpty {
  202|      0|                    self.failedResources.append(contentsOf: self.pendingResources)
  203|      0|                    self.handleComplete()
  204|      0|                }
  205|      0|            } else {
  206|      0|                self.reportCompletionOrStartNext()
  207|      0|            }
  208|      0|        }
  209|      0|
  210|      0|        let downloadTask = manager.loadAndCacheImage(
  211|      0|            source: .network(resource),
  212|      0|            options: optionsInfo,
  213|      0|            completionHandler: downloadTaskCompletionHandler)
  214|      0|        
  215|      0|        if let downloadTask = downloadTask {
  216|      0|            tasks[resource.downloadURL] = downloadTask
  217|      0|        }
  218|      0|    }
  219|       |    
  220|      0|    func append(cached resource: Resource) {
  221|      0|        skippedResources.append(resource)
  222|      0| 
  223|      0|        reportProgress()
  224|      0|        reportCompletionOrStartNext()
  225|      0|    }
  226|       |    
  227|       |    func startPrefetching(_ resource: Resource)
  228|      0|    {
  229|      0|        if optionsInfo.forceRefresh {
  230|      0|            downloadAndCache(resource)
  231|      0|            return
  232|      0|        }
  233|      0|        
  234|      0|        let cacheType = manager.cache.imageCachedType(
  235|      0|            forKey: resource.cacheKey,
  236|      0|            processorIdentifier: optionsInfo.processor.identifier)
  237|      0|        switch cacheType {
  238|      0|        case .memory:
  239|      0|            append(cached: resource)
  240|      0|        case .disk:
  241|      0|            if optionsInfo.alsoPrefetchToMemory {
  242|      0|                _ = manager.retrieveImageFromCache(
  243|      0|                    source: .network(resource),
  244|      0|                    options: optionsInfo)
  245|      0|                {
  246|      0|                    _ in
  247|      0|                    self.append(cached: resource)
  248|      0|                }
  249|      0|            } else {
  250|      0|                append(cached: resource)
  251|      0|            }
  252|      0|        case .none:
  253|      0|            downloadAndCache(resource)
  254|      0|        }
  255|      0|    }
  256|       |    
  257|      0|    func reportProgress() {
  258|      0|        progressBlock?(skippedResources, failedResources, completedResources)
  259|      0|    }
  260|       |    
  261|      0|    func reportCompletionOrStartNext() {
  262|      0|        if let resource = self.pendingResources.popFirst() {
  263|      0|            startPrefetching(resource)
  264|      0|        } else {
  265|      0|            guard tasks.isEmpty else { return }
  266|      0|            handleComplete()
  267|      0|        }
  268|      0|    }
  269|       |    
  270|      0|    func handleComplete() {
  271|      0|        // The completion handler should be called on the main thread
  272|      0|        DispatchQueue.main.safeAsync {
  273|      0|            self.completionHandler?(self.skippedResources, self.failedResources, self.completedResources)
  274|      0|            self.completionHandler = nil
  275|      0|            self.progressBlock = nil
  276|      0|        }
  277|      0|    }
  278|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/RedirectHandler.swift:
    1|       |//
    2|       |//  RedirectHandler.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Roman Maidanovych on 2018/12/10.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents and wraps a method for modifying request during an image download request redirection.
   30|       |public protocol ImageDownloadRedirectHandler {
   31|       |
   32|       |    /// The `ImageDownloadRedirectHandler` contained will be used to change the request before redirection.
   33|       |    /// This is the posibility you can modify the image download request during redirection. You can modify the
   34|       |    /// request for some customizing purpose, such as adding auth token to the header, do basic HTTP auth or
   35|       |    /// something like url mapping.
   36|       |    ///
   37|       |    /// Usually, you pass an `ImageDownloadRedirectHandler` as the associated value of
   38|       |    /// `KingfisherOptionsInfoItem.redirectHandler` and use it as the `options` parameter in related methods.
   39|       |    ///
   40|       |    /// If you do nothing with the input `request` and return it as is, a downloading process will redirect with it.
   41|       |    ///
   42|       |    /// - Parameters:
   43|       |    ///   - task: The current `SessionDataTask` which triggers this redirect.
   44|       |    ///   - response: The response received during redirection.
   45|       |    ///   - newRequest: The request for redirection which can be modified.
   46|       |    ///   - completionHandler: A closure for being called with modified request.
   47|       |    func handleHTTPRedirection(
   48|       |        for task: SessionDataTask,
   49|       |        response: HTTPURLResponse,
   50|       |        newRequest: URLRequest,
   51|       |        completionHandler: @escaping (URLRequest?) -> Void)
   52|       |}
   53|       |
   54|       |/// A wrapper for creating an `ImageDownloadRedirectHandler` easier.
   55|       |/// This type conforms to `ImageDownloadRedirectHandler` and wraps an redirect request modify block.
   56|       |public struct AnyRedirectHandler: ImageDownloadRedirectHandler {
   57|       |    
   58|       |    let block: (SessionDataTask, HTTPURLResponse, URLRequest, (URLRequest?) -> Void) -> Void
   59|       |
   60|       |    public func handleHTTPRedirection(
   61|       |        for task: SessionDataTask,
   62|       |        response: HTTPURLResponse,
   63|       |        newRequest: URLRequest,
   64|       |        completionHandler: @escaping (URLRequest?) -> Void)
   65|      0|    {
   66|      0|        block(task, response, newRequest, completionHandler)
   67|      0|    }
   68|       |    
   69|       |    /// Creates a value of `ImageDownloadRedirectHandler` which runs `modify` block.
   70|       |    ///
   71|       |    /// - Parameter modify: The request modifying block runs when a request modifying task comes.
   72|       |    ///
   73|      0|    public init(handle: @escaping (SessionDataTask, HTTPURLResponse, URLRequest, (URLRequest?) -> Void) -> Void) {
   74|      0|        block = handle
   75|      0|    }
   76|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/RequestModifier.swift:
    1|       |//
    2|       |//  RequestModifier.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2016/09/05.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents and wraps a method for modifying request before an image download request starts.
   30|       |public protocol ImageDownloadRequestModifier {
   31|       |
   32|       |    /// A method will be called just before the `request` being sent.
   33|       |    /// This is the last chance you can modify the image download request. You can modify the request for some
   34|       |    /// customizing purpose, such as adding auth token to the header, do basic HTTP auth or something like url mapping.
   35|       |    ///
   36|       |    /// Usually, you pass an `ImageDownloadRequestModifier` as the associated value of
   37|       |    /// `KingfisherOptionsInfoItem.requestModifier` and use it as the `options` parameter in related methods.
   38|       |    ///
   39|       |    /// If you do nothing with the input `request` and return it as is, a downloading process will start with it.
   40|       |    ///
   41|       |    /// - Parameter request: The input request contains necessary information like `url`. This request is generated
   42|       |    ///                      according to your resource url as a GET request.
   43|       |    /// - Returns: A modified version of request, which you wish to use for downloading an image. If `nil` returned,
   44|       |    ///            a `KingfisherError.requestError` with `.emptyRequest` as its reason will occur.
   45|       |    ///
   46|       |    func modified(for request: URLRequest) -> URLRequest?
   47|       |}
   48|       |
   49|       |/// A wrapper for creating an `ImageDownloadRequestModifier` easier.
   50|       |/// This type conforms to `ImageDownloadRequestModifier` and wraps an image modify block.
   51|       |public struct AnyModifier: ImageDownloadRequestModifier {
   52|       |    
   53|       |    let block: (URLRequest) -> URLRequest?
   54|       |
   55|       |    /// For `ImageDownloadRequestModifier` conformation.
   56|      0|    public func modified(for request: URLRequest) -> URLRequest? {
   57|      0|        return block(request)
   58|      0|    }
   59|       |    
   60|       |    /// Creates a value of `ImageDownloadRequestModifier` which runs `modify` block.
   61|       |    ///
   62|       |    /// - Parameter modify: The request modifying block runs when a request modifying task comes.
   63|       |    ///                     The return `URLRequest?` value of this block will be used as the image download request.
   64|       |    ///                     If `nil` returned, a `KingfisherError.requestError` with `.emptyRequest` as its
   65|       |    ///                     reason will occur.
   66|      0|    public init(modify: @escaping (URLRequest) -> URLRequest?) {
   67|      0|        block = modify
   68|      0|    }
   69|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/SessionDataTask.swift:
    1|       |//
    2|       |//  SessionDataTask.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/11/1.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents a session data task in `ImageDownloader`. It consists of an underlying `URLSessionDataTask` and
   30|       |/// an array of `TaskCallback`. Multiple `TaskCallback`s could be added for a single downloading data task.
   31|       |public class SessionDataTask {
   32|       |
   33|       |    /// Represents the type of token which used for cancelling a task.
   34|       |    public typealias CancelToken = Int
   35|       |
   36|       |    struct TaskCallback {
   37|       |        let onProgress: Delegate<(Int64, Int64), Void>?
   38|       |        let onCompleted: Delegate<Result<ImageLoadingResult, KingfisherError>, Void>?
   39|       |        let options: KingfisherParsedOptionsInfo
   40|       |    }
   41|       |
   42|       |    /// Downloaded raw data of current task.
   43|       |    public private(set) var mutableData: Data
   44|       |
   45|       |    /// The underlying download task. It is only for debugging purpose when you encountered an error. You should not
   46|       |    /// modify the content of this task or start it yourself.
   47|       |    public let task: URLSessionDataTask
   48|       |    private var callbacksStore = [CancelToken: TaskCallback]()
   49|       |
   50|      0|    var callbacks: Dictionary<SessionDataTask.CancelToken, SessionDataTask.TaskCallback>.Values {
   51|      0|        return callbacksStore.values
   52|      0|    }
   53|       |
   54|       |    private var currentToken = 0
   55|       |    private let lock = NSLock()
   56|       |
   57|       |    let onTaskDone = Delegate<(Result<(Data, URLResponse?), KingfisherError>, [TaskCallback]), Void>()
   58|       |    let onCallbackCancelled = Delegate<(CancelToken, TaskCallback), Void>()
   59|       |
   60|       |    var started = false
   61|      0|    var containsCallbacks: Bool {
   62|      0|        // We should be able to use `task.state != .running` to check it.
   63|      0|        // However, in some rare cases, cancelling the task does not change
   64|      0|        // task state to `.cancelling` immediately, but still in `.running`.
   65|      0|        // So we need to check callbacks count to for sure that it is safe to remove the
   66|      0|        // task in delegate.
   67|      0|        return !callbacks.isEmpty
   68|      0|    }
   69|       |
   70|      0|    init(task: URLSessionDataTask) {
   71|      0|        self.task = task
   72|      0|        mutableData = Data()
   73|      0|    }
   74|       |
   75|      0|    func addCallback(_ callback: TaskCallback) -> CancelToken {
   76|      0|        lock.lock()
   77|      0|        defer { lock.unlock() }
   78|      0|        callbacksStore[currentToken] = callback
   79|      0|        defer { currentToken += 1 }
   80|      0|        return currentToken
   81|      0|    }
   82|       |
   83|      0|    func removeCallback(_ token: CancelToken) -> TaskCallback? {
   84|      0|        lock.lock()
   85|      0|        defer { lock.unlock() }
   86|      0|        if let callback = callbacksStore[token] {
   87|      0|            callbacksStore[token] = nil
   88|      0|            return callback
   89|      0|        }
   90|      0|        return nil
   91|      0|    }
   92|       |
   93|      0|    func resume() {
   94|      0|        guard !started else { return }
   95|      0|        started = true
   96|      0|        task.resume()
   97|      0|    }
   98|       |
   99|      0|    func cancel(token: CancelToken) {
  100|      0|        guard let callback = removeCallback(token) else {
  101|      0|            return
  102|      0|        }
  103|      0|        if callbacksStore.count == 0 {
  104|      0|            task.cancel()
  105|      0|        }
  106|      0|        onCallbackCancelled.call((token, callback))
  107|      0|    }
  108|       |
  109|      0|    func forceCancel() {
  110|      0|        for token in callbacksStore.keys {
  111|      0|            cancel(token: token)
  112|      0|        }
  113|      0|    }
  114|       |
  115|      0|    func didReceiveData(_ data: Data) {
  116|      0|        mutableData.append(data)
  117|      0|    }
  118|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Networking/SessionDelegate.swift:
    1|       |//
    2|       |//  SessionDelegate.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/11/1.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |// Represents the delegate object of downloader session. It also behave like a task manager for downloading.
   30|       |class SessionDelegate: NSObject {
   31|       |
   32|       |    typealias SessionChallengeFunc = (
   33|       |        URLSession,
   34|       |        URLAuthenticationChallenge,
   35|       |        (URLSession.AuthChallengeDisposition, URLCredential?) -> Void
   36|       |    )
   37|       |
   38|       |    typealias SessionTaskChallengeFunc = (
   39|       |        URLSession,
   40|       |        URLSessionTask,
   41|       |        URLAuthenticationChallenge,
   42|       |        (URLSession.AuthChallengeDisposition, URLCredential?) -> Void
   43|       |    )
   44|       |
   45|       |    private var tasks: [URL: SessionDataTask] = [:]
   46|       |    private let lock = NSLock()
   47|       |
   48|       |    let onValidStatusCode = Delegate<Int, Bool>()
   49|       |    let onDownloadingFinished = Delegate<(URL, Result<URLResponse, KingfisherError>), Void>()
   50|       |    let onDidDownloadData = Delegate<SessionDataTask, Data?>()
   51|       |
   52|       |    let onReceiveSessionChallenge = Delegate<SessionChallengeFunc, Void>()
   53|       |    let onReceiveSessionTaskChallenge = Delegate<SessionTaskChallengeFunc, Void>()
   54|       |
   55|       |    func add(
   56|       |        _ dataTask: URLSessionDataTask,
   57|       |        url: URL,
   58|       |        callback: SessionDataTask.TaskCallback) -> DownloadTask
   59|      0|    {
   60|      0|        lock.lock()
   61|      0|        defer { lock.unlock() }
   62|      0|
   63|      0|        // Create a new task if necessary.
   64|      0|        let task = SessionDataTask(task: dataTask)
   65|      0|        task.onCallbackCancelled.delegate(on: self) { [unowned task] (self, value) in
   66|      0|            let (token, callback) = value
   67|      0|
   68|      0|            let error = KingfisherError.requestError(reason: .taskCancelled(task: task, token: token))
   69|      0|            task.onTaskDone.call((.failure(error), [callback]))
   70|      0|            // No other callbacks waiting, we can clear the task now.
   71|      0|            if !task.containsCallbacks {
   72|      0|                let dataTask = task.task
   73|      0|                self.remove(dataTask, acquireLock: true)
   74|      0|            }
   75|      0|        }
   76|      0|        let token = task.addCallback(callback)
   77|      0|        tasks[url] = task
   78|      0|        return DownloadTask(sessionTask: task, cancelToken: token)
   79|      0|    }
   80|       |
   81|       |    func append(
   82|       |        _ task: SessionDataTask,
   83|       |        url: URL,
   84|       |        callback: SessionDataTask.TaskCallback) -> DownloadTask
   85|      0|    {
   86|      0|        lock.lock()
   87|      0|        defer { lock.unlock() }
   88|      0|        let token = task.addCallback(callback)
   89|      0|        return DownloadTask(sessionTask: task, cancelToken: token)
   90|      0|    }
   91|       |
   92|      0|    private func remove(_ task: URLSessionTask, acquireLock: Bool) {
   93|      0|        guard let url = task.originalRequest?.url else {
   94|      0|            return
   95|      0|        }
   96|      0|        if acquireLock { lock.lock() }
   97|      0|        tasks[url] = nil
   98|      0|        if acquireLock { lock.unlock() }
   99|      0|    }
  100|       |
  101|      0|    private func task(for task: URLSessionTask) -> SessionDataTask? {
  102|      0|        guard let url = task.originalRequest?.url else {
  103|      0|            return nil
  104|      0|        }
  105|      0|        guard let sessionTask = tasks[url] else {
  106|      0|            return nil
  107|      0|        }
  108|      0|        guard sessionTask.task.taskIdentifier == task.taskIdentifier else {
  109|      0|            return nil
  110|      0|        }
  111|      0|        return sessionTask
  112|      0|    }
  113|       |
  114|      0|    func task(for url: URL) -> SessionDataTask? {
  115|      0|        lock.lock()
  116|      0|        defer { lock.unlock() }
  117|      0|        return tasks[url]
  118|      0|    }
  119|       |
  120|      0|    func cancelAll() {
  121|      0|        for task in tasks.values {
  122|      0|            task.forceCancel()
  123|      0|        }
  124|      0|    }
  125|       |
  126|      0|    func cancel(url: URL) {
  127|      0|        let task = tasks[url]
  128|      0|        task?.forceCancel()
  129|      0|    }
  130|       |}
  131|       |
  132|       |extension SessionDelegate: URLSessionDataDelegate {
  133|       |
  134|       |    func urlSession(
  135|       |        _ session: URLSession,
  136|       |        dataTask: URLSessionDataTask,
  137|       |        didReceive response: URLResponse,
  138|       |        completionHandler: @escaping (URLSession.ResponseDisposition) -> Void)
  139|      0|    {
  140|      0|        lock.lock()
  141|      0|        defer { lock.unlock() }
  142|      0|
  143|      0|        guard let httpResponse = response as? HTTPURLResponse else {
  144|      0|            let error = KingfisherError.responseError(reason: .invalidURLResponse(response: response))
  145|      0|            onCompleted(task: dataTask, result: .failure(error))
  146|      0|            completionHandler(.cancel)
  147|      0|            return
  148|      0|        }
  149|      0|
  150|      0|        let httpStatusCode = httpResponse.statusCode
  151|      0|        guard onValidStatusCode.call(httpStatusCode) == true else {
  152|      0|            let error = KingfisherError.responseError(reason: .invalidHTTPStatusCode(response: httpResponse))
  153|      0|            onCompleted(task: dataTask, result: .failure(error))
  154|      0|            completionHandler(.cancel)
  155|      0|            return
  156|      0|        }
  157|      0|        completionHandler(.allow)
  158|      0|    }
  159|       |
  160|      0|    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
  161|      0|        lock.lock()
  162|      0|        defer { lock.unlock() }
  163|      0|
  164|      0|        guard let task = self.task(for: dataTask) else {
  165|      0|            return
  166|      0|        }
  167|      0|        task.didReceiveData(data)
  168|      0|
  169|      0|        if let expectedContentLength = dataTask.response?.expectedContentLength, expectedContentLength != -1 {
  170|      0|            let dataLength = Int64(task.mutableData.count)
  171|      0|            DispatchQueue.main.async {
  172|      0|                task.callbacks.forEach { callback in
  173|      0|                    callback.onProgress?.call((dataLength, expectedContentLength))
  174|      0|                }
  175|      0|            }
  176|      0|        }
  177|      0|    }
  178|       |
  179|      0|    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
  180|      0|        lock.lock()
  181|      0|        defer { lock.unlock() }
  182|      0|
  183|      0|        guard let sessionTask = self.task(for: task) else { return }
  184|      0|
  185|      0|        if let url = task.originalRequest?.url {
  186|      0|            let result: Result<URLResponse, KingfisherError>
  187|      0|            if let error = error {
  188|      0|                result = .failure(KingfisherError.responseError(reason: .URLSessionError(error: error)))
  189|      0|            } else if let response = task.response {
  190|      0|                result = .success(response)
  191|      0|            } else {
  192|      0|                result = .failure(KingfisherError.responseError(reason: .noURLResponse(task: sessionTask)))
  193|      0|            }
  194|      0|            onDownloadingFinished.call((url, result))
  195|      0|        }
  196|      0|
  197|      0|        let result: Result<(Data, URLResponse?), KingfisherError>
  198|      0|        if let error = error {
  199|      0|            result = .failure(KingfisherError.responseError(reason: .URLSessionError(error: error)))
  200|      0|        } else {
  201|      0|            if let data = onDidDownloadData.call(sessionTask), let finalData = data {
  202|      0|                result = .success((finalData, task.response))
  203|      0|            } else {
  204|      0|                result = .failure(KingfisherError.responseError(reason: .dataModifyingFailed(task: sessionTask)))
  205|      0|            }
  206|      0|        }
  207|      0|        onCompleted(task: task, result: result)
  208|      0|    }
  209|       |
  210|       |    func urlSession(
  211|       |        _ session: URLSession,
  212|       |        didReceive challenge: URLAuthenticationChallenge,
  213|       |        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  214|      0|    {
  215|      0|        onReceiveSessionChallenge.call((session, challenge, completionHandler))
  216|      0|    }
  217|       |
  218|       |    func urlSession(
  219|       |        _ session: URLSession,
  220|       |        task: URLSessionTask,
  221|       |        didReceive challenge: URLAuthenticationChallenge,
  222|       |        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  223|      0|    {
  224|      0|        onReceiveSessionTaskChallenge.call((session, task, challenge, completionHandler))
  225|      0|    }
  226|       |    
  227|       |    func urlSession(
  228|       |        _ session: URLSession,
  229|       |        task: URLSessionTask,
  230|       |        willPerformHTTPRedirection response: HTTPURLResponse,
  231|       |        newRequest request: URLRequest,
  232|       |        completionHandler: @escaping (URLRequest?) -> Void)
  233|      0|    {
  234|      0|        lock.lock()
  235|      0|        defer { lock.unlock() }
  236|      0|        guard let sessionDataTask = self.task(for: task),
  237|      0|              let redirectHandler = Array(sessionDataTask.callbacks).last?.options.redirectHandler else
  238|      0|        {
  239|      0|            completionHandler(request)
  240|      0|            return
  241|      0|        }
  242|      0|        
  243|      0|        redirectHandler.handleHTTPRedirection(
  244|      0|            for: sessionDataTask,
  245|      0|            response: response,
  246|      0|            newRequest: request,
  247|      0|            completionHandler: completionHandler)
  248|      0|    }
  249|       |
  250|      0|    private func onCompleted(task: URLSessionTask, result: Result<(Data, URLResponse?), KingfisherError>) {
  251|      0|        guard let sessionTask = self.task(for: task) else {
  252|      0|            return
  253|      0|        }
  254|      0|        // The lock should be already acquired in the session delegate queue
  255|      0|        // by the caller `urlSession(_:task:didCompleteWithError:)`.
  256|      0|        remove(task, acquireLock: false)
  257|      0|        sessionTask.onTaskDone.call((result, Array(sessionTask.callbacks)))
  258|      0|    }
  259|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Utility/Box.swift:
    1|       |//
    2|       |//  Box.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/3/17.
    6|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    7|       |//
    8|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    9|       |//  of this software and associated documentation files (the "Software"), to deal
   10|       |//  in the Software without restriction, including without limitation the rights
   11|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   12|       |//  copies of the Software, and to permit persons to whom the Software is
   13|       |//  furnished to do so, subject to the following conditions:
   14|       |//
   15|       |//  The above copyright notice and this permission notice shall be included in
   16|       |//  all copies or substantial portions of the Software.
   17|       |//
   18|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   19|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   20|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   21|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   22|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   23|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   24|       |//  THE SOFTWARE.
   25|       |
   26|       |import Foundation
   27|       |
   28|       |class Box<T> {
   29|       |    let value: T
   30|       |    
   31|      0|    init(_ value: T) {
   32|      0|        self.value = value
   33|      0|    }
   34|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Utility/CallbackQueue.swift:
    1|       |//
    2|       |//  CallbackQueue.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/10/15.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Represents callback queue behaviors when an calling of closure be dispatched.
   30|       |///
   31|       |/// - asyncMain: Dispatch the calling to `DispatchQueue.main` with an `async` behavior.
   32|       |/// - currentMainOrAsync: Dispatch the calling to `DispatchQueue.main` with an `async` behavior if current queue is not
   33|       |///                       `.main`. Otherwise, call the closure immediately in current main queue.
   34|       |/// - untouch: Do not change the calling queue for closure.
   35|       |/// - dispatch: Dispatches to a specified `DispatchQueue`.
   36|       |public enum CallbackQueue {
   37|       |    /// Dispatch the calling to `DispatchQueue.main` with an `async` behavior.
   38|       |    case mainAsync
   39|       |    /// Dispatch the calling to `DispatchQueue.main` with an `async` behavior if current queue is not
   40|       |    /// `.main`. Otherwise, call the closure immediately in current main queue.
   41|       |    case mainCurrentOrAsync
   42|       |    /// Do not change the calling queue for closure.
   43|       |    case untouch
   44|       |    /// Dispatches to a specified `DispatchQueue`.
   45|       |    case dispatch(DispatchQueue)
   46|       |    
   47|      0|    public func execute(_ block: @escaping () -> Void) {
   48|      0|        switch self {
   49|      0|        case .mainAsync:
   50|      0|            DispatchQueue.main.async { block() }
   51|      0|        case .mainCurrentOrAsync:
   52|      0|            DispatchQueue.main.safeAsync { block() }
   53|      0|        case .untouch:
   54|      0|            block()
   55|      0|        case .dispatch(let queue):
   56|      0|            queue.async { block() }
   57|      0|        }
   58|      0|    }
   59|       |
   60|      0|    var queue: DispatchQueue {
   61|      0|        switch self {
   62|      0|        case .mainAsync: return .main
   63|      0|        case .mainCurrentOrAsync: return .main
   64|      0|        case .untouch: return OperationQueue.current?.underlyingQueue ?? .main
   65|      0|        case .dispatch(let queue): return queue
   66|      0|        }
   67|      0|    }
   68|       |}
   69|       |
   70|       |extension DispatchQueue {
   71|       |    // This method will dispatch the `block` to self.
   72|       |    // If `self` is the main queue, and current thread is main thread, the block
   73|       |    // will be invoked immediately instead of being dispatched.
   74|      0|    func safeAsync(_ block: @escaping ()->()) {
   75|      0|        if self === DispatchQueue.main && Thread.isMainThread {
   76|      0|            block()
   77|      0|        } else {
   78|      0|            async { block() }
   79|      0|        }
   80|      0|    }
   81|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Utility/Delegate.swift:
    1|       |//
    2|       |//  Delegate.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/10/10.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// A delegate helper type to "shadow" weak `self`, to prevent creating an unexpected retain cycle.
   30|       |class Delegate<Input, Output> {
   31|      0|    init() {}
   32|       |    
   33|       |    private var block: ((Input) -> Output?)?
   34|       |    
   35|      0|    func delegate<T: AnyObject>(on target: T, block: ((T, Input) -> Output)?) {
   36|      0|        // The `target` is weak inside block, so you do not need to worry about it in the caller side.
   37|      0|        self.block = { [weak target] input in
   38|      0|            guard let target = target else { return nil }
   39|      0|            return block?(target, input)
   40|      0|        }
   41|      0|    }
   42|       |    
   43|      0|    func call(_ input: Input) -> Output? {
   44|      0|        return block?(input)
   45|      0|    }
   46|       |}
   47|       |
   48|       |extension Delegate where Input == Void {
   49|       |    // To make syntax better for `Void` input.
   50|      0|    func call() -> Output? {
   51|      0|        return call(())
   52|      0|    }
   53|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Utility/ExtensionHelpers.swift:
    1|       |//
    2|       |//  ExtensionHelpers.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/09/28.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |extension Float {
   30|      0|    var isEven: Bool {
   31|      0|        return truncatingRemainder(dividingBy: 2.0) == 0
   32|      0|    }
   33|       |}
   34|       |
   35|       |#if canImport(AppKit)
   36|       |import AppKit
   37|       |extension NSBezierPath {
   38|       |    convenience init(roundedRect rect: NSRect, topLeftRadius: CGFloat, topRightRadius: CGFloat,
   39|       |                     bottomLeftRadius: CGFloat, bottomRightRadius: CGFloat)
   40|       |    {
   41|       |        self.init()
   42|       |        
   43|       |        let maxCorner = min(rect.width, rect.height) / 2
   44|       |        
   45|       |        let radiusTopLeft = min(maxCorner, max(0, topLeftRadius))
   46|       |        let radiusTopRight = min(maxCorner, max(0, topRightRadius))
   47|       |        let radiusBottomLeft = min(maxCorner, max(0, bottomLeftRadius))
   48|       |        let radiusBottomRight = min(maxCorner, max(0, bottomRightRadius))
   49|       |        
   50|       |        guard !rect.isEmpty else {
   51|       |            return
   52|       |        }
   53|       |        
   54|       |        let topLeft = NSPoint(x: rect.minX, y: rect.maxY)
   55|       |        let topRight = NSPoint(x: rect.maxX, y: rect.maxY)
   56|       |        let bottomRight = NSPoint(x: rect.maxX, y: rect.minY)
   57|       |        
   58|       |        move(to: NSPoint(x: rect.midX, y: rect.maxY))
   59|       |        appendArc(from: topLeft, to: rect.origin, radius: radiusTopLeft)
   60|       |        appendArc(from: rect.origin, to: bottomRight, radius: radiusBottomLeft)
   61|       |        appendArc(from: bottomRight, to: topRight, radius: radiusBottomRight)
   62|       |        appendArc(from: topRight, to: topLeft, radius: radiusTopRight)
   63|       |        close()
   64|       |    }
   65|       |    
   66|       |    convenience init(roundedRect rect: NSRect, byRoundingCorners corners: RectCorner, radius: CGFloat) {
   67|       |        let radiusTopLeft = corners.contains(.topLeft) ? radius : 0
   68|       |        let radiusTopRight = corners.contains(.topRight) ? radius : 0
   69|       |        let radiusBottomLeft = corners.contains(.bottomLeft) ? radius : 0
   70|       |        let radiusBottomRight = corners.contains(.bottomRight) ? radius : 0
   71|       |        
   72|       |        self.init(roundedRect: rect, topLeftRadius: radiusTopLeft, topRightRadius: radiusTopRight,
   73|       |                  bottomLeftRadius: radiusBottomLeft, bottomRightRadius: radiusBottomRight)
   74|       |    }
   75|       |}
   76|       |
   77|       |extension Image {
   78|       |    // macOS does not support scale. This is just for code compatibility across platforms.
   79|       |    convenience init?(data: Data, scale: CGFloat) {
   80|       |        self.init(data: data)
   81|       |    }
   82|       |}
   83|       |#endif
   84|       |
   85|       |#if canImport(UIKit)
   86|       |import UIKit
   87|       |extension RectCorner {
   88|      0|    var uiRectCorner: UIRectCorner {
   89|      0|        
   90|      0|        var result: UIRectCorner = []
   91|      0|        
   92|      0|        if contains(.topLeft) { result.insert(.topLeft) }
   93|      0|        if contains(.topRight) { result.insert(.topRight) }
   94|      0|        if contains(.bottomLeft) { result.insert(.bottomLeft) }
   95|      0|        if contains(.bottomRight) { result.insert(.bottomRight) }
   96|      0|        
   97|      0|        return result
   98|      0|    }
   99|       |}
  100|       |#endif
  101|       |
  102|       |extension Date {
  103|      0|    var isPast: Bool {
  104|      0|        return isPast(referenceDate: Date())
  105|      0|    }
  106|       |
  107|      0|    var isFuture: Bool {
  108|      0|        return !isPast
  109|      0|    }
  110|       |
  111|      0|    func isPast(referenceDate: Date) -> Bool {
  112|      0|        return timeIntervalSince(referenceDate) <= 0
  113|      0|    }
  114|       |
  115|      0|    func isFuture(referenceDate: Date) -> Bool {
  116|      0|        return !isPast(referenceDate: referenceDate)
  117|      0|    }
  118|       |
  119|       |    // `Date` in memory is a wrap for `TimeInterval`. But in file attribute it can only accept `Int` number.
  120|       |    // By default the system will `round` it. But it is not friendly for testing purpose.
  121|       |    // So we always `ceil` the value when used for file attributes.
  122|      0|    var fileAttributeDate: Date {
  123|      0|        return Date(timeIntervalSince1970: ceil(timeIntervalSince1970))
  124|      0|    }
  125|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Utility/Result.swift:
    1|       |//
    2|       |//  Result.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/09/22.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |// This is a copy from https://github.com/apple/swift/pull/19982
   30|       |// If this PR is merged to stblib later, we may need to remove these content by a Swift version flag.
   31|       |
   32|       |/// A value that represents either a success or failure, capturing associated
   33|       |/// values in both cases.
   34|       |public enum Result<Value, Error> {
   35|       |    /// A success, storing a `Value`.
   36|       |    case success(Value)
   37|       |    
   38|       |    /// A failure, storing an `Error`.
   39|       |    case failure(Error)
   40|       |    
   41|       |    /// The stored value of a successful `Result`. `nil` if the `Result` was a
   42|       |    /// failure.
   43|      0|    public var value: Value? {
   44|      0|        switch self {
   45|      0|        case let .success(value):
   46|      0|            return value
   47|      0|        case .failure:
   48|      0|            return nil
   49|      0|        }
   50|      0|    }
   51|       |    
   52|       |    /// The stored value of a failure `Result`. `nil` if the `Result` was a
   53|       |    /// success.
   54|      0|    public var error: Error? {
   55|      0|        switch self {
   56|      0|        case let .failure(error):
   57|      0|            return error
   58|      0|        case .success:
   59|      0|            return nil
   60|      0|        }
   61|      0|    }
   62|       |    
   63|       |    /// A Boolean value indicating whether the `Result` as a success.
   64|      0|    public var isSuccess: Bool {
   65|      0|        switch self {
   66|      0|        case .success:
   67|      0|            return true
   68|      0|        case .failure:
   69|      0|            return false
   70|      0|        }
   71|      0|    }
   72|       |    
   73|       |    /// Evaluates the given transform closure when this `Result` instance is
   74|       |    /// `.success`, passing the value as a parameter.
   75|       |    ///
   76|       |    /// Use the `map` method with a closure that returns a non-`Result` value.
   77|       |    ///
   78|       |    /// - Parameter transform: A closure that takes the successful value of the
   79|       |    ///   instance.
   80|       |    /// - Returns: A new `Result` instance with the result of the transform, if
   81|       |    ///   it was applied.
   82|       |    public func map<NewValue>(
   83|       |        _ transform: (Value) -> NewValue
   84|      0|        ) -> Result<NewValue, Error> {
   85|      0|        switch self {
   86|      0|        case let .success(value):
   87|      0|            return .success(transform(value))
   88|      0|        case let .failure(error):
   89|      0|            return .failure(error)
   90|      0|        }
   91|      0|    }
   92|       |    
   93|       |    /// Evaluates the given transform closure when this `Result` instance is
   94|       |    /// `.failure`, passing the error as a parameter.
   95|       |    ///
   96|       |    /// Use the `mapError` method with a closure that returns a non-`Result`
   97|       |    /// value.
   98|       |    ///
   99|       |    /// - Parameter transform: A closure that takes the failure value of the
  100|       |    ///   instance.
  101|       |    /// - Returns: A new `Result` instance with the result of the transform, if
  102|       |    ///   it was applied.
  103|       |    public func mapError<NewError>(
  104|       |        _ transform: (Error) -> NewError
  105|      0|        ) -> Result<Value, NewError> {
  106|      0|        switch self {
  107|      0|        case let .success(value):
  108|      0|            return .success(value)
  109|      0|        case let .failure(error):
  110|      0|            return .failure(transform(error))
  111|      0|        }
  112|      0|    }
  113|       |    
  114|       |    /// Evaluates the given transform closure when this `Result` instance is
  115|       |    /// `.success`, passing the value as a parameter and flattening the result.
  116|       |    ///
  117|       |    /// - Parameter transform: A closure that takes the successful value of the
  118|       |    ///   instance.
  119|       |    /// - Returns: A new `Result` instance, either from the transform or from
  120|       |    ///   the previous error value.
  121|       |    public func flatMap<NewValue>(
  122|       |        _ transform: (Value) -> Result<NewValue, Error>
  123|      0|        ) -> Result<NewValue, Error> {
  124|      0|        switch self {
  125|      0|        case let .success(value):
  126|      0|            return transform(value)
  127|      0|        case let .failure(error):
  128|      0|            return .failure(error)
  129|      0|        }
  130|      0|    }
  131|       |    
  132|       |    /// Evaluates the given transform closure when this `Result` instance is
  133|       |    /// `.failure`, passing the error as a parameter and flattening the result.
  134|       |    ///
  135|       |    /// - Parameter transform: A closure that takes the error value of the
  136|       |    ///   instance.
  137|       |    /// - Returns: A new `Result` instance, either from the transform or from
  138|       |    ///   the previous success value.
  139|       |    public func flatMapError<NewError>(
  140|       |        _ transform: (Error) -> Result<Value, NewError>
  141|      0|        ) -> Result<Value, NewError> {
  142|      0|        switch self {
  143|      0|        case let .success(value):
  144|      0|            return .success(value)
  145|      0|        case let .failure(error):
  146|      0|            return transform(error)
  147|      0|        }
  148|      0|    }
  149|       |    
  150|       |    /// Evaluates the given transform closures to create a single output value.
  151|       |    ///
  152|       |    /// - Parameters:
  153|       |    ///   - onSuccess: A closure that transforms the success value.
  154|       |    ///   - onFailure: A closure that transforms the error value.
  155|       |    /// - Returns: A single `Output` value.
  156|       |    public func fold<Output>(
  157|       |        onSuccess: (Value) -> Output,
  158|       |        onFailure: (Error) -> Output
  159|      0|        ) -> Output {
  160|      0|        switch self {
  161|      0|        case let .success(value):
  162|      0|            return onSuccess(value)
  163|      0|        case let .failure(error):
  164|      0|            return onFailure(error)
  165|      0|        }
  166|      0|    }
  167|       |}
  168|       |
  169|       |extension Result where Error : Swift.Error {
  170|       |    /// Unwraps the `Result` into a throwing expression.
  171|       |    ///
  172|       |    /// - Returns: The success value, if the instance is a success.
  173|       |    /// - Throws:  The error value, if the instance is a failure.
  174|      0|    public func unwrapped() throws -> Value {
  175|      0|        switch self {
  176|      0|        case let .success(value):
  177|      0|            return value
  178|      0|        case let .failure(error):
  179|      0|            throw error
  180|      0|        }
  181|      0|    }
  182|       |}
  183|       |
  184|       |extension Result where Error == Swift.Error {
  185|       |    /// Create an instance by capturing the output of a throwing closure.
  186|       |    ///
  187|       |    /// - Parameter throwing: A throwing closure to evaluate.
  188|       |    @_transparent
  189|      0|    public init(_ throwing: () throws -> Value) {
  190|      0|        do {
  191|      0|            let value = try throwing()
  192|      0|            self = .success(value)
  193|      0|        } catch {
  194|      0|            self = .failure(error)
  195|      0|        }
  196|      0|    }
  197|       |    
  198|       |    /// Unwraps the `Result` into a throwing expression.
  199|       |    ///
  200|       |    /// - Returns: The success value, if the instance is a success.
  201|       |    /// - Throws:  The error value, if the instance is a failure.
  202|      0|    public func unwrapped() throws -> Value {
  203|      0|        switch self {
  204|      0|        case let .success(value):
  205|      0|            return value
  206|      0|        case let .failure(error):
  207|      0|            throw error
  208|      0|        }
  209|      0|    }
  210|       |    
  211|       |    /// Evaluates the given transform closure when this `Result` instance is
  212|       |    /// `.success`, passing the value as a parameter and flattening the result.
  213|       |    ///
  214|       |    /// - Parameter transform: A closure that takes the successful value of the
  215|       |    ///   instance.
  216|       |    /// - Returns: A new `Result` instance, either from the transform or from
  217|       |    ///   the previous error value.
  218|       |    public func flatMap<NewValue>(
  219|       |        _ transform: (Value) throws -> NewValue
  220|      0|        ) -> Result<NewValue, Error> {
  221|      0|        switch self {
  222|      0|        case let .success(value):
  223|      0|            do {
  224|      0|                return .success(try transform(value))
  225|      0|            } catch {
  226|      0|                return .failure(error)
  227|      0|            }
  228|      0|        case let .failure(error):
  229|      0|            return .failure(error)
  230|      0|        }
  231|      0|    }
  232|       |}
  233|       |
  234|       |extension Result : Equatable where Value : Equatable, Error : Equatable { }
  235|       |
  236|       |extension Result : Hashable where Value : Hashable, Error : Hashable {
  237|      0|    public func hash(into hasher: inout Hasher) {
  238|      0|        hasher.combine(value)
  239|      0|        hasher.combine(error)
  240|      0|    }
  241|       |}
  242|       |
  243|       |extension Result : CustomDebugStringConvertible {
  244|      0|    public var debugDescription: String {
  245|      0|        var output = "Result."
  246|      0|        switch self {
  247|      0|        case let .success(value):
  248|      0|            output += "success("
  249|      0|            debugPrint(value, terminator: "", to: &output)
  250|      0|        case let .failure(error):
  251|      0|            output += "failure("
  252|      0|            debugPrint(error, terminator: "", to: &output)
  253|      0|        }
  254|      0|        output += ")"
  255|      0|        
  256|      0|        return output
  257|      0|    }
  258|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Utility/Runtime.swift:
    1|       |//
    2|       |//  Runtime.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/10/12.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|      0|func getAssociatedObject<T>(_ object: Any, _ key: UnsafeRawPointer) -> T? {
   30|      0|    return objc_getAssociatedObject(object, key) as? T
   31|      0|}
   32|       |
   33|      0|func setRetainedAssociatedObject<T>(_ object: Any, _ key: UnsafeRawPointer, _ value: T) {
   34|      0|    objc_setAssociatedObject(object, key, value, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
   35|      0|}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Utility/SizeExtensions.swift:
    1|       |//
    2|       |//  SizeExtensions.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by onevcat on 2018/09/28.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import CoreGraphics
   28|       |
   29|       |extension CGSize: KingfisherCompatible {}
   30|       |extension KingfisherWrapper where Base == CGSize {
   31|       |    
   32|       |    /// Returns a size by resizing the `base` size to a target size under a given content mode.
   33|       |    ///
   34|       |    /// - Parameters:
   35|       |    ///   - size: The target size to resize to.
   36|       |    ///   - contentMode: Content mode of the target size should be when resizing.
   37|       |    /// - Returns: The resized size under the given `ContentMode`.
   38|      0|    public func resize(to size: CGSize, for contentMode: ContentMode) -> CGSize {
   39|      0|        switch contentMode {
   40|      0|        case .aspectFit:
   41|      0|            return constrained(size)
   42|      0|        case .aspectFill:
   43|      0|            return filling(size)
   44|      0|        case .none:
   45|      0|            return size
   46|      0|        }
   47|      0|    }
   48|       |    
   49|       |    /// Returns a size by resizing the `base` size by making it aspect fitting the given `size`.
   50|       |    ///
   51|       |    /// - Parameter size: The size in which the `base` should fit in.
   52|       |    /// - Returns: The size fitted in by the input `size`, while keeps `base` aspect.
   53|      0|    public func constrained(_ size: CGSize) -> CGSize {
   54|      0|        let aspectWidth = round(aspectRatio * size.height)
   55|      0|        let aspectHeight = round(size.width / aspectRatio)
   56|      0|        
   57|      0|        return aspectWidth > size.width ?
   58|      0|            CGSize(width: size.width, height: aspectHeight) :
   59|      0|            CGSize(width: aspectWidth, height: size.height)
   60|      0|    }
   61|       |    
   62|       |    /// Returns a size by resizing the `base` size by making it aspect filling the given `size`.
   63|       |    ///
   64|       |    /// - Parameter size: The size in which the `base` should fill.
   65|       |    /// - Returns: The size be filled by the input `size`, while keeps `base` aspect.
   66|      0|    public func filling(_ size: CGSize) -> CGSize {
   67|      0|        let aspectWidth = round(aspectRatio * size.height)
   68|      0|        let aspectHeight = round(size.width / aspectRatio)
   69|      0|        
   70|      0|        return aspectWidth < size.width ?
   71|      0|            CGSize(width: size.width, height: aspectHeight) :
   72|      0|            CGSize(width: aspectWidth, height: size.height)
   73|      0|    }
   74|       |    
   75|       |    /// Returns a `CGRect` for which the `base` size is constrained to an input `size` at a given `anchor` point.
   76|       |    ///
   77|       |    /// - Parameters:
   78|       |    ///   - size: The size in which the `base` should be constrained to.
   79|       |    ///   - anchor: An anchor point in which the size constraint should happen.
   80|       |    /// - Returns: The result `CGRect` for the constraint operation.
   81|      0|    public func constrainedRect(for size: CGSize, anchor: CGPoint) -> CGRect {
   82|      0|        
   83|      0|        let unifiedAnchor = CGPoint(x: anchor.x.clamped(to: 0.0...1.0),
   84|      0|                                    y: anchor.y.clamped(to: 0.0...1.0))
   85|      0|        
   86|      0|        let x = unifiedAnchor.x * base.width - unifiedAnchor.x * size.width
   87|      0|        let y = unifiedAnchor.y * base.height - unifiedAnchor.y * size.height
   88|      0|        let r = CGRect(x: x, y: y, width: size.width, height: size.height)
   89|      0|        
   90|      0|        let ori = CGRect(origin: .zero, size: base)
   91|      0|        return ori.intersection(r)
   92|      0|    }
   93|       |    
   94|      0|    private var aspectRatio: CGFloat {
   95|      0|        return base.height == 0.0 ? 1.0 : base.width / base.height
   96|      0|    }
   97|       |}
   98|       |
   99|       |extension CGRect {
  100|      0|    func scaled(_ scale: CGFloat) -> CGRect {
  101|      0|        return CGRect(x: origin.x * scale, y: origin.y * scale,
  102|      0|                      width: size.width * scale, height: size.height * scale)
  103|      0|    }
  104|       |}
  105|       |
  106|       |extension Comparable {
  107|      0|    func clamped(to limits: ClosedRange<Self>) -> Self {
  108|      0|        return min(max(self, limits.lowerBound), limits.upperBound)
  109|      0|    }
  110|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Utility/String+MD5.swift:
    1|       |//
    2|       |//  String+MD5.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 18//25.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |import CommonCrypto
   29|       |
   30|       |extension String: KingfisherCompatible { }
   31|       |extension KingfisherWrapper where Base == String {
   32|      0|    var md5: String {
   33|      0|        guard let data = base.data(using: .utf8) else {
   34|      0|            return base
   35|      0|        }
   36|      0|        var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))
   37|      0|        _ = data.withUnsafeBytes { bytes in
   38|      0|            return CC_MD5(bytes, CC_LONG(data.count), &digest)
   39|      0|        }
   40|      0|        
   41|      0|        return digest.map { String(format: "%02x", $0) }.joined()
   42|      0|    }
   43|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Views/AnimatedImageView.swift:
    1|       |//
    2|       |//  AnimatableImageView.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by bl4ckra1sond3tre on 4/22/16.
    6|       |//
    7|       |//  The AnimatableImageView, AnimatedFrame and Animator is a modified version of 
    8|       |//  some classes from kaishin's Gifu project (https://github.com/kaishin/Gifu)
    9|       |//
   10|       |//  The MIT License (MIT)
   11|       |//
   12|       |//  Copyright (c) 2019 Reda Lemeden.
   13|       |//
   14|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy of
   15|       |//  this software and associated documentation files (the "Software"), to deal in
   16|       |//  the Software without restriction, including without limitation the rights to
   17|       |//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   18|       |//  the Software, and to permit persons to whom the Software is furnished to do so,
   19|       |//  subject to the following conditions:
   20|       |//
   21|       |//  The above copyright notice and this permission notice shall be included in all
   22|       |//  copies or substantial portions of the Software.
   23|       |//
   24|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   25|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   26|       |//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   27|       |//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   28|       |//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   29|       |//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   30|       |//
   31|       |//  The name and characters used in the demo of this software are property of their
   32|       |//  respective owners.
   33|       |
   34|       |import UIKit
   35|       |import ImageIO
   36|       |
   37|       |/// Protocol of `AnimatedImageView`.
   38|       |public protocol AnimatedImageViewDelegate: AnyObject {
   39|       |
   40|       |    /// Called after the animatedImageView has finished each animation loop.
   41|       |    ///
   42|       |    /// - Parameters:
   43|       |    ///   - imageView: The `AnimatedImageView` that is being animated.
   44|       |    ///   - count: The looped count.
   45|       |    func animatedImageView(_ imageView: AnimatedImageView, didPlayAnimationLoops count: UInt)
   46|       |
   47|       |    /// Called after the `AnimatedImageView` has reached the max repeat count.
   48|       |    ///
   49|       |    /// - Parameter imageView: The `AnimatedImageView` that is being animated.
   50|       |    func animatedImageViewDidFinishAnimating(_ imageView: AnimatedImageView)
   51|       |}
   52|       |
   53|       |extension AnimatedImageViewDelegate {
   54|      0|    public func animatedImageView(_ imageView: AnimatedImageView, didPlayAnimationLoops count: UInt) {}
   55|      0|    public func animatedImageViewDidFinishAnimating(_ imageView: AnimatedImageView) {}
   56|       |}
   57|       |
   58|       |#if swift(>=4.2)
   59|       |let KFRunLoopModeCommon = RunLoop.Mode.common
   60|       |#else
   61|       |let KFRunLoopModeCommon = RunLoopMode.commonModes
   62|       |#endif
   63|       |
   64|       |/// Represents a subclass of `UIImageView` for displaying animated image.
   65|       |/// Different from showing animated image in a normal `UIImageView` (which load all frames at one time),
   66|       |/// `AnimatedImageView` only tries to load several frames (defined by `framePreloadCount`) to reduce memory usage.
   67|       |/// It provides a tradeoff between memory usage and CPU time. If you have a memory issue when using a normal image
   68|       |/// view to load GIF data, you could give this class a try.
   69|       |///
   70|       |/// Kingfisher supports setting GIF animated data to either `UIImageView` and `AnimatedImageView` out of box. So
   71|       |/// it would be fairly easy to switch between them.
   72|       |open class AnimatedImageView: UIImageView {
   73|       |    
   74|       |    /// Proxy object for preventing a reference cycle between the `CADDisplayLink` and `AnimatedImageView`.
   75|       |    class TargetProxy {
   76|       |        private weak var target: AnimatedImageView?
   77|       |        
   78|      0|        init(target: AnimatedImageView) {
   79|      0|            self.target = target
   80|      0|        }
   81|       |        
   82|      0|        @objc func onScreenUpdate() {
   83|      0|            target?.updateFrameIfNeeded()
   84|      0|        }
   85|       |    }
   86|       |
   87|       |    /// Enumeration that specifies repeat count of GIF
   88|       |    public enum RepeatCount: Equatable {
   89|       |        case once
   90|       |        case finite(count: UInt)
   91|       |        case infinite
   92|       |
   93|      0|        public static func ==(lhs: RepeatCount, rhs: RepeatCount) -> Bool {
   94|      0|            switch (lhs, rhs) {
   95|      0|            case let (.finite(l), .finite(r)):
   96|      0|                return l == r
   97|      0|            case (.once, .once),
   98|      0|                 (.infinite, .infinite):
   99|      0|                return true
  100|      0|            case (.once, .finite(let count)),
  101|      0|                 (.finite(let count), .once):
  102|      0|                return count == 1
  103|      0|            case (.once, _),
  104|      0|                 (.infinite, _),
  105|      0|                 (.finite, _):
  106|      0|                return false
  107|      0|            }
  108|      0|        }
  109|       |    }
  110|       |    
  111|       |    // MARK: - Public property
  112|       |    /// Whether automatically play the animation when the view become visible. Default is `true`.
  113|       |    public var autoPlayAnimatedImage = true
  114|       |    
  115|       |    /// The count of the frames should be preloaded before shown.
  116|       |    public var framePreloadCount = 10
  117|       |    
  118|       |    /// Specifies whether the GIF frames should be pre-scaled to the image view's size or not.
  119|       |    /// If the downloaded image is larger than the image view's size, it will help to reduce some memory use.
  120|       |    /// Default is `true`.
  121|       |    public var needsPrescaling = true
  122|       |
  123|       |    /// The animation timer's run loop mode. Default is `RunLoop.Mode.common`.
  124|       |    /// Set this property to `RunLoop.Mode.default` will make the animation pause during UIScrollView scrolling.
  125|       |    public var runLoopMode = KFRunLoopModeCommon {
  126|      0|        willSet {
  127|      0|            guard runLoopMode == newValue else { return }
  128|      0|            stopAnimating()
  129|      0|            displayLink.remove(from: .main, forMode: runLoopMode)
  130|      0|            displayLink.add(to: .main, forMode: newValue)
  131|      0|            startAnimating()
  132|      0|        }
  133|       |    }
  134|       |    
  135|       |    /// The repeat count. The animated image will keep animate until it the loop count reaches this value.
  136|       |    /// Setting this value to another one will reset current animation.
  137|       |    ///
  138|       |    /// Default is `.infinite`, which means the animation will last forever.
  139|       |    public var repeatCount = RepeatCount.infinite {
  140|      0|        didSet {
  141|      0|            if oldValue != repeatCount {
  142|      0|                reset()
  143|      0|                setNeedsDisplay()
  144|      0|                layer.setNeedsDisplay()
  145|      0|            }
  146|      0|        }
  147|       |    }
  148|       |
  149|       |    /// Delegate of this `AnimatedImageView` object. See `AnimatedImageViewDelegate` protocol for more.
  150|       |    public weak var delegate: AnimatedImageViewDelegate?
  151|       |    
  152|       |    // MARK: - Private property
  153|       |    /// `Animator` instance that holds the frames of a specific image in memory.
  154|       |    private var animator: Animator?
  155|       |
  156|       |    // Dispatch queue used for preloading images.
  157|      0|    private lazy var preloadQueue: DispatchQueue = {
  158|      0|        return DispatchQueue(label: "com.onevcat.Kingfisher.Animator.preloadQueue")
  159|      0|    }()
  160|       |    
  161|       |    // A flag to avoid invalidating the displayLink on deinit if it was never created, because displayLink is so lazy.
  162|       |    private var isDisplayLinkInitialized: Bool = false
  163|       |    
  164|       |    // A display link that keeps calling the `updateFrame` method on every screen refresh.
  165|      0|    private lazy var displayLink: CADisplayLink = {
  166|      0|        isDisplayLinkInitialized = true
  167|      0|        let displayLink = CADisplayLink(
  168|      0|            target: TargetProxy(target: self), selector: #selector(TargetProxy.onScreenUpdate))
  169|      0|        displayLink.add(to: .main, forMode: runLoopMode)
  170|      0|        displayLink.isPaused = true
  171|      0|        return displayLink
  172|      0|    }()
  173|       |    
  174|       |    // MARK: - Override
  175|       |    override open var image: Image? {
  176|      0|        didSet {
  177|      0|            if image != oldValue {
  178|      0|                reset()
  179|      0|            }
  180|      0|            setNeedsDisplay()
  181|      0|            layer.setNeedsDisplay()
  182|      0|        }
  183|       |    }
  184|       |    
  185|      0|    deinit {
  186|      0|        if isDisplayLinkInitialized {
  187|      0|            displayLink.invalidate()
  188|      0|        }
  189|      0|    }
  190|       |    
  191|      0|    override open var isAnimating: Bool {
  192|      0|        if isDisplayLinkInitialized {
  193|      0|            return !displayLink.isPaused
  194|      0|        } else {
  195|      0|            return super.isAnimating
  196|      0|        }
  197|      0|    }
  198|       |    
  199|       |    /// Starts the animation.
  200|      0|    override open func startAnimating() {
  201|      0|        guard !isAnimating else { return }
  202|      0|        if animator?.isReachMaxRepeatCount ?? false {
  203|      0|            return
  204|      0|        }
  205|      0|
  206|      0|        displayLink.isPaused = false
  207|      0|    }
  208|       |    
  209|       |    /// Stops the animation.
  210|      0|    override open func stopAnimating() {
  211|      0|        super.stopAnimating()
  212|      0|        if isDisplayLinkInitialized {
  213|      0|            displayLink.isPaused = true
  214|      0|        }
  215|      0|    }
  216|       |    
  217|      0|    override open func display(_ layer: CALayer) {
  218|      0|        if let currentFrame = animator?.currentFrameImage {
  219|      0|            layer.contents = currentFrame.cgImage
  220|      0|        } else {
  221|      0|            layer.contents = image?.cgImage
  222|      0|        }
  223|      0|    }
  224|       |    
  225|      0|    override open func didMoveToWindow() {
  226|      0|        super.didMoveToWindow()
  227|      0|        didMove()
  228|      0|    }
  229|       |    
  230|      0|    override open func didMoveToSuperview() {
  231|      0|        super.didMoveToSuperview()
  232|      0|        didMove()
  233|      0|    }
  234|       |
  235|       |    // This is for back compatibility that using regular `UIImageView` to show animated image.
  236|      0|    override func shouldPreloadAllAnimation() -> Bool {
  237|      0|        return false
  238|      0|    }
  239|       |
  240|       |    // Reset the animator.
  241|      0|    private func reset() {
  242|      0|        animator = nil
  243|      0|        if let imageSource = image?.kf.imageSource {
  244|      0|            let targetSize = bounds.scaled(UIScreen.main.scale).size
  245|      0|            let animator = Animator(
  246|      0|                imageSource: imageSource,
  247|      0|                contentMode: contentMode,
  248|      0|                size: targetSize,
  249|      0|                framePreloadCount: framePreloadCount,
  250|      0|                repeatCount: repeatCount,
  251|      0|                preloadQueue: preloadQueue)
  252|      0|            animator.delegate = self
  253|      0|            animator.needsPrescaling = needsPrescaling
  254|      0|            animator.prepareFramesAsynchronously()
  255|      0|            self.animator = animator
  256|      0|        }
  257|      0|        didMove()
  258|      0|    }
  259|       |    
  260|      0|    private func didMove() {
  261|      0|        if autoPlayAnimatedImage && animator != nil {
  262|      0|            if let _ = superview, let _ = window {
  263|      0|                startAnimating()
  264|      0|            } else {
  265|      0|                stopAnimating()
  266|      0|            }
  267|      0|        }
  268|      0|    }
  269|       |    
  270|       |    /// Update the current frame with the displayLink duration.
  271|      0|    private func updateFrameIfNeeded() {
  272|      0|        guard let animator = animator else {
  273|      0|            return
  274|      0|        }
  275|      0|
  276|      0|        guard !animator.isFinished else {
  277|      0|            stopAnimating()
  278|      0|            delegate?.animatedImageViewDidFinishAnimating(self)
  279|      0|            return
  280|      0|        }
  281|      0|
  282|      0|        let duration: CFTimeInterval
  283|      0|
  284|      0|        // CA based display link is opt-out from ProMotion by default.
  285|      0|        // So the duration and its FPS might not match. 
  286|      0|        // See [#718](https://github.com/onevcat/Kingfisher/issues/718)
  287|      0|        // By setting CADisableMinimumFrameDuration to YES in Info.plist may
  288|      0|        // cause the preferredFramesPerSecond being 0
  289|      0|        if displayLink.preferredFramesPerSecond == 0 {
  290|      0|            duration = displayLink.duration
  291|      0|        } else {
  292|      0|            // Some devices (like iPad Pro 10.5) will have a different FPS.
  293|      0|            duration = 1.0 / Double(displayLink.preferredFramesPerSecond)
  294|      0|        }
  295|      0|
  296|      0|        animator.shouldChangeFrame(with: duration) { [weak self] hasNewFrame in
  297|      0|            if hasNewFrame {
  298|      0|                self?.layer.setNeedsDisplay()
  299|      0|            }
  300|      0|        }
  301|      0|    }
  302|       |}
  303|       |
  304|       |protocol AnimatorDelegate: AnyObject {
  305|       |    func animator(_ animator: AnimatedImageView.Animator, didPlayAnimationLoops count: UInt)
  306|       |}
  307|       |
  308|       |extension AnimatedImageView: AnimatorDelegate {
  309|      0|    func animator(_ animator: Animator, didPlayAnimationLoops count: UInt) {
  310|      0|        delegate?.animatedImageView(self, didPlayAnimationLoops: count)
  311|      0|    }
  312|       |}
  313|       |
  314|       |extension AnimatedImageView {
  315|       |
  316|       |    // Represents a single frame in a GIF.
  317|       |    struct AnimatedFrame {
  318|       |
  319|       |        // The image to display for this frame. Its value is nil when the frame is removed from the buffer.
  320|       |        let image: UIImage?
  321|       |
  322|       |        // The duration that this frame should remain active.
  323|       |        let duration: TimeInterval
  324|       |
  325|       |        // A placeholder frame with no image assigned.
  326|       |        // Used to replace frames that are no longer needed in the animation.
  327|      0|        var placeholderFrame: AnimatedFrame {
  328|      0|            return AnimatedFrame(image: nil, duration: duration)
  329|      0|        }
  330|       |
  331|       |        // Whether this frame instance contains an image or not.
  332|      0|        var isPlaceholder: Bool {
  333|      0|            return image == nil
  334|      0|        }
  335|       |
  336|       |        // Returns a new instance from an optional image.
  337|       |        //
  338|       |        // - parameter image: An optional `UIImage` instance to be assigned to the new frame.
  339|       |        // - returns: An `AnimatedFrame` instance.
  340|      0|        func makeAnimatedFrame(image: UIImage?) -> AnimatedFrame {
  341|      0|            return AnimatedFrame(image: image, duration: duration)
  342|      0|        }
  343|       |    }
  344|       |}
  345|       |
  346|       |extension AnimatedImageView {
  347|       |
  348|       |    // MARK: - Animator
  349|       |    class Animator {
  350|       |        private let size: CGSize
  351|       |        private let maxFrameCount: Int
  352|       |        private let imageSource: CGImageSource
  353|       |        private let maxRepeatCount: RepeatCount
  354|       |
  355|       |        private let maxTimeStep: TimeInterval = 1.0
  356|       |        private var animatedFrames = [AnimatedFrame]()
  357|       |        private var frameCount = 0
  358|       |        private var timeSinceLastFrameChange: TimeInterval = 0.0
  359|       |        private var currentRepeatCount: UInt = 0
  360|       |
  361|       |        var isFinished: Bool = false
  362|       |
  363|       |        var needsPrescaling = true
  364|       |        weak var delegate: AnimatorDelegate?
  365|       |
  366|       |        // Total duration of one animation loop
  367|       |        var loopDuration: TimeInterval = 0
  368|       |
  369|       |        // Current active frame image
  370|      0|        var currentFrameImage: UIImage? {
  371|      0|            return frame(at: currentFrameIndex)
  372|      0|        }
  373|       |
  374|       |        // Current active frame duration
  375|      0|        var currentFrameDuration: TimeInterval {
  376|      0|            return duration(at: currentFrameIndex)
  377|      0|        }
  378|       |
  379|       |        // The index of the current GIF frame.
  380|       |        var currentFrameIndex = 0 {
  381|      0|            didSet {
  382|      0|                previousFrameIndex = oldValue
  383|      0|            }
  384|       |        }
  385|       |
  386|       |        var previousFrameIndex = 0 {
  387|      0|            didSet {
  388|      0|                preloadQueue.async {
  389|      0|                    self.updatePreloadedFrames()
  390|      0|                }
  391|      0|            }
  392|       |        }
  393|       |
  394|      0|        var isReachMaxRepeatCount: Bool {
  395|      0|            switch maxRepeatCount {
  396|      0|            case .once:
  397|      0|                return currentRepeatCount >= 1
  398|      0|            case .finite(let maxCount):
  399|      0|                return currentRepeatCount >= maxCount
  400|      0|            case .infinite:
  401|      0|                return false
  402|      0|            }
  403|      0|        }
  404|       |
  405|      0|        var isLastFrame: Bool {
  406|      0|            return currentFrameIndex == frameCount - 1
  407|      0|        }
  408|       |
  409|      0|        var preloadingIsNeeded: Bool {
  410|      0|            return maxFrameCount < frameCount - 1
  411|      0|        }
  412|       |
  413|       |        var contentMode = UIView.ContentMode.scaleToFill
  414|       |
  415|      0|        private lazy var preloadQueue: DispatchQueue = {
  416|      0|            return DispatchQueue(label: "com.onevcat.Kingfisher.Animator.preloadQueue")
  417|      0|        }()
  418|       |
  419|       |        /// Creates an animator with image source reference.
  420|       |        ///
  421|       |        /// - Parameters:
  422|       |        ///   - source: The reference of animated image.
  423|       |        ///   - mode: Content mode of the `AnimatedImageView`.
  424|       |        ///   - size: Size of the `AnimatedImageView`.
  425|       |        ///   - count: Count of frames needed to be preloaded.
  426|       |        ///   - repeatCount: The repeat count should this animator uses.
  427|       |        init(imageSource source: CGImageSource,
  428|       |             contentMode mode: UIView.ContentMode,
  429|       |             size: CGSize,
  430|       |             framePreloadCount count: Int,
  431|       |             repeatCount: RepeatCount,
  432|      0|             preloadQueue: DispatchQueue) {
  433|      0|            self.imageSource = source
  434|      0|            self.contentMode = mode
  435|      0|            self.size = size
  436|      0|            self.maxFrameCount = count
  437|      0|            self.maxRepeatCount = repeatCount
  438|      0|            self.preloadQueue = preloadQueue
  439|      0|        }
  440|       |
  441|      0|        func frame(at index: Int) -> Image? {
  442|      0|            return animatedFrames[safe: index]?.image
  443|      0|        }
  444|       |
  445|      0|        func duration(at index: Int) -> TimeInterval {
  446|      0|            return animatedFrames[safe: index]?.duration  ?? .infinity
  447|      0|        }
  448|       |
  449|      0|        func prepareFramesAsynchronously() {
  450|      0|            frameCount = Int(CGImageSourceGetCount(imageSource))
  451|      0|            animatedFrames.reserveCapacity(frameCount)
  452|      0|            preloadQueue.async { [weak self] in
  453|      0|                self?.setupAnimatedFrames()
  454|      0|            }
  455|      0|        }
  456|       |
  457|      0|        func shouldChangeFrame(with duration: CFTimeInterval, handler: (Bool) -> Void) {
  458|      0|            incrementTimeSinceLastFrameChange(with: duration)
  459|      0|
  460|      0|            if currentFrameDuration > timeSinceLastFrameChange {
  461|      0|                handler(false)
  462|      0|            } else {
  463|      0|                resetTimeSinceLastFrameChange()
  464|      0|                incrementCurrentFrameIndex()
  465|      0|                handler(true)
  466|      0|            }
  467|      0|        }
  468|       |
  469|      0|        private func setupAnimatedFrames() {
  470|      0|            resetAnimatedFrames()
  471|      0|
  472|      0|            var duration: TimeInterval = 0
  473|      0|
  474|      0|            (0..<frameCount).forEach { index in
  475|      0|                let frameDuration = GIFAnimatedImage.getFrameDuration(from: imageSource, at: index)
  476|      0|                duration += min(frameDuration, maxTimeStep)
  477|      0|                animatedFrames += [AnimatedFrame(image: nil, duration: frameDuration)]
  478|      0|
  479|      0|                if index > maxFrameCount { return }
  480|      0|                animatedFrames[index] = animatedFrames[index].makeAnimatedFrame(image: loadFrame(at: index))
  481|      0|            }
  482|      0|
  483|      0|            self.loopDuration = duration
  484|      0|        }
  485|       |
  486|      0|        private func resetAnimatedFrames() {
  487|      0|            animatedFrames = []
  488|      0|        }
  489|       |
  490|      0|        private func loadFrame(at index: Int) -> UIImage? {
  491|      0|            guard let image = CGImageSourceCreateImageAtIndex(imageSource, index, nil) else {
  492|      0|                return nil
  493|      0|            }
  494|      0|
  495|      0|            let scaledImage: CGImage
  496|      0|            if needsPrescaling, size != .zero {
  497|      0|                scaledImage = image.kf.resize(to: size, for: contentMode)
  498|      0|            } else {
  499|      0|                scaledImage = image
  500|      0|            }
  501|      0|
  502|      0|            return Image(cgImage: scaledImage)
  503|      0|        }
  504|       |        
  505|      0|        private func updatePreloadedFrames() {
  506|      0|            guard preloadingIsNeeded else {
  507|      0|                return
  508|      0|            }
  509|      0|
  510|      0|            animatedFrames[previousFrameIndex] = animatedFrames[previousFrameIndex].placeholderFrame
  511|      0|
  512|      0|            preloadIndexes(start: currentFrameIndex).forEach { index in
  513|      0|                let currentAnimatedFrame = animatedFrames[index]
  514|      0|                if !currentAnimatedFrame.isPlaceholder { return }
  515|      0|                animatedFrames[index] = currentAnimatedFrame.makeAnimatedFrame(image: loadFrame(at: index))
  516|      0|            }
  517|      0|        }
  518|       |
  519|      0|        private func incrementCurrentFrameIndex() {
  520|      0|            currentFrameIndex = increment(frameIndex: currentFrameIndex)
  521|      0|            if isReachMaxRepeatCount && isLastFrame {
  522|      0|                isFinished = true
  523|      0|            } else if currentFrameIndex == 0 {
  524|      0|                currentRepeatCount += 1
  525|      0|                delegate?.animator(self, didPlayAnimationLoops: currentRepeatCount)
  526|      0|            }
  527|      0|        }
  528|       |
  529|      0|        private func incrementTimeSinceLastFrameChange(with duration: TimeInterval) {
  530|      0|            timeSinceLastFrameChange += min(maxTimeStep, duration)
  531|      0|        }
  532|       |
  533|      0|        private func resetTimeSinceLastFrameChange() {
  534|      0|            timeSinceLastFrameChange -= currentFrameDuration
  535|      0|        }
  536|       |
  537|      0|        private func increment(frameIndex: Int, by value: Int = 1) -> Int {
  538|      0|            return (frameIndex + value) % frameCount
  539|      0|        }
  540|       |
  541|      0|        private func preloadIndexes(start index: Int) -> [Int] {
  542|      0|            let nextIndex = increment(frameIndex: index)
  543|      0|            let lastIndex = increment(frameIndex: index, by: maxFrameCount)
  544|      0|
  545|      0|            if lastIndex >= nextIndex {
  546|      0|                return [Int](nextIndex...lastIndex)
  547|      0|            } else {
  548|      0|                return [Int](nextIndex..<frameCount) + [Int](0...lastIndex)
  549|      0|            }
  550|      0|        }
  551|       |    }
  552|       |}
  553|       |
  554|       |extension Array {
  555|      0|    subscript(safe index: Int) -> Element? {
  556|      0|        return indices ~= index ? self[index] : nil
  557|      0|    }
  558|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/Kingfisher/Sources/Views/Indicator.swift:
    1|       |//
    2|       |//  Indicator.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by João D. Moreira on 30/08/16.
    6|       |//
    7|       |//  Copyright (c) 2019 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if canImport(AppKit)
   28|       |import AppKit
   29|       |public typealias IndicatorView = NSView
   30|       |#else
   31|       |import UIKit
   32|       |public typealias IndicatorView = UIView
   33|       |#endif
   34|       |
   35|       |/// Represents the activity indicator type which should be added to
   36|       |/// an image view when an image is being downloaded.
   37|       |///
   38|       |/// - none: No indicator.
   39|       |/// - activity: Uses the system activity indicator.
   40|       |/// - image: Uses an image as indicator. GIF is supported.
   41|       |/// - custom: Uses a custom indicator. The type of associated value should conform to the `Indicator` protocol.
   42|       |public enum IndicatorType {
   43|       |    /// No indicator.
   44|       |    case none
   45|       |    /// Uses the system activity indicator.
   46|       |    case activity
   47|       |    /// Uses an image as indicator. GIF is supported.
   48|       |    case image(imageData: Data)
   49|       |    /// Uses a custom indicator. The type of associated value should conform to the `Indicator` protocol.
   50|       |    case custom(indicator: Indicator)
   51|       |}
   52|       |
   53|       |/// An indicator type which can be used to show the download task is in progress.
   54|       |public protocol Indicator {
   55|       |    
   56|       |    /// Called when the indicator should start animating.
   57|       |    func startAnimatingView()
   58|       |    
   59|       |    /// Called when the indicator should stop animating.
   60|       |    func stopAnimatingView()
   61|       |
   62|       |    /// Center offset of the indicator. Kingfisher will use this value to determine the position of
   63|       |    /// indicator in the super view.
   64|       |    var centerOffset: CGPoint { get }
   65|       |    
   66|       |    /// The indicator view which would be added to the super view.
   67|       |    var view: IndicatorView { get }
   68|       |}
   69|       |
   70|       |extension Indicator {
   71|       |    
   72|       |    /// Default implementation of `centerOffset` of `Indicator`. The default value is `.zero`, means that there is
   73|       |    /// no offset for the indicator view.
   74|      0|    public var centerOffset: CGPoint { return .zero }
   75|       |}
   76|       |
   77|       |// Displays a NSProgressIndicator / UIActivityIndicatorView
   78|       |final class ActivityIndicator: Indicator {
   79|       |
   80|       |    #if os(macOS)
   81|       |    private let activityIndicatorView: NSProgressIndicator
   82|       |    #else
   83|       |    private let activityIndicatorView: UIActivityIndicatorView
   84|       |    #endif
   85|       |    private var animatingCount = 0
   86|       |
   87|      0|    var view: IndicatorView {
   88|      0|        return activityIndicatorView
   89|      0|    }
   90|       |
   91|      0|    func startAnimatingView() {
   92|      0|        if animatingCount == 0 {
   93|      0|            #if os(macOS)
   94|      0|            activityIndicatorView.startAnimation(nil)
   95|      0|            #else
   96|      0|            activityIndicatorView.startAnimating()
   97|      0|            #endif
   98|      0|            activityIndicatorView.isHidden = false
   99|      0|        }
  100|      0|        animatingCount += 1
  101|      0|    }
  102|       |
  103|      0|    func stopAnimatingView() {
  104|      0|        animatingCount = max(animatingCount - 1, 0)
  105|      0|        if animatingCount == 0 {
  106|      0|            #if os(macOS)
  107|      0|                activityIndicatorView.stopAnimation(nil)
  108|      0|            #else
  109|      0|                activityIndicatorView.stopAnimating()
  110|      0|            #endif
  111|      0|            activityIndicatorView.isHidden = true
  112|      0|        }
  113|      0|    }
  114|       |
  115|      0|    init() {
  116|      0|        #if os(macOS)
  117|      0|            activityIndicatorView = NSProgressIndicator(frame: CGRect(x: 0, y: 0, width: 16, height: 16))
  118|      0|            activityIndicatorView.controlSize = .small
  119|      0|            activityIndicatorView.style = .spinning
  120|      0|        #else
  121|      0|            #if os(tvOS)
  122|      0|                let indicatorStyle = UIActivityIndicatorView.Style.white
  123|      0|            #else
  124|      0|                let indicatorStyle = UIActivityIndicatorView.Style.gray
  125|      0|            #endif
  126|      0|            #if swift(>=4.2)
  127|      0|            activityIndicatorView = UIActivityIndicatorView(style: indicatorStyle)
  128|      0|            #else
  129|      0|            activityIndicatorView = UIActivityIndicatorView(activityIndicatorStyle: indicatorStyle)
  130|      0|            #endif
  131|      0|        #endif
  132|      0|    }
  133|       |}
  134|       |
  135|       |// MARK: - ImageIndicator
  136|       |// Displays an ImageView. Supports gif
  137|       |final class ImageIndicator: Indicator {
  138|       |    private let animatedImageIndicatorView: ImageView
  139|       |
  140|      0|    var view: IndicatorView {
  141|      0|        return animatedImageIndicatorView
  142|      0|    }
  143|       |
  144|       |    init?(
  145|       |        imageData data: Data,
  146|       |        processor: ImageProcessor = DefaultImageProcessor.default,
  147|       |        options: KingfisherParsedOptionsInfo? = nil)
  148|      0|    {
  149|      0|        var options = options ?? KingfisherParsedOptionsInfo(nil)
  150|      0|        // Use normal image view to show animations, so we need to preload all animation data.
  151|      0|        if !options.preloadAllAnimationData {
  152|      0|            options.preloadAllAnimationData = true
  153|      0|        }
  154|      0|        
  155|      0|        guard let image = processor.process(item: .data(data), options: options) else {
  156|      0|            return nil
  157|      0|        }
  158|      0|
  159|      0|        animatedImageIndicatorView = ImageView()
  160|      0|        animatedImageIndicatorView.image = image
  161|      0|        
  162|      0|        #if os(macOS)
  163|      0|            // Need for gif to animate on macOS
  164|      0|            animatedImageIndicatorView.imageScaling = .scaleNone
  165|      0|            animatedImageIndicatorView.canDrawSubviewsIntoLayer = true
  166|      0|        #else
  167|      0|            animatedImageIndicatorView.contentMode = .center
  168|      0|        #endif
  169|      0|    }
  170|       |
  171|      0|    func startAnimatingView() {
  172|      0|        #if os(macOS)
  173|      0|            animatedImageIndicatorView.animates = true
  174|      0|        #else
  175|      0|            animatedImageIndicatorView.startAnimating()
  176|      0|        #endif
  177|      0|        animatedImageIndicatorView.isHidden = false
  178|      0|    }
  179|       |
  180|      0|    func stopAnimatingView() {
  181|      0|        #if os(macOS)
  182|      0|            animatedImageIndicatorView.animates = false
  183|      0|        #else
  184|      0|            animatedImageIndicatorView.stopAnimating()
  185|      0|        #endif
  186|      0|        animatedImageIndicatorView.isHidden = true
  187|      0|    }
  188|       |}

