/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpc/grpc_security.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_GRPC_SECURITY_H
   20|       |#define GRPC_GRPC_SECURITY_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/grpc.h>
   25|       |#include <grpc/grpc_security_constants.h>
   26|       |#include <grpc/status.h>
   27|       |
   28|       |#ifdef __cplusplus
   29|       |extern "C" {
   30|       |#endif
   31|       |
   32|       |/** --- Authentication Context. --- */
   33|       |
   34|       |typedef struct grpc_auth_context grpc_auth_context;
   35|       |
   36|       |typedef struct grpc_auth_property_iterator {
   37|       |  const grpc_auth_context* ctx;
   38|       |  size_t index;
   39|       |  const char* name;
   40|       |} grpc_auth_property_iterator;
   41|       |
   42|       |/** value, if not NULL, is guaranteed to be NULL terminated. */
   43|       |typedef struct grpc_auth_property {
   44|       |  char* name;
   45|       |  char* value;
   46|       |  size_t value_length;
   47|       |} grpc_auth_property;
   48|       |
   49|       |/** Returns NULL when the iterator is at the end. */
   50|       |GRPCAPI const grpc_auth_property* grpc_auth_property_iterator_next(
   51|       |    grpc_auth_property_iterator* it);
   52|       |
   53|       |/** Iterates over the auth context. */
   54|       |GRPCAPI grpc_auth_property_iterator
   55|       |grpc_auth_context_property_iterator(const grpc_auth_context* ctx);
   56|       |
   57|       |/** Gets the peer identity. Returns an empty iterator (first _next will return
   58|       |   NULL) if the peer is not authenticated. */
   59|       |GRPCAPI grpc_auth_property_iterator
   60|       |grpc_auth_context_peer_identity(const grpc_auth_context* ctx);
   61|       |
   62|       |/** Finds a property in the context. May return an empty iterator (first _next
   63|       |   will return NULL) if no property with this name was found in the context. */
   64|       |GRPCAPI grpc_auth_property_iterator grpc_auth_context_find_properties_by_name(
   65|       |    const grpc_auth_context* ctx, const char* name);
   66|       |
   67|       |/** Gets the name of the property that indicates the peer identity. Will return
   68|       |   NULL if the peer is not authenticated. */
   69|       |GRPCAPI const char* grpc_auth_context_peer_identity_property_name(
   70|       |    const grpc_auth_context* ctx);
   71|       |
   72|       |/** Returns 1 if the peer is authenticated, 0 otherwise. */
   73|       |GRPCAPI int grpc_auth_context_peer_is_authenticated(
   74|       |    const grpc_auth_context* ctx);
   75|       |
   76|       |/** Gets the auth context from the call. Caller needs to call
   77|       |   grpc_auth_context_release on the returned context. */
   78|       |GRPCAPI grpc_auth_context* grpc_call_auth_context(grpc_call* call);
   79|       |
   80|       |/** Releases the auth context returned from grpc_call_auth_context. */
   81|       |GRPCAPI void grpc_auth_context_release(grpc_auth_context* context);
   82|       |
   83|       |/** --
   84|       |   The following auth context methods should only be called by a server metadata
   85|       |   processor to set properties extracted from auth metadata.
   86|       |   -- */
   87|       |
   88|       |/** Add a property. */
   89|       |GRPCAPI void grpc_auth_context_add_property(grpc_auth_context* ctx,
   90|       |                                            const char* name, const char* value,
   91|       |                                            size_t value_length);
   92|       |
   93|       |/** Add a C string property. */
   94|       |GRPCAPI void grpc_auth_context_add_cstring_property(grpc_auth_context* ctx,
   95|       |                                                    const char* name,
   96|       |                                                    const char* value);
   97|       |
   98|       |/** Sets the property name. Returns 1 if successful or 0 in case of failure
   99|       |   (which means that no property with this name exists). */
  100|       |GRPCAPI int grpc_auth_context_set_peer_identity_property_name(
  101|       |    grpc_auth_context* ctx, const char* name);
  102|       |
  103|       |/** --- SSL Session Cache. ---
  104|       |
  105|       |    A SSL session cache object represents a way to cache client sessions
  106|       |    between connections. Only ticket-based resumption is supported. */
  107|       |
  108|       |typedef struct grpc_ssl_session_cache grpc_ssl_session_cache;
  109|       |
  110|       |/** Create LRU cache for client-side SSL sessions with the given capacity.
  111|       |    If capacity is < 1, a default capacity is used instead. */
  112|       |GRPCAPI grpc_ssl_session_cache* grpc_ssl_session_cache_create_lru(
  113|       |    size_t capacity);
  114|       |
  115|       |/** Destroy SSL session cache. */
  116|       |GRPCAPI void grpc_ssl_session_cache_destroy(grpc_ssl_session_cache* cache);
  117|       |
  118|       |/** Create a channel arg with the given cache object. */
  119|       |GRPCAPI grpc_arg
  120|       |grpc_ssl_session_cache_create_channel_arg(grpc_ssl_session_cache* cache);
  121|       |
  122|       |/** --- grpc_channel_credentials object. ---
  123|       |
  124|       |   A channel credentials object represents a way to authenticate a client on a
  125|       |   channel.  */
  126|       |
  127|       |typedef struct grpc_channel_credentials grpc_channel_credentials;
  128|       |
  129|       |/** Releases a channel credentials object.
  130|       |   The creator of the credentials object is responsible for its release. */
  131|       |GRPCAPI void grpc_channel_credentials_release(grpc_channel_credentials* creds);
  132|       |
  133|       |/** Creates default credentials to connect to a google gRPC service.
  134|       |   WARNING: Do NOT use this credentials to connect to a non-google service as
  135|       |   this could result in an oauth2 token leak. */
  136|       |GRPCAPI grpc_channel_credentials* grpc_google_default_credentials_create(void);
  137|       |
  138|       |/** Callback for getting the SSL roots override from the application.
  139|       |   In case of success, *pem_roots_certs must be set to a NULL terminated string
  140|       |   containing the list of PEM encoded root certificates. The ownership is passed
  141|       |   to the core and freed (laster by the core) with gpr_free.
  142|       |   If this function fails and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment is
  143|       |   set to a valid path, it will override the roots specified this func */
  144|       |typedef grpc_ssl_roots_override_result (*grpc_ssl_roots_override_callback)(
  145|       |    char** pem_root_certs);
  146|       |
  147|       |/** Setup a callback to override the default TLS/SSL roots.
  148|       |   This function is not thread-safe and must be called at initialization time
  149|       |   before any ssl credentials are created to have the desired side effect.
  150|       |   If GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment is set to a valid path, the
  151|       |   callback will not be called. */
  152|       |GRPCAPI void grpc_set_ssl_roots_override_callback(
  153|       |    grpc_ssl_roots_override_callback cb);
  154|       |
  155|       |/** Object that holds a private key / certificate chain pair in PEM format. */
  156|       |typedef struct {
  157|       |  /** private_key is the NULL-terminated string containing the PEM encoding of
  158|       |     the client's private key. */
  159|       |  const char* private_key;
  160|       |
  161|       |  /** cert_chain is the NULL-terminated string containing the PEM encoding of
  162|       |     the client's certificate chain. */
  163|       |  const char* cert_chain;
  164|       |} grpc_ssl_pem_key_cert_pair;
  165|       |
  166|       |/** Object that holds additional peer-verification options on a secure
  167|       |   channel. */
  168|       |typedef struct {
  169|       |  /** If non-NULL this callback will be invoked with the expected
  170|       |     target_name, the peer's certificate (in PEM format), and whatever
  171|       |     userdata pointer is set below. If a non-zero value is returned by this
  172|       |     callback then it is treated as a verification failure. Invocation of
  173|       |     the callback is blocking, so any implementation should be light-weight.
  174|       |     */
  175|       |  int (*verify_peer_callback)(const char* target_name, const char* peer_pem,
  176|       |                              void* userdata);
  177|       |  /** Arbitrary userdata that will be passed as the last argument to
  178|       |     verify_peer_callback. */
  179|       |  void* verify_peer_callback_userdata;
  180|       |  /** A destruct callback that will be invoked when the channel is being
  181|       |     cleaned up. The userdata argument will be passed to it. The intent is
  182|       |     to perform any cleanup associated with that userdata. */
  183|       |  void (*verify_peer_destruct)(void* userdata);
  184|       |} verify_peer_options;
  185|       |
  186|       |/** Creates an SSL credentials object.
  187|       |   - pem_root_certs is the NULL-terminated string containing the PEM encoding
  188|       |     of the server root certificates. If this parameter is NULL, the
  189|       |     implementation will first try to dereference the file pointed by the
  190|       |     GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment variable, and if that fails,
  191|       |     try to get the roots set by grpc_override_ssl_default_roots. Eventually,
  192|       |     if all these fail, it will try to get the roots from a well-known place on
  193|       |     disk (in the grpc install directory).
  194|       |
  195|       |     gRPC has implemented root cache if the underlying OpenSSL library supports
  196|       |     it. The gRPC root certificates cache is only applicable on the default
  197|       |     root certificates, which is used when this parameter is nullptr. If user
  198|       |     provides their own pem_root_certs, when creating an SSL credential object,
  199|       |     gRPC would not be able to cache it, and each subchannel will generate a
  200|       |     copy of the root store. So it is recommended to avoid providing large room
  201|       |     pem with pem_root_certs parameter to avoid excessive memory consumption,
  202|       |     particularly on mobile platforms such as iOS.
  203|       |   - pem_key_cert_pair is a pointer on the object containing client's private
  204|       |     key and certificate chain. This parameter can be NULL if the client does
  205|       |     not have such a key/cert pair.
  206|       |   - verify_options is an optional verify_peer_options object which holds
  207|       |     additional options controlling how peer certificates are verified. For
  208|       |     example, you can supply a callback which receives the peer's certificate
  209|       |     with which you can do additional verification. Can be NULL, in which
  210|       |     case verification will retain default behavior. Any settings in
  211|       |     verify_options are copied during this call, so the verify_options
  212|       |     object can be released afterwards. */
  213|       |GRPCAPI grpc_channel_credentials* grpc_ssl_credentials_create(
  214|       |    const char* pem_root_certs, grpc_ssl_pem_key_cert_pair* pem_key_cert_pair,
  215|       |    const verify_peer_options* verify_options, void* reserved);
  216|       |
  217|       |/** --- grpc_call_credentials object.
  218|       |
  219|       |   A call credentials object represents a way to authenticate on a particular
  220|       |   call. These credentials can be composed with a channel credentials object
  221|       |   so that they are sent with every call on this channel.  */
  222|       |
  223|       |typedef struct grpc_call_credentials grpc_call_credentials;
  224|       |
  225|       |/** Releases a call credentials object.
  226|       |   The creator of the credentials object is responsible for its release. */
  227|       |GRPCAPI void grpc_call_credentials_release(grpc_call_credentials* creds);
  228|       |
  229|       |/** Creates a composite channel credentials object. */
  230|       |GRPCAPI grpc_channel_credentials* grpc_composite_channel_credentials_create(
  231|       |    grpc_channel_credentials* channel_creds, grpc_call_credentials* call_creds,
  232|       |    void* reserved);
  233|       |
  234|       |/** Creates a composite call credentials object. */
  235|       |GRPCAPI grpc_call_credentials* grpc_composite_call_credentials_create(
  236|       |    grpc_call_credentials* creds1, grpc_call_credentials* creds2,
  237|       |    void* reserved);
  238|       |
  239|       |/** Creates a compute engine credentials object for connecting to Google.
  240|       |   WARNING: Do NOT use this credentials to connect to a non-google service as
  241|       |   this could result in an oauth2 token leak. */
  242|       |GRPCAPI grpc_call_credentials* grpc_google_compute_engine_credentials_create(
  243|       |    void* reserved);
  244|       |
  245|       |GRPCAPI gpr_timespec grpc_max_auth_token_lifetime(void);
  246|       |
  247|       |/** Creates a JWT credentials object. May return NULL if the input is invalid.
  248|       |   - json_key is the JSON key string containing the client's private key.
  249|       |   - token_lifetime is the lifetime of each Json Web Token (JWT) created with
  250|       |     this credentials.  It should not exceed grpc_max_auth_token_lifetime or
  251|       |     will be cropped to this value.  */
  252|       |GRPCAPI grpc_call_credentials*
  253|       |grpc_service_account_jwt_access_credentials_create(const char* json_key,
  254|       |                                                   gpr_timespec token_lifetime,
  255|       |                                                   void* reserved);
  256|       |
  257|       |/** Creates an Oauth2 Refresh Token credentials object for connecting to Google.
  258|       |   May return NULL if the input is invalid.
  259|       |   WARNING: Do NOT use this credentials to connect to a non-google service as
  260|       |   this could result in an oauth2 token leak.
  261|       |   - json_refresh_token is the JSON string containing the refresh token itself
  262|       |     along with a client_id and client_secret. */
  263|       |GRPCAPI grpc_call_credentials* grpc_google_refresh_token_credentials_create(
  264|       |    const char* json_refresh_token, void* reserved);
  265|       |
  266|       |/** Creates an Oauth2 Access Token credentials with an access token that was
  267|       |   acquired by an out of band mechanism. */
  268|       |GRPCAPI grpc_call_credentials* grpc_access_token_credentials_create(
  269|       |    const char* access_token, void* reserved);
  270|       |
  271|       |/** Creates an IAM credentials object for connecting to Google. */
  272|       |GRPCAPI grpc_call_credentials* grpc_google_iam_credentials_create(
  273|       |    const char* authorization_token, const char* authority_selector,
  274|       |    void* reserved);
  275|       |
  276|       |/** Callback function to be called by the metadata credentials plugin
  277|       |   implementation when the metadata is ready.
  278|       |   - user_data is the opaque pointer that was passed in the get_metadata method
  279|       |     of the grpc_metadata_credentials_plugin (see below).
  280|       |   - creds_md is an array of credentials metadata produced by the plugin. It
  281|       |     may be set to NULL in case of an error.
  282|       |   - num_creds_md is the number of items in the creds_md array.
  283|       |   - status must be GRPC_STATUS_OK in case of success or another specific error
  284|       |     code otherwise.
  285|       |   - error_details contains details about the error if any. In case of success
  286|       |     it should be NULL and will be otherwise ignored. */
  287|       |typedef void (*grpc_credentials_plugin_metadata_cb)(
  288|       |    void* user_data, const grpc_metadata* creds_md, size_t num_creds_md,
  289|       |    grpc_status_code status, const char* error_details);
  290|       |
  291|       |/** Context that can be used by metadata credentials plugin in order to create
  292|       |   auth related metadata. */
  293|       |typedef struct {
  294|       |  /** The fully qualifed service url. */
  295|       |  const char* service_url;
  296|       |
  297|       |  /** The method name of the RPC being called (not fully qualified).
  298|       |     The fully qualified method name can be built from the service_url:
  299|       |     full_qualified_method_name = ctx->service_url + '/' + ctx->method_name. */
  300|       |  const char* method_name;
  301|       |
  302|       |  /** The auth_context of the channel which gives the server's identity. */
  303|       |  const grpc_auth_context* channel_auth_context;
  304|       |
  305|       |  /** Reserved for future use. */
  306|       |  void* reserved;
  307|       |} grpc_auth_metadata_context;
  308|       |
  309|       |/** Maximum number of metadata entries returnable by a credentials plugin via
  310|       |    a synchronous return. */
  311|      0|#define GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX 4
  312|       |
  313|       |/** grpc_metadata_credentials plugin is an API user provided structure used to
  314|       |   create grpc_credentials objects that can be set on a channel (composed) or
  315|       |   a call. See grpc_credentials_metadata_create_from_plugin below.
  316|       |   The grpc client stack will call the get_metadata method of the plugin for
  317|       |   every call in scope for the credentials created from it. */
  318|       |typedef struct {
  319|       |  /** The implementation of this method has to be non-blocking, but can
  320|       |     be performed synchronously or asynchronously.
  321|       |
  322|       |     If processing occurs synchronously, returns non-zero and populates
  323|       |     creds_md, num_creds_md, status, and error_details.  In this case,
  324|       |     the caller takes ownership of the entries in creds_md and of
  325|       |     error_details.  Note that if the plugin needs to return more than
  326|       |     GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX entries in creds_md, it must
  327|       |     return asynchronously.
  328|       |
  329|       |     If processing occurs asynchronously, returns zero and invokes \a cb
  330|       |     when processing is completed.  \a user_data will be passed as the
  331|       |     first parameter of the callback.  NOTE: \a cb MUST be invoked in a
  332|       |     different thread, not from the thread in which \a get_metadata() is
  333|       |     invoked.
  334|       |
  335|       |     \a context is the information that can be used by the plugin to create
  336|       |     auth metadata. */
  337|       |  int (*get_metadata)(
  338|       |      void* state, grpc_auth_metadata_context context,
  339|       |      grpc_credentials_plugin_metadata_cb cb, void* user_data,
  340|       |      grpc_metadata creds_md[GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX],
  341|       |      size_t* num_creds_md, grpc_status_code* status,
  342|       |      const char** error_details);
  343|       |
  344|       |  /** Destroys the plugin state. */
  345|       |  void (*destroy)(void* state);
  346|       |
  347|       |  /** State that will be set as the first parameter of the methods above. */
  348|       |  void* state;
  349|       |
  350|       |  /** Type of credentials that this plugin is implementing. */
  351|       |  const char* type;
  352|       |} grpc_metadata_credentials_plugin;
  353|       |
  354|       |/** Creates a credentials object from a plugin. */
  355|       |GRPCAPI grpc_call_credentials* grpc_metadata_credentials_create_from_plugin(
  356|       |    grpc_metadata_credentials_plugin plugin, void* reserved);
  357|       |
  358|       |/** --- Secure channel creation. --- */
  359|       |
  360|       |/** Creates a secure channel using the passed-in credentials. Additional
  361|       |    channel level configuration MAY be provided by grpc_channel_args, though
  362|       |    the expectation is that most clients will want to simply pass NULL. The
  363|       |    user data in 'args' need only live through the invocation of this function.
  364|       |    However, if any args of the 'pointer' type are passed, then the referenced
  365|       |    vtable must be maintained by the caller until grpc_channel_destroy
  366|       |    terminates. See grpc_channel_args definition for more on this. */
  367|       |GRPCAPI grpc_channel* grpc_secure_channel_create(
  368|       |    grpc_channel_credentials* creds, const char* target,
  369|       |    const grpc_channel_args* args, void* reserved);
  370|       |
  371|       |/** --- grpc_server_credentials object. ---
  372|       |
  373|       |   A server credentials object represents a way to authenticate a server.  */
  374|       |
  375|       |typedef struct grpc_server_credentials grpc_server_credentials;
  376|       |
  377|       |/** Releases a server_credentials object.
  378|       |   The creator of the server_credentials object is responsible for its release.
  379|       |   */
  380|       |GRPCAPI void grpc_server_credentials_release(grpc_server_credentials* creds);
  381|       |
  382|       |/** Server certificate config object holds the server's public certificates and
  383|       |   associated private keys, as well as any CA certificates needed for client
  384|       |   certificate validation (if applicable). Create using
  385|       |   grpc_ssl_server_certificate_config_create(). */
  386|       |typedef struct grpc_ssl_server_certificate_config
  387|       |    grpc_ssl_server_certificate_config;
  388|       |
  389|       |/** Creates a grpc_ssl_server_certificate_config object.
  390|       |   - pem_roots_cert is the NULL-terminated string containing the PEM encoding of
  391|       |     the client root certificates. This parameter may be NULL if the server does
  392|       |     not want the client to be authenticated with SSL.
  393|       |   - pem_key_cert_pairs is an array private key / certificate chains of the
  394|       |     server. This parameter cannot be NULL.
  395|       |   - num_key_cert_pairs indicates the number of items in the private_key_files
  396|       |     and cert_chain_files parameters. It must be at least 1.
  397|       |   - It is the caller's responsibility to free this object via
  398|       |     grpc_ssl_server_certificate_config_destroy(). */
  399|       |GRPCAPI grpc_ssl_server_certificate_config*
  400|       |grpc_ssl_server_certificate_config_create(
  401|       |    const char* pem_root_certs,
  402|       |    const grpc_ssl_pem_key_cert_pair* pem_key_cert_pairs,
  403|       |    size_t num_key_cert_pairs);
  404|       |
  405|       |/** Destroys a grpc_ssl_server_certificate_config object. */
  406|       |GRPCAPI void grpc_ssl_server_certificate_config_destroy(
  407|       |    grpc_ssl_server_certificate_config* config);
  408|       |
  409|       |/** Callback to retrieve updated SSL server certificates, private keys, and
  410|       |   trusted CAs (for client authentication).
  411|       |    - user_data parameter, if not NULL, contains opaque data to be used by the
  412|       |      callback.
  413|       |    - Use grpc_ssl_server_certificate_config_create to create the config.
  414|       |    - The caller assumes ownership of the config. */
  415|       |typedef grpc_ssl_certificate_config_reload_status (
  416|       |    *grpc_ssl_server_certificate_config_callback)(
  417|       |    void* user_data, grpc_ssl_server_certificate_config** config);
  418|       |
  419|       |/** Deprecated in favor of grpc_ssl_server_credentials_create_ex.
  420|       |   Creates an SSL server_credentials object.
  421|       |   - pem_roots_cert is the NULL-terminated string containing the PEM encoding of
  422|       |     the client root certificates. This parameter may be NULL if the server does
  423|       |     not want the client to be authenticated with SSL.
  424|       |   - pem_key_cert_pairs is an array private key / certificate chains of the
  425|       |     server. This parameter cannot be NULL.
  426|       |   - num_key_cert_pairs indicates the number of items in the private_key_files
  427|       |     and cert_chain_files parameters. It should be at least 1.
  428|       |   - force_client_auth, if set to non-zero will force the client to authenticate
  429|       |     with an SSL cert. Note that this option is ignored if pem_root_certs is
  430|       |     NULL. */
  431|       |GRPCAPI grpc_server_credentials* grpc_ssl_server_credentials_create(
  432|       |    const char* pem_root_certs, grpc_ssl_pem_key_cert_pair* pem_key_cert_pairs,
  433|       |    size_t num_key_cert_pairs, int force_client_auth, void* reserved);
  434|       |
  435|       |/** Deprecated in favor of grpc_ssl_server_credentials_create_with_options.
  436|       |   Same as grpc_ssl_server_credentials_create method except uses
  437|       |   grpc_ssl_client_certificate_request_type enum to support more ways to
  438|       |   authenticate client cerificates.*/
  439|       |GRPCAPI grpc_server_credentials* grpc_ssl_server_credentials_create_ex(
  440|       |    const char* pem_root_certs, grpc_ssl_pem_key_cert_pair* pem_key_cert_pairs,
  441|       |    size_t num_key_cert_pairs,
  442|       |    grpc_ssl_client_certificate_request_type client_certificate_request,
  443|       |    void* reserved);
  444|       |
  445|       |typedef struct grpc_ssl_server_credentials_options
  446|       |    grpc_ssl_server_credentials_options;
  447|       |
  448|       |/** Creates an options object using a certificate config. Use this method when
  449|       |   the certificates and keys of the SSL server will not change during the
  450|       |   server's lifetime.
  451|       |   - Takes ownership of the certificate_config parameter. */
  452|       |GRPCAPI grpc_ssl_server_credentials_options*
  453|       |grpc_ssl_server_credentials_create_options_using_config(
  454|       |    grpc_ssl_client_certificate_request_type client_certificate_request,
  455|       |    grpc_ssl_server_certificate_config* certificate_config);
  456|       |
  457|       |/** Creates an options object using a certificate config fetcher. Use this
  458|       |   method to reload the certificates and keys of the SSL server without
  459|       |   interrupting the operation of the server. Initial certificate config will be
  460|       |   fetched during server initialization.
  461|       |   - user_data parameter, if not NULL, contains opaque data which will be passed
  462|       |     to the fetcher (see definition of
  463|       |     grpc_ssl_server_certificate_config_callback). */
  464|       |GRPCAPI grpc_ssl_server_credentials_options*
  465|       |grpc_ssl_server_credentials_create_options_using_config_fetcher(
  466|       |    grpc_ssl_client_certificate_request_type client_certificate_request,
  467|       |    grpc_ssl_server_certificate_config_callback cb, void* user_data);
  468|       |
  469|       |/** Destroys a grpc_ssl_server_credentials_options object. */
  470|       |GRPCAPI void grpc_ssl_server_credentials_options_destroy(
  471|       |    grpc_ssl_server_credentials_options* options);
  472|       |
  473|       |/** Creates an SSL server_credentials object using the provided options struct.
  474|       |    - Takes ownership of the options parameter. */
  475|       |GRPCAPI grpc_server_credentials*
  476|       |grpc_ssl_server_credentials_create_with_options(
  477|       |    grpc_ssl_server_credentials_options* options);
  478|       |
  479|       |/** --- Server-side secure ports. --- */
  480|       |
  481|       |/** Add a HTTP2 over an encrypted link over tcp listener.
  482|       |   Returns bound port number on success, 0 on failure.
  483|       |   REQUIRES: server not started */
  484|       |GRPCAPI int grpc_server_add_secure_http2_port(grpc_server* server,
  485|       |                                              const char* addr,
  486|       |                                              grpc_server_credentials* creds);
  487|       |
  488|       |/** --- Call specific credentials. --- */
  489|       |
  490|       |/** Sets a credentials to a call. Can only be called on the client side before
  491|       |   grpc_call_start_batch. */
  492|       |GRPCAPI grpc_call_error grpc_call_set_credentials(grpc_call* call,
  493|       |                                                  grpc_call_credentials* creds);
  494|       |
  495|       |/** --- Auth Metadata Processing --- */
  496|       |
  497|       |/** Callback function that is called when the metadata processing is done.
  498|       |   - Consumed metadata will be removed from the set of metadata available on the
  499|       |     call. consumed_md may be NULL if no metadata has been consumed.
  500|       |   - Response metadata will be set on the response. response_md may be NULL.
  501|       |   - status is GRPC_STATUS_OK for success or a specific status for an error.
  502|       |     Common error status for auth metadata processing is either
  503|       |     GRPC_STATUS_UNAUTHENTICATED in case of an authentication failure or
  504|       |     GRPC_STATUS PERMISSION_DENIED in case of an authorization failure.
  505|       |   - error_details gives details about the error. May be NULL. */
  506|       |typedef void (*grpc_process_auth_metadata_done_cb)(
  507|       |    void* user_data, const grpc_metadata* consumed_md, size_t num_consumed_md,
  508|       |    const grpc_metadata* response_md, size_t num_response_md,
  509|       |    grpc_status_code status, const char* error_details);
  510|       |
  511|       |/** Pluggable server-side metadata processor object. */
  512|       |typedef struct {
  513|       |  /** The context object is read/write: it contains the properties of the
  514|       |     channel peer and it is the job of the process function to augment it with
  515|       |     properties derived from the passed-in metadata.
  516|       |     The lifetime of these objects is guaranteed until cb is invoked. */
  517|       |  void (*process)(void* state, grpc_auth_context* context,
  518|       |                  const grpc_metadata* md, size_t num_md,
  519|       |                  grpc_process_auth_metadata_done_cb cb, void* user_data);
  520|       |  void (*destroy)(void* state);
  521|       |  void* state;
  522|       |} grpc_auth_metadata_processor;
  523|       |
  524|       |GRPCAPI void grpc_server_credentials_set_auth_metadata_processor(
  525|       |    grpc_server_credentials* creds, grpc_auth_metadata_processor processor);
  526|       |
  527|       |/** --- ALTS channel/server credentials --- **/
  528|       |
  529|       |/**
  530|       | * Main interface for ALTS credentials options. The options will contain
  531|       | * information that will be passed from grpc to TSI layer such as RPC protocol
  532|       | * versions. ALTS client (channel) and server credentials will have their own
  533|       | * implementation of this interface. The APIs listed in this header are
  534|       | * thread-compatible. It is used for experimental purpose for now and subject
  535|       | * to change.
  536|       | */
  537|       |typedef struct grpc_alts_credentials_options grpc_alts_credentials_options;
  538|       |
  539|       |/**
  540|       | * This method creates a grpc ALTS credentials client options instance.
  541|       | * It is used for experimental purpose for now and subject to change.
  542|       | */
  543|       |GRPCAPI grpc_alts_credentials_options*
  544|       |grpc_alts_credentials_client_options_create(void);
  545|       |
  546|       |/**
  547|       | * This method creates a grpc ALTS credentials server options instance.
  548|       | * It is used for experimental purpose for now and subject to change.
  549|       | */
  550|       |GRPCAPI grpc_alts_credentials_options*
  551|       |grpc_alts_credentials_server_options_create(void);
  552|       |
  553|       |/**
  554|       | * This method adds a target service account to grpc client's ALTS credentials
  555|       | * options instance. It is used for experimental purpose for now and subject
  556|       | * to change.
  557|       | *
  558|       | * - options: grpc ALTS credentials options instance.
  559|       | * - service_account: service account of target endpoint.
  560|       | */
  561|       |GRPCAPI void grpc_alts_credentials_client_options_add_target_service_account(
  562|       |    grpc_alts_credentials_options* options, const char* service_account);
  563|       |
  564|       |/**
  565|       | * This method destroys a grpc_alts_credentials_options instance by
  566|       | * de-allocating all of its occupied memory. It is used for experimental purpose
  567|       | * for now and subject to change.
  568|       | *
  569|       | * - options: a grpc_alts_credentials_options instance that needs to be
  570|       | *   destroyed.
  571|       | */
  572|       |GRPCAPI void grpc_alts_credentials_options_destroy(
  573|       |    grpc_alts_credentials_options* options);
  574|       |
  575|       |/**
  576|       | * This method creates an ALTS channel credential object. It is used for
  577|       | * experimental purpose for now and subject to change.
  578|       | *
  579|       | * - options: grpc ALTS credentials options instance for client.
  580|       | *
  581|       | * It returns the created ALTS channel credential object.
  582|       | */
  583|       |GRPCAPI grpc_channel_credentials* grpc_alts_credentials_create(
  584|       |    const grpc_alts_credentials_options* options);
  585|       |
  586|       |/**
  587|       | * This method creates an ALTS server credential object. It is used for
  588|       | * experimental purpose for now and subject to change.
  589|       | *
  590|       | * - options: grpc ALTS credentials options instance for server.
  591|       | *
  592|       | * It returns the created ALTS server credential object.
  593|       | */
  594|       |GRPCAPI grpc_server_credentials* grpc_alts_server_credentials_create(
  595|       |    const grpc_alts_credentials_options* options);
  596|       |
  597|       |/** --- Local channel/server credentials --- **/
  598|       |
  599|       |/**
  600|       | * This method creates a local channel credential object. It is used for
  601|       | * experimental purpose for now and subject to change.
  602|       | *
  603|       | * - type: local connection type
  604|       | *
  605|       | * It returns the created local channel credential object.
  606|       | */
  607|       |GRPCAPI grpc_channel_credentials* grpc_local_credentials_create(
  608|       |    grpc_local_connect_type type);
  609|       |
  610|       |/**
  611|       | * This method creates a local server credential object. It is used for
  612|       | * experimental purpose for now and subject to change.
  613|       | *
  614|       | * - type: local connection type
  615|       | *
  616|       | * It returns the created local server credential object.
  617|       | */
  618|       |GRPCAPI grpc_server_credentials* grpc_local_server_credentials_create(
  619|       |    grpc_local_connect_type type);
  620|       |
  621|       |/** --- SPIFFE and HTTPS-based TLS channel/server credentials ---
  622|       | * It is used for experimental purpose for now and subject to change. */
  623|       |
  624|       |/** Config for TLS key materials. It is used for
  625|       | *  experimental purpose for now and subject to change. */
  626|       |typedef struct grpc_tls_key_materials_config grpc_tls_key_materials_config;
  627|       |
  628|       |/** Config for TLS credential reload. It is used for
  629|       | *  experimental purpose for now and subject to change. */
  630|       |typedef struct grpc_tls_credential_reload_config
  631|       |    grpc_tls_credential_reload_config;
  632|       |
  633|       |/** Config for TLS server authorization check. It is used for
  634|       | *  experimental purpose for now and subject to change. */
  635|       |typedef struct grpc_tls_server_authorization_check_config
  636|       |    grpc_tls_server_authorization_check_config;
  637|       |
  638|       |/** TLS credentials options. It is used for
  639|       | *  experimental purpose for now and subject to change. */
  640|       |typedef struct grpc_tls_credentials_options grpc_tls_credentials_options;
  641|       |
  642|       |/** Create an empty TLS credentials options. It is used for
  643|       | *  experimental purpose for now and subject to change. */
  644|       |GRPCAPI grpc_tls_credentials_options* grpc_tls_credentials_options_create();
  645|       |
  646|       |/** Set grpc_ssl_client_certificate_request_type field in credentials options
  647|       |    with the provided type. options should not be NULL.
  648|       |    It returns 1 on success and 0 on failure. It is used for
  649|       |    experimental purpose for now and subject to change. */
  650|       |GRPCAPI int grpc_tls_credentials_options_set_cert_request_type(
  651|       |    grpc_tls_credentials_options* options,
  652|       |    grpc_ssl_client_certificate_request_type type);
  653|       |
  654|       |/** Set grpc_tls_key_materials_config field in credentials options
  655|       |    with the provided config struct whose ownership is transferred.
  656|       |    Both parameters should not be NULL.
  657|       |    It returns 1 on success and 0 on failure. It is used for
  658|       |    experimental purpose for now and subject to change. */
  659|       |GRPCAPI int grpc_tls_credentials_options_set_key_materials_config(
  660|       |    grpc_tls_credentials_options* options,
  661|       |    grpc_tls_key_materials_config* config);
  662|       |
  663|       |/** Set grpc_tls_credential_reload_config field in credentials options
  664|       |    with the provided config struct whose ownership is transferred.
  665|       |    Both parameters should not be NULL.
  666|       |    It returns 1 on success and 0 on failure. It is used for
  667|       |    experimental purpose for now and subject to change. */
  668|       |GRPCAPI int grpc_tls_credentials_options_set_credential_reload_config(
  669|       |    grpc_tls_credentials_options* options,
  670|       |    grpc_tls_credential_reload_config* config);
  671|       |
  672|       |/** Set grpc_tls_server_authorization_check_config field in credentials options
  673|       |    with the provided config struct whose ownership is transferred.
  674|       |    Both parameters should not be NULL.
  675|       |    It returns 1 on success and 0 on failure. It is used for
  676|       |    experimental purpose for now and subject to change. */
  677|       |GRPCAPI int grpc_tls_credentials_options_set_server_authorization_check_config(
  678|       |    grpc_tls_credentials_options* options,
  679|       |    grpc_tls_server_authorization_check_config* config);
  680|       |
  681|       |/** --- TLS key materials config. ---
  682|       |    It is used for experimental purpose for now and subject to change. */
  683|       |
  684|       |/** Create an empty grpc_tls_key_materials_config instance.
  685|       | *  It is used for experimental purpose for now and subject to change. */
  686|       |GRPCAPI grpc_tls_key_materials_config* grpc_tls_key_materials_config_create();
  687|       |
  688|       |/** Set grpc_tls_key_materials_config instance with provided a TLS certificate.
  689|       |    config will take the ownership of pem_root_certs and pem_key_cert_pairs.
  690|       |    It's valid for the caller to provide nullptr pem_root_certs, in which case
  691|       |    the gRPC-provided root cert will be used. pem_key_cert_pairs should not be
  692|       |    NULL. It returns 1 on success and 0 on failure. It is used for
  693|       |    experimental purpose for now and subject to change.
  694|       | */
  695|       |GRPCAPI int grpc_tls_key_materials_config_set_key_materials(
  696|       |    grpc_tls_key_materials_config* config, const char* pem_root_certs,
  697|       |    const grpc_ssl_pem_key_cert_pair** pem_key_cert_pairs,
  698|       |    size_t num_key_cert_pairs);
  699|       |
  700|       |/** --- TLS credential reload config. ---
  701|       |    It is used for experimental purpose for now and subject to change.*/
  702|       |
  703|       |typedef struct grpc_tls_credential_reload_arg grpc_tls_credential_reload_arg;
  704|       |
  705|       |/** A callback function provided by gRPC to handle the result of credential
  706|       |    reload. It is used when schedule API is implemented asynchronously and
  707|       |    serves to bring the control back to grpc C core. It is used for
  708|       |    experimental purpose for now and subject to change. */
  709|       |typedef void (*grpc_tls_on_credential_reload_done_cb)(
  710|       |    grpc_tls_credential_reload_arg* arg);
  711|       |
  712|       |/** A struct containing all information necessary to schedule/cancel
  713|       |    a credential reload request. cb and cb_user_data represent a gRPC-provided
  714|       |    callback and an argument passed to it. key_materials is an in/output
  715|       |    parameter containing currently used/newly reloaded credentials. status and
  716|       |    error_details are used to hold information about errors occurred when a
  717|       |    credential reload request is scheduled/cancelled. It is used for
  718|       |    experimental purpose for now and subject to change. */
  719|       |struct grpc_tls_credential_reload_arg {
  720|       |  grpc_tls_on_credential_reload_done_cb cb;
  721|       |  void* cb_user_data;
  722|       |  grpc_tls_key_materials_config* key_materials_config;
  723|       |  grpc_ssl_certificate_config_reload_status status;
  724|       |  const char* error_details;
  725|       |};
  726|       |
  727|       |/** Create a grpc_tls_credential_reload_config instance.
  728|       |    - config_user_data is config-specific, read-only user data
  729|       |      that works for all channels created with a credential using the config.
  730|       |    - schedule is a pointer to an application-provided callback used to invoke
  731|       |      credential reload API. The implementation of this method has to be
  732|       |      non-blocking, but can be performed synchronously or asynchronously.
  733|       |      1) If processing occurs synchronously, it populates arg->key_materials,
  734|       |      arg->status, and arg->error_details and returns zero.
  735|       |      2) If processing occurs asynchronously, it returns a non-zero value.
  736|       |      The application then invokes arg->cb when processing is completed. Note
  737|       |      that arg->cb cannot be invoked before schedule API returns.
  738|       |    - cancel is a pointer to an application-provided callback used to cancel
  739|       |      a credential reload request scheduled via an asynchronous schedule API.
  740|       |      arg is used to pinpoint an exact reloading request to be cancelled.
  741|       |      The operation may not have any effect if the request has already been
  742|       |      processed.
  743|       |    - destruct is a pointer to an application-provided callback used to clean up
  744|       |      any data associated with the config.
  745|       |    It is used for experimental purpose for now and subject to change.
  746|       |*/
  747|       |GRPCAPI grpc_tls_credential_reload_config*
  748|       |grpc_tls_credential_reload_config_create(
  749|       |    const void* config_user_data,
  750|       |    int (*schedule)(void* config_user_data,
  751|       |                    grpc_tls_credential_reload_arg* arg),
  752|       |    void (*cancel)(void* config_user_data, grpc_tls_credential_reload_arg* arg),
  753|       |    void (*destruct)(void* config_user_data));
  754|       |
  755|       |/** --- TLS server authorization check config. ---
  756|       | *  It is used for experimental purpose for now and subject to change. */
  757|       |
  758|       |typedef struct grpc_tls_server_authorization_check_arg
  759|       |    grpc_tls_server_authorization_check_arg;
  760|       |
  761|       |/** callback function provided by gRPC used to handle the result of server
  762|       |    authorization check. It is used when schedule API is implemented
  763|       |    asynchronously, and serves to bring the control back to gRPC C core. It is
  764|       |    used for experimental purpose for now and subject to change. */
  765|       |typedef void (*grpc_tls_on_server_authorization_check_done_cb)(
  766|       |    grpc_tls_server_authorization_check_arg* arg);
  767|       |
  768|       |/** A struct containing all information necessary to schedule/cancel a server
  769|       |   authorization check request. cb and cb_user_data represent a gRPC-provided
  770|       |   callback and an argument passed to it. success will store the result of
  771|       |   server authorization check. That is, if success returns a non-zero value, it
  772|       |   means the authorization check passes and if returning zero, it means the
  773|       |   check fails. target_name is the name of an endpoint the channel is connecting
  774|       |   to and certificate represents a complete certificate chain including both
  775|       |   signing and leaf certificates. status and error_details contain information
  776|       |   about errors occurred when a server authorization check request is
  777|       |   scheduled/cancelled. It is used for experimental purpose for now and subject
  778|       |   to change.*/
  779|       |struct grpc_tls_server_authorization_check_arg {
  780|       |  grpc_tls_on_server_authorization_check_done_cb cb;
  781|       |  void* cb_user_data;
  782|       |  int success;
  783|       |  const char* target_name;
  784|       |  const char* peer_cert;
  785|       |  grpc_status_code status;
  786|       |  const char* error_details;
  787|       |};
  788|       |
  789|       |/** Create a grpc_tls_server_authorization_check_config instance.
  790|       |    - config_user_data is config-specific, read-only user data
  791|       |      that works for all channels created with a credential using the config.
  792|       |    - schedule is a pointer to an application-provided callback used to invoke
  793|       |      server authorization check API. The implementation of this method has to
  794|       |      be non-blocking, but can be performed synchronously or asynchronously.
  795|       |      1)If processing occurs synchronously, it populates arg->result,
  796|       |      arg->status, and arg->error_details and returns zero.
  797|       |      2) If processing occurs asynchronously, it returns a non-zero value. The
  798|       |      application then invokes arg->cb when processing is completed. Note that
  799|       |      arg->cb cannot be invoked before schedule API returns.
  800|       |    - cancel is a pointer to an application-provided callback used to cancel a
  801|       |      server authorization check request scheduled via an asynchronous schedule
  802|       |      API. arg is used to pinpoint an exact check request to be cancelled. The
  803|       |      operation may not have any effect if the request has already been
  804|       |      processed.
  805|       |    - destruct is a pointer to an application-provided callback used to clean up
  806|       |      any data associated with the config.
  807|       |    It is used for experimental purpose for now and subject to change.
  808|       |*/
  809|       |GRPCAPI grpc_tls_server_authorization_check_config*
  810|       |grpc_tls_server_authorization_check_config_create(
  811|       |    const void* config_user_data,
  812|       |    int (*schedule)(void* config_user_data,
  813|       |                    grpc_tls_server_authorization_check_arg* arg),
  814|       |    void (*cancel)(void* config_user_data,
  815|       |                   grpc_tls_server_authorization_check_arg* arg),
  816|       |    void (*destruct)(void* config_user_data));
  817|       |
  818|       |/** --- SPIFFE channel/server credentials --- **/
  819|       |
  820|       |/**
  821|       | * This method creates a TLS SPIFFE channel credential object.
  822|       | * It takes ownership of the options parameter.
  823|       | *
  824|       | * - options: grpc TLS credentials options instance.
  825|       | *
  826|       | * It returns the created credential object.
  827|       | *
  828|       | * It is used for experimental purpose for now and subject
  829|       | * to change.
  830|       | */
  831|       |
  832|       |grpc_channel_credentials* grpc_tls_spiffe_credentials_create(
  833|       |    grpc_tls_credentials_options* options);
  834|       |
  835|       |/**
  836|       | * This method creates a TLS server credential object.
  837|       | * It takes ownership of the options parameter.
  838|       | *
  839|       | * - options: grpc TLS credentials options instance.
  840|       | *
  841|       | * It returns the created credential object.
  842|       | *
  843|       | * It is used for experimental purpose for now and subject
  844|       | * to change.
  845|       | */
  846|       |grpc_server_credentials* grpc_tls_spiffe_server_credentials_create(
  847|       |    grpc_tls_credentials_options* options);
  848|       |
  849|       |#ifdef __cplusplus
  850|       |}
  851|       |#endif
  852|       |
  853|       |#endif /* GRPC_GRPC_SECURITY_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpc/impl/codegen/atm_gcc_atomic.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_IMPL_CODEGEN_ATM_GCC_ATOMIC_H
   20|       |#define GRPC_IMPL_CODEGEN_ATM_GCC_ATOMIC_H
   21|       |
   22|       |/* atm_platform.h for gcc and gcc-like compilers with the
   23|       |   __atomic_* interface.  */
   24|       |#include <grpc/impl/codegen/port_platform.h>
   25|       |
   26|       |#ifdef __cplusplus
   27|       |extern "C" {
   28|       |#endif
   29|       |
   30|       |typedef intptr_t gpr_atm;
   31|       |#define GPR_ATM_MAX INTPTR_MAX
   32|       |#define GPR_ATM_MIN INTPTR_MIN
   33|       |
   34|       |#ifdef GPR_LOW_LEVEL_COUNTERS
   35|       |extern gpr_atm gpr_counter_atm_cas;
   36|       |extern gpr_atm gpr_counter_atm_add;
   37|       |#define GPR_ATM_INC_COUNTER(counter) \
   38|       |  __atomic_fetch_add(&counter, 1, __ATOMIC_RELAXED)
   39|       |#define GPR_ATM_INC_CAS_THEN(blah) \
   40|       |  (GPR_ATM_INC_COUNTER(gpr_counter_atm_cas), blah)
   41|       |#define GPR_ATM_INC_ADD_THEN(blah) \
   42|       |  (GPR_ATM_INC_COUNTER(gpr_counter_atm_add), blah)
   43|       |#else
   44|       |#define GPR_ATM_INC_CAS_THEN(blah) blah
   45|      0|#define GPR_ATM_INC_ADD_THEN(blah) blah
   46|       |#endif
   47|       |
   48|       |#define gpr_atm_full_barrier() (__atomic_thread_fence(__ATOMIC_SEQ_CST))
   49|       |
   50|       |#define gpr_atm_acq_load(p) (__atomic_load_n((p), __ATOMIC_ACQUIRE))
   51|       |#define gpr_atm_no_barrier_load(p) (__atomic_load_n((p), __ATOMIC_RELAXED))
   52|       |#define gpr_atm_rel_store(p, value) \
   53|      0|  (__atomic_store_n((p), (intptr_t)(value), __ATOMIC_RELEASE))
   54|       |#define gpr_atm_no_barrier_store(p, value) \
   55|       |  (__atomic_store_n((p), (intptr_t)(value), __ATOMIC_RELAXED))
   56|       |
   57|       |#define gpr_atm_no_barrier_fetch_add(p, delta) \
   58|      0|  GPR_ATM_INC_ADD_THEN(                        \
   59|      0|      __atomic_fetch_add((p), (intptr_t)(delta), __ATOMIC_RELAXED))
   60|       |#define gpr_atm_full_fetch_add(p, delta) \
   61|       |  GPR_ATM_INC_ADD_THEN(                  \
   62|       |      __atomic_fetch_add((p), (intptr_t)(delta), __ATOMIC_ACQ_REL))
   63|       |
   64|      0|static __inline int gpr_atm_no_barrier_cas(gpr_atm* p, gpr_atm o, gpr_atm n) {
   65|      0|  return GPR_ATM_INC_CAS_THEN(__atomic_compare_exchange_n(
   66|      0|      p, &o, n, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED));
   67|      0|}
  ------------------
  | Unexecuted instantiation: alarm.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: auth_property_iterator.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: byte_buffer_cc.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: channel_argument_option.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: channel_filter.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: client_interceptor.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: codegen_init.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: completion_queue_cc.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: core_codegen.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: create_channel_internal.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: create_channel_posix.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: create_default_thread_pool.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: dynamic_thread_pool.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: generic_stub.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: health_check_service_server_builder_option.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: insecure_server_credentials.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: resource_quota_cc.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: secure_auth_context.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: secure_channel_arguments.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: secure_create_auth_context.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: secure_server_credentials.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: server_context.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: thread_manager.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZL22gpr_atm_no_barrier_casPlll
  ------------------
   68|       |
   69|      0|static __inline int gpr_atm_acq_cas(gpr_atm* p, gpr_atm o, gpr_atm n) {
   70|      0|  return GPR_ATM_INC_CAS_THEN(__atomic_compare_exchange_n(
   71|      0|      p, &o, n, 0, __ATOMIC_ACQUIRE, __ATOMIC_RELAXED));
   72|      0|}
  ------------------
  | Unexecuted instantiation: alarm.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: auth_property_iterator.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: byte_buffer_cc.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: channel_argument_option.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: channel_filter.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: client_interceptor.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: codegen_init.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: completion_queue_cc.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: core_codegen.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: create_channel_internal.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: create_channel_posix.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: create_default_thread_pool.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: dynamic_thread_pool.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: generic_stub.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: health_check_service_server_builder_option.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: insecure_server_credentials.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: resource_quota_cc.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: secure_auth_context.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: secure_channel_arguments.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: secure_create_auth_context.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: secure_server_credentials.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: server_context.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: thread_manager.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZL15gpr_atm_acq_casPlll
  ------------------
   73|       |
   74|      0|static __inline int gpr_atm_rel_cas(gpr_atm* p, gpr_atm o, gpr_atm n) {
   75|      0|  return GPR_ATM_INC_CAS_THEN(__atomic_compare_exchange_n(
   76|      0|      p, &o, n, 0, __ATOMIC_RELEASE, __ATOMIC_RELAXED));
   77|      0|}
  ------------------
  | Unexecuted instantiation: alarm.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: auth_property_iterator.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: byte_buffer_cc.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: channel_argument_option.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: channel_filter.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: client_interceptor.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: codegen_init.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: completion_queue_cc.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: core_codegen.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: create_channel_internal.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: create_channel_posix.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: create_default_thread_pool.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: dynamic_thread_pool.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: generic_stub.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: health_check_service_server_builder_option.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: insecure_server_credentials.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: resource_quota_cc.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: secure_auth_context.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: secure_channel_arguments.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: secure_create_auth_context.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: secure_server_credentials.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: server_context.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: thread_manager.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZL15gpr_atm_rel_casPlll
  ------------------
   78|       |
   79|      0|static __inline int gpr_atm_full_cas(gpr_atm* p, gpr_atm o, gpr_atm n) {
   80|      0|  return GPR_ATM_INC_CAS_THEN(__atomic_compare_exchange_n(
   81|      0|      p, &o, n, 0, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED));
   82|      0|}
  ------------------
  | Unexecuted instantiation: alarm.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: auth_property_iterator.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: byte_buffer_cc.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: channel_argument_option.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: channel_filter.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: client_interceptor.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: codegen_init.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: completion_queue_cc.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: core_codegen.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: create_channel_internal.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: create_channel_posix.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: create_default_thread_pool.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: dynamic_thread_pool.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: generic_stub.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: health_check_service_server_builder_option.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: insecure_server_credentials.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: resource_quota_cc.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: secure_auth_context.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: secure_channel_arguments.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: secure_create_auth_context.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: secure_server_credentials.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: server_context.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: thread_manager.cc:_ZL16gpr_atm_full_casPlll
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZL16gpr_atm_full_casPlll
  ------------------
   83|       |
   84|       |#define gpr_atm_full_xchg(p, n) \
   85|       |  GPR_ATM_INC_CAS_THEN(__atomic_exchange_n((p), (n), __ATOMIC_ACQ_REL))
   86|       |
   87|       |#ifdef __cplusplus
   88|       |}
   89|       |#endif
   90|       |
   91|       |#endif /* GRPC_IMPL_CODEGEN_ATM_GCC_ATOMIC_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpc/impl/codegen/compression_types.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_IMPL_CODEGEN_COMPRESSION_TYPES_H
   20|       |#define GRPC_IMPL_CODEGEN_COMPRESSION_TYPES_H
   21|       |
   22|       |#include <grpc/impl/codegen/port_platform.h>
   23|       |
   24|       |#ifdef __cplusplus
   25|       |extern "C" {
   26|       |#endif
   27|       |
   28|       |/** To be used as initial metadata key for the request of a concrete compression
   29|       | * algorithm */
   30|       |#define GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY \
   31|      0|  "grpc-internal-encoding-request"
   32|       |
   33|       |/** To be used in channel arguments.
   34|       | *
   35|       | * \addtogroup grpc_arg_keys
   36|       | * \{ */
   37|       |/** Default compression algorithm for the channel.
   38|       | * Its value is an int from the \a grpc_compression_algorithm enum. */
   39|       |#define GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM \
   40|      0|  "grpc.default_compression_algorithm"
   41|       |/** Default compression level for the channel.
   42|       | * Its value is an int from the \a grpc_compression_level enum. */
   43|      0|#define GRPC_COMPRESSION_CHANNEL_DEFAULT_LEVEL "grpc.default_compression_level"
   44|       |/** Compression algorithms supported by the channel.
   45|       | * Its value is a bitset (an int). Bits correspond to algorithms in \a
   46|       | * grpc_compression_algorithm. For example, its LSB corresponds to
   47|       | * GRPC_COMPRESS_NONE, the next bit to GRPC_COMPRESS_DEFLATE, etc.
   48|       | * Unset bits disable support for the algorithm. By default all algorithms are
   49|       | * supported. It's not possible to disable GRPC_COMPRESS_NONE (the attempt will
   50|       | * be ignored). */
   51|       |#define GRPC_COMPRESSION_CHANNEL_ENABLED_ALGORITHMS_BITSET \
   52|      0|  "grpc.compression_enabled_algorithms_bitset"
   53|       |/** \} */
   54|       |
   55|       |/** The various compression algorithms supported by gRPC (not sorted by
   56|       | * compression level) */
   57|       |typedef enum {
   58|       |  GRPC_COMPRESS_NONE = 0,
   59|       |  GRPC_COMPRESS_DEFLATE,
   60|       |  GRPC_COMPRESS_GZIP,
   61|       |  /* EXPERIMENTAL: Stream compression is currently experimental. */
   62|       |  GRPC_COMPRESS_STREAM_GZIP,
   63|       |  /* TODO(ctiller): snappy */
   64|       |  GRPC_COMPRESS_ALGORITHMS_COUNT
   65|       |} grpc_compression_algorithm;
   66|       |
   67|       |/** Compression levels allow a party with knowledge of its peer's accepted
   68|       | * encodings to request compression in an abstract way. The level-algorithm
   69|       | * mapping is performed internally and depends on the peer's supported
   70|       | * compression algorithms. */
   71|       |typedef enum {
   72|       |  GRPC_COMPRESS_LEVEL_NONE = 0,
   73|       |  GRPC_COMPRESS_LEVEL_LOW,
   74|       |  GRPC_COMPRESS_LEVEL_MED,
   75|       |  GRPC_COMPRESS_LEVEL_HIGH,
   76|       |  GRPC_COMPRESS_LEVEL_COUNT
   77|       |} grpc_compression_level;
   78|       |
   79|       |typedef struct grpc_compression_options {
   80|       |  /** All algs are enabled by default. This option corresponds to the channel
   81|       |   * argument key behind \a GRPC_COMPRESSION_CHANNEL_ENABLED_ALGORITHMS_BITSET
   82|       |   */
   83|       |  uint32_t enabled_algorithms_bitset;
   84|       |
   85|       |  /** The default compression level. It'll be used in the absence of call
   86|       |   * specific settings. This option corresponds to the channel
   87|       |   * argument key behind \a GRPC_COMPRESSION_CHANNEL_DEFAULT_LEVEL. If present,
   88|       |   * takes precedence over \a default_algorithm.
   89|       |   * TODO(dgq): currently only available for server channels. */
   90|       |  struct grpc_compression_options_default_level {
   91|       |    int is_set;
   92|       |    grpc_compression_level level;
   93|       |  } default_level;
   94|       |
   95|       |  /** The default message compression algorithm. It'll be used in the absence of
   96|       |   * call specific settings. This option corresponds to the channel argument key
   97|       |   * behind \a GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM. */
   98|       |  struct grpc_compression_options_default_algorithm {
   99|       |    int is_set;
  100|       |    grpc_compression_algorithm algorithm;
  101|       |  } default_algorithm;
  102|       |} grpc_compression_options;
  103|       |
  104|       |#ifdef __cplusplus
  105|       |}
  106|       |#endif
  107|       |
  108|       |#endif /* GRPC_IMPL_CODEGEN_COMPRESSION_TYPES_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpc/impl/codegen/grpc_types.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_IMPL_CODEGEN_GRPC_TYPES_H
   20|       |#define GRPC_IMPL_CODEGEN_GRPC_TYPES_H
   21|       |
   22|       |#include <grpc/impl/codegen/port_platform.h>
   23|       |
   24|       |#include <grpc/impl/codegen/compression_types.h>
   25|       |#include <grpc/impl/codegen/gpr_types.h>
   26|       |#include <grpc/impl/codegen/slice.h>
   27|       |#include <grpc/impl/codegen/status.h>
   28|       |
   29|       |#include <stddef.h>
   30|       |
   31|       |#ifdef __cplusplus
   32|       |extern "C" {
   33|       |#endif
   34|       |
   35|       |typedef enum {
   36|       |  GRPC_BB_RAW
   37|       |  /** Future types may include GRPC_BB_PROTOBUF, etc. */
   38|       |} grpc_byte_buffer_type;
   39|       |
   40|       |typedef struct grpc_byte_buffer {
   41|       |  void* reserved;
   42|       |  grpc_byte_buffer_type type;
   43|       |  union grpc_byte_buffer_data {
   44|       |    struct /* internal */ {
   45|       |      void* reserved[8];
   46|       |    } reserved;
   47|       |    struct grpc_compressed_buffer {
   48|       |      grpc_compression_algorithm compression;
   49|       |      grpc_slice_buffer slice_buffer;
   50|       |    } raw;
   51|       |  } data;
   52|       |} grpc_byte_buffer;
   53|       |
   54|       |/** Completion Queues enable notification of the completion of
   55|       | * asynchronous actions. */
   56|       |typedef struct grpc_completion_queue grpc_completion_queue;
   57|       |
   58|       |/** An alarm associated with a completion queue. */
   59|       |typedef struct grpc_alarm grpc_alarm;
   60|       |
   61|       |/** The Channel interface allows creation of Call objects. */
   62|       |typedef struct grpc_channel grpc_channel;
   63|       |
   64|       |/** A server listens to some port and responds to request calls */
   65|       |typedef struct grpc_server grpc_server;
   66|       |
   67|       |/** A Call represents an RPC. When created, it is in a configuration state
   68|       |    allowing properties to be set until it is invoked. After invoke, the Call
   69|       |    can have messages written to it and read from it. */
   70|       |typedef struct grpc_call grpc_call;
   71|       |
   72|       |/** The Socket Mutator interface allows changes on socket options */
   73|       |typedef struct grpc_socket_mutator grpc_socket_mutator;
   74|       |
   75|       |/** The Socket Factory interface creates and binds sockets */
   76|       |typedef struct grpc_socket_factory grpc_socket_factory;
   77|       |
   78|       |/** Type specifier for grpc_arg */
   79|       |typedef enum {
   80|       |  GRPC_ARG_STRING,
   81|       |  GRPC_ARG_INTEGER,
   82|       |  GRPC_ARG_POINTER
   83|       |} grpc_arg_type;
   84|       |
   85|       |typedef struct grpc_arg_pointer_vtable {
   86|       |  void* (*copy)(void* p);
   87|       |  void (*destroy)(void* p);
   88|       |  int (*cmp)(void* p, void* q);
   89|       |} grpc_arg_pointer_vtable;
   90|       |
   91|       |/** A single argument... each argument has a key and a value
   92|       |
   93|       |    A note on naming keys:
   94|       |      Keys are namespaced into groups, usually grouped by library, and are
   95|       |      keys for module XYZ are named XYZ.key1, XYZ.key2, etc. Module names must
   96|       |      be restricted to the regex [A-Za-z][_A-Za-z0-9]{,15}.
   97|       |      Key names must be restricted to the regex [A-Za-z][_A-Za-z0-9]{,47}.
   98|       |
   99|       |    GRPC core library keys are prefixed by grpc.
  100|       |
  101|       |    Library authors are strongly encouraged to \#define symbolic constants for
  102|       |    their keys so that it's possible to change them in the future. */
  103|       |typedef struct {
  104|       |  grpc_arg_type type;
  105|       |  char* key;
  106|       |  union grpc_arg_value {
  107|       |    char* string;
  108|       |    int integer;
  109|       |    struct grpc_arg_pointer {
  110|       |      void* p;
  111|       |      const grpc_arg_pointer_vtable* vtable;
  112|       |    } pointer;
  113|       |  } value;
  114|       |} grpc_arg;
  115|       |
  116|       |/** An array of arguments that can be passed around.
  117|       |
  118|       |    Used to set optional channel-level configuration.
  119|       |    These configuration options are modelled as key-value pairs as defined
  120|       |    by grpc_arg; keys are strings to allow easy backwards-compatible extension
  121|       |    by arbitrary parties. All evaluation is performed at channel creation
  122|       |    time (i.e. the keys and values in this structure need only live through the
  123|       |    creation invocation).
  124|       |
  125|       |    However, if one of the args has grpc_arg_type==GRPC_ARG_POINTER, then the
  126|       |    grpc_arg_pointer_vtable must live until the channel args are done being
  127|       |    used by core (i.e. when the object for use with which they were passed
  128|       |    is destroyed).
  129|       |
  130|       |    See the description of the \ref grpc_arg_keys "available args" for more
  131|       |    details. */
  132|       |typedef struct {
  133|       |  size_t num_args;
  134|       |  grpc_arg* args;
  135|       |} grpc_channel_args;
  136|       |
  137|       |/** \defgroup grpc_arg_keys
  138|       | * Channel argument keys.
  139|       | * \{
  140|       | */
  141|       |/** If non-zero, enable census for tracing and stats collection. */
  142|       |#define GRPC_ARG_ENABLE_CENSUS "grpc.census"
  143|       |/** If non-zero, enable load reporting. */
  144|       |#define GRPC_ARG_ENABLE_LOAD_REPORTING "grpc.loadreporting"
  145|       |/** Request that optional features default to off (regardless of what they
  146|       |    usually default to) - to enable tight control over what gets enabled */
  147|       |#define GRPC_ARG_MINIMAL_STACK "grpc.minimal_stack"
  148|       |/** Maximum number of concurrent incoming streams to allow on a http2
  149|       |    connection. Int valued. */
  150|       |#define GRPC_ARG_MAX_CONCURRENT_STREAMS "grpc.max_concurrent_streams"
  151|       |/** Maximum message length that the channel can receive. Int valued, bytes.
  152|       |    -1 means unlimited. */
  153|      0|#define GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH "grpc.max_receive_message_length"
  154|       |/** \deprecated For backward compatibility.
  155|       | * Use GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH instead. */
  156|       |#define GRPC_ARG_MAX_MESSAGE_LENGTH GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH
  157|       |/** Maximum message length that the channel can send. Int valued, bytes.
  158|       |    -1 means unlimited. */
  159|      0|#define GRPC_ARG_MAX_SEND_MESSAGE_LENGTH "grpc.max_send_message_length"
  160|       |/** Maximum time that a channel may have no outstanding rpcs. Int valued,
  161|       |    milliseconds. INT_MAX means unlimited. */
  162|       |#define GRPC_ARG_MAX_CONNECTION_IDLE_MS "grpc.max_connection_idle_ms"
  163|       |/** Maximum time that a channel may exist. Int valued, milliseconds.
  164|       | * INT_MAX means unlimited. */
  165|       |#define GRPC_ARG_MAX_CONNECTION_AGE_MS "grpc.max_connection_age_ms"
  166|       |/** Grace period after the channel reaches its max age. Int valued,
  167|       |   milliseconds. INT_MAX means unlimited. */
  168|       |#define GRPC_ARG_MAX_CONNECTION_AGE_GRACE_MS "grpc.max_connection_age_grace_ms"
  169|       |/** Enable/disable support for per-message compression. Defaults to 1, unless
  170|       |    GRPC_ARG_MINIMAL_STACK is enabled, in which case it defaults to 0. */
  171|       |#define GRPC_ARG_ENABLE_PER_MESSAGE_COMPRESSION "grpc.per_message_compression"
  172|       |/** Enable/disable support for deadline checking. Defaults to 1, unless
  173|       |    GRPC_ARG_MINIMAL_STACK is enabled, in which case it defaults to 0 */
  174|       |#define GRPC_ARG_ENABLE_DEADLINE_CHECKS "grpc.enable_deadline_checking"
  175|       |/** Initial stream ID for http2 transports. Int valued. */
  176|       |#define GRPC_ARG_HTTP2_INITIAL_SEQUENCE_NUMBER \
  177|       |  "grpc.http2.initial_sequence_number"
  178|       |/** Amount to read ahead on individual streams. Defaults to 64kb, larger
  179|       |    values can help throughput on high-latency connections.
  180|       |    NOTE: at some point we'd like to auto-tune this, and this parameter
  181|       |    will become a no-op. Int valued, bytes. */
  182|       |#define GRPC_ARG_HTTP2_STREAM_LOOKAHEAD_BYTES "grpc.http2.lookahead_bytes"
  183|       |/** How much memory to use for hpack decoding. Int valued, bytes. */
  184|       |#define GRPC_ARG_HTTP2_HPACK_TABLE_SIZE_DECODER \
  185|       |  "grpc.http2.hpack_table_size.decoder"
  186|       |/** How much memory to use for hpack encoding. Int valued, bytes. */
  187|       |#define GRPC_ARG_HTTP2_HPACK_TABLE_SIZE_ENCODER \
  188|       |  "grpc.http2.hpack_table_size.encoder"
  189|       |/** How big a frame are we willing to receive via HTTP2.
  190|       |    Min 16384, max 16777215. Larger values give lower CPU usage for large
  191|       |    messages, but more head of line blocking for small messages. */
  192|       |#define GRPC_ARG_HTTP2_MAX_FRAME_SIZE "grpc.http2.max_frame_size"
  193|       |/** Should BDP probing be performed? */
  194|       |#define GRPC_ARG_HTTP2_BDP_PROBE "grpc.http2.bdp_probe"
  195|       |/** Minimum time between sending successive ping frames without receiving any
  196|       |    data frame, Int valued, milliseconds. */
  197|       |#define GRPC_ARG_HTTP2_MIN_SENT_PING_INTERVAL_WITHOUT_DATA_MS \
  198|       |  "grpc.http2.min_time_between_pings_ms"
  199|       |/** Minimum allowed time between a server receiving successive ping frames
  200|       |   without sending any data frame. Int valued, milliseconds */
  201|       |#define GRPC_ARG_HTTP2_MIN_RECV_PING_INTERVAL_WITHOUT_DATA_MS \
  202|       |  "grpc.http2.min_ping_interval_without_data_ms"
  203|       |/** Channel arg to override the http2 :scheme header */
  204|       |#define GRPC_ARG_HTTP2_SCHEME "grpc.http2_scheme"
  205|       |/** How many pings can we send before needing to send a data frame or header
  206|       |    frame? (0 indicates that an infinite number of pings can be sent without
  207|       |    sending a data frame or header frame) */
  208|       |#define GRPC_ARG_HTTP2_MAX_PINGS_WITHOUT_DATA \
  209|       |  "grpc.http2.max_pings_without_data"
  210|       |/** How many misbehaving pings the server can bear before sending goaway and
  211|       |    closing the transport? (0 indicates that the server can bear an infinite
  212|       |    number of misbehaving pings) */
  213|       |#define GRPC_ARG_HTTP2_MAX_PING_STRIKES "grpc.http2.max_ping_strikes"
  214|       |/** How much data are we willing to queue up per stream if
  215|       |    GRPC_WRITE_BUFFER_HINT is set? This is an upper bound */
  216|       |#define GRPC_ARG_HTTP2_WRITE_BUFFER_SIZE "grpc.http2.write_buffer_size"
  217|       |/** Should we allow receipt of true-binary data on http2 connections?
  218|       |    Defaults to on (1) */
  219|       |#define GRPC_ARG_HTTP2_ENABLE_TRUE_BINARY "grpc.http2.true_binary"
  220|       |/** After a duration of this time the client/server pings its peer to see if the
  221|       |    transport is still alive. Int valued, milliseconds. */
  222|       |#define GRPC_ARG_KEEPALIVE_TIME_MS "grpc.keepalive_time_ms"
  223|       |/** After waiting for a duration of this time, if the keepalive ping sender does
  224|       |    not receive the ping ack, it will close the transport. Int valued,
  225|       |    milliseconds. */
  226|       |#define GRPC_ARG_KEEPALIVE_TIMEOUT_MS "grpc.keepalive_timeout_ms"
  227|       |/** Is it permissible to send keepalive pings without any outstanding streams.
  228|       |    Int valued, 0(false)/1(true). */
  229|       |#define GRPC_ARG_KEEPALIVE_PERMIT_WITHOUT_CALLS \
  230|       |  "grpc.keepalive_permit_without_calls"
  231|       |/** Default authority to pass if none specified on call construction. A string.
  232|       | * */
  233|       |#define GRPC_ARG_DEFAULT_AUTHORITY "grpc.default_authority"
  234|       |/** Primary user agent: goes at the start of the user-agent metadata
  235|       |    sent on each request. A string. */
  236|      0|#define GRPC_ARG_PRIMARY_USER_AGENT_STRING "grpc.primary_user_agent"
  237|       |/** Secondary user agent: goes at the end of the user-agent metadata
  238|       |    sent on each request. A string. */
  239|       |#define GRPC_ARG_SECONDARY_USER_AGENT_STRING "grpc.secondary_user_agent"
  240|       |/** The minimum time between subsequent connection attempts, in ms */
  241|       |#define GRPC_ARG_MIN_RECONNECT_BACKOFF_MS "grpc.min_reconnect_backoff_ms"
  242|       |/** The maximum time between subsequent connection attempts, in ms */
  243|       |#define GRPC_ARG_MAX_RECONNECT_BACKOFF_MS "grpc.max_reconnect_backoff_ms"
  244|       |/** The time between the first and second connection attempts, in ms */
  245|       |#define GRPC_ARG_INITIAL_RECONNECT_BACKOFF_MS \
  246|       |  "grpc.initial_reconnect_backoff_ms"
  247|       |/** Minimum amount of time between DNS resolutions, in ms */
  248|       |#define GRPC_ARG_DNS_MIN_TIME_BETWEEN_RESOLUTIONS_MS \
  249|       |  "grpc.dns_min_time_between_resolutions_ms"
  250|       |/** The timeout used on servers for finishing handshaking on an incoming
  251|       |    connection.  Defaults to 120 seconds. */
  252|       |#define GRPC_ARG_SERVER_HANDSHAKE_TIMEOUT_MS "grpc.server_handshake_timeout_ms"
  253|       |/** This *should* be used for testing only.
  254|       |    The caller of the secure_channel_create functions may override the target
  255|       |    name used for SSL host name checking using this channel argument which is of
  256|       |    type \a GRPC_ARG_STRING. If this argument is not specified, the name used
  257|       |    for SSL host name checking will be the target parameter (assuming that the
  258|       |    secure channel is an SSL channel). If this parameter is specified and the
  259|       |    underlying is not an SSL channel, it will just be ignored. */
  260|      0|#define GRPC_SSL_TARGET_NAME_OVERRIDE_ARG "grpc.ssl_target_name_override"
  261|       |/** If non-zero, a pointer to a session cache (a pointer of type
  262|       |    grpc_ssl_session_cache*). (use grpc_ssl_session_cache_arg_vtable() to fetch
  263|       |    an appropriate pointer arg vtable) */
  264|       |#define GRPC_SSL_SESSION_CACHE_ARG "grpc.ssl_session_cache"
  265|       |/** Maximum metadata size, in bytes. Note this limit applies to the max sum of
  266|       |    all metadata key-value entries in a batch of headers. */
  267|       |#define GRPC_ARG_MAX_METADATA_SIZE "grpc.max_metadata_size"
  268|       |/** If non-zero, allow the use of SO_REUSEPORT if it's available (default 1) */
  269|       |#define GRPC_ARG_ALLOW_REUSEPORT "grpc.so_reuseport"
  270|       |/** If non-zero, a pointer to a buffer pool (a pointer of type
  271|       | * grpc_resource_quota*). (use grpc_resource_quota_arg_vtable() to fetch an
  272|       | * appropriate pointer arg vtable) */
  273|      0|#define GRPC_ARG_RESOURCE_QUOTA "grpc.resource_quota"
  274|       |/** If non-zero, expand wildcard addresses to a list of local addresses. */
  275|       |#define GRPC_ARG_EXPAND_WILDCARD_ADDRS "grpc.expand_wildcard_addrs"
  276|       |/** Service config data in JSON form.
  277|       |    This value will be ignored if the name resolver returns a service config. */
  278|      0|#define GRPC_ARG_SERVICE_CONFIG "grpc.service_config"
  279|       |/** Disable looking up the service config via the name resolver. */
  280|       |#define GRPC_ARG_SERVICE_CONFIG_DISABLE_RESOLUTION \
  281|       |  "grpc.service_config_disable_resolution"
  282|       |/** LB policy name. */
  283|      0|#define GRPC_ARG_LB_POLICY_NAME "grpc.lb_policy_name"
  284|       |/** The grpc_socket_mutator instance that set the socket options. A pointer. */
  285|       |#define GRPC_ARG_SOCKET_MUTATOR "grpc.socket_mutator"
  286|       |/** The grpc_socket_factory instance to create and bind sockets. A pointer. */
  287|       |#define GRPC_ARG_SOCKET_FACTORY "grpc.socket_factory"
  288|       |/** The maximum amount of memory used by trace events per channel trace node.
  289|       | * Once the maximum is reached, subsequent events will evict the oldest events
  290|       | * from the buffer. The unit for this knob is bytes. Setting it to zero causes
  291|       | * channel tracing to be disabled. */
  292|       |#define GRPC_ARG_MAX_CHANNEL_TRACE_EVENT_MEMORY_PER_NODE \
  293|       |  "grpc.max_channel_trace_event_memory_per_node"
  294|       |/** If non-zero, gRPC library will track stats and information at at per channel
  295|       | * level. Disabling channelz naturally disables channel tracing. The default
  296|       | * is for channelz to be enabled. */
  297|       |#define GRPC_ARG_ENABLE_CHANNELZ "grpc.enable_channelz"
  298|       |/** If non-zero, Cronet transport will coalesce packets to fewer frames
  299|       | * when possible. */
  300|       |#define GRPC_ARG_USE_CRONET_PACKET_COALESCING \
  301|       |  "grpc.use_cronet_packet_coalescing"
  302|       |/** Channel arg (integer) setting how large a slice to try and read from the
  303|       |   wire each time recvmsg (or equivalent) is called **/
  304|       |#define GRPC_ARG_TCP_READ_CHUNK_SIZE "grpc.experimental.tcp_read_chunk_size"
  305|       |/** Note this is not a "channel arg" key. This is the default slice size to use
  306|       | * when trying to read from the wire if the GRPC_ARG_TCP_READ_CHUNK_SIZE
  307|       | * channel arg is unspecified. */
  308|       |#define GRPC_TCP_DEFAULT_READ_SLICE_SIZE 8192
  309|       |#define GRPC_ARG_TCP_MIN_READ_CHUNK_SIZE \
  310|       |  "grpc.experimental.tcp_min_read_chunk_size"
  311|       |#define GRPC_ARG_TCP_MAX_READ_CHUNK_SIZE \
  312|       |  "grpc.experimental.tcp_max_read_chunk_size"
  313|       |/* Timeout in milliseconds to use for calls to the grpclb load balancer.
  314|       |   If 0 or unset, the balancer calls will have no deadline. */
  315|       |#define GRPC_ARG_GRPCLB_CALL_TIMEOUT_MS "grpc.grpclb_call_timeout_ms"
  316|       |/* Timeout in milliseconds to wait for the serverlist from the grpclb load
  317|       |   balancer before using fallback backend addresses from the resolver.
  318|       |   If 0, enter fallback mode immediately. Default value is 10000. */
  319|      0|#define GRPC_ARG_GRPCLB_FALLBACK_TIMEOUT_MS "grpc.grpclb_fallback_timeout_ms"
  320|       |/* Timeout in milliseconds to wait for the serverlist from the xDS load
  321|       |   balancer before using fallback backend addresses from the resolver.
  322|       |   If 0, enter fallback mode immediately. Default value is 10000. */
  323|       |#define GRPC_ARG_XDS_FALLBACK_TIMEOUT_MS "grpc.xds_fallback_timeout_ms"
  324|       |/** If non-zero, grpc server's cronet compression workaround will be enabled */
  325|       |#define GRPC_ARG_WORKAROUND_CRONET_COMPRESSION \
  326|      0|  "grpc.workaround.cronet_compression"
  327|       |/** String defining the optimization target for a channel.
  328|       |    Can be: "latency"    - attempt to minimize latency at the cost of throughput
  329|       |            "blend"      - try to balance latency and throughput
  330|       |            "throughput" - attempt to maximize throughput at the expense of
  331|       |                           latency
  332|       |    Defaults to "blend". In the current implementation "blend" is equivalent to
  333|       |    "latency". */
  334|       |#define GRPC_ARG_OPTIMIZATION_TARGET "grpc.optimization_target"
  335|       |/** If set to zero, disables retry behavior. Otherwise, transparent retries
  336|       |    are enabled for all RPCs, and configurable retries are enabled when they
  337|       |    are configured via the service config. For details, see:
  338|       |      https://github.com/grpc/proposal/blob/master/A6-client-retries.md
  339|       | */
  340|       |#define GRPC_ARG_ENABLE_RETRIES "grpc.enable_retries"
  341|       |/** Per-RPC retry buffer size, in bytes. Default is 256 KiB. */
  342|       |#define GRPC_ARG_PER_RPC_RETRY_BUFFER_SIZE "grpc.per_rpc_retry_buffer_size"
  343|       |/** Channel arg that carries the bridged objective c object for custom metrics
  344|       | * logging filter. */
  345|       |#define GRPC_ARG_MOBILE_LOG_CONTEXT "grpc.mobile_log_context"
  346|       |/** If non-zero, client authority filter is disabled for the channel */
  347|       |#define GRPC_ARG_DISABLE_CLIENT_AUTHORITY_FILTER \
  348|       |  "grpc.disable_client_authority_filter"
  349|       |/** If set to zero, disables use of http proxies. Enabled by default. */
  350|       |#define GRPC_ARG_ENABLE_HTTP_PROXY "grpc.enable_http_proxy"
  351|       |/** If set to non zero, surfaces the user agent string to the server. User
  352|       |    agent is surfaced by default. */
  353|       |#define GRPC_ARG_SURFACE_USER_AGENT "grpc.surface_user_agent"
  354|       |/** If set, inhibits health checking (which may be enabled via the
  355|       | *  service config.) */
  356|       |#define GRPC_ARG_INHIBIT_HEALTH_CHECKING "grpc.inhibit_health_checking"
  357|       |/** If set, the channel's resolver is allowed to query for SRV records.
  358|       | * For example, this is useful as a way to enable the "grpclb"
  359|       | * load balancing policy. Note that this only works with the "ares"
  360|       | * DNS resolver, and isn't supported by the "native" DNS resolver. */
  361|       |#define GRPC_ARG_DNS_ENABLE_SRV_QUERIES "grpc.dns_enable_srv_queries"
  362|       |/** If set, determines an upper bound on the number of milliseconds that the
  363|       | * c-ares based DNS resolver will wait on queries before cancelling them.
  364|       | * The default value is 120,000. Setting this to "0" will disable the
  365|       | * overall timeout entirely. Note that this doesn't include internal c-ares
  366|       | * timeouts/backoff/retry logic, and so the actual DNS resolution may time out
  367|       | * sooner than the value specified here. */
  368|       |#define GRPC_ARG_DNS_ARES_QUERY_TIMEOUT_MS "grpc.dns_ares_query_timeout"
  369|       |/** If set, uses a local subchannel pool within the channel. Otherwise, uses the
  370|       | * global subchannel pool. */
  371|       |#define GRPC_ARG_USE_LOCAL_SUBCHANNEL_POOL "grpc.use_local_subchannel_pool"
  372|       |/** gRPC Objective-C channel pooling domain string. */
  373|       |#define GRPC_ARG_CHANNEL_POOL_DOMAIN "grpc.channel_pooling_domain"
  374|       |/** gRPC Objective-C channel pooling id. */
  375|       |#define GRPC_ARG_CHANNEL_ID "grpc.channel_id"
  376|       |/** \} */
  377|       |
  378|       |/** Result of a grpc call. If the caller satisfies the prerequisites of a
  379|       |    particular operation, the grpc_call_error returned will be GRPC_CALL_OK.
  380|       |    Receiving any other value listed here is an indication of a bug in the
  381|       |    caller. */
  382|       |typedef enum grpc_call_error {
  383|       |  /** everything went ok */
  384|       |  GRPC_CALL_OK = 0,
  385|       |  /** something failed, we don't know what */
  386|       |  GRPC_CALL_ERROR,
  387|       |  /** this method is not available on the server */
  388|       |  GRPC_CALL_ERROR_NOT_ON_SERVER,
  389|       |  /** this method is not available on the client */
  390|       |  GRPC_CALL_ERROR_NOT_ON_CLIENT,
  391|       |  /** this method must be called before server_accept */
  392|       |  GRPC_CALL_ERROR_ALREADY_ACCEPTED,
  393|       |  /** this method must be called before invoke */
  394|       |  GRPC_CALL_ERROR_ALREADY_INVOKED,
  395|       |  /** this method must be called after invoke */
  396|       |  GRPC_CALL_ERROR_NOT_INVOKED,
  397|       |  /** this call is already finished
  398|       |      (writes_done or write_status has already been called) */
  399|       |  GRPC_CALL_ERROR_ALREADY_FINISHED,
  400|       |  /** there is already an outstanding read/write operation on the call */
  401|       |  GRPC_CALL_ERROR_TOO_MANY_OPERATIONS,
  402|       |  /** the flags value was illegal for this call */
  403|       |  GRPC_CALL_ERROR_INVALID_FLAGS,
  404|       |  /** invalid metadata was passed to this call */
  405|       |  GRPC_CALL_ERROR_INVALID_METADATA,
  406|       |  /** invalid message was passed to this call */
  407|       |  GRPC_CALL_ERROR_INVALID_MESSAGE,
  408|       |  /** completion queue for notification has not been registered
  409|       |   * with the server */
  410|       |  GRPC_CALL_ERROR_NOT_SERVER_COMPLETION_QUEUE,
  411|       |  /** this batch of operations leads to more operations than allowed */
  412|       |  GRPC_CALL_ERROR_BATCH_TOO_BIG,
  413|       |  /** payload type requested is not the type registered */
  414|       |  GRPC_CALL_ERROR_PAYLOAD_TYPE_MISMATCH,
  415|       |  /** completion queue has been shutdown */
  416|       |  GRPC_CALL_ERROR_COMPLETION_QUEUE_SHUTDOWN
  417|       |} grpc_call_error;
  418|       |
  419|       |/** Default send/receive message size limits in bytes. -1 for unlimited. */
  420|       |/** TODO(roth) Make this match the default receive limit after next release */
  421|       |#define GRPC_DEFAULT_MAX_SEND_MESSAGE_LENGTH -1
  422|       |#define GRPC_DEFAULT_MAX_RECV_MESSAGE_LENGTH (4 * 1024 * 1024)
  423|       |
  424|       |/** Write Flags: */
  425|       |/** Hint that the write may be buffered and need not go out on the wire
  426|       |    immediately. GRPC is free to buffer the message until the next non-buffered
  427|       |    write, or until writes_done, but it need not buffer completely or at all. */
  428|      0|#define GRPC_WRITE_BUFFER_HINT (0x00000001u)
  429|       |/** Force compression to be disabled for a particular write
  430|       |    (start_write/add_metadata). Illegal on invoke/accept. */
  431|       |#define GRPC_WRITE_NO_COMPRESS (0x00000002u)
  432|       |/** Force this message to be written to the socket before completing it */
  433|       |#define GRPC_WRITE_THROUGH (0x00000004u)
  434|       |/** Mask of all valid flags. */
  435|       |#define GRPC_WRITE_USED_MASK \
  436|       |  (GRPC_WRITE_BUFFER_HINT | GRPC_WRITE_NO_COMPRESS | GRPC_WRITE_THROUGH)
  437|       |
  438|       |/** Initial metadata flags */
  439|       |/** Signal that the call is idempotent */
  440|      0|#define GRPC_INITIAL_METADATA_IDEMPOTENT_REQUEST (0x00000010u)
  441|       |/** Signal that the call should not return UNAVAILABLE before it has started */
  442|      0|#define GRPC_INITIAL_METADATA_WAIT_FOR_READY (0x00000020u)
  443|       |/** Signal that the call is cacheable. GRPC is free to use GET verb */
  444|      0|#define GRPC_INITIAL_METADATA_CACHEABLE_REQUEST (0x00000040u)
  445|       |/** Signal that GRPC_INITIAL_METADATA_WAIT_FOR_READY was explicitly set
  446|       |    by the calling application. */
  447|      0|#define GRPC_INITIAL_METADATA_WAIT_FOR_READY_EXPLICITLY_SET (0x00000080u)
  448|       |/** Signal that the initial metadata should be corked */
  449|      0|#define GRPC_INITIAL_METADATA_CORKED (0x00000100u)
  450|       |
  451|       |/** Mask of all valid flags */
  452|       |#define GRPC_INITIAL_METADATA_USED_MASK                  \
  453|       |  (GRPC_INITIAL_METADATA_IDEMPOTENT_REQUEST |            \
  454|       |   GRPC_INITIAL_METADATA_WAIT_FOR_READY |                \
  455|       |   GRPC_INITIAL_METADATA_CACHEABLE_REQUEST |             \
  456|       |   GRPC_INITIAL_METADATA_WAIT_FOR_READY_EXPLICITLY_SET | \
  457|       |   GRPC_INITIAL_METADATA_CORKED | GRPC_WRITE_THROUGH)
  458|       |
  459|       |/** A single metadata element */
  460|       |typedef struct grpc_metadata {
  461|       |  /** the key, value values are expected to line up with grpc_mdelem: if
  462|       |     changing them, update metadata.h at the same time. */
  463|       |  grpc_slice key;
  464|       |  grpc_slice value;
  465|       |
  466|       |  uint32_t flags;
  467|       |
  468|       |  /** The following fields are reserved for grpc internal use.
  469|       |      There is no need to initialize them, and they will be set to garbage
  470|       |      during calls to grpc. */
  471|       |  struct /* internal */ {
  472|       |    void* obfuscated[4];
  473|       |  } internal_data;
  474|       |} grpc_metadata;
  475|       |
  476|       |/** The type of completion (for grpc_event) */
  477|       |typedef enum grpc_completion_type {
  478|       |  /** Shutting down */
  479|       |  GRPC_QUEUE_SHUTDOWN,
  480|       |  /** No event before timeout */
  481|       |  GRPC_QUEUE_TIMEOUT,
  482|       |  /** Operation completion */
  483|       |  GRPC_OP_COMPLETE
  484|       |} grpc_completion_type;
  485|       |
  486|       |/** The result of an operation.
  487|       |
  488|       |    Returned by a completion queue when the operation started with tag. */
  489|       |typedef struct grpc_event {
  490|       |  /** The type of the completion. */
  491|       |  grpc_completion_type type;
  492|       |  /** If the grpc_completion_type is GRPC_OP_COMPLETE, this field indicates
  493|       |      whether the operation was successful or not; 0 in case of failure and
  494|       |      non-zero in case of success.
  495|       |      If grpc_completion_type is GRPC_QUEUE_SHUTDOWN or GRPC_QUEUE_TIMEOUT, this
  496|       |      field is guaranteed to be 0 */
  497|       |  int success;
  498|       |  /** The tag passed to grpc_call_start_batch etc to start this operation.
  499|       |      *Only* GRPC_OP_COMPLETE has a tag. For all other grpc_completion_type
  500|       |      values, tag is uninitialized. */
  501|       |  void* tag;
  502|       |} grpc_event;
  503|       |
  504|       |typedef struct {
  505|       |  size_t count;
  506|       |  size_t capacity;
  507|       |  grpc_metadata* metadata;
  508|       |} grpc_metadata_array;
  509|       |
  510|       |typedef struct {
  511|       |  grpc_slice method;
  512|       |  grpc_slice host;
  513|       |  gpr_timespec deadline;
  514|       |  uint32_t flags;
  515|       |  void* reserved;
  516|       |} grpc_call_details;
  517|       |
  518|       |typedef enum {
  519|       |  /** Send initial metadata: one and only one instance MUST be sent for each
  520|       |      call, unless the call was cancelled - in which case this can be skipped.
  521|       |      This op completes after all bytes of metadata have been accepted by
  522|       |      outgoing flow control. */
  523|       |  GRPC_OP_SEND_INITIAL_METADATA = 0,
  524|       |  /** Send a message: 0 or more of these operations can occur for each call.
  525|       |      This op completes after all bytes for the message have been accepted by
  526|       |      outgoing flow control. */
  527|       |  GRPC_OP_SEND_MESSAGE,
  528|       |  /** Send a close from the client: one and only one instance MUST be sent from
  529|       |      the client, unless the call was cancelled - in which case this can be
  530|       |      skipped. This op completes after all bytes for the call
  531|       |      (including the close) have passed outgoing flow control. */
  532|       |  GRPC_OP_SEND_CLOSE_FROM_CLIENT,
  533|       |  /** Send status from the server: one and only one instance MUST be sent from
  534|       |      the server unless the call was cancelled - in which case this can be
  535|       |      skipped. This op completes after all bytes for the call
  536|       |      (including the status) have passed outgoing flow control. */
  537|       |  GRPC_OP_SEND_STATUS_FROM_SERVER,
  538|       |  /** Receive initial metadata: one and only one MUST be made on the client,
  539|       |      must not be made on the server.
  540|       |      This op completes after all initial metadata has been read from the
  541|       |      peer. */
  542|       |  GRPC_OP_RECV_INITIAL_METADATA,
  543|       |  /** Receive a message: 0 or more of these operations can occur for each call.
  544|       |      This op completes after all bytes of the received message have been
  545|       |      read, or after a half-close has been received on this call. */
  546|       |  GRPC_OP_RECV_MESSAGE,
  547|       |  /** Receive status on the client: one and only one must be made on the client.
  548|       |      This operation always succeeds, meaning ops paired with this operation
  549|       |      will also appear to succeed, even though they may not have. In that case
  550|       |      the status will indicate some failure.
  551|       |      This op completes after all activity on the call has completed. */
  552|       |  GRPC_OP_RECV_STATUS_ON_CLIENT,
  553|       |  /** Receive close on the server: one and only one must be made on the
  554|       |      server. This op completes after the close has been received by the
  555|       |      server. This operation always succeeds, meaning ops paired with
  556|       |      this operation will also appear to succeed, even though they may not
  557|       |      have. */
  558|       |  GRPC_OP_RECV_CLOSE_ON_SERVER
  559|       |} grpc_op_type;
  560|       |
  561|       |struct grpc_byte_buffer;
  562|       |
  563|       |/** Operation data: one field for each op type (except SEND_CLOSE_FROM_CLIENT
  564|       |   which has no arguments) */
  565|       |typedef struct grpc_op {
  566|       |  /** Operation type, as defined by grpc_op_type */
  567|       |  grpc_op_type op;
  568|       |  /** Write flags bitset for grpc_begin_messages */
  569|       |  uint32_t flags;
  570|       |  /** Reserved for future usage */
  571|       |  void* reserved;
  572|       |  union grpc_op_data {
  573|       |    /** Reserved for future usage */
  574|       |    struct /* internal */ {
  575|       |      void* reserved[8];
  576|       |    } reserved;
  577|       |    struct grpc_op_send_initial_metadata {
  578|       |      size_t count;
  579|       |      grpc_metadata* metadata;
  580|       |      /** If \a is_set, \a compression_level will be used for the call.
  581|       |       * Otherwise, \a compression_level won't be considered */
  582|       |      struct grpc_op_send_initial_metadata_maybe_compression_level {
  583|       |        uint8_t is_set;
  584|       |        grpc_compression_level level;
  585|       |      } maybe_compression_level;
  586|       |    } send_initial_metadata;
  587|       |    struct grpc_op_send_message {
  588|       |      /** This op takes ownership of the slices in send_message.  After
  589|       |       * a call completes, the contents of send_message are not guaranteed
  590|       |       * and likely empty.  The original owner should still call
  591|       |       * grpc_byte_buffer_destroy() on this object however.
  592|       |       */
  593|       |      struct grpc_byte_buffer* send_message;
  594|       |    } send_message;
  595|       |    struct grpc_op_send_status_from_server {
  596|       |      size_t trailing_metadata_count;
  597|       |      grpc_metadata* trailing_metadata;
  598|       |      grpc_status_code status;
  599|       |      /** optional: set to NULL if no details need sending, non-NULL if they do
  600|       |       * pointer will not be retained past the start_batch call
  601|       |       */
  602|       |      grpc_slice* status_details;
  603|       |    } send_status_from_server;
  604|       |    /** ownership of the array is with the caller, but ownership of the elements
  605|       |        stays with the call object (ie key, value members are owned by the call
  606|       |        object, recv_initial_metadata->array is owned by the caller).
  607|       |        After the operation completes, call grpc_metadata_array_destroy on this
  608|       |        value, or reuse it in a future op. */
  609|       |    struct grpc_op_recv_initial_metadata {
  610|       |      grpc_metadata_array* recv_initial_metadata;
  611|       |    } recv_initial_metadata;
  612|       |    /** ownership of the byte buffer is moved to the caller; the caller must
  613|       |        call grpc_byte_buffer_destroy on this value, or reuse it in a future op.
  614|       |        The returned byte buffer will be NULL if trailing metadata was
  615|       |        received instead of a message.
  616|       |       */
  617|       |    struct grpc_op_recv_message {
  618|       |      struct grpc_byte_buffer** recv_message;
  619|       |    } recv_message;
  620|       |    struct grpc_op_recv_status_on_client {
  621|       |      /** ownership of the array is with the caller, but ownership of the
  622|       |          elements stays with the call object (ie key, value members are owned
  623|       |          by the call object, trailing_metadata->array is owned by the caller).
  624|       |          After the operation completes, call grpc_metadata_array_destroy on
  625|       |          this value, or reuse it in a future op. */
  626|       |      grpc_metadata_array* trailing_metadata;
  627|       |      grpc_status_code* status;
  628|       |      grpc_slice* status_details;
  629|       |      /** If this is not nullptr, it will be populated with the full fidelity
  630|       |       * error string for debugging purposes. The application is responsible
  631|       |       * for freeing the data by using gpr_free(). */
  632|       |      const char** error_string;
  633|       |    } recv_status_on_client;
  634|       |    struct grpc_op_recv_close_on_server {
  635|       |      /** out argument, set to 1 if the call failed in any way (seen as a
  636|       |          cancellation on the server), or 0 if the call succeeded */
  637|       |      int* cancelled;
  638|       |    } recv_close_on_server;
  639|       |  } data;
  640|       |} grpc_op;
  641|       |
  642|       |/** Information requested from the channel. */
  643|       |typedef struct {
  644|       |  /** If non-NULL, will be set to point to a string indicating the LB
  645|       |   * policy name.  Caller takes ownership. */
  646|       |  char** lb_policy_name;
  647|       |  /** If non-NULL, will be set to point to a string containing the
  648|       |   * service config used by the channel in JSON form. */
  649|       |  char** service_config_json;
  650|       |} grpc_channel_info;
  651|       |
  652|       |typedef struct grpc_resource_quota grpc_resource_quota;
  653|       |
  654|       |/** Completion queues internally MAY maintain a set of file descriptors in a
  655|       |    structure called 'pollset'. This enum specifies if a completion queue has an
  656|       |    associated pollset and any restrictions on the type of file descriptors that
  657|       |    can be present in the pollset.
  658|       |
  659|       |    I/O progress can only be made when grpc_completion_queue_next() or
  660|       |    grpc_completion_queue_pluck() are called on the completion queue (unless the
  661|       |    grpc_cq_polling_type is GRPC_CQ_NON_POLLING) and hence it is very important
  662|       |    to actively call these APIs */
  663|       |typedef enum {
  664|       |  /** The completion queue will have an associated pollset and there is no
  665|       |      restriction on the type of file descriptors the pollset may contain */
  666|       |  GRPC_CQ_DEFAULT_POLLING,
  667|       |
  668|       |  /** Similar to GRPC_CQ_DEFAULT_POLLING except that the completion queues will
  669|       |      not contain any 'listening file descriptors' (i.e file descriptors used to
  670|       |      listen to incoming channels) */
  671|       |  GRPC_CQ_NON_LISTENING,
  672|       |
  673|       |  /** The completion queue will not have an associated pollset. Note that
  674|       |      grpc_completion_queue_next() or grpc_completion_queue_pluck() MUST still
  675|       |      be called to pop events from the completion queue; it is not required to
  676|       |      call them actively to make I/O progress */
  677|       |  GRPC_CQ_NON_POLLING
  678|       |} grpc_cq_polling_type;
  679|       |
  680|       |/** Specifies the type of APIs to use to pop events from the completion queue */
  681|       |typedef enum {
  682|       |  /** Events are popped out by calling grpc_completion_queue_next() API ONLY */
  683|       |  GRPC_CQ_NEXT,
  684|       |
  685|       |  /** Events are popped out by calling grpc_completion_queue_pluck() API ONLY*/
  686|       |  GRPC_CQ_PLUCK,
  687|       |
  688|       |  /** EXPERIMENTAL: Events trigger a callback specified as the tag */
  689|       |  GRPC_CQ_CALLBACK
  690|       |} grpc_cq_completion_type;
  691|       |
  692|       |/** EXPERIMENTAL: Specifies an interface class to be used as a tag
  693|       |    for callback-based completion queues. This can be used directly,
  694|       |    as the first element of a struct in C, or as a base class in C++.
  695|       |    Its "run" value should be assigned to some non-member function, such as
  696|       |    a static method. */
  697|       |typedef struct grpc_experimental_completion_queue_functor {
  698|       |  /** The run member specifies a function that will be called when this
  699|       |      tag is extracted from the completion queue. Its arguments will be a
  700|       |      pointer to this functor and a boolean that indicates whether the
  701|       |      operation succeeded (non-zero) or failed (zero) */
  702|       |  void (*functor_run)(struct grpc_experimental_completion_queue_functor*, int);
  703|       |
  704|       |  /** The following fields are not API. They are meant for internal use. */
  705|       |  int internal_success;
  706|       |  struct grpc_experimental_completion_queue_functor* internal_next;
  707|       |} grpc_experimental_completion_queue_functor;
  708|       |
  709|       |/* The upgrade to version 2 is currently experimental. */
  710|       |
  711|      0|#define GRPC_CQ_CURRENT_VERSION 2
  712|       |#define GRPC_CQ_VERSION_MINIMUM_FOR_CALLBACKABLE 2
  713|       |typedef struct grpc_completion_queue_attributes {
  714|       |  /** The version number of this structure. More fields might be added to this
  715|       |     structure in future. */
  716|       |  int version; /** Set to GRPC_CQ_CURRENT_VERSION */
  717|       |
  718|       |  grpc_cq_completion_type cq_completion_type;
  719|       |
  720|       |  grpc_cq_polling_type cq_polling_type;
  721|       |
  722|       |  /* END OF VERSION 1 CQ ATTRIBUTES */
  723|       |
  724|       |  /* EXPERIMENTAL: START OF VERSION 2 CQ ATTRIBUTES */
  725|       |  /** When creating a callbackable CQ, pass in a functor to get invoked when
  726|       |   * shutdown is complete */
  727|       |  grpc_experimental_completion_queue_functor* cq_shutdown_cb;
  728|       |
  729|       |  /* END OF VERSION 2 CQ ATTRIBUTES */
  730|       |} grpc_completion_queue_attributes;
  731|       |
  732|       |/** The completion queue factory structure is opaque to the callers of grpc */
  733|       |typedef struct grpc_completion_queue_factory grpc_completion_queue_factory;
  734|       |
  735|       |#ifdef __cplusplus
  736|       |}
  737|       |#endif
  738|       |
  739|       |#endif /* GRPC_IMPL_CODEGEN_GRPC_TYPES_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpc/impl/codegen/log.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_IMPL_CODEGEN_LOG_H
   20|       |#define GRPC_IMPL_CODEGEN_LOG_H
   21|       |
   22|       |#include <grpc/impl/codegen/port_platform.h>
   23|       |
   24|       |#include <stdarg.h>
   25|       |#include <stdlib.h> /* for abort() */
   26|       |
   27|       |#ifdef __cplusplus
   28|       |extern "C" {
   29|       |#endif
   30|       |
   31|       |/** GPR log API.
   32|       |
   33|       |   Usage (within grpc):
   34|       |
   35|       |   int argument1 = 3;
   36|       |   char* argument2 = "hello";
   37|       |   gpr_log(GPR_DEBUG, "format string %d", argument1);
   38|       |   gpr_log(GPR_INFO, "hello world");
   39|       |   gpr_log(GPR_ERROR, "%d %s!!", argument1, argument2); */
   40|       |
   41|       |/** The severity of a log message - use the #defines below when calling into
   42|       |   gpr_log to additionally supply file and line data */
   43|       |typedef enum gpr_log_severity {
   44|       |  GPR_LOG_SEVERITY_DEBUG,
   45|       |  GPR_LOG_SEVERITY_INFO,
   46|       |  GPR_LOG_SEVERITY_ERROR
   47|       |} gpr_log_severity;
   48|       |
   49|       |#define GPR_LOG_VERBOSITY_UNSET -1
   50|       |
   51|       |/** Returns a string representation of the log severity */
   52|       |GPRAPI const char* gpr_log_severity_string(gpr_log_severity severity);
   53|       |
   54|       |/** Macros to build log contexts at various severity levels */
   55|      0|#define GPR_DEBUG __FILE__, __LINE__, GPR_LOG_SEVERITY_DEBUG
   56|      0|#define GPR_INFO __FILE__, __LINE__, GPR_LOG_SEVERITY_INFO
   57|      0|#define GPR_ERROR __FILE__, __LINE__, GPR_LOG_SEVERITY_ERROR
   58|       |
   59|       |/** Log a message. It's advised to use GPR_xxx above to generate the context
   60|       | * for each message */
   61|       |GPRAPI void gpr_log(const char* file, int line, gpr_log_severity severity,
   62|       |                    const char* format, ...) GPR_PRINT_FORMAT_CHECK(4, 5);
   63|       |
   64|       |GPRAPI int gpr_should_log(gpr_log_severity severity);
   65|       |
   66|       |GPRAPI void gpr_log_message(const char* file, int line,
   67|       |                            gpr_log_severity severity, const char* message);
   68|       |
   69|       |/** Set global log verbosity */
   70|       |GPRAPI void gpr_set_log_verbosity(gpr_log_severity min_severity_to_print);
   71|       |
   72|       |GPRAPI void gpr_log_verbosity_init(void);
   73|       |
   74|       |/** Log overrides: applications can use this API to intercept logging calls
   75|       |   and use their own implementations */
   76|       |
   77|       |struct gpr_log_func_args {
   78|       |  const char* file;
   79|       |  int line;
   80|       |  gpr_log_severity severity;
   81|       |  const char* message;
   82|       |};
   83|       |
   84|       |typedef struct gpr_log_func_args gpr_log_func_args;
   85|       |
   86|       |typedef void (*gpr_log_func)(gpr_log_func_args* args);
   87|       |GPRAPI void gpr_set_log_function(gpr_log_func func);
   88|       |
   89|       |/** abort() the process if x is zero, having written a line to the log.
   90|       |
   91|       |   Intended for internal invariants.  If the error can be recovered from,
   92|       |   without the possibility of corruption, or might best be reflected via
   93|       |   an exception in a higher-level language, consider returning error code.  */
   94|       |#define GPR_ASSERT(x)                                 \
   95|      1|  do {                                                \
   96|      1|    if (GPR_UNLIKELY(!(x))) {                         \
   97|      0|      gpr_log(GPR_ERROR, "assertion failed: %s", #x); \
   98|      0|      abort();                                        \
   99|      0|    }                                                 \
  100|      1|  } while (0)
  101|       |
  102|       |#ifndef NDEBUG
  103|      0|#define GPR_DEBUG_ASSERT(x) GPR_ASSERT(x)
  104|       |#else
  105|       |#define GPR_DEBUG_ASSERT(x)
  106|       |#endif
  107|       |
  108|       |#ifdef __cplusplus
  109|       |}
  110|       |#endif
  111|       |
  112|       |#endif /* GRPC_IMPL_CODEGEN_LOG_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpc/impl/codegen/port_platform.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_IMPL_CODEGEN_PORT_PLATFORM_H
   20|       |#define GRPC_IMPL_CODEGEN_PORT_PLATFORM_H
   21|       |
   22|       |/*
   23|       | * Define GPR_BACKWARDS_COMPATIBILITY_MODE to try harder to be ABI
   24|       | * compatible with older platforms (currently only on Linux)
   25|       | * Causes:
   26|       | *  - some libc calls to be gotten via dlsym
   27|       | *  - some syscalls to be made directly
   28|       | */
   29|       |
   30|       |/* Get windows.h included everywhere (we need it) */
   31|       |#if defined(_WIN64) || defined(WIN64) || defined(_WIN32) || defined(WIN32)
   32|       |#ifndef WIN32_LEAN_AND_MEAN
   33|       |#define GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED
   34|       |#define WIN32_LEAN_AND_MEAN
   35|       |#endif /* WIN32_LEAN_AND_MEAN */
   36|       |
   37|       |#ifndef NOMINMAX
   38|       |#define GRPC_NOMINMX_WAS_NOT_DEFINED
   39|       |#define NOMINMAX
   40|       |#endif /* NOMINMAX */
   41|       |
   42|       |#ifndef _WIN32_WINNT
   43|       |#error \
   44|       |    "Please compile grpc with _WIN32_WINNT of at least 0x600 (aka Windows Vista)"
   45|       |#else /* !defined(_WIN32_WINNT) */
   46|       |#if (_WIN32_WINNT < 0x0600)
   47|       |#error \
   48|       |    "Please compile grpc with _WIN32_WINNT of at least 0x600 (aka Windows Vista)"
   49|       |#endif /* _WIN32_WINNT < 0x0600 */
   50|       |#endif /* defined(_WIN32_WINNT) */
   51|       |
   52|       |#include <windows.h>
   53|       |
   54|       |#ifdef GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED
   55|       |#undef GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED
   56|       |#undef WIN32_LEAN_AND_MEAN
   57|       |#endif /* GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED */
   58|       |
   59|       |#ifdef GRPC_NOMINMAX_WAS_NOT_DEFINED
   60|       |#undef GRPC_NOMINMAX_WAS_NOT_DEFINED
   61|       |#undef NOMINMAX
   62|       |#endif /* GRPC_WIN32_LEAN_AND_MEAN_WAS_NOT_DEFINED */
   63|       |#endif /* defined(_WIN64) || defined(WIN64) || defined(_WIN32) || \
   64|       |          defined(WIN32) */
   65|       |
   66|       |/* Override this file with one for your platform if you need to redefine
   67|       |   things.  */
   68|       |
   69|       |#if !defined(GPR_NO_AUTODETECT_PLATFORM)
   70|       |#if defined(_WIN64) || defined(WIN64) || defined(_WIN32) || defined(WIN32)
   71|       |#if defined(_WIN64) || defined(WIN64)
   72|       |#define GPR_ARCH_64 1
   73|       |#else
   74|       |#define GPR_ARCH_32 1
   75|       |#endif
   76|       |#define GPR_PLATFORM_STRING "windows"
   77|       |#define GPR_WINDOWS 1
   78|       |#define GPR_WINDOWS_SUBPROCESS 1
   79|       |#define GPR_WINDOWS_ENV
   80|       |#ifdef __MSYS__
   81|       |#define GPR_GETPID_IN_UNISTD_H 1
   82|       |#define GPR_MSYS_TMPFILE
   83|       |#define GPR_POSIX_LOG
   84|       |#define GPR_POSIX_STRING
   85|       |#define GPR_POSIX_TIME
   86|       |#else
   87|       |#define GPR_GETPID_IN_PROCESS_H 1
   88|       |#define GPR_WINDOWS_TMPFILE
   89|       |#define GPR_WINDOWS_LOG
   90|       |#define GPR_WINDOWS_CRASH_HANDLER 1
   91|       |#define GPR_WINDOWS_STRING
   92|       |#define GPR_WINDOWS_TIME
   93|       |#endif
   94|       |#ifdef __GNUC__
   95|       |#define GPR_GCC_ATOMIC 1
   96|       |#define GPR_GCC_TLS 1
   97|       |#else
   98|       |#define GPR_WINDOWS_ATOMIC 1
   99|       |#define GPR_MSVC_TLS 1
  100|       |#endif
  101|       |#elif defined(GPR_MANYLINUX1)
  102|       |// TODO(atash): manylinux1 is just another __linux__ but with ancient
  103|       |// libraries; it should be integrated with the `__linux__` definitions below.
  104|       |#define GPR_PLATFORM_STRING "manylinux"
  105|       |#define GPR_POSIX_CRASH_HANDLER 1
  106|       |#define GPR_CPU_POSIX 1
  107|       |#define GPR_GCC_ATOMIC 1
  108|       |#define GPR_GCC_TLS 1
  109|       |#define GPR_LINUX 1
  110|       |#define GPR_LINUX_LOG 1
  111|       |#define GPR_SUPPORT_CHANNELS_FROM_FD 1
  112|       |#define GPR_LINUX_ENV 1
  113|       |#define GPR_POSIX_TMPFILE 1
  114|       |#define GPR_POSIX_STRING 1
  115|       |#define GPR_POSIX_SUBPROCESS 1
  116|       |#define GPR_POSIX_SYNC 1
  117|       |#define GPR_POSIX_TIME 1
  118|       |#define GPR_HAS_PTHREAD_H 1
  119|       |#define GPR_GETPID_IN_UNISTD_H 1
  120|       |#ifdef _LP64
  121|       |#define GPR_ARCH_64 1
  122|       |#else /* _LP64 */
  123|       |#define GPR_ARCH_32 1
  124|       |#endif /* _LP64 */
  125|       |#include <linux/version.h>
  126|       |#elif defined(ANDROID) || defined(__ANDROID__)
  127|       |#define GPR_PLATFORM_STRING "android"
  128|       |#define GPR_ANDROID 1
  129|       |// TODO(apolcyn): re-evaluate support for c-ares
  130|       |// on android after upgrading our c-ares dependency.
  131|       |// See https://github.com/grpc/grpc/issues/18038.
  132|       |#define GRPC_ARES 0
  133|       |#ifdef _LP64
  134|       |#define GPR_ARCH_64 1
  135|       |#else /* _LP64 */
  136|       |#define GPR_ARCH_32 1
  137|       |#endif /* _LP64 */
  138|       |#define GPR_CPU_POSIX 1
  139|       |#define GPR_GCC_SYNC 1
  140|       |#define GPR_GCC_TLS 1
  141|       |#define GPR_POSIX_ENV 1
  142|       |#define GPR_POSIX_TMPFILE 1
  143|       |#define GPR_ANDROID_LOG 1
  144|       |#define GPR_POSIX_STRING 1
  145|       |#define GPR_POSIX_SUBPROCESS 1
  146|       |#define GPR_POSIX_SYNC 1
  147|       |#define GPR_POSIX_TIME 1
  148|       |#define GPR_HAS_PTHREAD_H 1
  149|       |#define GPR_GETPID_IN_UNISTD_H 1
  150|       |#define GPR_SUPPORT_CHANNELS_FROM_FD 1
  151|       |#elif defined(__linux__)
  152|       |#define GPR_PLATFORM_STRING "linux"
  153|       |#ifndef _BSD_SOURCE
  154|       |#define _BSD_SOURCE
  155|       |#endif
  156|       |#ifndef _DEFAULT_SOURCE
  157|       |#define _DEFAULT_SOURCE
  158|       |#endif
  159|       |#ifndef _GNU_SOURCE
  160|       |#define _GNU_SOURCE
  161|       |#endif
  162|       |#include <features.h>
  163|       |#define GPR_CPU_LINUX 1
  164|       |#define GPR_GCC_ATOMIC 1
  165|       |#define GPR_GCC_TLS 1
  166|       |#define GPR_LINUX 1
  167|       |#define GPR_LINUX_LOG
  168|       |#define GPR_SUPPORT_CHANNELS_FROM_FD 1
  169|       |#define GPR_LINUX_ENV 1
  170|       |#define GPR_POSIX_TMPFILE 1
  171|       |#define GPR_POSIX_STRING 1
  172|       |#define GPR_POSIX_SUBPROCESS 1
  173|       |#define GPR_POSIX_SYNC 1
  174|       |#define GPR_POSIX_TIME 1
  175|       |#define GPR_HAS_PTHREAD_H 1
  176|       |#define GPR_GETPID_IN_UNISTD_H 1
  177|       |#ifdef _LP64
  178|       |#define GPR_ARCH_64 1
  179|       |#else /* _LP64 */
  180|       |#define GPR_ARCH_32 1
  181|       |#endif /* _LP64 */
  182|       |#ifdef __GLIBC__
  183|       |#define GPR_POSIX_CRASH_HANDLER 1
  184|       |#define GPR_LINUX_PTHREAD_NAME 1
  185|       |#include <linux/version.h>
  186|       |#else /* musl libc */
  187|       |#define GPR_MUSL_LIBC_COMPAT 1
  188|       |#endif
  189|       |#elif defined(__APPLE__)
  190|       |#include <Availability.h>
  191|       |#include <TargetConditionals.h>
  192|       |#ifndef _BSD_SOURCE
  193|       |#define _BSD_SOURCE
  194|       |#endif
  195|       |#if TARGET_OS_IPHONE
  196|       |#define GPR_PLATFORM_STRING "ios"
  197|       |#define GPR_CPU_IPHONE 1
  198|       |#define GPR_PTHREAD_TLS 1
  199|       |#define GRPC_CFSTREAM 1
  200|       |/* the c-ares resolver isnt safe to enable on iOS */
  201|       |#define GRPC_ARES 0
  202|       |#else /* TARGET_OS_IPHONE */
  203|       |#define GPR_PLATFORM_STRING "osx"
  204|       |#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
  205|       |#if __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_7
  206|       |#define GPR_CPU_IPHONE 1
  207|       |#define GPR_PTHREAD_TLS 1
  208|       |#else /* __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_7 */
  209|       |#define GPR_CPU_POSIX 1
  210|       |/* TODO(vjpai): there is a reported issue in bazel build for Mac where __thread
  211|       |   in a header is currently not working (bazelbuild/bazel#4341). Remove
  212|       |   the following conditional and use GPR_GCC_TLS when that is fixed */
  213|       |#ifndef GRPC_BAZEL_BUILD
  214|       |#define GPR_GCC_TLS 1
  215|       |#else /* GRPC_BAZEL_BUILD */
  216|       |#define GPR_PTHREAD_TLS 1
  217|       |#endif /* GRPC_BAZEL_BUILD */
  218|       |#define GPR_APPLE_PTHREAD_NAME 1
  219|       |#endif
  220|       |#else /* __MAC_OS_X_VERSION_MIN_REQUIRED */
  221|       |#define GPR_CPU_POSIX 1
  222|       |/* TODO(vjpai): Remove the following conditional and use only GPR_GCC_TLS
  223|       |   when bazelbuild/bazel#4341 is fixed */
  224|       |#ifndef GRPC_BAZEL_BUILD
  225|       |#define GPR_GCC_TLS 1
  226|       |#else /* GRPC_BAZEL_BUILD */
  227|       |#define GPR_PTHREAD_TLS 1
  228|       |#endif /* GRPC_BAZEL_BUILD */
  229|       |#endif
  230|       |#define GPR_POSIX_CRASH_HANDLER 1
  231|       |#endif
  232|       |#define GPR_APPLE 1
  233|       |#define GPR_GCC_ATOMIC 1
  234|       |#define GPR_POSIX_LOG 1
  235|       |#define GPR_POSIX_ENV 1
  236|       |#define GPR_POSIX_TMPFILE 1
  237|       |#define GPR_POSIX_STRING 1
  238|       |#define GPR_POSIX_SUBPROCESS 1
  239|       |#define GPR_POSIX_SYNC 1
  240|       |#define GPR_POSIX_TIME 1
  241|       |#define GPR_HAS_PTHREAD_H 1
  242|       |#define GPR_GETPID_IN_UNISTD_H 1
  243|       |#ifndef GRPC_CFSTREAM
  244|       |#define GPR_SUPPORT_CHANNELS_FROM_FD 1
  245|       |#endif
  246|       |#ifdef _LP64
  247|       |#define GPR_ARCH_64 1
  248|       |#else /* _LP64 */
  249|       |#define GPR_ARCH_32 1
  250|       |#endif /* _LP64 */
  251|       |#elif defined(__FreeBSD__)
  252|       |#define GPR_PLATFORM_STRING "freebsd"
  253|       |#ifndef _BSD_SOURCE
  254|       |#define _BSD_SOURCE
  255|       |#endif
  256|       |#define GPR_FREEBSD 1
  257|       |#define GPR_CPU_POSIX 1
  258|       |#define GPR_GCC_ATOMIC 1
  259|       |#define GPR_GCC_TLS 1
  260|       |#define GPR_POSIX_LOG 1
  261|       |#define GPR_POSIX_ENV 1
  262|       |#define GPR_POSIX_TMPFILE 1
  263|       |#define GPR_POSIX_STRING 1
  264|       |#define GPR_POSIX_SUBPROCESS 1
  265|       |#define GPR_POSIX_SYNC 1
  266|       |#define GPR_POSIX_TIME 1
  267|       |#define GPR_HAS_PTHREAD_H 1
  268|       |#define GPR_GETPID_IN_UNISTD_H 1
  269|       |#define GPR_SUPPORT_CHANNELS_FROM_FD 1
  270|       |#ifdef _LP64
  271|       |#define GPR_ARCH_64 1
  272|       |#else /* _LP64 */
  273|       |#define GPR_ARCH_32 1
  274|       |#endif /* _LP64 */
  275|       |#elif defined(__OpenBSD__)
  276|       |#define GPR_PLATFORM_STRING "openbsd"
  277|       |#ifndef _BSD_SOURCE
  278|       |#define _BSD_SOURCE
  279|       |#endif
  280|       |#define GPR_OPENBSD 1
  281|       |#define GPR_CPU_POSIX 1
  282|       |#define GPR_GCC_ATOMIC 1
  283|       |#define GPR_GCC_TLS 1
  284|       |#define GPR_POSIX_LOG 1
  285|       |#define GPR_POSIX_ENV 1
  286|       |#define GPR_POSIX_TMPFILE 1
  287|       |#define GPR_POSIX_STRING 1
  288|       |#define GPR_POSIX_SUBPROCESS 1
  289|       |#define GPR_POSIX_SYNC 1
  290|       |#define GPR_POSIX_TIME 1
  291|       |#define GPR_HAS_PTHREAD_H 1
  292|       |#define GPR_GETPID_IN_UNISTD_H 1
  293|       |#define GPR_SUPPORT_CHANNELS_FROM_FD 1
  294|       |#ifdef _LP64
  295|       |#define GPR_ARCH_64 1
  296|       |#else /* _LP64 */
  297|       |#define GPR_ARCH_32 1
  298|       |#endif /* _LP64 */
  299|       |#elif defined(__sun) && defined(__SVR4)
  300|       |#define GPR_PLATFORM_STRING "solaris"
  301|       |#define GPR_SOLARIS 1
  302|       |#define GPR_CPU_POSIX 1
  303|       |#define GPR_GCC_ATOMIC 1
  304|       |#define GPR_GCC_TLS 1
  305|       |#define GPR_POSIX_LOG 1
  306|       |#define GPR_POSIX_ENV 1
  307|       |#define GPR_POSIX_TMPFILE 1
  308|       |#define GPR_POSIX_STRING 1
  309|       |#define GPR_POSIX_SUBPROCESS 1
  310|       |#define GPR_POSIX_SYNC 1
  311|       |#define GPR_POSIX_TIME 1
  312|       |#define GPR_HAS_PTHREAD_H 1
  313|       |#define GPR_GETPID_IN_UNISTD_H 1
  314|       |#ifdef _LP64
  315|       |#define GPR_ARCH_64 1
  316|       |#else /* _LP64 */
  317|       |#define GPR_ARCH_32 1
  318|       |#endif /* _LP64 */
  319|       |#elif defined(_AIX)
  320|       |#define GPR_PLATFORM_STRING "aix"
  321|       |#ifndef _ALL_SOURCE
  322|       |#define _ALL_SOURCE
  323|       |#endif
  324|       |#define GPR_AIX 1
  325|       |#define GPR_CPU_POSIX 1
  326|       |#define GPR_GCC_ATOMIC 1
  327|       |#define GPR_GCC_TLS 1
  328|       |#define GPR_POSIX_LOG 1
  329|       |#define GPR_POSIX_ENV 1
  330|       |#define GPR_POSIX_TMPFILE 1
  331|       |#define GPR_POSIX_STRING 1
  332|       |#define GPR_POSIX_SUBPROCESS 1
  333|       |#define GPR_POSIX_SYNC 1
  334|       |#define GPR_POSIX_TIME 1
  335|       |#define GPR_HAS_PTHREAD_H 1
  336|       |#define GPR_GETPID_IN_UNISTD_H 1
  337|       |#ifdef _LP64
  338|       |#define GPR_ARCH_64 1
  339|       |#else /* _LP64 */
  340|       |#define GPR_ARCH_32 1
  341|       |#endif /* _LP64 */
  342|       |#elif defined(__native_client__)
  343|       |#define GPR_PLATFORM_STRING "nacl"
  344|       |#ifndef _BSD_SOURCE
  345|       |#define _BSD_SOURCE
  346|       |#endif
  347|       |#ifndef _DEFAULT_SOURCE
  348|       |#define _DEFAULT_SOURCE
  349|       |#endif
  350|       |#ifndef _GNU_SOURCE
  351|       |#define _GNU_SOURCE
  352|       |#endif
  353|       |#define GPR_NACL 1
  354|       |#define GPR_CPU_POSIX 1
  355|       |#define GPR_GCC_ATOMIC 1
  356|       |#define GPR_GCC_TLS 1
  357|       |#define GPR_POSIX_LOG 1
  358|       |#define GPR_POSIX_ENV 1
  359|       |#define GPR_POSIX_TMPFILE 1
  360|       |#define GPR_POSIX_STRING 1
  361|       |#define GPR_POSIX_SUBPROCESS 1
  362|       |#define GPR_POSIX_SYNC 1
  363|       |#define GPR_POSIX_TIME 1
  364|       |#define GPR_HAS_PTHREAD_H 1
  365|       |#define GPR_GETPID_IN_UNISTD_H 1
  366|       |#ifdef _LP64
  367|       |#define GPR_ARCH_64 1
  368|       |#else /* _LP64 */
  369|       |#define GPR_ARCH_32 1
  370|       |#endif /* _LP64 */
  371|       |#elif defined(__Fuchsia__)
  372|       |#define GPR_FUCHSIA 1
  373|       |#define GPR_ARCH_64 1
  374|       |#define GPR_PLATFORM_STRING "fuchsia"
  375|       |#include <features.h>
  376|       |// Specifying musl libc affects wrap_memcpy.c. It causes memmove() to be
  377|       |// invoked.
  378|       |#define GPR_MUSL_LIBC_COMPAT 1
  379|       |#define GPR_CPU_POSIX 1
  380|       |#define GPR_GCC_ATOMIC 1
  381|       |#define GPR_PTHREAD_TLS 1
  382|       |#define GPR_POSIX_LOG 1
  383|       |#define GPR_POSIX_SYNC 1
  384|       |#define GPR_POSIX_ENV 1
  385|       |#define GPR_POSIX_TMPFILE 1
  386|       |#define GPR_POSIX_SUBPROCESS 1
  387|       |#define GPR_POSIX_SYNC 1
  388|       |#define GPR_POSIX_STRING 1
  389|       |#define GPR_POSIX_TIME 1
  390|       |#define GPR_HAS_PTHREAD_H 1
  391|       |#define GPR_GETPID_IN_UNISTD_H 1
  392|       |#else
  393|       |#error "Could not auto-detect platform"
  394|       |#endif
  395|       |#endif /* GPR_NO_AUTODETECT_PLATFORM */
  396|       |
  397|       |/*
  398|       | *  There are platforms for which TLS should not be used even though the
  399|       | * compiler makes it seem like it's supported (Android NDK < r12b for example).
  400|       | * This is primarily because of linker problems and toolchain misconfiguration:
  401|       | * TLS isn't supported until NDK r12b per
  402|       | * https://developer.android.com/ndk/downloads/revision_history.html
  403|       | * TLS also does not work with Android NDK if GCC is being used as the compiler
  404|       | * instead of Clang.
  405|       | * Since NDK r16, `__NDK_MAJOR__` and `__NDK_MINOR__` are defined in
  406|       | * <android/ndk-version.h>. For NDK < r16, users should define these macros,
  407|       | * e.g. `-D__NDK_MAJOR__=11 -D__NKD_MINOR__=0` for NDK r11. */
  408|       |#if defined(__ANDROID__) && defined(GPR_GCC_TLS)
  409|       |#if __has_include(<android/ndk-version.h>)
  410|       |#include <android/ndk-version.h>
  411|       |#endif /* __has_include(<android/ndk-version.h>) */
  412|       |#if (defined(__clang__) && defined(__NDK_MAJOR__) && defined(__NDK_MINOR__) && \
  413|       |     ((__NDK_MAJOR__ < 12) ||                                                  \
  414|       |      ((__NDK_MAJOR__ == 12) && (__NDK_MINOR__ < 1)))) ||                      \
  415|       |    (defined(__GNUC__) && !defined(__clang__))
  416|       |#undef GPR_GCC_TLS
  417|       |#define GPR_PTHREAD_TLS 1
  418|       |#endif
  419|       |#endif /*defined(__ANDROID__) && defined(GPR_GCC_TLS) */
  420|       |
  421|       |#if defined(__has_include)
  422|       |#if __has_include(<atomic>)
  423|       |#define GRPC_HAS_CXX11_ATOMIC
  424|       |#endif /* __has_include(<atomic>) */
  425|       |#endif /* defined(__has_include) */
  426|       |
  427|       |#ifndef GPR_PLATFORM_STRING
  428|       |#warning "GPR_PLATFORM_STRING not auto-detected"
  429|       |#define GPR_PLATFORM_STRING "unknown"
  430|       |#endif
  431|       |
  432|       |#ifdef GPR_GCOV
  433|       |#undef GPR_FORBID_UNREACHABLE_CODE
  434|       |#define GPR_FORBID_UNREACHABLE_CODE 1
  435|       |#endif
  436|       |
  437|       |#ifdef _MSC_VER
  438|       |#if _MSC_VER < 1700
  439|       |typedef __int8 int8_t;
  440|       |typedef __int16 int16_t;
  441|       |typedef __int32 int32_t;
  442|       |typedef __int64 int64_t;
  443|       |typedef unsigned __int8 uint8_t;
  444|       |typedef unsigned __int16 uint16_t;
  445|       |typedef unsigned __int32 uint32_t;
  446|       |typedef unsigned __int64 uint64_t;
  447|       |#else
  448|       |#include <stdint.h>
  449|       |#endif /* _MSC_VER < 1700 */
  450|       |#else
  451|       |#include <stdint.h>
  452|       |#endif /* _MSC_VER */
  453|       |
  454|       |/* Cache line alignment */
  455|       |#ifndef GPR_CACHELINE_SIZE_LOG
  456|       |#if defined(__i386__) || defined(__x86_64__)
  457|       |#define GPR_CACHELINE_SIZE_LOG 6
  458|       |#endif
  459|       |#ifndef GPR_CACHELINE_SIZE_LOG
  460|       |/* A reasonable default guess. Note that overestimates tend to waste more
  461|       |   space, while underestimates tend to waste more time. */
  462|       |#define GPR_CACHELINE_SIZE_LOG 6
  463|       |#endif /* GPR_CACHELINE_SIZE_LOG */
  464|       |#endif /* GPR_CACHELINE_SIZE_LOG */
  465|       |
  466|       |#define GPR_CACHELINE_SIZE (1 << GPR_CACHELINE_SIZE_LOG)
  467|       |
  468|       |/* scrub GCC_ATOMIC if it's not available on this compiler */
  469|       |#if defined(GPR_GCC_ATOMIC) && !defined(__ATOMIC_RELAXED)
  470|       |#undef GPR_GCC_ATOMIC
  471|       |#define GPR_GCC_SYNC 1
  472|       |#endif
  473|       |
  474|       |/* Validate platform combinations */
  475|       |#if defined(GPR_GCC_ATOMIC) + defined(GPR_GCC_SYNC) + \
  476|       |        defined(GPR_WINDOWS_ATOMIC) !=                \
  477|       |    1
  478|       |#error Must define exactly one of GPR_GCC_ATOMIC, GPR_GCC_SYNC, GPR_WINDOWS_ATOMIC
  479|       |#endif
  480|       |
  481|       |#if defined(GPR_ARCH_32) + defined(GPR_ARCH_64) != 1
  482|       |#error Must define exactly one of GPR_ARCH_32, GPR_ARCH_64
  483|       |#endif
  484|       |
  485|       |#if defined(GPR_CPU_LINUX) + defined(GPR_CPU_POSIX) + defined(GPR_WINDOWS) + \
  486|       |        defined(GPR_CPU_IPHONE) + defined(GPR_CPU_CUSTOM) !=                 \
  487|       |    1
  488|       |#error Must define exactly one of GPR_CPU_LINUX, GPR_CPU_POSIX, GPR_WINDOWS, GPR_CPU_IPHONE, GPR_CPU_CUSTOM
  489|       |#endif
  490|       |
  491|       |#if defined(GPR_MSVC_TLS) + defined(GPR_GCC_TLS) + defined(GPR_PTHREAD_TLS) + \
  492|       |        defined(GPR_CUSTOM_TLS) !=                                            \
  493|       |    1
  494|       |#error Must define exactly one of GPR_MSVC_TLS, GPR_GCC_TLS, GPR_PTHREAD_TLS, GPR_CUSTOM_TLS
  495|       |#endif
  496|       |
  497|       |/* maximum alignment needed for any type on this platform, rounded up to a
  498|       |   power of two */
  499|       |#define GPR_MAX_ALIGNMENT 16
  500|       |
  501|       |#ifndef GRPC_ARES
  502|       |#define GRPC_ARES 1
  503|       |#endif
  504|       |
  505|       |#ifndef GRPC_IF_NAMETOINDEX
  506|       |#define GRPC_IF_NAMETOINDEX 1
  507|       |#endif
  508|       |
  509|       |#ifndef GRPC_MUST_USE_RESULT
  510|       |#if defined(__GNUC__) && !defined(__MINGW32__)
  511|       |#define GRPC_MUST_USE_RESULT __attribute__((warn_unused_result))
  512|       |#define GPR_ALIGN_STRUCT(n) __attribute__((aligned(n)))
  513|       |#else
  514|       |#define GRPC_MUST_USE_RESULT
  515|       |#define GPR_ALIGN_STRUCT(n)
  516|       |#endif
  517|       |#endif
  518|       |
  519|       |#ifndef GRPC_UNUSED
  520|       |#if defined(__GNUC__) && !defined(__MINGW32__)
  521|       |#define GRPC_UNUSED __attribute__((unused))
  522|       |#else
  523|       |#define GRPC_UNUSED
  524|       |#endif
  525|       |#endif
  526|       |
  527|       |#ifndef GPR_PRINT_FORMAT_CHECK
  528|       |#ifdef __GNUC__
  529|       |#define GPR_PRINT_FORMAT_CHECK(FORMAT_STR, ARGS) \
  530|       |  __attribute__((format(printf, FORMAT_STR, ARGS)))
  531|       |#else
  532|       |#define GPR_PRINT_FORMAT_CHECK(FORMAT_STR, ARGS)
  533|       |#endif
  534|       |#endif /* GPR_PRINT_FORMAT_CHECK */
  535|       |
  536|       |#if GPR_FORBID_UNREACHABLE_CODE
  537|       |#define GPR_UNREACHABLE_CODE(STATEMENT)
  538|       |#else
  539|       |#define GPR_UNREACHABLE_CODE(STATEMENT)             \
  540|      0|  do {                                              \
  541|      0|    gpr_log(GPR_ERROR, "Should never reach here."); \
  542|      0|    abort();                                        \
  543|      0|    STATEMENT;                                      \
  544|      0|  } while (0)
  545|       |#endif /* GPR_FORBID_UNREACHABLE_CODE */
  546|       |
  547|       |#ifndef GPRAPI
  548|       |#define GPRAPI
  549|       |#endif
  550|       |
  551|       |#ifndef GRPCAPI
  552|       |#define GRPCAPI GPRAPI
  553|       |#endif
  554|       |
  555|       |#ifndef CENSUSAPI
  556|       |#define CENSUSAPI GRPCAPI
  557|       |#endif
  558|       |
  559|       |#ifndef GPR_HAS_ATTRIBUTE
  560|       |#ifdef __has_attribute
  561|       |#define GPR_HAS_ATTRIBUTE(a) __has_attribute(a)
  562|       |#else
  563|       |#define GPR_HAS_ATTRIBUTE(a) 0
  564|       |#endif
  565|       |#endif /* GPR_HAS_ATTRIBUTE */
  566|       |
  567|       |#ifndef GPR_HAS_FEATURE
  568|       |#ifdef __has_feature
  569|       |#define GPR_HAS_FEATURE(a) __has_feature(a)
  570|       |#else
  571|       |#define GPR_HAS_FEATURE(a) 0
  572|       |#endif
  573|       |#endif /* GPR_HAS_FEATURE */
  574|       |
  575|       |#ifndef GPR_ATTRIBUTE_NOINLINE
  576|       |#if GPR_HAS_ATTRIBUTE(noinline) || (defined(__GNUC__) && !defined(__clang__))
  577|       |#define GPR_ATTRIBUTE_NOINLINE __attribute__((noinline))
  578|       |#define GPR_HAS_ATTRIBUTE_NOINLINE 1
  579|       |#else
  580|       |#define GPR_ATTRIBUTE_NOINLINE
  581|       |#endif
  582|       |#endif /* GPR_ATTRIBUTE_NOINLINE */
  583|       |
  584|       |#ifndef GPR_ATTRIBUTE_WEAK
  585|       |/* Attribute weak is broken on LLVM/windows:
  586|       | * https://bugs.llvm.org/show_bug.cgi?id=37598 */
  587|       |#if (GPR_HAS_ATTRIBUTE(weak) || (defined(__GNUC__) && !defined(__clang__))) && \
  588|       |    !(defined(__llvm__) && defined(_WIN32))
  589|       |#define GPR_ATTRIBUTE_WEAK __attribute__((weak))
  590|       |#define GPR_HAS_ATTRIBUTE_WEAK 1
  591|       |#else
  592|       |#define GPR_ATTRIBUTE_WEAK
  593|       |#endif
  594|       |#endif /* GPR_ATTRIBUTE_WEAK */
  595|       |
  596|       |#ifndef GPR_ATTRIBUTE_NO_TSAN /* (1) */
  597|       |#if GPR_HAS_FEATURE(thread_sanitizer)
  598|       |#define GPR_ATTRIBUTE_NO_TSAN __attribute__((no_sanitize("thread")))
  599|       |#endif                        /* GPR_HAS_FEATURE */
  600|       |#ifndef GPR_ATTRIBUTE_NO_TSAN /* (2) */
  601|       |#define GPR_ATTRIBUTE_NO_TSAN
  602|       |#endif /* GPR_ATTRIBUTE_NO_TSAN (2) */
  603|       |#endif /* GPR_ATTRIBUTE_NO_TSAN (1) */
  604|       |
  605|       |/* GRPC_TSAN_ENABLED will be defined, when compiled with thread sanitizer. */
  606|       |#if defined(__SANITIZE_THREAD__)
  607|       |#define GRPC_TSAN_ENABLED
  608|       |#elif GPR_HAS_FEATURE(thread_sanitizer)
  609|       |#define GRPC_TSAN_ENABLED
  610|       |#endif
  611|       |
  612|       |/* GRPC_ASAN_ENABLED will be defined, when compiled with address sanitizer. */
  613|       |#if defined(__SANITIZE_ADDRESS__)
  614|       |#define GRPC_ASAN_ENABLED
  615|       |#elif GPR_HAS_FEATURE(address_sanitizer)
  616|       |#define GRPC_ASAN_ENABLED
  617|       |#endif
  618|       |
  619|       |/* GRPC_ALLOW_EXCEPTIONS should be 0 or 1 if exceptions are allowed or not */
  620|       |#ifndef GRPC_ALLOW_EXCEPTIONS
  621|       |/* If not already set, set to 1 on Windows (style guide standard) but to
  622|       | * 0 on non-Windows platforms unless the compiler defines __EXCEPTIONS */
  623|       |#ifdef GPR_WINDOWS
  624|       |#define GRPC_ALLOW_EXCEPTIONS 1
  625|       |#else /* GPR_WINDOWS */
  626|       |#ifdef __EXCEPTIONS
  627|       |#define GRPC_ALLOW_EXCEPTIONS 1
  628|       |#else /* __EXCEPTIONS */
  629|       |#define GRPC_ALLOW_EXCEPTIONS 0
  630|       |#endif /* __EXCEPTIONS */
  631|       |#endif /* __GPR_WINDOWS */
  632|       |#endif /* GRPC_ALLOW_EXCEPTIONS */
  633|       |
  634|       |/* Use GPR_LIKELY only in cases where you are sure that a certain outcome is the
  635|       | * most likely. Ideally, also collect performance numbers to justify the claim.
  636|       | */
  637|       |#ifdef __GNUC__
  638|       |#define GPR_LIKELY(x) __builtin_expect((x), 1)
  639|      2|#define GPR_UNLIKELY(x) __builtin_expect((x), 0)
  640|       |#else /* __GNUC__ */
  641|       |#define GPR_LIKELY(x) (x)
  642|       |#define GPR_UNLIKELY(x) (x)
  643|       |#endif /* __GNUC__ */
  644|       |
  645|       |#ifndef __STDC_FORMAT_MACROS
  646|       |#define __STDC_FORMAT_MACROS
  647|       |#endif
  648|       |
  649|       |#endif /* GRPC_IMPL_CODEGEN_PORT_PLATFORM_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpc/impl/codegen/slice.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_IMPL_CODEGEN_SLICE_H
   20|       |#define GRPC_IMPL_CODEGEN_SLICE_H
   21|       |
   22|       |#include <grpc/impl/codegen/port_platform.h>
   23|       |
   24|       |#include <stddef.h>
   25|       |
   26|       |#include <grpc/impl/codegen/gpr_slice.h>
   27|       |
   28|       |typedef struct grpc_slice grpc_slice;
   29|       |
   30|       |/** Slice API
   31|       |
   32|       |   A slice represents a contiguous reference counted array of bytes.
   33|       |   It is cheap to take references to a slice, and it is cheap to create a
   34|       |   slice pointing to a subset of another slice.
   35|       |
   36|       |   The data-structure for slices is exposed here to allow non-gpr code to
   37|       |   build slices from whatever data they have available.
   38|       |
   39|       |   When defining interfaces that handle slices, care should be taken to define
   40|       |   reference ownership semantics (who should call unref?) and mutability
   41|       |   constraints (is the callee allowed to modify the slice?) */
   42|       |
   43|       |/* Inlined half of grpc_slice is allowed to expand the size of the overall type
   44|       |   by this many bytes */
   45|       |#define GRPC_SLICE_INLINE_EXTRA_SIZE sizeof(void*)
   46|       |
   47|       |#define GRPC_SLICE_INLINED_SIZE \
   48|       |  (sizeof(size_t) + sizeof(uint8_t*) - 1 + GRPC_SLICE_INLINE_EXTRA_SIZE)
   49|       |
   50|       |struct grpc_slice_refcount;
   51|       |/** A grpc_slice s, if initialized, represents the byte range
   52|       |   s.bytes[0..s.length-1].
   53|       |
   54|       |   It can have an associated ref count which has a destruction routine to be run
   55|       |   when the ref count reaches zero (see grpc_slice_new() and grp_slice_unref()).
   56|       |   Multiple grpc_slice values may share a ref count.
   57|       |
   58|       |   If the slice does not have a refcount, it represents an inlined small piece
   59|       |   of data that is copied by value. */
   60|       |struct grpc_slice {
   61|       |  struct grpc_slice_refcount* refcount;
   62|       |  union grpc_slice_data {
   63|       |    struct grpc_slice_refcounted {
   64|       |      size_t length;
   65|       |      uint8_t* bytes;
   66|       |    } refcounted;
   67|       |    struct grpc_slice_inlined {
   68|       |      uint8_t length;
   69|       |      uint8_t bytes[GRPC_SLICE_INLINED_SIZE];
   70|       |    } inlined;
   71|       |  } data;
   72|       |};
   73|       |
   74|       |#define GRPC_SLICE_BUFFER_INLINE_ELEMENTS 8
   75|       |
   76|       |/** Represents an expandable array of slices, to be interpreted as a
   77|       |   single item. */
   78|       |typedef struct grpc_slice_buffer {
   79|       |  /** This is for internal use only. External users (i.e any code outside grpc
   80|       |   * core) MUST NOT use this field */
   81|       |  grpc_slice* base_slices;
   82|       |
   83|       |  /** slices in the array (Points to the first valid grpc_slice in the array) */
   84|       |  grpc_slice* slices;
   85|       |  /** the number of slices in the array */
   86|       |  size_t count;
   87|       |  /** the number of slices allocated in the array. External users (i.e any code
   88|       |   * outside grpc core) MUST NOT use this field */
   89|       |  size_t capacity;
   90|       |  /** the combined length of all slices in the array */
   91|       |  size_t length;
   92|       |  /** inlined elements to avoid allocations */
   93|       |  grpc_slice inlined[GRPC_SLICE_BUFFER_INLINE_ELEMENTS];
   94|       |} grpc_slice_buffer;
   95|       |
   96|       |#define GRPC_SLICE_START_PTR(slice)                 \
   97|      0|  ((slice).refcount ? (slice).data.refcounted.bytes \
   98|      0|                    : (slice).data.inlined.bytes)
   99|       |#define GRPC_SLICE_LENGTH(slice)                     \
  100|      0|  ((slice).refcount ? (slice).data.refcounted.length \
  101|      0|                    : (slice).data.inlined.length)
  102|       |#define GRPC_SLICE_SET_LENGTH(slice, newlen)                              \
  103|       |  ((slice).refcount ? ((slice).data.refcounted.length = (size_t)(newlen)) \
  104|       |                    : ((slice).data.inlined.length = (uint8_t)(newlen)))
  105|       |#define GRPC_SLICE_END_PTR(slice) \
  106|      0|  GRPC_SLICE_START_PTR(slice) + GRPC_SLICE_LENGTH(slice)
  107|      0|#define GRPC_SLICE_IS_EMPTY(slice) (GRPC_SLICE_LENGTH(slice) == 0)
  108|       |
  109|       |#ifdef GRPC_ALLOW_GPR_SLICE_FUNCTIONS
  110|       |
  111|       |/* Duplicate GPR_* definitions */
  112|       |#define GPR_SLICE_START_PTR(slice)                  \
  113|       |  ((slice).refcount ? (slice).data.refcounted.bytes \
  114|       |                    : (slice).data.inlined.bytes)
  115|       |#define GPR_SLICE_LENGTH(slice)                      \
  116|       |  ((slice).refcount ? (slice).data.refcounted.length \
  117|       |                    : (slice).data.inlined.length)
  118|       |#define GPR_SLICE_SET_LENGTH(slice, newlen)                               \
  119|       |  ((slice).refcount ? ((slice).data.refcounted.length = (size_t)(newlen)) \
  120|       |                    : ((slice).data.inlined.length = (uint8_t)(newlen)))
  121|       |#define GPR_SLICE_END_PTR(slice) \
  122|       |  GRPC_SLICE_START_PTR(slice) + GRPC_SLICE_LENGTH(slice)
  123|       |#define GPR_SLICE_IS_EMPTY(slice) (GRPC_SLICE_LENGTH(slice) == 0)
  124|       |
  125|       |#endif /* GRPC_ALLOW_GPR_SLICE_FUNCTIONS */
  126|       |
  127|       |#endif /* GRPC_IMPL_CODEGEN_SLICE_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpc/load_reporting.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_LOAD_REPORTING_H
   20|       |#define GRPC_LOAD_REPORTING_H
   21|       |
   22|       |#include <grpc/impl/codegen/port_platform.h>
   23|       |
   24|       |#ifdef __cplusplus
   25|       |extern "C" {
   26|       |#endif
   27|       |
   28|       |/** Metadata key for the gRPC LB load balancer token.
   29|       | *
   30|       | * The value corresponding to this key is an opaque token that is given to the
   31|       | * frontend as part of each pick; the frontend sends this token to the backend
   32|       | * in each request it sends when using that pick. The token is used by the
   33|       | * backend to verify the request and to allow the backend to report load to the
   34|       | * gRPC LB system. */
   35|       |#define GRPC_LB_TOKEN_MD_KEY "lb-token"
   36|       |
   37|       |/** Metadata key for gRPC LB cost reporting.
   38|       | *
   39|       | * The value corresponding to this key is an opaque binary blob reported by the
   40|       | * backend as part of its trailing metadata containing cost information for the
   41|       | * call. */
   42|      0|#define GRPC_LB_COST_MD_KEY "lb-cost-bin"
   43|       |
   44|       |#ifdef __cplusplus
   45|       |}
   46|       |#endif
   47|       |
   48|       |#endif /* GRPC_LOAD_REPORTING_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/alarm_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |/// An Alarm posts the user-provided tag to its associated completion queue or
   20|       |/// invokes the user-provided function on expiry or cancellation.
   21|       |#ifndef GRPCPP_ALARM_IMPL_H
   22|       |#define GRPCPP_ALARM_IMPL_H
   23|       |
   24|       |#include <functional>
   25|       |
   26|       |#include <grpc/grpc.h>
   27|       |#include <grpcpp/impl/codegen/completion_queue.h>
   28|       |#include <grpcpp/impl/codegen/completion_queue_tag.h>
   29|       |#include <grpcpp/impl/codegen/grpc_library.h>
   30|       |#include <grpcpp/impl/codegen/time.h>
   31|       |#include <grpcpp/impl/grpc_library.h>
   32|       |
   33|       |namespace grpc_impl {
   34|       |
   35|       |class Alarm : private ::grpc::GrpcLibraryCodegen {
   36|       | public:
   37|       |  /// Create an unset completion queue alarm
   38|       |  Alarm();
   39|       |
   40|       |  /// Destroy the given completion queue alarm, cancelling it in the process.
   41|       |  ~Alarm();
   42|       |
   43|       |  /// DEPRECATED: Create and set a completion queue alarm instance associated to
   44|       |  /// \a cq.
   45|       |  /// This form is deprecated because it is inherently racy.
   46|       |  /// \internal We rely on the presence of \a cq for grpc initialization. If \a
   47|       |  /// cq were ever to be removed, a reference to a static
   48|       |  /// internal::GrpcLibraryInitializer instance would need to be introduced
   49|       |  /// here. \endinternal.
   50|       |  template <typename T>
   51|       |  Alarm(::grpc::CompletionQueue* cq, const T& deadline, void* tag) : Alarm() {
   52|       |    SetInternal(cq, ::grpc::TimePoint<T>(deadline).raw_time(), tag);
   53|       |  }
   54|       |
   55|       |  /// Trigger an alarm instance on completion queue \a cq at the specified time.
   56|       |  /// Once the alarm expires (at \a deadline) or it's cancelled (see \a Cancel),
   57|       |  /// an event with tag \a tag will be added to \a cq. If the alarm expired, the
   58|       |  /// event's success bit will be true, false otherwise (ie, upon cancellation).
   59|       |  template <typename T>
   60|       |  void Set(::grpc::CompletionQueue* cq, const T& deadline, void* tag) {
   61|       |    SetInternal(cq, ::grpc::TimePoint<T>(deadline).raw_time(), tag);
   62|       |  }
   63|       |
   64|       |  /// Alarms aren't copyable.
   65|       |  Alarm(const Alarm&) = delete;
   66|       |  Alarm& operator=(const Alarm&) = delete;
   67|       |
   68|       |  /// Alarms are movable.
   69|      0|  Alarm(Alarm&& rhs) : alarm_(rhs.alarm_) { rhs.alarm_ = nullptr; }
   70|      0|  Alarm& operator=(Alarm&& rhs) {
   71|      0|    alarm_ = rhs.alarm_;
   72|      0|    rhs.alarm_ = nullptr;
   73|      0|    return *this;
   74|      0|  }
   75|       |
   76|       |  /// Cancel a completion queue alarm. Calling this function over an alarm that
   77|       |  /// has already fired has no effect.
   78|       |  void Cancel();
   79|       |
   80|       |  /// NOTE: class experimental_type is not part of the public API of this class
   81|       |  /// TODO(vjpai): Move these contents to the public API of Alarm when
   82|       |  ///              they are no longer experimental
   83|       |  class experimental_type {
   84|       |   public:
   85|      0|    explicit experimental_type(Alarm* alarm) : alarm_(alarm) {}
   86|       |
   87|       |    /// Set an alarm to invoke callback \a f. The argument to the callback
   88|       |    /// states whether the alarm expired at \a deadline (true) or was cancelled
   89|       |    /// (false)
   90|       |    template <typename T>
   91|       |    void Set(const T& deadline, std::function<void(bool)> f) {
   92|       |      alarm_->SetInternal(::grpc::TimePoint<T>(deadline).raw_time(),
   93|       |                          std::move(f));
   94|       |    }
   95|       |
   96|       |   private:
   97|       |    Alarm* alarm_;
   98|       |  };
   99|       |
  100|       |  /// NOTE: The function experimental() is not stable public API. It is a view
  101|       |  /// to the experimental components of this class. It may be changed or removed
  102|       |  /// at any time.
  103|      0|  experimental_type experimental() { return experimental_type(this); }
  104|       |
  105|       | private:
  106|       |  void SetInternal(::grpc::CompletionQueue* cq, gpr_timespec deadline,
  107|       |                   void* tag);
  108|       |  void SetInternal(gpr_timespec deadline, std::function<void(bool)> f);
  109|       |
  110|       |  ::grpc::internal::CompletionQueueTag* alarm_;
  111|       |};
  112|       |
  113|       |}  // namespace grpc_impl
  114|       |
  115|       |#endif  // GRPCPP_ALARM_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/create_channel.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2019 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_CREATE_CHANNEL_H
   20|       |#define GRPCPP_CREATE_CHANNEL_H
   21|       |
   22|       |#include <grpcpp/create_channel_impl.h>
   23|       |#include <grpcpp/support/channel_arguments.h>
   24|       |
   25|       |namespace grpc {
   26|       |
   27|       |static inline std::shared_ptr<::grpc::Channel> CreateChannel(
   28|       |    const grpc::string& target,
   29|      0|    const std::shared_ptr<ChannelCredentials>& creds) {
   30|      0|  return ::grpc_impl::CreateChannelImpl(target, creds);
   31|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL13CreateChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEE
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL13CreateChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL13CreateChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL13CreateChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL13CreateChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEE
  ------------------
   32|       |
   33|       |static inline std::shared_ptr<::grpc::Channel> CreateCustomChannel(
   34|       |    const grpc::string& target,
   35|       |    const std::shared_ptr<ChannelCredentials>& creds,
   36|      0|    const ChannelArguments& args) {
   37|      0|  return ::grpc_impl::CreateCustomChannelImpl(target, creds, args);
   38|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL19CreateCustomChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSA_16ChannelArgumentsE
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL19CreateCustomChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSA_16ChannelArgumentsE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL19CreateCustomChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSA_16ChannelArgumentsE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL19CreateCustomChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSA_16ChannelArgumentsE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL19CreateCustomChannelERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEERKNS0_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSA_16ChannelArgumentsE
  ------------------
   39|       |
   40|       |namespace experimental {
   41|       |
   42|       |static inline std::shared_ptr<::grpc::Channel>
   43|       |CreateCustomChannelWithInterceptors(
   44|       |    const grpc::string& target,
   45|       |    const std::shared_ptr<ChannelCredentials>& creds,
   46|       |    const ChannelArguments& args,
   47|       |    std::vector<
   48|       |        std::unique_ptr<experimental::ClientInterceptorFactoryInterface>>
   49|      0|        interceptor_creators) {
   50|      0|  return ::grpc_impl::experimental::CreateCustomChannelWithInterceptors(
   51|      0|      target, creds, args, std::move(interceptor_creators));
   52|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpc12experimentalL35CreateCustomChannelWithInterceptorsERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSB_16ChannelArgumentsENS1_6vectorINS1_10unique_ptrINS0_33ClientInterceptorFactoryInterfaceENS1_14default_deleteISL_EEEENS5_ISO_EEEE
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpc12experimentalL35CreateCustomChannelWithInterceptorsERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSB_16ChannelArgumentsENS1_6vectorINS1_10unique_ptrINS0_33ClientInterceptorFactoryInterfaceENS1_14default_deleteISL_EEEENS5_ISO_EEEE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpc12experimentalL35CreateCustomChannelWithInterceptorsERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSB_16ChannelArgumentsENS1_6vectorINS1_10unique_ptrINS0_33ClientInterceptorFactoryInterfaceENS1_14default_deleteISL_EEEENS5_ISO_EEEE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpc12experimentalL35CreateCustomChannelWithInterceptorsERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSB_16ChannelArgumentsENS1_6vectorINS1_10unique_ptrINS0_33ClientInterceptorFactoryInterfaceENS1_14default_deleteISL_EEEENS5_ISO_EEEE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpc12experimentalL35CreateCustomChannelWithInterceptorsERKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS1_10shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNSB_16ChannelArgumentsENS1_6vectorINS1_10unique_ptrINS0_33ClientInterceptorFactoryInterfaceENS1_14default_deleteISL_EEEENS5_ISO_EEEE
  ------------------
   53|       |
   54|       |}  // namespace experimental
   55|       |}  // namespace grpc
   56|       |
   57|       |#endif  // GRPCPP_CREATE_CHANNEL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/ext/health_check_service_server_builder_option.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_EXT_HEALTH_CHECK_SERVICE_SERVER_BUILDER_OPTION_H
   20|       |#define GRPCPP_EXT_HEALTH_CHECK_SERVICE_SERVER_BUILDER_OPTION_H
   21|       |
   22|       |#include <memory>
   23|       |
   24|       |#include <grpcpp/health_check_service_interface.h>
   25|       |#include <grpcpp/impl/server_builder_option.h>
   26|       |#include <grpcpp/support/config.h>
   27|       |
   28|       |namespace grpc {
   29|       |
   30|       |class HealthCheckServiceServerBuilderOption : public ServerBuilderOption {
   31|       | public:
   32|       |  /// The ownership of \a hc will be taken and transferred to the grpc server.
   33|       |  /// To explicitly disable default service, pass in a nullptr.
   34|       |  explicit HealthCheckServiceServerBuilderOption(
   35|       |      std::unique_ptr<HealthCheckServiceInterface> hc);
   36|      0|  ~HealthCheckServiceServerBuilderOption() override {}
   37|       |  void UpdateArguments(ChannelArguments* args) override;
   38|       |  void UpdatePlugins(
   39|       |      std::vector<std::unique_ptr<ServerBuilderPlugin>>* plugins) override;
   40|       |
   41|       | private:
   42|       |  std::unique_ptr<HealthCheckServiceInterface> hc_;
   43|       |};
   44|       |
   45|       |}  // namespace grpc
   46|       |
   47|       |#endif  // GRPCPP_EXT_HEALTH_CHECK_SERVICE_SERVER_BUILDER_OPTION_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/generic/generic_stub_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_GENERIC_GENERIC_STUB_IMPL_H
   20|       |#define GRPCPP_GENERIC_GENERIC_STUB_IMPL_H
   21|       |
   22|       |#include <functional>
   23|       |
   24|       |#include <grpcpp/support/async_stream.h>
   25|       |#include <grpcpp/support/async_unary_call.h>
   26|       |#include <grpcpp/support/byte_buffer.h>
   27|       |#include <grpcpp/support/client_callback.h>
   28|       |#include <grpcpp/support/status.h>
   29|       |
   30|       |namespace grpc {
   31|       |
   32|       |typedef ClientAsyncReaderWriter<ByteBuffer, ByteBuffer>
   33|       |    GenericClientAsyncReaderWriter;
   34|       |typedef ClientAsyncResponseReader<ByteBuffer> GenericClientAsyncResponseReader;
   35|       |}  // namespace grpc
   36|       |namespace grpc_impl {
   37|       |class CompletionQueue;
   38|       |
   39|       |/// Generic stubs provide a type-unsafe interface to call gRPC methods
   40|       |/// by name.
   41|       |class GenericStub final {
   42|       | public:
   43|       |  explicit GenericStub(std::shared_ptr<grpc::ChannelInterface> channel)
   44|      0|      : channel_(channel) {}
   45|       |
   46|       |  /// Setup a call to a named method \a method using \a context, but don't
   47|       |  /// start it. Let it be started explicitly with StartCall and a tag.
   48|       |  /// The return value only indicates whether or not registration of the call
   49|       |  /// succeeded (i.e. the call won't proceed if the return value is nullptr).
   50|       |  std::unique_ptr<grpc::GenericClientAsyncReaderWriter> PrepareCall(
   51|       |      grpc::ClientContext* context, const grpc::string& method,
   52|       |      grpc::CompletionQueue* cq);
   53|       |
   54|       |  /// Setup a unary call to a named method \a method using \a context, and don't
   55|       |  /// start it. Let it be started explicitly with StartCall.
   56|       |  /// The return value only indicates whether or not registration of the call
   57|       |  /// succeeded (i.e. the call won't proceed if the return value is nullptr).
   58|       |  std::unique_ptr<grpc::GenericClientAsyncResponseReader> PrepareUnaryCall(
   59|       |      grpc::ClientContext* context, const grpc::string& method,
   60|       |      const grpc::ByteBuffer& request, grpc::CompletionQueue* cq);
   61|       |
   62|       |  /// DEPRECATED for multi-threaded use
   63|       |  /// Begin a call to a named method \a method using \a context.
   64|       |  /// A tag \a tag will be delivered to \a cq when the call has been started
   65|       |  /// (i.e, initial metadata has been sent).
   66|       |  /// The return value only indicates whether or not registration of the call
   67|       |  /// succeeded (i.e. the call won't proceed if the return value is nullptr).
   68|       |  std::unique_ptr<grpc::GenericClientAsyncReaderWriter> Call(
   69|       |      grpc::ClientContext* context, const grpc::string& method,
   70|       |      grpc::CompletionQueue* cq, void* tag);
   71|       |
   72|       |  /// NOTE: class experimental_type is not part of the public API of this class
   73|       |  /// TODO(vjpai): Move these contents to the public API of GenericStub when
   74|       |  ///              they are no longer experimental
   75|       |  class experimental_type {
   76|       |   public:
   77|      0|    explicit experimental_type(GenericStub* stub) : stub_(stub) {}
   78|       |
   79|       |    /// Setup and start a unary call to a named method \a method using
   80|       |    /// \a context and specifying the \a request and \a response buffers.
   81|       |    void UnaryCall(grpc::ClientContext* context, const grpc::string& method,
   82|       |                   const grpc::ByteBuffer* request, grpc::ByteBuffer* response,
   83|       |                   std::function<void(grpc::Status)> on_completion);
   84|       |
   85|       |    /// Setup and start a unary call to a named method \a method using
   86|       |    /// \a context and specifying the \a request and \a response buffers.
   87|       |    void UnaryCall(grpc::ClientContext* context, const grpc::string& method,
   88|       |                   const grpc::ByteBuffer* request, grpc::ByteBuffer* response,
   89|       |                   grpc::experimental::ClientUnaryReactor* reactor);
   90|       |
   91|       |    /// Setup a call to a named method \a method using \a context and tied to
   92|       |    /// \a reactor . Like any other bidi streaming RPC, it will not be activated
   93|       |    /// until StartCall is invoked on its reactor.
   94|       |    void PrepareBidiStreamingCall(
   95|       |        grpc::ClientContext* context, const grpc::string& method,
   96|       |        grpc::experimental::ClientBidiReactor<grpc::ByteBuffer,
   97|       |                                              grpc::ByteBuffer>* reactor);
   98|       |
   99|       |   private:
  100|       |    GenericStub* stub_;
  101|       |  };
  102|       |
  103|       |  /// NOTE: The function experimental() is not stable public API. It is a view
  104|       |  /// to the experimental components of this class. It may be changed or removed
  105|       |  /// at any time.
  106|      0|  experimental_type experimental() { return experimental_type(this); }
  107|       |
  108|       | private:
  109|       |  std::shared_ptr<grpc::ChannelInterface> channel_;
  110|       |};
  111|       |
  112|       |}  // namespace grpc_impl
  113|       |
  114|       |#endif  // GRPCPP_GENERIC_GENERIC_STUB_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/health_check_service_interface.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2019 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_HEALTH_CHECK_SERVICE_INTERFACE_H
   20|       |#define GRPCPP_HEALTH_CHECK_SERVICE_INTERFACE_H
   21|       |
   22|       |#include <grpcpp/health_check_service_interface_impl.h>
   23|       |
   24|       |namespace grpc {
   25|       |
   26|       |const char kHealthCheckServiceInterfaceArg[] =
   27|       |    "grpc.health_check_service_interface";
   28|       |
   29|       |typedef ::grpc_impl::HealthCheckServiceInterface HealthCheckServiceInterface;
   30|       |
   31|      0|static inline void EnableDefaultHealthCheckService(bool enable) {
   32|      0|  ::grpc_impl::EnableDefaultHealthCheckService(enable);
   33|      0|}
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZN4grpcL31EnableDefaultHealthCheckServiceEb
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL31EnableDefaultHealthCheckServiceEb
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL31EnableDefaultHealthCheckServiceEb
  ------------------
  | Unexecuted instantiation: health_check_service_server_builder_option.cc:_ZN4grpcL31EnableDefaultHealthCheckServiceEb
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZN4grpcL31EnableDefaultHealthCheckServiceEb
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL31EnableDefaultHealthCheckServiceEb
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZN4grpcL31EnableDefaultHealthCheckServiceEb
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL31EnableDefaultHealthCheckServiceEb
  ------------------
   34|       |
   35|      0|static inline bool DefaultHealthCheckServiceEnabled() {
   36|      0|  return ::grpc_impl::DefaultHealthCheckServiceEnabled();
   37|      0|}
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZN4grpcL32DefaultHealthCheckServiceEnabledEv
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL32DefaultHealthCheckServiceEnabledEv
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL32DefaultHealthCheckServiceEnabledEv
  ------------------
  | Unexecuted instantiation: health_check_service_server_builder_option.cc:_ZN4grpcL32DefaultHealthCheckServiceEnabledEv
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZN4grpcL32DefaultHealthCheckServiceEnabledEv
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL32DefaultHealthCheckServiceEnabledEv
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZN4grpcL32DefaultHealthCheckServiceEnabledEv
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL32DefaultHealthCheckServiceEnabledEv
  ------------------
   38|       |
   39|       |}  // namespace grpc
   40|       |
   41|       |#endif  // GRPCPP_HEALTH_CHECK_SERVICE_INTERFACE_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/health_check_service_interface_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_HEALTH_CHECK_SERVICE_INTERFACE_IMPL_H
   20|       |#define GRPCPP_HEALTH_CHECK_SERVICE_INTERFACE_IMPL_H
   21|       |
   22|       |#include <grpcpp/support/config.h>
   23|       |
   24|       |namespace grpc_impl {
   25|       |
   26|       |/// The gRPC server uses this interface to expose the health checking service
   27|       |/// without depending on protobuf.
   28|       |class HealthCheckServiceInterface {
   29|       | public:
   30|      0|  virtual ~HealthCheckServiceInterface() {}
   31|       |
   32|       |  /// Set or change the serving status of the given \a service_name.
   33|       |  virtual void SetServingStatus(const grpc::string& service_name,
   34|       |                                bool serving) = 0;
   35|       |  /// Apply to all registered service names.
   36|       |  virtual void SetServingStatus(bool serving) = 0;
   37|       |
   38|       |  /// Set all registered service names to not serving and prevent future
   39|       |  /// state changes.
   40|      0|  virtual void Shutdown() {}
   41|       |};
   42|       |
   43|       |/// Enable/disable the default health checking service. This applies to all C++
   44|       |/// servers created afterwards. For each server, user can override the default
   45|       |/// with a HealthCheckServiceServerBuilderOption.
   46|       |/// NOT thread safe.
   47|       |void EnableDefaultHealthCheckService(bool enable);
   48|       |
   49|       |/// Returns whether the default health checking service is enabled.
   50|       |/// NOT thread safe.
   51|       |bool DefaultHealthCheckServiceEnabled();
   52|       |
   53|       |}  // namespace grpc_impl
   54|       |
   55|       |#endif  // GRPCPP_HEALTH_CHECK_SERVICE_INTERFACE_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/async_generic_service.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_ASYNC_GENERIC_SERVICE_H
   20|       |#define GRPCPP_IMPL_CODEGEN_ASYNC_GENERIC_SERVICE_H
   21|       |
   22|       |#include <grpcpp/impl/codegen/async_stream.h>
   23|       |#include <grpcpp/impl/codegen/byte_buffer.h>
   24|       |#include <grpcpp/impl/codegen/server_callback.h>
   25|       |
   26|       |struct grpc_server;
   27|       |
   28|       |namespace grpc {
   29|       |
   30|       |typedef ServerAsyncReaderWriter<ByteBuffer, ByteBuffer>
   31|       |    GenericServerAsyncReaderWriter;
   32|       |typedef ServerAsyncResponseWriter<ByteBuffer> GenericServerAsyncResponseWriter;
   33|       |typedef ServerAsyncReader<ByteBuffer, ByteBuffer> GenericServerAsyncReader;
   34|       |typedef ServerAsyncWriter<ByteBuffer> GenericServerAsyncWriter;
   35|       |
   36|       |class GenericServerContext final : public ServerContext {
   37|       | public:
   38|      0|  const grpc::string& method() const { return method_; }
   39|      0|  const grpc::string& host() const { return host_; }
   40|       |
   41|       | private:
   42|       |  friend class grpc_impl::Server;
   43|       |  friend class ServerInterface;
   44|       |
   45|      0|  void Clear() {
   46|      0|    method_.clear();
   47|      0|    host_.clear();
   48|      0|    ServerContext::Clear();
   49|      0|  }
   50|       |
   51|       |  grpc::string method_;
   52|       |  grpc::string host_;
   53|       |};
   54|       |
   55|       |// A generic service at the server side accepts all RPC methods and hosts. It is
   56|       |// typically used in proxies. The generic service can be registered to a server
   57|       |// which also has other services.
   58|       |// Sample usage:
   59|       |//   ServerBuilder builder;
   60|       |//   auto cq = builder.AddCompletionQueue();
   61|       |//   AsyncGenericService generic_service;
   62|       |//   builder.RegisterAsyncGenericService(&generic_service);
   63|       |//   auto server = builder.BuildAndStart();
   64|       |//
   65|       |//   // request a new call
   66|       |//   GenericServerContext context;
   67|       |//   GenericServerAsyncReaderWriter stream;
   68|       |//   generic_service.RequestCall(&context, &stream, cq.get(), cq.get(), tag);
   69|       |//
   70|       |// When tag is retrieved from cq->Next(), context.method() can be used to look
   71|       |// at the method and the RPC can be handled accordingly.
   72|       |class AsyncGenericService final {
   73|       | public:
   74|      0|  AsyncGenericService() : server_(nullptr) {}
   75|       |
   76|       |  void RequestCall(GenericServerContext* ctx,
   77|       |                   GenericServerAsyncReaderWriter* reader_writer,
   78|       |                   CompletionQueue* call_cq,
   79|       |                   ServerCompletionQueue* notification_cq, void* tag);
   80|       |
   81|       | private:
   82|       |  friend class grpc_impl::Server;
   83|       |  grpc_impl::Server* server_;
   84|       |};
   85|       |
   86|       |namespace experimental {
   87|       |
   88|       |/// \a ServerGenericBidiReactor is the reactor class for bidi streaming RPCs
   89|       |/// invoked on a CallbackGenericService. The API difference relative to
   90|       |/// ServerBidiReactor is that the argument to OnStarted is a
   91|       |/// GenericServerContext rather than a ServerContext. All other reaction and
   92|       |/// operation initiation APIs are the same as ServerBidiReactor.
   93|       |class ServerGenericBidiReactor
   94|       |    : public ServerBidiReactor<ByteBuffer, ByteBuffer> {
   95|       | public:
   96|       |  /// Similar to ServerBidiReactor::OnStarted except for argument type.
   97|       |  ///
   98|       |  /// \param[in] context The context object associated with this RPC.
   99|      0|  virtual void OnStarted(GenericServerContext* context) {}
  100|       |
  101|       | private:
  102|      0|  void OnStarted(ServerContext* ctx) final {
  103|      0|    OnStarted(static_cast<GenericServerContext*>(ctx));
  104|      0|  }
  105|       |};
  106|       |
  107|       |}  // namespace experimental
  108|       |
  109|       |namespace internal {
  110|       |class UnimplementedGenericBidiReactor
  111|       |    : public experimental::ServerGenericBidiReactor {
  112|       | public:
  113|      0|  void OnDone() override { delete this; }
  114|      0|  void OnStarted(GenericServerContext*) override {
  115|      0|    this->Finish(Status(StatusCode::UNIMPLEMENTED, ""));
  116|      0|  }
  117|       |};
  118|       |}  // namespace internal
  119|       |
  120|       |namespace experimental {
  121|       |
  122|       |/// \a CallbackGenericService is the base class for generic services implemented
  123|       |/// using the callback API and registered through the ServerBuilder using
  124|       |/// RegisterCallbackGenericService.
  125|       |class CallbackGenericService {
  126|       | public:
  127|      0|  CallbackGenericService() {}
  128|      0|  virtual ~CallbackGenericService() {}
  129|       |
  130|       |  /// The "method handler" for the generic API. This function should be
  131|       |  /// overridden to return a ServerGenericBidiReactor that implements the
  132|       |  /// application-level interface for this RPC.
  133|      0|  virtual ServerGenericBidiReactor* CreateReactor() {
  134|      0|    return new internal::UnimplementedGenericBidiReactor;
  135|      0|  }
  136|       |
  137|       | private:
  138|       |  friend class ::grpc_impl::Server;
  139|       |
  140|      0|  internal::CallbackBidiHandler<ByteBuffer, ByteBuffer>* Handler() {
  141|      0|    return new internal::CallbackBidiHandler<ByteBuffer, ByteBuffer>(
  142|      0|        [this] { return CreateReactor(); });
  143|      0|  }
  144|       |
  145|       |  grpc_impl::Server* server_{nullptr};
  146|       |};
  147|       |}  // namespace experimental
  148|       |}  // namespace grpc
  149|       |
  150|       |#endif  // GRPCPP_IMPL_CODEGEN_ASYNC_GENERIC_SERVICE_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/async_stream.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_ASYNC_STREAM_H
   20|       |#define GRPCPP_IMPL_CODEGEN_ASYNC_STREAM_H
   21|       |
   22|       |#include <grpcpp/impl/codegen/call.h>
   23|       |#include <grpcpp/impl/codegen/channel_interface.h>
   24|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   25|       |#include <grpcpp/impl/codegen/server_context.h>
   26|       |#include <grpcpp/impl/codegen/service_type.h>
   27|       |#include <grpcpp/impl/codegen/status.h>
   28|       |
   29|       |namespace grpc {
   30|       |
   31|       |namespace internal {
   32|       |/// Common interface for all client side asynchronous streaming.
   33|       |class ClientAsyncStreamingInterface {
   34|       | public:
   35|      0|  virtual ~ClientAsyncStreamingInterface() {}
   36|       |
   37|       |  /// Start the call that was set up by the constructor, but only if the
   38|       |  /// constructor was invoked through the "Prepare" API which doesn't actually
   39|       |  /// start the call
   40|       |  virtual void StartCall(void* tag) = 0;
   41|       |
   42|       |  /// Request notification of the reading of the initial metadata. Completion
   43|       |  /// will be notified by \a tag on the associated completion queue.
   44|       |  /// This call is optional, but if it is used, it cannot be used concurrently
   45|       |  /// with or after the \a AsyncReaderInterface::Read method.
   46|       |  ///
   47|       |  /// \param[in] tag Tag identifying this request.
   48|       |  virtual void ReadInitialMetadata(void* tag) = 0;
   49|       |
   50|       |  /// Indicate that the stream is to be finished and request notification for
   51|       |  /// when the call has been ended.
   52|       |  /// Should not be used concurrently with other operations.
   53|       |  ///
   54|       |  /// It is appropriate to call this method when both:
   55|       |  ///   * the client side has no more message to send
   56|       |  ///     (this can be declared implicitly by calling this method, or
   57|       |  ///     explicitly through an earlier call to the <i>WritesDone</i> method
   58|       |  ///     of the class in use, e.g. \a ClientAsyncWriterInterface::WritesDone or
   59|       |  ///     \a ClientAsyncReaderWriterInterface::WritesDone).
   60|       |  ///   * there are no more messages to be received from the server (this can
   61|       |  ///     be known implicitly by the calling code, or explicitly from an
   62|       |  ///     earlier call to \a AsyncReaderInterface::Read that yielded a failed
   63|       |  ///     result, e.g. cq->Next(&read_tag, &ok) filled in 'ok' with 'false').
   64|       |  ///
   65|       |  /// The tag will be returned when either:
   66|       |  /// - all incoming messages have been read and the server has returned
   67|       |  ///   a status.
   68|       |  /// - the server has returned a non-OK status.
   69|       |  /// - the call failed for some reason and the library generated a
   70|       |  ///   status.
   71|       |  ///
   72|       |  /// Note that implementations of this method attempt to receive initial
   73|       |  /// metadata from the server if initial metadata hasn't yet been received.
   74|       |  ///
   75|       |  /// \param[in] tag Tag identifying this request.
   76|       |  /// \param[out] status To be updated with the operation status.
   77|       |  virtual void Finish(Status* status, void* tag) = 0;
   78|       |};
   79|       |
   80|       |/// An interface that yields a sequence of messages of type \a R.
   81|       |template <class R>
   82|       |class AsyncReaderInterface {
   83|       | public:
   84|      0|  virtual ~AsyncReaderInterface() {}
   85|       |
   86|       |  /// Read a message of type \a R into \a msg. Completion will be notified by \a
   87|       |  /// tag on the associated completion queue.
   88|       |  /// This is thread-safe with respect to \a Write or \a WritesDone methods. It
   89|       |  /// should not be called concurrently with other streaming APIs
   90|       |  /// on the same stream. It is not meaningful to call it concurrently
   91|       |  /// with another \a AsyncReaderInterface::Read on the same stream since reads
   92|       |  /// on the same stream are delivered in order.
   93|       |  ///
   94|       |  /// \param[out] msg Where to eventually store the read message.
   95|       |  /// \param[in] tag The tag identifying the operation.
   96|       |  ///
   97|       |  /// Side effect: note that this method attempt to receive initial metadata for
   98|       |  /// a stream if it hasn't yet been received.
   99|       |  virtual void Read(R* msg, void* tag) = 0;
  100|       |};
  101|       |
  102|       |/// An interface that can be fed a sequence of messages of type \a W.
  103|       |template <class W>
  104|       |class AsyncWriterInterface {
  105|       | public:
  106|      0|  virtual ~AsyncWriterInterface() {}
  107|       |
  108|       |  /// Request the writing of \a msg with identifying tag \a tag.
  109|       |  ///
  110|       |  /// Only one write may be outstanding at any given time. This means that
  111|       |  /// after calling Write, one must wait to receive \a tag from the completion
  112|       |  /// queue BEFORE calling Write again.
  113|       |  /// This is thread-safe with respect to \a AsyncReaderInterface::Read
  114|       |  ///
  115|       |  /// gRPC doesn't take ownership or a reference to \a msg, so it is safe to
  116|       |  /// to deallocate once Write returns.
  117|       |  ///
  118|       |  /// \param[in] msg The message to be written.
  119|       |  /// \param[in] tag The tag identifying the operation.
  120|       |  virtual void Write(const W& msg, void* tag) = 0;
  121|       |
  122|       |  /// Request the writing of \a msg using WriteOptions \a options with
  123|       |  /// identifying tag \a tag.
  124|       |  ///
  125|       |  /// Only one write may be outstanding at any given time. This means that
  126|       |  /// after calling Write, one must wait to receive \a tag from the completion
  127|       |  /// queue BEFORE calling Write again.
  128|       |  /// WriteOptions \a options is used to set the write options of this message.
  129|       |  /// This is thread-safe with respect to \a AsyncReaderInterface::Read
  130|       |  ///
  131|       |  /// gRPC doesn't take ownership or a reference to \a msg, so it is safe to
  132|       |  /// to deallocate once Write returns.
  133|       |  ///
  134|       |  /// \param[in] msg The message to be written.
  135|       |  /// \param[in] options The WriteOptions to be used to write this message.
  136|       |  /// \param[in] tag The tag identifying the operation.
  137|       |  virtual void Write(const W& msg, WriteOptions options, void* tag) = 0;
  138|       |
  139|       |  /// Request the writing of \a msg and coalesce it with the writing
  140|       |  /// of trailing metadata, using WriteOptions \a options with
  141|       |  /// identifying tag \a tag.
  142|       |  ///
  143|       |  /// For client, WriteLast is equivalent of performing Write and
  144|       |  /// WritesDone in a single step.
  145|       |  /// For server, WriteLast buffers the \a msg. The writing of \a msg is held
  146|       |  /// until Finish is called, where \a msg and trailing metadata are coalesced
  147|       |  /// and write is initiated. Note that WriteLast can only buffer \a msg up to
  148|       |  /// the flow control window size. If \a msg size is larger than the window
  149|       |  /// size, it will be sent on wire without buffering.
  150|       |  ///
  151|       |  /// gRPC doesn't take ownership or a reference to \a msg, so it is safe to
  152|       |  /// to deallocate once Write returns.
  153|       |  ///
  154|       |  /// \param[in] msg The message to be written.
  155|       |  /// \param[in] options The WriteOptions to be used to write this message.
  156|       |  /// \param[in] tag The tag identifying the operation.
  157|       |  void WriteLast(const W& msg, WriteOptions options, void* tag) {
  158|       |    Write(msg, options.set_last_message(), tag);
  159|       |  }
  160|       |};
  161|       |
  162|       |}  // namespace internal
  163|       |
  164|       |template <class R>
  165|       |class ClientAsyncReaderInterface
  166|       |    : public internal::ClientAsyncStreamingInterface,
  167|       |      public internal::AsyncReaderInterface<R> {};
  168|       |
  169|       |namespace internal {
  170|       |template <class R>
  171|       |class ClientAsyncReaderFactory {
  172|       | public:
  173|       |  /// Create a stream object.
  174|       |  /// Write the first request out if \a start is set.
  175|       |  /// \a tag will be notified on \a cq when the call has been started and
  176|       |  /// \a request has been written out. If \a start is not set, \a tag must be
  177|       |  /// nullptr and the actual call must be initiated by StartCall
  178|       |  /// Note that \a context will be used to fill in custom initial metadata
  179|       |  /// used to send to the server when starting the call.
  180|       |  template <class W>
  181|       |  static ClientAsyncReader<R>* Create(ChannelInterface* channel,
  182|       |                                      CompletionQueue* cq,
  183|       |                                      const ::grpc::internal::RpcMethod& method,
  184|       |                                      ClientContext* context, const W& request,
  185|       |                                      bool start, void* tag) {
  186|       |    ::grpc::internal::Call call = channel->CreateCall(method, context, cq);
  187|       |    return new (g_core_codegen_interface->grpc_call_arena_alloc(
  188|       |        call.call(), sizeof(ClientAsyncReader<R>)))
  189|       |        ClientAsyncReader<R>(call, context, request, start, tag);
  190|       |  }
  191|       |};
  192|       |}  // namespace internal
  193|       |
  194|       |/// Async client-side API for doing server-streaming RPCs,
  195|       |/// where the incoming message stream coming from the server has
  196|       |/// messages of type \a R.
  197|       |template <class R>
  198|       |class ClientAsyncReader final : public ClientAsyncReaderInterface<R> {
  199|       | public:
  200|       |  // always allocated against a call arena, no memory free required
  201|       |  static void operator delete(void* ptr, std::size_t size) {
  202|       |    assert(size == sizeof(ClientAsyncReader));
  203|       |  }
  204|       |
  205|       |  // This operator should never be called as the memory should be freed as part
  206|       |  // of the arena destruction. It only exists to provide a matching operator
  207|       |  // delete to the operator new so that some compilers will not complain (see
  208|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
  209|       |  // there are no tests catching the compiler warning.
  210|       |  static void operator delete(void*, void*) { assert(0); }
  211|       |
  212|       |  void StartCall(void* tag) override {
  213|       |    assert(!started_);
  214|       |    started_ = true;
  215|       |    StartCallInternal(tag);
  216|       |  }
  217|       |
  218|       |  /// See the \a ClientAsyncStreamingInterface.ReadInitialMetadata
  219|       |  /// method for semantics.
  220|       |  ///
  221|       |  /// Side effect:
  222|       |  ///   - upon receiving initial metadata from the server,
  223|       |  ///     the \a ClientContext associated with this call is updated, and the
  224|       |  ///     calling code can access the received metadata through the
  225|       |  ///     \a ClientContext.
  226|       |  void ReadInitialMetadata(void* tag) override {
  227|       |    assert(started_);
  228|       |    GPR_CODEGEN_ASSERT(!context_->initial_metadata_received_);
  229|       |
  230|       |    meta_ops_.set_output_tag(tag);
  231|       |    meta_ops_.RecvInitialMetadata(context_);
  232|       |    call_.PerformOps(&meta_ops_);
  233|       |  }
  234|       |
  235|       |  void Read(R* msg, void* tag) override {
  236|       |    assert(started_);
  237|       |    read_ops_.set_output_tag(tag);
  238|       |    if (!context_->initial_metadata_received_) {
  239|       |      read_ops_.RecvInitialMetadata(context_);
  240|       |    }
  241|       |    read_ops_.RecvMessage(msg);
  242|       |    call_.PerformOps(&read_ops_);
  243|       |  }
  244|       |
  245|       |  /// See the \a ClientAsyncStreamingInterface.Finish method for semantics.
  246|       |  ///
  247|       |  /// Side effect:
  248|       |  ///   - the \a ClientContext associated with this call is updated with
  249|       |  ///     possible initial and trailing metadata received from the server.
  250|       |  void Finish(Status* status, void* tag) override {
  251|       |    assert(started_);
  252|       |    finish_ops_.set_output_tag(tag);
  253|       |    if (!context_->initial_metadata_received_) {
  254|       |      finish_ops_.RecvInitialMetadata(context_);
  255|       |    }
  256|       |    finish_ops_.ClientRecvStatus(context_, status);
  257|       |    call_.PerformOps(&finish_ops_);
  258|       |  }
  259|       |
  260|       | private:
  261|       |  friend class internal::ClientAsyncReaderFactory<R>;
  262|       |  template <class W>
  263|       |  ClientAsyncReader(::grpc::internal::Call call, ClientContext* context,
  264|       |                    const W& request, bool start, void* tag)
  265|       |      : context_(context), call_(call), started_(start) {
  266|       |    // TODO(ctiller): don't assert
  267|       |    GPR_CODEGEN_ASSERT(init_ops_.SendMessage(request).ok());
  268|       |    init_ops_.ClientSendClose();
  269|       |    if (start) {
  270|       |      StartCallInternal(tag);
  271|       |    } else {
  272|       |      assert(tag == nullptr);
  273|       |    }
  274|       |  }
  275|       |
  276|       |  void StartCallInternal(void* tag) {
  277|       |    init_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  278|       |                                  context_->initial_metadata_flags());
  279|       |    init_ops_.set_output_tag(tag);
  280|       |    call_.PerformOps(&init_ops_);
  281|       |  }
  282|       |
  283|       |  ClientContext* context_;
  284|       |  ::grpc::internal::Call call_;
  285|       |  bool started_;
  286|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  287|       |                              ::grpc::internal::CallOpSendMessage,
  288|       |                              ::grpc::internal::CallOpClientSendClose>
  289|       |      init_ops_;
  290|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata>
  291|       |      meta_ops_;
  292|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata,
  293|       |                              ::grpc::internal::CallOpRecvMessage<R>>
  294|       |      read_ops_;
  295|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata,
  296|       |                              ::grpc::internal::CallOpClientRecvStatus>
  297|       |      finish_ops_;
  298|       |};
  299|       |
  300|       |/// Common interface for client side asynchronous writing.
  301|       |template <class W>
  302|       |class ClientAsyncWriterInterface
  303|       |    : public internal::ClientAsyncStreamingInterface,
  304|       |      public internal::AsyncWriterInterface<W> {
  305|       | public:
  306|       |  /// Signal the client is done with the writes (half-close the client stream).
  307|       |  /// Thread-safe with respect to \a AsyncReaderInterface::Read
  308|       |  ///
  309|       |  /// \param[in] tag The tag identifying the operation.
  310|       |  virtual void WritesDone(void* tag) = 0;
  311|       |};
  312|       |
  313|       |namespace internal {
  314|       |template <class W>
  315|       |class ClientAsyncWriterFactory {
  316|       | public:
  317|       |  /// Create a stream object.
  318|       |  /// Start the RPC if \a start is set
  319|       |  /// \a tag will be notified on \a cq when the call has been started (i.e.
  320|       |  /// intitial metadata sent) and \a request has been written out.
  321|       |  /// If \a start is not set, \a tag must be nullptr and the actual call
  322|       |  /// must be initiated by StartCall
  323|       |  /// Note that \a context will be used to fill in custom initial metadata
  324|       |  /// used to send to the server when starting the call.
  325|       |  /// \a response will be filled in with the single expected response
  326|       |  /// message from the server upon a successful call to the \a Finish
  327|       |  /// method of this instance.
  328|       |  template <class R>
  329|       |  static ClientAsyncWriter<W>* Create(ChannelInterface* channel,
  330|       |                                      CompletionQueue* cq,
  331|       |                                      const ::grpc::internal::RpcMethod& method,
  332|       |                                      ClientContext* context, R* response,
  333|       |                                      bool start, void* tag) {
  334|       |    ::grpc::internal::Call call = channel->CreateCall(method, context, cq);
  335|       |    return new (g_core_codegen_interface->grpc_call_arena_alloc(
  336|       |        call.call(), sizeof(ClientAsyncWriter<W>)))
  337|       |        ClientAsyncWriter<W>(call, context, response, start, tag);
  338|       |  }
  339|       |};
  340|       |}  // namespace internal
  341|       |
  342|       |/// Async API on the client side for doing client-streaming RPCs,
  343|       |/// where the outgoing message stream going to the server contains
  344|       |/// messages of type \a W.
  345|       |template <class W>
  346|       |class ClientAsyncWriter final : public ClientAsyncWriterInterface<W> {
  347|       | public:
  348|       |  // always allocated against a call arena, no memory free required
  349|       |  static void operator delete(void* ptr, std::size_t size) {
  350|       |    assert(size == sizeof(ClientAsyncWriter));
  351|       |  }
  352|       |
  353|       |  // This operator should never be called as the memory should be freed as part
  354|       |  // of the arena destruction. It only exists to provide a matching operator
  355|       |  // delete to the operator new so that some compilers will not complain (see
  356|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
  357|       |  // there are no tests catching the compiler warning.
  358|       |  static void operator delete(void*, void*) { assert(0); }
  359|       |
  360|       |  void StartCall(void* tag) override {
  361|       |    assert(!started_);
  362|       |    started_ = true;
  363|       |    StartCallInternal(tag);
  364|       |  }
  365|       |
  366|       |  /// See the \a ClientAsyncStreamingInterface.ReadInitialMetadata method for
  367|       |  /// semantics.
  368|       |  ///
  369|       |  /// Side effect:
  370|       |  ///   - upon receiving initial metadata from the server, the \a ClientContext
  371|       |  ///     associated with this call is updated, and the calling code can access
  372|       |  ///     the received metadata through the \a ClientContext.
  373|       |  void ReadInitialMetadata(void* tag) override {
  374|       |    assert(started_);
  375|       |    GPR_CODEGEN_ASSERT(!context_->initial_metadata_received_);
  376|       |
  377|       |    meta_ops_.set_output_tag(tag);
  378|       |    meta_ops_.RecvInitialMetadata(context_);
  379|       |    call_.PerformOps(&meta_ops_);
  380|       |  }
  381|       |
  382|       |  void Write(const W& msg, void* tag) override {
  383|       |    assert(started_);
  384|       |    write_ops_.set_output_tag(tag);
  385|       |    // TODO(ctiller): don't assert
  386|       |    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg).ok());
  387|       |    call_.PerformOps(&write_ops_);
  388|       |  }
  389|       |
  390|       |  void Write(const W& msg, WriteOptions options, void* tag) override {
  391|       |    assert(started_);
  392|       |    write_ops_.set_output_tag(tag);
  393|       |    if (options.is_last_message()) {
  394|       |      options.set_buffer_hint();
  395|       |      write_ops_.ClientSendClose();
  396|       |    }
  397|       |    // TODO(ctiller): don't assert
  398|       |    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg, options).ok());
  399|       |    call_.PerformOps(&write_ops_);
  400|       |  }
  401|       |
  402|       |  void WritesDone(void* tag) override {
  403|       |    assert(started_);
  404|       |    write_ops_.set_output_tag(tag);
  405|       |    write_ops_.ClientSendClose();
  406|       |    call_.PerformOps(&write_ops_);
  407|       |  }
  408|       |
  409|       |  /// See the \a ClientAsyncStreamingInterface.Finish method for semantics.
  410|       |  ///
  411|       |  /// Side effect:
  412|       |  ///   - the \a ClientContext associated with this call is updated with
  413|       |  ///     possible initial and trailing metadata received from the server.
  414|       |  ///   - attempts to fill in the \a response parameter passed to this class's
  415|       |  ///     constructor with the server's response message.
  416|       |  void Finish(Status* status, void* tag) override {
  417|       |    assert(started_);
  418|       |    finish_ops_.set_output_tag(tag);
  419|       |    if (!context_->initial_metadata_received_) {
  420|       |      finish_ops_.RecvInitialMetadata(context_);
  421|       |    }
  422|       |    finish_ops_.ClientRecvStatus(context_, status);
  423|       |    call_.PerformOps(&finish_ops_);
  424|       |  }
  425|       |
  426|       | private:
  427|       |  friend class internal::ClientAsyncWriterFactory<W>;
  428|       |  template <class R>
  429|       |  ClientAsyncWriter(::grpc::internal::Call call, ClientContext* context,
  430|       |                    R* response, bool start, void* tag)
  431|       |      : context_(context), call_(call), started_(start) {
  432|       |    finish_ops_.RecvMessage(response);
  433|       |    finish_ops_.AllowNoMessage();
  434|       |    if (start) {
  435|       |      StartCallInternal(tag);
  436|       |    } else {
  437|       |      assert(tag == nullptr);
  438|       |    }
  439|       |  }
  440|       |
  441|       |  void StartCallInternal(void* tag) {
  442|       |    write_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  443|       |                                   context_->initial_metadata_flags());
  444|       |    // if corked bit is set in context, we just keep the initial metadata
  445|       |    // buffered up to coalesce with later message send. No op is performed.
  446|       |    if (!context_->initial_metadata_corked_) {
  447|       |      write_ops_.set_output_tag(tag);
  448|       |      call_.PerformOps(&write_ops_);
  449|       |    }
  450|       |  }
  451|       |
  452|       |  ClientContext* context_;
  453|       |  ::grpc::internal::Call call_;
  454|       |  bool started_;
  455|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata>
  456|       |      meta_ops_;
  457|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  458|       |                              ::grpc::internal::CallOpSendMessage,
  459|       |                              ::grpc::internal::CallOpClientSendClose>
  460|       |      write_ops_;
  461|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata,
  462|       |                              ::grpc::internal::CallOpGenericRecvMessage,
  463|       |                              ::grpc::internal::CallOpClientRecvStatus>
  464|       |      finish_ops_;
  465|       |};
  466|       |
  467|       |/// Async client-side interface for bi-directional streaming,
  468|       |/// where the client-to-server message stream has messages of type \a W,
  469|       |/// and the server-to-client message stream has messages of type \a R.
  470|       |template <class W, class R>
  471|       |class ClientAsyncReaderWriterInterface
  472|       |    : public internal::ClientAsyncStreamingInterface,
  473|       |      public internal::AsyncWriterInterface<W>,
  474|       |      public internal::AsyncReaderInterface<R> {
  475|       | public:
  476|       |  /// Signal the client is done with the writes (half-close the client stream).
  477|       |  /// Thread-safe with respect to \a AsyncReaderInterface::Read
  478|       |  ///
  479|       |  /// \param[in] tag The tag identifying the operation.
  480|       |  virtual void WritesDone(void* tag) = 0;
  481|       |};
  482|       |
  483|       |namespace internal {
  484|       |template <class W, class R>
  485|       |class ClientAsyncReaderWriterFactory {
  486|       | public:
  487|       |  /// Create a stream object.
  488|       |  /// Start the RPC request if \a start is set.
  489|       |  /// \a tag will be notified on \a cq when the call has been started (i.e.
  490|       |  /// intitial metadata sent). If \a start is not set, \a tag must be
  491|       |  /// nullptr and the actual call must be initiated by StartCall
  492|       |  /// Note that \a context will be used to fill in custom initial metadata
  493|       |  /// used to send to the server when starting the call.
  494|       |  static ClientAsyncReaderWriter<W, R>* Create(
  495|       |      ChannelInterface* channel, CompletionQueue* cq,
  496|       |      const ::grpc::internal::RpcMethod& method, ClientContext* context,
  497|      0|      bool start, void* tag) {
  498|      0|    ::grpc::internal::Call call = channel->CreateCall(method, context, cq);
  499|      0|
  500|      0|    return new (g_core_codegen_interface->grpc_call_arena_alloc(
  501|      0|        call.call(), sizeof(ClientAsyncReaderWriter<W, R>)))
  502|      0|        ClientAsyncReaderWriter<W, R>(call, context, start, tag);
  503|      0|  }
  504|       |};
  505|       |}  // namespace internal
  506|       |
  507|       |/// Async client-side interface for bi-directional streaming,
  508|       |/// where the outgoing message stream going to the server
  509|       |/// has messages of type \a W,  and the incoming message stream coming
  510|       |/// from the server has messages of type \a R.
  511|       |template <class W, class R>
  512|       |class ClientAsyncReaderWriter final
  513|       |    : public ClientAsyncReaderWriterInterface<W, R> {
  514|       | public:
  515|       |  // always allocated against a call arena, no memory free required
  516|      0|  static void operator delete(void* ptr, std::size_t size) {
  517|      0|    assert(size == sizeof(ClientAsyncReaderWriter));
  518|      0|  }
  519|       |
  520|       |  // This operator should never be called as the memory should be freed as part
  521|       |  // of the arena destruction. It only exists to provide a matching operator
  522|       |  // delete to the operator new so that some compilers will not complain (see
  523|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
  524|       |  // there are no tests catching the compiler warning.
  525|      0|  static void operator delete(void*, void*) { assert(0); }
  526|       |
  527|      0|  void StartCall(void* tag) override {
  528|      0|    assert(!started_);
  529|      0|    started_ = true;
  530|      0|    StartCallInternal(tag);
  531|      0|  }
  532|       |
  533|       |  /// See the \a ClientAsyncStreamingInterface.ReadInitialMetadata method
  534|       |  /// for semantics of this method.
  535|       |  ///
  536|       |  /// Side effect:
  537|       |  ///   - upon receiving initial metadata from the server, the \a ClientContext
  538|       |  ///     is updated with it, and then the receiving initial metadata can
  539|       |  ///     be accessed through this \a ClientContext.
  540|      0|  void ReadInitialMetadata(void* tag) override {
  541|      0|    assert(started_);
  542|      0|    GPR_CODEGEN_ASSERT(!context_->initial_metadata_received_);
  543|      0|
  544|      0|    meta_ops_.set_output_tag(tag);
  545|      0|    meta_ops_.RecvInitialMetadata(context_);
  546|      0|    call_.PerformOps(&meta_ops_);
  547|      0|  }
  548|       |
  549|      0|  void Read(R* msg, void* tag) override {
  550|      0|    assert(started_);
  551|      0|    read_ops_.set_output_tag(tag);
  552|      0|    if (!context_->initial_metadata_received_) {
  553|      0|      read_ops_.RecvInitialMetadata(context_);
  554|      0|    }
  555|      0|    read_ops_.RecvMessage(msg);
  556|      0|    call_.PerformOps(&read_ops_);
  557|      0|  }
  558|       |
  559|      0|  void Write(const W& msg, void* tag) override {
  560|      0|    assert(started_);
  561|      0|    write_ops_.set_output_tag(tag);
  562|      0|    // TODO(ctiller): don't assert
  563|      0|    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg).ok());
  564|      0|    call_.PerformOps(&write_ops_);
  565|      0|  }
  566|       |
  567|      0|  void Write(const W& msg, WriteOptions options, void* tag) override {
  568|      0|    assert(started_);
  569|      0|    write_ops_.set_output_tag(tag);
  570|      0|    if (options.is_last_message()) {
  571|      0|      options.set_buffer_hint();
  572|      0|      write_ops_.ClientSendClose();
  573|      0|    }
  574|      0|    // TODO(ctiller): don't assert
  575|      0|    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg, options).ok());
  576|      0|    call_.PerformOps(&write_ops_);
  577|      0|  }
  578|       |
  579|      0|  void WritesDone(void* tag) override {
  580|      0|    assert(started_);
  581|      0|    write_ops_.set_output_tag(tag);
  582|      0|    write_ops_.ClientSendClose();
  583|      0|    call_.PerformOps(&write_ops_);
  584|      0|  }
  585|       |
  586|       |  /// See the \a ClientAsyncStreamingInterface.Finish method for semantics.
  587|       |  /// Side effect
  588|       |  ///   - the \a ClientContext associated with this call is updated with
  589|       |  ///     possible initial and trailing metadata sent from the server.
  590|      0|  void Finish(Status* status, void* tag) override {
  591|      0|    assert(started_);
  592|      0|    finish_ops_.set_output_tag(tag);
  593|      0|    if (!context_->initial_metadata_received_) {
  594|      0|      finish_ops_.RecvInitialMetadata(context_);
  595|      0|    }
  596|      0|    finish_ops_.ClientRecvStatus(context_, status);
  597|      0|    call_.PerformOps(&finish_ops_);
  598|      0|  }
  599|       |
  600|       | private:
  601|       |  friend class internal::ClientAsyncReaderWriterFactory<W, R>;
  602|       |  ClientAsyncReaderWriter(::grpc::internal::Call call, ClientContext* context,
  603|       |                          bool start, void* tag)
  604|      0|      : context_(context), call_(call), started_(start) {
  605|      0|    if (start) {
  606|      0|      StartCallInternal(tag);
  607|      0|    } else {
  608|      0|      assert(tag == nullptr);
  609|      0|    }
  610|      0|  }
  611|       |
  612|      0|  void StartCallInternal(void* tag) {
  613|      0|    write_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  614|      0|                                   context_->initial_metadata_flags());
  615|      0|    // if corked bit is set in context, we just keep the initial metadata
  616|      0|    // buffered up to coalesce with later message send. No op is performed.
  617|      0|    if (!context_->initial_metadata_corked_) {
  618|      0|      write_ops_.set_output_tag(tag);
  619|      0|      call_.PerformOps(&write_ops_);
  620|      0|    }
  621|      0|  }
  622|       |
  623|       |  ClientContext* context_;
  624|       |  ::grpc::internal::Call call_;
  625|       |  bool started_;
  626|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata>
  627|       |      meta_ops_;
  628|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata,
  629|       |                              ::grpc::internal::CallOpRecvMessage<R>>
  630|       |      read_ops_;
  631|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  632|       |                              ::grpc::internal::CallOpSendMessage,
  633|       |                              ::grpc::internal::CallOpClientSendClose>
  634|       |      write_ops_;
  635|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata,
  636|       |                              ::grpc::internal::CallOpClientRecvStatus>
  637|       |      finish_ops_;
  638|       |};
  639|       |
  640|       |template <class W, class R>
  641|       |class ServerAsyncReaderInterface
  642|       |    : public internal::ServerAsyncStreamingInterface,
  643|       |      public internal::AsyncReaderInterface<R> {
  644|       | public:
  645|       |  /// Indicate that the stream is to be finished with a certain status code
  646|       |  /// and also send out \a msg response to the client.
  647|       |  /// Request notification for when the server has sent the response and the
  648|       |  /// appropriate signals to the client to end the call.
  649|       |  /// Should not be used concurrently with other operations.
  650|       |  ///
  651|       |  /// It is appropriate to call this method when:
  652|       |  ///   * all messages from the client have been received (either known
  653|       |  ///     implictly, or explicitly because a previous
  654|       |  ///     \a AsyncReaderInterface::Read operation with a non-ok result,
  655|       |  ///     e.g., cq->Next(&read_tag, &ok) filled in 'ok' with 'false').
  656|       |  ///
  657|       |  /// This operation will end when the server has finished sending out initial
  658|       |  /// metadata (if not sent already), response message, and status, or if
  659|       |  /// some failure occurred when trying to do so.
  660|       |  ///
  661|       |  /// gRPC doesn't take ownership or a reference to \a msg or \a status, so it
  662|       |  /// is safe to deallocate once Finish returns.
  663|       |  ///
  664|       |  /// \param[in] tag Tag identifying this request.
  665|       |  /// \param[in] status To be sent to the client as the result of this call.
  666|       |  /// \param[in] msg To be sent to the client as the response for this call.
  667|       |  virtual void Finish(const W& msg, const Status& status, void* tag) = 0;
  668|       |
  669|       |  /// Indicate that the stream is to be finished with a certain
  670|       |  /// non-OK status code.
  671|       |  /// Request notification for when the server has sent the appropriate
  672|       |  /// signals to the client to end the call.
  673|       |  /// Should not be used concurrently with other operations.
  674|       |  ///
  675|       |  /// This call is meant to end the call with some error, and can be called at
  676|       |  /// any point that the server would like to "fail" the call (though note
  677|       |  /// this shouldn't be called concurrently with any other "sending" call, like
  678|       |  /// \a AsyncWriterInterface::Write).
  679|       |  ///
  680|       |  /// This operation will end when the server has finished sending out initial
  681|       |  /// metadata (if not sent already), and status, or if some failure occurred
  682|       |  /// when trying to do so.
  683|       |  ///
  684|       |  /// gRPC doesn't take ownership or a reference to \a status, so it is safe to
  685|       |  /// to deallocate once FinishWithError returns.
  686|       |  ///
  687|       |  /// \param[in] tag Tag identifying this request.
  688|       |  /// \param[in] status To be sent to the client as the result of this call.
  689|       |  ///     - Note: \a status must have a non-OK code.
  690|       |  virtual void FinishWithError(const Status& status, void* tag) = 0;
  691|       |};
  692|       |
  693|       |/// Async server-side API for doing client-streaming RPCs,
  694|       |/// where the incoming message stream from the client has messages of type \a R,
  695|       |/// and the single response message sent from the server is type \a W.
  696|       |template <class W, class R>
  697|       |class ServerAsyncReader final : public ServerAsyncReaderInterface<W, R> {
  698|       | public:
  699|       |  explicit ServerAsyncReader(ServerContext* ctx)
  700|       |      : call_(nullptr, nullptr, nullptr), ctx_(ctx) {}
  701|       |
  702|       |  /// See \a ServerAsyncStreamingInterface::SendInitialMetadata for semantics.
  703|       |  ///
  704|       |  /// Implicit input parameter:
  705|       |  ///   - The initial metadata that will be sent to the client from this op will
  706|       |  ///     be taken from the \a ServerContext associated with the call.
  707|       |  void SendInitialMetadata(void* tag) override {
  708|       |    GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
  709|       |
  710|       |    meta_ops_.set_output_tag(tag);
  711|       |    meta_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  712|       |                                  ctx_->initial_metadata_flags());
  713|       |    if (ctx_->compression_level_set()) {
  714|       |      meta_ops_.set_compression_level(ctx_->compression_level());
  715|       |    }
  716|       |    ctx_->sent_initial_metadata_ = true;
  717|       |    call_.PerformOps(&meta_ops_);
  718|       |  }
  719|       |
  720|       |  void Read(R* msg, void* tag) override {
  721|       |    read_ops_.set_output_tag(tag);
  722|       |    read_ops_.RecvMessage(msg);
  723|       |    call_.PerformOps(&read_ops_);
  724|       |  }
  725|       |
  726|       |  /// See the \a ServerAsyncReaderInterface.Read method for semantics
  727|       |  ///
  728|       |  /// Side effect:
  729|       |  ///   - also sends initial metadata if not alreay sent.
  730|       |  ///   - uses the \a ServerContext associated with this call to send possible
  731|       |  ///     initial and trailing metadata.
  732|       |  ///
  733|       |  /// Note: \a msg is not sent if \a status has a non-OK code.
  734|       |  ///
  735|       |  /// gRPC doesn't take ownership or a reference to \a msg and \a status, so it
  736|       |  /// is safe to deallocate once Finish returns.
  737|       |  void Finish(const W& msg, const Status& status, void* tag) override {
  738|       |    finish_ops_.set_output_tag(tag);
  739|       |    if (!ctx_->sent_initial_metadata_) {
  740|       |      finish_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  741|       |                                      ctx_->initial_metadata_flags());
  742|       |      if (ctx_->compression_level_set()) {
  743|       |        finish_ops_.set_compression_level(ctx_->compression_level());
  744|       |      }
  745|       |      ctx_->sent_initial_metadata_ = true;
  746|       |    }
  747|       |    // The response is dropped if the status is not OK.
  748|       |    if (status.ok()) {
  749|       |      finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_,
  750|       |                                   finish_ops_.SendMessage(msg));
  751|       |    } else {
  752|       |      finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_, status);
  753|       |    }
  754|       |    call_.PerformOps(&finish_ops_);
  755|       |  }
  756|       |
  757|       |  /// See the \a ServerAsyncReaderInterface.Read method for semantics
  758|       |  ///
  759|       |  /// Side effect:
  760|       |  ///   - also sends initial metadata if not alreay sent.
  761|       |  ///   - uses the \a ServerContext associated with this call to send possible
  762|       |  ///     initial and trailing metadata.
  763|       |  ///
  764|       |  /// gRPC doesn't take ownership or a reference to \a status, so it is safe to
  765|       |  /// to deallocate once FinishWithError returns.
  766|       |  void FinishWithError(const Status& status, void* tag) override {
  767|       |    GPR_CODEGEN_ASSERT(!status.ok());
  768|       |    finish_ops_.set_output_tag(tag);
  769|       |    if (!ctx_->sent_initial_metadata_) {
  770|       |      finish_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  771|       |                                      ctx_->initial_metadata_flags());
  772|       |      if (ctx_->compression_level_set()) {
  773|       |        finish_ops_.set_compression_level(ctx_->compression_level());
  774|       |      }
  775|       |      ctx_->sent_initial_metadata_ = true;
  776|       |    }
  777|       |    finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_, status);
  778|       |    call_.PerformOps(&finish_ops_);
  779|       |  }
  780|       |
  781|       | private:
  782|       |  void BindCall(::grpc::internal::Call* call) override { call_ = *call; }
  783|       |
  784|       |  ::grpc::internal::Call call_;
  785|       |  ServerContext* ctx_;
  786|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata>
  787|       |      meta_ops_;
  788|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvMessage<R>> read_ops_;
  789|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  790|       |                              ::grpc::internal::CallOpSendMessage,
  791|       |                              ::grpc::internal::CallOpServerSendStatus>
  792|       |      finish_ops_;
  793|       |};
  794|       |
  795|       |template <class W>
  796|       |class ServerAsyncWriterInterface
  797|       |    : public internal::ServerAsyncStreamingInterface,
  798|       |      public internal::AsyncWriterInterface<W> {
  799|       | public:
  800|       |  /// Indicate that the stream is to be finished with a certain status code.
  801|       |  /// Request notification for when the server has sent the appropriate
  802|       |  /// signals to the client to end the call.
  803|       |  /// Should not be used concurrently with other operations.
  804|       |  ///
  805|       |  /// It is appropriate to call this method when either:
  806|       |  ///   * all messages from the client have been received (either known
  807|       |  ///     implictly, or explicitly because a previous \a
  808|       |  ///     AsyncReaderInterface::Read operation with a non-ok
  809|       |  ///     result (e.g., cq->Next(&read_tag, &ok) filled in 'ok' with 'false'.
  810|       |  ///   * it is desired to end the call early with some non-OK status code.
  811|       |  ///
  812|       |  /// This operation will end when the server has finished sending out initial
  813|       |  /// metadata (if not sent already), response message, and status, or if
  814|       |  /// some failure occurred when trying to do so.
  815|       |  ///
  816|       |  /// gRPC doesn't take ownership or a reference to \a status, so it is safe to
  817|       |  /// to deallocate once Finish returns.
  818|       |  ///
  819|       |  /// \param[in] tag Tag identifying this request.
  820|       |  /// \param[in] status To be sent to the client as the result of this call.
  821|       |  virtual void Finish(const Status& status, void* tag) = 0;
  822|       |
  823|       |  /// Request the writing of \a msg and coalesce it with trailing metadata which
  824|       |  /// contains \a status, using WriteOptions options with
  825|       |  /// identifying tag \a tag.
  826|       |  ///
  827|       |  /// WriteAndFinish is equivalent of performing WriteLast and Finish
  828|       |  /// in a single step.
  829|       |  ///
  830|       |  /// gRPC doesn't take ownership or a reference to \a msg and \a status, so it
  831|       |  /// is safe to deallocate once WriteAndFinish returns.
  832|       |  ///
  833|       |  /// \param[in] msg The message to be written.
  834|       |  /// \param[in] options The WriteOptions to be used to write this message.
  835|       |  /// \param[in] status The Status that server returns to client.
  836|       |  /// \param[in] tag The tag identifying the operation.
  837|       |  virtual void WriteAndFinish(const W& msg, WriteOptions options,
  838|       |                              const Status& status, void* tag) = 0;
  839|       |};
  840|       |
  841|       |/// Async server-side API for doing server streaming RPCs,
  842|       |/// where the outgoing message stream from the server has messages of type \a W.
  843|       |template <class W>
  844|       |class ServerAsyncWriter final : public ServerAsyncWriterInterface<W> {
  845|       | public:
  846|       |  explicit ServerAsyncWriter(ServerContext* ctx)
  847|      0|      : call_(nullptr, nullptr, nullptr), ctx_(ctx) {}
  848|       |
  849|       |  /// See \a ServerAsyncStreamingInterface::SendInitialMetadata for semantics.
  850|       |  ///
  851|       |  /// Implicit input parameter:
  852|       |  ///   - The initial metadata that will be sent to the client from this op will
  853|       |  ///     be taken from the \a ServerContext associated with the call.
  854|       |  ///
  855|       |  /// \param[in] tag Tag identifying this request.
  856|      0|  void SendInitialMetadata(void* tag) override {
  857|      0|    GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
  858|      0|
  859|      0|    meta_ops_.set_output_tag(tag);
  860|      0|    meta_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  861|      0|                                  ctx_->initial_metadata_flags());
  862|      0|    if (ctx_->compression_level_set()) {
  863|      0|      meta_ops_.set_compression_level(ctx_->compression_level());
  864|      0|    }
  865|      0|    ctx_->sent_initial_metadata_ = true;
  866|      0|    call_.PerformOps(&meta_ops_);
  867|      0|  }
  868|       |
  869|      0|  void Write(const W& msg, void* tag) override {
  870|      0|    write_ops_.set_output_tag(tag);
  871|      0|    EnsureInitialMetadataSent(&write_ops_);
  872|      0|    // TODO(ctiller): don't assert
  873|      0|    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg).ok());
  874|      0|    call_.PerformOps(&write_ops_);
  875|      0|  }
  876|       |
  877|      0|  void Write(const W& msg, WriteOptions options, void* tag) override {
  878|      0|    write_ops_.set_output_tag(tag);
  879|      0|    if (options.is_last_message()) {
  880|      0|      options.set_buffer_hint();
  881|      0|    }
  882|      0|
  883|      0|    EnsureInitialMetadataSent(&write_ops_);
  884|      0|    // TODO(ctiller): don't assert
  885|      0|    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg, options).ok());
  886|      0|    call_.PerformOps(&write_ops_);
  887|      0|  }
  888|       |
  889|       |  /// See the \a ServerAsyncWriterInterface.WriteAndFinish method for semantics.
  890|       |  ///
  891|       |  /// Implicit input parameter:
  892|       |  ///   - the \a ServerContext associated with this call is used
  893|       |  ///     for sending trailing (and initial) metadata to the client.
  894|       |  ///
  895|       |  /// Note: \a status must have an OK code.
  896|       |  ///
  897|       |  /// gRPC doesn't take ownership or a reference to \a msg and \a status, so it
  898|       |  /// is safe to deallocate once WriteAndFinish returns.
  899|       |  void WriteAndFinish(const W& msg, WriteOptions options, const Status& status,
  900|      0|                      void* tag) override {
  901|      0|    write_ops_.set_output_tag(tag);
  902|      0|    EnsureInitialMetadataSent(&write_ops_);
  903|      0|    options.set_buffer_hint();
  904|      0|    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg, options).ok());
  905|      0|    write_ops_.ServerSendStatus(&ctx_->trailing_metadata_, status);
  906|      0|    call_.PerformOps(&write_ops_);
  907|      0|  }
  908|       |
  909|       |  /// See the \a ServerAsyncWriterInterface.Finish method for semantics.
  910|       |  ///
  911|       |  /// Implicit input parameter:
  912|       |  ///   - the \a ServerContext associated with this call is used for sending
  913|       |  ///     trailing (and initial if not already sent) metadata to the client.
  914|       |  ///
  915|       |  /// Note: there are no restrictions are the code of
  916|       |  /// \a status,it may be non-OK
  917|       |  ///
  918|       |  /// gRPC doesn't take ownership or a reference to \a status, so it is safe to
  919|       |  /// to deallocate once Finish returns.
  920|      0|  void Finish(const Status& status, void* tag) override {
  921|      0|    finish_ops_.set_output_tag(tag);
  922|      0|    EnsureInitialMetadataSent(&finish_ops_);
  923|      0|    finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_, status);
  924|      0|    call_.PerformOps(&finish_ops_);
  925|      0|  }
  926|       |
  927|       | private:
  928|      0|  void BindCall(::grpc::internal::Call* call) override { call_ = *call; }
  929|       |
  930|       |  template <class T>
  931|      0|  void EnsureInitialMetadataSent(T* ops) {
  932|      0|    if (!ctx_->sent_initial_metadata_) {
  933|      0|      ops->SendInitialMetadata(&ctx_->initial_metadata_,
  934|      0|                               ctx_->initial_metadata_flags());
  935|      0|      if (ctx_->compression_level_set()) {
  936|      0|        ops->set_compression_level(ctx_->compression_level());
  937|      0|      }
  938|      0|      ctx_->sent_initial_metadata_ = true;
  939|      0|    }
  940|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc17ServerAsyncWriterINS_10ByteBufferEE25EnsureInitialMetadataSentINS_8internal9CallOpSetINS4_25CallOpSendInitialMetadataENS4_17CallOpSendMessageENS4_22CallOpServerSendStatusENS4_8CallNoOpILi4EEENS9_ILi5EEENS9_ILi6EEEEEEEvPT_
  ------------------
  | Unexecuted instantiation: _ZN4grpc17ServerAsyncWriterINS_10ByteBufferEE25EnsureInitialMetadataSentINS_8internal9CallOpSetINS4_25CallOpSendInitialMetadataENS4_22CallOpServerSendStatusENS4_8CallNoOpILi3EEENS8_ILi4EEENS8_ILi5EEENS8_ILi6EEEEEEEvPT_
  ------------------
  941|       |
  942|       |  ::grpc::internal::Call call_;
  943|       |  ServerContext* ctx_;
  944|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata>
  945|       |      meta_ops_;
  946|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  947|       |                              ::grpc::internal::CallOpSendMessage,
  948|       |                              ::grpc::internal::CallOpServerSendStatus>
  949|       |      write_ops_;
  950|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  951|       |                              ::grpc::internal::CallOpServerSendStatus>
  952|       |      finish_ops_;
  953|       |};
  954|       |
  955|       |/// Server-side interface for asynchronous bi-directional streaming.
  956|       |template <class W, class R>
  957|       |class ServerAsyncReaderWriterInterface
  958|       |    : public internal::ServerAsyncStreamingInterface,
  959|       |      public internal::AsyncWriterInterface<W>,
  960|       |      public internal::AsyncReaderInterface<R> {
  961|       | public:
  962|       |  /// Indicate that the stream is to be finished with a certain status code.
  963|       |  /// Request notification for when the server has sent the appropriate
  964|       |  /// signals to the client to end the call.
  965|       |  /// Should not be used concurrently with other operations.
  966|       |  ///
  967|       |  /// It is appropriate to call this method when either:
  968|       |  ///   * all messages from the client have been received (either known
  969|       |  ///     implictly, or explicitly because a previous \a
  970|       |  ///     AsyncReaderInterface::Read operation
  971|       |  ///     with a non-ok result (e.g., cq->Next(&read_tag, &ok) filled in 'ok'
  972|       |  ///     with 'false'.
  973|       |  ///   * it is desired to end the call early with some non-OK status code.
  974|       |  ///
  975|       |  /// This operation will end when the server has finished sending out initial
  976|       |  /// metadata (if not sent already), response message, and status, or if some
  977|       |  /// failure occurred when trying to do so.
  978|       |  ///
  979|       |  /// gRPC doesn't take ownership or a reference to \a status, so it is safe to
  980|       |  /// to deallocate once Finish returns.
  981|       |  ///
  982|       |  /// \param[in] tag Tag identifying this request.
  983|       |  /// \param[in] status To be sent to the client as the result of this call.
  984|       |  virtual void Finish(const Status& status, void* tag) = 0;
  985|       |
  986|       |  /// Request the writing of \a msg and coalesce it with trailing metadata which
  987|       |  /// contains \a status, using WriteOptions options with
  988|       |  /// identifying tag \a tag.
  989|       |  ///
  990|       |  /// WriteAndFinish is equivalent of performing WriteLast and Finish in a
  991|       |  /// single step.
  992|       |  ///
  993|       |  /// gRPC doesn't take ownership or a reference to \a msg and \a status, so it
  994|       |  /// is safe to deallocate once WriteAndFinish returns.
  995|       |  ///
  996|       |  /// \param[in] msg The message to be written.
  997|       |  /// \param[in] options The WriteOptions to be used to write this message.
  998|       |  /// \param[in] status The Status that server returns to client.
  999|       |  /// \param[in] tag The tag identifying the operation.
 1000|       |  virtual void WriteAndFinish(const W& msg, WriteOptions options,
 1001|       |                              const Status& status, void* tag) = 0;
 1002|       |};
 1003|       |
 1004|       |/// Async server-side API for doing bidirectional streaming RPCs,
 1005|       |/// where the incoming message stream coming from the client has messages of
 1006|       |/// type \a R, and the outgoing message stream coming from the server has
 1007|       |/// messages of type \a W.
 1008|       |template <class W, class R>
 1009|       |class ServerAsyncReaderWriter final
 1010|       |    : public ServerAsyncReaderWriterInterface<W, R> {
 1011|       | public:
 1012|       |  explicit ServerAsyncReaderWriter(ServerContext* ctx)
 1013|      0|      : call_(nullptr, nullptr, nullptr), ctx_(ctx) {}
 1014|       |
 1015|       |  /// See \a ServerAsyncStreamingInterface::SendInitialMetadata for semantics.
 1016|       |  ///
 1017|       |  /// Implicit input parameter:
 1018|       |  ///   - The initial metadata that will be sent to the client from this op will
 1019|       |  ///     be taken from the \a ServerContext associated with the call.
 1020|       |  ///
 1021|       |  /// \param[in] tag Tag identifying this request.
 1022|      0|  void SendInitialMetadata(void* tag) override {
 1023|      0|    GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
 1024|      0|
 1025|      0|    meta_ops_.set_output_tag(tag);
 1026|      0|    meta_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
 1027|      0|                                  ctx_->initial_metadata_flags());
 1028|      0|    if (ctx_->compression_level_set()) {
 1029|      0|      meta_ops_.set_compression_level(ctx_->compression_level());
 1030|      0|    }
 1031|      0|    ctx_->sent_initial_metadata_ = true;
 1032|      0|    call_.PerformOps(&meta_ops_);
 1033|      0|  }
 1034|       |
 1035|      0|  void Read(R* msg, void* tag) override {
 1036|      0|    read_ops_.set_output_tag(tag);
 1037|      0|    read_ops_.RecvMessage(msg);
 1038|      0|    call_.PerformOps(&read_ops_);
 1039|      0|  }
 1040|       |
 1041|      0|  void Write(const W& msg, void* tag) override {
 1042|      0|    write_ops_.set_output_tag(tag);
 1043|      0|    EnsureInitialMetadataSent(&write_ops_);
 1044|      0|    // TODO(ctiller): don't assert
 1045|      0|    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg).ok());
 1046|      0|    call_.PerformOps(&write_ops_);
 1047|      0|  }
 1048|       |
 1049|      0|  void Write(const W& msg, WriteOptions options, void* tag) override {
 1050|      0|    write_ops_.set_output_tag(tag);
 1051|      0|    if (options.is_last_message()) {
 1052|      0|      options.set_buffer_hint();
 1053|      0|    }
 1054|      0|    EnsureInitialMetadataSent(&write_ops_);
 1055|      0|    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg, options).ok());
 1056|      0|    call_.PerformOps(&write_ops_);
 1057|      0|  }
 1058|       |
 1059|       |  /// See the \a ServerAsyncReaderWriterInterface.WriteAndFinish
 1060|       |  /// method for semantics.
 1061|       |  ///
 1062|       |  /// Implicit input parameter:
 1063|       |  ///   - the \a ServerContext associated with this call is used
 1064|       |  ///     for sending trailing (and initial) metadata to the client.
 1065|       |  ///
 1066|       |  /// Note: \a status must have an OK code.
 1067|       |  //
 1068|       |  /// gRPC doesn't take ownership or a reference to \a msg and \a status, so it
 1069|       |  /// is safe to deallocate once WriteAndFinish returns.
 1070|       |  void WriteAndFinish(const W& msg, WriteOptions options, const Status& status,
 1071|      0|                      void* tag) override {
 1072|      0|    write_ops_.set_output_tag(tag);
 1073|      0|    EnsureInitialMetadataSent(&write_ops_);
 1074|      0|    options.set_buffer_hint();
 1075|      0|    GPR_CODEGEN_ASSERT(write_ops_.SendMessage(msg, options).ok());
 1076|      0|    write_ops_.ServerSendStatus(&ctx_->trailing_metadata_, status);
 1077|      0|    call_.PerformOps(&write_ops_);
 1078|      0|  }
 1079|       |
 1080|       |  /// See the \a ServerAsyncReaderWriterInterface.Finish method for semantics.
 1081|       |  ///
 1082|       |  /// Implicit input parameter:
 1083|       |  ///   - the \a ServerContext associated with this call is used for sending
 1084|       |  ///     trailing (and initial if not already sent) metadata to the client.
 1085|       |  ///
 1086|       |  /// Note: there are no restrictions are the code of \a status,
 1087|       |  /// it may be non-OK
 1088|       |  //
 1089|       |  /// gRPC doesn't take ownership or a reference to \a status, so it is safe to
 1090|       |  /// to deallocate once Finish returns.
 1091|      0|  void Finish(const Status& status, void* tag) override {
 1092|      0|    finish_ops_.set_output_tag(tag);
 1093|      0|    EnsureInitialMetadataSent(&finish_ops_);
 1094|      0|
 1095|      0|    finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_, status);
 1096|      0|    call_.PerformOps(&finish_ops_);
 1097|      0|  }
 1098|       |
 1099|       | private:
 1100|       |  friend class ::grpc_impl::Server;
 1101|       |
 1102|      0|  void BindCall(::grpc::internal::Call* call) override { call_ = *call; }
 1103|       |
 1104|       |  template <class T>
 1105|      0|  void EnsureInitialMetadataSent(T* ops) {
 1106|      0|    if (!ctx_->sent_initial_metadata_) {
 1107|      0|      ops->SendInitialMetadata(&ctx_->initial_metadata_,
 1108|      0|                               ctx_->initial_metadata_flags());
 1109|      0|      if (ctx_->compression_level_set()) {
 1110|      0|        ops->set_compression_level(ctx_->compression_level());
 1111|      0|      }
 1112|      0|      ctx_->sent_initial_metadata_ = true;
 1113|      0|    }
 1114|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc23ServerAsyncReaderWriterINS_10ByteBufferES1_E25EnsureInitialMetadataSentINS_8internal9CallOpSetINS4_25CallOpSendInitialMetadataENS4_22CallOpServerSendStatusENS4_8CallNoOpILi3EEENS8_ILi4EEENS8_ILi5EEENS8_ILi6EEEEEEEvPT_
  ------------------
  | Unexecuted instantiation: _ZN4grpc23ServerAsyncReaderWriterINS_10ByteBufferES1_E25EnsureInitialMetadataSentINS_8internal9CallOpSetINS4_25CallOpSendInitialMetadataENS4_17CallOpSendMessageENS4_22CallOpServerSendStatusENS4_8CallNoOpILi4EEENS9_ILi5EEENS9_ILi6EEEEEEEvPT_
  ------------------
 1115|       |
 1116|       |  ::grpc::internal::Call call_;
 1117|       |  ServerContext* ctx_;
 1118|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata>
 1119|       |      meta_ops_;
 1120|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvMessage<R>> read_ops_;
 1121|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
 1122|       |                              ::grpc::internal::CallOpSendMessage,
 1123|       |                              ::grpc::internal::CallOpServerSendStatus>
 1124|       |      write_ops_;
 1125|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
 1126|       |                              ::grpc::internal::CallOpServerSendStatus>
 1127|       |      finish_ops_;
 1128|       |};
 1129|       |
 1130|       |}  // namespace grpc
 1131|       |
 1132|       |#endif  // GRPCPP_IMPL_CODEGEN_ASYNC_STREAM_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/async_unary_call.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_ASYNC_UNARY_CALL_H
   20|       |#define GRPCPP_IMPL_CODEGEN_ASYNC_UNARY_CALL_H
   21|       |
   22|       |#include <assert.h>
   23|       |#include <grpcpp/impl/codegen/call.h>
   24|       |#include <grpcpp/impl/codegen/channel_interface.h>
   25|       |#include <grpcpp/impl/codegen/client_context.h>
   26|       |#include <grpcpp/impl/codegen/server_context.h>
   27|       |#include <grpcpp/impl/codegen/service_type.h>
   28|       |#include <grpcpp/impl/codegen/status.h>
   29|       |
   30|       |namespace grpc {
   31|       |
   32|       |extern CoreCodegenInterface* g_core_codegen_interface;
   33|       |
   34|       |/// An interface relevant for async client side unary RPCs (which send
   35|       |/// one request message to a server and receive one response message).
   36|       |template <class R>
   37|       |class ClientAsyncResponseReaderInterface {
   38|       | public:
   39|      0|  virtual ~ClientAsyncResponseReaderInterface() {}
   40|       |
   41|       |  /// Start the call that was set up by the constructor, but only if the
   42|       |  /// constructor was invoked through the "Prepare" API which doesn't actually
   43|       |  /// start the call
   44|       |  virtual void StartCall() = 0;
   45|       |
   46|       |  /// Request notification of the reading of initial metadata. Completion
   47|       |  /// will be notified by \a tag on the associated completion queue.
   48|       |  /// This call is optional, but if it is used, it cannot be used concurrently
   49|       |  /// with or after the \a Finish method.
   50|       |  ///
   51|       |  /// \param[in] tag Tag identifying this request.
   52|       |  virtual void ReadInitialMetadata(void* tag) = 0;
   53|       |
   54|       |  /// Request to receive the server's response \a msg and final \a status for
   55|       |  /// the call, and to notify \a tag on this call's completion queue when
   56|       |  /// finished.
   57|       |  ///
   58|       |  /// This function will return when either:
   59|       |  /// - when the server's response message and status have been received.
   60|       |  /// - when the server has returned a non-OK status (no message expected in
   61|       |  ///   this case).
   62|       |  /// - when the call failed for some reason and the library generated a
   63|       |  ///   non-OK status.
   64|       |  ///
   65|       |  /// \param[in] tag Tag identifying this request.
   66|       |  /// \param[out] status To be updated with the operation status.
   67|       |  /// \param[out] msg To be filled in with the server's response message.
   68|       |  virtual void Finish(R* msg, Status* status, void* tag) = 0;
   69|       |};
   70|       |
   71|       |namespace internal {
   72|       |template <class R>
   73|       |class ClientAsyncResponseReaderFactory {
   74|       | public:
   75|       |  /// Start a call and write the request out if \a start is set.
   76|       |  /// \a tag will be notified on \a cq when the call has been started (i.e.
   77|       |  /// intitial metadata sent) and \a request has been written out.
   78|       |  /// If \a start is not set, the actual call must be initiated by StartCall
   79|       |  /// Note that \a context will be used to fill in custom initial metadata
   80|       |  /// used to send to the server when starting the call.
   81|       |  template <class W>
   82|       |  static ClientAsyncResponseReader<R>* Create(
   83|       |      ChannelInterface* channel, CompletionQueue* cq,
   84|       |      const ::grpc::internal::RpcMethod& method, ClientContext* context,
   85|      0|      const W& request, bool start) {
   86|      0|    ::grpc::internal::Call call = channel->CreateCall(method, context, cq);
   87|      0|    return new (g_core_codegen_interface->grpc_call_arena_alloc(
   88|      0|        call.call(), sizeof(ClientAsyncResponseReader<R>)))
   89|      0|        ClientAsyncResponseReader<R>(call, context, request, start);
   90|      0|  }
   91|       |};
   92|       |}  // namespace internal
   93|       |
   94|       |/// Async API for client-side unary RPCs, where the message response
   95|       |/// received from the server is of type \a R.
   96|       |template <class R>
   97|       |class ClientAsyncResponseReader final
   98|       |    : public ClientAsyncResponseReaderInterface<R> {
   99|       | public:
  100|       |  // always allocated against a call arena, no memory free required
  101|      0|  static void operator delete(void* ptr, std::size_t size) {
  102|      0|    assert(size == sizeof(ClientAsyncResponseReader));
  103|      0|  }
  104|       |
  105|       |  // This operator should never be called as the memory should be freed as part
  106|       |  // of the arena destruction. It only exists to provide a matching operator
  107|       |  // delete to the operator new so that some compilers will not complain (see
  108|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
  109|       |  // there are no tests catching the compiler warning.
  110|      0|  static void operator delete(void*, void*) { assert(0); }
  111|       |
  112|      0|  void StartCall() override {
  113|      0|    assert(!started_);
  114|      0|    started_ = true;
  115|      0|    StartCallInternal();
  116|      0|  }
  117|       |
  118|       |  /// See \a ClientAsyncResponseReaderInterface::ReadInitialMetadata for
  119|       |  /// semantics.
  120|       |  ///
  121|       |  /// Side effect:
  122|       |  ///   - the \a ClientContext associated with this call is updated with
  123|       |  ///     possible initial and trailing metadata sent from the server.
  124|      0|  void ReadInitialMetadata(void* tag) override {
  125|      0|    assert(started_);
  126|      0|    GPR_CODEGEN_ASSERT(!context_->initial_metadata_received_);
  127|      0|
  128|      0|    single_buf.set_output_tag(tag);
  129|      0|    single_buf.RecvInitialMetadata(context_);
  130|      0|    call_.PerformOps(&single_buf);
  131|      0|    initial_metadata_read_ = true;
  132|      0|  }
  133|       |
  134|       |  /// See \a ClientAysncResponseReaderInterface::Finish for semantics.
  135|       |  ///
  136|       |  /// Side effect:
  137|       |  ///   - the \a ClientContext associated with this call is updated with
  138|       |  ///     possible initial and trailing metadata sent from the server.
  139|      0|  void Finish(R* msg, Status* status, void* tag) override {
  140|      0|    assert(started_);
  141|      0|    if (initial_metadata_read_) {
  142|      0|      finish_buf.set_output_tag(tag);
  143|      0|      finish_buf.RecvMessage(msg);
  144|      0|      finish_buf.AllowNoMessage();
  145|      0|      finish_buf.ClientRecvStatus(context_, status);
  146|      0|      call_.PerformOps(&finish_buf);
  147|      0|    } else {
  148|      0|      single_buf.set_output_tag(tag);
  149|      0|      single_buf.RecvInitialMetadata(context_);
  150|      0|      single_buf.RecvMessage(msg);
  151|      0|      single_buf.AllowNoMessage();
  152|      0|      single_buf.ClientRecvStatus(context_, status);
  153|      0|      call_.PerformOps(&single_buf);
  154|      0|    }
  155|      0|  }
  156|       |
  157|       | private:
  158|       |  friend class internal::ClientAsyncResponseReaderFactory<R>;
  159|       |  ClientContext* const context_;
  160|       |  ::grpc::internal::Call call_;
  161|       |  bool started_;
  162|       |  bool initial_metadata_read_ = false;
  163|       |
  164|       |  template <class W>
  165|       |  ClientAsyncResponseReader(::grpc::internal::Call call, ClientContext* context,
  166|       |                            const W& request, bool start)
  167|      0|      : context_(context), call_(call), started_(start) {
  168|      0|    // Bind the metadata at time of StartCallInternal but set up the rest here
  169|      0|    // TODO(ctiller): don't assert
  170|      0|    GPR_CODEGEN_ASSERT(single_buf.SendMessage(request).ok());
  171|      0|    single_buf.ClientSendClose();
  172|      0|    if (start) StartCallInternal();
  173|      0|  }
  174|       |
  175|      0|  void StartCallInternal() {
  176|      0|    single_buf.SendInitialMetadata(&context_->send_initial_metadata_,
  177|      0|                                   context_->initial_metadata_flags());
  178|      0|  }
  179|       |
  180|       |  // disable operator new
  181|       |  static void* operator new(std::size_t size);
  182|      0|  static void* operator new(std::size_t size, void* p) { return p; }
  183|       |
  184|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  185|       |                              ::grpc::internal::CallOpSendMessage,
  186|       |                              ::grpc::internal::CallOpClientSendClose,
  187|       |                              ::grpc::internal::CallOpRecvInitialMetadata,
  188|       |                              ::grpc::internal::CallOpRecvMessage<R>,
  189|       |                              ::grpc::internal::CallOpClientRecvStatus>
  190|       |      single_buf;
  191|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvMessage<R>,
  192|       |                              ::grpc::internal::CallOpClientRecvStatus>
  193|       |      finish_buf;
  194|       |};
  195|       |
  196|       |/// Async server-side API for handling unary calls, where the single
  197|       |/// response message sent to the client is of type \a W.
  198|       |template <class W>
  199|       |class ServerAsyncResponseWriter final
  200|       |    : public internal::ServerAsyncStreamingInterface {
  201|       | public:
  202|       |  explicit ServerAsyncResponseWriter(ServerContext* ctx)
  203|      0|      : call_(nullptr, nullptr, nullptr), ctx_(ctx) {}
  204|       |
  205|       |  /// See \a ServerAsyncStreamingInterface::SendInitialMetadata for semantics.
  206|       |  ///
  207|       |  /// Side effect:
  208|       |  ///   The initial metadata that will be sent to the client from this op will
  209|       |  ///   be taken from the \a ServerContext associated with the call.
  210|       |  ///
  211|       |  /// \param[in] tag Tag identifying this request.
  212|      0|  void SendInitialMetadata(void* tag) override {
  213|      0|    GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
  214|      0|
  215|      0|    meta_buf_.set_output_tag(tag);
  216|      0|    meta_buf_.SendInitialMetadata(&ctx_->initial_metadata_,
  217|      0|                                  ctx_->initial_metadata_flags());
  218|      0|    if (ctx_->compression_level_set()) {
  219|      0|      meta_buf_.set_compression_level(ctx_->compression_level());
  220|      0|    }
  221|      0|    ctx_->sent_initial_metadata_ = true;
  222|      0|    call_.PerformOps(&meta_buf_);
  223|      0|  }
  224|       |
  225|       |  /// Indicate that the stream is to be finished and request notification
  226|       |  /// when the server has sent the appropriate signals to the client to
  227|       |  /// end the call. Should not be used concurrently with other operations.
  228|       |  ///
  229|       |  /// \param[in] tag Tag identifying this request.
  230|       |  /// \param[in] status To be sent to the client as the result of the call.
  231|       |  /// \param[in] msg Message to be sent to the client.
  232|       |  ///
  233|       |  /// Side effect:
  234|       |  ///   - also sends initial metadata if not already sent (using the
  235|       |  ///     \a ServerContext associated with this call).
  236|       |  ///
  237|       |  /// Note: if \a status has a non-OK code, then \a msg will not be sent,
  238|       |  /// and the client will receive only the status with possible trailing
  239|       |  /// metadata.
  240|      0|  void Finish(const W& msg, const Status& status, void* tag) {
  241|      0|    finish_buf_.set_output_tag(tag);
  242|      0|    finish_buf_.set_core_cq_tag(&finish_buf_);
  243|      0|    if (!ctx_->sent_initial_metadata_) {
  244|      0|      finish_buf_.SendInitialMetadata(&ctx_->initial_metadata_,
  245|      0|                                      ctx_->initial_metadata_flags());
  246|      0|      if (ctx_->compression_level_set()) {
  247|      0|        finish_buf_.set_compression_level(ctx_->compression_level());
  248|      0|      }
  249|      0|      ctx_->sent_initial_metadata_ = true;
  250|      0|    }
  251|      0|    // The response is dropped if the status is not OK.
  252|      0|    if (status.ok()) {
  253|      0|      finish_buf_.ServerSendStatus(&ctx_->trailing_metadata_,
  254|      0|                                   finish_buf_.SendMessage(msg));
  255|      0|    } else {
  256|      0|      finish_buf_.ServerSendStatus(&ctx_->trailing_metadata_, status);
  257|      0|    }
  258|      0|    call_.PerformOps(&finish_buf_);
  259|      0|  }
  260|       |
  261|       |  /// Indicate that the stream is to be finished with a non-OK status,
  262|       |  /// and request notification for when the server has finished sending the
  263|       |  /// appropriate signals to the client to end the call.
  264|       |  /// Should not be used concurrently with other operations.
  265|       |  ///
  266|       |  /// \param[in] tag Tag identifying this request.
  267|       |  /// \param[in] status To be sent to the client as the result of the call.
  268|       |  ///   - Note: \a status must have a non-OK code.
  269|       |  ///
  270|       |  /// Side effect:
  271|       |  ///   - also sends initial metadata if not already sent (using the
  272|       |  ///     \a ServerContext associated with this call).
  273|      0|  void FinishWithError(const Status& status, void* tag) {
  274|      0|    GPR_CODEGEN_ASSERT(!status.ok());
  275|      0|    finish_buf_.set_output_tag(tag);
  276|      0|    if (!ctx_->sent_initial_metadata_) {
  277|      0|      finish_buf_.SendInitialMetadata(&ctx_->initial_metadata_,
  278|      0|                                      ctx_->initial_metadata_flags());
  279|      0|      if (ctx_->compression_level_set()) {
  280|      0|        finish_buf_.set_compression_level(ctx_->compression_level());
  281|      0|      }
  282|      0|      ctx_->sent_initial_metadata_ = true;
  283|      0|    }
  284|      0|    finish_buf_.ServerSendStatus(&ctx_->trailing_metadata_, status);
  285|      0|    call_.PerformOps(&finish_buf_);
  286|      0|  }
  287|       |
  288|       | private:
  289|      0|  void BindCall(::grpc::internal::Call* call) override { call_ = *call; }
  290|       |
  291|       |  ::grpc::internal::Call call_;
  292|       |  ServerContext* ctx_;
  293|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata>
  294|       |      meta_buf_;
  295|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  296|       |                              ::grpc::internal::CallOpSendMessage,
  297|       |                              ::grpc::internal::CallOpServerSendStatus>
  298|       |      finish_buf_;
  299|       |};
  300|       |
  301|       |}  // namespace grpc
  302|       |
  303|       |namespace std {
  304|       |template <class R>
  305|       |class default_delete<grpc::ClientAsyncResponseReader<R>> {
  306|       | public:
  307|      0|  void operator()(void* p) {}
  308|       |};
  309|       |template <class R>
  310|       |class default_delete<grpc::ClientAsyncResponseReaderInterface<R>> {
  311|       | public:
  312|       |  void operator()(void* p) {}
  313|       |};
  314|       |}  // namespace std
  315|       |
  316|       |#endif  // GRPCPP_IMPL_CODEGEN_ASYNC_UNARY_CALL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/byte_buffer.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_BYTE_BUFFER_H
   20|       |#define GRPCPP_IMPL_CODEGEN_BYTE_BUFFER_H
   21|       |
   22|       |#include <grpc/impl/codegen/byte_buffer.h>
   23|       |
   24|       |#include <grpcpp/impl/codegen/config.h>
   25|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   26|       |#include <grpcpp/impl/codegen/serialization_traits.h>
   27|       |#include <grpcpp/impl/codegen/slice.h>
   28|       |#include <grpcpp/impl/codegen/status.h>
   29|       |
   30|       |#include <vector>
   31|       |
   32|       |namespace grpc {
   33|       |
   34|       |class ServerInterface;
   35|       |class ByteBuffer;
   36|       |class ServerInterface;
   37|       |
   38|       |namespace internal {
   39|       |class CallOpSendMessage;
   40|       |template <class R>
   41|       |class CallOpRecvMessage;
   42|       |class CallOpGenericRecvMessage;
   43|       |class MethodHandler;
   44|       |template <class ServiceType, class RequestType, class ResponseType>
   45|       |class RpcMethodHandler;
   46|       |template <class ServiceType, class RequestType, class ResponseType>
   47|       |class ServerStreamingHandler;
   48|       |template <class RequestType, class ResponseType>
   49|       |class CallbackUnaryHandler;
   50|       |template <class RequestType, class ResponseType>
   51|       |class CallbackServerStreamingHandler;
   52|       |template <StatusCode code>
   53|       |class ErrorMethodHandler;
   54|       |template <class R>
   55|       |class DeserializeFuncType;
   56|       |class GrpcByteBufferPeer;
   57|       |template <class ServiceType, class RequestType, class ResponseType>
   58|       |class RpcMethodHandler;
   59|       |template <class ServiceType, class RequestType, class ResponseType>
   60|       |class ServerStreamingHandler;
   61|       |
   62|       |}  // namespace internal
   63|       |/// A sequence of bytes.
   64|       |class ByteBuffer final {
   65|       | public:
   66|       |  /// Constuct an empty buffer.
   67|      0|  ByteBuffer() : buffer_(nullptr) {}
   68|       |
   69|       |  /// Construct buffer from \a slices, of which there are \a nslices.
   70|      0|  ByteBuffer(const Slice* slices, size_t nslices) {
   71|      0|    // The following assertions check that the representation of a grpc::Slice
   72|      0|    // is identical to that of a grpc_slice:  it has a grpc_slice field, and
   73|      0|    // nothing else.
   74|      0|    static_assert(std::is_same<decltype(slices[0].slice_), grpc_slice>::value,
   75|      0|                  "Slice must have same representation as grpc_slice");
   76|      0|    static_assert(sizeof(Slice) == sizeof(grpc_slice),
   77|      0|                  "Slice must have same representation as grpc_slice");
   78|      0|    // The following assertions check that the representation of a ByteBuffer is
   79|      0|    // identical to grpc_byte_buffer*:  it has a grpc_byte_buffer* field,
   80|      0|    // and nothing else.
   81|      0|    static_assert(std::is_same<decltype(buffer_), grpc_byte_buffer*>::value,
   82|      0|                  "ByteBuffer must have same representation as "
   83|      0|                  "grpc_byte_buffer*");
   84|      0|    static_assert(sizeof(ByteBuffer) == sizeof(grpc_byte_buffer*),
   85|      0|                  "ByteBuffer must have same representation as "
   86|      0|                  "grpc_byte_buffer*");
   87|      0|    // The const_cast is legal if grpc_raw_byte_buffer_create() does no more
   88|      0|    // than its advertised side effect of increasing the reference count of the
   89|      0|    // slices it processes, and such an increase does not affect the semantics
   90|      0|    // seen by the caller of this constructor.
   91|      0|    buffer_ = g_core_codegen_interface->grpc_raw_byte_buffer_create(
   92|      0|        reinterpret_cast<grpc_slice*>(const_cast<Slice*>(slices)), nslices);
   93|      0|  }
   94|       |
   95|       |  /// Constuct a byte buffer by referencing elements of existing buffer
   96|       |  /// \a buf. Wrapper of core function grpc_byte_buffer_copy . This is not
   97|       |  /// a deep copy; it is just a referencing. As a result, its performance is
   98|       |  /// size-independent.
   99|      0|  ByteBuffer(const ByteBuffer& buf) : buffer_(nullptr) { operator=(buf); }
  100|       |
  101|      0|  ~ByteBuffer() {
  102|      0|    if (buffer_) {
  103|      0|      g_core_codegen_interface->grpc_byte_buffer_destroy(buffer_);
  104|      0|    }
  105|      0|  }
  106|       |
  107|       |  /// Wrapper of core function grpc_byte_buffer_copy . This is not
  108|       |  /// a deep copy; it is just a referencing. As a result, its performance is
  109|       |  /// size-independent.
  110|      0|  ByteBuffer& operator=(const ByteBuffer& buf) {
  111|      0|    if (this != &buf) {
  112|      0|      Clear();  // first remove existing data
  113|      0|    }
  114|      0|    if (buf.buffer_) {
  115|      0|      // then copy
  116|      0|      buffer_ = g_core_codegen_interface->grpc_byte_buffer_copy(buf.buffer_);
  117|      0|    }
  118|      0|    return *this;
  119|      0|  }
  120|       |
  121|       |  /// Dump (read) the buffer contents into \a slices.
  122|       |  Status Dump(std::vector<Slice>* slices) const;
  123|       |
  124|       |  /// Remove all data.
  125|      0|  void Clear() {
  126|      0|    if (buffer_) {
  127|      0|      g_core_codegen_interface->grpc_byte_buffer_destroy(buffer_);
  128|      0|      buffer_ = nullptr;
  129|      0|    }
  130|      0|  }
  131|       |
  132|       |  /// Make a duplicate copy of the internals of this byte
  133|       |  /// buffer so that we have our own owned version of it.
  134|       |  /// bbuf.Duplicate(); is equivalent to bbuf=bbuf; but is actually readable.
  135|       |  /// This is not a deep copy; it is a referencing and its performance
  136|       |  /// is size-independent.
  137|      0|  void Duplicate() {
  138|      0|    buffer_ = g_core_codegen_interface->grpc_byte_buffer_copy(buffer_);
  139|      0|  }
  140|       |
  141|       |  /// Forget underlying byte buffer without destroying
  142|       |  /// Use this only for un-owned byte buffers
  143|      0|  void Release() { buffer_ = nullptr; }
  144|       |
  145|       |  /// Buffer size in bytes.
  146|      0|  size_t Length() const {
  147|      0|    return buffer_ == nullptr
  148|      0|               ? 0
  149|      0|               : g_core_codegen_interface->grpc_byte_buffer_length(buffer_);
  150|      0|  }
  151|       |
  152|       |  /// Swap the state of *this and *other.
  153|      0|  void Swap(ByteBuffer* other) {
  154|      0|    grpc_byte_buffer* tmp = other->buffer_;
  155|      0|    other->buffer_ = buffer_;
  156|      0|    buffer_ = tmp;
  157|      0|  }
  158|       |
  159|       |  /// Is this ByteBuffer valid?
  160|      0|  bool Valid() const { return (buffer_ != nullptr); }
  161|       |
  162|       | private:
  163|       |  friend class SerializationTraits<ByteBuffer, void>;
  164|       |  friend class ServerInterface;
  165|       |  friend class internal::CallOpSendMessage;
  166|       |  template <class R>
  167|       |  friend class internal::CallOpRecvMessage;
  168|       |  friend class internal::CallOpGenericRecvMessage;
  169|       |  template <class ServiceType, class RequestType, class ResponseType>
  170|       |  friend class RpcMethodHandler;
  171|       |  template <class ServiceType, class RequestType, class ResponseType>
  172|       |  friend class ServerStreamingHandler;
  173|       |  template <class ServiceType, class RequestType, class ResponseType>
  174|       |  friend class internal::RpcMethodHandler;
  175|       |  template <class ServiceType, class RequestType, class ResponseType>
  176|       |  friend class internal::ServerStreamingHandler;
  177|       |  template <class RequestType, class ResponseType>
  178|       |  friend class internal::CallbackUnaryHandler;
  179|       |  template <class RequestType, class ResponseType>
  180|       |  friend class ::grpc::internal::CallbackServerStreamingHandler;
  181|       |  template <StatusCode code>
  182|       |  friend class internal::ErrorMethodHandler;
  183|       |  template <class R>
  184|       |  friend class internal::DeserializeFuncType;
  185|       |  friend class ProtoBufferReader;
  186|       |  friend class ProtoBufferWriter;
  187|       |  friend class internal::GrpcByteBufferPeer;
  188|       |
  189|       |  grpc_byte_buffer* buffer_;
  190|       |
  191|       |  // takes ownership
  192|      0|  void set_buffer(grpc_byte_buffer* buf) {
  193|      0|    if (buffer_) {
  194|      0|      Clear();
  195|      0|    }
  196|      0|    buffer_ = buf;
  197|      0|  }
  198|       |
  199|      0|  grpc_byte_buffer* c_buffer() { return buffer_; }
  200|      0|  grpc_byte_buffer** c_buffer_ptr() { return &buffer_; }
  201|       |
  202|       |  class ByteBufferPointer {
  203|       |   public:
  204|       |    ByteBufferPointer(const ByteBuffer* b)
  205|      0|        : bbuf_(const_cast<ByteBuffer*>(b)) {}
  206|      0|    operator ByteBuffer*() { return bbuf_; }
  207|      0|    operator grpc_byte_buffer*() { return bbuf_->buffer_; }
  208|      0|    operator grpc_byte_buffer**() { return &bbuf_->buffer_; }
  209|       |
  210|       |   private:
  211|       |    ByteBuffer* bbuf_;
  212|       |  };
  213|      0|  ByteBufferPointer bbuf_ptr() const { return ByteBufferPointer(this); }
  214|       |};
  215|       |
  216|       |template <>
  217|       |class SerializationTraits<ByteBuffer, void> {
  218|       | public:
  219|      0|  static Status Deserialize(ByteBuffer* byte_buffer, ByteBuffer* dest) {
  220|      0|    dest->set_buffer(byte_buffer->buffer_);
  221|      0|    return Status::OK;
  222|      0|  }
  223|       |  static Status Serialize(const ByteBuffer& source, ByteBuffer* buffer,
  224|      0|                          bool* own_buffer) {
  225|      0|    *buffer = source;
  226|      0|    *own_buffer = true;
  227|      0|    return g_core_codegen_interface->ok();
  228|      0|  }
  229|       |};
  230|       |
  231|       |}  // namespace grpc
  232|       |
  233|       |#endif  // GRPCPP_IMPL_CODEGEN_BYTE_BUFFER_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/call.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |#ifndef GRPCPP_IMPL_CODEGEN_CALL_H
   19|       |#define GRPCPP_IMPL_CODEGEN_CALL_H
   20|       |
   21|       |#include <grpc/impl/codegen/grpc_types.h>
   22|       |#include <grpcpp/impl/codegen/call_hook.h>
   23|       |
   24|       |namespace grpc_impl {
   25|       |class CompletionQueue;
   26|       |}
   27|       |
   28|       |namespace grpc {
   29|       |namespace experimental {
   30|       |class ClientRpcInfo;
   31|       |class ServerRpcInfo;
   32|       |}  // namespace experimental
   33|       |namespace internal {
   34|       |class CallHook;
   35|       |class CallOpSetInterface;
   36|       |
   37|       |/// Straightforward wrapping of the C call object
   38|       |class Call final {
   39|       | public:
   40|       |  Call()
   41|       |      : call_hook_(nullptr),
   42|       |        cq_(nullptr),
   43|       |        call_(nullptr),
   44|      0|        max_receive_message_size_(-1) {}
   45|       |  /** call is owned by the caller */
   46|       |  Call(grpc_call* call, CallHook* call_hook, ::grpc_impl::CompletionQueue* cq)
   47|       |      : call_hook_(call_hook),
   48|       |        cq_(cq),
   49|       |        call_(call),
   50|      0|        max_receive_message_size_(-1) {}
   51|       |
   52|       |  Call(grpc_call* call, CallHook* call_hook, ::grpc_impl::CompletionQueue* cq,
   53|       |       experimental::ClientRpcInfo* rpc_info)
   54|       |      : call_hook_(call_hook),
   55|       |        cq_(cq),
   56|       |        call_(call),
   57|       |        max_receive_message_size_(-1),
   58|      0|        client_rpc_info_(rpc_info) {}
   59|       |
   60|       |  Call(grpc_call* call, CallHook* call_hook, ::grpc_impl::CompletionQueue* cq,
   61|       |       int max_receive_message_size, experimental::ServerRpcInfo* rpc_info)
   62|       |      : call_hook_(call_hook),
   63|       |        cq_(cq),
   64|       |        call_(call),
   65|       |        max_receive_message_size_(max_receive_message_size),
   66|      0|        server_rpc_info_(rpc_info) {}
   67|       |
   68|      0|  void PerformOps(CallOpSetInterface* ops) {
   69|      0|    call_hook_->PerformOpsOnCall(ops, this);
   70|      0|  }
   71|       |
   72|      0|  grpc_call* call() const { return call_; }
   73|      0|  ::grpc_impl::CompletionQueue* cq() const { return cq_; }
   74|       |
   75|      0|  int max_receive_message_size() const { return max_receive_message_size_; }
   76|       |
   77|      0|  experimental::ClientRpcInfo* client_rpc_info() const {
   78|      0|    return client_rpc_info_;
   79|      0|  }
   80|       |
   81|      0|  experimental::ServerRpcInfo* server_rpc_info() const {
   82|      0|    return server_rpc_info_;
   83|      0|  }
   84|       |
   85|       | private:
   86|       |  CallHook* call_hook_;
   87|       |  ::grpc_impl::CompletionQueue* cq_;
   88|       |  grpc_call* call_;
   89|       |  int max_receive_message_size_;
   90|       |  experimental::ClientRpcInfo* client_rpc_info_ = nullptr;
   91|       |  experimental::ServerRpcInfo* server_rpc_info_ = nullptr;
   92|       |};
   93|       |}  // namespace internal
   94|       |}  // namespace grpc
   95|       |
   96|       |#endif  // GRPCPP_IMPL_CODEGEN_CALL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/call_hook.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_CALL_HOOK_H
   20|       |#define GRPCPP_IMPL_CODEGEN_CALL_HOOK_H
   21|       |
   22|       |namespace grpc {
   23|       |
   24|       |namespace internal {
   25|       |class CallOpSetInterface;
   26|       |class Call;
   27|       |
   28|       |/// This is an interface that Channel and Server implement to allow them to hook
   29|       |/// performing ops.
   30|       |class CallHook {
   31|       | public:
   32|      0|  virtual ~CallHook() {}
   33|       |  virtual void PerformOpsOnCall(CallOpSetInterface* ops, Call* call) = 0;
   34|       |};
   35|       |}  // namespace internal
   36|       |
   37|       |}  // namespace grpc
   38|       |
   39|       |#endif  // GRPCPP_IMPL_CODEGEN_CALL_HOOK_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/call_op_set.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_CALL_OP_SET_H
   20|       |#define GRPCPP_IMPL_CODEGEN_CALL_OP_SET_H
   21|       |
   22|       |#include <assert.h>
   23|       |#include <array>
   24|       |#include <cstring>
   25|       |#include <functional>
   26|       |#include <map>
   27|       |#include <memory>
   28|       |#include <vector>
   29|       |
   30|       |#include <grpcpp/impl/codegen/byte_buffer.h>
   31|       |#include <grpcpp/impl/codegen/call.h>
   32|       |#include <grpcpp/impl/codegen/call_hook.h>
   33|       |#include <grpcpp/impl/codegen/call_op_set_interface.h>
   34|       |#include <grpcpp/impl/codegen/client_context.h>
   35|       |#include <grpcpp/impl/codegen/completion_queue.h>
   36|       |#include <grpcpp/impl/codegen/completion_queue_tag.h>
   37|       |#include <grpcpp/impl/codegen/config.h>
   38|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   39|       |#include <grpcpp/impl/codegen/intercepted_channel.h>
   40|       |#include <grpcpp/impl/codegen/interceptor_common.h>
   41|       |#include <grpcpp/impl/codegen/serialization_traits.h>
   42|       |#include <grpcpp/impl/codegen/slice.h>
   43|       |#include <grpcpp/impl/codegen/string_ref.h>
   44|       |
   45|       |#include <grpc/impl/codegen/atm.h>
   46|       |#include <grpc/impl/codegen/compression_types.h>
   47|       |#include <grpc/impl/codegen/grpc_types.h>
   48|       |
   49|       |namespace grpc {
   50|       |
   51|       |extern CoreCodegenInterface* g_core_codegen_interface;
   52|       |
   53|       |namespace internal {
   54|       |class Call;
   55|       |class CallHook;
   56|       |
   57|       |// TODO(yangg) if the map is changed before we send, the pointers will be a
   58|       |// mess. Make sure it does not happen.
   59|       |inline grpc_metadata* FillMetadataArray(
   60|       |    const std::multimap<grpc::string, grpc::string>& metadata,
   61|      0|    size_t* metadata_count, const grpc::string& optional_error_details) {
   62|      0|  *metadata_count = metadata.size() + (optional_error_details.empty() ? 0 : 1);
   63|      0|  if (*metadata_count == 0) {
   64|      0|    return nullptr;
   65|      0|  }
   66|      0|  grpc_metadata* metadata_array =
   67|      0|      (grpc_metadata*)(g_core_codegen_interface->gpr_malloc(
   68|      0|          (*metadata_count) * sizeof(grpc_metadata)));
   69|      0|  size_t i = 0;
   70|      0|  for (auto iter = metadata.cbegin(); iter != metadata.cend(); ++iter, ++i) {
   71|      0|    metadata_array[i].key = SliceReferencingString(iter->first);
   72|      0|    metadata_array[i].value = SliceReferencingString(iter->second);
   73|      0|  }
   74|      0|  if (!optional_error_details.empty()) {
   75|      0|    metadata_array[i].key =
   76|      0|        g_core_codegen_interface->grpc_slice_from_static_buffer(
   77|      0|            kBinaryErrorDetailsKey, sizeof(kBinaryErrorDetailsKey) - 1);
   78|      0|    metadata_array[i].value = SliceReferencingString(optional_error_details);
   79|      0|  }
   80|      0|  return metadata_array;
   81|      0|}
   82|       |}  // namespace internal
   83|       |
   84|       |/// Per-message write options.
   85|       |class WriteOptions {
   86|       | public:
   87|      0|  WriteOptions() : flags_(0), last_message_(false) {}
   88|       |  WriteOptions(const WriteOptions& other)
   89|      0|      : flags_(other.flags_), last_message_(other.last_message_) {}
   90|       |
   91|       |  /// Clear all flags.
   92|      0|  inline void Clear() { flags_ = 0; }
   93|       |
   94|       |  /// Returns raw flags bitset.
   95|      0|  inline uint32_t flags() const { return flags_; }
   96|       |
   97|       |  /// Sets flag for the disabling of compression for the next message write.
   98|       |  ///
   99|       |  /// \sa GRPC_WRITE_NO_COMPRESS
  100|      0|  inline WriteOptions& set_no_compression() {
  101|      0|    SetBit(GRPC_WRITE_NO_COMPRESS);
  102|      0|    return *this;
  103|      0|  }
  104|       |
  105|       |  /// Clears flag for the disabling of compression for the next message write.
  106|       |  ///
  107|       |  /// \sa GRPC_WRITE_NO_COMPRESS
  108|      0|  inline WriteOptions& clear_no_compression() {
  109|      0|    ClearBit(GRPC_WRITE_NO_COMPRESS);
  110|      0|    return *this;
  111|      0|  }
  112|       |
  113|       |  /// Get value for the flag indicating whether compression for the next
  114|       |  /// message write is forcefully disabled.
  115|       |  ///
  116|       |  /// \sa GRPC_WRITE_NO_COMPRESS
  117|      0|  inline bool get_no_compression() const {
  118|      0|    return GetBit(GRPC_WRITE_NO_COMPRESS);
  119|      0|  }
  120|       |
  121|       |  /// Sets flag indicating that the write may be buffered and need not go out on
  122|       |  /// the wire immediately.
  123|       |  ///
  124|       |  /// \sa GRPC_WRITE_BUFFER_HINT
  125|      0|  inline WriteOptions& set_buffer_hint() {
  126|      0|    SetBit(GRPC_WRITE_BUFFER_HINT);
  127|      0|    return *this;
  128|      0|  }
  129|       |
  130|       |  /// Clears flag indicating that the write may be buffered and need not go out
  131|       |  /// on the wire immediately.
  132|       |  ///
  133|       |  /// \sa GRPC_WRITE_BUFFER_HINT
  134|      0|  inline WriteOptions& clear_buffer_hint() {
  135|      0|    ClearBit(GRPC_WRITE_BUFFER_HINT);
  136|      0|    return *this;
  137|      0|  }
  138|       |
  139|       |  /// Get value for the flag indicating that the write may be buffered and need
  140|       |  /// not go out on the wire immediately.
  141|       |  ///
  142|       |  /// \sa GRPC_WRITE_BUFFER_HINT
  143|      0|  inline bool get_buffer_hint() const { return GetBit(GRPC_WRITE_BUFFER_HINT); }
  144|       |
  145|       |  /// corked bit: aliases set_buffer_hint currently, with the intent that
  146|       |  /// set_buffer_hint will be removed in the future
  147|      0|  inline WriteOptions& set_corked() {
  148|      0|    SetBit(GRPC_WRITE_BUFFER_HINT);
  149|      0|    return *this;
  150|      0|  }
  151|       |
  152|      0|  inline WriteOptions& clear_corked() {
  153|      0|    ClearBit(GRPC_WRITE_BUFFER_HINT);
  154|      0|    return *this;
  155|      0|  }
  156|       |
  157|      0|  inline bool is_corked() const { return GetBit(GRPC_WRITE_BUFFER_HINT); }
  158|       |
  159|       |  /// last-message bit: indicates this is the last message in a stream
  160|       |  /// client-side:  makes Write the equivalent of performing Write, WritesDone
  161|       |  /// in a single step
  162|       |  /// server-side:  hold the Write until the service handler returns (sync api)
  163|       |  /// or until Finish is called (async api)
  164|       |  inline WriteOptions& set_last_message() {
  165|       |    last_message_ = true;
  166|       |    return *this;
  167|       |  }
  168|       |
  169|       |  /// Clears flag indicating that this is the last message in a stream,
  170|       |  /// disabling coalescing.
  171|      0|  inline WriteOptions& clear_last_message() {
  172|      0|    last_message_ = false;
  173|      0|    return *this;
  174|      0|  }
  175|       |
  176|       |  /// Guarantee that all bytes have been written to the socket before completing
  177|       |  /// this write (usually writes are completed when they pass flow control).
  178|      0|  inline WriteOptions& set_write_through() {
  179|      0|    SetBit(GRPC_WRITE_THROUGH);
  180|      0|    return *this;
  181|      0|  }
  182|       |
  183|      0|  inline bool is_write_through() const { return GetBit(GRPC_WRITE_THROUGH); }
  184|       |
  185|       |  /// Get value for the flag indicating that this is the last message, and
  186|       |  /// should be coalesced with trailing metadata.
  187|       |  ///
  188|       |  /// \sa GRPC_WRITE_LAST_MESSAGE
  189|      0|  bool is_last_message() const { return last_message_; }
  190|       |
  191|      0|  WriteOptions& operator=(const WriteOptions& rhs) {
  192|      0|    flags_ = rhs.flags_;
  193|      0|    return *this;
  194|      0|  }
  195|       |
  196|       | private:
  197|      0|  void SetBit(const uint32_t mask) { flags_ |= mask; }
  198|       |
  199|      0|  void ClearBit(const uint32_t mask) { flags_ &= ~mask; }
  200|       |
  201|      0|  bool GetBit(const uint32_t mask) const { return (flags_ & mask) != 0; }
  202|       |
  203|       |  uint32_t flags_;
  204|       |  bool last_message_;
  205|       |};
  206|       |
  207|       |namespace internal {
  208|       |
  209|       |/// Default argument for CallOpSet. I is unused by the class, but can be
  210|       |/// used for generating multiple names for the same thing.
  211|       |template <int I>
  212|       |class CallNoOp {
  213|       | protected:
  214|      0|  void AddOp(grpc_op* ops, size_t* nops) {}
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi2EE5AddOpEP7grpc_opPm
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi3EE5AddOpEP7grpc_opPm
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi4EE5AddOpEP7grpc_opPm
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi5EE5AddOpEP7grpc_opPm
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi6EE5AddOpEP7grpc_opPm
  ------------------
  215|      0|  void FinishOp(bool* status) {}
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi2EE8FinishOpEPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi3EE8FinishOpEPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi4EE8FinishOpEPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi5EE8FinishOpEPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi6EE8FinishOpEPb
  ------------------
  216|       |  void SetInterceptionHookPoint(
  217|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {}
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi2EE24SetInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi3EE24SetInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi4EE24SetInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi5EE24SetInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi6EE24SetInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  218|       |  void SetFinishInterceptionHookPoint(
  219|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {}
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi2EE30SetFinishInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi3EE30SetFinishInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi4EE30SetFinishInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi5EE30SetFinishInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi6EE30SetFinishInterceptionHookPointEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  220|      0|  void SetHijackingState(InterceptorBatchMethodsImpl* interceptor_methods) {}
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi2EE17SetHijackingStateEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi3EE17SetHijackingStateEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi4EE17SetHijackingStateEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi5EE17SetHijackingStateEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal8CallNoOpILi6EE17SetHijackingStateEPNS0_27InterceptorBatchMethodsImplE
  ------------------
  221|       |};
  222|       |
  223|       |class CallOpSendInitialMetadata {
  224|       | public:
  225|      0|  CallOpSendInitialMetadata() : send_(false) {
  226|      0|    maybe_compression_level_.is_set = false;
  227|      0|  }
  228|       |
  229|       |  void SendInitialMetadata(std::multimap<grpc::string, grpc::string>* metadata,
  230|      0|                           uint32_t flags) {
  231|      0|    maybe_compression_level_.is_set = false;
  232|      0|    send_ = true;
  233|      0|    flags_ = flags;
  234|      0|    metadata_map_ = metadata;
  235|      0|  }
  236|       |
  237|      0|  void set_compression_level(grpc_compression_level level) {
  238|      0|    maybe_compression_level_.is_set = true;
  239|      0|    maybe_compression_level_.level = level;
  240|      0|  }
  241|       |
  242|       | protected:
  243|      0|  void AddOp(grpc_op* ops, size_t* nops) {
  244|      0|    if (!send_ || hijacked_) return;
  245|      0|    grpc_op* op = &ops[(*nops)++];
  246|      0|    op->op = GRPC_OP_SEND_INITIAL_METADATA;
  247|      0|    op->flags = flags_;
  248|      0|    op->reserved = NULL;
  249|      0|    initial_metadata_ =
  250|      0|        FillMetadataArray(*metadata_map_, &initial_metadata_count_, "");
  251|      0|    op->data.send_initial_metadata.count = initial_metadata_count_;
  252|      0|    op->data.send_initial_metadata.metadata = initial_metadata_;
  253|      0|    op->data.send_initial_metadata.maybe_compression_level.is_set =
  254|      0|        maybe_compression_level_.is_set;
  255|      0|    if (maybe_compression_level_.is_set) {
  256|      0|      op->data.send_initial_metadata.maybe_compression_level.level =
  257|      0|          maybe_compression_level_.level;
  258|      0|    }
  259|      0|  }
  260|      0|  void FinishOp(bool* status) {
  261|      0|    if (!send_ || hijacked_) return;
  262|      0|    g_core_codegen_interface->gpr_free(initial_metadata_);
  263|      0|    send_ = false;
  264|      0|  }
  265|       |
  266|       |  void SetInterceptionHookPoint(
  267|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  268|      0|    if (!send_) return;
  269|      0|    interceptor_methods->AddInterceptionHookPoint(
  270|      0|        experimental::InterceptionHookPoints::PRE_SEND_INITIAL_METADATA);
  271|      0|    interceptor_methods->SetSendInitialMetadata(metadata_map_);
  272|      0|  }
  273|       |
  274|       |  void SetFinishInterceptionHookPoint(
  275|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {}
  276|       |
  277|      0|  void SetHijackingState(InterceptorBatchMethodsImpl* interceptor_methods) {
  278|      0|    hijacked_ = true;
  279|      0|  }
  280|       |
  281|       |  bool hijacked_ = false;
  282|       |  bool send_;
  283|       |  uint32_t flags_;
  284|       |  size_t initial_metadata_count_;
  285|       |  std::multimap<grpc::string, grpc::string>* metadata_map_;
  286|       |  grpc_metadata* initial_metadata_;
  287|       |  struct {
  288|       |    bool is_set;
  289|       |    grpc_compression_level level;
  290|       |  } maybe_compression_level_;
  291|       |};
  292|       |
  293|       |class CallOpSendMessage {
  294|       | public:
  295|      0|  CallOpSendMessage() : send_buf_() {}
  296|       |
  297|       |  /// Send \a message using \a options for the write. The \a options are cleared
  298|       |  /// after use.
  299|       |  template <class M>
  300|       |  Status SendMessage(const M& message,
  301|       |                     WriteOptions options) GRPC_MUST_USE_RESULT;
  302|       |
  303|       |  template <class M>
  304|       |  Status SendMessage(const M& message) GRPC_MUST_USE_RESULT;
  305|       |
  306|       |  /// Send \a message using \a options for the write. The \a options are cleared
  307|       |  /// after use. This form of SendMessage allows gRPC to reference \a message
  308|       |  /// beyond the lifetime of SendMessage.
  309|       |  template <class M>
  310|       |  Status SendMessagePtr(const M* message,
  311|       |                        WriteOptions options) GRPC_MUST_USE_RESULT;
  312|       |
  313|       |  /// This form of SendMessage allows gRPC to reference \a message beyond the
  314|       |  /// lifetime of SendMessage.
  315|       |  template <class M>
  316|       |  Status SendMessagePtr(const M* message) GRPC_MUST_USE_RESULT;
  317|       |
  318|       | protected:
  319|      0|  void AddOp(grpc_op* ops, size_t* nops) {
  320|      0|    if (msg_ == nullptr && !send_buf_.Valid()) return;
  321|      0|    if (hijacked_) {
  322|      0|      serializer_ = nullptr;
  323|      0|      return;
  324|      0|    }
  325|      0|    if (msg_ != nullptr) {
  326|      0|      GPR_CODEGEN_ASSERT(serializer_(msg_).ok());
  327|      0|    }
  328|      0|    serializer_ = nullptr;
  329|      0|    grpc_op* op = &ops[(*nops)++];
  330|      0|    op->op = GRPC_OP_SEND_MESSAGE;
  331|      0|    op->flags = write_options_.flags();
  332|      0|    op->reserved = NULL;
  333|      0|    op->data.send_message.send_message = send_buf_.c_buffer();
  334|      0|    // Flags are per-message: clear them after use.
  335|      0|    write_options_.Clear();
  336|      0|  }
  337|      0|  void FinishOp(bool* status) {
  338|      0|    if (msg_ == nullptr && !send_buf_.Valid()) return;
  339|      0|    if (hijacked_ && failed_send_) {
  340|      0|      // Hijacking interceptor failed this Op
  341|      0|      *status = false;
  342|      0|    } else if (!*status) {
  343|      0|      // This Op was passed down to core and the Op failed
  344|      0|      failed_send_ = true;
  345|      0|    }
  346|      0|  }
  347|       |
  348|       |  void SetInterceptionHookPoint(
  349|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  350|      0|    if (msg_ == nullptr && !send_buf_.Valid()) return;
  351|      0|    interceptor_methods->AddInterceptionHookPoint(
  352|      0|        experimental::InterceptionHookPoints::PRE_SEND_MESSAGE);
  353|      0|    interceptor_methods->SetSendMessage(&send_buf_, &msg_, &failed_send_,
  354|      0|                                        serializer_);
  355|      0|  }
  356|       |
  357|       |  void SetFinishInterceptionHookPoint(
  358|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  359|      0|    if (msg_ != nullptr || send_buf_.Valid()) {
  360|      0|      interceptor_methods->AddInterceptionHookPoint(
  361|      0|          experimental::InterceptionHookPoints::POST_SEND_MESSAGE);
  362|      0|    }
  363|      0|    send_buf_.Clear();
  364|      0|    msg_ = nullptr;
  365|      0|    // The contents of the SendMessage value that was previously set
  366|      0|    // has had its references stolen by core's operations
  367|      0|    interceptor_methods->SetSendMessage(nullptr, nullptr, &failed_send_,
  368|      0|                                        nullptr);
  369|      0|  }
  370|       |
  371|      0|  void SetHijackingState(InterceptorBatchMethodsImpl* interceptor_methods) {
  372|      0|    hijacked_ = true;
  373|      0|  }
  374|       |
  375|       | private:
  376|       |  const void* msg_ = nullptr;  // The original non-serialized message
  377|       |  bool hijacked_ = false;
  378|       |  bool failed_send_ = false;
  379|       |  ByteBuffer send_buf_;
  380|       |  WriteOptions write_options_;
  381|       |  std::function<Status(const void*)> serializer_;
  382|       |};
  383|       |
  384|       |template <class M>
  385|      0|Status CallOpSendMessage::SendMessage(const M& message, WriteOptions options) {
  386|      0|  write_options_ = options;
  387|      0|  serializer_ = [this](const void* message) {
  388|      0|    bool own_buf;
  389|      0|    send_buf_.Clear();
  390|      0|    // TODO(vjpai): Remove the void below when possible
  391|      0|    // The void in the template parameter below should not be needed
  392|      0|    // (since it should be implicit) but is needed due to an observed
  393|      0|    // difference in behavior between clang and gcc for certain internal users
  394|      0|    Status result = SerializationTraits<M, void>::Serialize(
  395|      0|        *static_cast<const M*>(message), send_buf_.bbuf_ptr(), &own_buf);
  396|      0|    if (!own_buf) {
  397|      0|      send_buf_.Duplicate();
  398|      0|    }
  399|      0|    return result;
  400|      0|  };
  401|      0|  // Serialize immediately only if we do not have access to the message pointer
  402|      0|  if (msg_ == nullptr) {
  403|      0|    Status result = serializer_(&message);
  404|      0|    serializer_ = nullptr;
  405|      0|    return result;
  406|      0|  }
  407|      0|  return Status();
  408|      0|}
  409|       |
  410|       |template <class M>
  411|      0|Status CallOpSendMessage::SendMessage(const M& message) {
  412|      0|  return SendMessage(message, WriteOptions());
  413|      0|}
  414|       |
  415|       |template <class M>
  416|       |Status CallOpSendMessage::SendMessagePtr(const M* message,
  417|      0|                                         WriteOptions options) {
  418|      0|  msg_ = message;
  419|      0|  return SendMessage(*message, options);
  420|      0|}
  421|       |
  422|       |template <class M>
  423|      0|Status CallOpSendMessage::SendMessagePtr(const M* message) {
  424|      0|  msg_ = message;
  425|      0|  return SendMessage(*message, WriteOptions());
  426|      0|}
  427|       |
  428|       |template <class R>
  429|       |class CallOpRecvMessage {
  430|       | public:
  431|       |  CallOpRecvMessage()
  432|       |      : got_message(false),
  433|       |        message_(nullptr),
  434|      0|        allow_not_getting_message_(false) {}
  435|       |
  436|      0|  void RecvMessage(R* message) { message_ = message; }
  437|       |
  438|       |  // Do not change status if no message is received.
  439|      0|  void AllowNoMessage() { allow_not_getting_message_ = true; }
  440|       |
  441|       |  bool got_message;
  442|       |
  443|       | protected:
  444|      0|  void AddOp(grpc_op* ops, size_t* nops) {
  445|      0|    if (message_ == nullptr || hijacked_) return;
  446|      0|    grpc_op* op = &ops[(*nops)++];
  447|      0|    op->op = GRPC_OP_RECV_MESSAGE;
  448|      0|    op->flags = 0;
  449|      0|    op->reserved = NULL;
  450|      0|    op->data.recv_message.recv_message = recv_buf_.c_buffer_ptr();
  451|      0|  }
  452|       |
  453|      0|  void FinishOp(bool* status) {
  454|      0|    if (message_ == nullptr || hijacked_) return;
  455|      0|    if (recv_buf_.Valid()) {
  456|      0|      if (*status) {
  457|      0|        got_message = *status =
  458|      0|            SerializationTraits<R>::Deserialize(recv_buf_.bbuf_ptr(), message_)
  459|      0|                .ok();
  460|      0|        recv_buf_.Release();
  461|      0|      } else {
  462|      0|        got_message = false;
  463|      0|        recv_buf_.Clear();
  464|      0|      }
  465|      0|    } else {
  466|      0|      got_message = false;
  467|      0|      if (!allow_not_getting_message_) {
  468|      0|        *status = false;
  469|      0|      }
  470|      0|    }
  471|      0|    message_ = nullptr;
  472|      0|  }
  473|       |
  474|       |  void SetInterceptionHookPoint(
  475|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  476|      0|    if (message_ == nullptr) return;
  477|      0|    interceptor_methods->SetRecvMessage(message_, &got_message);
  478|      0|  }
  479|       |
  480|       |  void SetFinishInterceptionHookPoint(
  481|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  482|      0|    if (message_ == nullptr) return;
  483|      0|    interceptor_methods->AddInterceptionHookPoint(
  484|      0|        experimental::InterceptionHookPoints::POST_RECV_MESSAGE);
  485|      0|    if (!got_message) interceptor_methods->SetRecvMessage(nullptr, nullptr);
  486|      0|  }
  487|      0|  void SetHijackingState(InterceptorBatchMethodsImpl* interceptor_methods) {
  488|      0|    hijacked_ = true;
  489|      0|    if (message_ == nullptr) return;
  490|      0|    interceptor_methods->AddInterceptionHookPoint(
  491|      0|        experimental::InterceptionHookPoints::PRE_RECV_MESSAGE);
  492|      0|    got_message = true;
  493|      0|  }
  494|       |
  495|       | private:
  496|       |  R* message_;
  497|       |  ByteBuffer recv_buf_;
  498|       |  bool allow_not_getting_message_;
  499|       |  bool hijacked_ = false;
  500|       |};
  501|       |
  502|       |class DeserializeFunc {
  503|       | public:
  504|       |  virtual Status Deserialize(ByteBuffer* buf) = 0;
  505|      0|  virtual ~DeserializeFunc() {}
  506|       |};
  507|       |
  508|       |template <class R>
  509|       |class DeserializeFuncType final : public DeserializeFunc {
  510|       | public:
  511|       |  DeserializeFuncType(R* message) : message_(message) {}
  512|       |  Status Deserialize(ByteBuffer* buf) override {
  513|       |    return SerializationTraits<R>::Deserialize(buf->bbuf_ptr(), message_);
  514|       |  }
  515|       |
  516|       |  ~DeserializeFuncType() override {}
  517|       |
  518|       | private:
  519|       |  R* message_;  // Not a managed pointer because management is external to this
  520|       |};
  521|       |
  522|       |class CallOpGenericRecvMessage {
  523|       | public:
  524|       |  CallOpGenericRecvMessage()
  525|      0|      : got_message(false), allow_not_getting_message_(false) {}
  526|       |
  527|       |  template <class R>
  528|       |  void RecvMessage(R* message) {
  529|       |    // Use an explicit base class pointer to avoid resolution error in the
  530|       |    // following unique_ptr::reset for some old implementations.
  531|       |    DeserializeFunc* func = new DeserializeFuncType<R>(message);
  532|       |    deserialize_.reset(func);
  533|       |    message_ = message;
  534|       |  }
  535|       |
  536|       |  // Do not change status if no message is received.
  537|      0|  void AllowNoMessage() { allow_not_getting_message_ = true; }
  538|       |
  539|       |  bool got_message;
  540|       |
  541|       | protected:
  542|      0|  void AddOp(grpc_op* ops, size_t* nops) {
  543|      0|    if (!deserialize_ || hijacked_) return;
  544|      0|    grpc_op* op = &ops[(*nops)++];
  545|      0|    op->op = GRPC_OP_RECV_MESSAGE;
  546|      0|    op->flags = 0;
  547|      0|    op->reserved = NULL;
  548|      0|    op->data.recv_message.recv_message = recv_buf_.c_buffer_ptr();
  549|      0|  }
  550|       |
  551|      0|  void FinishOp(bool* status) {
  552|      0|    if (!deserialize_ || hijacked_) return;
  553|      0|    if (recv_buf_.Valid()) {
  554|      0|      if (*status) {
  555|      0|        got_message = true;
  556|      0|        *status = deserialize_->Deserialize(&recv_buf_).ok();
  557|      0|        recv_buf_.Release();
  558|      0|      } else {
  559|      0|        got_message = false;
  560|      0|        recv_buf_.Clear();
  561|      0|      }
  562|      0|    } else {
  563|      0|      got_message = false;
  564|      0|      if (!allow_not_getting_message_) {
  565|      0|        *status = false;
  566|      0|      }
  567|      0|    }
  568|      0|    deserialize_.reset();
  569|      0|  }
  570|       |
  571|       |  void SetInterceptionHookPoint(
  572|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  573|      0|    if (!deserialize_) return;
  574|      0|    interceptor_methods->SetRecvMessage(message_, &got_message);
  575|      0|  }
  576|       |
  577|       |  void SetFinishInterceptionHookPoint(
  578|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  579|      0|    if (!deserialize_) return;
  580|      0|    interceptor_methods->AddInterceptionHookPoint(
  581|      0|        experimental::InterceptionHookPoints::POST_RECV_MESSAGE);
  582|      0|    if (!got_message) interceptor_methods->SetRecvMessage(nullptr, nullptr);
  583|      0|  }
  584|      0|  void SetHijackingState(InterceptorBatchMethodsImpl* interceptor_methods) {
  585|      0|    hijacked_ = true;
  586|      0|    if (!deserialize_) return;
  587|      0|    interceptor_methods->AddInterceptionHookPoint(
  588|      0|        experimental::InterceptionHookPoints::PRE_RECV_MESSAGE);
  589|      0|    got_message = true;
  590|      0|  }
  591|       |
  592|       | private:
  593|       |  void* message_;
  594|       |  bool hijacked_ = false;
  595|       |  std::unique_ptr<DeserializeFunc> deserialize_;
  596|       |  ByteBuffer recv_buf_;
  597|       |  bool allow_not_getting_message_;
  598|       |};
  599|       |
  600|       |class CallOpClientSendClose {
  601|       | public:
  602|      0|  CallOpClientSendClose() : send_(false) {}
  603|       |
  604|      0|  void ClientSendClose() { send_ = true; }
  605|       |
  606|       | protected:
  607|      0|  void AddOp(grpc_op* ops, size_t* nops) {
  608|      0|    if (!send_ || hijacked_) return;
  609|      0|    grpc_op* op = &ops[(*nops)++];
  610|      0|    op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;
  611|      0|    op->flags = 0;
  612|      0|    op->reserved = NULL;
  613|      0|  }
  614|      0|  void FinishOp(bool* status) { send_ = false; }
  615|       |
  616|       |  void SetInterceptionHookPoint(
  617|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  618|      0|    if (!send_) return;
  619|      0|    interceptor_methods->AddInterceptionHookPoint(
  620|      0|        experimental::InterceptionHookPoints::PRE_SEND_CLOSE);
  621|      0|  }
  622|       |
  623|       |  void SetFinishInterceptionHookPoint(
  624|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {}
  625|       |
  626|      0|  void SetHijackingState(InterceptorBatchMethodsImpl* interceptor_methods) {
  627|      0|    hijacked_ = true;
  628|      0|  }
  629|       |
  630|       | private:
  631|       |  bool hijacked_ = false;
  632|       |  bool send_;
  633|       |};
  634|       |
  635|       |class CallOpServerSendStatus {
  636|       | public:
  637|      0|  CallOpServerSendStatus() : send_status_available_(false) {}
  638|       |
  639|       |  void ServerSendStatus(
  640|       |      std::multimap<grpc::string, grpc::string>* trailing_metadata,
  641|      0|      const Status& status) {
  642|      0|    send_error_details_ = status.error_details();
  643|      0|    metadata_map_ = trailing_metadata;
  644|      0|    send_status_available_ = true;
  645|      0|    send_status_code_ = static_cast<grpc_status_code>(status.error_code());
  646|      0|    send_error_message_ = status.error_message();
  647|      0|  }
  648|       |
  649|       | protected:
  650|      0|  void AddOp(grpc_op* ops, size_t* nops) {
  651|      0|    if (!send_status_available_ || hijacked_) return;
  652|      0|    trailing_metadata_ = FillMetadataArray(
  653|      0|        *metadata_map_, &trailing_metadata_count_, send_error_details_);
  654|      0|    grpc_op* op = &ops[(*nops)++];
  655|      0|    op->op = GRPC_OP_SEND_STATUS_FROM_SERVER;
  656|      0|    op->data.send_status_from_server.trailing_metadata_count =
  657|      0|        trailing_metadata_count_;
  658|      0|    op->data.send_status_from_server.trailing_metadata = trailing_metadata_;
  659|      0|    op->data.send_status_from_server.status = send_status_code_;
  660|      0|    error_message_slice_ = SliceReferencingString(send_error_message_);
  661|      0|    op->data.send_status_from_server.status_details =
  662|      0|        send_error_message_.empty() ? nullptr : &error_message_slice_;
  663|      0|    op->flags = 0;
  664|      0|    op->reserved = NULL;
  665|      0|  }
  666|       |
  667|      0|  void FinishOp(bool* status) {
  668|      0|    if (!send_status_available_ || hijacked_) return;
  669|      0|    g_core_codegen_interface->gpr_free(trailing_metadata_);
  670|      0|    send_status_available_ = false;
  671|      0|  }
  672|       |
  673|       |  void SetInterceptionHookPoint(
  674|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  675|      0|    if (!send_status_available_) return;
  676|      0|    interceptor_methods->AddInterceptionHookPoint(
  677|      0|        experimental::InterceptionHookPoints::PRE_SEND_STATUS);
  678|      0|    interceptor_methods->SetSendTrailingMetadata(metadata_map_);
  679|      0|    interceptor_methods->SetSendStatus(&send_status_code_, &send_error_details_,
  680|      0|                                       &send_error_message_);
  681|      0|  }
  682|       |
  683|       |  void SetFinishInterceptionHookPoint(
  684|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {}
  685|       |
  686|      0|  void SetHijackingState(InterceptorBatchMethodsImpl* interceptor_methods) {
  687|      0|    hijacked_ = true;
  688|      0|  }
  689|       |
  690|       | private:
  691|       |  bool hijacked_ = false;
  692|       |  bool send_status_available_;
  693|       |  grpc_status_code send_status_code_;
  694|       |  grpc::string send_error_details_;
  695|       |  grpc::string send_error_message_;
  696|       |  size_t trailing_metadata_count_;
  697|       |  std::multimap<grpc::string, grpc::string>* metadata_map_;
  698|       |  grpc_metadata* trailing_metadata_;
  699|       |  grpc_slice error_message_slice_;
  700|       |};
  701|       |
  702|       |class CallOpRecvInitialMetadata {
  703|       | public:
  704|      0|  CallOpRecvInitialMetadata() : metadata_map_(nullptr) {}
  705|       |
  706|      0|  void RecvInitialMetadata(ClientContext* context) {
  707|      0|    context->initial_metadata_received_ = true;
  708|      0|    metadata_map_ = &context->recv_initial_metadata_;
  709|      0|  }
  710|       |
  711|       | protected:
  712|      0|  void AddOp(grpc_op* ops, size_t* nops) {
  713|      0|    if (metadata_map_ == nullptr || hijacked_) return;
  714|      0|    grpc_op* op = &ops[(*nops)++];
  715|      0|    op->op = GRPC_OP_RECV_INITIAL_METADATA;
  716|      0|    op->data.recv_initial_metadata.recv_initial_metadata = metadata_map_->arr();
  717|      0|    op->flags = 0;
  718|      0|    op->reserved = NULL;
  719|      0|  }
  720|       |
  721|      0|  void FinishOp(bool* status) {
  722|      0|    if (metadata_map_ == nullptr || hijacked_) return;
  723|      0|  }
  724|       |
  725|       |  void SetInterceptionHookPoint(
  726|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  727|      0|    interceptor_methods->SetRecvInitialMetadata(metadata_map_);
  728|      0|  }
  729|       |
  730|       |  void SetFinishInterceptionHookPoint(
  731|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  732|      0|    if (metadata_map_ == nullptr) return;
  733|      0|    interceptor_methods->AddInterceptionHookPoint(
  734|      0|        experimental::InterceptionHookPoints::POST_RECV_INITIAL_METADATA);
  735|      0|    metadata_map_ = nullptr;
  736|      0|  }
  737|       |
  738|      0|  void SetHijackingState(InterceptorBatchMethodsImpl* interceptor_methods) {
  739|      0|    hijacked_ = true;
  740|      0|    if (metadata_map_ == nullptr) return;
  741|      0|    interceptor_methods->AddInterceptionHookPoint(
  742|      0|        experimental::InterceptionHookPoints::PRE_RECV_INITIAL_METADATA);
  743|      0|  }
  744|       |
  745|       | private:
  746|       |  bool hijacked_ = false;
  747|       |  MetadataMap* metadata_map_;
  748|       |};
  749|       |
  750|       |class CallOpClientRecvStatus {
  751|       | public:
  752|       |  CallOpClientRecvStatus()
  753|      0|      : recv_status_(nullptr), debug_error_string_(nullptr) {}
  754|       |
  755|      0|  void ClientRecvStatus(ClientContext* context, Status* status) {
  756|      0|    client_context_ = context;
  757|      0|    metadata_map_ = &client_context_->trailing_metadata_;
  758|      0|    recv_status_ = status;
  759|      0|    error_message_ = g_core_codegen_interface->grpc_empty_slice();
  760|      0|  }
  761|       |
  762|       | protected:
  763|      0|  void AddOp(grpc_op* ops, size_t* nops) {
  764|      0|    if (recv_status_ == nullptr || hijacked_) return;
  765|      0|    grpc_op* op = &ops[(*nops)++];
  766|      0|    op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;
  767|      0|    op->data.recv_status_on_client.trailing_metadata = metadata_map_->arr();
  768|      0|    op->data.recv_status_on_client.status = &status_code_;
  769|      0|    op->data.recv_status_on_client.status_details = &error_message_;
  770|      0|    op->data.recv_status_on_client.error_string = &debug_error_string_;
  771|      0|    op->flags = 0;
  772|      0|    op->reserved = NULL;
  773|      0|  }
  774|       |
  775|      0|  void FinishOp(bool* status) {
  776|      0|    if (recv_status_ == nullptr || hijacked_) return;
  777|      0|    grpc::string binary_error_details = metadata_map_->GetBinaryErrorDetails();
  778|      0|    *recv_status_ =
  779|      0|        Status(static_cast<StatusCode>(status_code_),
  780|      0|               GRPC_SLICE_IS_EMPTY(error_message_)
  781|      0|                   ? grpc::string()
  782|      0|                   : grpc::string(GRPC_SLICE_START_PTR(error_message_),
  783|      0|                                  GRPC_SLICE_END_PTR(error_message_)),
  784|      0|               binary_error_details);
  785|      0|    client_context_->set_debug_error_string(
  786|      0|        debug_error_string_ != nullptr ? debug_error_string_ : "");
  787|      0|    g_core_codegen_interface->grpc_slice_unref(error_message_);
  788|      0|    if (debug_error_string_ != nullptr) {
  789|      0|      g_core_codegen_interface->gpr_free((void*)debug_error_string_);
  790|      0|    }
  791|      0|  }
  792|       |
  793|       |  void SetInterceptionHookPoint(
  794|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  795|      0|    interceptor_methods->SetRecvStatus(recv_status_);
  796|      0|    interceptor_methods->SetRecvTrailingMetadata(metadata_map_);
  797|      0|  }
  798|       |
  799|       |  void SetFinishInterceptionHookPoint(
  800|      0|      InterceptorBatchMethodsImpl* interceptor_methods) {
  801|      0|    if (recv_status_ == nullptr) return;
  802|      0|    interceptor_methods->AddInterceptionHookPoint(
  803|      0|        experimental::InterceptionHookPoints::POST_RECV_STATUS);
  804|      0|    recv_status_ = nullptr;
  805|      0|  }
  806|       |
  807|      0|  void SetHijackingState(InterceptorBatchMethodsImpl* interceptor_methods) {
  808|      0|    hijacked_ = true;
  809|      0|    if (recv_status_ == nullptr) return;
  810|      0|    interceptor_methods->AddInterceptionHookPoint(
  811|      0|        experimental::InterceptionHookPoints::PRE_RECV_STATUS);
  812|      0|  }
  813|       |
  814|       | private:
  815|       |  bool hijacked_ = false;
  816|       |  ClientContext* client_context_;
  817|       |  MetadataMap* metadata_map_;
  818|       |  Status* recv_status_;
  819|       |  const char* debug_error_string_;
  820|       |  grpc_status_code status_code_;
  821|       |  grpc_slice error_message_;
  822|       |};
  823|       |
  824|       |template <class Op1 = CallNoOp<1>, class Op2 = CallNoOp<2>,
  825|       |          class Op3 = CallNoOp<3>, class Op4 = CallNoOp<4>,
  826|       |          class Op5 = CallNoOp<5>, class Op6 = CallNoOp<6>>
  827|       |class CallOpSet;
  828|       |
  829|       |/// Primary implementation of CallOpSetInterface.
  830|       |/// Since we cannot use variadic templates, we declare slots up to
  831|       |/// the maximum count of ops we'll need in a set. We leverage the
  832|       |/// empty base class optimization to slim this class (especially
  833|       |/// when there are many unused slots used). To avoid duplicate base classes,
  834|       |/// the template parmeter for CallNoOp is varied by argument position.
  835|       |template <class Op1, class Op2, class Op3, class Op4, class Op5, class Op6>
  836|       |class CallOpSet : public CallOpSetInterface,
  837|       |                  public Op1,
  838|       |                  public Op2,
  839|       |                  public Op3,
  840|       |                  public Op4,
  841|       |                  public Op5,
  842|       |                  public Op6 {
  843|       | public:
  844|      0|  CallOpSet() : core_cq_tag_(this), return_tag_(this) {}
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEEC2Ev
  ------------------
  845|       |  // The copy constructor and assignment operator reset the value of
  846|       |  // core_cq_tag_, return_tag_, done_intercepting_ and interceptor_methods_
  847|       |  // since those are only meaningful on a specific object, not across objects.
  848|       |  CallOpSet(const CallOpSet& other)
  849|       |      : core_cq_tag_(this),
  850|       |        return_tag_(this),
  851|       |        call_(other.call_),
  852|       |        done_intercepting_(false),
  853|       |        interceptor_methods_(InterceptorBatchMethodsImpl()) {}
  854|       |
  855|       |  CallOpSet& operator=(const CallOpSet& other) {
  856|       |    core_cq_tag_ = this;
  857|       |    return_tag_ = this;
  858|       |    call_ = other.call_;
  859|       |    done_intercepting_ = false;
  860|       |    interceptor_methods_ = InterceptorBatchMethodsImpl();
  861|       |    return *this;
  862|       |  }
  863|       |
  864|      0|  void FillOps(Call* call) override {
  865|      0|    done_intercepting_ = false;
  866|      0|    g_core_codegen_interface->grpc_call_ref(call->call());
  867|      0|    call_ =
  868|      0|        *call;  // It's fine to create a copy of call since it's just pointers
  869|      0|
  870|      0|    if (RunInterceptors()) {
  871|      0|      ContinueFillOpsAfterInterception();
  872|      0|    } else {
  873|      0|      // After the interceptors are run, ContinueFillOpsAfterInterception will
  874|      0|      // be run
  875|      0|    }
  876|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi5EEENS6_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_24CallOpGenericRecvMessageENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE7FillOpsEPNS0_4CallE
  ------------------
  877|       |
  878|      0|  bool FinalizeResult(void** tag, bool* status) override {
  879|      0|    if (done_intercepting_) {
  880|      0|      // Complete the avalanching since we are done with this batch of ops
  881|      0|      call_.cq()->CompleteAvalanching();
  882|      0|      // We have already finished intercepting and filling in the results. This
  883|      0|      // round trip from the core needed to be made because interceptors were
  884|      0|      // run
  885|      0|      *tag = return_tag_;
  886|      0|      *status = saved_status_;
  887|      0|      g_core_codegen_interface->grpc_call_unref(call_.call());
  888|      0|      return true;
  889|      0|    }
  890|      0|
  891|      0|    this->Op1::FinishOp(status);
  892|      0|    this->Op2::FinishOp(status);
  893|      0|    this->Op3::FinishOp(status);
  894|      0|    this->Op4::FinishOp(status);
  895|      0|    this->Op5::FinishOp(status);
  896|      0|    this->Op6::FinishOp(status);
  897|      0|    saved_status_ = *status;
  898|      0|    if (RunInterceptorsPostRecv()) {
  899|      0|      *tag = return_tag_;
  900|      0|      g_core_codegen_interface->grpc_call_unref(call_.call());
  901|      0|      return true;
  902|      0|    }
  903|      0|    // Interceptors are going to be run, so we can't return the tag just yet.
  904|      0|    // After the interceptors are run, ContinueFinalizeResultAfterInterception
  905|      0|    return false;
  906|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi5EEENS6_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_24CallOpGenericRecvMessageENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE14FinalizeResultEPPvPb
  ------------------
  907|       |
  908|      0|  void set_output_tag(void* return_tag) { return_tag_ = return_tag; }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE14set_output_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE14set_output_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE14set_output_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE14set_output_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE14set_output_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE14set_output_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE14set_output_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEE14set_output_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE14set_output_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE14set_output_tagEPv
  ------------------
  909|       |
  910|      0|  void* core_cq_tag() override { return core_cq_tag_; }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi5EEENS6_ILi6EEEE11core_cq_tagEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_24CallOpGenericRecvMessageENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE11core_cq_tagEv
  ------------------
  911|       |
  912|       |  /// set_core_cq_tag is used to provide a different core CQ tag than "this".
  913|       |  /// This is used for callback-based tags, where the core tag is the core
  914|       |  /// callback function. It does not change the use or behavior of any other
  915|       |  /// function (such as FinalizeResult)
  916|      0|  void set_core_cq_tag(void* core_cq_tag) { core_cq_tag_ = core_cq_tag; }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi5EEENS6_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_24CallOpGenericRecvMessageENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15set_core_cq_tagEPv
  ------------------
  917|       |
  918|       |  // This will be called while interceptors are run if the RPC is a hijacked
  919|       |  // RPC. This should set hijacking state for each of the ops.
  920|      0|  void SetHijackingState() override {
  921|      0|    this->Op1::SetHijackingState(&interceptor_methods_);
  922|      0|    this->Op2::SetHijackingState(&interceptor_methods_);
  923|      0|    this->Op3::SetHijackingState(&interceptor_methods_);
  924|      0|    this->Op4::SetHijackingState(&interceptor_methods_);
  925|      0|    this->Op5::SetHijackingState(&interceptor_methods_);
  926|      0|    this->Op6::SetHijackingState(&interceptor_methods_);
  927|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi5EEENS6_ILi6EEEE17SetHijackingStateEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_24CallOpGenericRecvMessageENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE17SetHijackingStateEv
  ------------------
  928|       |
  929|       |  // Should be called after interceptors are done running
  930|      0|  void ContinueFillOpsAfterInterception() override {
  931|      0|    static const size_t MAX_OPS = 6;
  932|      0|    grpc_op ops[MAX_OPS];
  933|      0|    size_t nops = 0;
  934|      0|    this->Op1::AddOp(ops, &nops);
  935|      0|    this->Op2::AddOp(ops, &nops);
  936|      0|    this->Op3::AddOp(ops, &nops);
  937|      0|    this->Op4::AddOp(ops, &nops);
  938|      0|    this->Op5::AddOp(ops, &nops);
  939|      0|    this->Op6::AddOp(ops, &nops);
  940|      0|    GPR_CODEGEN_ASSERT(GRPC_CALL_OK ==
  941|      0|                       g_core_codegen_interface->grpc_call_start_batch(
  942|      0|                           call_.call(), ops, nops, core_cq_tag(), nullptr));
  943|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi5EEENS6_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_24CallOpGenericRecvMessageENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE32ContinueFillOpsAfterInterceptionEv
  ------------------
  944|       |
  945|       |  // Should be called after interceptors are done running on the finalize result
  946|       |  // path
  947|      0|  void ContinueFinalizeResultAfterInterception() override {
  948|      0|    done_intercepting_ = true;
  949|      0|    GPR_CODEGEN_ASSERT(GRPC_CALL_OK ==
  950|      0|                       g_core_codegen_interface->grpc_call_start_batch(
  951|      0|                           call_.call(), nullptr, 0, core_cq_tag(), nullptr));
  952|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi5EEENS6_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_24CallOpGenericRecvMessageENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE39ContinueFinalizeResultAfterInterceptionEv
  ------------------
  953|       |
  954|       | private:
  955|       |  // Returns true if no interceptors need to be run
  956|      0|  bool RunInterceptors() {
  957|      0|    interceptor_methods_.ClearState();
  958|      0|    interceptor_methods_.SetCallOpSetInterface(this);
  959|      0|    interceptor_methods_.SetCall(&call_);
  960|      0|    this->Op1::SetInterceptionHookPoint(&interceptor_methods_);
  961|      0|    this->Op2::SetInterceptionHookPoint(&interceptor_methods_);
  962|      0|    this->Op3::SetInterceptionHookPoint(&interceptor_methods_);
  963|      0|    this->Op4::SetInterceptionHookPoint(&interceptor_methods_);
  964|      0|    this->Op5::SetInterceptionHookPoint(&interceptor_methods_);
  965|      0|    this->Op6::SetInterceptionHookPoint(&interceptor_methods_);
  966|      0|    if (interceptor_methods_.InterceptorsListEmpty()) {
  967|      0|      return true;
  968|      0|    }
  969|      0|    // This call will go through interceptors and would need to
  970|      0|    // schedule new batches, so delay completion queue shutdown
  971|      0|    call_.cq()->RegisterAvalanching();
  972|      0|    return interceptor_methods_.RunInterceptors();
  973|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi5EEENS6_ILi6EEEE15RunInterceptorsEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_24CallOpGenericRecvMessageENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE15RunInterceptorsEv
  ------------------
  974|       |  // Returns true if no interceptors need to be run
  975|      0|  bool RunInterceptorsPostRecv() {
  976|      0|    // Call and OpSet had already been set on the set state.
  977|      0|    // SetReverse also clears previously set hook points
  978|      0|    interceptor_methods_.SetReverse();
  979|      0|    this->Op1::SetFinishInterceptionHookPoint(&interceptor_methods_);
  980|      0|    this->Op2::SetFinishInterceptionHookPoint(&interceptor_methods_);
  981|      0|    this->Op3::SetFinishInterceptionHookPoint(&interceptor_methods_);
  982|      0|    this->Op4::SetFinishInterceptionHookPoint(&interceptor_methods_);
  983|      0|    this->Op5::SetFinishInterceptionHookPoint(&interceptor_methods_);
  984|      0|    this->Op6::SetFinishInterceptionHookPoint(&interceptor_methods_);
  985|      0|    return interceptor_methods_.RunInterceptors();
  986|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_22CallOpServerSendStatusENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi2EEENS5_ILi3EEENS5_ILi4EEENS5_ILi5EEENS5_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_8CallNoOpILi4EEENS5_ILi5EEENS5_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpRecvInitialMetadataENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS6_ILi4EEENS6_ILi5EEENS6_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_25CallOpRecvInitialMetadataENS0_17CallOpRecvMessageINS_10ByteBufferEEENS0_21CallOpClientSendCloseENS0_22CallOpClientRecvStatusEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_22CallOpClientRecvStatusENS0_8CallNoOpILi2EEENS3_ILi3EEENS3_ILi4EEENS3_ILi5EEENS3_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_21CallOpClientSendCloseENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_25CallOpSendInitialMetadataENS0_17CallOpSendMessageENS0_21CallOpClientSendCloseENS0_25CallOpRecvInitialMetadataENS0_8CallNoOpILi5EEENS6_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal9CallOpSetINS0_24CallOpGenericRecvMessageENS0_22CallOpClientRecvStatusENS0_8CallNoOpILi3EEENS4_ILi4EEENS4_ILi5EEENS4_ILi6EEEE23RunInterceptorsPostRecvEv
  ------------------
  987|       |
  988|       |  void* core_cq_tag_;
  989|       |  void* return_tag_;
  990|       |  Call call_;
  991|       |  bool done_intercepting_ = false;
  992|       |  InterceptorBatchMethodsImpl interceptor_methods_;
  993|       |  bool saved_status_;
  994|       |};
  995|       |
  996|       |}  // namespace internal
  997|       |}  // namespace grpc
  998|       |
  999|       |#endif  // GRPCPP_IMPL_CODEGEN_CALL_OP_SET_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/callback_common.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_CALLBACK_COMMON_H
   20|       |#define GRPCPP_IMPL_CODEGEN_CALLBACK_COMMON_H
   21|       |
   22|       |#include <functional>
   23|       |
   24|       |#include <grpc/impl/codegen/grpc_types.h>
   25|       |#include <grpcpp/impl/codegen/call.h>
   26|       |#include <grpcpp/impl/codegen/channel_interface.h>
   27|       |#include <grpcpp/impl/codegen/config.h>
   28|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   29|       |#include <grpcpp/impl/codegen/status.h>
   30|       |
   31|       |namespace grpc {
   32|       |namespace internal {
   33|       |
   34|       |/// An exception-safe way of invoking a user-specified callback function
   35|       |// TODO(vjpai): decide whether it is better for this to take a const lvalue
   36|       |//              parameter or an rvalue parameter, or if it even matters
   37|       |template <class Func, class... Args>
   38|      0|void CatchingCallback(Func&& func, Args&&... args) {
   39|      0|#if GRPC_ALLOW_EXCEPTIONS
   40|      0|  try {
   41|      0|    func(std::forward<Args>(args)...);
   42|      0|  } catch (...) {
   43|      0|    // nothing to return or change here, just don't crash the library
   44|      0|  }
   45|       |#else   // GRPC_ALLOW_EXCEPTIONS
   46|       |  func(std::forward<Args>(args)...);
   47|       |#endif  // GRPC_ALLOW_EXCEPTIONS
   48|       |}
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal16CatchingCallbackINSt3__18functionIFvNS_6StatusEEEEJS4_EEEvOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal16CatchingCallbackIRNSt3__18functionIFvbEEEJRbEEEvOT_DpOT0_
  ------------------
   49|       |
   50|       |template <class ReturnType, class Func, class... Args>
   51|      0|ReturnType* CatchingReactorCreator(Func&& func, Args&&... args) {
   52|      0|#if GRPC_ALLOW_EXCEPTIONS
   53|      0|  try {
   54|      0|    return func(std::forward<Args>(args)...);
   55|      0|  } catch (...) {
   56|      0|    // fail the RPC, don't crash the library
   57|      0|    return nullptr;
   58|      0|  }
   59|       |#else   // GRPC_ALLOW_EXCEPTIONS
   60|       |  return func(std::forward<Args>(args)...);
   61|       |#endif  // GRPC_ALLOW_EXCEPTIONS
   62|       |}
   63|       |
   64|       |// The contract on these tags is that they are single-shot. They must be
   65|       |// constructed and then fired at exactly one point. There is no expectation
   66|       |// that they can be reused without reconstruction.
   67|       |
   68|       |class CallbackWithStatusTag
   69|       |    : public grpc_experimental_completion_queue_functor {
   70|       | public:
   71|       |  // always allocated against a call arena, no memory free required
   72|      0|  static void operator delete(void* ptr, std::size_t size) {
   73|      0|    assert(size == sizeof(CallbackWithStatusTag));
   74|      0|  }
   75|       |
   76|       |  // This operator should never be called as the memory should be freed as part
   77|       |  // of the arena destruction. It only exists to provide a matching operator
   78|       |  // delete to the operator new so that some compilers will not complain (see
   79|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
   80|       |  // there are no tests catching the compiler warning.
   81|      0|  static void operator delete(void*, void*) { assert(0); }
   82|       |
   83|       |  CallbackWithStatusTag(grpc_call* call, std::function<void(Status)> f,
   84|       |                        CompletionQueueTag* ops)
   85|      0|      : call_(call), func_(std::move(f)), ops_(ops) {
   86|      0|    g_core_codegen_interface->grpc_call_ref(call);
   87|      0|    functor_run = &CallbackWithStatusTag::StaticRun;
   88|      0|  }
   89|      0|  ~CallbackWithStatusTag() {}
   90|      0|  Status* status_ptr() { return &status_; }
   91|       |
   92|       |  // force_run can not be performed on a tag if operations using this tag
   93|       |  // have been sent to PerformOpsOnCall. It is intended for error conditions
   94|       |  // that are detected before the operations are internally processed.
   95|      0|  void force_run(Status s) {
   96|      0|    status_ = std::move(s);
   97|      0|    Run(true);
   98|      0|  }
   99|       |
  100|       | private:
  101|       |  grpc_call* call_;
  102|       |  std::function<void(Status)> func_;
  103|       |  CompletionQueueTag* ops_;
  104|       |  Status status_;
  105|       |
  106|       |  static void StaticRun(grpc_experimental_completion_queue_functor* cb,
  107|      0|                        int ok) {
  108|      0|    static_cast<CallbackWithStatusTag*>(cb)->Run(static_cast<bool>(ok));
  109|      0|  }
  110|      0|  void Run(bool ok) {
  111|      0|    void* ignored = ops_;
  112|      0|
  113|      0|    if (!ops_->FinalizeResult(&ignored, &ok)) {
  114|      0|      // The tag was swallowed
  115|      0|      return;
  116|      0|    }
  117|      0|    GPR_CODEGEN_ASSERT(ignored == ops_);
  118|      0|
  119|      0|    // Last use of func_ or status_, so ok to move them out
  120|      0|    auto func = std::move(func_);
  121|      0|    auto status = std::move(status_);
  122|      0|    func_ = nullptr;     // reset to clear this out for sure
  123|      0|    status_ = Status();  // reset to clear this out for sure
  124|      0|    CatchingCallback(std::move(func), std::move(status));
  125|      0|    g_core_codegen_interface->grpc_call_unref(call_);
  126|      0|  }
  127|       |};
  128|       |
  129|       |/// CallbackWithSuccessTag can be reused multiple times, and will be used in
  130|       |/// this fashion for streaming operations. As a result, it shouldn't clear
  131|       |/// anything up until its destructor
  132|       |class CallbackWithSuccessTag
  133|       |    : public grpc_experimental_completion_queue_functor {
  134|       | public:
  135|       |  // always allocated against a call arena, no memory free required
  136|      0|  static void operator delete(void* ptr, std::size_t size) {
  137|      0|    assert(size == sizeof(CallbackWithSuccessTag));
  138|      0|  }
  139|       |
  140|       |  // This operator should never be called as the memory should be freed as part
  141|       |  // of the arena destruction. It only exists to provide a matching operator
  142|       |  // delete to the operator new so that some compilers will not complain (see
  143|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
  144|       |  // there are no tests catching the compiler warning.
  145|      0|  static void operator delete(void*, void*) { assert(0); }
  146|       |
  147|      0|  CallbackWithSuccessTag() : call_(nullptr) {}
  148|       |
  149|       |  CallbackWithSuccessTag(grpc_call* call, std::function<void(bool)> f,
  150|      0|                         CompletionQueueTag* ops) {
  151|      0|    Set(call, f, ops);
  152|      0|  }
  153|       |
  154|       |  CallbackWithSuccessTag(const CallbackWithSuccessTag&) = delete;
  155|       |  CallbackWithSuccessTag& operator=(const CallbackWithSuccessTag&) = delete;
  156|       |
  157|      0|  ~CallbackWithSuccessTag() { Clear(); }
  158|       |
  159|       |  // Set can only be called on a default-constructed or Clear'ed tag.
  160|       |  // It should never be called on a tag that was constructed with arguments
  161|       |  // or on a tag that has been Set before unless the tag has been cleared.
  162|       |  void Set(grpc_call* call, std::function<void(bool)> f,
  163|      0|           CompletionQueueTag* ops) {
  164|      0|    GPR_CODEGEN_ASSERT(call_ == nullptr);
  165|      0|    g_core_codegen_interface->grpc_call_ref(call);
  166|      0|    call_ = call;
  167|      0|    func_ = std::move(f);
  168|      0|    ops_ = ops;
  169|      0|    functor_run = &CallbackWithSuccessTag::StaticRun;
  170|      0|  }
  171|       |
  172|      0|  void Clear() {
  173|      0|    if (call_ != nullptr) {
  174|      0|      grpc_call* call = call_;
  175|      0|      call_ = nullptr;
  176|      0|      func_ = nullptr;
  177|      0|      g_core_codegen_interface->grpc_call_unref(call);
  178|      0|    }
  179|      0|  }
  180|       |
  181|      0|  CompletionQueueTag* ops() { return ops_; }
  182|       |
  183|       |  // force_run can not be performed on a tag if operations using this tag
  184|       |  // have been sent to PerformOpsOnCall. It is intended for error conditions
  185|       |  // that are detected before the operations are internally processed.
  186|      0|  void force_run(bool ok) { Run(ok); }
  187|       |
  188|       |  /// check if this tag is currently set
  189|      0|  operator bool() const { return call_ != nullptr; }
  190|       |
  191|       | private:
  192|       |  grpc_call* call_;
  193|       |  std::function<void(bool)> func_;
  194|       |  CompletionQueueTag* ops_;
  195|       |
  196|       |  static void StaticRun(grpc_experimental_completion_queue_functor* cb,
  197|      0|                        int ok) {
  198|      0|    static_cast<CallbackWithSuccessTag*>(cb)->Run(static_cast<bool>(ok));
  199|      0|  }
  200|      0|  void Run(bool ok) {
  201|      0|    void* ignored = ops_;
  202|      0|    // Allow a "false" return value from FinalizeResult to silence the
  203|      0|    // callback, just as it silences a CQ tag in the async cases
  204|      0|    auto* ops = ops_;
  205|      0|    bool do_callback = ops_->FinalizeResult(&ignored, &ok);
  206|      0|    GPR_CODEGEN_ASSERT(ignored == ops);
  207|      0|
  208|      0|    if (do_callback) {
  209|      0|      CatchingCallback(func_, ok);
  210|      0|    }
  211|      0|  }
  212|       |};
  213|       |
  214|       |}  // namespace internal
  215|       |}  // namespace grpc
  216|       |
  217|       |#endif  // GRPCPP_IMPL_CODEGEN_CALLBACK_COMMON_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/channel_interface.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_CHANNEL_INTERFACE_H
   20|       |#define GRPCPP_IMPL_CODEGEN_CHANNEL_INTERFACE_H
   21|       |
   22|       |#include <grpc/impl/codegen/connectivity_state.h>
   23|       |#include <grpcpp/impl/codegen/call.h>
   24|       |#include <grpcpp/impl/codegen/status.h>
   25|       |#include <grpcpp/impl/codegen/time.h>
   26|       |
   27|       |namespace grpc_impl {
   28|       |class CompletionQueue;
   29|       |}
   30|       |
   31|       |namespace grpc {
   32|       |class ChannelInterface;
   33|       |class ClientContext;
   34|       |
   35|       |template <class R>
   36|       |class ClientReader;
   37|       |template <class W>
   38|       |class ClientWriter;
   39|       |template <class W, class R>
   40|       |class ClientReaderWriter;
   41|       |
   42|       |namespace internal {
   43|       |class Call;
   44|       |class CallOpSetInterface;
   45|       |class RpcMethod;
   46|       |template <class InputMessage, class OutputMessage>
   47|       |class BlockingUnaryCallImpl;
   48|       |template <class InputMessage, class OutputMessage>
   49|       |class CallbackUnaryCallImpl;
   50|       |template <class R>
   51|       |class ClientAsyncReaderFactory;
   52|       |template <class W>
   53|       |class ClientAsyncWriterFactory;
   54|       |template <class W, class R>
   55|       |class ClientAsyncReaderWriterFactory;
   56|       |template <class R>
   57|       |class ClientAsyncResponseReaderFactory;
   58|       |template <class W, class R>
   59|       |class ClientCallbackReaderWriterFactory;
   60|       |template <class R>
   61|       |class ClientCallbackReaderFactory;
   62|       |template <class W>
   63|       |class ClientCallbackWriterFactory;
   64|       |class ClientCallbackUnaryFactory;
   65|       |class InterceptedChannel;
   66|       |}  // namespace internal
   67|       |
   68|       |/// Codegen interface for \a grpc::Channel.
   69|       |class ChannelInterface {
   70|       | public:
   71|      0|  virtual ~ChannelInterface() {}
   72|       |  /// Get the current channel state. If the channel is in IDLE and
   73|       |  /// \a try_to_connect is set to true, try to connect.
   74|       |  virtual grpc_connectivity_state GetState(bool try_to_connect) = 0;
   75|       |
   76|       |  /// Return the \a tag on \a cq when the channel state is changed or \a
   77|       |  /// deadline expires. \a GetState needs to called to get the current state.
   78|       |  template <typename T>
   79|       |  void NotifyOnStateChange(grpc_connectivity_state last_observed, T deadline,
   80|       |                           ::grpc_impl::CompletionQueue* cq, void* tag) {
   81|       |    TimePoint<T> deadline_tp(deadline);
   82|       |    NotifyOnStateChangeImpl(last_observed, deadline_tp.raw_time(), cq, tag);
   83|       |  }
   84|       |
   85|       |  /// Blocking wait for channel state change or \a deadline expiration.
   86|       |  /// \a GetState needs to called to get the current state.
   87|       |  template <typename T>
   88|       |  bool WaitForStateChange(grpc_connectivity_state last_observed, T deadline) {
   89|       |    TimePoint<T> deadline_tp(deadline);
   90|       |    return WaitForStateChangeImpl(last_observed, deadline_tp.raw_time());
   91|       |  }
   92|       |
   93|       |  /// Wait for this channel to be connected
   94|       |  template <typename T>
   95|       |  bool WaitForConnected(T deadline) {
   96|       |    grpc_connectivity_state state;
   97|       |    while ((state = GetState(true)) != GRPC_CHANNEL_READY) {
   98|       |      if (!WaitForStateChange(state, deadline)) return false;
   99|       |    }
  100|       |    return true;
  101|       |  }
  102|       |
  103|       | private:
  104|       |  template <class R>
  105|       |  friend class ::grpc::ClientReader;
  106|       |  template <class W>
  107|       |  friend class ::grpc::ClientWriter;
  108|       |  template <class W, class R>
  109|       |  friend class ::grpc::ClientReaderWriter;
  110|       |  template <class R>
  111|       |  friend class ::grpc::internal::ClientAsyncReaderFactory;
  112|       |  template <class W>
  113|       |  friend class ::grpc::internal::ClientAsyncWriterFactory;
  114|       |  template <class W, class R>
  115|       |  friend class ::grpc::internal::ClientAsyncReaderWriterFactory;
  116|       |  template <class R>
  117|       |  friend class ::grpc::internal::ClientAsyncResponseReaderFactory;
  118|       |  template <class W, class R>
  119|       |  friend class ::grpc::internal::ClientCallbackReaderWriterFactory;
  120|       |  template <class R>
  121|       |  friend class ::grpc::internal::ClientCallbackReaderFactory;
  122|       |  template <class W>
  123|       |  friend class ::grpc::internal::ClientCallbackWriterFactory;
  124|       |  friend class ::grpc::internal::ClientCallbackUnaryFactory;
  125|       |  template <class InputMessage, class OutputMessage>
  126|       |  friend class ::grpc::internal::BlockingUnaryCallImpl;
  127|       |  template <class InputMessage, class OutputMessage>
  128|       |  friend class ::grpc::internal::CallbackUnaryCallImpl;
  129|       |  friend class ::grpc::internal::RpcMethod;
  130|       |  friend class ::grpc::internal::InterceptedChannel;
  131|       |  virtual internal::Call CreateCall(const internal::RpcMethod& method,
  132|       |                                    ClientContext* context,
  133|       |                                    ::grpc_impl::CompletionQueue* cq) = 0;
  134|       |  virtual void PerformOpsOnCall(internal::CallOpSetInterface* ops,
  135|       |                                internal::Call* call) = 0;
  136|       |  virtual void* RegisterMethod(const char* method) = 0;
  137|       |  virtual void NotifyOnStateChangeImpl(grpc_connectivity_state last_observed,
  138|       |                                       gpr_timespec deadline,
  139|       |                                       ::grpc_impl::CompletionQueue* cq,
  140|       |                                       void* tag) = 0;
  141|       |  virtual bool WaitForStateChangeImpl(grpc_connectivity_state last_observed,
  142|       |                                      gpr_timespec deadline) = 0;
  143|       |
  144|       |  // EXPERIMENTAL
  145|       |  // This is needed to keep codegen_test_minimal happy. InterceptedChannel needs
  146|       |  // to make use of this but can't directly call Channel's implementation
  147|       |  // because of the test.
  148|       |  // Returns an empty Call object (rather than being pure) since this is a new
  149|       |  // method and adding a new pure method to an interface would be a breaking
  150|       |  // change (even though this is private and non-API)
  151|       |  virtual internal::Call CreateCallInternal(const internal::RpcMethod& method,
  152|       |                                            ClientContext* context,
  153|       |                                            ::grpc_impl::CompletionQueue* cq,
  154|      0|                                            size_t interceptor_pos) {
  155|      0|    return internal::Call();
  156|      0|  }
  157|       |
  158|       |  // EXPERIMENTAL
  159|       |  // A method to get the callbackable completion queue associated with this
  160|       |  // channel. If the return value is nullptr, this channel doesn't support
  161|       |  // callback operations.
  162|       |  // TODO(vjpai): Consider a better default like using a global CQ
  163|       |  // Returns nullptr (rather than being pure) since this is a post-1.0 method
  164|       |  // and adding a new pure method to an interface would be a breaking change
  165|       |  // (even though this is private and non-API)
  166|      0|  virtual ::grpc_impl::CompletionQueue* CallbackCQ() { return nullptr; }
  167|       |};
  168|       |}  // namespace grpc
  169|       |
  170|       |#endif  // GRPCPP_IMPL_CODEGEN_CHANNEL_INTERFACE_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/client_callback.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_CLIENT_CALLBACK_H
   20|       |#define GRPCPP_IMPL_CODEGEN_CLIENT_CALLBACK_H
   21|       |
   22|       |#include <functional>
   23|       |
   24|       |#include <grpcpp/impl/codegen/call.h>
   25|       |#include <grpcpp/impl/codegen/call_op_set.h>
   26|       |#include <grpcpp/impl/codegen/callback_common.h>
   27|       |#include <grpcpp/impl/codegen/channel_interface.h>
   28|       |#include <grpcpp/impl/codegen/config.h>
   29|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   30|       |#include <grpcpp/impl/codegen/status.h>
   31|       |
   32|       |namespace grpc_impl {
   33|       |class Channel;
   34|       |}
   35|       |
   36|       |namespace grpc {
   37|       |
   38|       |class ClientContext;
   39|       |
   40|       |namespace internal {
   41|       |class RpcMethod;
   42|       |
   43|       |/// Perform a callback-based unary call
   44|       |/// TODO(vjpai): Combine as much as possible with the blocking unary call code
   45|       |template <class InputMessage, class OutputMessage>
   46|       |void CallbackUnaryCall(ChannelInterface* channel, const RpcMethod& method,
   47|       |                       ClientContext* context, const InputMessage* request,
   48|       |                       OutputMessage* result,
   49|      0|                       std::function<void(Status)> on_completion) {
   50|      0|  CallbackUnaryCallImpl<InputMessage, OutputMessage> x(
   51|      0|      channel, method, context, request, result, on_completion);
   52|      0|}
   53|       |
   54|       |template <class InputMessage, class OutputMessage>
   55|       |class CallbackUnaryCallImpl {
   56|       | public:
   57|       |  CallbackUnaryCallImpl(ChannelInterface* channel, const RpcMethod& method,
   58|       |                        ClientContext* context, const InputMessage* request,
   59|       |                        OutputMessage* result,
   60|      0|                        std::function<void(Status)> on_completion) {
   61|      0|    CompletionQueue* cq = channel->CallbackCQ();
   62|      0|    GPR_CODEGEN_ASSERT(cq != nullptr);
   63|      0|    Call call(channel->CreateCall(method, context, cq));
   64|      0|
   65|      0|    using FullCallOpSet =
   66|      0|        CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage,
   67|      0|                  CallOpRecvInitialMetadata, CallOpRecvMessage<OutputMessage>,
   68|      0|                  CallOpClientSendClose, CallOpClientRecvStatus>;
   69|      0|
   70|      0|    auto* ops = new (g_core_codegen_interface->grpc_call_arena_alloc(
   71|      0|        call.call(), sizeof(FullCallOpSet))) FullCallOpSet;
   72|      0|
   73|      0|    auto* tag = new (g_core_codegen_interface->grpc_call_arena_alloc(
   74|      0|        call.call(), sizeof(CallbackWithStatusTag)))
   75|      0|        CallbackWithStatusTag(call.call(), on_completion, ops);
   76|      0|
   77|      0|    // TODO(vjpai): Unify code with sync API as much as possible
   78|      0|    Status s = ops->SendMessagePtr(request);
   79|      0|    if (!s.ok()) {
   80|      0|      tag->force_run(s);
   81|      0|      return;
   82|      0|    }
   83|      0|    ops->SendInitialMetadata(&context->send_initial_metadata_,
   84|      0|                             context->initial_metadata_flags());
   85|      0|    ops->RecvInitialMetadata(context);
   86|      0|    ops->RecvMessage(result);
   87|      0|    ops->AllowNoMessage();
   88|      0|    ops->ClientSendClose();
   89|      0|    ops->ClientRecvStatus(context, tag->status_ptr());
   90|      0|    ops->set_core_cq_tag(tag);
   91|      0|    call.PerformOps(ops);
   92|      0|  }
   93|       |};
   94|       |}  // namespace internal
   95|       |
   96|       |namespace experimental {
   97|       |
   98|       |// Forward declarations
   99|       |template <class Request, class Response>
  100|       |class ClientBidiReactor;
  101|       |template <class Response>
  102|       |class ClientReadReactor;
  103|       |template <class Request>
  104|       |class ClientWriteReactor;
  105|       |class ClientUnaryReactor;
  106|       |
  107|       |// NOTE: The streaming objects are not actually implemented in the public API.
  108|       |//       These interfaces are provided for mocking only. Typical applications
  109|       |//       will interact exclusively with the reactors that they define.
  110|       |template <class Request, class Response>
  111|       |class ClientCallbackReaderWriter {
  112|       | public:
  113|      0|  virtual ~ClientCallbackReaderWriter() {}
  114|       |  virtual void StartCall() = 0;
  115|       |  virtual void Write(const Request* req, WriteOptions options) = 0;
  116|       |  virtual void WritesDone() = 0;
  117|       |  virtual void Read(Response* resp) = 0;
  118|       |  virtual void AddHold(int holds) = 0;
  119|       |  virtual void RemoveHold() = 0;
  120|       |
  121|       | protected:
  122|      0|  void BindReactor(ClientBidiReactor<Request, Response>* reactor) {
  123|      0|    reactor->BindStream(this);
  124|      0|  }
  125|       |};
  126|       |
  127|       |template <class Response>
  128|       |class ClientCallbackReader {
  129|       | public:
  130|       |  virtual ~ClientCallbackReader() {}
  131|       |  virtual void StartCall() = 0;
  132|       |  virtual void Read(Response* resp) = 0;
  133|       |  virtual void AddHold(int holds) = 0;
  134|       |  virtual void RemoveHold() = 0;
  135|       |
  136|       | protected:
  137|       |  void BindReactor(ClientReadReactor<Response>* reactor) {
  138|       |    reactor->BindReader(this);
  139|       |  }
  140|       |};
  141|       |
  142|       |template <class Request>
  143|       |class ClientCallbackWriter {
  144|       | public:
  145|       |  virtual ~ClientCallbackWriter() {}
  146|       |  virtual void StartCall() = 0;
  147|       |  void Write(const Request* req) { Write(req, WriteOptions()); }
  148|       |  virtual void Write(const Request* req, WriteOptions options) = 0;
  149|       |  void WriteLast(const Request* req, WriteOptions options) {
  150|       |    Write(req, options.set_last_message());
  151|       |  }
  152|       |  virtual void WritesDone() = 0;
  153|       |
  154|       |  virtual void AddHold(int holds) = 0;
  155|       |  virtual void RemoveHold() = 0;
  156|       |
  157|       | protected:
  158|       |  void BindReactor(ClientWriteReactor<Request>* reactor) {
  159|       |    reactor->BindWriter(this);
  160|       |  }
  161|       |};
  162|       |
  163|       |class ClientCallbackUnary {
  164|       | public:
  165|      0|  virtual ~ClientCallbackUnary() {}
  166|       |  virtual void StartCall() = 0;
  167|       |
  168|       | protected:
  169|       |  void BindReactor(ClientUnaryReactor* reactor);
  170|       |};
  171|       |
  172|       |// The following classes are the reactor interfaces that are to be implemented
  173|       |// by the user. They are passed in to the library as an argument to a call on a
  174|       |// stub (either a codegen-ed call or a generic call). The streaming RPC is
  175|       |// activated by calling StartCall, possibly after initiating StartRead,
  176|       |// StartWrite, or AddHold operations on the streaming object. Note that none of
  177|       |// the classes are pure; all reactions have a default empty reaction so that the
  178|       |// user class only needs to override those classes that it cares about.
  179|       |// The reactor must be passed to the stub invocation before any of the below
  180|       |// operations can be called.
  181|       |
  182|       |/// \a ClientBidiReactor is the interface for a bidirectional streaming RPC.
  183|       |template <class Request, class Response>
  184|       |class ClientBidiReactor {
  185|       | public:
  186|       |  virtual ~ClientBidiReactor() {}
  187|       |
  188|       |  /// Activate the RPC and initiate any reads or writes that have been Start'ed
  189|       |  /// before this call. All streaming RPCs issued by the client MUST have
  190|       |  /// StartCall invoked on them (even if they are canceled) as this call is the
  191|       |  /// activation of their lifecycle.
  192|       |  void StartCall() { stream_->StartCall(); }
  193|       |
  194|       |  /// Initiate a read operation (or post it for later initiation if StartCall
  195|       |  /// has not yet been invoked).
  196|       |  ///
  197|       |  /// \param[out] resp Where to eventually store the read message. Valid when
  198|       |  ///                  the library calls OnReadDone
  199|       |  void StartRead(Response* resp) { stream_->Read(resp); }
  200|       |
  201|       |  /// Initiate a write operation (or post it for later initiation if StartCall
  202|       |  /// has not yet been invoked).
  203|       |  ///
  204|       |  /// \param[in] req The message to be written. The library takes temporary
  205|       |  ///                ownership until OnWriteDone, at which point the application
  206|       |  ///                regains ownership of msg.
  207|       |  void StartWrite(const Request* req) { StartWrite(req, WriteOptions()); }
  208|       |
  209|       |  /// Initiate/post a write operation with specified options.
  210|       |  ///
  211|       |  /// \param[in] req The message to be written. The library takes temporary
  212|       |  ///                ownership until OnWriteDone, at which point the application
  213|       |  ///                regains ownership of msg.
  214|       |  /// \param[in] options The WriteOptions to use for writing this message
  215|       |  void StartWrite(const Request* req, WriteOptions options) {
  216|       |    stream_->Write(req, std::move(options));
  217|       |  }
  218|       |
  219|       |  /// Initiate/post a write operation with specified options and an indication
  220|       |  /// that this is the last write (like StartWrite and StartWritesDone, merged).
  221|       |  /// Note that calling this means that no more calls to StartWrite,
  222|       |  /// StartWriteLast, or StartWritesDone are allowed.
  223|       |  ///
  224|       |  /// \param[in] req The message to be written. The library takes temporary
  225|       |  ///                ownership until OnWriteDone, at which point the application
  226|       |  ///                regains ownership of msg.
  227|       |  /// \param[in] options The WriteOptions to use for writing this message
  228|       |  void StartWriteLast(const Request* req, WriteOptions options) {
  229|       |    StartWrite(req, std::move(options.set_last_message()));
  230|       |  }
  231|       |
  232|       |  /// Indicate that the RPC will have no more write operations. This can only be
  233|       |  /// issued once for a given RPC. This is not required or allowed if
  234|       |  /// StartWriteLast is used since that already has the same implication.
  235|       |  /// Note that calling this means that no more calls to StartWrite,
  236|       |  /// StartWriteLast, or StartWritesDone are allowed.
  237|       |  void StartWritesDone() { stream_->WritesDone(); }
  238|       |
  239|       |  /// Holds are needed if (and only if) this stream has operations that take
  240|       |  /// place on it after StartCall but from outside one of the reactions
  241|       |  /// (OnReadDone, etc). This is _not_ a common use of the streaming API.
  242|       |  ///
  243|       |  /// Holds must be added before calling StartCall. If a stream still has a hold
  244|       |  /// in place, its resources will not be destroyed even if the status has
  245|       |  /// already come in from the wire and there are currently no active callbacks
  246|       |  /// outstanding. Similarly, the stream will not call OnDone if there are still
  247|       |  /// holds on it.
  248|       |  ///
  249|       |  /// For example, if a StartRead or StartWrite operation is going to be
  250|       |  /// initiated from elsewhere in the application, the application should call
  251|       |  /// AddHold or AddMultipleHolds before StartCall.  If there is going to be,
  252|       |  /// for example, a read-flow and a write-flow taking place outside the
  253|       |  /// reactions, then call AddMultipleHolds(2) before StartCall. When the
  254|       |  /// application knows that it won't issue any more read operations (such as
  255|       |  /// when a read comes back as not ok), it should issue a RemoveHold(). It
  256|       |  /// should also call RemoveHold() again after it does StartWriteLast or
  257|       |  /// StartWritesDone that indicates that there will be no more write ops.
  258|       |  /// The number of RemoveHold calls must match the total number of AddHold
  259|       |  /// calls plus the number of holds added by AddMultipleHolds.
  260|       |  void AddHold() { AddMultipleHolds(1); }
  261|       |  void AddMultipleHolds(int holds) { stream_->AddHold(holds); }
  262|       |  void RemoveHold() { stream_->RemoveHold(); }
  263|       |
  264|       |  /// Notifies the application that all operations associated with this RPC
  265|       |  /// have completed and provides the RPC status outcome.
  266|       |  ///
  267|       |  /// \param[in] s The status outcome of this RPC
  268|      0|  virtual void OnDone(const Status& s) {}
  269|       |
  270|       |  /// Notifies the application that a read of initial metadata from the
  271|       |  /// server is done. If the application chooses not to implement this method,
  272|       |  /// it can assume that the initial metadata has been read before the first
  273|       |  /// call of OnReadDone or OnDone.
  274|       |  ///
  275|       |  /// \param[in] ok Was the initial metadata read successfully? If false, no
  276|       |  ///               further read-side operation will succeed.
  277|      0|  virtual void OnReadInitialMetadataDone(bool ok) {}
  278|       |
  279|       |  /// Notifies the application that a StartRead operation completed.
  280|       |  ///
  281|       |  /// \param[in] ok Was it successful? If false, no further read-side operation
  282|       |  ///               will succeed.
  283|      0|  virtual void OnReadDone(bool ok) {}
  284|       |
  285|       |  /// Notifies the application that a StartWrite operation completed.
  286|       |  ///
  287|       |  /// \param[in] ok Was it successful? If false, no further write-side operation
  288|       |  ///               will succeed.
  289|      0|  virtual void OnWriteDone(bool ok) {}
  290|       |
  291|       |  /// Notifies the application that a StartWritesDone operation completed. Note
  292|       |  /// that this is only used on explicit StartWritesDone operations and not for
  293|       |  /// those that are implicitly invoked as part of a StartWriteLast.
  294|       |  ///
  295|       |  /// \param[in] ok Was it successful? If false, the application will later see
  296|       |  ///               the failure reflected as a bad status in OnDone.
  297|      0|  virtual void OnWritesDoneDone(bool ok) {}
  298|       |
  299|       | private:
  300|       |  friend class ClientCallbackReaderWriter<Request, Response>;
  301|      0|  void BindStream(ClientCallbackReaderWriter<Request, Response>* stream) {
  302|      0|    stream_ = stream;
  303|      0|  }
  304|       |  ClientCallbackReaderWriter<Request, Response>* stream_;
  305|       |};
  306|       |
  307|       |/// \a ClientReadReactor is the interface for a server-streaming RPC.
  308|       |/// All public methods behave as in ClientBidiReactor.
  309|       |template <class Response>
  310|       |class ClientReadReactor {
  311|       | public:
  312|       |  virtual ~ClientReadReactor() {}
  313|       |
  314|       |  void StartCall() { reader_->StartCall(); }
  315|       |  void StartRead(Response* resp) { reader_->Read(resp); }
  316|       |
  317|       |  void AddHold() { AddMultipleHolds(1); }
  318|       |  void AddMultipleHolds(int holds) { reader_->AddHold(holds); }
  319|       |  void RemoveHold() { reader_->RemoveHold(); }
  320|       |
  321|       |  virtual void OnDone(const Status& s) {}
  322|       |  virtual void OnReadInitialMetadataDone(bool ok) {}
  323|       |  virtual void OnReadDone(bool ok) {}
  324|       |
  325|       | private:
  326|       |  friend class ClientCallbackReader<Response>;
  327|       |  void BindReader(ClientCallbackReader<Response>* reader) { reader_ = reader; }
  328|       |  ClientCallbackReader<Response>* reader_;
  329|       |};
  330|       |
  331|       |/// \a ClientWriteReactor is the interface for a client-streaming RPC.
  332|       |/// All public methods behave as in ClientBidiReactor.
  333|       |template <class Request>
  334|       |class ClientWriteReactor {
  335|       | public:
  336|       |  virtual ~ClientWriteReactor() {}
  337|       |
  338|       |  void StartCall() { writer_->StartCall(); }
  339|       |  void StartWrite(const Request* req) { StartWrite(req, WriteOptions()); }
  340|       |  void StartWrite(const Request* req, WriteOptions options) {
  341|       |    writer_->Write(req, std::move(options));
  342|       |  }
  343|       |  void StartWriteLast(const Request* req, WriteOptions options) {
  344|       |    StartWrite(req, std::move(options.set_last_message()));
  345|       |  }
  346|       |  void StartWritesDone() { writer_->WritesDone(); }
  347|       |
  348|       |  void AddHold() { AddMultipleHolds(1); }
  349|       |  void AddMultipleHolds(int holds) { writer_->AddHold(holds); }
  350|       |  void RemoveHold() { writer_->RemoveHold(); }
  351|       |
  352|       |  virtual void OnDone(const Status& s) {}
  353|       |  virtual void OnReadInitialMetadataDone(bool ok) {}
  354|       |  virtual void OnWriteDone(bool ok) {}
  355|       |  virtual void OnWritesDoneDone(bool ok) {}
  356|       |
  357|       | private:
  358|       |  friend class ClientCallbackWriter<Request>;
  359|       |  void BindWriter(ClientCallbackWriter<Request>* writer) { writer_ = writer; }
  360|       |  ClientCallbackWriter<Request>* writer_;
  361|       |};
  362|       |
  363|       |/// \a ClientUnaryReactor is a reactor-style interface for a unary RPC.
  364|       |/// This is _not_ a common way of invoking a unary RPC. In practice, this
  365|       |/// option should be used only if the unary RPC wants to receive initial
  366|       |/// metadata without waiting for the response to complete. Most deployments of
  367|       |/// RPC systems do not use this option, but it is needed for generality.
  368|       |/// All public methods behave as in ClientBidiReactor.
  369|       |/// StartCall is included for consistency with the other reactor flavors: even
  370|       |/// though there are no StartRead or StartWrite operations to queue before the
  371|       |/// call (that is part of the unary call itself) and there is no reactor object
  372|       |/// being created as a result of this call, we keep a consistent 2-phase
  373|       |/// initiation API among all the reactor flavors.
  374|       |class ClientUnaryReactor {
  375|       | public:
  376|      0|  virtual ~ClientUnaryReactor() {}
  377|       |
  378|      0|  void StartCall() { call_->StartCall(); }
  379|      0|  virtual void OnDone(const Status& s) {}
  380|      0|  virtual void OnReadInitialMetadataDone(bool ok) {}
  381|       |
  382|       | private:
  383|       |  friend class ClientCallbackUnary;
  384|      0|  void BindCall(ClientCallbackUnary* call) { call_ = call; }
  385|       |  ClientCallbackUnary* call_;
  386|       |};
  387|       |
  388|       |// Define function out-of-line from class to avoid forward declaration issue
  389|      0|inline void ClientCallbackUnary::BindReactor(ClientUnaryReactor* reactor) {
  390|      0|  reactor->BindCall(this);
  391|      0|}
  392|       |
  393|       |}  // namespace experimental
  394|       |
  395|       |namespace internal {
  396|       |
  397|       |// Forward declare factory classes for friendship
  398|       |template <class Request, class Response>
  399|       |class ClientCallbackReaderWriterFactory;
  400|       |template <class Response>
  401|       |class ClientCallbackReaderFactory;
  402|       |template <class Request>
  403|       |class ClientCallbackWriterFactory;
  404|       |
  405|       |template <class Request, class Response>
  406|       |class ClientCallbackReaderWriterImpl
  407|       |    : public ::grpc::experimental::ClientCallbackReaderWriter<Request,
  408|       |                                                              Response> {
  409|       | public:
  410|       |  // always allocated against a call arena, no memory free required
  411|      0|  static void operator delete(void* ptr, std::size_t size) {
  412|      0|    assert(size == sizeof(ClientCallbackReaderWriterImpl));
  413|      0|  }
  414|       |
  415|       |  // This operator should never be called as the memory should be freed as part
  416|       |  // of the arena destruction. It only exists to provide a matching operator
  417|       |  // delete to the operator new so that some compilers will not complain (see
  418|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
  419|       |  // there are no tests catching the compiler warning.
  420|      0|  static void operator delete(void*, void*) { assert(0); }
  421|       |
  422|      0|  void MaybeFinish() {
  423|      0|    if (--callbacks_outstanding_ == 0) {
  424|      0|      Status s = std::move(finish_status_);
  425|      0|      auto* reactor = reactor_;
  426|      0|      auto* call = call_.call();
  427|      0|      this->~ClientCallbackReaderWriterImpl();
  428|      0|      g_core_codegen_interface->grpc_call_unref(call);
  429|      0|      reactor->OnDone(s);
  430|      0|    }
  431|      0|  }
  432|       |
  433|      0|  void StartCall() override {
  434|      0|    // This call initiates two batches, plus any backlog, each with a callback
  435|      0|    // 1. Send initial metadata (unless corked) + recv initial metadata
  436|      0|    // 2. Any read backlog
  437|      0|    // 3. Any write backlog
  438|      0|    // 4. Recv trailing metadata, on_completion callback
  439|      0|    started_ = true;
  440|      0|
  441|      0|    start_tag_.Set(call_.call(),
  442|      0|                   [this](bool ok) {
  443|      0|                     reactor_->OnReadInitialMetadataDone(ok);
  444|      0|                     MaybeFinish();
  445|      0|                   },
  446|      0|                   &start_ops_);
  447|      0|    if (!start_corked_) {
  448|      0|      start_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  449|      0|                                     context_->initial_metadata_flags());
  450|      0|    }
  451|      0|    start_ops_.RecvInitialMetadata(context_);
  452|      0|    start_ops_.set_core_cq_tag(&start_tag_);
  453|      0|    call_.PerformOps(&start_ops_);
  454|      0|
  455|      0|    // Also set up the read and write tags so that they don't have to be set up
  456|      0|    // each time
  457|      0|    write_tag_.Set(call_.call(),
  458|      0|                   [this](bool ok) {
  459|      0|                     reactor_->OnWriteDone(ok);
  460|      0|                     MaybeFinish();
  461|      0|                   },
  462|      0|                   &write_ops_);
  463|      0|    write_ops_.set_core_cq_tag(&write_tag_);
  464|      0|
  465|      0|    read_tag_.Set(call_.call(),
  466|      0|                  [this](bool ok) {
  467|      0|                    reactor_->OnReadDone(ok);
  468|      0|                    MaybeFinish();
  469|      0|                  },
  470|      0|                  &read_ops_);
  471|      0|    read_ops_.set_core_cq_tag(&read_tag_);
  472|      0|    if (read_ops_at_start_) {
  473|      0|      call_.PerformOps(&read_ops_);
  474|      0|    }
  475|      0|
  476|      0|    if (write_ops_at_start_) {
  477|      0|      call_.PerformOps(&write_ops_);
  478|      0|    }
  479|      0|
  480|      0|    if (writes_done_ops_at_start_) {
  481|      0|      call_.PerformOps(&writes_done_ops_);
  482|      0|    }
  483|      0|
  484|      0|    finish_tag_.Set(call_.call(), [this](bool ok) { MaybeFinish(); },
  485|      0|                    &finish_ops_);
  486|      0|    finish_ops_.ClientRecvStatus(context_, &finish_status_);
  487|      0|    finish_ops_.set_core_cq_tag(&finish_tag_);
  488|      0|    call_.PerformOps(&finish_ops_);
  489|      0|  }
  490|       |
  491|      0|  void Read(Response* msg) override {
  492|      0|    read_ops_.RecvMessage(msg);
  493|      0|    callbacks_outstanding_++;
  494|      0|    if (started_) {
  495|      0|      call_.PerformOps(&read_ops_);
  496|      0|    } else {
  497|      0|      read_ops_at_start_ = true;
  498|      0|    }
  499|      0|  }
  500|       |
  501|      0|  void Write(const Request* msg, WriteOptions options) override {
  502|      0|    if (start_corked_) {
  503|      0|      write_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  504|      0|                                     context_->initial_metadata_flags());
  505|      0|      start_corked_ = false;
  506|      0|    }
  507|      0|
  508|      0|    if (options.is_last_message()) {
  509|      0|      options.set_buffer_hint();
  510|      0|      write_ops_.ClientSendClose();
  511|      0|    }
  512|      0|    // TODO(vjpai): don't assert
  513|      0|    GPR_CODEGEN_ASSERT(write_ops_.SendMessagePtr(msg, options).ok());
  514|      0|    callbacks_outstanding_++;
  515|      0|    if (started_) {
  516|      0|      call_.PerformOps(&write_ops_);
  517|      0|    } else {
  518|      0|      write_ops_at_start_ = true;
  519|      0|    }
  520|      0|  }
  521|      0|  void WritesDone() override {
  522|      0|    if (start_corked_) {
  523|      0|      writes_done_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  524|      0|                                           context_->initial_metadata_flags());
  525|      0|      start_corked_ = false;
  526|      0|    }
  527|      0|    writes_done_ops_.ClientSendClose();
  528|      0|    writes_done_tag_.Set(call_.call(),
  529|      0|                         [this](bool ok) {
  530|      0|                           reactor_->OnWritesDoneDone(ok);
  531|      0|                           MaybeFinish();
  532|      0|                         },
  533|      0|                         &writes_done_ops_);
  534|      0|    writes_done_ops_.set_core_cq_tag(&writes_done_tag_);
  535|      0|    callbacks_outstanding_++;
  536|      0|    if (started_) {
  537|      0|      call_.PerformOps(&writes_done_ops_);
  538|      0|    } else {
  539|      0|      writes_done_ops_at_start_ = true;
  540|      0|    }
  541|      0|  }
  542|       |
  543|      0|  virtual void AddHold(int holds) override { callbacks_outstanding_ += holds; }
  544|      0|  virtual void RemoveHold() override { MaybeFinish(); }
  545|       |
  546|       | private:
  547|       |  friend class ClientCallbackReaderWriterFactory<Request, Response>;
  548|       |
  549|       |  ClientCallbackReaderWriterImpl(
  550|       |      Call call, ClientContext* context,
  551|       |      ::grpc::experimental::ClientBidiReactor<Request, Response>* reactor)
  552|       |      : context_(context),
  553|       |        call_(call),
  554|       |        reactor_(reactor),
  555|      0|        start_corked_(context_->initial_metadata_corked_) {
  556|      0|    this->BindReactor(reactor);
  557|      0|  }
  558|       |
  559|       |  ClientContext* const context_;
  560|       |  Call call_;
  561|       |  ::grpc::experimental::ClientBidiReactor<Request, Response>* const reactor_;
  562|       |
  563|       |  CallOpSet<CallOpSendInitialMetadata, CallOpRecvInitialMetadata> start_ops_;
  564|       |  CallbackWithSuccessTag start_tag_;
  565|       |  bool start_corked_;
  566|       |
  567|       |  CallOpSet<CallOpClientRecvStatus> finish_ops_;
  568|       |  CallbackWithSuccessTag finish_tag_;
  569|       |  Status finish_status_;
  570|       |
  571|       |  CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage, CallOpClientSendClose>
  572|       |      write_ops_;
  573|       |  CallbackWithSuccessTag write_tag_;
  574|       |  bool write_ops_at_start_{false};
  575|       |
  576|       |  CallOpSet<CallOpSendInitialMetadata, CallOpClientSendClose> writes_done_ops_;
  577|       |  CallbackWithSuccessTag writes_done_tag_;
  578|       |  bool writes_done_ops_at_start_{false};
  579|       |
  580|       |  CallOpSet<CallOpRecvMessage<Response>> read_ops_;
  581|       |  CallbackWithSuccessTag read_tag_;
  582|       |  bool read_ops_at_start_{false};
  583|       |
  584|       |  // Minimum of 2 callbacks to pre-register for start and finish
  585|       |  std::atomic_int callbacks_outstanding_{2};
  586|       |  bool started_{false};
  587|       |};
  588|       |
  589|       |template <class Request, class Response>
  590|       |class ClientCallbackReaderWriterFactory {
  591|       | public:
  592|       |  static void Create(
  593|       |      ChannelInterface* channel, const ::grpc::internal::RpcMethod& method,
  594|       |      ClientContext* context,
  595|      0|      ::grpc::experimental::ClientBidiReactor<Request, Response>* reactor) {
  596|      0|    Call call = channel->CreateCall(method, context, channel->CallbackCQ());
  597|      0|
  598|      0|    g_core_codegen_interface->grpc_call_ref(call.call());
  599|      0|    new (g_core_codegen_interface->grpc_call_arena_alloc(
  600|      0|        call.call(), sizeof(ClientCallbackReaderWriterImpl<Request, Response>)))
  601|      0|        ClientCallbackReaderWriterImpl<Request, Response>(call, context,
  602|      0|                                                          reactor);
  603|      0|  }
  604|       |};
  605|       |
  606|       |template <class Response>
  607|       |class ClientCallbackReaderImpl
  608|       |    : public ::grpc::experimental::ClientCallbackReader<Response> {
  609|       | public:
  610|       |  // always allocated against a call arena, no memory free required
  611|       |  static void operator delete(void* ptr, std::size_t size) {
  612|       |    assert(size == sizeof(ClientCallbackReaderImpl));
  613|       |  }
  614|       |
  615|       |  // This operator should never be called as the memory should be freed as part
  616|       |  // of the arena destruction. It only exists to provide a matching operator
  617|       |  // delete to the operator new so that some compilers will not complain (see
  618|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
  619|       |  // there are no tests catching the compiler warning.
  620|       |  static void operator delete(void*, void*) { assert(0); }
  621|       |
  622|       |  void MaybeFinish() {
  623|       |    if (--callbacks_outstanding_ == 0) {
  624|       |      Status s = std::move(finish_status_);
  625|       |      auto* reactor = reactor_;
  626|       |      auto* call = call_.call();
  627|       |      this->~ClientCallbackReaderImpl();
  628|       |      g_core_codegen_interface->grpc_call_unref(call);
  629|       |      reactor->OnDone(s);
  630|       |    }
  631|       |  }
  632|       |
  633|       |  void StartCall() override {
  634|       |    // This call initiates two batches, plus any backlog, each with a callback
  635|       |    // 1. Send initial metadata (unless corked) + recv initial metadata
  636|       |    // 2. Any backlog
  637|       |    // 3. Recv trailing metadata, on_completion callback
  638|       |    started_ = true;
  639|       |
  640|       |    start_tag_.Set(call_.call(),
  641|       |                   [this](bool ok) {
  642|       |                     reactor_->OnReadInitialMetadataDone(ok);
  643|       |                     MaybeFinish();
  644|       |                   },
  645|       |                   &start_ops_);
  646|       |    start_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  647|       |                                   context_->initial_metadata_flags());
  648|       |    start_ops_.RecvInitialMetadata(context_);
  649|       |    start_ops_.set_core_cq_tag(&start_tag_);
  650|       |    call_.PerformOps(&start_ops_);
  651|       |
  652|       |    // Also set up the read tag so it doesn't have to be set up each time
  653|       |    read_tag_.Set(call_.call(),
  654|       |                  [this](bool ok) {
  655|       |                    reactor_->OnReadDone(ok);
  656|       |                    MaybeFinish();
  657|       |                  },
  658|       |                  &read_ops_);
  659|       |    read_ops_.set_core_cq_tag(&read_tag_);
  660|       |    if (read_ops_at_start_) {
  661|       |      call_.PerformOps(&read_ops_);
  662|       |    }
  663|       |
  664|       |    finish_tag_.Set(call_.call(), [this](bool ok) { MaybeFinish(); },
  665|       |                    &finish_ops_);
  666|       |    finish_ops_.ClientRecvStatus(context_, &finish_status_);
  667|       |    finish_ops_.set_core_cq_tag(&finish_tag_);
  668|       |    call_.PerformOps(&finish_ops_);
  669|       |  }
  670|       |
  671|       |  void Read(Response* msg) override {
  672|       |    read_ops_.RecvMessage(msg);
  673|       |    callbacks_outstanding_++;
  674|       |    if (started_) {
  675|       |      call_.PerformOps(&read_ops_);
  676|       |    } else {
  677|       |      read_ops_at_start_ = true;
  678|       |    }
  679|       |  }
  680|       |
  681|       |  virtual void AddHold(int holds) override { callbacks_outstanding_ += holds; }
  682|       |  virtual void RemoveHold() override { MaybeFinish(); }
  683|       |
  684|       | private:
  685|       |  friend class ClientCallbackReaderFactory<Response>;
  686|       |
  687|       |  template <class Request>
  688|       |  ClientCallbackReaderImpl(
  689|       |      Call call, ClientContext* context, Request* request,
  690|       |      ::grpc::experimental::ClientReadReactor<Response>* reactor)
  691|       |      : context_(context), call_(call), reactor_(reactor) {
  692|       |    this->BindReactor(reactor);
  693|       |    // TODO(vjpai): don't assert
  694|       |    GPR_CODEGEN_ASSERT(start_ops_.SendMessagePtr(request).ok());
  695|       |    start_ops_.ClientSendClose();
  696|       |  }
  697|       |
  698|       |  ClientContext* const context_;
  699|       |  Call call_;
  700|       |  ::grpc::experimental::ClientReadReactor<Response>* const reactor_;
  701|       |
  702|       |  CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage, CallOpClientSendClose,
  703|       |            CallOpRecvInitialMetadata>
  704|       |      start_ops_;
  705|       |  CallbackWithSuccessTag start_tag_;
  706|       |
  707|       |  CallOpSet<CallOpClientRecvStatus> finish_ops_;
  708|       |  CallbackWithSuccessTag finish_tag_;
  709|       |  Status finish_status_;
  710|       |
  711|       |  CallOpSet<CallOpRecvMessage<Response>> read_ops_;
  712|       |  CallbackWithSuccessTag read_tag_;
  713|       |  bool read_ops_at_start_{false};
  714|       |
  715|       |  // Minimum of 2 callbacks to pre-register for start and finish
  716|       |  std::atomic_int callbacks_outstanding_{2};
  717|       |  bool started_{false};
  718|       |};
  719|       |
  720|       |template <class Response>
  721|       |class ClientCallbackReaderFactory {
  722|       | public:
  723|       |  template <class Request>
  724|       |  static void Create(
  725|       |      ChannelInterface* channel, const ::grpc::internal::RpcMethod& method,
  726|       |      ClientContext* context, const Request* request,
  727|       |      ::grpc::experimental::ClientReadReactor<Response>* reactor) {
  728|       |    Call call = channel->CreateCall(method, context, channel->CallbackCQ());
  729|       |
  730|       |    g_core_codegen_interface->grpc_call_ref(call.call());
  731|       |    new (g_core_codegen_interface->grpc_call_arena_alloc(
  732|       |        call.call(), sizeof(ClientCallbackReaderImpl<Response>)))
  733|       |        ClientCallbackReaderImpl<Response>(call, context, request, reactor);
  734|       |  }
  735|       |};
  736|       |
  737|       |template <class Request>
  738|       |class ClientCallbackWriterImpl
  739|       |    : public ::grpc::experimental::ClientCallbackWriter<Request> {
  740|       | public:
  741|       |  // always allocated against a call arena, no memory free required
  742|       |  static void operator delete(void* ptr, std::size_t size) {
  743|       |    assert(size == sizeof(ClientCallbackWriterImpl));
  744|       |  }
  745|       |
  746|       |  // This operator should never be called as the memory should be freed as part
  747|       |  // of the arena destruction. It only exists to provide a matching operator
  748|       |  // delete to the operator new so that some compilers will not complain (see
  749|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
  750|       |  // there are no tests catching the compiler warning.
  751|       |  static void operator delete(void*, void*) { assert(0); }
  752|       |
  753|       |  void MaybeFinish() {
  754|       |    if (--callbacks_outstanding_ == 0) {
  755|       |      Status s = std::move(finish_status_);
  756|       |      auto* reactor = reactor_;
  757|       |      auto* call = call_.call();
  758|       |      this->~ClientCallbackWriterImpl();
  759|       |      g_core_codegen_interface->grpc_call_unref(call);
  760|       |      reactor->OnDone(s);
  761|       |    }
  762|       |  }
  763|       |
  764|       |  void StartCall() override {
  765|       |    // This call initiates two batches, plus any backlog, each with a callback
  766|       |    // 1. Send initial metadata (unless corked) + recv initial metadata
  767|       |    // 2. Any backlog
  768|       |    // 3. Recv trailing metadata, on_completion callback
  769|       |    started_ = true;
  770|       |
  771|       |    start_tag_.Set(call_.call(),
  772|       |                   [this](bool ok) {
  773|       |                     reactor_->OnReadInitialMetadataDone(ok);
  774|       |                     MaybeFinish();
  775|       |                   },
  776|       |                   &start_ops_);
  777|       |    if (!start_corked_) {
  778|       |      start_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  779|       |                                     context_->initial_metadata_flags());
  780|       |    }
  781|       |    start_ops_.RecvInitialMetadata(context_);
  782|       |    start_ops_.set_core_cq_tag(&start_tag_);
  783|       |    call_.PerformOps(&start_ops_);
  784|       |
  785|       |    // Also set up the read and write tags so that they don't have to be set up
  786|       |    // each time
  787|       |    write_tag_.Set(call_.call(),
  788|       |                   [this](bool ok) {
  789|       |                     reactor_->OnWriteDone(ok);
  790|       |                     MaybeFinish();
  791|       |                   },
  792|       |                   &write_ops_);
  793|       |    write_ops_.set_core_cq_tag(&write_tag_);
  794|       |
  795|       |    if (write_ops_at_start_) {
  796|       |      call_.PerformOps(&write_ops_);
  797|       |    }
  798|       |
  799|       |    if (writes_done_ops_at_start_) {
  800|       |      call_.PerformOps(&writes_done_ops_);
  801|       |    }
  802|       |
  803|       |    finish_tag_.Set(call_.call(), [this](bool ok) { MaybeFinish(); },
  804|       |                    &finish_ops_);
  805|       |    finish_ops_.ClientRecvStatus(context_, &finish_status_);
  806|       |    finish_ops_.set_core_cq_tag(&finish_tag_);
  807|       |    call_.PerformOps(&finish_ops_);
  808|       |  }
  809|       |
  810|       |  void Write(const Request* msg, WriteOptions options) override {
  811|       |    if (start_corked_) {
  812|       |      write_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  813|       |                                     context_->initial_metadata_flags());
  814|       |      start_corked_ = false;
  815|       |    }
  816|       |
  817|       |    if (options.is_last_message()) {
  818|       |      options.set_buffer_hint();
  819|       |      write_ops_.ClientSendClose();
  820|       |    }
  821|       |    // TODO(vjpai): don't assert
  822|       |    GPR_CODEGEN_ASSERT(write_ops_.SendMessagePtr(msg, options).ok());
  823|       |    callbacks_outstanding_++;
  824|       |    if (started_) {
  825|       |      call_.PerformOps(&write_ops_);
  826|       |    } else {
  827|       |      write_ops_at_start_ = true;
  828|       |    }
  829|       |  }
  830|       |  void WritesDone() override {
  831|       |    if (start_corked_) {
  832|       |      writes_done_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  833|       |                                           context_->initial_metadata_flags());
  834|       |      start_corked_ = false;
  835|       |    }
  836|       |    writes_done_ops_.ClientSendClose();
  837|       |    writes_done_tag_.Set(call_.call(),
  838|       |                         [this](bool ok) {
  839|       |                           reactor_->OnWritesDoneDone(ok);
  840|       |                           MaybeFinish();
  841|       |                         },
  842|       |                         &writes_done_ops_);
  843|       |    writes_done_ops_.set_core_cq_tag(&writes_done_tag_);
  844|       |    callbacks_outstanding_++;
  845|       |    if (started_) {
  846|       |      call_.PerformOps(&writes_done_ops_);
  847|       |    } else {
  848|       |      writes_done_ops_at_start_ = true;
  849|       |    }
  850|       |  }
  851|       |
  852|       |  virtual void AddHold(int holds) override { callbacks_outstanding_ += holds; }
  853|       |  virtual void RemoveHold() override { MaybeFinish(); }
  854|       |
  855|       | private:
  856|       |  friend class ClientCallbackWriterFactory<Request>;
  857|       |
  858|       |  template <class Response>
  859|       |  ClientCallbackWriterImpl(
  860|       |      Call call, ClientContext* context, Response* response,
  861|       |      ::grpc::experimental::ClientWriteReactor<Request>* reactor)
  862|       |      : context_(context),
  863|       |        call_(call),
  864|       |        reactor_(reactor),
  865|       |        start_corked_(context_->initial_metadata_corked_) {
  866|       |    this->BindReactor(reactor);
  867|       |    finish_ops_.RecvMessage(response);
  868|       |    finish_ops_.AllowNoMessage();
  869|       |  }
  870|       |
  871|       |  ClientContext* const context_;
  872|       |  Call call_;
  873|       |  ::grpc::experimental::ClientWriteReactor<Request>* const reactor_;
  874|       |
  875|       |  CallOpSet<CallOpSendInitialMetadata, CallOpRecvInitialMetadata> start_ops_;
  876|       |  CallbackWithSuccessTag start_tag_;
  877|       |  bool start_corked_;
  878|       |
  879|       |  CallOpSet<CallOpGenericRecvMessage, CallOpClientRecvStatus> finish_ops_;
  880|       |  CallbackWithSuccessTag finish_tag_;
  881|       |  Status finish_status_;
  882|       |
  883|       |  CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage, CallOpClientSendClose>
  884|       |      write_ops_;
  885|       |  CallbackWithSuccessTag write_tag_;
  886|       |  bool write_ops_at_start_{false};
  887|       |
  888|       |  CallOpSet<CallOpSendInitialMetadata, CallOpClientSendClose> writes_done_ops_;
  889|       |  CallbackWithSuccessTag writes_done_tag_;
  890|       |  bool writes_done_ops_at_start_{false};
  891|       |
  892|       |  // Minimum of 2 callbacks to pre-register for start and finish
  893|       |  std::atomic_int callbacks_outstanding_{2};
  894|       |  bool started_{false};
  895|       |};
  896|       |
  897|       |template <class Request>
  898|       |class ClientCallbackWriterFactory {
  899|       | public:
  900|       |  template <class Response>
  901|       |  static void Create(
  902|       |      ChannelInterface* channel, const ::grpc::internal::RpcMethod& method,
  903|       |      ClientContext* context, Response* response,
  904|       |      ::grpc::experimental::ClientWriteReactor<Request>* reactor) {
  905|       |    Call call = channel->CreateCall(method, context, channel->CallbackCQ());
  906|       |
  907|       |    g_core_codegen_interface->grpc_call_ref(call.call());
  908|       |    new (g_core_codegen_interface->grpc_call_arena_alloc(
  909|       |        call.call(), sizeof(ClientCallbackWriterImpl<Request>)))
  910|       |        ClientCallbackWriterImpl<Request>(call, context, response, reactor);
  911|       |  }
  912|       |};
  913|       |
  914|       |class ClientCallbackUnaryImpl final
  915|       |    : public ::grpc::experimental::ClientCallbackUnary {
  916|       | public:
  917|       |  // always allocated against a call arena, no memory free required
  918|      0|  static void operator delete(void* ptr, std::size_t size) {
  919|      0|    assert(size == sizeof(ClientCallbackUnaryImpl));
  920|      0|  }
  921|       |
  922|       |  // This operator should never be called as the memory should be freed as part
  923|       |  // of the arena destruction. It only exists to provide a matching operator
  924|       |  // delete to the operator new so that some compilers will not complain (see
  925|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
  926|       |  // there are no tests catching the compiler warning.
  927|      0|  static void operator delete(void*, void*) { assert(0); }
  928|       |
  929|      0|  void StartCall() override {
  930|      0|    // This call initiates two batches, each with a callback
  931|      0|    // 1. Send initial metadata + write + writes done + recv initial metadata
  932|      0|    // 2. Read message, recv trailing metadata
  933|      0|    started_ = true;
  934|      0|
  935|      0|    start_tag_.Set(call_.call(),
  936|      0|                   [this](bool ok) {
  937|      0|                     reactor_->OnReadInitialMetadataDone(ok);
  938|      0|                     MaybeFinish();
  939|      0|                   },
  940|      0|                   &start_ops_);
  941|      0|    start_ops_.SendInitialMetadata(&context_->send_initial_metadata_,
  942|      0|                                   context_->initial_metadata_flags());
  943|      0|    start_ops_.RecvInitialMetadata(context_);
  944|      0|    start_ops_.set_core_cq_tag(&start_tag_);
  945|      0|    call_.PerformOps(&start_ops_);
  946|      0|
  947|      0|    finish_tag_.Set(call_.call(), [this](bool ok) { MaybeFinish(); },
  948|      0|                    &finish_ops_);
  949|      0|    finish_ops_.ClientRecvStatus(context_, &finish_status_);
  950|      0|    finish_ops_.set_core_cq_tag(&finish_tag_);
  951|      0|    call_.PerformOps(&finish_ops_);
  952|      0|  }
  953|       |
  954|      0|  void MaybeFinish() {
  955|      0|    if (--callbacks_outstanding_ == 0) {
  956|      0|      Status s = std::move(finish_status_);
  957|      0|      auto* reactor = reactor_;
  958|      0|      auto* call = call_.call();
  959|      0|      this->~ClientCallbackUnaryImpl();
  960|      0|      g_core_codegen_interface->grpc_call_unref(call);
  961|      0|      reactor->OnDone(s);
  962|      0|    }
  963|      0|  }
  964|       |
  965|       | private:
  966|       |  friend class ClientCallbackUnaryFactory;
  967|       |
  968|       |  template <class Request, class Response>
  969|       |  ClientCallbackUnaryImpl(Call call, ClientContext* context, Request* request,
  970|       |                          Response* response,
  971|       |                          ::grpc::experimental::ClientUnaryReactor* reactor)
  972|       |      : context_(context), call_(call), reactor_(reactor) {
  973|       |    this->BindReactor(reactor);
  974|       |    // TODO(vjpai): don't assert
  975|       |    GPR_CODEGEN_ASSERT(start_ops_.SendMessagePtr(request).ok());
  976|       |    start_ops_.ClientSendClose();
  977|       |    finish_ops_.RecvMessage(response);
  978|       |    finish_ops_.AllowNoMessage();
  979|       |  }
  980|       |
  981|       |  ClientContext* const context_;
  982|       |  Call call_;
  983|       |  ::grpc::experimental::ClientUnaryReactor* const reactor_;
  984|       |
  985|       |  CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage, CallOpClientSendClose,
  986|       |            CallOpRecvInitialMetadata>
  987|       |      start_ops_;
  988|       |  CallbackWithSuccessTag start_tag_;
  989|       |
  990|       |  CallOpSet<CallOpGenericRecvMessage, CallOpClientRecvStatus> finish_ops_;
  991|       |  CallbackWithSuccessTag finish_tag_;
  992|       |  Status finish_status_;
  993|       |
  994|       |  // This call will have 2 callbacks: start and finish
  995|       |  std::atomic_int callbacks_outstanding_{2};
  996|       |  bool started_{false};
  997|       |};
  998|       |
  999|       |class ClientCallbackUnaryFactory {
 1000|       | public:
 1001|       |  template <class Request, class Response>
 1002|       |  static void Create(ChannelInterface* channel,
 1003|       |                     const ::grpc::internal::RpcMethod& method,
 1004|       |                     ClientContext* context, const Request* request,
 1005|       |                     Response* response,
 1006|       |                     ::grpc::experimental::ClientUnaryReactor* reactor) {
 1007|       |    Call call = channel->CreateCall(method, context, channel->CallbackCQ());
 1008|       |
 1009|       |    g_core_codegen_interface->grpc_call_ref(call.call());
 1010|       |
 1011|       |    new (g_core_codegen_interface->grpc_call_arena_alloc(
 1012|       |        call.call(), sizeof(ClientCallbackUnaryImpl)))
 1013|       |        ClientCallbackUnaryImpl(call, context, request, response, reactor);
 1014|       |  }
 1015|       |};
 1016|       |
 1017|       |}  // namespace internal
 1018|       |}  // namespace grpc
 1019|       |
 1020|       |#endif  // GRPCPP_IMPL_CODEGEN_CLIENT_CALLBACK_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/client_context.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |/// A ClientContext allows the person implementing a service client to:
   20|       |///
   21|       |/// - Add custom metadata key-value pairs that will propagated to the server
   22|       |/// side.
   23|       |/// - Control call settings such as compression and authentication.
   24|       |/// - Initial and trailing metadata coming from the server.
   25|       |/// - Get performance metrics (ie, census).
   26|       |///
   27|       |/// Context settings are only relevant to the call they are invoked with, that
   28|       |/// is to say, they aren't sticky. Some of these settings, such as the
   29|       |/// compression options, can be made persistent at channel construction time
   30|       |/// (see \a grpc::CreateCustomChannel).
   31|       |///
   32|       |/// \warning ClientContext instances should \em not be reused across rpcs.
   33|       |
   34|       |#ifndef GRPCPP_IMPL_CODEGEN_CLIENT_CONTEXT_H
   35|       |#define GRPCPP_IMPL_CODEGEN_CLIENT_CONTEXT_H
   36|       |
   37|       |#include <map>
   38|       |#include <memory>
   39|       |#include <mutex>
   40|       |#include <string>
   41|       |
   42|       |#include <grpc/impl/codegen/compression_types.h>
   43|       |#include <grpc/impl/codegen/propagation_bits.h>
   44|       |#include <grpcpp/impl/codegen/client_interceptor.h>
   45|       |#include <grpcpp/impl/codegen/config.h>
   46|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   47|       |#include <grpcpp/impl/codegen/create_auth_context.h>
   48|       |#include <grpcpp/impl/codegen/metadata_map.h>
   49|       |#include <grpcpp/impl/codegen/rpc_method.h>
   50|       |#include <grpcpp/impl/codegen/security/auth_context.h>
   51|       |#include <grpcpp/impl/codegen/slice.h>
   52|       |#include <grpcpp/impl/codegen/status.h>
   53|       |#include <grpcpp/impl/codegen/string_ref.h>
   54|       |#include <grpcpp/impl/codegen/sync.h>
   55|       |#include <grpcpp/impl/codegen/time.h>
   56|       |
   57|       |struct census_context;
   58|       |struct grpc_call;
   59|       |
   60|       |namespace grpc_impl {
   61|       |
   62|       |class CallCredentials;
   63|       |class Channel;
   64|       |class CompletionQueue;
   65|       |}  // namespace grpc_impl
   66|       |namespace grpc {
   67|       |
   68|       |class ChannelInterface;
   69|       |class ClientContext;
   70|       |
   71|       |namespace internal {
   72|       |class RpcMethod;
   73|       |class CallOpClientRecvStatus;
   74|       |class CallOpRecvInitialMetadata;
   75|       |template <class InputMessage, class OutputMessage>
   76|       |class BlockingUnaryCallImpl;
   77|       |template <class InputMessage, class OutputMessage>
   78|       |class CallbackUnaryCallImpl;
   79|       |template <class Request, class Response>
   80|       |class ClientCallbackReaderWriterImpl;
   81|       |template <class Response>
   82|       |class ClientCallbackReaderImpl;
   83|       |template <class Request>
   84|       |class ClientCallbackWriterImpl;
   85|       |class ClientCallbackUnaryImpl;
   86|       |}  // namespace internal
   87|       |
   88|       |template <class R>
   89|       |class ClientReader;
   90|       |template <class W>
   91|       |class ClientWriter;
   92|       |template <class W, class R>
   93|       |class ClientReaderWriter;
   94|       |template <class R>
   95|       |class ClientAsyncReader;
   96|       |template <class W>
   97|       |class ClientAsyncWriter;
   98|       |template <class W, class R>
   99|       |class ClientAsyncReaderWriter;
  100|       |template <class R>
  101|       |class ClientAsyncResponseReader;
  102|       |class ServerContext;
  103|       |
  104|       |/// Options for \a ClientContext::FromServerContext specifying which traits from
  105|       |/// the \a ServerContext to propagate (copy) from it into a new \a
  106|       |/// ClientContext.
  107|       |///
  108|       |/// \see ClientContext::FromServerContext
  109|       |class PropagationOptions {
  110|       | public:
  111|      0|  PropagationOptions() : propagate_(GRPC_PROPAGATE_DEFAULTS) {}
  112|       |
  113|      0|  PropagationOptions& enable_deadline_propagation() {
  114|      0|    propagate_ |= GRPC_PROPAGATE_DEADLINE;
  115|      0|    return *this;
  116|      0|  }
  117|       |
  118|      0|  PropagationOptions& disable_deadline_propagation() {
  119|      0|    propagate_ &= ~GRPC_PROPAGATE_DEADLINE;
  120|      0|    return *this;
  121|      0|  }
  122|       |
  123|      0|  PropagationOptions& enable_census_stats_propagation() {
  124|      0|    propagate_ |= GRPC_PROPAGATE_CENSUS_STATS_CONTEXT;
  125|      0|    return *this;
  126|      0|  }
  127|       |
  128|      0|  PropagationOptions& disable_census_stats_propagation() {
  129|      0|    propagate_ &= ~GRPC_PROPAGATE_CENSUS_STATS_CONTEXT;
  130|      0|    return *this;
  131|      0|  }
  132|       |
  133|      0|  PropagationOptions& enable_census_tracing_propagation() {
  134|      0|    propagate_ |= GRPC_PROPAGATE_CENSUS_TRACING_CONTEXT;
  135|      0|    return *this;
  136|      0|  }
  137|       |
  138|      0|  PropagationOptions& disable_census_tracing_propagation() {
  139|      0|    propagate_ &= ~GRPC_PROPAGATE_CENSUS_TRACING_CONTEXT;
  140|      0|    return *this;
  141|      0|  }
  142|       |
  143|      0|  PropagationOptions& enable_cancellation_propagation() {
  144|      0|    propagate_ |= GRPC_PROPAGATE_CANCELLATION;
  145|      0|    return *this;
  146|      0|  }
  147|       |
  148|      0|  PropagationOptions& disable_cancellation_propagation() {
  149|      0|    propagate_ &= ~GRPC_PROPAGATE_CANCELLATION;
  150|      0|    return *this;
  151|      0|  }
  152|       |
  153|      0|  uint32_t c_bitmask() const { return propagate_; }
  154|       |
  155|       | private:
  156|       |  uint32_t propagate_;
  157|       |};
  158|       |
  159|       |namespace testing {
  160|       |class InteropClientContextInspector;
  161|       |}  // namespace testing
  162|       |
  163|       |/// A ClientContext allows the person implementing a service client to:
  164|       |///
  165|       |/// - Add custom metadata key-value pairs that will propagated to the server
  166|       |///   side.
  167|       |/// - Control call settings such as compression and authentication.
  168|       |/// - Initial and trailing metadata coming from the server.
  169|       |/// - Get performance metrics (ie, census).
  170|       |///
  171|       |/// Context settings are only relevant to the call they are invoked with, that
  172|       |/// is to say, they aren't sticky. Some of these settings, such as the
  173|       |/// compression options, can be made persistent at channel construction time
  174|       |/// (see \a grpc::CreateCustomChannel).
  175|       |///
  176|       |/// \warning ClientContext instances should \em not be reused across rpcs.
  177|       |/// \warning The ClientContext instance used for creating an rpc must remain
  178|       |///          alive and valid for the lifetime of the rpc.
  179|       |class ClientContext {
  180|       | public:
  181|       |  ClientContext();
  182|       |  ~ClientContext();
  183|       |
  184|       |  /// Create a new \a ClientContext as a child of an incoming server call,
  185|       |  /// according to \a options (\see PropagationOptions).
  186|       |  ///
  187|       |  /// \param server_context The source server context to use as the basis for
  188|       |  /// constructing the client context.
  189|       |  /// \param options The options controlling what to copy from the \a
  190|       |  /// server_context.
  191|       |  ///
  192|       |  /// \return A newly constructed \a ClientContext instance based on \a
  193|       |  /// server_context, with traits propagated (copied) according to \a options.
  194|       |  static std::unique_ptr<ClientContext> FromServerContext(
  195|       |      const ServerContext& server_context,
  196|       |      PropagationOptions options = PropagationOptions());
  197|       |
  198|       |  /// Add the (\a meta_key, \a meta_value) pair to the metadata associated with
  199|       |  /// a client call. These are made available at the server side by the \a
  200|       |  /// grpc::ServerContext::client_metadata() method.
  201|       |  ///
  202|       |  /// \warning This method should only be called before invoking the rpc.
  203|       |  ///
  204|       |  /// \param meta_key The metadata key. If \a meta_value is binary data, it must
  205|       |  /// end in "-bin".
  206|       |  /// \param meta_value The metadata value. If its value is binary, the key name
  207|       |  /// must end in "-bin".
  208|       |  ///
  209|       |  /// Metadata must conform to the following format:
  210|       |  /// Custom-Metadata -> Binary-Header / ASCII-Header
  211|       |  /// Binary-Header -> {Header-Name "-bin" } {binary value}
  212|       |  /// ASCII-Header -> Header-Name ASCII-Value
  213|       |  /// Header-Name -> 1*( %x30-39 / %x61-7A / "_" / "-" / ".") ; 0-9 a-z _ - .
  214|       |  /// ASCII-Value -> 1*( %x20-%x7E ) ; space and printable ASCII
  215|       |  void AddMetadata(const grpc::string& meta_key,
  216|       |                   const grpc::string& meta_value);
  217|       |
  218|       |  /// Return a collection of initial metadata key-value pairs. Note that keys
  219|       |  /// may happen more than once (ie, a \a std::multimap is returned).
  220|       |  ///
  221|       |  /// \warning This method should only be called after initial metadata has been
  222|       |  /// received. For streaming calls, see \a
  223|       |  /// ClientReaderInterface::WaitForInitialMetadata().
  224|       |  ///
  225|       |  /// \return A multimap of initial metadata key-value pairs from the server.
  226|       |  const std::multimap<grpc::string_ref, grpc::string_ref>&
  227|       |  GetServerInitialMetadata() const {
  228|       |    GPR_CODEGEN_ASSERT(initial_metadata_received_);
  229|       |    return *recv_initial_metadata_.map();
  230|       |  }
  231|       |
  232|       |  /// Return a collection of trailing metadata key-value pairs. Note that keys
  233|       |  /// may happen more than once (ie, a \a std::multimap is returned).
  234|       |  ///
  235|       |  /// \warning This method is only callable once the stream has finished.
  236|       |  ///
  237|       |  /// \return A multimap of metadata trailing key-value pairs from the server.
  238|       |  const std::multimap<grpc::string_ref, grpc::string_ref>&
  239|      0|  GetServerTrailingMetadata() const {
  240|      0|    // TODO(yangg) check finished
  241|      0|    return *trailing_metadata_.map();
  242|      0|  }
  243|       |
  244|       |  /// Set the deadline for the client call.
  245|       |  ///
  246|       |  /// \warning This method should only be called before invoking the rpc.
  247|       |  ///
  248|       |  /// \param deadline the deadline for the client call. Units are determined by
  249|       |  /// the type used. The deadline is an absolute (not relative) time.
  250|       |  template <typename T>
  251|       |  void set_deadline(const T& deadline) {
  252|       |    TimePoint<T> deadline_tp(deadline);
  253|       |    deadline_ = deadline_tp.raw_time();
  254|       |  }
  255|       |
  256|       |  /// EXPERIMENTAL: Indicate that this request is idempotent.
  257|       |  /// By default, RPCs are assumed to <i>not</i> be idempotent.
  258|       |  ///
  259|       |  /// If true, the gRPC library assumes that it's safe to initiate
  260|       |  /// this RPC multiple times.
  261|      0|  void set_idempotent(bool idempotent) { idempotent_ = idempotent; }
  262|       |
  263|       |  /// EXPERIMENTAL: Set this request to be cacheable.
  264|       |  /// If set, grpc is free to use the HTTP GET verb for sending the request,
  265|       |  /// with the possibility of receiving a cached response.
  266|      0|  void set_cacheable(bool cacheable) { cacheable_ = cacheable; }
  267|       |
  268|       |  /// EXPERIMENTAL: Trigger wait-for-ready or not on this request.
  269|       |  /// See https://github.com/grpc/grpc/blob/master/doc/wait-for-ready.md.
  270|       |  /// If set, if an RPC is made when a channel's connectivity state is
  271|       |  /// TRANSIENT_FAILURE or CONNECTING, the call will not "fail fast",
  272|       |  /// and the channel will wait until the channel is READY before making the
  273|       |  /// call.
  274|      0|  void set_wait_for_ready(bool wait_for_ready) {
  275|      0|    wait_for_ready_ = wait_for_ready;
  276|      0|    wait_for_ready_explicitly_set_ = true;
  277|      0|  }
  278|       |
  279|       |  /// DEPRECATED: Use set_wait_for_ready() instead.
  280|      0|  void set_fail_fast(bool fail_fast) { set_wait_for_ready(!fail_fast); }
  281|       |
  282|       |  /// Return the deadline for the client call.
  283|      0|  std::chrono::system_clock::time_point deadline() const {
  284|      0|    return Timespec2Timepoint(deadline_);
  285|      0|  }
  286|       |
  287|       |  /// Return a \a gpr_timespec representation of the client call's deadline.
  288|      0|  gpr_timespec raw_deadline() const { return deadline_; }
  289|       |
  290|       |  /// Set the per call authority header (see
  291|       |  /// https://tools.ietf.org/html/rfc7540#section-8.1.2.3).
  292|      0|  void set_authority(const grpc::string& authority) { authority_ = authority; }
  293|       |
  294|       |  /// Return the authentication context for this client call.
  295|       |  ///
  296|       |  /// \see grpc::AuthContext.
  297|      0|  std::shared_ptr<const AuthContext> auth_context() const {
  298|      0|    if (auth_context_.get() == nullptr) {
  299|      0|      auth_context_ = CreateAuthContext(call_);
  300|      0|    }
  301|      0|    return auth_context_;
  302|      0|  }
  303|       |
  304|       |  /// Set credentials for the client call.
  305|       |  ///
  306|       |  /// A credentials object encapsulates all the state needed by a client to
  307|       |  /// authenticate with a server and make various assertions, e.g., about the
  308|       |  /// clients identity, role, or whether it is authorized to make a particular
  309|       |  /// call.
  310|       |  ///
  311|       |  /// \see  https://grpc.io/docs/guides/auth.html
  312|       |  void set_credentials(
  313|      0|      const std::shared_ptr<grpc_impl::CallCredentials>& creds) {
  314|      0|    creds_ = creds;
  315|      0|  }
  316|       |
  317|       |  /// Return the compression algorithm the client call will request be used.
  318|       |  /// Note that the gRPC runtime may decide to ignore this request, for example,
  319|       |  /// due to resource constraints.
  320|      0|  grpc_compression_algorithm compression_algorithm() const {
  321|      0|    return compression_algorithm_;
  322|      0|  }
  323|       |
  324|       |  /// Set \a algorithm to be the compression algorithm used for the client call.
  325|       |  ///
  326|       |  /// \param algorithm The compression algorithm used for the client call.
  327|       |  void set_compression_algorithm(grpc_compression_algorithm algorithm);
  328|       |
  329|       |  /// Flag whether the initial metadata should be \a corked
  330|       |  ///
  331|       |  /// If \a corked is true, then the initial metadata will be coalesced with the
  332|       |  /// write of first message in the stream. As a result, any tag set for the
  333|       |  /// initial metadata operation (starting a client-streaming or bidi-streaming
  334|       |  /// RPC) will not actually be sent to the completion queue or delivered
  335|       |  /// via Next.
  336|       |  ///
  337|       |  /// \param corked The flag indicating whether the initial metadata is to be
  338|       |  /// corked or not.
  339|      0|  void set_initial_metadata_corked(bool corked) {
  340|      0|    initial_metadata_corked_ = corked;
  341|      0|  }
  342|       |
  343|       |  /// Return the peer uri in a string.
  344|       |  ///
  345|       |  /// \warning This value is never authenticated or subject to any security
  346|       |  /// related code. It must not be used for any authentication related
  347|       |  /// functionality. Instead, use auth_context.
  348|       |  ///
  349|       |  /// \return The call's peer URI.
  350|       |  grpc::string peer() const;
  351|       |
  352|       |  /// Get and set census context.
  353|      0|  void set_census_context(struct census_context* ccp) { census_context_ = ccp; }
  354|      0|  struct census_context* census_context() const {
  355|      0|    return census_context_;
  356|      0|  }
  357|       |
  358|       |  /// Send a best-effort out-of-band cancel on the call associated with
  359|       |  /// this client context.  The call could be in any stage; e.g., if it is
  360|       |  /// already finished, it may still return success.
  361|       |  ///
  362|       |  /// There is no guarantee the call will be cancelled.
  363|       |  ///
  364|       |  /// Note that TryCancel() does not change any of the tags that are pending
  365|       |  /// on the completion queue. All pending tags will still be delivered
  366|       |  /// (though their ok result may reflect the effect of cancellation).
  367|       |  void TryCancel();
  368|       |
  369|       |  /// Global Callbacks
  370|       |  ///
  371|       |  /// Can be set exactly once per application to install hooks whenever
  372|       |  /// a client context is constructed and destructed.
  373|       |  class GlobalCallbacks {
  374|       |   public:
  375|      0|    virtual ~GlobalCallbacks() {}
  376|       |    virtual void DefaultConstructor(ClientContext* context) = 0;
  377|       |    virtual void Destructor(ClientContext* context) = 0;
  378|       |  };
  379|       |  static void SetGlobalCallbacks(GlobalCallbacks* callbacks);
  380|       |
  381|       |  /// Should be used for framework-level extensions only.
  382|       |  /// Applications never need to call this method.
  383|      0|  grpc_call* c_call() { return call_; }
  384|       |
  385|       |  /// EXPERIMENTAL debugging API
  386|       |  ///
  387|       |  /// if status is not ok() for an RPC, this will return a detailed string
  388|       |  /// of the gRPC Core error that led to the failure. It should not be relied
  389|       |  /// upon for anything other than gaining more debug data in failure cases.
  390|      0|  grpc::string debug_error_string() const { return debug_error_string_; }
  391|       |
  392|       | private:
  393|       |  // Disallow copy and assign.
  394|       |  ClientContext(const ClientContext&);
  395|       |  ClientContext& operator=(const ClientContext&);
  396|       |
  397|       |  friend class ::grpc::testing::InteropClientContextInspector;
  398|       |  friend class ::grpc::internal::CallOpClientRecvStatus;
  399|       |  friend class ::grpc::internal::CallOpRecvInitialMetadata;
  400|       |  friend class ::grpc_impl::Channel;
  401|       |  template <class R>
  402|       |  friend class ::grpc::ClientReader;
  403|       |  template <class W>
  404|       |  friend class ::grpc::ClientWriter;
  405|       |  template <class W, class R>
  406|       |  friend class ::grpc::ClientReaderWriter;
  407|       |  template <class R>
  408|       |  friend class ::grpc::ClientAsyncReader;
  409|       |  template <class W>
  410|       |  friend class ::grpc::ClientAsyncWriter;
  411|       |  template <class W, class R>
  412|       |  friend class ::grpc::ClientAsyncReaderWriter;
  413|       |  template <class R>
  414|       |  friend class ::grpc::ClientAsyncResponseReader;
  415|       |  template <class InputMessage, class OutputMessage>
  416|       |  friend class ::grpc::internal::BlockingUnaryCallImpl;
  417|       |  template <class InputMessage, class OutputMessage>
  418|       |  friend class ::grpc::internal::CallbackUnaryCallImpl;
  419|       |  template <class Request, class Response>
  420|       |  friend class ::grpc::internal::ClientCallbackReaderWriterImpl;
  421|       |  template <class Response>
  422|       |  friend class ::grpc::internal::ClientCallbackReaderImpl;
  423|       |  template <class Request>
  424|       |  friend class ::grpc::internal::ClientCallbackWriterImpl;
  425|       |  friend class ::grpc::internal::ClientCallbackUnaryImpl;
  426|       |
  427|       |  // Used by friend class CallOpClientRecvStatus
  428|      0|  void set_debug_error_string(const grpc::string& debug_error_string) {
  429|      0|    debug_error_string_ = debug_error_string;
  430|      0|  }
  431|       |
  432|      0|  grpc_call* call() const { return call_; }
  433|       |  void set_call(grpc_call* call,
  434|       |                const std::shared_ptr<::grpc_impl::Channel>& channel);
  435|       |
  436|       |  experimental::ClientRpcInfo* set_client_rpc_info(
  437|       |      const char* method, internal::RpcMethod::RpcType type,
  438|       |      grpc::ChannelInterface* channel,
  439|       |      const std::vector<
  440|       |          std::unique_ptr<experimental::ClientInterceptorFactoryInterface>>&
  441|       |          creators,
  442|      0|      size_t interceptor_pos) {
  443|      0|    rpc_info_ = experimental::ClientRpcInfo(this, type, method, channel);
  444|      0|    rpc_info_.RegisterInterceptors(creators, interceptor_pos);
  445|      0|    return &rpc_info_;
  446|      0|  }
  447|       |
  448|      0|  uint32_t initial_metadata_flags() const {
  449|      0|    return (idempotent_ ? GRPC_INITIAL_METADATA_IDEMPOTENT_REQUEST : 0) |
  450|      0|           (wait_for_ready_ ? GRPC_INITIAL_METADATA_WAIT_FOR_READY : 0) |
  451|      0|           (cacheable_ ? GRPC_INITIAL_METADATA_CACHEABLE_REQUEST : 0) |
  452|      0|           (wait_for_ready_explicitly_set_
  453|      0|                ? GRPC_INITIAL_METADATA_WAIT_FOR_READY_EXPLICITLY_SET
  454|      0|                : 0) |
  455|      0|           (initial_metadata_corked_ ? GRPC_INITIAL_METADATA_CORKED : 0);
  456|      0|  }
  457|       |
  458|      0|  grpc::string authority() { return authority_; }
  459|       |
  460|       |  void SendCancelToInterceptors();
  461|       |
  462|       |  bool initial_metadata_received_;
  463|       |  bool wait_for_ready_;
  464|       |  bool wait_for_ready_explicitly_set_;
  465|       |  bool idempotent_;
  466|       |  bool cacheable_;
  467|       |  std::shared_ptr<::grpc_impl::Channel> channel_;
  468|       |  grpc::internal::Mutex mu_;
  469|       |  grpc_call* call_;
  470|       |  bool call_canceled_;
  471|       |  gpr_timespec deadline_;
  472|       |  grpc::string authority_;
  473|       |  std::shared_ptr<grpc_impl::CallCredentials> creds_;
  474|       |  mutable std::shared_ptr<const AuthContext> auth_context_;
  475|       |  struct census_context* census_context_;
  476|       |  std::multimap<grpc::string, grpc::string> send_initial_metadata_;
  477|       |  mutable internal::MetadataMap recv_initial_metadata_;
  478|       |  mutable internal::MetadataMap trailing_metadata_;
  479|       |
  480|       |  grpc_call* propagate_from_call_;
  481|       |  PropagationOptions propagation_options_;
  482|       |
  483|       |  grpc_compression_algorithm compression_algorithm_;
  484|       |  bool initial_metadata_corked_;
  485|       |
  486|       |  grpc::string debug_error_string_;
  487|       |
  488|       |  experimental::ClientRpcInfo rpc_info_;
  489|       |};
  490|       |
  491|       |}  // namespace grpc
  492|       |
  493|       |#endif  // GRPCPP_IMPL_CODEGEN_CLIENT_CONTEXT_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/client_interceptor.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_CLIENT_INTERCEPTOR_H
   20|       |#define GRPCPP_IMPL_CODEGEN_CLIENT_INTERCEPTOR_H
   21|       |
   22|       |#include <memory>
   23|       |#include <vector>
   24|       |
   25|       |#include <grpcpp/impl/codegen/interceptor.h>
   26|       |#include <grpcpp/impl/codegen/rpc_method.h>
   27|       |#include <grpcpp/impl/codegen/string_ref.h>
   28|       |
   29|       |namespace grpc_impl {
   30|       |
   31|       |class Channel;
   32|       |}
   33|       |
   34|       |namespace grpc {
   35|       |
   36|       |class ClientContext;
   37|       |
   38|       |namespace internal {
   39|       |class InterceptorBatchMethodsImpl;
   40|       |}
   41|       |
   42|       |namespace experimental {
   43|       |class ClientRpcInfo;
   44|       |
   45|       |// A factory interface for creation of client interceptors. A vector of
   46|       |// factories can be provided at channel creation which will be used to create a
   47|       |// new vector of client interceptors per RPC. Client interceptor authors should
   48|       |// create a subclass of ClientInterceptorFactorInterface which creates objects
   49|       |// of their interceptors.
   50|       |class ClientInterceptorFactoryInterface {
   51|       | public:
   52|      0|  virtual ~ClientInterceptorFactoryInterface() {}
   53|       |  // Returns a pointer to an Interceptor object on successful creation, nullptr
   54|       |  // otherwise. If nullptr is returned, this server interceptor factory is
   55|       |  // ignored for the purposes of that RPC.
   56|       |  virtual Interceptor* CreateClientInterceptor(ClientRpcInfo* info) = 0;
   57|       |};
   58|       |}  // namespace experimental
   59|       |
   60|       |namespace internal {
   61|       |extern experimental::ClientInterceptorFactoryInterface*
   62|       |    g_global_client_interceptor_factory;
   63|       |}
   64|       |
   65|       |/// ClientRpcInfo represents the state of a particular RPC as it
   66|       |/// appears to an interceptor. It is created and owned by the library and
   67|       |/// passed to the CreateClientInterceptor method of the application's
   68|       |/// ClientInterceptorFactoryInterface implementation
   69|       |namespace experimental {
   70|       |class ClientRpcInfo {
   71|       | public:
   72|       |  // TODO(yashykt): Stop default-constructing ClientRpcInfo and remove UNKNOWN
   73|       |  //                from the list of possible Types.
   74|       |  /// Type categorizes RPCs by unary or streaming type
   75|       |  enum class Type {
   76|       |    UNARY,
   77|       |    CLIENT_STREAMING,
   78|       |    SERVER_STREAMING,
   79|       |    BIDI_STREAMING,
   80|       |    UNKNOWN  // UNKNOWN is not API and will be removed later
   81|       |  };
   82|       |
   83|      0|  ~ClientRpcInfo() {}
   84|       |
   85|       |  // Delete copy constructor but allow default move constructor
   86|       |  ClientRpcInfo(const ClientRpcInfo&) = delete;
   87|       |  ClientRpcInfo(ClientRpcInfo&&) = default;
   88|       |
   89|       |  // Getter methods
   90|       |
   91|       |  /// Return the fully-specified method name
   92|      0|  const char* method() const { return method_; }
   93|       |
   94|       |  /// Return a pointer to the channel on which the RPC is being sent
   95|      0|  ChannelInterface* channel() { return channel_; }
   96|       |
   97|       |  /// Return a pointer to the underlying ClientContext structure associated
   98|       |  /// with the RPC to support features that apply to it
   99|      0|  grpc::ClientContext* client_context() { return ctx_; }
  100|       |
  101|       |  /// Return the type of the RPC (unary or a streaming flavor)
  102|      0|  Type type() const { return type_; }
  103|       |
  104|       | private:
  105|       |  static_assert(Type::UNARY ==
  106|       |                    static_cast<Type>(internal::RpcMethod::NORMAL_RPC),
  107|       |                "violated expectation about Type enum");
  108|       |  static_assert(Type::CLIENT_STREAMING ==
  109|       |                    static_cast<Type>(internal::RpcMethod::CLIENT_STREAMING),
  110|       |                "violated expectation about Type enum");
  111|       |  static_assert(Type::SERVER_STREAMING ==
  112|       |                    static_cast<Type>(internal::RpcMethod::SERVER_STREAMING),
  113|       |                "violated expectation about Type enum");
  114|       |  static_assert(Type::BIDI_STREAMING ==
  115|       |                    static_cast<Type>(internal::RpcMethod::BIDI_STREAMING),
  116|       |                "violated expectation about Type enum");
  117|       |
  118|       |  // Default constructor should only be used by ClientContext
  119|      0|  ClientRpcInfo() = default;
  120|       |
  121|       |  // Constructor will only be called from ClientContext
  122|       |  ClientRpcInfo(grpc::ClientContext* ctx, internal::RpcMethod::RpcType type,
  123|       |                const char* method, grpc::ChannelInterface* channel)
  124|       |      : ctx_(ctx),
  125|       |        type_(static_cast<Type>(type)),
  126|       |        method_(method),
  127|      0|        channel_(channel) {}
  128|       |
  129|       |  // Move assignment should only be used by ClientContext
  130|       |  // TODO(yashykt): Delete move assignment
  131|      0|  ClientRpcInfo& operator=(ClientRpcInfo&&) = default;
  132|       |
  133|       |  // Runs interceptor at pos \a pos.
  134|       |  void RunInterceptor(
  135|      0|      experimental::InterceptorBatchMethods* interceptor_methods, size_t pos) {
  136|      0|    GPR_CODEGEN_ASSERT(pos < interceptors_.size());
  137|      0|    interceptors_[pos]->Intercept(interceptor_methods);
  138|      0|  }
  139|       |
  140|       |  void RegisterInterceptors(
  141|       |      const std::vector<std::unique_ptr<
  142|       |          experimental::ClientInterceptorFactoryInterface>>& creators,
  143|      0|      size_t interceptor_pos) {
  144|      0|    if (interceptor_pos > creators.size()) {
  145|      0|      // No interceptors to register
  146|      0|      return;
  147|      0|    }
  148|      0|    for (auto it = creators.begin() + interceptor_pos; it != creators.end();
  149|      0|         ++it) {
  150|      0|      auto* interceptor = (*it)->CreateClientInterceptor(this);
  151|      0|      if (interceptor != nullptr) {
  152|      0|        interceptors_.push_back(
  153|      0|            std::unique_ptr<experimental::Interceptor>(interceptor));
  154|      0|      }
  155|      0|    }
  156|      0|    if (internal::g_global_client_interceptor_factory != nullptr) {
  157|      0|      interceptors_.push_back(std::unique_ptr<experimental::Interceptor>(
  158|      0|          internal::g_global_client_interceptor_factory
  159|      0|              ->CreateClientInterceptor(this)));
  160|      0|    }
  161|      0|  }
  162|       |
  163|       |  grpc::ClientContext* ctx_ = nullptr;
  164|       |  // TODO(yashykt): make type_ const once move-assignment is deleted
  165|       |  Type type_{Type::UNKNOWN};
  166|       |  const char* method_ = nullptr;
  167|       |  grpc::ChannelInterface* channel_ = nullptr;
  168|       |  std::vector<std::unique_ptr<experimental::Interceptor>> interceptors_;
  169|       |  bool hijacked_ = false;
  170|       |  size_t hijacked_interceptor_ = 0;
  171|       |
  172|       |  friend class internal::InterceptorBatchMethodsImpl;
  173|       |  friend class grpc::ClientContext;
  174|       |};
  175|       |
  176|       |// PLEASE DO NOT USE THIS. ALWAYS PREFER PER CHANNEL INTERCEPTORS OVER A GLOBAL
  177|       |// INTERCEPTOR. IF USAGE IS ABSOLUTELY NECESSARY, PLEASE READ THE SAFETY NOTES.
  178|       |// Registers a global client interceptor factory object, which is used for all
  179|       |// RPCs made in this process. The application is responsible for maintaining the
  180|       |// life of the object while gRPC operations are in progress. The global
  181|       |// interceptor factory should only be registered once at the start of the
  182|       |// process before any gRPC operations have begun.
  183|       |void RegisterGlobalClientInterceptorFactory(
  184|       |    ClientInterceptorFactoryInterface* factory);
  185|       |
  186|       |// For testing purposes only
  187|       |void TestOnlyResetGlobalClientInterceptorFactory();
  188|       |
  189|       |}  // namespace experimental
  190|       |}  // namespace grpc
  191|       |
  192|       |#endif  // GRPCPP_IMPL_CODEGEN_CLIENT_INTERCEPTOR_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/completion_queue_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015-2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |/// A completion queue implements a concurrent producer-consumer queue, with
   20|       |/// two main API-exposed methods: \a Next and \a AsyncNext. These
   21|       |/// methods are the essential component of the gRPC C++ asynchronous API.
   22|       |/// There is also a \a Shutdown method to indicate that a given completion queue
   23|       |/// will no longer have regular events. This must be called before the
   24|       |/// completion queue is destroyed.
   25|       |/// All completion queue APIs are thread-safe and may be used concurrently with
   26|       |/// any other completion queue API invocation; it is acceptable to have
   27|       |/// multiple threads calling \a Next or \a AsyncNext on the same or different
   28|       |/// completion queues, or to call these methods concurrently with a \a Shutdown
   29|       |/// elsewhere.
   30|       |/// \remark{All other API calls on completion queue should be completed before
   31|       |/// a completion queue destructor is called.}
   32|       |#ifndef GRPCPP_IMPL_CODEGEN_COMPLETION_QUEUE_IMPL_H
   33|       |#define GRPCPP_IMPL_CODEGEN_COMPLETION_QUEUE_IMPL_H
   34|       |
   35|       |#include <grpc/impl/codegen/atm.h>
   36|       |#include <grpcpp/impl/codegen/completion_queue_tag.h>
   37|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   38|       |#include <grpcpp/impl/codegen/grpc_library.h>
   39|       |#include <grpcpp/impl/codegen/status.h>
   40|       |#include <grpcpp/impl/codegen/time.h>
   41|       |
   42|       |struct grpc_completion_queue;
   43|       |
   44|       |namespace grpc_impl {
   45|       |
   46|       |class Channel;
   47|       |class Server;
   48|       |class ServerBuilder;
   49|       |}  // namespace grpc_impl
   50|       |namespace grpc {
   51|       |
   52|       |template <class R>
   53|       |class ClientReader;
   54|       |template <class W>
   55|       |class ClientWriter;
   56|       |template <class W, class R>
   57|       |class ClientReaderWriter;
   58|       |template <class R>
   59|       |class ServerReader;
   60|       |template <class W>
   61|       |class ServerWriter;
   62|       |namespace internal {
   63|       |template <class W, class R>
   64|       |class ServerReaderWriterBody;
   65|       |}  // namespace internal
   66|       |
   67|       |class ChannelInterface;
   68|       |class ClientContext;
   69|       |class ServerContext;
   70|       |class ServerInterface;
   71|       |
   72|       |namespace internal {
   73|       |class CompletionQueueTag;
   74|       |class RpcMethod;
   75|       |template <class ServiceType, class RequestType, class ResponseType>
   76|       |class RpcMethodHandler;
   77|       |template <class ServiceType, class RequestType, class ResponseType>
   78|       |class ClientStreamingHandler;
   79|       |template <class ServiceType, class RequestType, class ResponseType>
   80|       |class ServerStreamingHandler;
   81|       |template <class ServiceType, class RequestType, class ResponseType>
   82|       |class BidiStreamingHandler;
   83|       |template <class Streamer, bool WriteNeeded>
   84|       |class TemplatedBidiStreamingHandler;
   85|       |template <StatusCode code>
   86|       |class ErrorMethodHandler;
   87|       |template <class InputMessage, class OutputMessage>
   88|       |class BlockingUnaryCallImpl;
   89|       |template <class Op1, class Op2, class Op3, class Op4, class Op5, class Op6>
   90|       |class CallOpSet;
   91|       |}  // namespace internal
   92|       |
   93|       |extern CoreCodegenInterface* g_core_codegen_interface;
   94|       |
   95|       |}  // namespace grpc
   96|       |
   97|       |namespace grpc_impl {
   98|       |
   99|       |/// A thin wrapper around \ref grpc_completion_queue (see \ref
  100|       |/// src/core/lib/surface/completion_queue.h).
  101|       |/// See \ref doc/cpp/perf_notes.md for notes on best practices for high
  102|       |/// performance servers.
  103|       |class CompletionQueue : private ::grpc::GrpcLibraryCodegen {
  104|       | public:
  105|       |  /// Default constructor. Implicitly creates a \a grpc_completion_queue
  106|       |  /// instance.
  107|       |  CompletionQueue()
  108|       |      : CompletionQueue(grpc_completion_queue_attributes{
  109|       |            GRPC_CQ_CURRENT_VERSION, GRPC_CQ_NEXT, GRPC_CQ_DEFAULT_POLLING,
  110|      0|            nullptr}) {}
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl15CompletionQueueC2Ev
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl15CompletionQueueC1Ev
  ------------------
  111|       |
  112|       |  /// Wrap \a take, taking ownership of the instance.
  113|       |  ///
  114|       |  /// \param take The completion queue instance to wrap. Ownership is taken.
  115|       |  explicit CompletionQueue(grpc_completion_queue* take);
  116|       |
  117|       |  /// Destructor. Destroys the owned wrapped completion queue / instance.
  118|      0|  ~CompletionQueue() {
  119|      0|    ::grpc::g_core_codegen_interface->grpc_completion_queue_destroy(cq_);
  120|      0|  }
  121|       |
  122|       |  /// Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT.
  123|       |  enum NextStatus {
  124|       |    SHUTDOWN,   ///< The completion queue has been shutdown and fully-drained
  125|       |    GOT_EVENT,  ///< Got a new event; \a tag will be filled in with its
  126|       |                ///< associated value; \a ok indicating its success.
  127|       |    TIMEOUT     ///< deadline was reached.
  128|       |  };
  129|       |
  130|       |  /// Read from the queue, blocking until an event is available or the queue is
  131|       |  /// shutting down.
  132|       |  ///
  133|       |  /// \param tag [out] Updated to point to the read event's tag.
  134|       |  /// \param ok [out] true if read a successful event, false otherwise.
  135|       |  ///
  136|       |  /// Note that each tag sent to the completion queue (through RPC operations
  137|       |  /// or alarms) will be delivered out of the completion queue by a call to
  138|       |  /// Next (or a related method), regardless of whether the operation succeeded
  139|       |  /// or not. Success here means that this operation completed in the normal
  140|       |  /// valid manner.
  141|       |  ///
  142|       |  /// Server-side RPC request: \a ok indicates that the RPC has indeed
  143|       |  /// been started. If it is false, the server has been Shutdown
  144|       |  /// before this particular call got matched to an incoming RPC.
  145|       |  ///
  146|       |  /// Client-side StartCall/RPC invocation: \a ok indicates that the RPC is
  147|       |  /// going to go to the wire. If it is false, it not going to the wire. This
  148|       |  /// would happen if the channel is either permanently broken or
  149|       |  /// transiently broken but with the fail-fast option. (Note that async unary
  150|       |  /// RPCs don't post a CQ tag at this point, nor do client-streaming
  151|       |  /// or bidi-streaming RPCs that have the initial metadata corked option set.)
  152|       |  ///
  153|       |  /// Client-side Write, Client-side WritesDone, Server-side Write,
  154|       |  /// Server-side Finish, Server-side SendInitialMetadata (which is
  155|       |  /// typically included in Write or Finish when not done explicitly):
  156|       |  /// \a ok means that the data/metadata/status/etc is going to go to the
  157|       |  /// wire. If it is false, it not going to the wire because the call
  158|       |  /// is already dead (i.e., canceled, deadline expired, other side
  159|       |  /// dropped the channel, etc).
  160|       |  ///
  161|       |  /// Client-side Read, Server-side Read, Client-side
  162|       |  /// RecvInitialMetadata (which is typically included in Read if not
  163|       |  /// done explicitly): \a ok indicates whether there is a valid message
  164|       |  /// that got read. If not, you know that there are certainly no more
  165|       |  /// messages that can ever be read from this stream. For the client-side
  166|       |  /// operations, this only happens because the call is dead. For the
  167|       |  /// server-sider operation, though, this could happen because the client
  168|       |  /// has done a WritesDone already.
  169|       |  ///
  170|       |  /// Client-side Finish: \a ok should always be true
  171|       |  ///
  172|       |  /// Server-side AsyncNotifyWhenDone: \a ok should always be true
  173|       |  ///
  174|       |  /// Alarm: \a ok is true if it expired, false if it was canceled
  175|       |  ///
  176|       |  /// \return true if got an event, false if the queue is fully drained and
  177|       |  ///         shut down.
  178|      0|  bool Next(void** tag, bool* ok) {
  179|      0|    return (AsyncNextInternal(tag, ok,
  180|      0|                              ::grpc::g_core_codegen_interface->gpr_inf_future(
  181|      0|                                  GPR_CLOCK_REALTIME)) != SHUTDOWN);
  182|      0|  }
  183|       |
  184|       |  /// Read from the queue, blocking up to \a deadline (or the queue's shutdown).
  185|       |  /// Both \a tag and \a ok are updated upon success (if an event is available
  186|       |  /// within the \a deadline).  A \a tag points to an arbitrary location usually
  187|       |  /// employed to uniquely identify an event.
  188|       |  ///
  189|       |  /// \param tag [out] Upon sucess, updated to point to the event's tag.
  190|       |  /// \param ok [out] Upon sucess, true if a successful event, false otherwise
  191|       |  ///        See documentation for CompletionQueue::Next for explanation of ok
  192|       |  /// \param deadline [in] How long to block in wait for an event.
  193|       |  ///
  194|       |  /// \return The type of event read.
  195|       |  template <typename T>
  196|      0|  NextStatus AsyncNext(void** tag, bool* ok, const T& deadline) {
  197|      0|    ::grpc::TimePoint<T> deadline_tp(deadline);
  198|      0|    return AsyncNextInternal(tag, ok, deadline_tp.raw_time());
  199|      0|  }
  200|       |
  201|       |  /// EXPERIMENTAL
  202|       |  /// First executes \a F, then reads from the queue, blocking up to
  203|       |  /// \a deadline (or the queue's shutdown).
  204|       |  /// Both \a tag and \a ok are updated upon success (if an event is available
  205|       |  /// within the \a deadline).  A \a tag points to an arbitrary location usually
  206|       |  /// employed to uniquely identify an event.
  207|       |  ///
  208|       |  /// \param f [in] Function to execute before calling AsyncNext on this queue.
  209|       |  /// \param tag [out] Upon sucess, updated to point to the event's tag.
  210|       |  /// \param ok [out] Upon sucess, true if read a regular event, false
  211|       |  /// otherwise.
  212|       |  /// \param deadline [in] How long to block in wait for an event.
  213|       |  ///
  214|       |  /// \return The type of event read.
  215|       |  template <typename T, typename F>
  216|       |  NextStatus DoThenAsyncNext(F&& f, void** tag, bool* ok, const T& deadline) {
  217|       |    CompletionQueueTLSCache cache = CompletionQueueTLSCache(this);
  218|       |    f();
  219|       |    if (cache.Flush(tag, ok)) {
  220|       |      return GOT_EVENT;
  221|       |    } else {
  222|       |      return AsyncNext(tag, ok, deadline);
  223|       |    }
  224|       |  }
  225|       |
  226|       |  /// Request the shutdown of the queue.
  227|       |  ///
  228|       |  /// \warning This method must be called at some point if this completion queue
  229|       |  /// is accessed with Next or AsyncNext. \a Next will not return false
  230|       |  /// until this method has been called and all pending tags have been drained.
  231|       |  /// (Likewise for \a AsyncNext returning \a NextStatus::SHUTDOWN .)
  232|       |  /// Only once either one of these methods does that (that is, once the queue
  233|       |  /// has been \em drained) can an instance of this class be destroyed.
  234|       |  /// Also note that applications must ensure that no work is enqueued on this
  235|       |  /// completion queue after this method is called.
  236|       |  void Shutdown();
  237|       |
  238|       |  /// Returns a \em raw pointer to the underlying \a grpc_completion_queue
  239|       |  /// instance.
  240|       |  ///
  241|       |  /// \warning Remember that the returned instance is owned. No transfer of
  242|       |  /// owership is performed.
  243|      0|  grpc_completion_queue* cq() { return cq_; }
  244|       |
  245|       | protected:
  246|       |  /// Private constructor of CompletionQueue only visible to friend classes
  247|      0|  CompletionQueue(const grpc_completion_queue_attributes& attributes) {
  248|      0|    cq_ = ::grpc::g_core_codegen_interface->grpc_completion_queue_create(
  249|      0|        ::grpc::g_core_codegen_interface->grpc_completion_queue_factory_lookup(
  250|      0|            &attributes),
  251|      0|        &attributes, NULL);
  252|      0|    InitialAvalanching();  // reserve this for the future shutdown
  253|      0|  }
  254|       |
  255|       | private:
  256|       |  // Friend synchronous wrappers so that they can access Pluck(), which is
  257|       |  // a semi-private API geared towards the synchronous implementation.
  258|       |  template <class R>
  259|       |  friend class ::grpc::ClientReader;
  260|       |  template <class W>
  261|       |  friend class ::grpc::ClientWriter;
  262|       |  template <class W, class R>
  263|       |  friend class ::grpc::ClientReaderWriter;
  264|       |  template <class R>
  265|       |  friend class ::grpc::ServerReader;
  266|       |  template <class W>
  267|       |  friend class ::grpc::ServerWriter;
  268|       |  template <class W, class R>
  269|       |  friend class ::grpc::internal::ServerReaderWriterBody;
  270|       |  template <class ServiceType, class RequestType, class ResponseType>
  271|       |  friend class ::grpc::internal::RpcMethodHandler;
  272|       |  template <class ServiceType, class RequestType, class ResponseType>
  273|       |  friend class ::grpc::internal::ClientStreamingHandler;
  274|       |  template <class ServiceType, class RequestType, class ResponseType>
  275|       |  friend class ::grpc::internal::ServerStreamingHandler;
  276|       |  template <class Streamer, bool WriteNeeded>
  277|       |  friend class ::grpc::internal::TemplatedBidiStreamingHandler;
  278|       |  template <::grpc::StatusCode code>
  279|       |  friend class ::grpc::internal::ErrorMethodHandler;
  280|       |  friend class ::grpc_impl::Server;
  281|       |  friend class ::grpc::ServerContext;
  282|       |  friend class ::grpc::ServerInterface;
  283|       |  template <class InputMessage, class OutputMessage>
  284|       |  friend class ::grpc::internal::BlockingUnaryCallImpl;
  285|       |
  286|       |  // Friends that need access to constructor for callback CQ
  287|       |  friend class ::grpc_impl::Channel;
  288|       |
  289|       |  // For access to Register/CompleteAvalanching
  290|       |  template <class Op1, class Op2, class Op3, class Op4, class Op5, class Op6>
  291|       |  friend class ::grpc::internal::CallOpSet;
  292|       |
  293|       |  /// EXPERIMENTAL
  294|       |  /// Creates a Thread Local cache to store the first event
  295|       |  /// On this completion queue queued from this thread.  Once
  296|       |  /// initialized, it must be flushed on the same thread.
  297|       |  class CompletionQueueTLSCache {
  298|       |   public:
  299|       |    CompletionQueueTLSCache(CompletionQueue* cq);
  300|       |    ~CompletionQueueTLSCache();
  301|       |    bool Flush(void** tag, bool* ok);
  302|       |
  303|       |   private:
  304|       |    CompletionQueue* cq_;
  305|       |    bool flushed_;
  306|       |  };
  307|       |
  308|       |  NextStatus AsyncNextInternal(void** tag, bool* ok, gpr_timespec deadline);
  309|       |
  310|       |  /// Wraps \a grpc_completion_queue_pluck.
  311|       |  /// \warning Must not be mixed with calls to \a Next.
  312|      0|  bool Pluck(::grpc::internal::CompletionQueueTag* tag) {
  313|      0|    auto deadline =
  314|      0|        ::grpc::g_core_codegen_interface->gpr_inf_future(GPR_CLOCK_REALTIME);
  315|      0|    while (true) {
  316|      0|      auto ev = ::grpc::g_core_codegen_interface->grpc_completion_queue_pluck(
  317|      0|          cq_, tag, deadline, nullptr);
  318|      0|      bool ok = ev.success != 0;
  319|      0|      void* ignored = tag;
  320|      0|      if (tag->FinalizeResult(&ignored, &ok)) {
  321|      0|        GPR_CODEGEN_ASSERT(ignored == tag);
  322|      0|        return ok;
  323|      0|      }
  324|      0|    }
  325|      0|  }
  326|       |
  327|       |  /// Performs a single polling pluck on \a tag.
  328|       |  /// \warning Must not be mixed with calls to \a Next.
  329|       |  ///
  330|       |  /// TODO: sreek - This calls tag->FinalizeResult() even if the cq_ is already
  331|       |  /// shutdown. This is most likely a bug and if it is a bug, then change this
  332|       |  /// implementation to simple call the other TryPluck function with a zero
  333|       |  /// timeout. i.e:
  334|       |  ///      TryPluck(tag, gpr_time_0(GPR_CLOCK_REALTIME))
  335|      0|  void TryPluck(::grpc::internal::CompletionQueueTag* tag) {
  336|      0|    auto deadline =
  337|      0|        ::grpc::g_core_codegen_interface->gpr_time_0(GPR_CLOCK_REALTIME);
  338|      0|    auto ev = ::grpc::g_core_codegen_interface->grpc_completion_queue_pluck(
  339|      0|        cq_, tag, deadline, nullptr);
  340|      0|    if (ev.type == GRPC_QUEUE_TIMEOUT) return;
  341|      0|    bool ok = ev.success != 0;
  342|      0|    void* ignored = tag;
  343|      0|    // the tag must be swallowed if using TryPluck
  344|      0|    GPR_CODEGEN_ASSERT(!tag->FinalizeResult(&ignored, &ok));
  345|      0|  }
  346|       |
  347|       |  /// Performs a single polling pluck on \a tag. Calls tag->FinalizeResult if
  348|       |  /// the pluck() was successful and returned the tag.
  349|       |  ///
  350|       |  /// This exects tag->FinalizeResult (if called) to return 'false' i.e expects
  351|       |  /// that the tag is internal not something that is returned to the user.
  352|       |  void TryPluck(::grpc::internal::CompletionQueueTag* tag,
  353|      0|                gpr_timespec deadline) {
  354|      0|    auto ev = ::grpc::g_core_codegen_interface->grpc_completion_queue_pluck(
  355|      0|        cq_, tag, deadline, nullptr);
  356|      0|    if (ev.type == GRPC_QUEUE_TIMEOUT || ev.type == GRPC_QUEUE_SHUTDOWN) {
  357|      0|      return;
  358|      0|    }
  359|      0|
  360|      0|    bool ok = ev.success != 0;
  361|      0|    void* ignored = tag;
  362|      0|    GPR_CODEGEN_ASSERT(!tag->FinalizeResult(&ignored, &ok));
  363|      0|  }
  364|       |
  365|       |  /// Manage state of avalanching operations : completion queue tags that
  366|       |  /// trigger other completion queue operations. The underlying core completion
  367|       |  /// queue should not really shutdown until all avalanching operations have
  368|       |  /// been finalized. Note that we maintain the requirement that an avalanche
  369|       |  /// registration must take place before CQ shutdown (which must be maintained
  370|       |  /// elsehwere)
  371|      0|  void InitialAvalanching() {
  372|      0|    gpr_atm_rel_store(&avalanches_in_flight_, static_cast<gpr_atm>(1));
  373|      0|  }
  374|      0|  void RegisterAvalanching() {
  375|      0|    gpr_atm_no_barrier_fetch_add(&avalanches_in_flight_,
  376|      0|                                 static_cast<gpr_atm>(1));
  377|      0|  }
  378|      0|  void CompleteAvalanching() {
  379|      0|    if (gpr_atm_no_barrier_fetch_add(&avalanches_in_flight_,
  380|      0|                                     static_cast<gpr_atm>(-1)) == 1) {
  381|      0|      ::grpc::g_core_codegen_interface->grpc_completion_queue_shutdown(cq_);
  382|      0|    }
  383|      0|  }
  384|       |
  385|       |  grpc_completion_queue* cq_;  // owned
  386|       |
  387|       |  gpr_atm avalanches_in_flight_;
  388|       |};
  389|       |
  390|       |/// A specific type of completion queue used by the processing of notifications
  391|       |/// by servers. Instantiated by \a ServerBuilder.
  392|       |class ServerCompletionQueue : public CompletionQueue {
  393|       | public:
  394|      0|  bool IsFrequentlyPolled() { return polling_type_ != GRPC_CQ_NON_LISTENING; }
  395|       |
  396|       | protected:
  397|       |  /// Default constructor
  398|      0|  ServerCompletionQueue() : polling_type_(GRPC_CQ_DEFAULT_POLLING) {}
  399|       |
  400|       | private:
  401|       |  /// \param completion_type indicates whether this is a NEXT or CALLBACK
  402|       |  /// completion queue.
  403|       |  /// \param polling_type Informs the GRPC library about the type of polling
  404|       |  /// allowed on this completion queue. See grpc_cq_polling_type's description
  405|       |  /// in grpc_types.h for more details.
  406|       |  /// \param shutdown_cb is the shutdown callback used for CALLBACK api queues
  407|       |  ServerCompletionQueue(grpc_cq_completion_type completion_type,
  408|       |                        grpc_cq_polling_type polling_type,
  409|       |                        grpc_experimental_completion_queue_functor* shutdown_cb)
  410|       |      : CompletionQueue(grpc_completion_queue_attributes{
  411|       |            GRPC_CQ_CURRENT_VERSION, completion_type, polling_type,
  412|       |            shutdown_cb}),
  413|      0|        polling_type_(polling_type) {}
  414|       |
  415|       |  grpc_cq_polling_type polling_type_;
  416|       |  friend class ::grpc_impl::ServerBuilder;
  417|       |  friend class ::grpc_impl::Server;
  418|       |};
  419|       |
  420|       |}  // namespace grpc_impl
  421|       |
  422|       |#endif  // GRPCPP_IMPL_CODEGEN_COMPLETION_QUEUE_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/completion_queue_tag.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_COMPLETION_QUEUE_TAG_H
   20|       |#define GRPCPP_IMPL_CODEGEN_COMPLETION_QUEUE_TAG_H
   21|       |
   22|       |namespace grpc {
   23|       |
   24|       |namespace internal {
   25|       |/// An interface allowing implementors to process and filter event tags.
   26|       |class CompletionQueueTag {
   27|       | public:
   28|      0|  virtual ~CompletionQueueTag() {}
   29|       |
   30|       |  /// FinalizeResult must be called before informing user code that the
   31|       |  /// operation bound to the underlying core completion queue tag has
   32|       |  /// completed. In practice, this means:
   33|       |  ///
   34|       |  ///   1. For the sync API - before returning from Pluck
   35|       |  ///   2. For the CQ-based async API - before returning from Next
   36|       |  ///   3. For the callback-based API - before invoking the user callback
   37|       |  ///
   38|       |  /// This is the method that translates from core-side tag/status to
   39|       |  /// C++ API-observable tag/status.
   40|       |  ///
   41|       |  /// The return value is the status of the operation (returning status is the
   42|       |  /// general behavior of this function). If this function returns false, the
   43|       |  /// tag is dropped and not returned from the completion queue: this concept is
   44|       |  /// for events that are observed at core but not requested by the user
   45|       |  /// application (e.g., server shutdown, for server unimplemented method
   46|       |  /// responses, or for cases where a server-side RPC doesn't have a completion
   47|       |  /// notification registered using AsyncNotifyWhenDone)
   48|       |  virtual bool FinalizeResult(void** tag, bool* status) = 0;
   49|       |};
   50|       |}  // namespace internal
   51|       |
   52|       |}  // namespace grpc
   53|       |
   54|       |#endif  // GRPCPP_IMPL_CODEGEN_COMPLETION_QUEUE_TAG_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/core_codegen_interface.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_CORE_CODEGEN_INTERFACE_H
   20|       |#define GRPCPP_IMPL_CODEGEN_CORE_CODEGEN_INTERFACE_H
   21|       |
   22|       |#include <grpc/impl/codegen/byte_buffer_reader.h>
   23|       |#include <grpc/impl/codegen/grpc_types.h>
   24|       |#include <grpc/impl/codegen/sync.h>
   25|       |#include <grpcpp/impl/codegen/config.h>
   26|       |#include <grpcpp/impl/codegen/status.h>
   27|       |
   28|       |namespace grpc {
   29|       |
   30|       |/// Interface between the codegen library and the minimal subset of core
   31|       |/// features required by the generated code.
   32|       |///
   33|       |/// All undocumented methods are simply forwarding the call to their namesakes.
   34|       |/// Please refer to their corresponding documentation for details.
   35|       |///
   36|       |/// \warning This interface should be considered internal and private.
   37|       |class CoreCodegenInterface {
   38|       | public:
   39|      0|  virtual ~CoreCodegenInterface() = default;
   40|       |
   41|       |  /// Upon a failed assertion, log the error.
   42|       |  virtual void assert_fail(const char* failed_assertion, const char* file,
   43|       |                           int line) = 0;
   44|       |
   45|       |  virtual const grpc_completion_queue_factory*
   46|       |  grpc_completion_queue_factory_lookup(
   47|       |      const grpc_completion_queue_attributes* attributes) = 0;
   48|       |  virtual grpc_completion_queue* grpc_completion_queue_create(
   49|       |      const grpc_completion_queue_factory* factory,
   50|       |      const grpc_completion_queue_attributes* attributes, void* reserved) = 0;
   51|       |  virtual grpc_completion_queue* grpc_completion_queue_create_for_next(
   52|       |      void* reserved) = 0;
   53|       |  virtual grpc_completion_queue* grpc_completion_queue_create_for_pluck(
   54|       |      void* reserved) = 0;
   55|       |  virtual void grpc_completion_queue_shutdown(grpc_completion_queue* cq) = 0;
   56|       |  virtual void grpc_completion_queue_destroy(grpc_completion_queue* cq) = 0;
   57|       |  virtual grpc_event grpc_completion_queue_pluck(grpc_completion_queue* cq,
   58|       |                                                 void* tag,
   59|       |                                                 gpr_timespec deadline,
   60|       |                                                 void* reserved) = 0;
   61|       |
   62|       |  virtual void* gpr_malloc(size_t size) = 0;
   63|       |  virtual void gpr_free(void* p) = 0;
   64|       |
   65|       |  // These are only to be used to fix edge cases involving grpc_init and
   66|       |  // grpc_shutdown. Calling grpc_init from the codegen interface before
   67|       |  // the real grpc_init is called will cause a crash, so if you use this
   68|       |  // function, ensure that it is not the first call to grpc_init.
   69|       |  virtual void grpc_init() = 0;
   70|       |  virtual void grpc_shutdown() = 0;
   71|       |
   72|       |  virtual void gpr_mu_init(gpr_mu* mu) = 0;
   73|       |  virtual void gpr_mu_destroy(gpr_mu* mu) = 0;
   74|       |  virtual void gpr_mu_lock(gpr_mu* mu) = 0;
   75|       |  virtual void gpr_mu_unlock(gpr_mu* mu) = 0;
   76|       |  virtual void gpr_cv_init(gpr_cv* cv) = 0;
   77|       |  virtual void gpr_cv_destroy(gpr_cv* cv) = 0;
   78|       |  virtual int gpr_cv_wait(gpr_cv* cv, gpr_mu* mu,
   79|       |                          gpr_timespec abs_deadline) = 0;
   80|       |  virtual void gpr_cv_signal(gpr_cv* cv) = 0;
   81|       |  virtual void gpr_cv_broadcast(gpr_cv* cv) = 0;
   82|       |
   83|       |  virtual grpc_byte_buffer* grpc_byte_buffer_copy(grpc_byte_buffer* bb) = 0;
   84|       |  virtual void grpc_byte_buffer_destroy(grpc_byte_buffer* bb) = 0;
   85|       |  virtual size_t grpc_byte_buffer_length(grpc_byte_buffer* bb)
   86|       |      GRPC_MUST_USE_RESULT = 0;
   87|       |
   88|       |  virtual int grpc_byte_buffer_reader_init(grpc_byte_buffer_reader* reader,
   89|       |                                           grpc_byte_buffer* buffer)
   90|       |      GRPC_MUST_USE_RESULT = 0;
   91|       |  virtual void grpc_byte_buffer_reader_destroy(
   92|       |      grpc_byte_buffer_reader* reader) = 0;
   93|       |  virtual int grpc_byte_buffer_reader_next(grpc_byte_buffer_reader* reader,
   94|       |                                           grpc_slice* slice) = 0;
   95|       |  virtual int grpc_byte_buffer_reader_peek(grpc_byte_buffer_reader* reader,
   96|       |                                           grpc_slice** slice) = 0;
   97|       |
   98|       |  virtual grpc_byte_buffer* grpc_raw_byte_buffer_create(grpc_slice* slice,
   99|       |                                                        size_t nslices) = 0;
  100|       |  virtual grpc_slice grpc_slice_new_with_user_data(void* p, size_t len,
  101|       |                                                   void (*destroy)(void*),
  102|       |                                                   void* user_data) = 0;
  103|       |  virtual grpc_slice grpc_slice_new_with_len(void* p, size_t len,
  104|       |                                             void (*destroy)(void*,
  105|       |                                                             size_t)) = 0;
  106|       |  virtual grpc_call_error grpc_call_start_batch(grpc_call* call,
  107|       |                                                const grpc_op* ops, size_t nops,
  108|       |                                                void* tag, void* reserved) = 0;
  109|       |  virtual grpc_call_error grpc_call_cancel_with_status(grpc_call* call,
  110|       |                                                       grpc_status_code status,
  111|       |                                                       const char* description,
  112|       |                                                       void* reserved) = 0;
  113|       |  virtual void grpc_call_ref(grpc_call* call) = 0;
  114|       |  virtual void grpc_call_unref(grpc_call* call) = 0;
  115|       |  virtual void* grpc_call_arena_alloc(grpc_call* call, size_t length) = 0;
  116|       |  virtual grpc_slice grpc_empty_slice() = 0;
  117|       |  virtual grpc_slice grpc_slice_malloc(size_t length) = 0;
  118|       |  virtual void grpc_slice_unref(grpc_slice slice) = 0;
  119|       |  virtual grpc_slice grpc_slice_ref(grpc_slice slice) = 0;
  120|       |  virtual grpc_slice grpc_slice_split_tail(grpc_slice* s, size_t split) = 0;
  121|       |  virtual grpc_slice grpc_slice_split_head(grpc_slice* s, size_t split) = 0;
  122|       |  virtual grpc_slice grpc_slice_sub(grpc_slice s, size_t begin, size_t end) = 0;
  123|       |  virtual void grpc_slice_buffer_add(grpc_slice_buffer* sb,
  124|       |                                     grpc_slice slice) = 0;
  125|       |  virtual void grpc_slice_buffer_pop(grpc_slice_buffer* sb) = 0;
  126|       |  virtual grpc_slice grpc_slice_from_static_buffer(const void* buffer,
  127|       |                                                   size_t length) = 0;
  128|       |  virtual grpc_slice grpc_slice_from_copied_buffer(const void* buffer,
  129|       |                                                   size_t length) = 0;
  130|       |
  131|       |  virtual void grpc_metadata_array_init(grpc_metadata_array* array) = 0;
  132|       |  virtual void grpc_metadata_array_destroy(grpc_metadata_array* array) = 0;
  133|       |
  134|       |  virtual const Status& ok() = 0;
  135|       |  virtual const Status& cancelled() = 0;
  136|       |
  137|       |  virtual gpr_timespec gpr_inf_future(gpr_clock_type type) = 0;
  138|       |  virtual gpr_timespec gpr_time_0(gpr_clock_type type) = 0;
  139|       |};
  140|       |
  141|       |extern CoreCodegenInterface* g_core_codegen_interface;
  142|       |
  143|       |/// Codegen specific version of \a GPR_ASSERT.
  144|       |#define GPR_CODEGEN_ASSERT(x)                                              \
  145|      0|  do {                                                                     \
  146|      0|    if (!(x)) {                                                            \
  147|      0|      grpc::g_core_codegen_interface->assert_fail(#x, __FILE__, __LINE__); \
  148|      0|    }                                                                      \
  149|      0|  } while (0)
  150|       |
  151|       |/// Codegen specific version of \a GPR_DEBUG_ASSERT.
  152|       |#ifndef NDEBUG
  153|       |#define GPR_CODEGEN_DEBUG_ASSERT(x) GPR_CODEGEN_ASSERT(x)
  154|       |#else
  155|       |#define GPR_CODEGEN_DEBUG_ASSERT(x) \
  156|       |  do {                              \
  157|       |  } while (0)
  158|       |#endif
  159|       |
  160|       |}  // namespace grpc
  161|       |
  162|       |#endif  // GRPCPP_IMPL_CODEGEN_CORE_CODEGEN_INTERFACE_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/grpc_library.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_GRPC_LIBRARY_H
   20|       |#define GRPCPP_IMPL_CODEGEN_GRPC_LIBRARY_H
   21|       |
   22|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   23|       |
   24|       |namespace grpc {
   25|       |
   26|       |class GrpcLibraryInterface {
   27|       | public:
   28|      0|  virtual ~GrpcLibraryInterface() = default;
   29|       |  virtual void init() = 0;
   30|       |  virtual void shutdown() = 0;
   31|       |};
   32|       |
   33|       |/// Initialized by \a grpc::GrpcLibraryInitializer from
   34|       |/// <grpcpp/impl/grpc_library.h>
   35|       |extern GrpcLibraryInterface* g_glip;
   36|       |
   37|       |/// Classes that require gRPC to be initialized should inherit from this class.
   38|       |class GrpcLibraryCodegen {
   39|       | public:
   40|      0|  GrpcLibraryCodegen(bool call_grpc_init = true) : grpc_init_called_(false) {
   41|      0|    if (call_grpc_init) {
   42|      0|      GPR_CODEGEN_ASSERT(g_glip &&
   43|      0|                         "gRPC library not initialized. See "
   44|      0|                         "grpc::internal::GrpcLibraryInitializer.");
   45|      0|      g_glip->init();
   46|      0|      grpc_init_called_ = true;
   47|      0|    }
   48|      0|  }
   49|      0|  virtual ~GrpcLibraryCodegen() {
   50|      0|    if (grpc_init_called_) {
   51|      0|      GPR_CODEGEN_ASSERT(g_glip &&
   52|      0|                         "gRPC library not initialized. See "
   53|      0|                         "grpc::internal::GrpcLibraryInitializer.");
   54|      0|      g_glip->shutdown();
   55|      0|    }
   56|      0|  }
   57|       |
   58|       | private:
   59|       |  bool grpc_init_called_;
   60|       |};
   61|       |
   62|       |}  // namespace grpc
   63|       |
   64|       |#endif  // GRPCPP_IMPL_CODEGEN_GRPC_LIBRARY_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/intercepted_channel.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_INTERCEPTED_CHANNEL_H
   20|       |#define GRPCPP_IMPL_CODEGEN_INTERCEPTED_CHANNEL_H
   21|       |
   22|       |#include <grpcpp/impl/codegen/channel_interface.h>
   23|       |
   24|       |namespace grpc_impl {
   25|       |class CompletionQueue;
   26|       |}
   27|       |
   28|       |namespace grpc {
   29|       |
   30|       |namespace internal {
   31|       |
   32|       |class InterceptorBatchMethodsImpl;
   33|       |
   34|       |/// An InterceptedChannel is available to client Interceptors. An
   35|       |/// InterceptedChannel is unique to an interceptor, and when an RPC is started
   36|       |/// on this channel, only those interceptors that come after this interceptor
   37|       |/// see the RPC.
   38|       |class InterceptedChannel : public ChannelInterface {
   39|       | public:
   40|      0|  virtual ~InterceptedChannel() { channel_ = nullptr; }
   41|       |
   42|       |  /// Get the current channel state. If the channel is in IDLE and
   43|       |  /// \a try_to_connect is set to true, try to connect.
   44|      0|  grpc_connectivity_state GetState(bool try_to_connect) override {
   45|      0|    return channel_->GetState(try_to_connect);
   46|      0|  }
   47|       |
   48|       | private:
   49|       |  InterceptedChannel(ChannelInterface* channel, size_t pos)
   50|      0|      : channel_(channel), interceptor_pos_(pos) {}
   51|       |
   52|       |  Call CreateCall(const RpcMethod& method, ClientContext* context,
   53|      0|                  ::grpc_impl::CompletionQueue* cq) override {
   54|      0|    return channel_->CreateCallInternal(method, context, cq, interceptor_pos_);
   55|      0|  }
   56|       |
   57|      0|  void PerformOpsOnCall(CallOpSetInterface* ops, Call* call) override {
   58|      0|    return channel_->PerformOpsOnCall(ops, call);
   59|      0|  }
   60|      0|  void* RegisterMethod(const char* method) override {
   61|      0|    return channel_->RegisterMethod(method);
   62|      0|  }
   63|       |
   64|       |  void NotifyOnStateChangeImpl(grpc_connectivity_state last_observed,
   65|       |                               gpr_timespec deadline,
   66|       |                               ::grpc_impl::CompletionQueue* cq,
   67|      0|                               void* tag) override {
   68|      0|    return channel_->NotifyOnStateChangeImpl(last_observed, deadline, cq, tag);
   69|      0|  }
   70|       |  bool WaitForStateChangeImpl(grpc_connectivity_state last_observed,
   71|      0|                              gpr_timespec deadline) override {
   72|      0|    return channel_->WaitForStateChangeImpl(last_observed, deadline);
   73|      0|  }
   74|       |
   75|      0|  ::grpc_impl::CompletionQueue* CallbackCQ() override {
   76|      0|    return channel_->CallbackCQ();
   77|      0|  }
   78|       |
   79|       |  ChannelInterface* channel_;
   80|       |  size_t interceptor_pos_;
   81|       |
   82|       |  friend class InterceptorBatchMethodsImpl;
   83|       |};
   84|       |}  // namespace internal
   85|       |}  // namespace grpc
   86|       |
   87|       |#endif  // GRPCPP_IMPL_CODEGEN_INTERCEPTED_CHANNEL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/interceptor.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_INTERCEPTOR_H
   20|       |#define GRPCPP_IMPL_CODEGEN_INTERCEPTOR_H
   21|       |
   22|       |#include <grpc/impl/codegen/grpc_types.h>
   23|       |#include <grpcpp/impl/codegen/byte_buffer.h>
   24|       |#include <grpcpp/impl/codegen/config.h>
   25|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   26|       |#include <grpcpp/impl/codegen/metadata_map.h>
   27|       |
   28|       |namespace grpc {
   29|       |
   30|       |class ChannelInterface;
   31|       |class Status;
   32|       |
   33|       |namespace experimental {
   34|       |
   35|       |/// An enumeration of different possible points at which the \a Intercept
   36|       |/// method of the \a Interceptor interface may be called. Any given call
   37|       |/// to \a Intercept will include one or more of these hook points, and
   38|       |/// each hook point makes certain types of information available to the
   39|       |/// interceptor.
   40|       |/// In these enumeration names, PRE_SEND means that an interception has taken
   41|       |/// place between the time the application provided a certain type of data
   42|       |/// (e.g., initial metadata, status) and the time that that data goes to the
   43|       |/// other side. POST_SEND means that the data has been committed for going to
   44|       |/// the other side (even if it has not yet been received at the other side).
   45|       |/// PRE_RECV means an interception between the time that a certain
   46|       |/// operation has been requested and it is available. POST_RECV means that a
   47|       |/// result is available but has not yet been passed back to the application.
   48|       |/// A batch of interception points will only contain either PRE or POST hooks
   49|       |/// but not both types. For example, a batch with PRE_SEND hook points will not
   50|       |/// contain POST_RECV or POST_SEND ops. Likewise, a batch with POST_* ops can
   51|       |/// not contain PRE_* ops.
   52|       |enum class InterceptionHookPoints {
   53|       |  /// The first three in this list are for clients and servers
   54|       |  PRE_SEND_INITIAL_METADATA,
   55|       |  PRE_SEND_MESSAGE,
   56|       |  POST_SEND_MESSAGE,
   57|       |  PRE_SEND_STATUS,  // server only
   58|       |  PRE_SEND_CLOSE,   // client only: WritesDone for stream; after write in unary
   59|       |  /// The following three are for hijacked clients only. A batch with PRE_RECV_*
   60|       |  /// hook points will never contain hook points of other types.
   61|       |  PRE_RECV_INITIAL_METADATA,
   62|       |  PRE_RECV_MESSAGE,
   63|       |  PRE_RECV_STATUS,
   64|       |  /// The following two are for all clients and servers
   65|       |  POST_RECV_INITIAL_METADATA,
   66|       |  POST_RECV_MESSAGE,
   67|       |  POST_RECV_STATUS,  // client only
   68|       |  POST_RECV_CLOSE,   // server only
   69|       |  /// This is a special hook point available to both clients and servers when
   70|       |  /// TryCancel() is performed.
   71|       |  ///  - No other hook points will be present along with this.
   72|       |  ///  - It is illegal for an interceptor to block/delay this operation.
   73|       |  ///  - ALL interceptors see this hook point irrespective of whether the
   74|       |  ///    RPC was hijacked or not.
   75|       |  PRE_SEND_CANCEL,
   76|       |  NUM_INTERCEPTION_HOOKS
   77|       |};
   78|       |
   79|       |/// Class that is passed as an argument to the \a Intercept method
   80|       |/// of the application's \a Interceptor interface implementation. It has five
   81|       |/// purposes:
   82|       |///   1. Indicate which hook points are present at a specific interception
   83|       |///   2. Allow an interceptor to inform the library that an RPC should
   84|       |///      continue to the next stage of its processing (which may be another
   85|       |///      interceptor or the main path of the library)
   86|       |///   3. Allow an interceptor to hijack the processing of the RPC (only for
   87|       |///      client-side RPCs with PRE_SEND_INITIAL_METADATA) so that it does not
   88|       |///      proceed with normal processing beyond that stage
   89|       |///   4. Access the relevant fields of an RPC at each interception point
   90|       |///   5. Set some fields of an RPC at each interception point, when possible
   91|       |class InterceptorBatchMethods {
   92|       | public:
   93|      0|  virtual ~InterceptorBatchMethods() {}
   94|       |  /// Determine whether the current batch has an interception hook point
   95|       |  /// of type \a type
   96|       |  virtual bool QueryInterceptionHookPoint(InterceptionHookPoints type) = 0;
   97|       |  /// Signal that the interceptor is done intercepting the current batch of the
   98|       |  /// RPC. Every interceptor must either call Proceed or Hijack on each
   99|       |  /// interception. In most cases, only Proceed will be used. Explicit use of
  100|       |  /// Proceed is what enables interceptors to delay the processing of RPCs
  101|       |  /// while they perform other work.
  102|       |  /// Proceed is a no-op if the batch contains PRE_SEND_CANCEL. Simply returning
  103|       |  /// from the Intercept method does the job of continuing the RPC in this case.
  104|       |  /// This is because PRE_SEND_CANCEL is always in a separate batch and is not
  105|       |  /// allowed to be delayed.
  106|       |  virtual void Proceed() = 0;
  107|       |  /// Indicate that the interceptor has hijacked the RPC (only valid if the
  108|       |  /// batch contains send_initial_metadata on the client side). Later
  109|       |  /// interceptors in the interceptor list will not be called. Later batches
  110|       |  /// on the same RPC will go through interception, but only up to the point
  111|       |  /// of the hijacking interceptor.
  112|       |  virtual void Hijack() = 0;
  113|       |
  114|       |  /// Send Message Methods
  115|       |  /// GetSerializedSendMessage and GetSendMessage/ModifySendMessage are the
  116|       |  /// available methods to view and modify the request payload. An interceptor
  117|       |  /// can access the payload in either serialized form or non-serialized form
  118|       |  /// but not both at the same time.
  119|       |  /// gRPC performs serialization in a lazy manner, which means
  120|       |  /// that a call to GetSerializedSendMessage will result in a serialization
  121|       |  /// operation if the payload stored is not in the serialized form already; the
  122|       |  /// non-serialized form will be lost and GetSendMessage will no longer return
  123|       |  /// a valid pointer, and this will remain true for later interceptors too.
  124|       |  /// This can change however if ModifySendMessage is used to replace the
  125|       |  /// current payload. Note that ModifySendMessage requires a new payload
  126|       |  /// message in the non-serialized form. This will overwrite the existing
  127|       |  /// payload irrespective of whether it had been serialized earlier. Also note
  128|       |  /// that gRPC Async API requires early serialization of the payload which
  129|       |  /// means that the payload would be available in the serialized form only
  130|       |  /// unless an interceptor replaces the payload with ModifySendMessage.
  131|       |
  132|       |  /// Returns a modifable ByteBuffer holding the serialized form of the message
  133|       |  /// that is going to be sent. Valid for PRE_SEND_MESSAGE interceptions.
  134|       |  /// A return value of nullptr indicates that this ByteBuffer is not valid.
  135|       |  virtual ByteBuffer* GetSerializedSendMessage() = 0;
  136|       |
  137|       |  /// Returns a non-modifiable pointer to the non-serialized form of the message
  138|       |  /// to be sent. Valid for PRE_SEND_MESSAGE interceptions. A return value of
  139|       |  /// nullptr indicates that this field is not valid.
  140|       |  virtual const void* GetSendMessage() = 0;
  141|       |
  142|       |  /// Overwrites the message to be sent with \a message. \a message should be in
  143|       |  /// the non-serialized form expected by the method. Valid for PRE_SEND_MESSAGE
  144|       |  /// interceptions. Note that the interceptor is responsible for maintaining
  145|       |  /// the life of the message till it is serialized or it receives the
  146|       |  /// POST_SEND_MESSAGE interception point, whichever happens earlier. The
  147|       |  /// modifying interceptor may itself force early serialization by calling
  148|       |  /// GetSerializedSendMessage.
  149|       |  virtual void ModifySendMessage(const void* message) = 0;
  150|       |
  151|       |  /// Checks whether the SEND MESSAGE op succeeded. Valid for POST_SEND_MESSAGE
  152|       |  /// interceptions.
  153|       |  virtual bool GetSendMessageStatus() = 0;
  154|       |
  155|       |  /// Returns a modifiable multimap of the initial metadata to be sent. Valid
  156|       |  /// for PRE_SEND_INITIAL_METADATA interceptions. A value of nullptr indicates
  157|       |  /// that this field is not valid.
  158|       |  virtual std::multimap<grpc::string, grpc::string>*
  159|       |  GetSendInitialMetadata() = 0;
  160|       |
  161|       |  /// Returns the status to be sent. Valid for PRE_SEND_STATUS interceptions.
  162|       |  virtual Status GetSendStatus() = 0;
  163|       |
  164|       |  /// Overwrites the status with \a status. Valid for PRE_SEND_STATUS
  165|       |  /// interceptions.
  166|       |  virtual void ModifySendStatus(const Status& status) = 0;
  167|       |
  168|       |  /// Returns a modifiable multimap of the trailing metadata to be sent. Valid
  169|       |  /// for PRE_SEND_STATUS interceptions. A value of nullptr indicates
  170|       |  /// that this field is not valid.
  171|       |  virtual std::multimap<grpc::string, grpc::string>*
  172|       |  GetSendTrailingMetadata() = 0;
  173|       |
  174|       |  /// Returns a pointer to the modifiable received message. Note that the
  175|       |  /// message is already deserialized but the type is not set; the interceptor
  176|       |  /// should static_cast to the appropriate type before using it. This is valid
  177|       |  /// for POST_RECV_MESSAGE interceptions; nullptr for not valid
  178|       |  virtual void* GetRecvMessage() = 0;
  179|       |
  180|       |  /// Returns a modifiable multimap of the received initial metadata.
  181|       |  /// Valid for POST_RECV_INITIAL_METADATA interceptions; nullptr if not valid
  182|       |  virtual std::multimap<grpc::string_ref, grpc::string_ref>*
  183|       |  GetRecvInitialMetadata() = 0;
  184|       |
  185|       |  /// Returns a modifiable view of the received status on POST_RECV_STATUS
  186|       |  /// interceptions; nullptr if not valid.
  187|       |  virtual Status* GetRecvStatus() = 0;
  188|       |
  189|       |  /// Returns a modifiable multimap of the received trailing metadata on
  190|       |  /// POST_RECV_STATUS interceptions; nullptr if not valid
  191|       |  virtual std::multimap<grpc::string_ref, grpc::string_ref>*
  192|       |  GetRecvTrailingMetadata() = 0;
  193|       |
  194|       |  /// Gets an intercepted channel. When a call is started on this interceptor,
  195|       |  /// only interceptors after the current interceptor are created from the
  196|       |  /// factory objects registered with the channel. This allows calls to be
  197|       |  /// started from interceptors without infinite regress through the interceptor
  198|       |  /// list.
  199|       |  virtual std::unique_ptr<ChannelInterface> GetInterceptedChannel() = 0;
  200|       |
  201|       |  /// On a hijacked RPC, an interceptor can decide to fail a PRE_RECV_MESSAGE
  202|       |  /// op. This would be a signal to the reader that there will be no more
  203|       |  /// messages, or the stream has failed or been cancelled.
  204|       |  virtual void FailHijackedRecvMessage() = 0;
  205|       |
  206|       |  /// On a hijacked RPC/ to-be hijacked RPC, this can be called to fail a SEND
  207|       |  /// MESSAGE op
  208|       |  virtual void FailHijackedSendMessage() = 0;
  209|       |};
  210|       |
  211|       |/// Interface for an interceptor. Interceptor authors must create a class
  212|       |/// that derives from this parent class.
  213|       |class Interceptor {
  214|       | public:
  215|      0|  virtual ~Interceptor() {}
  216|       |
  217|       |  /// The one public method of an Interceptor interface. Override this to
  218|       |  /// trigger the desired actions at the hook points described above.
  219|       |  virtual void Intercept(InterceptorBatchMethods* methods) = 0;
  220|       |};
  221|       |
  222|       |}  // namespace experimental
  223|       |}  // namespace grpc
  224|       |
  225|       |#endif  // GRPCPP_IMPL_CODEGEN_INTERCEPTOR_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/interceptor_common.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_INTERCEPTOR_COMMON_H
   20|       |#define GRPCPP_IMPL_CODEGEN_INTERCEPTOR_COMMON_H
   21|       |
   22|       |#include <array>
   23|       |#include <functional>
   24|       |
   25|       |#include <grpcpp/impl/codegen/call.h>
   26|       |#include <grpcpp/impl/codegen/call_op_set_interface.h>
   27|       |#include <grpcpp/impl/codegen/client_interceptor.h>
   28|       |#include <grpcpp/impl/codegen/intercepted_channel.h>
   29|       |#include <grpcpp/impl/codegen/server_interceptor.h>
   30|       |
   31|       |#include <grpc/impl/codegen/grpc_types.h>
   32|       |
   33|       |namespace grpc {
   34|       |namespace internal {
   35|       |
   36|       |class InterceptorBatchMethodsImpl
   37|       |    : public experimental::InterceptorBatchMethods {
   38|       | public:
   39|      0|  InterceptorBatchMethodsImpl() {
   40|      0|    for (auto i = static_cast<experimental::InterceptionHookPoints>(0);
   41|      0|         i < experimental::InterceptionHookPoints::NUM_INTERCEPTION_HOOKS;
   42|      0|         i = static_cast<experimental::InterceptionHookPoints>(
   43|      0|             static_cast<size_t>(i) + 1)) {
   44|      0|      hooks_[static_cast<size_t>(i)] = false;
   45|      0|    }
   46|      0|  }
   47|       |
   48|      0|  ~InterceptorBatchMethodsImpl() {}
   49|       |
   50|       |  bool QueryInterceptionHookPoint(
   51|      0|      experimental::InterceptionHookPoints type) override {
   52|      0|    return hooks_[static_cast<size_t>(type)];
   53|      0|  }
   54|       |
   55|      0|  void Proceed() override {
   56|      0|    if (call_->client_rpc_info() != nullptr) {
   57|      0|      return ProceedClient();
   58|      0|    }
   59|      0|    GPR_CODEGEN_ASSERT(call_->server_rpc_info() != nullptr);
   60|      0|    ProceedServer();
   61|      0|  }
   62|       |
   63|      0|  void Hijack() override {
   64|      0|    // Only the client can hijack when sending down initial metadata
   65|      0|    GPR_CODEGEN_ASSERT(!reverse_ && ops_ != nullptr &&
   66|      0|                       call_->client_rpc_info() != nullptr);
   67|      0|    // It is illegal to call Hijack twice
   68|      0|    GPR_CODEGEN_ASSERT(!ran_hijacking_interceptor_);
   69|      0|    auto* rpc_info = call_->client_rpc_info();
   70|      0|    rpc_info->hijacked_ = true;
   71|      0|    rpc_info->hijacked_interceptor_ = current_interceptor_index_;
   72|      0|    ClearHookPoints();
   73|      0|    ops_->SetHijackingState();
   74|      0|    ran_hijacking_interceptor_ = true;
   75|      0|    rpc_info->RunInterceptor(this, current_interceptor_index_);
   76|      0|  }
   77|       |
   78|      0|  void AddInterceptionHookPoint(experimental::InterceptionHookPoints type) {
   79|      0|    hooks_[static_cast<size_t>(type)] = true;
   80|      0|  }
   81|       |
   82|      0|  ByteBuffer* GetSerializedSendMessage() override {
   83|      0|    GPR_CODEGEN_ASSERT(orig_send_message_ != nullptr);
   84|      0|    if (*orig_send_message_ != nullptr) {
   85|      0|      GPR_CODEGEN_ASSERT(serializer_(*orig_send_message_).ok());
   86|      0|      *orig_send_message_ = nullptr;
   87|      0|    }
   88|      0|    return send_message_;
   89|      0|  }
   90|       |
   91|      0|  const void* GetSendMessage() override {
   92|      0|    GPR_CODEGEN_ASSERT(orig_send_message_ != nullptr);
   93|      0|    return *orig_send_message_;
   94|      0|  }
   95|       |
   96|      0|  void ModifySendMessage(const void* message) override {
   97|      0|    GPR_CODEGEN_ASSERT(orig_send_message_ != nullptr);
   98|      0|    *orig_send_message_ = message;
   99|      0|  }
  100|       |
  101|      0|  bool GetSendMessageStatus() override { return !*fail_send_message_; }
  102|       |
  103|      0|  std::multimap<grpc::string, grpc::string>* GetSendInitialMetadata() override {
  104|      0|    return send_initial_metadata_;
  105|      0|  }
  106|       |
  107|      0|  Status GetSendStatus() override {
  108|      0|    return Status(static_cast<StatusCode>(*code_), *error_message_,
  109|      0|                  *error_details_);
  110|      0|  }
  111|       |
  112|      0|  void ModifySendStatus(const Status& status) override {
  113|      0|    *code_ = static_cast<grpc_status_code>(status.error_code());
  114|      0|    *error_details_ = status.error_details();
  115|      0|    *error_message_ = status.error_message();
  116|      0|  }
  117|       |
  118|       |  std::multimap<grpc::string, grpc::string>* GetSendTrailingMetadata()
  119|      0|      override {
  120|      0|    return send_trailing_metadata_;
  121|      0|  }
  122|       |
  123|      0|  void* GetRecvMessage() override { return recv_message_; }
  124|       |
  125|       |  std::multimap<grpc::string_ref, grpc::string_ref>* GetRecvInitialMetadata()
  126|      0|      override {
  127|      0|    return recv_initial_metadata_->map();
  128|      0|  }
  129|       |
  130|      0|  Status* GetRecvStatus() override { return recv_status_; }
  131|       |
  132|      0|  void FailHijackedSendMessage() override {
  133|      0|    GPR_CODEGEN_ASSERT(hooks_[static_cast<size_t>(
  134|      0|        experimental::InterceptionHookPoints::PRE_SEND_MESSAGE)]);
  135|      0|    *fail_send_message_ = true;
  136|      0|  }
  137|       |
  138|       |  std::multimap<grpc::string_ref, grpc::string_ref>* GetRecvTrailingMetadata()
  139|      0|      override {
  140|      0|    return recv_trailing_metadata_->map();
  141|      0|  }
  142|       |
  143|       |  void SetSendMessage(ByteBuffer* buf, const void** msg,
  144|       |                      bool* fail_send_message,
  145|      0|                      std::function<Status(const void*)> serializer) {
  146|      0|    send_message_ = buf;
  147|      0|    orig_send_message_ = msg;
  148|      0|    fail_send_message_ = fail_send_message;
  149|      0|    serializer_ = serializer;
  150|      0|  }
  151|       |
  152|       |  void SetSendInitialMetadata(
  153|      0|      std::multimap<grpc::string, grpc::string>* metadata) {
  154|      0|    send_initial_metadata_ = metadata;
  155|      0|  }
  156|       |
  157|       |  void SetSendStatus(grpc_status_code* code, grpc::string* error_details,
  158|      0|                     grpc::string* error_message) {
  159|      0|    code_ = code;
  160|      0|    error_details_ = error_details;
  161|      0|    error_message_ = error_message;
  162|      0|  }
  163|       |
  164|       |  void SetSendTrailingMetadata(
  165|      0|      std::multimap<grpc::string, grpc::string>* metadata) {
  166|      0|    send_trailing_metadata_ = metadata;
  167|      0|  }
  168|       |
  169|      0|  void SetRecvMessage(void* message, bool* got_message) {
  170|      0|    recv_message_ = message;
  171|      0|    got_message_ = got_message;
  172|      0|  }
  173|       |
  174|      0|  void SetRecvInitialMetadata(MetadataMap* map) {
  175|      0|    recv_initial_metadata_ = map;
  176|      0|  }
  177|       |
  178|      0|  void SetRecvStatus(Status* status) { recv_status_ = status; }
  179|       |
  180|      0|  void SetRecvTrailingMetadata(MetadataMap* map) {
  181|      0|    recv_trailing_metadata_ = map;
  182|      0|  }
  183|       |
  184|      0|  std::unique_ptr<ChannelInterface> GetInterceptedChannel() override {
  185|      0|    auto* info = call_->client_rpc_info();
  186|      0|    if (info == nullptr) {
  187|      0|      return std::unique_ptr<ChannelInterface>(nullptr);
  188|      0|    }
  189|      0|    // The intercepted channel starts from the interceptor just after the
  190|      0|    // current interceptor
  191|      0|    return std::unique_ptr<ChannelInterface>(new InterceptedChannel(
  192|      0|        info->channel(), current_interceptor_index_ + 1));
  193|      0|  }
  194|       |
  195|      0|  void FailHijackedRecvMessage() override {
  196|      0|    GPR_CODEGEN_ASSERT(hooks_[static_cast<size_t>(
  197|      0|        experimental::InterceptionHookPoints::PRE_RECV_MESSAGE)]);
  198|      0|    *got_message_ = false;
  199|      0|  }
  200|       |
  201|       |  // Clears all state
  202|      0|  void ClearState() {
  203|      0|    reverse_ = false;
  204|      0|    ran_hijacking_interceptor_ = false;
  205|      0|    ClearHookPoints();
  206|      0|  }
  207|       |
  208|       |  // Prepares for Post_recv operations
  209|      0|  void SetReverse() {
  210|      0|    reverse_ = true;
  211|      0|    ran_hijacking_interceptor_ = false;
  212|      0|    ClearHookPoints();
  213|      0|  }
  214|       |
  215|       |  // This needs to be set before interceptors are run
  216|      0|  void SetCall(Call* call) { call_ = call; }
  217|       |
  218|       |  // This needs to be set before interceptors are run using RunInterceptors().
  219|       |  // Alternatively, RunInterceptors(std::function<void(void)> f) can be used.
  220|      0|  void SetCallOpSetInterface(CallOpSetInterface* ops) { ops_ = ops; }
  221|       |
  222|       |  // SetCall should have been called before this.
  223|       |  // Returns true if the interceptors list is empty
  224|      0|  bool InterceptorsListEmpty() {
  225|      0|    auto* client_rpc_info = call_->client_rpc_info();
  226|      0|    if (client_rpc_info != nullptr) {
  227|      0|      if (client_rpc_info->interceptors_.size() == 0) {
  228|      0|        return true;
  229|      0|      } else {
  230|      0|        return false;
  231|      0|      }
  232|      0|    }
  233|      0|
  234|      0|    auto* server_rpc_info = call_->server_rpc_info();
  235|      0|    if (server_rpc_info == nullptr ||
  236|      0|        server_rpc_info->interceptors_.size() == 0) {
  237|      0|      return true;
  238|      0|    }
  239|      0|    return false;
  240|      0|  }
  241|       |
  242|       |  // This should be used only by subclasses of CallOpSetInterface. SetCall and
  243|       |  // SetCallOpSetInterface should have been called before this. After all the
  244|       |  // interceptors are done running, either ContinueFillOpsAfterInterception or
  245|       |  // ContinueFinalizeOpsAfterInterception will be called. Note that neither of
  246|       |  // them is invoked if there were no interceptors registered.
  247|      0|  bool RunInterceptors() {
  248|      0|    GPR_CODEGEN_ASSERT(ops_);
  249|      0|    auto* client_rpc_info = call_->client_rpc_info();
  250|      0|    if (client_rpc_info != nullptr) {
  251|      0|      if (client_rpc_info->interceptors_.size() == 0) {
  252|      0|        return true;
  253|      0|      } else {
  254|      0|        RunClientInterceptors();
  255|      0|        return false;
  256|      0|      }
  257|      0|    }
  258|      0|
  259|      0|    auto* server_rpc_info = call_->server_rpc_info();
  260|      0|    if (server_rpc_info == nullptr ||
  261|      0|        server_rpc_info->interceptors_.size() == 0) {
  262|      0|      return true;
  263|      0|    }
  264|      0|    RunServerInterceptors();
  265|      0|    return false;
  266|      0|  }
  267|       |
  268|       |  // Returns true if no interceptors are run. Returns false otherwise if there
  269|       |  // are interceptors registered. After the interceptors are done running \a f
  270|       |  // will be invoked. This is to be used only by BaseAsyncRequest and
  271|       |  // SyncRequest.
  272|      0|  bool RunInterceptors(std::function<void(void)> f) {
  273|      0|    // This is used only by the server for initial call request
  274|      0|    GPR_CODEGEN_ASSERT(reverse_ == true);
  275|      0|    GPR_CODEGEN_ASSERT(call_->client_rpc_info() == nullptr);
  276|      0|    auto* server_rpc_info = call_->server_rpc_info();
  277|      0|    if (server_rpc_info == nullptr ||
  278|      0|        server_rpc_info->interceptors_.size() == 0) {
  279|      0|      return true;
  280|      0|    }
  281|      0|    callback_ = std::move(f);
  282|      0|    RunServerInterceptors();
  283|      0|    return false;
  284|      0|  }
  285|       |
  286|       | private:
  287|      0|  void RunClientInterceptors() {
  288|      0|    auto* rpc_info = call_->client_rpc_info();
  289|      0|    if (!reverse_) {
  290|      0|      current_interceptor_index_ = 0;
  291|      0|    } else {
  292|      0|      if (rpc_info->hijacked_) {
  293|      0|        current_interceptor_index_ = rpc_info->hijacked_interceptor_;
  294|      0|      } else {
  295|      0|        current_interceptor_index_ = rpc_info->interceptors_.size() - 1;
  296|      0|      }
  297|      0|    }
  298|      0|    rpc_info->RunInterceptor(this, current_interceptor_index_);
  299|      0|  }
  300|       |
  301|      0|  void RunServerInterceptors() {
  302|      0|    auto* rpc_info = call_->server_rpc_info();
  303|      0|    if (!reverse_) {
  304|      0|      current_interceptor_index_ = 0;
  305|      0|    } else {
  306|      0|      current_interceptor_index_ = rpc_info->interceptors_.size() - 1;
  307|      0|    }
  308|      0|    rpc_info->RunInterceptor(this, current_interceptor_index_);
  309|      0|  }
  310|       |
  311|      0|  void ProceedClient() {
  312|      0|    auto* rpc_info = call_->client_rpc_info();
  313|      0|    if (rpc_info->hijacked_ && !reverse_ &&
  314|      0|        current_interceptor_index_ == rpc_info->hijacked_interceptor_ &&
  315|      0|        !ran_hijacking_interceptor_) {
  316|      0|      // We now need to provide hijacked recv ops to this interceptor
  317|      0|      ClearHookPoints();
  318|      0|      ops_->SetHijackingState();
  319|      0|      ran_hijacking_interceptor_ = true;
  320|      0|      rpc_info->RunInterceptor(this, current_interceptor_index_);
  321|      0|      return;
  322|      0|    }
  323|      0|    if (!reverse_) {
  324|      0|      current_interceptor_index_++;
  325|      0|      // We are going down the stack of interceptors
  326|      0|      if (current_interceptor_index_ < rpc_info->interceptors_.size()) {
  327|      0|        if (rpc_info->hijacked_ &&
  328|      0|            current_interceptor_index_ > rpc_info->hijacked_interceptor_) {
  329|      0|          // This is a hijacked RPC and we are done with hijacking
  330|      0|          ops_->ContinueFillOpsAfterInterception();
  331|      0|        } else {
  332|      0|          rpc_info->RunInterceptor(this, current_interceptor_index_);
  333|      0|        }
  334|      0|      } else {
  335|      0|        // we are done running all the interceptors without any hijacking
  336|      0|        ops_->ContinueFillOpsAfterInterception();
  337|      0|      }
  338|      0|    } else {
  339|      0|      // We are going up the stack of interceptors
  340|      0|      if (current_interceptor_index_ > 0) {
  341|      0|        // Continue running interceptors
  342|      0|        current_interceptor_index_--;
  343|      0|        rpc_info->RunInterceptor(this, current_interceptor_index_);
  344|      0|      } else {
  345|      0|        // we are done running all the interceptors without any hijacking
  346|      0|        ops_->ContinueFinalizeResultAfterInterception();
  347|      0|      }
  348|      0|    }
  349|      0|  }
  350|       |
  351|      0|  void ProceedServer() {
  352|      0|    auto* rpc_info = call_->server_rpc_info();
  353|      0|    if (!reverse_) {
  354|      0|      current_interceptor_index_++;
  355|      0|      if (current_interceptor_index_ < rpc_info->interceptors_.size()) {
  356|      0|        return rpc_info->RunInterceptor(this, current_interceptor_index_);
  357|      0|      } else if (ops_) {
  358|      0|        return ops_->ContinueFillOpsAfterInterception();
  359|      0|      }
  360|      0|    } else {
  361|      0|      // We are going up the stack of interceptors
  362|      0|      if (current_interceptor_index_ > 0) {
  363|      0|        // Continue running interceptors
  364|      0|        current_interceptor_index_--;
  365|      0|        return rpc_info->RunInterceptor(this, current_interceptor_index_);
  366|      0|      } else if (ops_) {
  367|      0|        return ops_->ContinueFinalizeResultAfterInterception();
  368|      0|      }
  369|      0|    }
  370|      0|    GPR_CODEGEN_ASSERT(callback_);
  371|      0|    callback_();
  372|      0|  }
  373|       |
  374|      0|  void ClearHookPoints() {
  375|      0|    for (auto i = static_cast<experimental::InterceptionHookPoints>(0);
  376|      0|         i < experimental::InterceptionHookPoints::NUM_INTERCEPTION_HOOKS;
  377|      0|         i = static_cast<experimental::InterceptionHookPoints>(
  378|      0|             static_cast<size_t>(i) + 1)) {
  379|      0|      hooks_[static_cast<size_t>(i)] = false;
  380|      0|    }
  381|      0|  }
  382|       |
  383|       |  std::array<bool,
  384|       |             static_cast<size_t>(
  385|       |                 experimental::InterceptionHookPoints::NUM_INTERCEPTION_HOOKS)>
  386|       |      hooks_;
  387|       |
  388|       |  size_t current_interceptor_index_ = 0;  // Current iterator
  389|       |  bool reverse_ = false;
  390|       |  bool ran_hijacking_interceptor_ = false;
  391|       |  Call* call_ = nullptr;  // The Call object is present along with CallOpSet
  392|       |                          // object/callback
  393|       |  CallOpSetInterface* ops_ = nullptr;
  394|       |  std::function<void(void)> callback_;
  395|       |
  396|       |  ByteBuffer* send_message_ = nullptr;
  397|       |  bool* fail_send_message_ = nullptr;
  398|       |  const void** orig_send_message_ = nullptr;
  399|       |  std::function<Status(const void*)> serializer_;
  400|       |
  401|       |  std::multimap<grpc::string, grpc::string>* send_initial_metadata_;
  402|       |
  403|       |  grpc_status_code* code_ = nullptr;
  404|       |  grpc::string* error_details_ = nullptr;
  405|       |  grpc::string* error_message_ = nullptr;
  406|       |
  407|       |  std::multimap<grpc::string, grpc::string>* send_trailing_metadata_ = nullptr;
  408|       |
  409|       |  void* recv_message_ = nullptr;
  410|       |  bool* got_message_ = nullptr;
  411|       |
  412|       |  MetadataMap* recv_initial_metadata_ = nullptr;
  413|       |
  414|       |  Status* recv_status_ = nullptr;
  415|       |
  416|       |  MetadataMap* recv_trailing_metadata_ = nullptr;
  417|       |};
  418|       |
  419|       |// A special implementation of InterceptorBatchMethods to send a Cancel
  420|       |// notification down the interceptor stack
  421|       |class CancelInterceptorBatchMethods
  422|       |    : public experimental::InterceptorBatchMethods {
  423|       | public:
  424|       |  bool QueryInterceptionHookPoint(
  425|      0|      experimental::InterceptionHookPoints type) override {
  426|      0|    if (type == experimental::InterceptionHookPoints::PRE_SEND_CANCEL) {
  427|      0|      return true;
  428|      0|    } else {
  429|      0|      return false;
  430|      0|    }
  431|      0|  }
  432|       |
  433|      0|  void Proceed() override {
  434|      0|    // This is a no-op. For actual continuation of the RPC simply needs to
  435|      0|    // return from the Intercept method
  436|      0|  }
  437|       |
  438|      0|  void Hijack() override {
  439|      0|    // Only the client can hijack when sending down initial metadata
  440|      0|    GPR_CODEGEN_ASSERT(false &&
  441|      0|                       "It is illegal to call Hijack on a method which has a "
  442|      0|                       "Cancel notification");
  443|      0|  }
  444|       |
  445|      0|  ByteBuffer* GetSerializedSendMessage() override {
  446|      0|    GPR_CODEGEN_ASSERT(false &&
  447|      0|                       "It is illegal to call GetSendMessage on a method which "
  448|      0|                       "has a Cancel notification");
  449|      0|    return nullptr;
  450|      0|  }
  451|       |
  452|      0|  bool GetSendMessageStatus() override {
  453|      0|    GPR_CODEGEN_ASSERT(
  454|      0|        false &&
  455|      0|        "It is illegal to call GetSendMessageStatus on a method which "
  456|      0|        "has a Cancel notification");
  457|      0|    return false;
  458|      0|  }
  459|       |
  460|      0|  const void* GetSendMessage() override {
  461|      0|    GPR_CODEGEN_ASSERT(
  462|      0|        false &&
  463|      0|        "It is illegal to call GetOriginalSendMessage on a method which "
  464|      0|        "has a Cancel notification");
  465|      0|    return nullptr;
  466|      0|  }
  467|       |
  468|      0|  void ModifySendMessage(const void* message) override {
  469|      0|    GPR_CODEGEN_ASSERT(
  470|      0|        false &&
  471|      0|        "It is illegal to call ModifySendMessage on a method which "
  472|      0|        "has a Cancel notification");
  473|      0|  }
  474|       |
  475|      0|  std::multimap<grpc::string, grpc::string>* GetSendInitialMetadata() override {
  476|      0|    GPR_CODEGEN_ASSERT(false &&
  477|      0|                       "It is illegal to call GetSendInitialMetadata on a "
  478|      0|                       "method which has a Cancel notification");
  479|      0|    return nullptr;
  480|      0|  }
  481|       |
  482|      0|  Status GetSendStatus() override {
  483|      0|    GPR_CODEGEN_ASSERT(false &&
  484|      0|                       "It is illegal to call GetSendStatus on a method which "
  485|      0|                       "has a Cancel notification");
  486|      0|    return Status();
  487|      0|  }
  488|       |
  489|      0|  void ModifySendStatus(const Status& status) override {
  490|      0|    GPR_CODEGEN_ASSERT(false &&
  491|      0|                       "It is illegal to call ModifySendStatus on a method "
  492|      0|                       "which has a Cancel notification");
  493|      0|    return;
  494|      0|  }
  495|       |
  496|       |  std::multimap<grpc::string, grpc::string>* GetSendTrailingMetadata()
  497|      0|      override {
  498|      0|    GPR_CODEGEN_ASSERT(false &&
  499|      0|                       "It is illegal to call GetSendTrailingMetadata on a "
  500|      0|                       "method which has a Cancel notification");
  501|      0|    return nullptr;
  502|      0|  }
  503|       |
  504|      0|  void* GetRecvMessage() override {
  505|      0|    GPR_CODEGEN_ASSERT(false &&
  506|      0|                       "It is illegal to call GetRecvMessage on a method which "
  507|      0|                       "has a Cancel notification");
  508|      0|    return nullptr;
  509|      0|  }
  510|       |
  511|       |  std::multimap<grpc::string_ref, grpc::string_ref>* GetRecvInitialMetadata()
  512|      0|      override {
  513|      0|    GPR_CODEGEN_ASSERT(false &&
  514|      0|                       "It is illegal to call GetRecvInitialMetadata on a "
  515|      0|                       "method which has a Cancel notification");
  516|      0|    return nullptr;
  517|      0|  }
  518|       |
  519|      0|  Status* GetRecvStatus() override {
  520|      0|    GPR_CODEGEN_ASSERT(false &&
  521|      0|                       "It is illegal to call GetRecvStatus on a method which "
  522|      0|                       "has a Cancel notification");
  523|      0|    return nullptr;
  524|      0|  }
  525|       |
  526|       |  std::multimap<grpc::string_ref, grpc::string_ref>* GetRecvTrailingMetadata()
  527|      0|      override {
  528|      0|    GPR_CODEGEN_ASSERT(false &&
  529|      0|                       "It is illegal to call GetRecvTrailingMetadata on a "
  530|      0|                       "method which has a Cancel notification");
  531|      0|    return nullptr;
  532|      0|  }
  533|       |
  534|      0|  std::unique_ptr<ChannelInterface> GetInterceptedChannel() override {
  535|      0|    GPR_CODEGEN_ASSERT(false &&
  536|      0|                       "It is illegal to call GetInterceptedChannel on a "
  537|      0|                       "method which has a Cancel notification");
  538|      0|    return std::unique_ptr<ChannelInterface>(nullptr);
  539|      0|  }
  540|       |
  541|      0|  void FailHijackedRecvMessage() override {
  542|      0|    GPR_CODEGEN_ASSERT(false &&
  543|      0|                       "It is illegal to call FailHijackedRecvMessage on a "
  544|      0|                       "method which has a Cancel notification");
  545|      0|  }
  546|       |
  547|      0|  void FailHijackedSendMessage() override {
  548|      0|    GPR_CODEGEN_ASSERT(false &&
  549|      0|                       "It is illegal to call FailHijackedSendMessage on a "
  550|      0|                       "method which has a Cancel notification");
  551|      0|  }
  552|       |};
  553|       |}  // namespace internal
  554|       |}  // namespace grpc
  555|       |
  556|       |#endif  // GRPCPP_IMPL_CODEGEN_INTERCEPTOR_COMMON_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/metadata_map.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_METADATA_MAP_H
   20|       |#define GRPCPP_IMPL_CODEGEN_METADATA_MAP_H
   21|       |
   22|       |#include <map>
   23|       |
   24|       |#include <grpc/impl/codegen/log.h>
   25|       |#include <grpcpp/impl/codegen/slice.h>
   26|       |
   27|       |namespace grpc {
   28|       |
   29|       |namespace internal {
   30|       |
   31|       |const char kBinaryErrorDetailsKey[] = "grpc-status-details-bin";
   32|       |
   33|       |class MetadataMap {
   34|       | public:
   35|      0|  MetadataMap() { Setup(); }
   36|       |
   37|      0|  ~MetadataMap() { Destroy(); }
   38|       |
   39|      0|  grpc::string GetBinaryErrorDetails() {
   40|      0|    // if filled_, extract from the multimap for O(log(n))
   41|      0|    if (filled_) {
   42|      0|      auto iter = map_.find(kBinaryErrorDetailsKey);
   43|      0|      if (iter != map_.end()) {
   44|      0|        return grpc::string(iter->second.begin(), iter->second.length());
   45|      0|      }
   46|      0|    }
   47|      0|    // if not yet filled, take the O(n) lookup to avoid allocating the
   48|      0|    // multimap until it is requested.
   49|      0|    // TODO(ncteisen): plumb this through core as a first class object, just
   50|      0|    // like code and message.
   51|      0|    else {
   52|      0|      for (size_t i = 0; i < arr_.count; i++) {
   53|      0|        if (strncmp(reinterpret_cast<const char*>(
   54|      0|                        GRPC_SLICE_START_PTR(arr_.metadata[i].key)),
   55|      0|                    kBinaryErrorDetailsKey,
   56|      0|                    GRPC_SLICE_LENGTH(arr_.metadata[i].key)) == 0) {
   57|      0|          return grpc::string(reinterpret_cast<const char*>(
   58|      0|                                  GRPC_SLICE_START_PTR(arr_.metadata[i].value)),
   59|      0|                              GRPC_SLICE_LENGTH(arr_.metadata[i].value));
   60|      0|        }
   61|      0|      }
   62|      0|    }
   63|      0|    return grpc::string();
   64|      0|  }
   65|       |
   66|      0|  std::multimap<grpc::string_ref, grpc::string_ref>* map() {
   67|      0|    FillMap();
   68|      0|    return &map_;
   69|      0|  }
   70|      0|  grpc_metadata_array* arr() { return &arr_; }
   71|       |
   72|      0|  void Reset() {
   73|      0|    filled_ = false;
   74|      0|    map_.clear();
   75|      0|    Destroy();
   76|      0|    Setup();
   77|      0|  }
   78|       |
   79|       | private:
   80|       |  bool filled_ = false;
   81|       |  grpc_metadata_array arr_;
   82|       |  std::multimap<grpc::string_ref, grpc::string_ref> map_;
   83|       |
   84|      0|  void Destroy() {
   85|      0|    g_core_codegen_interface->grpc_metadata_array_destroy(&arr_);
   86|      0|  }
   87|       |
   88|      0|  void Setup() { memset(&arr_, 0, sizeof(arr_)); }
   89|       |
   90|      0|  void FillMap() {
   91|      0|    if (filled_) return;
   92|      0|    filled_ = true;
   93|      0|    for (size_t i = 0; i < arr_.count; i++) {
   94|      0|      // TODO(yangg) handle duplicates?
   95|      0|      map_.insert(std::pair<grpc::string_ref, grpc::string_ref>(
   96|      0|          StringRefFromSlice(&arr_.metadata[i].key),
   97|      0|          StringRefFromSlice(&arr_.metadata[i].value)));
   98|      0|    }
   99|      0|  }
  100|       |};
  101|       |}  // namespace internal
  102|       |
  103|       |}  // namespace grpc
  104|       |
  105|       |#endif  // GRPCPP_IMPL_CODEGEN_METADATA_MAP_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/method_handler_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_METHOD_HANDLER_IMPL_H
   20|       |#define GRPCPP_IMPL_CODEGEN_METHOD_HANDLER_IMPL_H
   21|       |
   22|       |#include <grpcpp/impl/codegen/byte_buffer.h>
   23|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   24|       |#include <grpcpp/impl/codegen/rpc_service_method.h>
   25|       |#include <grpcpp/impl/codegen/sync_stream.h>
   26|       |
   27|       |namespace grpc {
   28|       |
   29|       |namespace internal {
   30|       |
   31|       |// Invoke the method handler, fill in the status, and
   32|       |// return whether or not we finished safely (without an exception).
   33|       |// Note that exception handling is 0-cost in most compiler/library
   34|       |// implementations (except when an exception is actually thrown),
   35|       |// so this process doesn't require additional overhead in the common case.
   36|       |// Additionally, we don't need to return if we caught an exception or not;
   37|       |// the handling is the same in either case.
   38|       |template <class Callable>
   39|       |Status CatchingFunctionHandler(Callable&& handler) {
   40|       |#if GRPC_ALLOW_EXCEPTIONS
   41|       |  try {
   42|       |    return handler();
   43|       |  } catch (...) {
   44|       |    return Status(StatusCode::UNKNOWN, "Unexpected error in RPC handling");
   45|       |  }
   46|       |#else   // GRPC_ALLOW_EXCEPTIONS
   47|       |  return handler();
   48|       |#endif  // GRPC_ALLOW_EXCEPTIONS
   49|       |}
   50|       |
   51|       |/// A wrapper class of an application provided rpc method handler.
   52|       |template <class ServiceType, class RequestType, class ResponseType>
   53|       |class RpcMethodHandler : public MethodHandler {
   54|       | public:
   55|       |  RpcMethodHandler(std::function<Status(ServiceType*, ServerContext*,
   56|       |                                        const RequestType*, ResponseType*)>
   57|       |                       func,
   58|       |                   ServiceType* service)
   59|       |      : func_(func), service_(service) {}
   60|       |
   61|       |  void RunHandler(const HandlerParameter& param) final {
   62|       |    ResponseType rsp;
   63|       |    Status status = param.status;
   64|       |    if (status.ok()) {
   65|       |      status = CatchingFunctionHandler([this, &param, &rsp] {
   66|       |        return func_(service_, param.server_context,
   67|       |                     static_cast<RequestType*>(param.request), &rsp);
   68|       |      });
   69|       |      static_cast<RequestType*>(param.request)->~RequestType();
   70|       |    }
   71|       |
   72|       |    GPR_CODEGEN_ASSERT(!param.server_context->sent_initial_metadata_);
   73|       |    CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage,
   74|       |              CallOpServerSendStatus>
   75|       |        ops;
   76|       |    ops.SendInitialMetadata(&param.server_context->initial_metadata_,
   77|       |                            param.server_context->initial_metadata_flags());
   78|       |    if (param.server_context->compression_level_set()) {
   79|       |      ops.set_compression_level(param.server_context->compression_level());
   80|       |    }
   81|       |    if (status.ok()) {
   82|       |      status = ops.SendMessagePtr(&rsp);
   83|       |    }
   84|       |    ops.ServerSendStatus(&param.server_context->trailing_metadata_, status);
   85|       |    param.call->PerformOps(&ops);
   86|       |    param.call->cq()->Pluck(&ops);
   87|       |  }
   88|       |
   89|       |  void* Deserialize(grpc_call* call, grpc_byte_buffer* req, Status* status,
   90|       |                    void** handler_data) final {
   91|       |    ByteBuffer buf;
   92|       |    buf.set_buffer(req);
   93|       |    auto* request = new (g_core_codegen_interface->grpc_call_arena_alloc(
   94|       |        call, sizeof(RequestType))) RequestType();
   95|       |    *status = SerializationTraits<RequestType>::Deserialize(&buf, request);
   96|       |    buf.Release();
   97|       |    if (status->ok()) {
   98|       |      return request;
   99|       |    }
  100|       |    request->~RequestType();
  101|       |    return nullptr;
  102|       |  }
  103|       |
  104|       | private:
  105|       |  /// Application provided rpc handler function.
  106|       |  std::function<Status(ServiceType*, ServerContext*, const RequestType*,
  107|       |                       ResponseType*)>
  108|       |      func_;
  109|       |  // The class the above handler function lives in.
  110|       |  ServiceType* service_;
  111|       |};
  112|       |
  113|       |/// A wrapper class of an application provided client streaming handler.
  114|       |template <class ServiceType, class RequestType, class ResponseType>
  115|       |class ClientStreamingHandler : public MethodHandler {
  116|       | public:
  117|       |  ClientStreamingHandler(
  118|       |      std::function<Status(ServiceType*, ServerContext*,
  119|       |                           ServerReader<RequestType>*, ResponseType*)>
  120|       |          func,
  121|       |      ServiceType* service)
  122|       |      : func_(func), service_(service) {}
  123|       |
  124|       |  void RunHandler(const HandlerParameter& param) final {
  125|       |    ServerReader<RequestType> reader(param.call, param.server_context);
  126|       |    ResponseType rsp;
  127|       |    Status status = CatchingFunctionHandler([this, &param, &reader, &rsp] {
  128|       |      return func_(service_, param.server_context, &reader, &rsp);
  129|       |    });
  130|       |
  131|       |    CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage,
  132|       |              CallOpServerSendStatus>
  133|       |        ops;
  134|       |    if (!param.server_context->sent_initial_metadata_) {
  135|       |      ops.SendInitialMetadata(&param.server_context->initial_metadata_,
  136|       |                              param.server_context->initial_metadata_flags());
  137|       |      if (param.server_context->compression_level_set()) {
  138|       |        ops.set_compression_level(param.server_context->compression_level());
  139|       |      }
  140|       |    }
  141|       |    if (status.ok()) {
  142|       |      status = ops.SendMessagePtr(&rsp);
  143|       |    }
  144|       |    ops.ServerSendStatus(&param.server_context->trailing_metadata_, status);
  145|       |    param.call->PerformOps(&ops);
  146|       |    param.call->cq()->Pluck(&ops);
  147|       |  }
  148|       |
  149|       | private:
  150|       |  std::function<Status(ServiceType*, ServerContext*, ServerReader<RequestType>*,
  151|       |                       ResponseType*)>
  152|       |      func_;
  153|       |  ServiceType* service_;
  154|       |};
  155|       |
  156|       |/// A wrapper class of an application provided server streaming handler.
  157|       |template <class ServiceType, class RequestType, class ResponseType>
  158|       |class ServerStreamingHandler : public MethodHandler {
  159|       | public:
  160|       |  ServerStreamingHandler(
  161|       |      std::function<Status(ServiceType*, ServerContext*, const RequestType*,
  162|       |                           ServerWriter<ResponseType>*)>
  163|       |          func,
  164|       |      ServiceType* service)
  165|       |      : func_(func), service_(service) {}
  166|       |
  167|       |  void RunHandler(const HandlerParameter& param) final {
  168|       |    Status status = param.status;
  169|       |    if (status.ok()) {
  170|       |      ServerWriter<ResponseType> writer(param.call, param.server_context);
  171|       |      status = CatchingFunctionHandler([this, &param, &writer] {
  172|       |        return func_(service_, param.server_context,
  173|       |                     static_cast<RequestType*>(param.request), &writer);
  174|       |      });
  175|       |      static_cast<RequestType*>(param.request)->~RequestType();
  176|       |    }
  177|       |
  178|       |    CallOpSet<CallOpSendInitialMetadata, CallOpServerSendStatus> ops;
  179|       |    if (!param.server_context->sent_initial_metadata_) {
  180|       |      ops.SendInitialMetadata(&param.server_context->initial_metadata_,
  181|       |                              param.server_context->initial_metadata_flags());
  182|       |      if (param.server_context->compression_level_set()) {
  183|       |        ops.set_compression_level(param.server_context->compression_level());
  184|       |      }
  185|       |    }
  186|       |    ops.ServerSendStatus(&param.server_context->trailing_metadata_, status);
  187|       |    param.call->PerformOps(&ops);
  188|       |    if (param.server_context->has_pending_ops_) {
  189|       |      param.call->cq()->Pluck(&param.server_context->pending_ops_);
  190|       |    }
  191|       |    param.call->cq()->Pluck(&ops);
  192|       |  }
  193|       |
  194|       |  void* Deserialize(grpc_call* call, grpc_byte_buffer* req, Status* status,
  195|       |                    void** handler_data) final {
  196|       |    ByteBuffer buf;
  197|       |    buf.set_buffer(req);
  198|       |    auto* request = new (g_core_codegen_interface->grpc_call_arena_alloc(
  199|       |        call, sizeof(RequestType))) RequestType();
  200|       |    *status = SerializationTraits<RequestType>::Deserialize(&buf, request);
  201|       |    buf.Release();
  202|       |    if (status->ok()) {
  203|       |      return request;
  204|       |    }
  205|       |    request->~RequestType();
  206|       |    return nullptr;
  207|       |  }
  208|       |
  209|       | private:
  210|       |  std::function<Status(ServiceType*, ServerContext*, const RequestType*,
  211|       |                       ServerWriter<ResponseType>*)>
  212|       |      func_;
  213|       |  ServiceType* service_;
  214|       |};
  215|       |
  216|       |/// A wrapper class of an application provided bidi-streaming handler.
  217|       |/// This also applies to server-streamed implementation of a unary method
  218|       |/// with the additional requirement that such methods must have done a
  219|       |/// write for status to be ok
  220|       |/// Since this is used by more than 1 class, the service is not passed in.
  221|       |/// Instead, it is expected to be an implicitly-captured argument of func
  222|       |/// (through bind or something along those lines)
  223|       |template <class Streamer, bool WriteNeeded>
  224|       |class TemplatedBidiStreamingHandler : public MethodHandler {
  225|       | public:
  226|       |  TemplatedBidiStreamingHandler(
  227|       |      std::function<Status(ServerContext*, Streamer*)> func)
  228|       |      : func_(func), write_needed_(WriteNeeded) {}
  229|       |
  230|       |  void RunHandler(const HandlerParameter& param) final {
  231|       |    Streamer stream(param.call, param.server_context);
  232|       |    Status status = CatchingFunctionHandler([this, &param, &stream] {
  233|       |      return func_(param.server_context, &stream);
  234|       |    });
  235|       |
  236|       |    CallOpSet<CallOpSendInitialMetadata, CallOpServerSendStatus> ops;
  237|       |    if (!param.server_context->sent_initial_metadata_) {
  238|       |      ops.SendInitialMetadata(&param.server_context->initial_metadata_,
  239|       |                              param.server_context->initial_metadata_flags());
  240|       |      if (param.server_context->compression_level_set()) {
  241|       |        ops.set_compression_level(param.server_context->compression_level());
  242|       |      }
  243|       |      if (write_needed_ && status.ok()) {
  244|       |        // If we needed a write but never did one, we need to mark the
  245|       |        // status as a fail
  246|       |        status = Status(StatusCode::INTERNAL,
  247|       |                        "Service did not provide response message");
  248|       |      }
  249|       |    }
  250|       |    ops.ServerSendStatus(&param.server_context->trailing_metadata_, status);
  251|       |    param.call->PerformOps(&ops);
  252|       |    if (param.server_context->has_pending_ops_) {
  253|       |      param.call->cq()->Pluck(&param.server_context->pending_ops_);
  254|       |    }
  255|       |    param.call->cq()->Pluck(&ops);
  256|       |  }
  257|       |
  258|       | private:
  259|       |  std::function<Status(ServerContext*, Streamer*)> func_;
  260|       |  const bool write_needed_;
  261|       |};
  262|       |
  263|       |template <class ServiceType, class RequestType, class ResponseType>
  264|       |class BidiStreamingHandler
  265|       |    : public TemplatedBidiStreamingHandler<
  266|       |          ServerReaderWriter<ResponseType, RequestType>, false> {
  267|       | public:
  268|       |  BidiStreamingHandler(
  269|       |      std::function<Status(ServiceType*, ServerContext*,
  270|       |                           ServerReaderWriter<ResponseType, RequestType>*)>
  271|       |          func,
  272|       |      ServiceType* service)
  273|       |      : TemplatedBidiStreamingHandler<
  274|       |            ServerReaderWriter<ResponseType, RequestType>, false>(std::bind(
  275|       |            func, service, std::placeholders::_1, std::placeholders::_2)) {}
  276|       |};
  277|       |
  278|       |template <class RequestType, class ResponseType>
  279|       |class StreamedUnaryHandler
  280|       |    : public TemplatedBidiStreamingHandler<
  281|       |          ServerUnaryStreamer<RequestType, ResponseType>, true> {
  282|       | public:
  283|       |  explicit StreamedUnaryHandler(
  284|       |      std::function<Status(ServerContext*,
  285|       |                           ServerUnaryStreamer<RequestType, ResponseType>*)>
  286|       |          func)
  287|       |      : TemplatedBidiStreamingHandler<
  288|       |            ServerUnaryStreamer<RequestType, ResponseType>, true>(func) {}
  289|       |};
  290|       |
  291|       |template <class RequestType, class ResponseType>
  292|       |class SplitServerStreamingHandler
  293|       |    : public TemplatedBidiStreamingHandler<
  294|       |          ServerSplitStreamer<RequestType, ResponseType>, false> {
  295|       | public:
  296|       |  explicit SplitServerStreamingHandler(
  297|       |      std::function<Status(ServerContext*,
  298|       |                           ServerSplitStreamer<RequestType, ResponseType>*)>
  299|       |          func)
  300|       |      : TemplatedBidiStreamingHandler<
  301|       |            ServerSplitStreamer<RequestType, ResponseType>, false>(func) {}
  302|       |};
  303|       |
  304|       |/// General method handler class for errors that prevent real method use
  305|       |/// e.g., handle unknown method by returning UNIMPLEMENTED error.
  306|       |template <StatusCode code>
  307|       |class ErrorMethodHandler : public MethodHandler {
  308|       | public:
  309|       |  template <class T>
  310|      0|  static void FillOps(ServerContext* context, T* ops) {
  311|      0|    Status status(code, "");
  312|      0|    if (!context->sent_initial_metadata_) {
  313|      0|      ops->SendInitialMetadata(&context->initial_metadata_,
  314|      0|                               context->initial_metadata_flags());
  315|      0|      if (context->compression_level_set()) {
  316|      0|        ops->set_compression_level(context->compression_level());
  317|      0|      }
  318|      0|      context->sent_initial_metadata_ = true;
  319|      0|    }
  320|      0|    ops->ServerSendStatus(&context->trailing_metadata_, status);
  321|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal18ErrorMethodHandlerILNS_10StatusCodeE12EE7FillOpsINS0_9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS8_ILi4EEENS8_ILi5EEENS8_ILi6EEEEEEEvPNS_13ServerContextEPT_
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal18ErrorMethodHandlerILNS_10StatusCodeE8EE7FillOpsINS0_9CallOpSetINS0_25CallOpSendInitialMetadataENS0_22CallOpServerSendStatusENS0_8CallNoOpILi3EEENS8_ILi4EEENS8_ILi5EEENS8_ILi6EEEEEEEvPNS_13ServerContextEPT_
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal18ErrorMethodHandlerILNS_10StatusCodeE12EE7FillOpsIN9grpc_impl6Server26UnimplementedAsyncResponseEEEvPNS_13ServerContextEPT_
  ------------------
  322|       |
  323|      0|  void RunHandler(const HandlerParameter& param) final {
  324|      0|    CallOpSet<CallOpSendInitialMetadata, CallOpServerSendStatus> ops;
  325|      0|    FillOps(param.server_context, &ops);
  326|      0|    param.call->PerformOps(&ops);
  327|      0|    param.call->cq()->Pluck(&ops);
  328|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal18ErrorMethodHandlerILNS_10StatusCodeE12EE10RunHandlerERKNS0_13MethodHandler16HandlerParameterE
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal18ErrorMethodHandlerILNS_10StatusCodeE8EE10RunHandlerERKNS0_13MethodHandler16HandlerParameterE
  ------------------
  329|       |
  330|       |  void* Deserialize(grpc_call* call, grpc_byte_buffer* req, Status* status,
  331|      0|                    void** handler_data) final {
  332|      0|    // We have to destroy any request payload
  333|      0|    if (req != nullptr) {
  334|      0|      g_core_codegen_interface->grpc_byte_buffer_destroy(req);
  335|      0|    }
  336|      0|    return nullptr;
  337|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal18ErrorMethodHandlerILNS_10StatusCodeE12EE11DeserializeEP9grpc_callP16grpc_byte_bufferPNS_6StatusEPPv
  ------------------
  | Unexecuted instantiation: _ZN4grpc8internal18ErrorMethodHandlerILNS_10StatusCodeE8EE11DeserializeEP9grpc_callP16grpc_byte_bufferPNS_6StatusEPPv
  ------------------
  338|       |};
  339|       |
  340|       |typedef ErrorMethodHandler<StatusCode::UNIMPLEMENTED> UnknownMethodHandler;
  341|       |typedef ErrorMethodHandler<StatusCode::RESOURCE_EXHAUSTED>
  342|       |    ResourceExhaustedHandler;
  343|       |
  344|       |}  // namespace internal
  345|       |}  // namespace grpc
  346|       |
  347|       |#endif  // GRPCPP_IMPL_CODEGEN_METHOD_HANDLER_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/rpc_method.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_RPC_METHOD_H
   20|       |#define GRPCPP_IMPL_CODEGEN_RPC_METHOD_H
   21|       |
   22|       |#include <memory>
   23|       |
   24|       |#include <grpcpp/impl/codegen/channel_interface.h>
   25|       |
   26|       |namespace grpc {
   27|       |namespace internal {
   28|       |/// Descriptor of an RPC method
   29|       |class RpcMethod {
   30|       | public:
   31|       |  enum RpcType {
   32|       |    NORMAL_RPC = 0,
   33|       |    CLIENT_STREAMING,  // request streaming
   34|       |    SERVER_STREAMING,  // response streaming
   35|       |    BIDI_STREAMING
   36|       |  };
   37|       |
   38|       |  RpcMethod(const char* name, RpcType type)
   39|      0|      : name_(name), method_type_(type), channel_tag_(NULL) {}
   40|       |
   41|       |  RpcMethod(const char* name, RpcType type,
   42|       |            const std::shared_ptr<ChannelInterface>& channel)
   43|       |      : name_(name),
   44|       |        method_type_(type),
   45|      0|        channel_tag_(channel->RegisterMethod(name)) {}
   46|       |
   47|      0|  const char* name() const { return name_; }
   48|      0|  RpcType method_type() const { return method_type_; }
   49|      0|  void SetMethodType(RpcType type) { method_type_ = type; }
   50|      0|  void* channel_tag() const { return channel_tag_; }
   51|       |
   52|       | private:
   53|       |  const char* const name_;
   54|       |  RpcType method_type_;
   55|       |  void* const channel_tag_;
   56|       |};
   57|       |
   58|       |}  // namespace internal
   59|       |}  // namespace grpc
   60|       |
   61|       |#endif  // GRPCPP_IMPL_CODEGEN_RPC_METHOD_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/rpc_service_method.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_RPC_SERVICE_METHOD_H
   20|       |#define GRPCPP_IMPL_CODEGEN_RPC_SERVICE_METHOD_H
   21|       |
   22|       |#include <climits>
   23|       |#include <functional>
   24|       |#include <map>
   25|       |#include <memory>
   26|       |#include <vector>
   27|       |
   28|       |#include <grpc/impl/codegen/log.h>
   29|       |#include <grpcpp/impl/codegen/byte_buffer.h>
   30|       |#include <grpcpp/impl/codegen/config.h>
   31|       |#include <grpcpp/impl/codegen/rpc_method.h>
   32|       |#include <grpcpp/impl/codegen/status.h>
   33|       |
   34|       |namespace grpc {
   35|       |class ServerContext;
   36|       |
   37|       |namespace internal {
   38|       |/// Base class for running an RPC handler.
   39|       |class MethodHandler {
   40|       | public:
   41|      0|  virtual ~MethodHandler() {}
   42|       |  struct HandlerParameter {
   43|       |    /// Constructor for HandlerParameter
   44|       |    ///
   45|       |    /// \param c : the gRPC Call structure for this server call
   46|       |    /// \param context : the ServerContext structure for this server call
   47|       |    /// \param req : the request payload, if appropriate for this RPC
   48|       |    /// \param req_status : the request status after any interceptors have run
   49|       |    /// \param handler_data: internal data for the handler.
   50|       |    /// \param requester : used only by the callback API. It is a function
   51|       |    ///        called by the RPC Controller to request another RPC (and also
   52|       |    ///        to set up the state required to make that request possible)
   53|       |    HandlerParameter(Call* c, ServerContext* context, void* req,
   54|       |                     Status req_status, void* handler_data,
   55|       |                     std::function<void()> requester)
   56|       |        : call(c),
   57|       |          server_context(context),
   58|       |          request(req),
   59|       |          status(req_status),
   60|       |          internal_data(handler_data),
   61|      0|          call_requester(std::move(requester)) {}
   62|      0|    ~HandlerParameter() {}
   63|       |    Call* call;
   64|       |    ServerContext* server_context;
   65|       |    void* request;
   66|       |    Status status;
   67|       |    void* internal_data;
   68|       |    std::function<void()> call_requester;
   69|       |  };
   70|       |  virtual void RunHandler(const HandlerParameter& param) = 0;
   71|       |
   72|       |  /* Returns a pointer to the deserialized request. \a status reflects the
   73|       |     result of deserialization. This pointer and the status should be filled in
   74|       |     a HandlerParameter and passed to RunHandler. It is illegal to access the
   75|       |     pointer after calling RunHandler. Ownership of the deserialized request is
   76|       |     retained by the handler. Returns nullptr if deserialization failed. */
   77|       |  virtual void* Deserialize(grpc_call* call, grpc_byte_buffer* req,
   78|      0|                            Status* status, void** handler_data) {
   79|      0|    GPR_CODEGEN_ASSERT(req == nullptr);
   80|      0|    return nullptr;
   81|      0|  }
   82|       |};
   83|       |
   84|       |/// Server side rpc method class
   85|       |class RpcServiceMethod : public RpcMethod {
   86|       | public:
   87|       |  /// Takes ownership of the handler
   88|       |  RpcServiceMethod(const char* name, RpcMethod::RpcType type,
   89|       |                   MethodHandler* handler)
   90|       |      : RpcMethod(name, type),
   91|       |        server_tag_(nullptr),
   92|       |        api_type_(ApiType::SYNC),
   93|      0|        handler_(handler) {}
   94|       |
   95|       |  enum class ApiType {
   96|       |    SYNC,
   97|       |    ASYNC,
   98|       |    RAW,
   99|       |    CALL_BACK,  // not CALLBACK because that is reserved in Windows
  100|       |    RAW_CALL_BACK,
  101|       |  };
  102|       |
  103|      0|  void set_server_tag(void* tag) { server_tag_ = tag; }
  104|      0|  void* server_tag() const { return server_tag_; }
  105|       |  /// if MethodHandler is nullptr, then this is an async method
  106|      0|  MethodHandler* handler() const { return handler_.get(); }
  107|      0|  ApiType api_type() const { return api_type_; }
  108|      0|  void SetHandler(MethodHandler* handler) { handler_.reset(handler); }
  109|      0|  void SetServerApiType(RpcServiceMethod::ApiType type) {
  110|      0|    if ((api_type_ == ApiType::SYNC) &&
  111|      0|        (type == ApiType::ASYNC || type == ApiType::RAW)) {
  112|      0|      // this marks this method as async
  113|      0|      handler_.reset();
  114|      0|    } else if (api_type_ != ApiType::SYNC) {
  115|      0|      // this is not an error condition, as it allows users to declare a server
  116|      0|      // like WithRawMethod_foo<AsyncService>. However since it
  117|      0|      // overwrites behavior, it should be logged.
  118|      0|      gpr_log(
  119|      0|          GPR_INFO,
  120|      0|          "You are marking method %s as '%s', even though it was "
  121|      0|          "previously marked '%s'. This behavior will overwrite the original "
  122|      0|          "behavior. If you expected this then ignore this message.",
  123|      0|          name(), TypeToString(api_type_), TypeToString(type));
  124|      0|    }
  125|      0|    api_type_ = type;
  126|      0|  }
  127|       |
  128|       | private:
  129|       |  void* server_tag_;
  130|       |  ApiType api_type_;
  131|       |  std::unique_ptr<MethodHandler> handler_;
  132|       |
  133|      0|  const char* TypeToString(RpcServiceMethod::ApiType type) {
  134|      0|    switch (type) {
  135|      0|      case ApiType::SYNC:
  136|      0|        return "sync";
  137|      0|      case ApiType::ASYNC:
  138|      0|        return "async";
  139|      0|      case ApiType::RAW:
  140|      0|        return "raw";
  141|      0|      case ApiType::CALL_BACK:
  142|      0|        return "callback";
  143|      0|      case ApiType::RAW_CALL_BACK:
  144|      0|        return "raw_callback";
  145|      0|      default:
  146|      0|        GPR_UNREACHABLE_CODE(return "unknown");
  147|      0|    }
  148|      0|  }
  149|       |};
  150|       |}  // namespace internal
  151|       |
  152|       |}  // namespace grpc
  153|       |
  154|       |#endif  // GRPCPP_IMPL_CODEGEN_RPC_SERVICE_METHOD_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/security/auth_context.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_SECURITY_AUTH_CONTEXT_H
   20|       |#define GRPCPP_IMPL_CODEGEN_SECURITY_AUTH_CONTEXT_H
   21|       |
   22|       |#include <iterator>
   23|       |#include <vector>
   24|       |
   25|       |#include <grpcpp/impl/codegen/config.h>
   26|       |#include <grpcpp/impl/codegen/string_ref.h>
   27|       |
   28|       |struct grpc_auth_context;
   29|       |struct grpc_auth_property;
   30|       |struct grpc_auth_property_iterator;
   31|       |
   32|       |namespace grpc {
   33|       |class SecureAuthContext;
   34|       |
   35|       |typedef std::pair<grpc::string_ref, grpc::string_ref> AuthProperty;
   36|       |
   37|       |class AuthPropertyIterator
   38|       |    : public std::iterator<std::input_iterator_tag, const AuthProperty> {
   39|       | public:
   40|       |  ~AuthPropertyIterator();
   41|       |  AuthPropertyIterator& operator++();
   42|       |  AuthPropertyIterator operator++(int);
   43|       |  bool operator==(const AuthPropertyIterator& rhs) const;
   44|       |  bool operator!=(const AuthPropertyIterator& rhs) const;
   45|       |  const AuthProperty operator*();
   46|       |
   47|       | protected:
   48|       |  AuthPropertyIterator();
   49|       |  AuthPropertyIterator(const grpc_auth_property* property,
   50|       |                       const grpc_auth_property_iterator* iter);
   51|       |
   52|       | private:
   53|       |  friend class SecureAuthContext;
   54|       |  const grpc_auth_property* property_;
   55|       |  // The following items form a grpc_auth_property_iterator.
   56|       |  const grpc_auth_context* ctx_;
   57|       |  size_t index_;
   58|       |  const char* name_;
   59|       |};
   60|       |
   61|       |/// Class encapsulating the Authentication Information.
   62|       |///
   63|       |/// It includes the secure identity of the peer, the type of secure transport
   64|       |/// used as well as any other properties required by the authorization layer.
   65|       |class AuthContext {
   66|       | public:
   67|      0|  virtual ~AuthContext() {}
   68|       |
   69|       |  /// Returns true if the peer is authenticated.
   70|       |  virtual bool IsPeerAuthenticated() const = 0;
   71|       |
   72|       |  /// A peer identity.
   73|       |  ///
   74|       |  /// It is, in general, comprised of one or more properties (in which case they
   75|       |  /// have the same name).
   76|       |  virtual std::vector<grpc::string_ref> GetPeerIdentity() const = 0;
   77|       |  virtual grpc::string GetPeerIdentityPropertyName() const = 0;
   78|       |
   79|       |  /// Returns all the property values with the given name.
   80|       |  virtual std::vector<grpc::string_ref> FindPropertyValues(
   81|       |      const grpc::string& name) const = 0;
   82|       |
   83|       |  /// Iteration over all the properties.
   84|       |  virtual AuthPropertyIterator begin() const = 0;
   85|       |  virtual AuthPropertyIterator end() const = 0;
   86|       |
   87|       |  /// Mutation functions: should only be used by an AuthMetadataProcessor.
   88|       |  virtual void AddProperty(const grpc::string& key,
   89|       |                           const grpc::string_ref& value) = 0;
   90|       |  virtual bool SetPeerIdentityPropertyName(const grpc::string& name) = 0;
   91|       |};
   92|       |
   93|       |}  // namespace grpc
   94|       |
   95|       |#endif  // GRPCPP_IMPL_CODEGEN_SECURITY_AUTH_CONTEXT_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/server_callback.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_SERVER_CALLBACK_H
   20|       |#define GRPCPP_IMPL_CODEGEN_SERVER_CALLBACK_H
   21|       |
   22|       |#include <atomic>
   23|       |#include <functional>
   24|       |#include <type_traits>
   25|       |
   26|       |#include <grpcpp/impl/codegen/call.h>
   27|       |#include <grpcpp/impl/codegen/call_op_set.h>
   28|       |#include <grpcpp/impl/codegen/callback_common.h>
   29|       |#include <grpcpp/impl/codegen/config.h>
   30|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   31|       |#include <grpcpp/impl/codegen/message_allocator.h>
   32|       |#include <grpcpp/impl/codegen/server_context.h>
   33|       |#include <grpcpp/impl/codegen/server_interface.h>
   34|       |#include <grpcpp/impl/codegen/status.h>
   35|       |
   36|       |namespace grpc {
   37|       |
   38|       |// Declare base class of all reactors as internal
   39|       |namespace internal {
   40|       |
   41|       |// Forward declarations
   42|       |template <class Request, class Response>
   43|       |class CallbackClientStreamingHandler;
   44|       |template <class Request, class Response>
   45|       |class CallbackServerStreamingHandler;
   46|       |template <class Request, class Response>
   47|       |class CallbackBidiHandler;
   48|       |
   49|       |class ServerReactor {
   50|       | public:
   51|      0|  virtual ~ServerReactor() = default;
   52|       |  virtual void OnDone() = 0;
   53|       |  virtual void OnCancel() = 0;
   54|       |
   55|       | private:
   56|       |  friend class ::grpc::ServerContext;
   57|       |  template <class Request, class Response>
   58|       |  friend class CallbackClientStreamingHandler;
   59|       |  template <class Request, class Response>
   60|       |  friend class CallbackServerStreamingHandler;
   61|       |  template <class Request, class Response>
   62|       |  friend class CallbackBidiHandler;
   63|       |
   64|       |  // The ServerReactor is responsible for tracking when it is safe to call
   65|       |  // OnCancel. This function should not be called until after OnStarted is done
   66|       |  // and the RPC has completed with a cancellation. This is tracked by counting
   67|       |  // how many of these conditions have been met and calling OnCancel when none
   68|       |  // remain unmet.
   69|       |
   70|      0|  void MaybeCallOnCancel() {
   71|      0|    if (on_cancel_conditions_remaining_.fetch_sub(
   72|      0|            1, std::memory_order_acq_rel) == 1) {
   73|      0|      OnCancel();
   74|      0|    }
   75|      0|  }
   76|       |
   77|       |  std::atomic_int on_cancel_conditions_remaining_{2};
   78|       |};
   79|       |
   80|       |}  // namespace internal
   81|       |
   82|       |namespace experimental {
   83|       |
   84|       |// Forward declarations
   85|       |template <class Request, class Response>
   86|       |class ServerReadReactor;
   87|       |template <class Request, class Response>
   88|       |class ServerWriteReactor;
   89|       |template <class Request, class Response>
   90|       |class ServerBidiReactor;
   91|       |
   92|       |// For unary RPCs, the exposed controller class is only an interface
   93|       |// and the actual implementation is an internal class.
   94|       |class ServerCallbackRpcController {
   95|       | public:
   96|       |  virtual ~ServerCallbackRpcController() = default;
   97|       |
   98|       |  // The method handler must call this function when it is done so that
   99|       |  // the library knows to free its resources
  100|       |  virtual void Finish(Status s) = 0;
  101|       |
  102|       |  // Allow the method handler to push out the initial metadata before
  103|       |  // the response and status are ready
  104|       |  virtual void SendInitialMetadata(std::function<void(bool)>) = 0;
  105|       |
  106|       |  /// SetCancelCallback passes in a callback to be called when the RPC is
  107|       |  /// canceled for whatever reason (streaming calls have OnCancel instead). This
  108|       |  /// is an advanced and uncommon use with several important restrictions. This
  109|       |  /// function may not be called more than once on the same RPC.
  110|       |  ///
  111|       |  /// If code calls SetCancelCallback on an RPC, it must also call
  112|       |  /// ClearCancelCallback before calling Finish on the RPC controller. That
  113|       |  /// method makes sure that no cancellation callback is executed for this RPC
  114|       |  /// beyond the point of its return. ClearCancelCallback may be called even if
  115|       |  /// SetCancelCallback was not called for this RPC, and it may be called
  116|       |  /// multiple times. It _must_ be called if SetCancelCallback was called for
  117|       |  /// this RPC.
  118|       |  ///
  119|       |  /// The callback should generally be lightweight and nonblocking and primarily
  120|       |  /// concerned with clearing application state related to the RPC or causing
  121|       |  /// operations (such as cancellations) to happen on dependent RPCs.
  122|       |  ///
  123|       |  /// If the RPC is already canceled at the time that SetCancelCallback is
  124|       |  /// called, the callback is invoked immediately.
  125|       |  ///
  126|       |  /// The cancellation callback may be executed concurrently with the method
  127|       |  /// handler that invokes it but will certainly not issue or execute after the
  128|       |  /// return of ClearCancelCallback. If ClearCancelCallback is invoked while the
  129|       |  /// callback is already executing, the callback will complete its execution
  130|       |  /// before ClearCancelCallback takes effect.
  131|       |  ///
  132|       |  /// To preserve the orderings described above, the callback may be called
  133|       |  /// under a lock that is also used for ClearCancelCallback and
  134|       |  /// ServerContext::IsCancelled, so the callback CANNOT call either of those
  135|       |  /// operations on this RPC or any other function that causes those operations
  136|       |  /// to be called before the callback completes.
  137|       |  virtual void SetCancelCallback(std::function<void()> callback) = 0;
  138|       |  virtual void ClearCancelCallback() = 0;
  139|       |
  140|       |  // NOTE: This is an API for advanced users who need custom allocators.
  141|       |  // Optionally deallocate request early to reduce the size of working set.
  142|       |  // A custom MessageAllocator needs to be registered to make use of this.
  143|       |  virtual void FreeRequest() = 0;
  144|       |  // NOTE: This is an API for advanced users who need custom allocators.
  145|       |  // Get and maybe mutate the allocator state associated with the current RPC.
  146|       |  virtual void* GetAllocatorState() = 0;
  147|       |};
  148|       |
  149|       |// NOTE: The actual streaming object classes are provided
  150|       |// as API only to support mocking. There are no implementations of
  151|       |// these class interfaces in the API.
  152|       |template <class Request>
  153|       |class ServerCallbackReader {
  154|       | public:
  155|       |  virtual ~ServerCallbackReader() {}
  156|       |  virtual void Finish(Status s) = 0;
  157|       |  virtual void SendInitialMetadata() = 0;
  158|       |  virtual void Read(Request* msg) = 0;
  159|       |
  160|       | protected:
  161|       |  template <class Response>
  162|       |  void BindReactor(ServerReadReactor<Request, Response>* reactor) {
  163|       |    reactor->BindReader(this);
  164|       |  }
  165|       |};
  166|       |
  167|       |template <class Response>
  168|       |class ServerCallbackWriter {
  169|       | public:
  170|       |  virtual ~ServerCallbackWriter() {}
  171|       |
  172|       |  virtual void Finish(Status s) = 0;
  173|       |  virtual void SendInitialMetadata() = 0;
  174|       |  virtual void Write(const Response* msg, WriteOptions options) = 0;
  175|       |  virtual void WriteAndFinish(const Response* msg, WriteOptions options,
  176|       |                              Status s) {
  177|       |    // Default implementation that can/should be overridden
  178|       |    Write(msg, std::move(options));
  179|       |    Finish(std::move(s));
  180|       |  }
  181|       |
  182|       | protected:
  183|       |  template <class Request>
  184|       |  void BindReactor(ServerWriteReactor<Request, Response>* reactor) {
  185|       |    reactor->BindWriter(this);
  186|       |  }
  187|       |};
  188|       |
  189|       |template <class Request, class Response>
  190|       |class ServerCallbackReaderWriter {
  191|       | public:
  192|      0|  virtual ~ServerCallbackReaderWriter() {}
  193|       |
  194|       |  virtual void Finish(Status s) = 0;
  195|       |  virtual void SendInitialMetadata() = 0;
  196|       |  virtual void Read(Request* msg) = 0;
  197|       |  virtual void Write(const Response* msg, WriteOptions options) = 0;
  198|       |  virtual void WriteAndFinish(const Response* msg, WriteOptions options,
  199|      0|                              Status s) {
  200|      0|    // Default implementation that can/should be overridden
  201|      0|    Write(msg, std::move(options));
  202|      0|    Finish(std::move(s));
  203|      0|  }
  204|       |
  205|       | protected:
  206|      0|  void BindReactor(ServerBidiReactor<Request, Response>* reactor) {
  207|      0|    reactor->BindStream(this);
  208|      0|  }
  209|       |};
  210|       |
  211|       |// The following classes are the reactor interfaces that are to be implemented
  212|       |// by the user, returned as the result of the method handler for a callback
  213|       |// method, and activated by the call to OnStarted. The library guarantees that
  214|       |// OnStarted will be called for any reactor that has been created using a
  215|       |// method handler registered on a service. No operation initiation method may be
  216|       |// called until after the call to OnStarted.
  217|       |// Note that none of the classes are pure; all reactions have a default empty
  218|       |// reaction so that the user class only needs to override those classes that it
  219|       |// cares about.
  220|       |
  221|       |/// \a ServerBidiReactor is the interface for a bidirectional streaming RPC.
  222|       |template <class Request, class Response>
  223|       |class ServerBidiReactor : public internal::ServerReactor {
  224|       | public:
  225|      0|  ~ServerBidiReactor() = default;
  226|       |
  227|       |  /// Do NOT call any operation initiation method (names that start with Start)
  228|       |  /// until after the library has called OnStarted on this object.
  229|       |
  230|       |  /// Send any initial metadata stored in the RPC context. If not invoked,
  231|       |  /// any initial metadata will be passed along with the first Write or the
  232|       |  /// Finish (if there are no writes).
  233|       |  void StartSendInitialMetadata() { stream_->SendInitialMetadata(); }
  234|       |
  235|       |  /// Initiate a read operation.
  236|       |  ///
  237|       |  /// \param[out] req Where to eventually store the read message. Valid when
  238|       |  ///                 the library calls OnReadDone
  239|       |  void StartRead(Request* req) { stream_->Read(req); }
  240|       |
  241|       |  /// Initiate a write operation.
  242|       |  ///
  243|       |  /// \param[in] resp The message to be written. The library takes temporary
  244|       |  ///                 ownership until OnWriteDone, at which point the
  245|       |  ///                 application regains ownership of resp.
  246|       |  void StartWrite(const Response* resp) { StartWrite(resp, WriteOptions()); }
  247|       |
  248|       |  /// Initiate a write operation with specified options.
  249|       |  ///
  250|       |  /// \param[in] resp The message to be written. The library takes temporary
  251|       |  ///                 ownership until OnWriteDone, at which point the
  252|       |  ///                 application regains ownership of resp.
  253|       |  /// \param[in] options The WriteOptions to use for writing this message
  254|       |  void StartWrite(const Response* resp, WriteOptions options) {
  255|       |    stream_->Write(resp, std::move(options));
  256|       |  }
  257|       |
  258|       |  /// Initiate a write operation with specified options and final RPC Status,
  259|       |  /// which also causes any trailing metadata for this RPC to be sent out.
  260|       |  /// StartWriteAndFinish is like merging StartWriteLast and Finish into a
  261|       |  /// single step. A key difference, though, is that this operation doesn't have
  262|       |  /// an OnWriteDone reaction - it is considered complete only when OnDone is
  263|       |  /// available. An RPC can either have StartWriteAndFinish or Finish, but not
  264|       |  /// both.
  265|       |  ///
  266|       |  /// \param[in] resp The message to be written. The library takes temporary
  267|       |  ///                 ownership until Onone, at which point the application
  268|       |  ///                 regains ownership of resp.
  269|       |  /// \param[in] options The WriteOptions to use for writing this message
  270|       |  /// \param[in] s The status outcome of this RPC
  271|       |  void StartWriteAndFinish(const Response* resp, WriteOptions options,
  272|       |                           Status s) {
  273|       |    stream_->WriteAndFinish(resp, std::move(options), std::move(s));
  274|       |  }
  275|       |
  276|       |  /// Inform system of a planned write operation with specified options, but
  277|       |  /// allow the library to schedule the actual write coalesced with the writing
  278|       |  /// of trailing metadata (which takes place on a Finish call).
  279|       |  ///
  280|       |  /// \param[in] resp The message to be written. The library takes temporary
  281|       |  ///                 ownership until OnWriteDone, at which point the
  282|       |  ///                 application regains ownership of resp.
  283|       |  /// \param[in] options The WriteOptions to use for writing this message
  284|       |  void StartWriteLast(const Response* resp, WriteOptions options) {
  285|       |    StartWrite(resp, std::move(options.set_last_message()));
  286|       |  }
  287|       |
  288|       |  /// Indicate that the stream is to be finished and the trailing metadata and
  289|       |  /// RPC status are to be sent. Every RPC MUST be finished using either Finish
  290|       |  /// or StartWriteAndFinish (but not both), even if the RPC is already
  291|       |  /// cancelled.
  292|       |  ///
  293|       |  /// \param[in] s The status outcome of this RPC
  294|      0|  void Finish(Status s) { stream_->Finish(std::move(s)); }
  295|       |
  296|       |  /// Notify the application that a streaming RPC has started and that it is now
  297|       |  /// ok to call any operation initiation method. An RPC is considered started
  298|       |  /// after the server has received all initial metadata from the client, which
  299|       |  /// is a result of the client calling StartCall().
  300|       |  ///
  301|       |  /// \param[in] context The context object now associated with this RPC
  302|      0|  virtual void OnStarted(ServerContext* context) {}
  303|       |
  304|       |  /// Notifies the application that an explicit StartSendInitialMetadata
  305|       |  /// operation completed. Not used when the sending of initial metadata
  306|       |  /// piggybacks onto the first write.
  307|       |  ///
  308|       |  /// \param[in] ok Was it successful? If false, no further write-side operation
  309|       |  ///               will succeed.
  310|      0|  virtual void OnSendInitialMetadataDone(bool ok) {}
  311|       |
  312|       |  /// Notifies the application that a StartRead operation completed.
  313|       |  ///
  314|       |  /// \param[in] ok Was it successful? If false, no further read-side operation
  315|       |  ///               will succeed.
  316|      0|  virtual void OnReadDone(bool ok) {}
  317|       |
  318|       |  /// Notifies the application that a StartWrite (or StartWriteLast) operation
  319|       |  /// completed.
  320|       |  ///
  321|       |  /// \param[in] ok Was it successful? If false, no further write-side operation
  322|       |  ///               will succeed.
  323|      0|  virtual void OnWriteDone(bool ok) {}
  324|       |
  325|       |  /// Notifies the application that all operations associated with this RPC
  326|       |  /// have completed. This is an override (from the internal base class) but not
  327|       |  /// final, so derived classes should override it if they want to take action.
  328|      0|  void OnDone() override {}
  329|       |
  330|       |  /// Notifies the application that this RPC has been cancelled. This is an
  331|       |  /// override (from the internal base class) but not final, so derived classes
  332|       |  /// should override it if they want to take action.
  333|      0|  void OnCancel() override {}
  334|       |
  335|       | private:
  336|       |  friend class ServerCallbackReaderWriter<Request, Response>;
  337|      0|  void BindStream(ServerCallbackReaderWriter<Request, Response>* stream) {
  338|      0|    stream_ = stream;
  339|      0|  }
  340|       |
  341|       |  ServerCallbackReaderWriter<Request, Response>* stream_;
  342|       |};
  343|       |
  344|       |/// \a ServerReadReactor is the interface for a client-streaming RPC.
  345|       |template <class Request, class Response>
  346|       |class ServerReadReactor : public internal::ServerReactor {
  347|       | public:
  348|       |  ~ServerReadReactor() = default;
  349|       |
  350|       |  /// The following operation initiations are exactly like ServerBidiReactor.
  351|       |  void StartSendInitialMetadata() { reader_->SendInitialMetadata(); }
  352|       |  void StartRead(Request* req) { reader_->Read(req); }
  353|       |  void Finish(Status s) { reader_->Finish(std::move(s)); }
  354|       |
  355|       |  /// Similar to ServerBidiReactor::OnStarted, except that this also provides
  356|       |  /// the response object that the stream fills in before calling Finish.
  357|       |  /// (It must be filled in if status is OK, but it may be filled in otherwise.)
  358|       |  ///
  359|       |  /// \param[in] context The context object now associated with this RPC
  360|       |  /// \param[in] resp The response object to be used by this RPC
  361|       |  virtual void OnStarted(ServerContext* context, Response* resp) {}
  362|       |
  363|       |  /// The following notifications are exactly like ServerBidiReactor.
  364|       |  virtual void OnSendInitialMetadataDone(bool ok) {}
  365|       |  virtual void OnReadDone(bool ok) {}
  366|       |  void OnDone() override {}
  367|       |  void OnCancel() override {}
  368|       |
  369|       | private:
  370|       |  friend class ServerCallbackReader<Request>;
  371|       |  void BindReader(ServerCallbackReader<Request>* reader) { reader_ = reader; }
  372|       |
  373|       |  ServerCallbackReader<Request>* reader_;
  374|       |};
  375|       |
  376|       |/// \a ServerWriteReactor is the interface for a server-streaming RPC.
  377|       |template <class Request, class Response>
  378|       |class ServerWriteReactor : public internal::ServerReactor {
  379|       | public:
  380|       |  ~ServerWriteReactor() = default;
  381|       |
  382|       |  /// The following operation initiations are exactly like ServerBidiReactor.
  383|       |  void StartSendInitialMetadata() { writer_->SendInitialMetadata(); }
  384|       |  void StartWrite(const Response* resp) { StartWrite(resp, WriteOptions()); }
  385|       |  void StartWrite(const Response* resp, WriteOptions options) {
  386|       |    writer_->Write(resp, std::move(options));
  387|       |  }
  388|       |  void StartWriteAndFinish(const Response* resp, WriteOptions options,
  389|       |                           Status s) {
  390|       |    writer_->WriteAndFinish(resp, std::move(options), std::move(s));
  391|       |  }
  392|       |  void StartWriteLast(const Response* resp, WriteOptions options) {
  393|       |    StartWrite(resp, std::move(options.set_last_message()));
  394|       |  }
  395|       |  void Finish(Status s) { writer_->Finish(std::move(s)); }
  396|       |
  397|       |  /// Similar to ServerBidiReactor::OnStarted, except that this also provides
  398|       |  /// the request object sent by the client.
  399|       |  ///
  400|       |  /// \param[in] context The context object now associated with this RPC
  401|       |  /// \param[in] req The request object sent by the client
  402|       |  virtual void OnStarted(ServerContext* context, const Request* req) {}
  403|       |
  404|       |  /// The following notifications are exactly like ServerBidiReactor.
  405|       |  virtual void OnSendInitialMetadataDone(bool ok) {}
  406|       |  virtual void OnWriteDone(bool ok) {}
  407|       |  void OnDone() override {}
  408|       |  void OnCancel() override {}
  409|       |
  410|       | private:
  411|       |  friend class ServerCallbackWriter<Response>;
  412|       |  void BindWriter(ServerCallbackWriter<Response>* writer) { writer_ = writer; }
  413|       |
  414|       |  ServerCallbackWriter<Response>* writer_;
  415|       |};
  416|       |
  417|       |}  // namespace experimental
  418|       |
  419|       |namespace internal {
  420|       |
  421|       |template <class Request, class Response>
  422|       |class UnimplementedReadReactor
  423|       |    : public experimental::ServerReadReactor<Request, Response> {
  424|       | public:
  425|       |  void OnDone() override { delete this; }
  426|       |  void OnStarted(ServerContext*, Response*) override {
  427|       |    this->Finish(Status(StatusCode::UNIMPLEMENTED, ""));
  428|       |  }
  429|       |};
  430|       |
  431|       |template <class Request, class Response>
  432|       |class UnimplementedWriteReactor
  433|       |    : public experimental::ServerWriteReactor<Request, Response> {
  434|       | public:
  435|       |  void OnDone() override { delete this; }
  436|       |  void OnStarted(ServerContext*, const Request*) override {
  437|       |    this->Finish(Status(StatusCode::UNIMPLEMENTED, ""));
  438|       |  }
  439|       |};
  440|       |
  441|       |template <class Request, class Response>
  442|       |class UnimplementedBidiReactor
  443|       |    : public experimental::ServerBidiReactor<Request, Response> {
  444|       | public:
  445|      0|  void OnDone() override { delete this; }
  446|      0|  void OnStarted(ServerContext*) override {
  447|      0|    this->Finish(Status(StatusCode::UNIMPLEMENTED, ""));
  448|      0|  }
  449|       |};
  450|       |
  451|       |template <class RequestType, class ResponseType>
  452|       |class CallbackUnaryHandler : public MethodHandler {
  453|       | public:
  454|       |  CallbackUnaryHandler(
  455|       |      std::function<void(ServerContext*, const RequestType*, ResponseType*,
  456|       |                         experimental::ServerCallbackRpcController*)>
  457|       |          func)
  458|       |      : func_(func) {}
  459|       |
  460|       |  void SetMessageAllocator(
  461|       |      experimental::MessageAllocator<RequestType, ResponseType>* allocator) {
  462|       |    allocator_ = allocator;
  463|       |  }
  464|       |
  465|       |  void RunHandler(const HandlerParameter& param) final {
  466|       |    // Arena allocate a controller structure (that includes request/response)
  467|       |    g_core_codegen_interface->grpc_call_ref(param.call->call());
  468|       |    auto* allocator_info =
  469|       |        static_cast<experimental::RpcAllocatorInfo<RequestType, ResponseType>*>(
  470|       |            param.internal_data);
  471|       |    auto* controller = new (g_core_codegen_interface->grpc_call_arena_alloc(
  472|       |        param.call->call(), sizeof(ServerCallbackRpcControllerImpl)))
  473|       |        ServerCallbackRpcControllerImpl(param.server_context, param.call,
  474|       |                                        allocator_info, allocator_,
  475|       |                                        std::move(param.call_requester));
  476|       |    Status status = param.status;
  477|       |    if (status.ok()) {
  478|       |      // Call the actual function handler and expect the user to call finish
  479|       |      CatchingCallback(func_, param.server_context, controller->request(),
  480|       |                       controller->response(), controller);
  481|       |    } else {
  482|       |      // if deserialization failed, we need to fail the call
  483|       |      controller->Finish(status);
  484|       |    }
  485|       |  }
  486|       |
  487|       |  void* Deserialize(grpc_call* call, grpc_byte_buffer* req, Status* status,
  488|       |                    void** handler_data) final {
  489|       |    ByteBuffer buf;
  490|       |    buf.set_buffer(req);
  491|       |    RequestType* request = nullptr;
  492|       |    experimental::RpcAllocatorInfo<RequestType, ResponseType>* allocator_info =
  493|       |        new (g_core_codegen_interface->grpc_call_arena_alloc(
  494|       |            call, sizeof(*allocator_info)))
  495|       |            experimental::RpcAllocatorInfo<RequestType, ResponseType>();
  496|       |    if (allocator_ != nullptr) {
  497|       |      allocator_->AllocateMessages(allocator_info);
  498|       |    } else {
  499|       |      allocator_info->request =
  500|       |          new (g_core_codegen_interface->grpc_call_arena_alloc(
  501|       |              call, sizeof(RequestType))) RequestType();
  502|       |      allocator_info->response =
  503|       |          new (g_core_codegen_interface->grpc_call_arena_alloc(
  504|       |              call, sizeof(ResponseType))) ResponseType();
  505|       |    }
  506|       |    *handler_data = allocator_info;
  507|       |    request = allocator_info->request;
  508|       |    *status = SerializationTraits<RequestType>::Deserialize(&buf, request);
  509|       |    buf.Release();
  510|       |    if (status->ok()) {
  511|       |      return request;
  512|       |    }
  513|       |    // Clean up on deserialization failure.
  514|       |    if (allocator_ != nullptr) {
  515|       |      allocator_->DeallocateMessages(allocator_info);
  516|       |    } else {
  517|       |      allocator_info->request->~RequestType();
  518|       |      allocator_info->response->~ResponseType();
  519|       |      allocator_info->request = nullptr;
  520|       |      allocator_info->response = nullptr;
  521|       |    }
  522|       |    return nullptr;
  523|       |  }
  524|       |
  525|       | private:
  526|       |  std::function<void(ServerContext*, const RequestType*, ResponseType*,
  527|       |                     experimental::ServerCallbackRpcController*)>
  528|       |      func_;
  529|       |  experimental::MessageAllocator<RequestType, ResponseType>* allocator_ =
  530|       |      nullptr;
  531|       |
  532|       |  // The implementation class of ServerCallbackRpcController is a private member
  533|       |  // of CallbackUnaryHandler since it is never exposed anywhere, and this allows
  534|       |  // it to take advantage of CallbackUnaryHandler's friendships.
  535|       |  class ServerCallbackRpcControllerImpl
  536|       |      : public experimental::ServerCallbackRpcController {
  537|       |   public:
  538|       |    void Finish(Status s) override {
  539|       |      finish_tag_.Set(call_.call(), [this](bool) { MaybeDone(); },
  540|       |                      &finish_ops_);
  541|       |      if (!ctx_->sent_initial_metadata_) {
  542|       |        finish_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  543|       |                                        ctx_->initial_metadata_flags());
  544|       |        if (ctx_->compression_level_set()) {
  545|       |          finish_ops_.set_compression_level(ctx_->compression_level());
  546|       |        }
  547|       |        ctx_->sent_initial_metadata_ = true;
  548|       |      }
  549|       |      // The response is dropped if the status is not OK.
  550|       |      if (s.ok()) {
  551|       |        finish_ops_.ServerSendStatus(
  552|       |            &ctx_->trailing_metadata_,
  553|       |            finish_ops_.SendMessagePtr(allocator_info_->response));
  554|       |      } else {
  555|       |        finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_, s);
  556|       |      }
  557|       |      finish_ops_.set_core_cq_tag(&finish_tag_);
  558|       |      call_.PerformOps(&finish_ops_);
  559|       |    }
  560|       |
  561|       |    void SendInitialMetadata(std::function<void(bool)> f) override {
  562|       |      GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
  563|       |      callbacks_outstanding_++;
  564|       |      // TODO(vjpai): Consider taking f as a move-capture if we adopt C++14
  565|       |      //              and if performance of this operation matters
  566|       |      meta_tag_.Set(call_.call(),
  567|       |                    [this, f](bool ok) {
  568|       |                      f(ok);
  569|       |                      MaybeDone();
  570|       |                    },
  571|       |                    &meta_ops_);
  572|       |      meta_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  573|       |                                    ctx_->initial_metadata_flags());
  574|       |      if (ctx_->compression_level_set()) {
  575|       |        meta_ops_.set_compression_level(ctx_->compression_level());
  576|       |      }
  577|       |      ctx_->sent_initial_metadata_ = true;
  578|       |      meta_ops_.set_core_cq_tag(&meta_tag_);
  579|       |      call_.PerformOps(&meta_ops_);
  580|       |    }
  581|       |
  582|       |    // Neither SetCancelCallback nor ClearCancelCallback should affect the
  583|       |    // callbacks_outstanding_ count since they are paired and both must precede
  584|       |    // the invocation of Finish (if they are used at all)
  585|       |    void SetCancelCallback(std::function<void()> callback) override {
  586|       |      ctx_->SetCancelCallback(std::move(callback));
  587|       |    }
  588|       |
  589|       |    void ClearCancelCallback() override { ctx_->ClearCancelCallback(); }
  590|       |
  591|       |    void FreeRequest() override {
  592|       |      if (allocator_ != nullptr) {
  593|       |        allocator_->DeallocateRequest(allocator_info_);
  594|       |      }
  595|       |    }
  596|       |
  597|       |    void* GetAllocatorState() override {
  598|       |      return allocator_info_->allocator_state;
  599|       |    }
  600|       |
  601|       |   private:
  602|       |    friend class CallbackUnaryHandler<RequestType, ResponseType>;
  603|       |
  604|       |    ServerCallbackRpcControllerImpl(
  605|       |        ServerContext* ctx, Call* call,
  606|       |        experimental::RpcAllocatorInfo<RequestType, ResponseType>*
  607|       |            allocator_info,
  608|       |        experimental::MessageAllocator<RequestType, ResponseType>* allocator,
  609|       |        std::function<void()> call_requester)
  610|       |        : ctx_(ctx),
  611|       |          call_(*call),
  612|       |          allocator_info_(allocator_info),
  613|       |          allocator_(allocator),
  614|       |          call_requester_(std::move(call_requester)) {
  615|       |      ctx_->BeginCompletionOp(call, [this](bool) { MaybeDone(); }, nullptr);
  616|       |    }
  617|       |
  618|       |    const RequestType* request() { return allocator_info_->request; }
  619|       |    ResponseType* response() { return allocator_info_->response; }
  620|       |
  621|       |    void MaybeDone() {
  622|       |      if (--callbacks_outstanding_ == 0) {
  623|       |        grpc_call* call = call_.call();
  624|       |        auto call_requester = std::move(call_requester_);
  625|       |        if (allocator_ != nullptr) {
  626|       |          allocator_->DeallocateMessages(allocator_info_);
  627|       |        } else {
  628|       |          if (allocator_info_->request != nullptr) {
  629|       |            allocator_info_->request->~RequestType();
  630|       |          }
  631|       |          if (allocator_info_->response != nullptr) {
  632|       |            allocator_info_->response->~ResponseType();
  633|       |          }
  634|       |        }
  635|       |        this->~ServerCallbackRpcControllerImpl();  // explicitly call destructor
  636|       |        g_core_codegen_interface->grpc_call_unref(call);
  637|       |        call_requester();
  638|       |      }
  639|       |    }
  640|       |
  641|       |    CallOpSet<CallOpSendInitialMetadata> meta_ops_;
  642|       |    CallbackWithSuccessTag meta_tag_;
  643|       |    CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage,
  644|       |              CallOpServerSendStatus>
  645|       |        finish_ops_;
  646|       |    CallbackWithSuccessTag finish_tag_;
  647|       |
  648|       |    ServerContext* ctx_;
  649|       |    Call call_;
  650|       |    experimental::RpcAllocatorInfo<RequestType, ResponseType>* allocator_info_;
  651|       |    experimental::MessageAllocator<RequestType, ResponseType>* allocator_;
  652|       |    std::function<void()> call_requester_;
  653|       |    std::atomic_int callbacks_outstanding_{
  654|       |        2};  // reserve for Finish and CompletionOp
  655|       |  };
  656|       |};
  657|       |
  658|       |template <class RequestType, class ResponseType>
  659|       |class CallbackClientStreamingHandler : public MethodHandler {
  660|       | public:
  661|       |  CallbackClientStreamingHandler(
  662|       |      std::function<
  663|       |          experimental::ServerReadReactor<RequestType, ResponseType>*()>
  664|       |          func)
  665|       |      : func_(std::move(func)) {}
  666|       |  void RunHandler(const HandlerParameter& param) final {
  667|       |    // Arena allocate a reader structure (that includes response)
  668|       |    g_core_codegen_interface->grpc_call_ref(param.call->call());
  669|       |
  670|       |    experimental::ServerReadReactor<RequestType, ResponseType>* reactor =
  671|       |        param.status.ok()
  672|       |            ? CatchingReactorCreator<
  673|       |                  experimental::ServerReadReactor<RequestType, ResponseType>>(
  674|       |                  func_)
  675|       |            : nullptr;
  676|       |
  677|       |    if (reactor == nullptr) {
  678|       |      // if deserialization or reactor creator failed, we need to fail the call
  679|       |      reactor = new UnimplementedReadReactor<RequestType, ResponseType>;
  680|       |    }
  681|       |
  682|       |    auto* reader = new (g_core_codegen_interface->grpc_call_arena_alloc(
  683|       |        param.call->call(), sizeof(ServerCallbackReaderImpl)))
  684|       |        ServerCallbackReaderImpl(param.server_context, param.call,
  685|       |                                 std::move(param.call_requester), reactor);
  686|       |
  687|       |    reader->BindReactor(reactor);
  688|       |    reactor->OnStarted(param.server_context, reader->response());
  689|       |    // The earliest that OnCancel can be called is after OnStarted is done.
  690|       |    reactor->MaybeCallOnCancel();
  691|       |    reader->MaybeDone();
  692|       |  }
  693|       |
  694|       | private:
  695|       |  std::function<experimental::ServerReadReactor<RequestType, ResponseType>*()>
  696|       |      func_;
  697|       |
  698|       |  class ServerCallbackReaderImpl
  699|       |      : public experimental::ServerCallbackReader<RequestType> {
  700|       |   public:
  701|       |    void Finish(Status s) override {
  702|       |      finish_tag_.Set(call_.call(), [this](bool) { MaybeDone(); },
  703|       |                      &finish_ops_);
  704|       |      if (!ctx_->sent_initial_metadata_) {
  705|       |        finish_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  706|       |                                        ctx_->initial_metadata_flags());
  707|       |        if (ctx_->compression_level_set()) {
  708|       |          finish_ops_.set_compression_level(ctx_->compression_level());
  709|       |        }
  710|       |        ctx_->sent_initial_metadata_ = true;
  711|       |      }
  712|       |      // The response is dropped if the status is not OK.
  713|       |      if (s.ok()) {
  714|       |        finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_,
  715|       |                                     finish_ops_.SendMessagePtr(&resp_));
  716|       |      } else {
  717|       |        finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_, s);
  718|       |      }
  719|       |      finish_ops_.set_core_cq_tag(&finish_tag_);
  720|       |      call_.PerformOps(&finish_ops_);
  721|       |    }
  722|       |
  723|       |    void SendInitialMetadata() override {
  724|       |      GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
  725|       |      callbacks_outstanding_++;
  726|       |      meta_tag_.Set(call_.call(),
  727|       |                    [this](bool ok) {
  728|       |                      reactor_->OnSendInitialMetadataDone(ok);
  729|       |                      MaybeDone();
  730|       |                    },
  731|       |                    &meta_ops_);
  732|       |      meta_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  733|       |                                    ctx_->initial_metadata_flags());
  734|       |      if (ctx_->compression_level_set()) {
  735|       |        meta_ops_.set_compression_level(ctx_->compression_level());
  736|       |      }
  737|       |      ctx_->sent_initial_metadata_ = true;
  738|       |      meta_ops_.set_core_cq_tag(&meta_tag_);
  739|       |      call_.PerformOps(&meta_ops_);
  740|       |    }
  741|       |
  742|       |    void Read(RequestType* req) override {
  743|       |      callbacks_outstanding_++;
  744|       |      read_ops_.RecvMessage(req);
  745|       |      call_.PerformOps(&read_ops_);
  746|       |    }
  747|       |
  748|       |   private:
  749|       |    friend class CallbackClientStreamingHandler<RequestType, ResponseType>;
  750|       |
  751|       |    ServerCallbackReaderImpl(
  752|       |        ServerContext* ctx, Call* call, std::function<void()> call_requester,
  753|       |        experimental::ServerReadReactor<RequestType, ResponseType>* reactor)
  754|       |        : ctx_(ctx),
  755|       |          call_(*call),
  756|       |          call_requester_(std::move(call_requester)),
  757|       |          reactor_(reactor) {
  758|       |      ctx_->BeginCompletionOp(call, [this](bool) { MaybeDone(); }, reactor);
  759|       |      read_tag_.Set(call_.call(),
  760|       |                    [this](bool ok) {
  761|       |                      reactor_->OnReadDone(ok);
  762|       |                      MaybeDone();
  763|       |                    },
  764|       |                    &read_ops_);
  765|       |      read_ops_.set_core_cq_tag(&read_tag_);
  766|       |    }
  767|       |
  768|       |    ~ServerCallbackReaderImpl() {}
  769|       |
  770|       |    ResponseType* response() { return &resp_; }
  771|       |
  772|       |    void MaybeDone() {
  773|       |      if (--callbacks_outstanding_ == 0) {
  774|       |        reactor_->OnDone();
  775|       |        grpc_call* call = call_.call();
  776|       |        auto call_requester = std::move(call_requester_);
  777|       |        this->~ServerCallbackReaderImpl();  // explicitly call destructor
  778|       |        g_core_codegen_interface->grpc_call_unref(call);
  779|       |        call_requester();
  780|       |      }
  781|       |    }
  782|       |
  783|       |    CallOpSet<CallOpSendInitialMetadata> meta_ops_;
  784|       |    CallbackWithSuccessTag meta_tag_;
  785|       |    CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage,
  786|       |              CallOpServerSendStatus>
  787|       |        finish_ops_;
  788|       |    CallbackWithSuccessTag finish_tag_;
  789|       |    CallOpSet<CallOpRecvMessage<RequestType>> read_ops_;
  790|       |    CallbackWithSuccessTag read_tag_;
  791|       |
  792|       |    ServerContext* ctx_;
  793|       |    Call call_;
  794|       |    ResponseType resp_;
  795|       |    std::function<void()> call_requester_;
  796|       |    experimental::ServerReadReactor<RequestType, ResponseType>* reactor_;
  797|       |    std::atomic_int callbacks_outstanding_{
  798|       |        3};  // reserve for OnStarted, Finish, and CompletionOp
  799|       |  };
  800|       |};
  801|       |
  802|       |template <class RequestType, class ResponseType>
  803|       |class CallbackServerStreamingHandler : public MethodHandler {
  804|       | public:
  805|       |  CallbackServerStreamingHandler(
  806|       |      std::function<
  807|       |          experimental::ServerWriteReactor<RequestType, ResponseType>*()>
  808|       |          func)
  809|       |      : func_(std::move(func)) {}
  810|       |  void RunHandler(const HandlerParameter& param) final {
  811|       |    // Arena allocate a writer structure
  812|       |    g_core_codegen_interface->grpc_call_ref(param.call->call());
  813|       |
  814|       |    experimental::ServerWriteReactor<RequestType, ResponseType>* reactor =
  815|       |        param.status.ok()
  816|       |            ? CatchingReactorCreator<
  817|       |                  experimental::ServerWriteReactor<RequestType, ResponseType>>(
  818|       |                  func_)
  819|       |            : nullptr;
  820|       |
  821|       |    if (reactor == nullptr) {
  822|       |      // if deserialization or reactor creator failed, we need to fail the call
  823|       |      reactor = new UnimplementedWriteReactor<RequestType, ResponseType>;
  824|       |    }
  825|       |
  826|       |    auto* writer = new (g_core_codegen_interface->grpc_call_arena_alloc(
  827|       |        param.call->call(), sizeof(ServerCallbackWriterImpl)))
  828|       |        ServerCallbackWriterImpl(param.server_context, param.call,
  829|       |                                 static_cast<RequestType*>(param.request),
  830|       |                                 std::move(param.call_requester), reactor);
  831|       |    writer->BindReactor(reactor);
  832|       |    reactor->OnStarted(param.server_context, writer->request());
  833|       |    // The earliest that OnCancel can be called is after OnStarted is done.
  834|       |    reactor->MaybeCallOnCancel();
  835|       |    writer->MaybeDone();
  836|       |  }
  837|       |
  838|       |  void* Deserialize(grpc_call* call, grpc_byte_buffer* req, Status* status,
  839|       |                    void** handler_data) final {
  840|       |    ByteBuffer buf;
  841|       |    buf.set_buffer(req);
  842|       |    auto* request = new (g_core_codegen_interface->grpc_call_arena_alloc(
  843|       |        call, sizeof(RequestType))) RequestType();
  844|       |    *status = SerializationTraits<RequestType>::Deserialize(&buf, request);
  845|       |    buf.Release();
  846|       |    if (status->ok()) {
  847|       |      return request;
  848|       |    }
  849|       |    request->~RequestType();
  850|       |    return nullptr;
  851|       |  }
  852|       |
  853|       | private:
  854|       |  std::function<experimental::ServerWriteReactor<RequestType, ResponseType>*()>
  855|       |      func_;
  856|       |
  857|       |  class ServerCallbackWriterImpl
  858|       |      : public experimental::ServerCallbackWriter<ResponseType> {
  859|       |   public:
  860|       |    void Finish(Status s) override {
  861|       |      finish_tag_.Set(call_.call(), [this](bool) { MaybeDone(); },
  862|       |                      &finish_ops_);
  863|       |      finish_ops_.set_core_cq_tag(&finish_tag_);
  864|       |
  865|       |      if (!ctx_->sent_initial_metadata_) {
  866|       |        finish_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  867|       |                                        ctx_->initial_metadata_flags());
  868|       |        if (ctx_->compression_level_set()) {
  869|       |          finish_ops_.set_compression_level(ctx_->compression_level());
  870|       |        }
  871|       |        ctx_->sent_initial_metadata_ = true;
  872|       |      }
  873|       |      finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_, s);
  874|       |      call_.PerformOps(&finish_ops_);
  875|       |    }
  876|       |
  877|       |    void SendInitialMetadata() override {
  878|       |      GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
  879|       |      callbacks_outstanding_++;
  880|       |      meta_tag_.Set(call_.call(),
  881|       |                    [this](bool ok) {
  882|       |                      reactor_->OnSendInitialMetadataDone(ok);
  883|       |                      MaybeDone();
  884|       |                    },
  885|       |                    &meta_ops_);
  886|       |      meta_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  887|       |                                    ctx_->initial_metadata_flags());
  888|       |      if (ctx_->compression_level_set()) {
  889|       |        meta_ops_.set_compression_level(ctx_->compression_level());
  890|       |      }
  891|       |      ctx_->sent_initial_metadata_ = true;
  892|       |      meta_ops_.set_core_cq_tag(&meta_tag_);
  893|       |      call_.PerformOps(&meta_ops_);
  894|       |    }
  895|       |
  896|       |    void Write(const ResponseType* resp, WriteOptions options) override {
  897|       |      callbacks_outstanding_++;
  898|       |      if (options.is_last_message()) {
  899|       |        options.set_buffer_hint();
  900|       |      }
  901|       |      if (!ctx_->sent_initial_metadata_) {
  902|       |        write_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  903|       |                                       ctx_->initial_metadata_flags());
  904|       |        if (ctx_->compression_level_set()) {
  905|       |          write_ops_.set_compression_level(ctx_->compression_level());
  906|       |        }
  907|       |        ctx_->sent_initial_metadata_ = true;
  908|       |      }
  909|       |      // TODO(vjpai): don't assert
  910|       |      GPR_CODEGEN_ASSERT(write_ops_.SendMessagePtr(resp, options).ok());
  911|       |      call_.PerformOps(&write_ops_);
  912|       |    }
  913|       |
  914|       |    void WriteAndFinish(const ResponseType* resp, WriteOptions options,
  915|       |                        Status s) override {
  916|       |      // This combines the write into the finish callback
  917|       |      // Don't send any message if the status is bad
  918|       |      if (s.ok()) {
  919|       |        // TODO(vjpai): don't assert
  920|       |        GPR_CODEGEN_ASSERT(finish_ops_.SendMessagePtr(resp, options).ok());
  921|       |      }
  922|       |      Finish(std::move(s));
  923|       |    }
  924|       |
  925|       |   private:
  926|       |    friend class CallbackServerStreamingHandler<RequestType, ResponseType>;
  927|       |
  928|       |    ServerCallbackWriterImpl(
  929|       |        ServerContext* ctx, Call* call, const RequestType* req,
  930|       |        std::function<void()> call_requester,
  931|       |        experimental::ServerWriteReactor<RequestType, ResponseType>* reactor)
  932|       |        : ctx_(ctx),
  933|       |          call_(*call),
  934|       |          req_(req),
  935|       |          call_requester_(std::move(call_requester)),
  936|       |          reactor_(reactor) {
  937|       |      ctx_->BeginCompletionOp(call, [this](bool) { MaybeDone(); }, reactor);
  938|       |      write_tag_.Set(call_.call(),
  939|       |                     [this](bool ok) {
  940|       |                       reactor_->OnWriteDone(ok);
  941|       |                       MaybeDone();
  942|       |                     },
  943|       |                     &write_ops_);
  944|       |      write_ops_.set_core_cq_tag(&write_tag_);
  945|       |    }
  946|       |    ~ServerCallbackWriterImpl() { req_->~RequestType(); }
  947|       |
  948|       |    const RequestType* request() { return req_; }
  949|       |
  950|       |    void MaybeDone() {
  951|       |      if (--callbacks_outstanding_ == 0) {
  952|       |        reactor_->OnDone();
  953|       |        grpc_call* call = call_.call();
  954|       |        auto call_requester = std::move(call_requester_);
  955|       |        this->~ServerCallbackWriterImpl();  // explicitly call destructor
  956|       |        g_core_codegen_interface->grpc_call_unref(call);
  957|       |        call_requester();
  958|       |      }
  959|       |    }
  960|       |
  961|       |    CallOpSet<CallOpSendInitialMetadata> meta_ops_;
  962|       |    CallbackWithSuccessTag meta_tag_;
  963|       |    CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage,
  964|       |              CallOpServerSendStatus>
  965|       |        finish_ops_;
  966|       |    CallbackWithSuccessTag finish_tag_;
  967|       |    CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage> write_ops_;
  968|       |    CallbackWithSuccessTag write_tag_;
  969|       |
  970|       |    ServerContext* ctx_;
  971|       |    Call call_;
  972|       |    const RequestType* req_;
  973|       |    std::function<void()> call_requester_;
  974|       |    experimental::ServerWriteReactor<RequestType, ResponseType>* reactor_;
  975|       |    std::atomic_int callbacks_outstanding_{
  976|       |        3};  // reserve for OnStarted, Finish, and CompletionOp
  977|       |  };
  978|       |};
  979|       |
  980|       |template <class RequestType, class ResponseType>
  981|       |class CallbackBidiHandler : public MethodHandler {
  982|       | public:
  983|       |  CallbackBidiHandler(
  984|       |      std::function<
  985|       |          experimental::ServerBidiReactor<RequestType, ResponseType>*()>
  986|       |          func)
  987|      0|      : func_(std::move(func)) {}
  988|      0|  void RunHandler(const HandlerParameter& param) final {
  989|      0|    g_core_codegen_interface->grpc_call_ref(param.call->call());
  990|      0|
  991|      0|    experimental::ServerBidiReactor<RequestType, ResponseType>* reactor =
  992|      0|        param.status.ok()
  993|      0|            ? CatchingReactorCreator<
  994|      0|                  experimental::ServerBidiReactor<RequestType, ResponseType>>(
  995|      0|                  func_)
  996|      0|            : nullptr;
  997|      0|
  998|      0|    if (reactor == nullptr) {
  999|      0|      // if deserialization or reactor creator failed, we need to fail the call
 1000|      0|      reactor = new UnimplementedBidiReactor<RequestType, ResponseType>;
 1001|      0|    }
 1002|      0|
 1003|      0|    auto* stream = new (g_core_codegen_interface->grpc_call_arena_alloc(
 1004|      0|        param.call->call(), sizeof(ServerCallbackReaderWriterImpl)))
 1005|      0|        ServerCallbackReaderWriterImpl(param.server_context, param.call,
 1006|      0|                                       std::move(param.call_requester),
 1007|      0|                                       reactor);
 1008|      0|
 1009|      0|    stream->BindReactor(reactor);
 1010|      0|    reactor->OnStarted(param.server_context);
 1011|      0|    // The earliest that OnCancel can be called is after OnStarted is done.
 1012|      0|    reactor->MaybeCallOnCancel();
 1013|      0|    stream->MaybeDone();
 1014|      0|  }
 1015|       |
 1016|       | private:
 1017|       |  std::function<experimental::ServerBidiReactor<RequestType, ResponseType>*()>
 1018|       |      func_;
 1019|       |
 1020|       |  class ServerCallbackReaderWriterImpl
 1021|       |      : public experimental::ServerCallbackReaderWriter<RequestType,
 1022|       |                                                        ResponseType> {
 1023|       |   public:
 1024|      0|    void Finish(Status s) override {
 1025|      0|      finish_tag_.Set(call_.call(), [this](bool) { MaybeDone(); },
 1026|      0|                      &finish_ops_);
 1027|      0|      finish_ops_.set_core_cq_tag(&finish_tag_);
 1028|      0|
 1029|      0|      if (!ctx_->sent_initial_metadata_) {
 1030|      0|        finish_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
 1031|      0|                                        ctx_->initial_metadata_flags());
 1032|      0|        if (ctx_->compression_level_set()) {
 1033|      0|          finish_ops_.set_compression_level(ctx_->compression_level());
 1034|      0|        }
 1035|      0|        ctx_->sent_initial_metadata_ = true;
 1036|      0|      }
 1037|      0|      finish_ops_.ServerSendStatus(&ctx_->trailing_metadata_, s);
 1038|      0|      call_.PerformOps(&finish_ops_);
 1039|      0|    }
 1040|       |
 1041|      0|    void SendInitialMetadata() override {
 1042|      0|      GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
 1043|      0|      callbacks_outstanding_++;
 1044|      0|      meta_tag_.Set(call_.call(),
 1045|      0|                    [this](bool ok) {
 1046|      0|                      reactor_->OnSendInitialMetadataDone(ok);
 1047|      0|                      MaybeDone();
 1048|      0|                    },
 1049|      0|                    &meta_ops_);
 1050|      0|      meta_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
 1051|      0|                                    ctx_->initial_metadata_flags());
 1052|      0|      if (ctx_->compression_level_set()) {
 1053|      0|        meta_ops_.set_compression_level(ctx_->compression_level());
 1054|      0|      }
 1055|      0|      ctx_->sent_initial_metadata_ = true;
 1056|      0|      meta_ops_.set_core_cq_tag(&meta_tag_);
 1057|      0|      call_.PerformOps(&meta_ops_);
 1058|      0|    }
 1059|       |
 1060|      0|    void Write(const ResponseType* resp, WriteOptions options) override {
 1061|      0|      callbacks_outstanding_++;
 1062|      0|      if (options.is_last_message()) {
 1063|      0|        options.set_buffer_hint();
 1064|      0|      }
 1065|      0|      if (!ctx_->sent_initial_metadata_) {
 1066|      0|        write_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
 1067|      0|                                       ctx_->initial_metadata_flags());
 1068|      0|        if (ctx_->compression_level_set()) {
 1069|      0|          write_ops_.set_compression_level(ctx_->compression_level());
 1070|      0|        }
 1071|      0|        ctx_->sent_initial_metadata_ = true;
 1072|      0|      }
 1073|      0|      // TODO(vjpai): don't assert
 1074|      0|      GPR_CODEGEN_ASSERT(write_ops_.SendMessagePtr(resp, options).ok());
 1075|      0|      call_.PerformOps(&write_ops_);
 1076|      0|    }
 1077|       |
 1078|       |    void WriteAndFinish(const ResponseType* resp, WriteOptions options,
 1079|      0|                        Status s) override {
 1080|      0|      // Don't send any message if the status is bad
 1081|      0|      if (s.ok()) {
 1082|      0|        // TODO(vjpai): don't assert
 1083|      0|        GPR_CODEGEN_ASSERT(finish_ops_.SendMessagePtr(resp, options).ok());
 1084|      0|      }
 1085|      0|      Finish(std::move(s));
 1086|      0|    }
 1087|       |
 1088|      0|    void Read(RequestType* req) override {
 1089|      0|      callbacks_outstanding_++;
 1090|      0|      read_ops_.RecvMessage(req);
 1091|      0|      call_.PerformOps(&read_ops_);
 1092|      0|    }
 1093|       |
 1094|       |   private:
 1095|       |    friend class CallbackBidiHandler<RequestType, ResponseType>;
 1096|       |
 1097|       |    ServerCallbackReaderWriterImpl(
 1098|       |        ServerContext* ctx, Call* call, std::function<void()> call_requester,
 1099|       |        experimental::ServerBidiReactor<RequestType, ResponseType>* reactor)
 1100|       |        : ctx_(ctx),
 1101|       |          call_(*call),
 1102|       |          call_requester_(std::move(call_requester)),
 1103|      0|          reactor_(reactor) {
 1104|      0|      ctx_->BeginCompletionOp(call, [this](bool) { MaybeDone(); }, reactor);
 1105|      0|      write_tag_.Set(call_.call(),
 1106|      0|                     [this](bool ok) {
 1107|      0|                       reactor_->OnWriteDone(ok);
 1108|      0|                       MaybeDone();
 1109|      0|                     },
 1110|      0|                     &write_ops_);
 1111|      0|      write_ops_.set_core_cq_tag(&write_tag_);
 1112|      0|      read_tag_.Set(call_.call(),
 1113|      0|                    [this](bool ok) {
 1114|      0|                      reactor_->OnReadDone(ok);
 1115|      0|                      MaybeDone();
 1116|      0|                    },
 1117|      0|                    &read_ops_);
 1118|      0|      read_ops_.set_core_cq_tag(&read_tag_);
 1119|      0|    }
 1120|      0|    ~ServerCallbackReaderWriterImpl() {}
 1121|       |
 1122|      0|    void MaybeDone() {
 1123|      0|      if (--callbacks_outstanding_ == 0) {
 1124|      0|        reactor_->OnDone();
 1125|      0|        grpc_call* call = call_.call();
 1126|      0|        auto call_requester = std::move(call_requester_);
 1127|      0|        this->~ServerCallbackReaderWriterImpl();  // explicitly call destructor
 1128|      0|        g_core_codegen_interface->grpc_call_unref(call);
 1129|      0|        call_requester();
 1130|      0|      }
 1131|      0|    }
 1132|       |
 1133|       |    CallOpSet<CallOpSendInitialMetadata> meta_ops_;
 1134|       |    CallbackWithSuccessTag meta_tag_;
 1135|       |    CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage,
 1136|       |              CallOpServerSendStatus>
 1137|       |        finish_ops_;
 1138|       |    CallbackWithSuccessTag finish_tag_;
 1139|       |    CallOpSet<CallOpSendInitialMetadata, CallOpSendMessage> write_ops_;
 1140|       |    CallbackWithSuccessTag write_tag_;
 1141|       |    CallOpSet<CallOpRecvMessage<RequestType>> read_ops_;
 1142|       |    CallbackWithSuccessTag read_tag_;
 1143|       |
 1144|       |    ServerContext* ctx_;
 1145|       |    Call call_;
 1146|       |    std::function<void()> call_requester_;
 1147|       |    experimental::ServerBidiReactor<RequestType, ResponseType>* reactor_;
 1148|       |    std::atomic_int callbacks_outstanding_{
 1149|       |        3};  // reserve for OnStarted, Finish, and CompletionOp
 1150|       |  };
 1151|       |};
 1152|       |
 1153|       |}  // namespace internal
 1154|       |
 1155|       |}  // namespace grpc
 1156|       |
 1157|       |#endif  // GRPCPP_IMPL_CODEGEN_SERVER_CALLBACK_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/server_context.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_SERVER_CONTEXT_H
   20|       |#define GRPCPP_IMPL_CODEGEN_SERVER_CONTEXT_H
   21|       |
   22|       |#include <map>
   23|       |#include <memory>
   24|       |#include <vector>
   25|       |
   26|       |#include <grpc/impl/codegen/compression_types.h>
   27|       |
   28|       |#include <grpcpp/impl/codegen/call.h>
   29|       |#include <grpcpp/impl/codegen/call_op_set.h>
   30|       |#include <grpcpp/impl/codegen/callback_common.h>
   31|       |#include <grpcpp/impl/codegen/completion_queue_tag.h>
   32|       |#include <grpcpp/impl/codegen/config.h>
   33|       |#include <grpcpp/impl/codegen/create_auth_context.h>
   34|       |#include <grpcpp/impl/codegen/metadata_map.h>
   35|       |#include <grpcpp/impl/codegen/security/auth_context.h>
   36|       |#include <grpcpp/impl/codegen/server_interceptor.h>
   37|       |#include <grpcpp/impl/codegen/string_ref.h>
   38|       |#include <grpcpp/impl/codegen/time.h>
   39|       |
   40|       |struct grpc_metadata;
   41|       |struct grpc_call;
   42|       |struct census_context;
   43|       |
   44|       |namespace grpc_impl {
   45|       |
   46|       |class CompletionQueue;
   47|       |class Server;
   48|       |}  // namespace grpc_impl
   49|       |namespace grpc {
   50|       |class ClientContext;
   51|       |class GenericServerContext;
   52|       |class ServerInterface;
   53|       |template <class W, class R>
   54|       |class ServerAsyncReader;
   55|       |template <class W>
   56|       |class ServerAsyncWriter;
   57|       |template <class W>
   58|       |class ServerAsyncResponseWriter;
   59|       |template <class W, class R>
   60|       |class ServerAsyncReaderWriter;
   61|       |template <class R>
   62|       |class ServerReader;
   63|       |template <class W>
   64|       |class ServerWriter;
   65|       |
   66|       |namespace internal {
   67|       |template <class W, class R>
   68|       |class ServerReaderWriterBody;
   69|       |template <class ServiceType, class RequestType, class ResponseType>
   70|       |class RpcMethodHandler;
   71|       |template <class ServiceType, class RequestType, class ResponseType>
   72|       |class ClientStreamingHandler;
   73|       |template <class ServiceType, class RequestType, class ResponseType>
   74|       |class ServerStreamingHandler;
   75|       |template <class ServiceType, class RequestType, class ResponseType>
   76|       |class BidiStreamingHandler;
   77|       |template <class RequestType, class ResponseType>
   78|       |class CallbackUnaryHandler;
   79|       |template <class RequestType, class ResponseType>
   80|       |class CallbackClientStreamingHandler;
   81|       |template <class RequestType, class ResponseType>
   82|       |class CallbackServerStreamingHandler;
   83|       |template <class RequestType, class ResponseType>
   84|       |class CallbackBidiHandler;
   85|       |template <class Streamer, bool WriteNeeded>
   86|       |class TemplatedBidiStreamingHandler;
   87|       |template <StatusCode code>
   88|       |class ErrorMethodHandler;
   89|       |class Call;
   90|       |class ServerReactor;
   91|       |}  // namespace internal
   92|       |
   93|       |class ServerInterface;
   94|       |namespace testing {
   95|       |class InteropServerContextInspector;
   96|       |class ServerContextTestSpouse;
   97|       |}  // namespace testing
   98|       |
   99|       |/// A ServerContext allows the person implementing a service handler to:
  100|       |///
  101|       |/// - Add custom initial and trailing metadata key-value pairs that will
  102|       |///   propagated to the client side.
  103|       |/// - Control call settings such as compression and authentication.
  104|       |/// - Access metadata coming from the client.
  105|       |/// - Get performance metrics (ie, census).
  106|       |///
  107|       |/// Context settings are only relevant to the call handler they are supplied to,
  108|       |/// that is to say, they aren't sticky across multiple calls. Some of these
  109|       |/// settings, such as the compression options, can be made persistent at server
  110|       |/// construction time by specifying the appropriate \a ChannelArguments
  111|       |/// to a \a grpc::ServerBuilder, via \a ServerBuilder::AddChannelArgument.
  112|       |///
  113|       |/// \warning ServerContext instances should \em not be reused across rpcs.
  114|       |class ServerContext {
  115|       | public:
  116|       |  ServerContext();  // for async calls
  117|       |  ~ServerContext();
  118|       |
  119|       |  /// Return the deadline for the server call.
  120|      0|  std::chrono::system_clock::time_point deadline() const {
  121|      0|    return Timespec2Timepoint(deadline_);
  122|      0|  }
  123|       |
  124|       |  /// Return a \a gpr_timespec representation of the server call's deadline.
  125|      0|  gpr_timespec raw_deadline() const { return deadline_; }
  126|       |
  127|       |  /// Add the (\a key, \a value) pair to the initial metadata
  128|       |  /// associated with a server call. These are made available at the client side
  129|       |  /// by the \a grpc::ClientContext::GetServerInitialMetadata() method.
  130|       |  ///
  131|       |  /// \warning This method should only be called before sending initial metadata
  132|       |  /// to the client (which can happen explicitly, or implicitly when sending a
  133|       |  /// a response message or status to the client).
  134|       |  ///
  135|       |  /// \param key The metadata key. If \a value is binary data, it must
  136|       |  /// end in "-bin".
  137|       |  /// \param value The metadata value. If its value is binary, the key name
  138|       |  /// must end in "-bin".
  139|       |  ///
  140|       |  /// Metadata must conform to the following format:
  141|       |  /// Custom-Metadata -> Binary-Header / ASCII-Header
  142|       |  /// Binary-Header -> {Header-Name "-bin" } {binary value}
  143|       |  /// ASCII-Header -> Header-Name ASCII-Value
  144|       |  /// Header-Name -> 1*( %x30-39 / %x61-7A / "_" / "-" / ".") ; 0-9 a-z _ - .
  145|       |  /// ASCII-Value -> 1*( %x20-%x7E ) ; space and printable ASCII
  146|       |  void AddInitialMetadata(const grpc::string& key, const grpc::string& value);
  147|       |
  148|       |  /// Add the (\a key, \a value) pair to the initial metadata
  149|       |  /// associated with a server call. These are made available at the client
  150|       |  /// side by the \a grpc::ClientContext::GetServerTrailingMetadata() method.
  151|       |  ///
  152|       |  /// \warning This method should only be called before sending trailing
  153|       |  /// metadata to the client (which happens when the call is finished and a
  154|       |  /// status is sent to the client).
  155|       |  ///
  156|       |  /// \param key The metadata key. If \a value is binary data,
  157|       |  /// it must end in "-bin".
  158|       |  /// \param value The metadata value. If its value is binary, the key name
  159|       |  /// must end in "-bin".
  160|       |  ///
  161|       |  /// Metadata must conform to the following format:
  162|       |  /// Custom-Metadata -> Binary-Header / ASCII-Header
  163|       |  /// Binary-Header -> {Header-Name "-bin" } {binary value}
  164|       |  /// ASCII-Header -> Header-Name ASCII-Value
  165|       |  /// Header-Name -> 1*( %x30-39 / %x61-7A / "_" / "-" / ".") ; 0-9 a-z _ - .
  166|       |  /// ASCII-Value -> 1*( %x20-%x7E ) ; space and printable ASCII
  167|       |  void AddTrailingMetadata(const grpc::string& key, const grpc::string& value);
  168|       |
  169|       |  /// IsCancelled is always safe to call when using sync or callback API.
  170|       |  /// When using async API, it is only safe to call IsCancelled after
  171|       |  /// the AsyncNotifyWhenDone tag has been delivered.
  172|       |  bool IsCancelled() const;
  173|       |
  174|       |  /// Cancel the Call from the server. This is a best-effort API and
  175|       |  /// depending on when it is called, the RPC may still appear successful to
  176|       |  /// the client.
  177|       |  /// For example, if TryCancel() is called on a separate thread, it might race
  178|       |  /// with the server handler which might return success to the client before
  179|       |  /// TryCancel() was even started by the thread.
  180|       |  ///
  181|       |  /// It is the caller's responsibility to prevent such races and ensure that if
  182|       |  /// TryCancel() is called, the serverhandler must return Status::CANCELLED.
  183|       |  /// The only exception is that if the serverhandler is already returning an
  184|       |  /// error status code, it is ok to not return Status::CANCELLED even if
  185|       |  /// TryCancel() was called.
  186|       |  ///
  187|       |  /// Note that TryCancel() does not change any of the tags that are pending
  188|       |  /// on the completion queue. All pending tags will still be delivered
  189|       |  /// (though their ok result may reflect the effect of cancellation).
  190|       |  void TryCancel() const;
  191|       |
  192|       |  /// Return a collection of initial metadata key-value pairs sent from the
  193|       |  /// client. Note that keys may happen more than
  194|       |  /// once (ie, a \a std::multimap is returned).
  195|       |  ///
  196|       |  /// It is safe to use this method after initial metadata has been received,
  197|       |  /// Calls always begin with the client sending initial metadata, so this is
  198|       |  /// safe to access as soon as the call has begun on the server side.
  199|       |  ///
  200|       |  /// \return A multimap of initial metadata key-value pairs from the server.
  201|       |  const std::multimap<grpc::string_ref, grpc::string_ref>& client_metadata()
  202|      0|      const {
  203|      0|    return *client_metadata_.map();
  204|      0|  }
  205|       |
  206|       |  /// Return the compression algorithm to be used by the server call.
  207|      0|  grpc_compression_level compression_level() const {
  208|      0|    return compression_level_;
  209|      0|  }
  210|       |
  211|       |  /// Set \a level to be the compression level used for the server call.
  212|       |  ///
  213|       |  /// \param level The compression level used for the server call.
  214|      0|  void set_compression_level(grpc_compression_level level) {
  215|      0|    compression_level_set_ = true;
  216|      0|    compression_level_ = level;
  217|      0|  }
  218|       |
  219|       |  /// Return a bool indicating whether the compression level for this call
  220|       |  /// has been set (either implicitly or through a previous call to
  221|       |  /// \a set_compression_level.
  222|      0|  bool compression_level_set() const { return compression_level_set_; }
  223|       |
  224|       |  /// Return the compression algorithm the server call will request be used.
  225|       |  /// Note that the gRPC runtime may decide to ignore this request, for example,
  226|       |  /// due to resource constraints, or if the server is aware the client doesn't
  227|       |  /// support the requested algorithm.
  228|      0|  grpc_compression_algorithm compression_algorithm() const {
  229|      0|    return compression_algorithm_;
  230|      0|  }
  231|       |  /// Set \a algorithm to be the compression algorithm used for the server call.
  232|       |  ///
  233|       |  /// \param algorithm The compression algorithm used for the server call.
  234|       |  void set_compression_algorithm(grpc_compression_algorithm algorithm);
  235|       |
  236|       |  /// Set the serialized load reporting costs in \a cost_data for the call.
  237|       |  void SetLoadReportingCosts(const std::vector<grpc::string>& cost_data);
  238|       |
  239|       |  /// Return the authentication context for this server call.
  240|       |  ///
  241|       |  /// \see grpc::AuthContext.
  242|      0|  std::shared_ptr<const AuthContext> auth_context() const {
  243|      0|    if (auth_context_.get() == nullptr) {
  244|      0|      auth_context_ = CreateAuthContext(call_);
  245|      0|    }
  246|      0|    return auth_context_;
  247|      0|  }
  248|       |
  249|       |  /// Return the peer uri in a string.
  250|       |  /// WARNING: this value is never authenticated or subject to any security
  251|       |  /// related code. It must not be used for any authentication related
  252|       |  /// functionality. Instead, use auth_context.
  253|       |  grpc::string peer() const;
  254|       |
  255|       |  /// Get the census context associated with this server call.
  256|       |  const struct census_context* census_context() const;
  257|       |
  258|       |  /// Async only. Has to be called before the rpc starts.
  259|       |  /// Returns the tag in completion queue when the rpc finishes.
  260|       |  /// IsCancelled() can then be called to check whether the rpc was cancelled.
  261|       |  /// TODO(vjpai): Fix this so that the tag is returned even if the call never
  262|       |  /// starts (https://github.com/grpc/grpc/issues/10136).
  263|      0|  void AsyncNotifyWhenDone(void* tag) {
  264|      0|    has_notify_when_done_tag_ = true;
  265|      0|    async_notify_when_done_tag_ = tag;
  266|      0|  }
  267|       |
  268|       |  /// Should be used for framework-level extensions only.
  269|       |  /// Applications never need to call this method.
  270|      0|  grpc_call* c_call() { return call_; }
  271|       |
  272|       | private:
  273|       |  friend class ::grpc::testing::InteropServerContextInspector;
  274|       |  friend class ::grpc::testing::ServerContextTestSpouse;
  275|       |  friend class ::grpc::ServerInterface;
  276|       |  friend class ::grpc_impl::Server;
  277|       |  template <class W, class R>
  278|       |  friend class ::grpc::ServerAsyncReader;
  279|       |  template <class W>
  280|       |  friend class ::grpc::ServerAsyncWriter;
  281|       |  template <class W>
  282|       |  friend class ::grpc::ServerAsyncResponseWriter;
  283|       |  template <class W, class R>
  284|       |  friend class ::grpc::ServerAsyncReaderWriter;
  285|       |  template <class R>
  286|       |  friend class ::grpc::ServerReader;
  287|       |  template <class W>
  288|       |  friend class ::grpc::ServerWriter;
  289|       |  template <class W, class R>
  290|       |  friend class ::grpc::internal::ServerReaderWriterBody;
  291|       |  template <class ServiceType, class RequestType, class ResponseType>
  292|       |  friend class ::grpc::internal::RpcMethodHandler;
  293|       |  template <class ServiceType, class RequestType, class ResponseType>
  294|       |  friend class ::grpc::internal::ClientStreamingHandler;
  295|       |  template <class ServiceType, class RequestType, class ResponseType>
  296|       |  friend class ::grpc::internal::ServerStreamingHandler;
  297|       |  template <class Streamer, bool WriteNeeded>
  298|       |  friend class ::grpc::internal::TemplatedBidiStreamingHandler;
  299|       |  template <class RequestType, class ResponseType>
  300|       |  friend class ::grpc::internal::CallbackUnaryHandler;
  301|       |  template <class RequestType, class ResponseType>
  302|       |  friend class ::grpc::internal::CallbackClientStreamingHandler;
  303|       |  template <class RequestType, class ResponseType>
  304|       |  friend class ::grpc::internal::CallbackServerStreamingHandler;
  305|       |  template <class RequestType, class ResponseType>
  306|       |  friend class ::grpc::internal::CallbackBidiHandler;
  307|       |  template <StatusCode code>
  308|       |  friend class internal::ErrorMethodHandler;
  309|       |  friend class ::grpc::ClientContext;
  310|       |  friend class ::grpc::GenericServerContext;
  311|       |
  312|       |  /// Prevent copying.
  313|       |  ServerContext(const ServerContext&);
  314|       |  ServerContext& operator=(const ServerContext&);
  315|       |
  316|       |  class CompletionOp;
  317|       |
  318|       |  void BeginCompletionOp(internal::Call* call,
  319|       |                         std::function<void(bool)> callback,
  320|       |                         internal::ServerReactor* reactor);
  321|       |  /// Return the tag queued by BeginCompletionOp()
  322|       |  internal::CompletionQueueTag* GetCompletionOpTag();
  323|       |
  324|       |  ServerContext(gpr_timespec deadline, grpc_metadata_array* arr);
  325|       |
  326|      0|  void set_call(grpc_call* call) { call_ = call; }
  327|       |
  328|       |  void BindDeadlineAndMetadata(gpr_timespec deadline, grpc_metadata_array* arr);
  329|       |
  330|       |  void Clear();
  331|       |
  332|       |  void Setup(gpr_timespec deadline);
  333|       |
  334|      0|  uint32_t initial_metadata_flags() const { return 0; }
  335|       |
  336|       |  void SetCancelCallback(std::function<void()> callback);
  337|       |  void ClearCancelCallback();
  338|       |
  339|       |  experimental::ServerRpcInfo* set_server_rpc_info(
  340|       |      const char* method, internal::RpcMethod::RpcType type,
  341|       |      const std::vector<
  342|       |          std::unique_ptr<experimental::ServerInterceptorFactoryInterface>>&
  343|      0|          creators) {
  344|      0|    if (creators.size() != 0) {
  345|      0|      rpc_info_ = new experimental::ServerRpcInfo(this, method, type);
  346|      0|      rpc_info_->RegisterInterceptors(creators);
  347|      0|    }
  348|      0|    return rpc_info_;
  349|      0|  }
  350|       |
  351|       |  CompletionOp* completion_op_;
  352|       |  bool has_notify_when_done_tag_;
  353|       |  void* async_notify_when_done_tag_;
  354|       |  internal::CallbackWithSuccessTag completion_tag_;
  355|       |
  356|       |  gpr_timespec deadline_;
  357|       |  grpc_call* call_;
  358|       |  ::grpc_impl::CompletionQueue* cq_;
  359|       |  bool sent_initial_metadata_;
  360|       |  mutable std::shared_ptr<const AuthContext> auth_context_;
  361|       |  mutable internal::MetadataMap client_metadata_;
  362|       |  std::multimap<grpc::string, grpc::string> initial_metadata_;
  363|       |  std::multimap<grpc::string, grpc::string> trailing_metadata_;
  364|       |
  365|       |  bool compression_level_set_;
  366|       |  grpc_compression_level compression_level_;
  367|       |  grpc_compression_algorithm compression_algorithm_;
  368|       |
  369|       |  internal::CallOpSet<internal::CallOpSendInitialMetadata,
  370|       |                      internal::CallOpSendMessage>
  371|       |      pending_ops_;
  372|       |  bool has_pending_ops_;
  373|       |
  374|       |  experimental::ServerRpcInfo* rpc_info_;
  375|       |};
  376|       |
  377|       |}  // namespace grpc
  378|       |
  379|       |#endif  // GRPCPP_IMPL_CODEGEN_SERVER_CONTEXT_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/server_interceptor.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_SERVER_INTERCEPTOR_H
   20|       |#define GRPCPP_IMPL_CODEGEN_SERVER_INTERCEPTOR_H
   21|       |
   22|       |#include <atomic>
   23|       |#include <vector>
   24|       |
   25|       |#include <grpcpp/impl/codegen/interceptor.h>
   26|       |#include <grpcpp/impl/codegen/rpc_method.h>
   27|       |#include <grpcpp/impl/codegen/string_ref.h>
   28|       |
   29|       |namespace grpc {
   30|       |
   31|       |class ServerContext;
   32|       |
   33|       |namespace internal {
   34|       |class InterceptorBatchMethodsImpl;
   35|       |}
   36|       |
   37|       |namespace experimental {
   38|       |class ServerRpcInfo;
   39|       |
   40|       |// A factory interface for creation of server interceptors. A vector of
   41|       |// factories can be provided to ServerBuilder which will be used to create a new
   42|       |// vector of server interceptors per RPC. Server interceptor authors should
   43|       |// create a subclass of ServerInterceptorFactorInterface which creates objects
   44|       |// of their interceptors.
   45|       |class ServerInterceptorFactoryInterface {
   46|       | public:
   47|      0|  virtual ~ServerInterceptorFactoryInterface() {}
   48|       |  // Returns a pointer to an Interceptor object on successful creation, nullptr
   49|       |  // otherwise. If nullptr is returned, this server interceptor factory is
   50|       |  // ignored for the purposes of that RPC.
   51|       |  virtual Interceptor* CreateServerInterceptor(ServerRpcInfo* info) = 0;
   52|       |};
   53|       |
   54|       |/// ServerRpcInfo represents the state of a particular RPC as it
   55|       |/// appears to an interceptor. It is created and owned by the library and
   56|       |/// passed to the CreateServerInterceptor method of the application's
   57|       |/// ServerInterceptorFactoryInterface implementation
   58|       |class ServerRpcInfo {
   59|       | public:
   60|       |  /// Type categorizes RPCs by unary or streaming type
   61|       |  enum class Type { UNARY, CLIENT_STREAMING, SERVER_STREAMING, BIDI_STREAMING };
   62|       |
   63|      0|  ~ServerRpcInfo() {}
   64|       |
   65|       |  // Delete all copy and move constructors and assignments
   66|       |  ServerRpcInfo(const ServerRpcInfo&) = delete;
   67|       |  ServerRpcInfo& operator=(const ServerRpcInfo&) = delete;
   68|       |  ServerRpcInfo(ServerRpcInfo&&) = delete;
   69|       |  ServerRpcInfo& operator=(ServerRpcInfo&&) = delete;
   70|       |
   71|       |  // Getter methods
   72|       |
   73|       |  /// Return the fully-specified method name
   74|      0|  const char* method() const { return method_; }
   75|       |
   76|       |  /// Return the type of the RPC (unary or a streaming flavor)
   77|      0|  Type type() const { return type_; }
   78|       |
   79|       |  /// Return a pointer to the underlying ServerContext structure associated
   80|       |  /// with the RPC to support features that apply to it
   81|      0|  grpc::ServerContext* server_context() { return ctx_; }
   82|       |
   83|       | private:
   84|       |  static_assert(Type::UNARY ==
   85|       |                    static_cast<Type>(internal::RpcMethod::NORMAL_RPC),
   86|       |                "violated expectation about Type enum");
   87|       |  static_assert(Type::CLIENT_STREAMING ==
   88|       |                    static_cast<Type>(internal::RpcMethod::CLIENT_STREAMING),
   89|       |                "violated expectation about Type enum");
   90|       |  static_assert(Type::SERVER_STREAMING ==
   91|       |                    static_cast<Type>(internal::RpcMethod::SERVER_STREAMING),
   92|       |                "violated expectation about Type enum");
   93|       |  static_assert(Type::BIDI_STREAMING ==
   94|       |                    static_cast<Type>(internal::RpcMethod::BIDI_STREAMING),
   95|       |                "violated expectation about Type enum");
   96|       |
   97|       |  ServerRpcInfo(grpc::ServerContext* ctx, const char* method,
   98|       |                internal::RpcMethod::RpcType type)
   99|      0|      : ctx_(ctx), method_(method), type_(static_cast<Type>(type)) {
  100|      0|    ref_.store(1);
  101|      0|  }
  102|       |
  103|       |  // Runs interceptor at pos \a pos.
  104|       |  void RunInterceptor(
  105|      0|      experimental::InterceptorBatchMethods* interceptor_methods, size_t pos) {
  106|      0|    GPR_CODEGEN_ASSERT(pos < interceptors_.size());
  107|      0|    interceptors_[pos]->Intercept(interceptor_methods);
  108|      0|  }
  109|       |
  110|       |  void RegisterInterceptors(
  111|       |      const std::vector<
  112|       |          std::unique_ptr<experimental::ServerInterceptorFactoryInterface>>&
  113|      0|          creators) {
  114|      0|    for (const auto& creator : creators) {
  115|      0|      auto* interceptor = creator->CreateServerInterceptor(this);
  116|      0|      if (interceptor != nullptr) {
  117|      0|        interceptors_.push_back(
  118|      0|            std::unique_ptr<experimental::Interceptor>(interceptor));
  119|      0|      }
  120|      0|    }
  121|      0|  }
  122|       |
  123|      0|  void Ref() { ref_++; }
  124|      0|  void Unref() {
  125|      0|    if (--ref_ == 0) {
  126|      0|      delete this;
  127|      0|    }
  128|      0|  }
  129|       |
  130|       |  grpc::ServerContext* ctx_ = nullptr;
  131|       |  const char* method_ = nullptr;
  132|       |  const Type type_;
  133|       |  std::atomic_int ref_;
  134|       |  std::vector<std::unique_ptr<experimental::Interceptor>> interceptors_;
  135|       |
  136|       |  friend class internal::InterceptorBatchMethodsImpl;
  137|       |  friend class grpc::ServerContext;
  138|       |};
  139|       |
  140|       |}  // namespace experimental
  141|       |}  // namespace grpc
  142|       |
  143|       |#endif  // GRPCPP_IMPL_CODEGEN_SERVER_INTERCEPTOR_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/server_interface.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_SERVER_INTERFACE_H
   20|       |#define GRPCPP_IMPL_CODEGEN_SERVER_INTERFACE_H
   21|       |
   22|       |#include <grpc/impl/codegen/grpc_types.h>
   23|       |#include <grpcpp/impl/codegen/byte_buffer.h>
   24|       |#include <grpcpp/impl/codegen/call.h>
   25|       |#include <grpcpp/impl/codegen/call_hook.h>
   26|       |#include <grpcpp/impl/codegen/completion_queue_tag.h>
   27|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   28|       |#include <grpcpp/impl/codegen/rpc_service_method.h>
   29|       |#include <grpcpp/impl/codegen/server_context.h>
   30|       |
   31|       |namespace grpc_impl {
   32|       |
   33|       |class CompletionQueue;
   34|       |class ServerCompletionQueue;
   35|       |class Channel;
   36|       |class ServerCredentials;
   37|       |}  // namespace grpc_impl
   38|       |namespace grpc {
   39|       |
   40|       |class AsyncGenericService;
   41|       |class GenericServerContext;
   42|       |class ServerContext;
   43|       |class Service;
   44|       |
   45|       |extern CoreCodegenInterface* g_core_codegen_interface;
   46|       |
   47|       |/// Models a gRPC server.
   48|       |///
   49|       |/// Servers are configured and started via \a grpc::ServerBuilder.
   50|       |namespace internal {
   51|       |class ServerAsyncStreamingInterface;
   52|       |}  // namespace internal
   53|       |
   54|       |namespace experimental {
   55|       |class CallbackGenericService;
   56|       |}  // namespace experimental
   57|       |
   58|       |class ServerInterface : public internal::CallHook {
   59|       | public:
   60|      0|  virtual ~ServerInterface() {}
   61|       |
   62|       |  /// \a Shutdown does the following things:
   63|       |  ///
   64|       |  /// 1. Shutdown the server: deactivate all listening ports, mark it in
   65|       |  ///    "shutdown mode" so that further call Request's or incoming RPC matches
   66|       |  ///    are no longer allowed. Also return all Request'ed-but-not-yet-active
   67|       |  ///    calls as failed (!ok). This refers to calls that have been requested
   68|       |  ///    at the server by the server-side library or application code but that
   69|       |  ///    have not yet been matched to incoming RPCs from the client. Note that
   70|       |  ///    this would even include default calls added automatically by the gRPC
   71|       |  ///    C++ API without the user's input (e.g., "Unimplemented RPC method")
   72|       |  ///
   73|       |  /// 2. Block until all rpc method handlers invoked automatically by the sync
   74|       |  ///    API finish.
   75|       |  ///
   76|       |  /// 3. If all pending calls complete (and all their operations are
   77|       |  ///    retrieved by Next) before \a deadline expires, this finishes
   78|       |  ///    gracefully. Otherwise, forcefully cancel all pending calls associated
   79|       |  ///    with the server after \a deadline expires. In the case of the sync API,
   80|       |  ///    if the RPC function for a streaming call has already been started and
   81|       |  ///    takes a week to complete, the RPC function won't be forcefully
   82|       |  ///    terminated (since that would leave state corrupt and incomplete) and
   83|       |  ///    the method handler will just keep running (which will prevent the
   84|       |  ///    server from completing the "join" operation that it needs to do at
   85|       |  ///    shutdown time).
   86|       |  ///
   87|       |  /// All completion queue associated with the server (for example, for async
   88|       |  /// serving) must be shutdown *after* this method has returned:
   89|       |  /// See \a ServerBuilder::AddCompletionQueue for details.
   90|       |  /// They must also be drained (by repeated Next) after being shutdown.
   91|       |  ///
   92|       |  /// \param deadline How long to wait until pending rpcs are forcefully
   93|       |  /// terminated.
   94|       |  template <class T>
   95|       |  void Shutdown(const T& deadline) {
   96|       |    ShutdownInternal(TimePoint<T>(deadline).raw_time());
   97|       |  }
   98|       |
   99|       |  /// Shutdown the server without a deadline and forced cancellation.
  100|       |  ///
  101|       |  /// All completion queue associated with the server (for example, for async
  102|       |  /// serving) must be shutdown *after* this method has returned:
  103|       |  /// See \a ServerBuilder::AddCompletionQueue for details.
  104|      0|  void Shutdown() {
  105|      0|    ShutdownInternal(
  106|      0|        g_core_codegen_interface->gpr_inf_future(GPR_CLOCK_MONOTONIC));
  107|      0|  }
  108|       |
  109|       |  /// Block waiting for all work to complete.
  110|       |  ///
  111|       |  /// \warning The server must be either shutting down or some other thread must
  112|       |  /// call \a Shutdown for this function to ever return.
  113|       |  virtual void Wait() = 0;
  114|       |
  115|       | protected:
  116|       |  friend class ::grpc::Service;
  117|       |
  118|       |  /// Register a service. This call does not take ownership of the service.
  119|       |  /// The service must exist for the lifetime of the Server instance.
  120|       |  virtual bool RegisterService(const grpc::string* host, Service* service) = 0;
  121|       |
  122|       |  /// Register a generic service. This call does not take ownership of the
  123|       |  /// service. The service must exist for the lifetime of the Server instance.
  124|       |  virtual void RegisterAsyncGenericService(AsyncGenericService* service) = 0;
  125|       |
  126|       |  /// NOTE: class experimental_registration_interface is not part of the public
  127|       |  /// API of this class
  128|       |  /// TODO(vjpai): Move these contents to public API when no longer experimental
  129|       |  class experimental_registration_interface {
  130|       |   public:
  131|      0|    virtual ~experimental_registration_interface() {}
  132|       |    /// May not be abstract since this is a post-1.0 API addition
  133|       |    virtual void RegisterCallbackGenericService(
  134|      0|        experimental::CallbackGenericService* service) {}
  135|       |  };
  136|       |
  137|       |  /// NOTE: The function experimental_registration() is not stable public API.
  138|       |  /// It is a view to the experimental components of this class. It may be
  139|       |  /// changed or removed at any time. May not be abstract since this is a
  140|       |  /// post-1.0 API addition
  141|      0|  virtual experimental_registration_interface* experimental_registration() {
  142|      0|    return nullptr;
  143|      0|  }
  144|       |
  145|       |  /// Tries to bind \a server to the given \a addr.
  146|       |  ///
  147|       |  /// It can be invoked multiple times.
  148|       |  ///
  149|       |  /// \param addr The address to try to bind to the server (eg, localhost:1234,
  150|       |  /// 192.168.1.1:31416, [::1]:27182, etc.).
  151|       |  /// \params creds The credentials associated with the server.
  152|       |  ///
  153|       |  /// \return bound port number on success, 0 on failure.
  154|       |  ///
  155|       |  /// \warning It's an error to call this method on an already started server.
  156|       |  virtual int AddListeningPort(const grpc::string& addr,
  157|       |                               grpc_impl::ServerCredentials* creds) = 0;
  158|       |
  159|       |  /// Start the server.
  160|       |  ///
  161|       |  /// \param cqs Completion queues for handling asynchronous services. The
  162|       |  /// caller is required to keep all completion queues live until the server is
  163|       |  /// destroyed.
  164|       |  /// \param num_cqs How many completion queues does \a cqs hold.
  165|       |  virtual void Start(::grpc_impl::ServerCompletionQueue** cqs,
  166|       |                     size_t num_cqs) = 0;
  167|       |
  168|       |  virtual void ShutdownInternal(gpr_timespec deadline) = 0;
  169|       |
  170|       |  virtual int max_receive_message_size() const = 0;
  171|       |
  172|       |  virtual grpc_server* server() = 0;
  173|       |
  174|       |  virtual void PerformOpsOnCall(internal::CallOpSetInterface* ops,
  175|       |                                internal::Call* call) = 0;
  176|       |
  177|       |  class BaseAsyncRequest : public internal::CompletionQueueTag {
  178|       |   public:
  179|       |    BaseAsyncRequest(ServerInterface* server, ServerContext* context,
  180|       |                     internal::ServerAsyncStreamingInterface* stream,
  181|       |                     ::grpc_impl::CompletionQueue* call_cq,
  182|       |                     ::grpc_impl::ServerCompletionQueue* notification_cq,
  183|       |                     void* tag, bool delete_on_finalize);
  184|       |    virtual ~BaseAsyncRequest();
  185|       |
  186|       |    bool FinalizeResult(void** tag, bool* status) override;
  187|       |
  188|       |   private:
  189|       |    void ContinueFinalizeResultAfterInterception();
  190|       |
  191|       |   protected:
  192|       |    ServerInterface* const server_;
  193|       |    ServerContext* const context_;
  194|       |    internal::ServerAsyncStreamingInterface* const stream_;
  195|       |    ::grpc_impl::CompletionQueue* const call_cq_;
  196|       |    ::grpc_impl::ServerCompletionQueue* const notification_cq_;
  197|       |    void* const tag_;
  198|       |    const bool delete_on_finalize_;
  199|       |    grpc_call* call_;
  200|       |    internal::Call call_wrapper_;
  201|       |    internal::InterceptorBatchMethodsImpl interceptor_methods_;
  202|       |    bool done_intercepting_;
  203|       |  };
  204|       |
  205|       |  /// RegisteredAsyncRequest is not part of the C++ API
  206|       |  class RegisteredAsyncRequest : public BaseAsyncRequest {
  207|       |   public:
  208|       |    RegisteredAsyncRequest(ServerInterface* server, ServerContext* context,
  209|       |                           internal::ServerAsyncStreamingInterface* stream,
  210|       |                           ::grpc_impl::CompletionQueue* call_cq,
  211|       |                           ::grpc_impl::ServerCompletionQueue* notification_cq,
  212|       |                           void* tag, const char* name,
  213|       |                           internal::RpcMethod::RpcType type);
  214|       |
  215|      0|    virtual bool FinalizeResult(void** tag, bool* status) override {
  216|      0|      /* If we are done intercepting, then there is nothing more for us to do */
  217|      0|      if (done_intercepting_) {
  218|      0|        return BaseAsyncRequest::FinalizeResult(tag, status);
  219|      0|      }
  220|      0|      call_wrapper_ = ::grpc::internal::Call(
  221|      0|          call_, server_, call_cq_, server_->max_receive_message_size(),
  222|      0|          context_->set_server_rpc_info(name_, type_,
  223|      0|                                        *server_->interceptor_creators()));
  224|      0|      return BaseAsyncRequest::FinalizeResult(tag, status);
  225|      0|    }
  226|       |
  227|       |   protected:
  228|       |    void IssueRequest(void* registered_method, grpc_byte_buffer** payload,
  229|       |                      ::grpc_impl::ServerCompletionQueue* notification_cq);
  230|       |    const char* name_;
  231|       |    const internal::RpcMethod::RpcType type_;
  232|       |  };
  233|       |
  234|       |  class NoPayloadAsyncRequest final : public RegisteredAsyncRequest {
  235|       |   public:
  236|       |    NoPayloadAsyncRequest(internal::RpcServiceMethod* registered_method,
  237|       |                          ServerInterface* server, ServerContext* context,
  238|       |                          internal::ServerAsyncStreamingInterface* stream,
  239|       |                          ::grpc_impl::CompletionQueue* call_cq,
  240|       |                          ::grpc_impl::ServerCompletionQueue* notification_cq,
  241|       |                          void* tag)
  242|       |        : RegisteredAsyncRequest(
  243|       |              server, context, stream, call_cq, notification_cq, tag,
  244|      0|              registered_method->name(), registered_method->method_type()) {
  245|      0|      IssueRequest(registered_method->server_tag(), nullptr, notification_cq);
  246|      0|    }
  247|       |
  248|       |    // uses RegisteredAsyncRequest::FinalizeResult
  249|       |  };
  250|       |
  251|       |  template <class Message>
  252|       |  class PayloadAsyncRequest final : public RegisteredAsyncRequest {
  253|       |   public:
  254|       |    PayloadAsyncRequest(internal::RpcServiceMethod* registered_method,
  255|       |                        ServerInterface* server, ServerContext* context,
  256|       |                        internal::ServerAsyncStreamingInterface* stream,
  257|       |                        ::grpc_impl::CompletionQueue* call_cq,
  258|       |                        ::grpc_impl::ServerCompletionQueue* notification_cq,
  259|       |                        void* tag, Message* request)
  260|       |        : RegisteredAsyncRequest(
  261|       |              server, context, stream, call_cq, notification_cq, tag,
  262|       |              registered_method->name(), registered_method->method_type()),
  263|       |          registered_method_(registered_method),
  264|       |          server_(server),
  265|       |          context_(context),
  266|       |          stream_(stream),
  267|       |          call_cq_(call_cq),
  268|       |          notification_cq_(notification_cq),
  269|       |          tag_(tag),
  270|      0|          request_(request) {
  271|      0|      IssueRequest(registered_method->server_tag(), payload_.bbuf_ptr(),
  272|      0|                   notification_cq);
  273|      0|    }
  274|       |
  275|      0|    ~PayloadAsyncRequest() {
  276|      0|      payload_.Release();  // We do not own the payload_
  277|      0|    }
  278|       |
  279|      0|    bool FinalizeResult(void** tag, bool* status) override {
  280|      0|      /* If we are done intercepting, then there is nothing more for us to do */
  281|      0|      if (done_intercepting_) {
  282|      0|        return RegisteredAsyncRequest::FinalizeResult(tag, status);
  283|      0|      }
  284|      0|      if (*status) {
  285|      0|        if (!payload_.Valid() || !SerializationTraits<Message>::Deserialize(
  286|      0|                                      payload_.bbuf_ptr(), request_)
  287|      0|                                      .ok()) {
  288|      0|          // If deserialization fails, we cancel the call and instantiate
  289|      0|          // a new instance of ourselves to request another call.  We then
  290|      0|          // return false, which prevents the call from being returned to
  291|      0|          // the application.
  292|      0|          g_core_codegen_interface->grpc_call_cancel_with_status(
  293|      0|              call_, GRPC_STATUS_INTERNAL, "Unable to parse request", nullptr);
  294|      0|          g_core_codegen_interface->grpc_call_unref(call_);
  295|      0|          new PayloadAsyncRequest(registered_method_, server_, context_,
  296|      0|                                  stream_, call_cq_, notification_cq_, tag_,
  297|      0|                                  request_);
  298|      0|          delete this;
  299|      0|          return false;
  300|      0|        }
  301|      0|      }
  302|      0|      /* Set interception point for recv message */
  303|      0|      interceptor_methods_.AddInterceptionHookPoint(
  304|      0|          experimental::InterceptionHookPoints::POST_RECV_MESSAGE);
  305|      0|      interceptor_methods_.SetRecvMessage(request_, nullptr);
  306|      0|      return RegisteredAsyncRequest::FinalizeResult(tag, status);
  307|      0|    }
  308|       |
  309|       |   private:
  310|       |    internal::RpcServiceMethod* const registered_method_;
  311|       |    ServerInterface* const server_;
  312|       |    ServerContext* const context_;
  313|       |    internal::ServerAsyncStreamingInterface* const stream_;
  314|       |    ::grpc_impl::CompletionQueue* const call_cq_;
  315|       |
  316|       |    ::grpc_impl::ServerCompletionQueue* const notification_cq_;
  317|       |    void* const tag_;
  318|       |    Message* const request_;
  319|       |    ByteBuffer payload_;
  320|       |  };
  321|       |
  322|       |  class GenericAsyncRequest : public BaseAsyncRequest {
  323|       |   public:
  324|       |    GenericAsyncRequest(ServerInterface* server, GenericServerContext* context,
  325|       |                        internal::ServerAsyncStreamingInterface* stream,
  326|       |                        ::grpc_impl::CompletionQueue* call_cq,
  327|       |                        ::grpc_impl::ServerCompletionQueue* notification_cq,
  328|       |                        void* tag, bool delete_on_finalize);
  329|       |
  330|       |    bool FinalizeResult(void** tag, bool* status) override;
  331|       |
  332|       |   private:
  333|       |    grpc_call_details call_details_;
  334|       |  };
  335|       |
  336|       |  template <class Message>
  337|       |  void RequestAsyncCall(internal::RpcServiceMethod* method,
  338|       |                        ServerContext* context,
  339|       |                        internal::ServerAsyncStreamingInterface* stream,
  340|       |                        ::grpc_impl::CompletionQueue* call_cq,
  341|       |                        ::grpc_impl::ServerCompletionQueue* notification_cq,
  342|      0|                        void* tag, Message* message) {
  343|      0|    GPR_CODEGEN_ASSERT(method);
  344|      0|    new PayloadAsyncRequest<Message>(method, this, context, stream, call_cq,
  345|      0|                                     notification_cq, tag, message);
  346|      0|  }
  347|       |
  348|       |  void RequestAsyncCall(internal::RpcServiceMethod* method,
  349|       |                        ServerContext* context,
  350|       |                        internal::ServerAsyncStreamingInterface* stream,
  351|       |                        ::grpc_impl::CompletionQueue* call_cq,
  352|       |                        ::grpc_impl::ServerCompletionQueue* notification_cq,
  353|      0|                        void* tag) {
  354|      0|    GPR_CODEGEN_ASSERT(method);
  355|      0|    new NoPayloadAsyncRequest(method, this, context, stream, call_cq,
  356|      0|                              notification_cq, tag);
  357|      0|  }
  358|       |
  359|       |  void RequestAsyncGenericCall(
  360|       |      GenericServerContext* context,
  361|       |      internal::ServerAsyncStreamingInterface* stream,
  362|       |      ::grpc_impl::CompletionQueue* call_cq,
  363|      0|      ::grpc_impl::ServerCompletionQueue* notification_cq, void* tag) {
  364|      0|    new GenericAsyncRequest(this, context, stream, call_cq, notification_cq,
  365|      0|                            tag, true);
  366|      0|  }
  367|       |
  368|       | private:
  369|       |  // EXPERIMENTAL
  370|       |  // Getter method for the vector of interceptor factory objects.
  371|       |  // Returns a nullptr (rather than being pure) since this is a post-1.0 method
  372|       |  // and adding a new pure method to an interface would be a breaking change
  373|       |  // (even though this is private and non-API)
  374|       |  virtual std::vector<
  375|       |      std::unique_ptr<experimental::ServerInterceptorFactoryInterface>>*
  376|      0|  interceptor_creators() {
  377|      0|    return nullptr;
  378|      0|  }
  379|       |
  380|       |  // EXPERIMENTAL
  381|       |  // A method to get the callbackable completion queue associated with this
  382|       |  // server. If the return value is nullptr, this server doesn't support
  383|       |  // callback operations.
  384|       |  // TODO(vjpai): Consider a better default like using a global CQ
  385|       |  // Returns nullptr (rather than being pure) since this is a post-1.0 method
  386|       |  // and adding a new pure method to an interface would be a breaking change
  387|       |  // (even though this is private and non-API)
  388|      0|  virtual ::grpc_impl::CompletionQueue* CallbackCQ() { return nullptr; }
  389|       |};
  390|       |
  391|       |}  // namespace grpc
  392|       |
  393|       |#endif  // GRPCPP_IMPL_CODEGEN_SERVER_INTERFACE_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/service_type.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_SERVICE_TYPE_H
   20|       |#define GRPCPP_IMPL_CODEGEN_SERVICE_TYPE_H
   21|       |
   22|       |#include <grpcpp/impl/codegen/config.h>
   23|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   24|       |#include <grpcpp/impl/codegen/rpc_service_method.h>
   25|       |#include <grpcpp/impl/codegen/serialization_traits.h>
   26|       |#include <grpcpp/impl/codegen/server_interface.h>
   27|       |#include <grpcpp/impl/codegen/status.h>
   28|       |
   29|       |namespace grpc_impl {
   30|       |
   31|       |class Server;
   32|       |class CompletionQueue;
   33|       |}  // namespace grpc_impl
   34|       |namespace grpc {
   35|       |
   36|       |class ServerInterface;
   37|       |class ServerContext;
   38|       |
   39|       |namespace internal {
   40|       |class Call;
   41|       |class ServerAsyncStreamingInterface {
   42|       | public:
   43|      0|  virtual ~ServerAsyncStreamingInterface() {}
   44|       |
   45|       |  /// Request notification of the sending of initial metadata to the client.
   46|       |  /// Completion will be notified by \a tag on the associated completion
   47|       |  /// queue. This call is optional, but if it is used, it cannot be used
   48|       |  /// concurrently with or after the \a Finish method.
   49|       |  ///
   50|       |  /// \param[in] tag Tag identifying this request.
   51|       |  virtual void SendInitialMetadata(void* tag) = 0;
   52|       |
   53|       | private:
   54|       |  friend class ::grpc::ServerInterface;
   55|       |  virtual void BindCall(Call* call) = 0;
   56|       |};
   57|       |}  // namespace internal
   58|       |
   59|       |/// Desriptor of an RPC service and its various RPC methods
   60|       |class Service {
   61|       | public:
   62|      0|  Service() : server_(nullptr) {}
   63|      0|  virtual ~Service() {}
   64|       |
   65|      0|  bool has_async_methods() const {
   66|      0|    for (auto it = methods_.begin(); it != methods_.end(); ++it) {
   67|      0|      if (*it && (*it)->handler() == nullptr) {
   68|      0|        return true;
   69|      0|      }
   70|      0|    }
   71|      0|    return false;
   72|      0|  }
   73|       |
   74|      0|  bool has_synchronous_methods() const {
   75|      0|    for (auto it = methods_.begin(); it != methods_.end(); ++it) {
   76|      0|      if (*it &&
   77|      0|          (*it)->api_type() == internal::RpcServiceMethod::ApiType::SYNC) {
   78|      0|        return true;
   79|      0|      }
   80|      0|    }
   81|      0|    return false;
   82|      0|  }
   83|       |
   84|      0|  bool has_callback_methods() const {
   85|      0|    for (auto it = methods_.begin(); it != methods_.end(); ++it) {
   86|      0|      if (*it && ((*it)->api_type() ==
   87|      0|                      internal::RpcServiceMethod::ApiType::CALL_BACK ||
   88|      0|                  (*it)->api_type() ==
   89|      0|                      internal::RpcServiceMethod::ApiType::RAW_CALL_BACK)) {
   90|      0|        return true;
   91|      0|      }
   92|      0|    }
   93|      0|    return false;
   94|      0|  }
   95|       |
   96|      0|  bool has_generic_methods() const {
   97|      0|    for (auto it = methods_.begin(); it != methods_.end(); ++it) {
   98|      0|      if (it->get() == nullptr) {
   99|      0|        return true;
  100|      0|      }
  101|      0|    }
  102|      0|    return false;
  103|      0|  }
  104|       |
  105|       | protected:
  106|       |  // TODO(vjpai): Promote experimental contents once callback API is accepted
  107|       |  class experimental_type {
  108|       |   public:
  109|      0|    explicit experimental_type(Service* service) : service_(service) {}
  110|       |
  111|      0|    void MarkMethodCallback(int index, internal::MethodHandler* handler) {
  112|      0|      // This does not have to be a hard error, however no one has approached us
  113|      0|      // with a use case yet. Please file an issue if you believe you have one.
  114|      0|      size_t idx = static_cast<size_t>(index);
  115|      0|      GPR_CODEGEN_ASSERT(
  116|      0|          service_->methods_[idx].get() != nullptr &&
  117|      0|          "Cannot mark the method as 'callback' because it has already been "
  118|      0|          "marked as 'generic'.");
  119|      0|      service_->methods_[idx]->SetHandler(handler);
  120|      0|      service_->methods_[idx]->SetServerApiType(
  121|      0|          internal::RpcServiceMethod::ApiType::CALL_BACK);
  122|      0|    }
  123|       |
  124|      0|    void MarkMethodRawCallback(int index, internal::MethodHandler* handler) {
  125|      0|      // This does not have to be a hard error, however no one has approached us
  126|      0|      // with a use case yet. Please file an issue if you believe you have one.
  127|      0|      size_t idx = static_cast<size_t>(index);
  128|      0|      GPR_CODEGEN_ASSERT(
  129|      0|          service_->methods_[idx].get() != nullptr &&
  130|      0|          "Cannot mark the method as 'raw callback' because it has already "
  131|      0|          "been marked as 'generic'.");
  132|      0|      service_->methods_[idx]->SetHandler(handler);
  133|      0|      service_->methods_[idx]->SetServerApiType(
  134|      0|          internal::RpcServiceMethod::ApiType::RAW_CALL_BACK);
  135|      0|    }
  136|       |
  137|      0|    internal::MethodHandler* GetHandler(int index) {
  138|      0|      size_t idx = static_cast<size_t>(index);
  139|      0|      return service_->methods_[idx]->handler();
  140|      0|    }
  141|       |
  142|       |   private:
  143|       |    Service* service_;
  144|       |  };
  145|       |
  146|      0|  experimental_type experimental() { return experimental_type(this); }
  147|       |
  148|       |  template <class Message>
  149|       |  void RequestAsyncUnary(int index, ServerContext* context, Message* request,
  150|       |                         internal::ServerAsyncStreamingInterface* stream,
  151|       |                         CompletionQueue* call_cq,
  152|      0|                         ServerCompletionQueue* notification_cq, void* tag) {
  153|      0|    // Typecast the index to size_t for indexing into a vector
  154|      0|    // while preserving the API that existed before a compiler
  155|      0|    // warning was first seen (grpc/grpc#11664)
  156|      0|    size_t idx = static_cast<size_t>(index);
  157|      0|    server_->RequestAsyncCall(methods_[idx].get(), context, stream, call_cq,
  158|      0|                              notification_cq, tag, request);
  159|      0|  }
  160|       |  void RequestAsyncClientStreaming(
  161|       |      int index, ServerContext* context,
  162|       |      internal::ServerAsyncStreamingInterface* stream, CompletionQueue* call_cq,
  163|      0|      ServerCompletionQueue* notification_cq, void* tag) {
  164|      0|    size_t idx = static_cast<size_t>(index);
  165|      0|    server_->RequestAsyncCall(methods_[idx].get(), context, stream, call_cq,
  166|      0|                              notification_cq, tag);
  167|      0|  }
  168|       |  template <class Message>
  169|       |  void RequestAsyncServerStreaming(
  170|       |      int index, ServerContext* context, Message* request,
  171|       |      internal::ServerAsyncStreamingInterface* stream, CompletionQueue* call_cq,
  172|      0|      ServerCompletionQueue* notification_cq, void* tag) {
  173|      0|    size_t idx = static_cast<size_t>(index);
  174|      0|    server_->RequestAsyncCall(methods_[idx].get(), context, stream, call_cq,
  175|      0|                              notification_cq, tag, request);
  176|      0|  }
  177|       |  void RequestAsyncBidiStreaming(
  178|       |      int index, ServerContext* context,
  179|       |      internal::ServerAsyncStreamingInterface* stream, CompletionQueue* call_cq,
  180|      0|      ServerCompletionQueue* notification_cq, void* tag) {
  181|      0|    size_t idx = static_cast<size_t>(index);
  182|      0|    server_->RequestAsyncCall(methods_[idx].get(), context, stream, call_cq,
  183|      0|                              notification_cq, tag);
  184|      0|  }
  185|       |
  186|      0|  void AddMethod(internal::RpcServiceMethod* method) {
  187|      0|    methods_.emplace_back(method);
  188|      0|  }
  189|       |
  190|      0|  void MarkMethodAsync(int index) {
  191|      0|    // This does not have to be a hard error, however no one has approached us
  192|      0|    // with a use case yet. Please file an issue if you believe you have one.
  193|      0|    size_t idx = static_cast<size_t>(index);
  194|      0|    GPR_CODEGEN_ASSERT(
  195|      0|        methods_[idx].get() != nullptr &&
  196|      0|        "Cannot mark the method as 'async' because it has already been "
  197|      0|        "marked as 'generic'.");
  198|      0|    methods_[idx]->SetServerApiType(internal::RpcServiceMethod::ApiType::ASYNC);
  199|      0|  }
  200|       |
  201|      0|  void MarkMethodRaw(int index) {
  202|      0|    // This does not have to be a hard error, however no one has approached us
  203|      0|    // with a use case yet. Please file an issue if you believe you have one.
  204|      0|    size_t idx = static_cast<size_t>(index);
  205|      0|    GPR_CODEGEN_ASSERT(methods_[idx].get() != nullptr &&
  206|      0|                       "Cannot mark the method as 'raw' because it has already "
  207|      0|                       "been marked as 'generic'.");
  208|      0|    methods_[idx]->SetServerApiType(internal::RpcServiceMethod::ApiType::RAW);
  209|      0|  }
  210|       |
  211|      0|  void MarkMethodGeneric(int index) {
  212|      0|    // This does not have to be a hard error, however no one has approached us
  213|      0|    // with a use case yet. Please file an issue if you believe you have one.
  214|      0|    size_t idx = static_cast<size_t>(index);
  215|      0|    GPR_CODEGEN_ASSERT(
  216|      0|        methods_[idx]->handler() != nullptr &&
  217|      0|        "Cannot mark the method as 'generic' because it has already been "
  218|      0|        "marked as 'async' or 'raw'.");
  219|      0|    methods_[idx].reset();
  220|      0|  }
  221|       |
  222|      0|  void MarkMethodStreamed(int index, internal::MethodHandler* streamed_method) {
  223|      0|    // This does not have to be a hard error, however no one has approached us
  224|      0|    // with a use case yet. Please file an issue if you believe you have one.
  225|      0|    size_t idx = static_cast<size_t>(index);
  226|      0|    GPR_CODEGEN_ASSERT(methods_[idx] && methods_[idx]->handler() &&
  227|      0|                       "Cannot mark an async or generic method Streamed");
  228|      0|    methods_[idx]->SetHandler(streamed_method);
  229|      0|
  230|      0|    // From the server's point of view, streamed unary is a special
  231|      0|    // case of BIDI_STREAMING that has 1 read and 1 write, in that order,
  232|      0|    // and split server-side streaming is BIDI_STREAMING with 1 read and
  233|      0|    // any number of writes, in that order.
  234|      0|    methods_[idx]->SetMethodType(internal::RpcMethod::BIDI_STREAMING);
  235|      0|  }
  236|       |
  237|       | private:
  238|       |  friend class grpc_impl::Server;
  239|       |  friend class ServerInterface;
  240|       |  ServerInterface* server_;
  241|       |  std::vector<std::unique_ptr<internal::RpcServiceMethod>> methods_;
  242|       |};
  243|       |
  244|       |}  // namespace grpc
  245|       |
  246|       |#endif  // GRPCPP_IMPL_CODEGEN_SERVICE_TYPE_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/slice.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_SLICE_H
   20|       |#define GRPCPP_IMPL_CODEGEN_SLICE_H
   21|       |
   22|       |#include <grpcpp/impl/codegen/config.h>
   23|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   24|       |#include <grpcpp/impl/codegen/string_ref.h>
   25|       |
   26|       |#include <grpc/impl/codegen/slice.h>
   27|       |
   28|       |namespace grpc {
   29|       |
   30|       |/// A wrapper around \a grpc_slice.
   31|       |///
   32|       |/// A slice represents a contiguous reference counted array of bytes.
   33|       |/// It is cheap to take references to a slice, and it is cheap to create a
   34|       |/// slice pointing to a subset of another slice.
   35|       |class Slice final {
   36|       | public:
   37|       |  /// Construct an empty slice.
   38|      0|  Slice() : slice_(g_core_codegen_interface->grpc_empty_slice()) {}
   39|       |  /// Destructor - drops one reference.
   40|      0|  ~Slice() { g_core_codegen_interface->grpc_slice_unref(slice_); }
   41|       |
   42|       |  enum AddRef { ADD_REF };
   43|       |  /// Construct a slice from \a slice, adding a reference.
   44|       |  Slice(grpc_slice slice, AddRef)
   45|      0|      : slice_(g_core_codegen_interface->grpc_slice_ref(slice)) {}
   46|       |
   47|       |  enum StealRef { STEAL_REF };
   48|       |  /// Construct a slice from \a slice, stealing a reference.
   49|      0|  Slice(grpc_slice slice, StealRef) : slice_(slice) {}
   50|       |
   51|       |  /// Allocate a slice of specified size
   52|       |  Slice(size_t len)
   53|      0|      : slice_(g_core_codegen_interface->grpc_slice_malloc(len)) {}
   54|       |
   55|       |  /// Construct a slice from a copied buffer
   56|       |  Slice(const void* buf, size_t len)
   57|       |      : slice_(g_core_codegen_interface->grpc_slice_from_copied_buffer(
   58|      0|            reinterpret_cast<const char*>(buf), len)) {}
   59|       |
   60|       |  /// Construct a slice from a copied string
   61|       |  Slice(const grpc::string& str)
   62|       |      : slice_(g_core_codegen_interface->grpc_slice_from_copied_buffer(
   63|      0|            str.c_str(), str.length())) {}
   64|       |
   65|       |  enum StaticSlice { STATIC_SLICE };
   66|       |
   67|       |  /// Construct a slice from a static buffer
   68|       |  Slice(const void* buf, size_t len, StaticSlice)
   69|       |      : slice_(g_core_codegen_interface->grpc_slice_from_static_buffer(
   70|      0|            reinterpret_cast<const char*>(buf), len)) {}
   71|       |
   72|       |  /// Copy constructor, adds a reference.
   73|       |  Slice(const Slice& other)
   74|      0|      : slice_(g_core_codegen_interface->grpc_slice_ref(other.slice_)) {}
   75|       |
   76|       |  /// Assignment, reference count is unchanged.
   77|      0|  Slice& operator=(Slice other) {
   78|      0|    std::swap(slice_, other.slice_);
   79|      0|    return *this;
   80|      0|  }
   81|       |
   82|       |  /// Create a slice pointing at some data. Calls malloc to allocate a refcount
   83|       |  /// for the object, and arranges that destroy will be called with the
   84|       |  /// user data pointer passed in at destruction. Can be the same as buf or
   85|       |  /// different (e.g., if data is part of a larger structure that must be
   86|       |  /// destroyed when the data is no longer needed)
   87|       |  Slice(void* buf, size_t len, void (*destroy)(void*), void* user_data)
   88|       |      : slice_(g_core_codegen_interface->grpc_slice_new_with_user_data(
   89|      0|            buf, len, destroy, user_data)) {}
   90|       |
   91|       |  /// Specialization of above for common case where buf == user_data
   92|       |  Slice(void* buf, size_t len, void (*destroy)(void*))
   93|      0|      : Slice(buf, len, destroy, buf) {}
   94|       |
   95|       |  /// Similar to the above but has a destroy that also takes slice length
   96|       |  Slice(void* buf, size_t len, void (*destroy)(void*, size_t))
   97|       |      : slice_(g_core_codegen_interface->grpc_slice_new_with_len(buf, len,
   98|      0|                                                                 destroy)) {}
   99|       |
  100|       |  /// Byte size.
  101|      0|  size_t size() const { return GRPC_SLICE_LENGTH(slice_); }
  102|       |
  103|       |  /// Raw pointer to the beginning (first element) of the slice.
  104|      0|  const uint8_t* begin() const { return GRPC_SLICE_START_PTR(slice_); }
  105|       |
  106|       |  /// Raw pointer to the end (one byte \em past the last element) of the slice.
  107|      0|  const uint8_t* end() const { return GRPC_SLICE_END_PTR(slice_); }
  108|       |
  109|       |  /// Raw C slice. Caller needs to call grpc_slice_unref when done.
  110|      0|  grpc_slice c_slice() const {
  111|      0|    return g_core_codegen_interface->grpc_slice_ref(slice_);
  112|      0|  }
  113|       |
  114|       | private:
  115|       |  friend class ByteBuffer;
  116|       |
  117|       |  grpc_slice slice_;
  118|       |};
  119|       |
  120|      0|inline grpc::string_ref StringRefFromSlice(const grpc_slice* slice) {
  121|      0|  return grpc::string_ref(
  122|      0|      reinterpret_cast<const char*>(GRPC_SLICE_START_PTR(*slice)),
  123|      0|      GRPC_SLICE_LENGTH(*slice));
  124|      0|}
  125|       |
  126|      0|inline grpc::string StringFromCopiedSlice(grpc_slice slice) {
  127|      0|  return grpc::string(reinterpret_cast<char*>(GRPC_SLICE_START_PTR(slice)),
  128|      0|                      GRPC_SLICE_LENGTH(slice));
  129|      0|}
  130|       |
  131|      0|inline grpc_slice SliceReferencingString(const grpc::string& str) {
  132|      0|  return g_core_codegen_interface->grpc_slice_from_static_buffer(str.data(),
  133|      0|                                                                 str.length());
  134|      0|}
  135|       |
  136|      0|inline grpc_slice SliceFromCopiedString(const grpc::string& str) {
  137|      0|  return g_core_codegen_interface->grpc_slice_from_copied_buffer(str.data(),
  138|      0|                                                                 str.length());
  139|      0|}
  140|       |
  141|       |}  // namespace grpc
  142|       |
  143|       |#endif  // GRPCPP_IMPL_CODEGEN_SLICE_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/status.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_STATUS_H
   20|       |#define GRPCPP_IMPL_CODEGEN_STATUS_H
   21|       |
   22|       |#include <grpc/impl/codegen/status.h>
   23|       |#include <grpcpp/impl/codegen/config.h>
   24|       |#include <grpcpp/impl/codegen/status_code_enum.h>
   25|       |
   26|       |namespace grpc {
   27|       |
   28|       |/// Did it work? If it didn't, why?
   29|       |///
   30|       |/// See \a grpc::StatusCode for details on the available code and their meaning.
   31|       |class Status {
   32|       | public:
   33|       |  /// Construct an OK instance.
   34|      1|  Status() : code_(StatusCode::OK) {
   35|      1|    // Static assertions to make sure that the C++ API value correctly
   36|      1|    // maps to the core surface API value
   37|      1|    static_assert(StatusCode::OK == static_cast<StatusCode>(GRPC_STATUS_OK),
   38|      1|                  "Mismatched status code");
   39|      1|    static_assert(
   40|      1|        StatusCode::CANCELLED == static_cast<StatusCode>(GRPC_STATUS_CANCELLED),
   41|      1|        "Mismatched status code");
   42|      1|    static_assert(
   43|      1|        StatusCode::UNKNOWN == static_cast<StatusCode>(GRPC_STATUS_UNKNOWN),
   44|      1|        "Mismatched status code");
   45|      1|    static_assert(StatusCode::INVALID_ARGUMENT ==
   46|      1|                      static_cast<StatusCode>(GRPC_STATUS_INVALID_ARGUMENT),
   47|      1|                  "Mismatched status code");
   48|      1|    static_assert(StatusCode::DEADLINE_EXCEEDED ==
   49|      1|                      static_cast<StatusCode>(GRPC_STATUS_DEADLINE_EXCEEDED),
   50|      1|                  "Mismatched status code");
   51|      1|    static_assert(
   52|      1|        StatusCode::NOT_FOUND == static_cast<StatusCode>(GRPC_STATUS_NOT_FOUND),
   53|      1|        "Mismatched status code");
   54|      1|    static_assert(StatusCode::ALREADY_EXISTS ==
   55|      1|                      static_cast<StatusCode>(GRPC_STATUS_ALREADY_EXISTS),
   56|      1|                  "Mismatched status code");
   57|      1|    static_assert(StatusCode::PERMISSION_DENIED ==
   58|      1|                      static_cast<StatusCode>(GRPC_STATUS_PERMISSION_DENIED),
   59|      1|                  "Mismatched status code");
   60|      1|    static_assert(StatusCode::UNAUTHENTICATED ==
   61|      1|                      static_cast<StatusCode>(GRPC_STATUS_UNAUTHENTICATED),
   62|      1|                  "Mismatched status code");
   63|      1|    static_assert(StatusCode::RESOURCE_EXHAUSTED ==
   64|      1|                      static_cast<StatusCode>(GRPC_STATUS_RESOURCE_EXHAUSTED),
   65|      1|                  "Mismatched status code");
   66|      1|    static_assert(StatusCode::FAILED_PRECONDITION ==
   67|      1|                      static_cast<StatusCode>(GRPC_STATUS_FAILED_PRECONDITION),
   68|      1|                  "Mismatched status code");
   69|      1|    static_assert(
   70|      1|        StatusCode::ABORTED == static_cast<StatusCode>(GRPC_STATUS_ABORTED),
   71|      1|        "Mismatched status code");
   72|      1|    static_assert(StatusCode::OUT_OF_RANGE ==
   73|      1|                      static_cast<StatusCode>(GRPC_STATUS_OUT_OF_RANGE),
   74|      1|                  "Mismatched status code");
   75|      1|    static_assert(StatusCode::UNIMPLEMENTED ==
   76|      1|                      static_cast<StatusCode>(GRPC_STATUS_UNIMPLEMENTED),
   77|      1|                  "Mismatched status code");
   78|      1|    static_assert(
   79|      1|        StatusCode::INTERNAL == static_cast<StatusCode>(GRPC_STATUS_INTERNAL),
   80|      1|        "Mismatched status code");
   81|      1|    static_assert(StatusCode::UNAVAILABLE ==
   82|      1|                      static_cast<StatusCode>(GRPC_STATUS_UNAVAILABLE),
   83|      1|                  "Mismatched status code");
   84|      1|    static_assert(
   85|      1|        StatusCode::DATA_LOSS == static_cast<StatusCode>(GRPC_STATUS_DATA_LOSS),
   86|      1|        "Mismatched status code");
   87|      1|  }
   88|       |
   89|       |  /// Construct an instance with associated \a code and \a error_message.
   90|       |  /// It is an error to construct an OK status with non-empty \a error_message.
   91|       |  Status(StatusCode code, const grpc::string& error_message)
   92|      1|      : code_(code), error_message_(error_message) {}
   93|       |
   94|       |  /// Construct an instance with \a code,  \a error_message and
   95|       |  /// \a error_details. It is an error to construct an OK status with non-empty
   96|       |  /// \a error_message and/or \a error_details.
   97|       |  Status(StatusCode code, const grpc::string& error_message,
   98|       |         const grpc::string& error_details)
   99|       |      : code_(code),
  100|       |        error_message_(error_message),
  101|      0|        binary_error_details_(error_details) {}
  102|       |
  103|       |  // Pre-defined special status objects.
  104|       |  /// An OK pre-defined instance.
  105|       |  static const Status& OK;
  106|       |  /// A CANCELLED pre-defined instance.
  107|       |  static const Status& CANCELLED;
  108|       |
  109|       |  /// Return the instance's error code.
  110|      0|  StatusCode error_code() const { return code_; }
  111|       |  /// Return the instance's error message.
  112|      0|  grpc::string error_message() const { return error_message_; }
  113|       |  /// Return the (binary) error details.
  114|       |  // Usually it contains a serialized google.rpc.Status proto.
  115|      0|  grpc::string error_details() const { return binary_error_details_; }
  116|       |
  117|       |  /// Is the status OK?
  118|      0|  bool ok() const { return code_ == StatusCode::OK; }
  119|       |
  120|       |  // Ignores any errors. This method does nothing except potentially suppress
  121|       |  // complaints from any tools that are checking that errors are not dropped on
  122|       |  // the floor.
  123|      0|  void IgnoreError() const {}
  124|       |
  125|       | private:
  126|       |  StatusCode code_;
  127|       |  grpc::string error_message_;
  128|       |  grpc::string binary_error_details_;
  129|       |};
  130|       |
  131|       |}  // namespace grpc
  132|       |
  133|       |#endif  // GRPCPP_IMPL_CODEGEN_STATUS_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/string_ref.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_STRING_REF_H
   20|       |#define GRPCPP_IMPL_CODEGEN_STRING_REF_H
   21|       |
   22|       |#include <string.h>
   23|       |
   24|       |#include <algorithm>
   25|       |#include <iosfwd>
   26|       |#include <iostream>
   27|       |#include <iterator>
   28|       |
   29|       |#include <grpcpp/impl/codegen/config.h>
   30|       |
   31|       |namespace grpc {
   32|       |
   33|       |/// This class is a non owning reference to a string.
   34|       |///
   35|       |/// It should be a strict subset of the upcoming std::string_ref.
   36|       |///
   37|       |/// \see http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3442.html
   38|       |///
   39|       |/// The constexpr is dropped or replaced with const for legacy compiler
   40|       |/// compatibility.
   41|       |class string_ref {
   42|       | public:
   43|       |  /// types
   44|       |  typedef const char* const_iterator;
   45|       |  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
   46|       |
   47|       |  /// constants
   48|       |  const static size_t npos;
   49|       |
   50|       |  /// construct/copy.
   51|      0|  string_ref() : data_(nullptr), length_(0) {}
   52|       |  string_ref(const string_ref& other)
   53|      0|      : data_(other.data_), length_(other.length_) {}
   54|      0|  string_ref& operator=(const string_ref& rhs) {
   55|      0|    data_ = rhs.data_;
   56|      0|    length_ = rhs.length_;
   57|      0|    return *this;
   58|      0|  }
   59|       |
   60|      0|  string_ref(const char* s) : data_(s), length_(strlen(s)) {}
   61|      0|  string_ref(const char* s, size_t l) : data_(s), length_(l) {}
   62|      0|  string_ref(const grpc::string& s) : data_(s.data()), length_(s.length()) {}
   63|       |
   64|       |  /// iterators
   65|      0|  const_iterator begin() const { return data_; }
   66|      0|  const_iterator end() const { return data_ + length_; }
   67|      0|  const_iterator cbegin() const { return data_; }
   68|      0|  const_iterator cend() const { return data_ + length_; }
   69|      0|  const_reverse_iterator rbegin() const {
   70|      0|    return const_reverse_iterator(end());
   71|      0|  }
   72|      0|  const_reverse_iterator rend() const {
   73|      0|    return const_reverse_iterator(begin());
   74|      0|  }
   75|      0|  const_reverse_iterator crbegin() const {
   76|      0|    return const_reverse_iterator(end());
   77|      0|  }
   78|      0|  const_reverse_iterator crend() const {
   79|      0|    return const_reverse_iterator(begin());
   80|      0|  }
   81|       |
   82|       |  /// capacity
   83|      0|  size_t size() const { return length_; }
   84|      0|  size_t length() const { return length_; }
   85|      0|  size_t max_size() const { return length_; }
   86|      0|  bool empty() const { return length_ == 0; }
   87|       |
   88|       |  /// element access
   89|      0|  const char* data() const { return data_; }
   90|       |
   91|       |  /// string operations
   92|      0|  int compare(string_ref x) const {
   93|      0|    size_t min_size = length_ < x.length_ ? length_ : x.length_;
   94|      0|    int r = memcmp(data_, x.data_, min_size);
   95|      0|    if (r < 0) return -1;
   96|      0|    if (r > 0) return 1;
   97|      0|    if (length_ < x.length_) return -1;
   98|      0|    if (length_ > x.length_) return 1;
   99|      0|    return 0;
  100|      0|  }
  101|       |
  102|      0|  bool starts_with(string_ref x) const {
  103|      0|    return length_ >= x.length_ && (memcmp(data_, x.data_, x.length_) == 0);
  104|      0|  }
  105|       |
  106|      0|  bool ends_with(string_ref x) const {
  107|      0|    return length_ >= x.length_ &&
  108|      0|           (memcmp(data_ + (length_ - x.length_), x.data_, x.length_) == 0);
  109|      0|  }
  110|       |
  111|      0|  size_t find(string_ref s) const {
  112|      0|    auto it = std::search(cbegin(), cend(), s.cbegin(), s.cend());
  113|      0|    return it == cend() ? npos : std::distance(cbegin(), it);
  114|      0|  }
  115|       |
  116|      0|  size_t find(char c) const {
  117|      0|    auto it = std::find(cbegin(), cend(), c);
  118|      0|    return it == cend() ? npos : std::distance(cbegin(), it);
  119|      0|  }
  120|       |
  121|      0|  string_ref substr(size_t pos, size_t n = npos) const {
  122|      0|    if (pos > length_) pos = length_;
  123|      0|    if (n > (length_ - pos)) n = length_ - pos;
  124|      0|    return string_ref(data_ + pos, n);
  125|      0|  }
  126|       |
  127|       | private:
  128|       |  const char* data_;
  129|       |  size_t length_;
  130|       |};
  131|       |
  132|       |/// Comparison operators
  133|      0|inline bool operator==(string_ref x, string_ref y) { return x.compare(y) == 0; }
  134|      0|inline bool operator!=(string_ref x, string_ref y) { return x.compare(y) != 0; }
  135|      0|inline bool operator<(string_ref x, string_ref y) { return x.compare(y) < 0; }
  136|      0|inline bool operator<=(string_ref x, string_ref y) { return x.compare(y) <= 0; }
  137|      0|inline bool operator>(string_ref x, string_ref y) { return x.compare(y) > 0; }
  138|      0|inline bool operator>=(string_ref x, string_ref y) { return x.compare(y) >= 0; }
  139|       |
  140|      0|inline std::ostream& operator<<(std::ostream& out, const string_ref& string) {
  141|      0|  return out << grpc::string(string.begin(), string.end());
  142|      0|}
  143|       |
  144|       |}  // namespace grpc
  145|       |
  146|       |#endif  // GRPCPP_IMPL_CODEGEN_STRING_REF_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/sync.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2019 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_SYNC_H
   20|       |#define GRPCPP_IMPL_CODEGEN_SYNC_H
   21|       |
   22|       |#include <grpc/impl/codegen/port_platform.h>
   23|       |
   24|       |#ifdef GPR_HAS_PTHREAD_H
   25|       |#include <pthread.h>
   26|       |#endif
   27|       |
   28|       |#include <mutex>
   29|       |
   30|       |#include <grpc/impl/codegen/log.h>
   31|       |#include <grpc/impl/codegen/sync.h>
   32|       |
   33|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   34|       |
   35|       |// The core library is not accessible in C++ codegen headers, and vice versa.
   36|       |// Thus, we need to have duplicate headers with similar functionality.
   37|       |// Make sure any change to this file is also reflected in
   38|       |// src/core/lib/gprpp/sync.h too.
   39|       |//
   40|       |// Whenever possible, prefer "src/core/lib/gprpp/sync.h" over this file,
   41|       |// since in core we do not rely on g_core_codegen_interface and hence do not
   42|       |// pay the costs of virtual function calls.
   43|       |
   44|       |namespace grpc {
   45|       |namespace internal {
   46|       |
   47|       |class Mutex {
   48|       | public:
   49|      0|  Mutex() { g_core_codegen_interface->gpr_mu_init(&mu_); }
   50|      0|  ~Mutex() { g_core_codegen_interface->gpr_mu_destroy(&mu_); }
   51|       |
   52|       |  Mutex(const Mutex&) = delete;
   53|       |  Mutex& operator=(const Mutex&) = delete;
   54|       |
   55|      0|  gpr_mu* get() { return &mu_; }
   56|      0|  const gpr_mu* get() const { return &mu_; }
   57|       |
   58|       | private:
   59|       |  union {
   60|       |    gpr_mu mu_;
   61|       |    std::mutex do_not_use_sth_;
   62|       |#ifdef GPR_HAS_PTHREAD_H
   63|       |    pthread_mutex_t do_not_use_pth_;
   64|       |#endif
   65|       |  };
   66|       |};
   67|       |
   68|       |// MutexLock is a std::
   69|       |class MutexLock {
   70|       | public:
   71|      0|  explicit MutexLock(Mutex* mu) : mu_(mu->get()) {
   72|      0|    g_core_codegen_interface->gpr_mu_lock(mu_);
   73|      0|  }
   74|      0|  explicit MutexLock(gpr_mu* mu) : mu_(mu) {
   75|      0|    g_core_codegen_interface->gpr_mu_lock(mu_);
   76|      0|  }
   77|      0|  ~MutexLock() { g_core_codegen_interface->gpr_mu_unlock(mu_); }
   78|       |
   79|       |  MutexLock(const MutexLock&) = delete;
   80|       |  MutexLock& operator=(const MutexLock&) = delete;
   81|       |
   82|       | private:
   83|       |  gpr_mu* const mu_;
   84|       |};
   85|       |
   86|       |class ReleasableMutexLock {
   87|       | public:
   88|      0|  explicit ReleasableMutexLock(Mutex* mu) : mu_(mu->get()) {
   89|      0|    g_core_codegen_interface->gpr_mu_lock(mu_);
   90|      0|  }
   91|      0|  explicit ReleasableMutexLock(gpr_mu* mu) : mu_(mu) {
   92|      0|    g_core_codegen_interface->gpr_mu_lock(mu_);
   93|      0|  }
   94|      0|  ~ReleasableMutexLock() {
   95|      0|    if (!released_) g_core_codegen_interface->gpr_mu_unlock(mu_);
   96|      0|  }
   97|       |
   98|       |  ReleasableMutexLock(const ReleasableMutexLock&) = delete;
   99|       |  ReleasableMutexLock& operator=(const ReleasableMutexLock&) = delete;
  100|       |
  101|      0|  void Lock() {
  102|      0|    GPR_DEBUG_ASSERT(released_);
  103|      0|    g_core_codegen_interface->gpr_mu_lock(mu_);
  104|      0|    released_ = false;
  105|      0|  }
  106|       |
  107|      0|  void Unlock() {
  108|      0|    GPR_DEBUG_ASSERT(!released_);
  109|      0|    released_ = true;
  110|      0|    g_core_codegen_interface->gpr_mu_unlock(mu_);
  111|      0|  }
  112|       |
  113|       | private:
  114|       |  gpr_mu* const mu_;
  115|       |  bool released_ = false;
  116|       |};
  117|       |
  118|       |class CondVar {
  119|       | public:
  120|      0|  CondVar() { g_core_codegen_interface->gpr_cv_init(&cv_); }
  121|      0|  ~CondVar() { g_core_codegen_interface->gpr_cv_destroy(&cv_); }
  122|       |
  123|       |  CondVar(const CondVar&) = delete;
  124|       |  CondVar& operator=(const CondVar&) = delete;
  125|       |
  126|      0|  void Signal() { g_core_codegen_interface->gpr_cv_signal(&cv_); }
  127|      0|  void Broadcast() { g_core_codegen_interface->gpr_cv_broadcast(&cv_); }
  128|       |
  129|      0|  int Wait(Mutex* mu) {
  130|      0|    return Wait(mu,
  131|      0|                g_core_codegen_interface->gpr_inf_future(GPR_CLOCK_REALTIME));
  132|      0|  }
  133|      0|  int Wait(Mutex* mu, const gpr_timespec& deadline) {
  134|      0|    return g_core_codegen_interface->gpr_cv_wait(&cv_, mu->get(), deadline);
  135|      0|  }
  136|       |
  137|       |  template <typename Predicate>
  138|      0|  void WaitUntil(Mutex* mu, Predicate pred) {
  139|      0|    while (!pred()) {
  140|      0|      Wait(mu, g_core_codegen_interface->gpr_inf_future(GPR_CLOCK_REALTIME));
  141|      0|    }
  142|      0|  }
  143|       |
  144|       | private:
  145|       |  gpr_cv cv_;
  146|       |};
  147|       |
  148|       |}  // namespace internal
  149|       |}  // namespace grpc
  150|       |
  151|       |#endif  // GRPCPP_IMPL_CODEGEN_SYNC_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/sync_stream.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_SYNC_STREAM_H
   20|       |#define GRPCPP_IMPL_CODEGEN_SYNC_STREAM_H
   21|       |
   22|       |#include <grpcpp/impl/codegen/call.h>
   23|       |#include <grpcpp/impl/codegen/channel_interface.h>
   24|       |#include <grpcpp/impl/codegen/client_context.h>
   25|       |#include <grpcpp/impl/codegen/completion_queue.h>
   26|       |#include <grpcpp/impl/codegen/core_codegen_interface.h>
   27|       |#include <grpcpp/impl/codegen/server_context.h>
   28|       |#include <grpcpp/impl/codegen/service_type.h>
   29|       |#include <grpcpp/impl/codegen/status.h>
   30|       |
   31|       |namespace grpc {
   32|       |
   33|       |namespace internal {
   34|       |/// Common interface for all synchronous client side streaming.
   35|       |class ClientStreamingInterface {
   36|       | public:
   37|      0|  virtual ~ClientStreamingInterface() {}
   38|       |
   39|       |  /// Block waiting until the stream finishes and a final status of the call is
   40|       |  /// available.
   41|       |  ///
   42|       |  /// It is appropriate to call this method when both:
   43|       |  ///   * the calling code (client-side) has no more message to send
   44|       |  ///     (this can be declared implicitly by calling this method, or
   45|       |  ///     explicitly through an earlier call to <i>WritesDone</i> method of the
   46|       |  ///     class in use, e.g. \a ClientWriterInterface::WritesDone or
   47|       |  ///     \a ClientReaderWriterInterface::WritesDone).
   48|       |  ///   * there are no more messages to be received from the server (which can
   49|       |  ///     be known implicitly, or explicitly from an earlier call to \a
   50|       |  ///     ReaderInterface::Read that returned "false").
   51|       |  ///
   52|       |  /// This function will return either:
   53|       |  /// - when all incoming messages have been read and the server has
   54|       |  ///   returned status.
   55|       |  /// - when the server has returned a non-OK status.
   56|       |  /// - OR when the call failed for some reason and the library generated a
   57|       |  ///   status.
   58|       |  ///
   59|       |  /// Return values:
   60|       |  ///   - \a Status contains the status code, message and details for the call
   61|       |  ///   - the \a ClientContext associated with this call is updated with
   62|       |  ///     possible trailing metadata sent from the server.
   63|       |  virtual Status Finish() = 0;
   64|       |};
   65|       |
   66|       |/// Common interface for all synchronous server side streaming.
   67|       |class ServerStreamingInterface {
   68|       | public:
   69|      0|  virtual ~ServerStreamingInterface() {}
   70|       |
   71|       |  /// Block to send initial metadata to client.
   72|       |  /// This call is optional, but if it is used, it cannot be used concurrently
   73|       |  /// with or after the \a Finish method.
   74|       |  ///
   75|       |  /// The initial metadata that will be sent to the client will be
   76|       |  /// taken from the \a ServerContext associated with the call.
   77|       |  virtual void SendInitialMetadata() = 0;
   78|       |};
   79|       |
   80|       |/// An interface that yields a sequence of messages of type \a R.
   81|       |template <class R>
   82|       |class ReaderInterface {
   83|       | public:
   84|       |  virtual ~ReaderInterface() {}
   85|       |
   86|       |  /// Get an upper bound on the next message size available for reading on this
   87|       |  /// stream.
   88|       |  virtual bool NextMessageSize(uint32_t* sz) = 0;
   89|       |
   90|       |  /// Block to read a message and parse to \a msg. Returns \a true on success.
   91|       |  /// This is thread-safe with respect to \a Write or \WritesDone methods on
   92|       |  /// the same stream. It should not be called concurrently with another \a
   93|       |  /// Read on the same stream as the order of delivery will not be defined.
   94|       |  ///
   95|       |  /// \param[out] msg The read message.
   96|       |  ///
   97|       |  /// \return \a false when there will be no more incoming messages, either
   98|       |  /// because the other side has called \a WritesDone() or the stream has failed
   99|       |  /// (or been cancelled).
  100|       |  virtual bool Read(R* msg) = 0;
  101|       |};
  102|       |
  103|       |/// An interface that can be fed a sequence of messages of type \a W.
  104|       |template <class W>
  105|       |class WriterInterface {
  106|       | public:
  107|       |  virtual ~WriterInterface() {}
  108|       |
  109|       |  /// Block to write \a msg to the stream with WriteOptions \a options.
  110|       |  /// This is thread-safe with respect to \a ReaderInterface::Read
  111|       |  ///
  112|       |  /// \param msg The message to be written to the stream.
  113|       |  /// \param options The WriteOptions affecting the write operation.
  114|       |  ///
  115|       |  /// \return \a true on success, \a false when the stream has been closed.
  116|       |  virtual bool Write(const W& msg, WriteOptions options) = 0;
  117|       |
  118|       |  /// Block to write \a msg to the stream with default write options.
  119|       |  /// This is thread-safe with respect to \a ReaderInterface::Read
  120|       |  ///
  121|       |  /// \param msg The message to be written to the stream.
  122|       |  ///
  123|       |  /// \return \a true on success, \a false when the stream has been closed.
  124|       |  inline bool Write(const W& msg) { return Write(msg, WriteOptions()); }
  125|       |
  126|       |  /// Write \a msg and coalesce it with the writing of trailing metadata, using
  127|       |  /// WriteOptions \a options.
  128|       |  ///
  129|       |  /// For client, WriteLast is equivalent of performing Write and WritesDone in
  130|       |  /// a single step. \a msg and trailing metadata are coalesced and sent on wire
  131|       |  /// by calling this function. For server, WriteLast buffers the \a msg.
  132|       |  /// The writing of \a msg is held until the service handler returns,
  133|       |  /// where \a msg and trailing metadata are coalesced and sent on wire.
  134|       |  /// Note that WriteLast can only buffer \a msg up to the flow control window
  135|       |  /// size. If \a msg size is larger than the window size, it will be sent on
  136|       |  /// wire without buffering.
  137|       |  ///
  138|       |  /// \param[in] msg The message to be written to the stream.
  139|       |  /// \param[in] options The WriteOptions to be used to write this message.
  140|       |  void WriteLast(const W& msg, WriteOptions options) {
  141|       |    Write(msg, options.set_last_message());
  142|       |  }
  143|       |};
  144|       |
  145|       |}  // namespace internal
  146|       |
  147|       |/// Client-side interface for streaming reads of message of type \a R.
  148|       |template <class R>
  149|       |class ClientReaderInterface : public internal::ClientStreamingInterface,
  150|       |                              public internal::ReaderInterface<R> {
  151|       | public:
  152|       |  /// Block to wait for initial metadata from server. The received metadata
  153|       |  /// can only be accessed after this call returns. Should only be called before
  154|       |  /// the first read. Calling this method is optional, and if it is not called
  155|       |  /// the metadata will be available in ClientContext after the first read.
  156|       |  virtual void WaitForInitialMetadata() = 0;
  157|       |};
  158|       |
  159|       |namespace internal {
  160|       |template <class R>
  161|       |class ClientReaderFactory {
  162|       | public:
  163|       |  template <class W>
  164|       |  static ClientReader<R>* Create(ChannelInterface* channel,
  165|       |                                 const ::grpc::internal::RpcMethod& method,
  166|       |                                 ClientContext* context, const W& request) {
  167|       |    return new ClientReader<R>(channel, method, context, request);
  168|       |  }
  169|       |};
  170|       |}  // namespace internal
  171|       |
  172|       |/// Synchronous (blocking) client-side API for doing server-streaming RPCs,
  173|       |/// where the stream of messages coming from the server has messages
  174|       |/// of type \a R.
  175|       |template <class R>
  176|       |class ClientReader final : public ClientReaderInterface<R> {
  177|       | public:
  178|       |  /// See the \a ClientStreamingInterface.WaitForInitialMetadata method for
  179|       |  /// semantics.
  180|       |  ///
  181|       |  //  Side effect:
  182|       |  ///   Once complete, the initial metadata read from
  183|       |  ///   the server will be accessible through the \a ClientContext used to
  184|       |  ///   construct this object.
  185|       |  void WaitForInitialMetadata() override {
  186|       |    GPR_CODEGEN_ASSERT(!context_->initial_metadata_received_);
  187|       |
  188|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata>
  189|       |        ops;
  190|       |    ops.RecvInitialMetadata(context_);
  191|       |    call_.PerformOps(&ops);
  192|       |    cq_.Pluck(&ops);  /// status ignored
  193|       |  }
  194|       |
  195|       |  bool NextMessageSize(uint32_t* sz) override {
  196|       |    *sz = call_.max_receive_message_size();
  197|       |    return true;
  198|       |  }
  199|       |
  200|       |  /// See the \a ReaderInterface.Read method for semantics.
  201|       |  /// Side effect:
  202|       |  ///   This also receives initial metadata from the server, if not
  203|       |  ///   already received (if initial metadata is received, it can be then
  204|       |  ///   accessed through the \a ClientContext associated with this call).
  205|       |  bool Read(R* msg) override {
  206|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata,
  207|       |                                ::grpc::internal::CallOpRecvMessage<R>>
  208|       |        ops;
  209|       |    if (!context_->initial_metadata_received_) {
  210|       |      ops.RecvInitialMetadata(context_);
  211|       |    }
  212|       |    ops.RecvMessage(msg);
  213|       |    call_.PerformOps(&ops);
  214|       |    return cq_.Pluck(&ops) && ops.got_message;
  215|       |  }
  216|       |
  217|       |  /// See the \a ClientStreamingInterface.Finish method for semantics.
  218|       |  ///
  219|       |  /// Side effect:
  220|       |  ///   The \a ClientContext associated with this call is updated with
  221|       |  ///   possible metadata received from the server.
  222|       |  Status Finish() override {
  223|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpClientRecvStatus> ops;
  224|       |    Status status;
  225|       |    ops.ClientRecvStatus(context_, &status);
  226|       |    call_.PerformOps(&ops);
  227|       |    GPR_CODEGEN_ASSERT(cq_.Pluck(&ops));
  228|       |    return status;
  229|       |  }
  230|       |
  231|       | private:
  232|       |  friend class internal::ClientReaderFactory<R>;
  233|       |  ClientContext* context_;
  234|       |  CompletionQueue cq_;
  235|       |  ::grpc::internal::Call call_;
  236|       |
  237|       |  /// Block to create a stream and write the initial metadata and \a request
  238|       |  /// out. Note that \a context will be used to fill in custom initial
  239|       |  /// metadata used to send to the server when starting the call.
  240|       |  template <class W>
  241|       |  ClientReader(::grpc::ChannelInterface* channel,
  242|       |               const ::grpc::internal::RpcMethod& method,
  243|       |               ClientContext* context, const W& request)
  244|       |      : context_(context),
  245|       |        cq_(grpc_completion_queue_attributes{
  246|       |            GRPC_CQ_CURRENT_VERSION, GRPC_CQ_PLUCK, GRPC_CQ_DEFAULT_POLLING,
  247|       |            nullptr}),  // Pluckable cq
  248|       |        call_(channel->CreateCall(method, context, &cq_)) {
  249|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  250|       |                                ::grpc::internal::CallOpSendMessage,
  251|       |                                ::grpc::internal::CallOpClientSendClose>
  252|       |        ops;
  253|       |    ops.SendInitialMetadata(&context->send_initial_metadata_,
  254|       |                            context->initial_metadata_flags());
  255|       |    // TODO(ctiller): don't assert
  256|       |    GPR_CODEGEN_ASSERT(ops.SendMessagePtr(&request).ok());
  257|       |    ops.ClientSendClose();
  258|       |    call_.PerformOps(&ops);
  259|       |    cq_.Pluck(&ops);
  260|       |  }
  261|       |};
  262|       |
  263|       |/// Client-side interface for streaming writes of message type \a W.
  264|       |template <class W>
  265|       |class ClientWriterInterface : public internal::ClientStreamingInterface,
  266|       |                              public internal::WriterInterface<W> {
  267|       | public:
  268|       |  /// Half close writing from the client. (signal that the stream of messages
  269|       |  /// coming from the client is complete).
  270|       |  /// Blocks until currently-pending writes are completed.
  271|       |  /// Thread safe with respect to \a ReaderInterface::Read operations only
  272|       |  ///
  273|       |  /// \return Whether the writes were successful.
  274|       |  virtual bool WritesDone() = 0;
  275|       |};
  276|       |
  277|       |namespace internal {
  278|       |template <class W>
  279|       |class ClientWriterFactory {
  280|       | public:
  281|       |  template <class R>
  282|       |  static ClientWriter<W>* Create(::grpc::ChannelInterface* channel,
  283|       |                                 const ::grpc::internal::RpcMethod& method,
  284|       |                                 ClientContext* context, R* response) {
  285|       |    return new ClientWriter<W>(channel, method, context, response);
  286|       |  }
  287|       |};
  288|       |}  // namespace internal
  289|       |
  290|       |/// Synchronous (blocking) client-side API for doing client-streaming RPCs,
  291|       |/// where the outgoing message stream coming from the client has messages of
  292|       |/// type \a W.
  293|       |template <class W>
  294|       |class ClientWriter : public ClientWriterInterface<W> {
  295|       | public:
  296|       |  /// See the \a ClientStreamingInterface.WaitForInitialMetadata method for
  297|       |  /// semantics.
  298|       |  ///
  299|       |  //  Side effect:
  300|       |  ///   Once complete, the initial metadata read from the server will be
  301|       |  ///   accessible through the \a ClientContext used to construct this object.
  302|       |  void WaitForInitialMetadata() {
  303|       |    GPR_CODEGEN_ASSERT(!context_->initial_metadata_received_);
  304|       |
  305|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata>
  306|       |        ops;
  307|       |    ops.RecvInitialMetadata(context_);
  308|       |    call_.PerformOps(&ops);
  309|       |    cq_.Pluck(&ops);  // status ignored
  310|       |  }
  311|       |
  312|       |  /// See the WriterInterface.Write(const W& msg, WriteOptions options) method
  313|       |  /// for semantics.
  314|       |  ///
  315|       |  /// Side effect:
  316|       |  ///   Also sends initial metadata if not already sent (using the
  317|       |  ///   \a ClientContext associated with this call).
  318|       |  using ::grpc::internal::WriterInterface<W>::Write;
  319|       |  bool Write(const W& msg, WriteOptions options) override {
  320|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  321|       |                                ::grpc::internal::CallOpSendMessage,
  322|       |                                ::grpc::internal::CallOpClientSendClose>
  323|       |        ops;
  324|       |
  325|       |    if (options.is_last_message()) {
  326|       |      options.set_buffer_hint();
  327|       |      ops.ClientSendClose();
  328|       |    }
  329|       |    if (context_->initial_metadata_corked_) {
  330|       |      ops.SendInitialMetadata(&context_->send_initial_metadata_,
  331|       |                              context_->initial_metadata_flags());
  332|       |      context_->set_initial_metadata_corked(false);
  333|       |    }
  334|       |    if (!ops.SendMessagePtr(&msg, options).ok()) {
  335|       |      return false;
  336|       |    }
  337|       |
  338|       |    call_.PerformOps(&ops);
  339|       |    return cq_.Pluck(&ops);
  340|       |  }
  341|       |
  342|       |  bool WritesDone() override {
  343|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpClientSendClose> ops;
  344|       |    ops.ClientSendClose();
  345|       |    call_.PerformOps(&ops);
  346|       |    return cq_.Pluck(&ops);
  347|       |  }
  348|       |
  349|       |  /// See the ClientStreamingInterface.Finish method for semantics.
  350|       |  /// Side effects:
  351|       |  ///   - Also receives initial metadata if not already received.
  352|       |  ///   - Attempts to fill in the \a response parameter passed
  353|       |  ///     to the constructor of this instance with the response
  354|       |  ///     message from the server.
  355|       |  Status Finish() override {
  356|       |    Status status;
  357|       |    if (!context_->initial_metadata_received_) {
  358|       |      finish_ops_.RecvInitialMetadata(context_);
  359|       |    }
  360|       |    finish_ops_.ClientRecvStatus(context_, &status);
  361|       |    call_.PerformOps(&finish_ops_);
  362|       |    GPR_CODEGEN_ASSERT(cq_.Pluck(&finish_ops_));
  363|       |    return status;
  364|       |  }
  365|       |
  366|       | private:
  367|       |  friend class internal::ClientWriterFactory<W>;
  368|       |
  369|       |  /// Block to create a stream (i.e. send request headers and other initial
  370|       |  /// metadata to the server). Note that \a context will be used to fill
  371|       |  /// in custom initial metadata. \a response will be filled in with the
  372|       |  /// single expected response message from the server upon a successful
  373|       |  /// call to the \a Finish method of this instance.
  374|       |  template <class R>
  375|       |  ClientWriter(ChannelInterface* channel,
  376|       |               const ::grpc::internal::RpcMethod& method,
  377|       |               ClientContext* context, R* response)
  378|       |      : context_(context),
  379|       |        cq_(grpc_completion_queue_attributes{
  380|       |            GRPC_CQ_CURRENT_VERSION, GRPC_CQ_PLUCK, GRPC_CQ_DEFAULT_POLLING,
  381|       |            nullptr}),  // Pluckable cq
  382|       |        call_(channel->CreateCall(method, context, &cq_)) {
  383|       |    finish_ops_.RecvMessage(response);
  384|       |    finish_ops_.AllowNoMessage();
  385|       |
  386|       |    if (!context_->initial_metadata_corked_) {
  387|       |      ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata>
  388|       |          ops;
  389|       |      ops.SendInitialMetadata(&context->send_initial_metadata_,
  390|       |                              context->initial_metadata_flags());
  391|       |      call_.PerformOps(&ops);
  392|       |      cq_.Pluck(&ops);
  393|       |    }
  394|       |  }
  395|       |
  396|       |  ClientContext* context_;
  397|       |  ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata,
  398|       |                              ::grpc::internal::CallOpGenericRecvMessage,
  399|       |                              ::grpc::internal::CallOpClientRecvStatus>
  400|       |      finish_ops_;
  401|       |  CompletionQueue cq_;
  402|       |  ::grpc::internal::Call call_;
  403|       |};
  404|       |
  405|       |/// Client-side interface for bi-directional streaming with
  406|       |/// client-to-server stream messages of type \a W and
  407|       |/// server-to-client stream messages of type \a R.
  408|       |template <class W, class R>
  409|       |class ClientReaderWriterInterface : public internal::ClientStreamingInterface,
  410|       |                                    public internal::WriterInterface<W>,
  411|       |                                    public internal::ReaderInterface<R> {
  412|       | public:
  413|       |  /// Block to wait for initial metadata from server. The received metadata
  414|       |  /// can only be accessed after this call returns. Should only be called before
  415|       |  /// the first read. Calling this method is optional, and if it is not called
  416|       |  /// the metadata will be available in ClientContext after the first read.
  417|       |  virtual void WaitForInitialMetadata() = 0;
  418|       |
  419|       |  /// Half close writing from the client. (signal that the stream of messages
  420|       |  /// coming from the clinet is complete).
  421|       |  /// Blocks until currently-pending writes are completed.
  422|       |  /// Thread-safe with respect to \a ReaderInterface::Read
  423|       |  ///
  424|       |  /// \return Whether the writes were successful.
  425|       |  virtual bool WritesDone() = 0;
  426|       |};
  427|       |
  428|       |namespace internal {
  429|       |template <class W, class R>
  430|       |class ClientReaderWriterFactory {
  431|       | public:
  432|       |  static ClientReaderWriter<W, R>* Create(
  433|       |      ::grpc::ChannelInterface* channel,
  434|       |      const ::grpc::internal::RpcMethod& method, ClientContext* context) {
  435|       |    return new ClientReaderWriter<W, R>(channel, method, context);
  436|       |  }
  437|       |};
  438|       |}  // namespace internal
  439|       |
  440|       |/// Synchronous (blocking) client-side API for bi-directional streaming RPCs,
  441|       |/// where the outgoing message stream coming from the client has messages of
  442|       |/// type \a W, and the incoming messages stream coming from the server has
  443|       |/// messages of type \a R.
  444|       |template <class W, class R>
  445|       |class ClientReaderWriter final : public ClientReaderWriterInterface<W, R> {
  446|       | public:
  447|       |  /// Block waiting to read initial metadata from the server.
  448|       |  /// This call is optional, but if it is used, it cannot be used concurrently
  449|       |  /// with or after the \a Finish method.
  450|       |  ///
  451|       |  /// Once complete, the initial metadata read from the server will be
  452|       |  /// accessible through the \a ClientContext used to construct this object.
  453|       |  void WaitForInitialMetadata() override {
  454|       |    GPR_CODEGEN_ASSERT(!context_->initial_metadata_received_);
  455|       |
  456|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata>
  457|       |        ops;
  458|       |    ops.RecvInitialMetadata(context_);
  459|       |    call_.PerformOps(&ops);
  460|       |    cq_.Pluck(&ops);  // status ignored
  461|       |  }
  462|       |
  463|       |  bool NextMessageSize(uint32_t* sz) override {
  464|       |    *sz = call_.max_receive_message_size();
  465|       |    return true;
  466|       |  }
  467|       |
  468|       |  /// See the \a ReaderInterface.Read method for semantics.
  469|       |  /// Side effect:
  470|       |  ///   Also receives initial metadata if not already received (updates the \a
  471|       |  ///   ClientContext associated with this call in that case).
  472|       |  bool Read(R* msg) override {
  473|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata,
  474|       |                                ::grpc::internal::CallOpRecvMessage<R>>
  475|       |        ops;
  476|       |    if (!context_->initial_metadata_received_) {
  477|       |      ops.RecvInitialMetadata(context_);
  478|       |    }
  479|       |    ops.RecvMessage(msg);
  480|       |    call_.PerformOps(&ops);
  481|       |    return cq_.Pluck(&ops) && ops.got_message;
  482|       |  }
  483|       |
  484|       |  /// See the \a WriterInterface.Write method for semantics.
  485|       |  ///
  486|       |  /// Side effect:
  487|       |  ///   Also sends initial metadata if not already sent (using the
  488|       |  ///   \a ClientContext associated with this call to fill in values).
  489|       |  using ::grpc::internal::WriterInterface<W>::Write;
  490|       |  bool Write(const W& msg, WriteOptions options) override {
  491|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata,
  492|       |                                ::grpc::internal::CallOpSendMessage,
  493|       |                                ::grpc::internal::CallOpClientSendClose>
  494|       |        ops;
  495|       |
  496|       |    if (options.is_last_message()) {
  497|       |      options.set_buffer_hint();
  498|       |      ops.ClientSendClose();
  499|       |    }
  500|       |    if (context_->initial_metadata_corked_) {
  501|       |      ops.SendInitialMetadata(&context_->send_initial_metadata_,
  502|       |                              context_->initial_metadata_flags());
  503|       |      context_->set_initial_metadata_corked(false);
  504|       |    }
  505|       |    if (!ops.SendMessagePtr(&msg, options).ok()) {
  506|       |      return false;
  507|       |    }
  508|       |
  509|       |    call_.PerformOps(&ops);
  510|       |    return cq_.Pluck(&ops);
  511|       |  }
  512|       |
  513|       |  bool WritesDone() override {
  514|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpClientSendClose> ops;
  515|       |    ops.ClientSendClose();
  516|       |    call_.PerformOps(&ops);
  517|       |    return cq_.Pluck(&ops);
  518|       |  }
  519|       |
  520|       |  /// See the ClientStreamingInterface.Finish method for semantics.
  521|       |  ///
  522|       |  /// Side effect:
  523|       |  ///   - the \a ClientContext associated with this call is updated with
  524|       |  ///     possible trailing metadata sent from the server.
  525|       |  Status Finish() override {
  526|       |    ::grpc::internal::CallOpSet<::grpc::internal::CallOpRecvInitialMetadata,
  527|       |                                ::grpc::internal::CallOpClientRecvStatus>
  528|       |        ops;
  529|       |    if (!context_->initial_metadata_received_) {
  530|       |      ops.RecvInitialMetadata(context_);
  531|       |    }
  532|       |    Status status;
  533|       |    ops.ClientRecvStatus(context_, &status);
  534|       |    call_.PerformOps(&ops);
  535|       |    GPR_CODEGEN_ASSERT(cq_.Pluck(&ops));
  536|       |    return status;
  537|       |  }
  538|       |
  539|       | private:
  540|       |  friend class internal::ClientReaderWriterFactory<W, R>;
  541|       |
  542|       |  ClientContext* context_;
  543|       |  CompletionQueue cq_;
  544|       |  ::grpc::internal::Call call_;
  545|       |
  546|       |  /// Block to create a stream and write the initial metadata and \a request
  547|       |  /// out. Note that \a context will be used to fill in custom initial metadata
  548|       |  /// used to send to the server when starting the call.
  549|       |  ClientReaderWriter(::grpc::ChannelInterface* channel,
  550|       |                     const ::grpc::internal::RpcMethod& method,
  551|       |                     ClientContext* context)
  552|       |      : context_(context),
  553|       |        cq_(grpc_completion_queue_attributes{
  554|       |            GRPC_CQ_CURRENT_VERSION, GRPC_CQ_PLUCK, GRPC_CQ_DEFAULT_POLLING,
  555|       |            nullptr}),  // Pluckable cq
  556|       |        call_(channel->CreateCall(method, context, &cq_)) {
  557|       |    if (!context_->initial_metadata_corked_) {
  558|       |      ::grpc::internal::CallOpSet<::grpc::internal::CallOpSendInitialMetadata>
  559|       |          ops;
  560|       |      ops.SendInitialMetadata(&context->send_initial_metadata_,
  561|       |                              context->initial_metadata_flags());
  562|       |      call_.PerformOps(&ops);
  563|       |      cq_.Pluck(&ops);
  564|       |    }
  565|       |  }
  566|       |};
  567|       |
  568|       |/// Server-side interface for streaming reads of message of type \a R.
  569|       |template <class R>
  570|       |class ServerReaderInterface : public internal::ServerStreamingInterface,
  571|       |                              public internal::ReaderInterface<R> {};
  572|       |
  573|       |/// Synchronous (blocking) server-side API for doing client-streaming RPCs,
  574|       |/// where the incoming message stream coming from the client has messages of
  575|       |/// type \a R.
  576|       |template <class R>
  577|       |class ServerReader final : public ServerReaderInterface<R> {
  578|       | public:
  579|       |  /// See the \a ServerStreamingInterface.SendInitialMetadata method
  580|       |  /// for semantics. Note that initial metadata will be affected by the
  581|       |  /// \a ServerContext associated with this call.
  582|       |  void SendInitialMetadata() override {
  583|       |    GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
  584|       |
  585|       |    internal::CallOpSet<internal::CallOpSendInitialMetadata> ops;
  586|       |    ops.SendInitialMetadata(&ctx_->initial_metadata_,
  587|       |                            ctx_->initial_metadata_flags());
  588|       |    if (ctx_->compression_level_set()) {
  589|       |      ops.set_compression_level(ctx_->compression_level());
  590|       |    }
  591|       |    ctx_->sent_initial_metadata_ = true;
  592|       |    call_->PerformOps(&ops);
  593|       |    call_->cq()->Pluck(&ops);
  594|       |  }
  595|       |
  596|       |  bool NextMessageSize(uint32_t* sz) override {
  597|       |    *sz = call_->max_receive_message_size();
  598|       |    return true;
  599|       |  }
  600|       |
  601|       |  bool Read(R* msg) override {
  602|       |    internal::CallOpSet<internal::CallOpRecvMessage<R>> ops;
  603|       |    ops.RecvMessage(msg);
  604|       |    call_->PerformOps(&ops);
  605|       |    return call_->cq()->Pluck(&ops) && ops.got_message;
  606|       |  }
  607|       |
  608|       | private:
  609|       |  internal::Call* const call_;
  610|       |  ServerContext* const ctx_;
  611|       |
  612|       |  template <class ServiceType, class RequestType, class ResponseType>
  613|       |  friend class internal::ClientStreamingHandler;
  614|       |
  615|       |  ServerReader(internal::Call* call, ServerContext* ctx)
  616|       |      : call_(call), ctx_(ctx) {}
  617|       |};
  618|       |
  619|       |/// Server-side interface for streaming writes of message of type \a W.
  620|       |template <class W>
  621|       |class ServerWriterInterface : public internal::ServerStreamingInterface,
  622|       |                              public internal::WriterInterface<W> {};
  623|       |
  624|       |/// Synchronous (blocking) server-side API for doing for doing a
  625|       |/// server-streaming RPCs, where the outgoing message stream coming from the
  626|       |/// server has messages of type \a W.
  627|       |template <class W>
  628|       |class ServerWriter final : public ServerWriterInterface<W> {
  629|       | public:
  630|       |  /// See the \a ServerStreamingInterface.SendInitialMetadata method
  631|       |  /// for semantics.
  632|       |  /// Note that initial metadata will be affected by the
  633|       |  /// \a ServerContext associated with this call.
  634|       |  void SendInitialMetadata() override {
  635|       |    GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
  636|       |
  637|       |    internal::CallOpSet<internal::CallOpSendInitialMetadata> ops;
  638|       |    ops.SendInitialMetadata(&ctx_->initial_metadata_,
  639|       |                            ctx_->initial_metadata_flags());
  640|       |    if (ctx_->compression_level_set()) {
  641|       |      ops.set_compression_level(ctx_->compression_level());
  642|       |    }
  643|       |    ctx_->sent_initial_metadata_ = true;
  644|       |    call_->PerformOps(&ops);
  645|       |    call_->cq()->Pluck(&ops);
  646|       |  }
  647|       |
  648|       |  /// See the \a WriterInterface.Write method for semantics.
  649|       |  ///
  650|       |  /// Side effect:
  651|       |  ///   Also sends initial metadata if not already sent (using the
  652|       |  ///   \a ClientContext associated with this call to fill in values).
  653|       |  using internal::WriterInterface<W>::Write;
  654|       |  bool Write(const W& msg, WriteOptions options) override {
  655|       |    if (options.is_last_message()) {
  656|       |      options.set_buffer_hint();
  657|       |    }
  658|       |
  659|       |    if (!ctx_->pending_ops_.SendMessagePtr(&msg, options).ok()) {
  660|       |      return false;
  661|       |    }
  662|       |    if (!ctx_->sent_initial_metadata_) {
  663|       |      ctx_->pending_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  664|       |                                             ctx_->initial_metadata_flags());
  665|       |      if (ctx_->compression_level_set()) {
  666|       |        ctx_->pending_ops_.set_compression_level(ctx_->compression_level());
  667|       |      }
  668|       |      ctx_->sent_initial_metadata_ = true;
  669|       |    }
  670|       |    call_->PerformOps(&ctx_->pending_ops_);
  671|       |    // if this is the last message we defer the pluck until AFTER we start
  672|       |    // the trailing md op. This prevents hangs. See
  673|       |    // https://github.com/grpc/grpc/issues/11546
  674|       |    if (options.is_last_message()) {
  675|       |      ctx_->has_pending_ops_ = true;
  676|       |      return true;
  677|       |    }
  678|       |    ctx_->has_pending_ops_ = false;
  679|       |    return call_->cq()->Pluck(&ctx_->pending_ops_);
  680|       |  }
  681|       |
  682|       | private:
  683|       |  internal::Call* const call_;
  684|       |  ServerContext* const ctx_;
  685|       |
  686|       |  template <class ServiceType, class RequestType, class ResponseType>
  687|       |  friend class internal::ServerStreamingHandler;
  688|       |
  689|       |  ServerWriter(internal::Call* call, ServerContext* ctx)
  690|       |      : call_(call), ctx_(ctx) {}
  691|       |};
  692|       |
  693|       |/// Server-side interface for bi-directional streaming.
  694|       |template <class W, class R>
  695|       |class ServerReaderWriterInterface : public internal::ServerStreamingInterface,
  696|       |                                    public internal::WriterInterface<W>,
  697|       |                                    public internal::ReaderInterface<R> {};
  698|       |
  699|       |/// Actual implementation of bi-directional streaming
  700|       |namespace internal {
  701|       |template <class W, class R>
  702|       |class ServerReaderWriterBody final {
  703|       | public:
  704|       |  ServerReaderWriterBody(Call* call, ServerContext* ctx)
  705|       |      : call_(call), ctx_(ctx) {}
  706|       |
  707|       |  void SendInitialMetadata() {
  708|       |    GPR_CODEGEN_ASSERT(!ctx_->sent_initial_metadata_);
  709|       |
  710|       |    CallOpSet<CallOpSendInitialMetadata> ops;
  711|       |    ops.SendInitialMetadata(&ctx_->initial_metadata_,
  712|       |                            ctx_->initial_metadata_flags());
  713|       |    if (ctx_->compression_level_set()) {
  714|       |      ops.set_compression_level(ctx_->compression_level());
  715|       |    }
  716|       |    ctx_->sent_initial_metadata_ = true;
  717|       |    call_->PerformOps(&ops);
  718|       |    call_->cq()->Pluck(&ops);
  719|       |  }
  720|       |
  721|       |  bool NextMessageSize(uint32_t* sz) {
  722|       |    *sz = call_->max_receive_message_size();
  723|       |    return true;
  724|       |  }
  725|       |
  726|       |  bool Read(R* msg) {
  727|       |    CallOpSet<CallOpRecvMessage<R>> ops;
  728|       |    ops.RecvMessage(msg);
  729|       |    call_->PerformOps(&ops);
  730|       |    return call_->cq()->Pluck(&ops) && ops.got_message;
  731|       |  }
  732|       |
  733|       |  bool Write(const W& msg, WriteOptions options) {
  734|       |    if (options.is_last_message()) {
  735|       |      options.set_buffer_hint();
  736|       |    }
  737|       |    if (!ctx_->pending_ops_.SendMessagePtr(&msg, options).ok()) {
  738|       |      return false;
  739|       |    }
  740|       |    if (!ctx_->sent_initial_metadata_) {
  741|       |      ctx_->pending_ops_.SendInitialMetadata(&ctx_->initial_metadata_,
  742|       |                                             ctx_->initial_metadata_flags());
  743|       |      if (ctx_->compression_level_set()) {
  744|       |        ctx_->pending_ops_.set_compression_level(ctx_->compression_level());
  745|       |      }
  746|       |      ctx_->sent_initial_metadata_ = true;
  747|       |    }
  748|       |    call_->PerformOps(&ctx_->pending_ops_);
  749|       |    // if this is the last message we defer the pluck until AFTER we start
  750|       |    // the trailing md op. This prevents hangs. See
  751|       |    // https://github.com/grpc/grpc/issues/11546
  752|       |    if (options.is_last_message()) {
  753|       |      ctx_->has_pending_ops_ = true;
  754|       |      return true;
  755|       |    }
  756|       |    ctx_->has_pending_ops_ = false;
  757|       |    return call_->cq()->Pluck(&ctx_->pending_ops_);
  758|       |  }
  759|       |
  760|       | private:
  761|       |  Call* const call_;
  762|       |  ServerContext* const ctx_;
  763|       |};
  764|       |
  765|       |}  // namespace internal
  766|       |
  767|       |/// Synchronous (blocking) server-side API for a bidirectional
  768|       |/// streaming call, where the incoming message stream coming from the client has
  769|       |/// messages of type \a R, and the outgoing message streaming coming from
  770|       |/// the server has messages of type \a W.
  771|       |template <class W, class R>
  772|       |class ServerReaderWriter final : public ServerReaderWriterInterface<W, R> {
  773|       | public:
  774|       |  /// See the \a ServerStreamingInterface.SendInitialMetadata method
  775|       |  /// for semantics. Note that initial metadata will be affected by the
  776|       |  /// \a ServerContext associated with this call.
  777|       |  void SendInitialMetadata() override { body_.SendInitialMetadata(); }
  778|       |
  779|       |  bool NextMessageSize(uint32_t* sz) override {
  780|       |    return body_.NextMessageSize(sz);
  781|       |  }
  782|       |
  783|       |  bool Read(R* msg) override { return body_.Read(msg); }
  784|       |
  785|       |  /// See the \a WriterInterface.Write(const W& msg, WriteOptions options)
  786|       |  /// method for semantics.
  787|       |  /// Side effect:
  788|       |  ///   Also sends initial metadata if not already sent (using the \a
  789|       |  ///   ServerContext associated with this call).
  790|       |  using internal::WriterInterface<W>::Write;
  791|       |  bool Write(const W& msg, WriteOptions options) override {
  792|       |    return body_.Write(msg, options);
  793|       |  }
  794|       |
  795|       | private:
  796|       |  internal::ServerReaderWriterBody<W, R> body_;
  797|       |
  798|       |  friend class internal::TemplatedBidiStreamingHandler<ServerReaderWriter<W, R>,
  799|       |                                                       false>;
  800|       |  ServerReaderWriter(internal::Call* call, ServerContext* ctx)
  801|       |      : body_(call, ctx) {}
  802|       |};
  803|       |
  804|       |/// A class to represent a flow-controlled unary call. This is something
  805|       |/// of a hybrid between conventional unary and streaming. This is invoked
  806|       |/// through a unary call on the client side, but the server responds to it
  807|       |/// as though it were a single-ping-pong streaming call. The server can use
  808|       |/// the \a NextMessageSize method to determine an upper-bound on the size of
  809|       |/// the message. A key difference relative to streaming: ServerUnaryStreamer
  810|       |/// must have exactly 1 Read and exactly 1 Write, in that order, to function
  811|       |/// correctly. Otherwise, the RPC is in error.
  812|       |template <class RequestType, class ResponseType>
  813|       |class ServerUnaryStreamer final
  814|       |    : public ServerReaderWriterInterface<ResponseType, RequestType> {
  815|       | public:
  816|       |  /// Block to send initial metadata to client.
  817|       |  /// Implicit input parameter:
  818|       |  ///    - the \a ServerContext associated with this call will be used for
  819|       |  ///      sending initial metadata.
  820|       |  void SendInitialMetadata() override { body_.SendInitialMetadata(); }
  821|       |
  822|       |  /// Get an upper bound on the request message size from the client.
  823|       |  bool NextMessageSize(uint32_t* sz) override {
  824|       |    return body_.NextMessageSize(sz);
  825|       |  }
  826|       |
  827|       |  /// Read a message of type \a R into \a msg. Completion will be notified by \a
  828|       |  /// tag on the associated completion queue.
  829|       |  /// This is thread-safe with respect to \a Write or \a WritesDone methods. It
  830|       |  /// should not be called concurrently with other streaming APIs
  831|       |  /// on the same stream. It is not meaningful to call it concurrently
  832|       |  /// with another \a ReaderInterface::Read on the same stream since reads on
  833|       |  /// the same stream are delivered in order.
  834|       |  ///
  835|       |  /// \param[out] msg Where to eventually store the read message.
  836|       |  /// \param[in] tag The tag identifying the operation.
  837|       |  bool Read(RequestType* request) override {
  838|       |    if (read_done_) {
  839|       |      return false;
  840|       |    }
  841|       |    read_done_ = true;
  842|       |    return body_.Read(request);
  843|       |  }
  844|       |
  845|       |  /// Block to write \a msg to the stream with WriteOptions \a options.
  846|       |  /// This is thread-safe with respect to \a ReaderInterface::Read
  847|       |  ///
  848|       |  /// \param msg The message to be written to the stream.
  849|       |  /// \param options The WriteOptions affecting the write operation.
  850|       |  ///
  851|       |  /// \return \a true on success, \a false when the stream has been closed.
  852|       |  using internal::WriterInterface<ResponseType>::Write;
  853|       |  bool Write(const ResponseType& response, WriteOptions options) override {
  854|       |    if (write_done_ || !read_done_) {
  855|       |      return false;
  856|       |    }
  857|       |    write_done_ = true;
  858|       |    return body_.Write(response, options);
  859|       |  }
  860|       |
  861|       | private:
  862|       |  internal::ServerReaderWriterBody<ResponseType, RequestType> body_;
  863|       |  bool read_done_;
  864|       |  bool write_done_;
  865|       |
  866|       |  friend class internal::TemplatedBidiStreamingHandler<
  867|       |      ServerUnaryStreamer<RequestType, ResponseType>, true>;
  868|       |  ServerUnaryStreamer(internal::Call* call, ServerContext* ctx)
  869|       |      : body_(call, ctx), read_done_(false), write_done_(false) {}
  870|       |};
  871|       |
  872|       |/// A class to represent a flow-controlled server-side streaming call.
  873|       |/// This is something of a hybrid between server-side and bidi streaming.
  874|       |/// This is invoked through a server-side streaming call on the client side,
  875|       |/// but the server responds to it as though it were a bidi streaming call that
  876|       |/// must first have exactly 1 Read and then any number of Writes.
  877|       |template <class RequestType, class ResponseType>
  878|       |class ServerSplitStreamer final
  879|       |    : public ServerReaderWriterInterface<ResponseType, RequestType> {
  880|       | public:
  881|       |  /// Block to send initial metadata to client.
  882|       |  /// Implicit input parameter:
  883|       |  ///    - the \a ServerContext associated with this call will be used for
  884|       |  ///      sending initial metadata.
  885|       |  void SendInitialMetadata() override { body_.SendInitialMetadata(); }
  886|       |
  887|       |  /// Get an upper bound on the request message size from the client.
  888|       |  bool NextMessageSize(uint32_t* sz) override {
  889|       |    return body_.NextMessageSize(sz);
  890|       |  }
  891|       |
  892|       |  /// Read a message of type \a R into \a msg. Completion will be notified by \a
  893|       |  /// tag on the associated completion queue.
  894|       |  /// This is thread-safe with respect to \a Write or \a WritesDone methods. It
  895|       |  /// should not be called concurrently with other streaming APIs
  896|       |  /// on the same stream. It is not meaningful to call it concurrently
  897|       |  /// with another \a ReaderInterface::Read on the same stream since reads on
  898|       |  /// the same stream are delivered in order.
  899|       |  ///
  900|       |  /// \param[out] msg Where to eventually store the read message.
  901|       |  /// \param[in] tag The tag identifying the operation.
  902|       |  bool Read(RequestType* request) override {
  903|       |    if (read_done_) {
  904|       |      return false;
  905|       |    }
  906|       |    read_done_ = true;
  907|       |    return body_.Read(request);
  908|       |  }
  909|       |
  910|       |  /// Block to write \a msg to the stream with WriteOptions \a options.
  911|       |  /// This is thread-safe with respect to \a ReaderInterface::Read
  912|       |  ///
  913|       |  /// \param msg The message to be written to the stream.
  914|       |  /// \param options The WriteOptions affecting the write operation.
  915|       |  ///
  916|       |  /// \return \a true on success, \a false when the stream has been closed.
  917|       |  using internal::WriterInterface<ResponseType>::Write;
  918|       |  bool Write(const ResponseType& response, WriteOptions options) override {
  919|       |    return read_done_ && body_.Write(response, options);
  920|       |  }
  921|       |
  922|       | private:
  923|       |  internal::ServerReaderWriterBody<ResponseType, RequestType> body_;
  924|       |  bool read_done_;
  925|       |
  926|       |  friend class internal::TemplatedBidiStreamingHandler<
  927|       |      ServerSplitStreamer<RequestType, ResponseType>, false>;
  928|       |  ServerSplitStreamer(internal::Call* call, ServerContext* ctx)
  929|       |      : body_(call, ctx), read_done_(false) {}
  930|       |};
  931|       |
  932|       |}  // namespace grpc
  933|       |
  934|       |#endif  // GRPCPP_IMPL_CODEGEN_SYNC_STREAM_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/codegen/time.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_CODEGEN_TIME_H
   20|       |#define GRPCPP_IMPL_CODEGEN_TIME_H
   21|       |
   22|       |#include <chrono>
   23|       |
   24|       |#include <grpc/impl/codegen/grpc_types.h>
   25|       |#include <grpcpp/impl/codegen/config.h>
   26|       |
   27|       |namespace grpc {
   28|       |
   29|       |/** If you are trying to use CompletionQueue::AsyncNext with a time class that
   30|       |    isn't either gpr_timespec or std::chrono::system_clock::time_point, you
   31|       |    will most likely be looking at this comment as your compiler will have
   32|       |    fired an error below. In order to fix this issue, you have two potential
   33|       |    solutions:
   34|       |
   35|       |      1. Use gpr_timespec or std::chrono::system_clock::time_point instead
   36|       |      2. Specialize the TimePoint class with whichever time class that you
   37|       |         want to use here. See below for two examples of how to do this.
   38|       | */
   39|       |template <typename T>
   40|       |class TimePoint {
   41|       | public:
   42|       |  TimePoint(const T& time) { you_need_a_specialization_of_TimePoint(); }
   43|       |  gpr_timespec raw_time() {
   44|       |    gpr_timespec t;
   45|       |    return t;
   46|       |  }
   47|       |
   48|       | private:
   49|       |  void you_need_a_specialization_of_TimePoint();
   50|       |};
   51|       |
   52|       |template <>
   53|       |class TimePoint<gpr_timespec> {
   54|       | public:
   55|      0|  TimePoint(const gpr_timespec& time) : time_(time) {}
   56|      0|  gpr_timespec raw_time() { return time_; }
   57|       |
   58|       | private:
   59|       |  gpr_timespec time_;
   60|       |};
   61|       |
   62|       |}  // namespace grpc
   63|       |
   64|       |namespace grpc {
   65|       |
   66|       |// from and to should be absolute time.
   67|       |void Timepoint2Timespec(const std::chrono::system_clock::time_point& from,
   68|       |                        gpr_timespec* to);
   69|       |void TimepointHR2Timespec(
   70|       |    const std::chrono::high_resolution_clock::time_point& from,
   71|       |    gpr_timespec* to);
   72|       |
   73|       |std::chrono::system_clock::time_point Timespec2Timepoint(gpr_timespec t);
   74|       |
   75|       |template <>
   76|       |class TimePoint<std::chrono::system_clock::time_point> {
   77|       | public:
   78|      0|  TimePoint(const std::chrono::system_clock::time_point& time) {
   79|      0|    Timepoint2Timespec(time, &time_);
   80|      0|  }
   81|      0|  gpr_timespec raw_time() const { return time_; }
   82|       |
   83|       | private:
   84|       |  gpr_timespec time_;
   85|       |};
   86|       |
   87|       |}  // namespace grpc
   88|       |
   89|       |#endif  // GRPCPP_IMPL_CODEGEN_TIME_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/grpc_library.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_GRPC_LIBRARY_H
   20|       |#define GRPCPP_IMPL_GRPC_LIBRARY_H
   21|       |
   22|       |#include <iostream>
   23|       |
   24|       |#include <grpc/grpc.h>
   25|       |#include <grpcpp/impl/codegen/config.h>
   26|       |#include <grpcpp/impl/codegen/core_codegen.h>
   27|       |#include <grpcpp/impl/codegen/grpc_library.h>
   28|       |
   29|       |namespace grpc {
   30|       |
   31|       |namespace internal {
   32|       |class GrpcLibrary final : public GrpcLibraryInterface {
   33|       | public:
   34|      0|  void init() override { grpc_init(); }
   35|      0|  void shutdown() override { grpc_shutdown(); }
   36|       |};
   37|       |
   38|       |/// Instantiating this class ensures the proper initialization of gRPC.
   39|       |class GrpcLibraryInitializer final {
   40|       | public:
   41|      8|  GrpcLibraryInitializer() {
   42|      8|    if (grpc::g_glip == nullptr) {
   43|      1|      static auto* const g_gli = new GrpcLibrary();
   44|      1|      grpc::g_glip = g_gli;
   45|      1|    }
   46|      8|    if (grpc::g_core_codegen_interface == nullptr) {
   47|      1|      static auto* const g_core_codegen = new CoreCodegen();
   48|      1|      grpc::g_core_codegen_interface = g_core_codegen;
   49|      1|    }
   50|      8|  }
   51|       |
   52|       |  /// A no-op method to force the linker to reference this class, which will
   53|       |  /// take care of initializing and shutting down the gRPC runtime.
   54|      0|  int summon() { return 0; }
   55|       |};
   56|       |
   57|       |}  // namespace internal
   58|       |}  // namespace grpc
   59|       |
   60|       |#endif  // GRPCPP_IMPL_GRPC_LIBRARY_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/server_builder_option_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_SERVER_BUILDER_OPTION_IMPL_H
   20|       |#define GRPCPP_IMPL_SERVER_BUILDER_OPTION_IMPL_H
   21|       |
   22|       |#include <map>
   23|       |#include <memory>
   24|       |
   25|       |#include <grpcpp/impl/server_builder_plugin.h>
   26|       |#include <grpcpp/support/channel_arguments.h>
   27|       |
   28|       |namespace grpc_impl {
   29|       |
   30|       |/// Interface to pass an option to a \a ServerBuilder.
   31|       |class ServerBuilderOption {
   32|       | public:
   33|      0|  virtual ~ServerBuilderOption() {}
   34|       |  /// Alter the \a ChannelArguments used to create the gRPC server.
   35|       |  virtual void UpdateArguments(grpc::ChannelArguments* args) = 0;
   36|       |  /// Alter the ServerBuilderPlugin map that will be added into ServerBuilder.
   37|       |  virtual void UpdatePlugins(
   38|       |      std::vector<std::unique_ptr<grpc::ServerBuilderPlugin>>* plugins) = 0;
   39|       |};
   40|       |
   41|       |}  // namespace grpc_impl
   42|       |
   43|       |#endif  // GRPCPP_IMPL_SERVER_BUILDER_OPTION_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/server_builder_plugin.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_SERVER_BUILDER_PLUGIN_H
   20|       |#define GRPCPP_IMPL_SERVER_BUILDER_PLUGIN_H
   21|       |
   22|       |#include <memory>
   23|       |
   24|       |#include <grpcpp/support/config.h>
   25|       |
   26|       |namespace grpc_impl {
   27|       |
   28|       |class ChannelArguments;
   29|       |class ServerBuilder;
   30|       |class ServerInitializer;
   31|       |}  // namespace grpc_impl
   32|       |namespace grpc {
   33|       |
   34|       |/// This interface is meant for internal usage only. Implementations of this
   35|       |/// interface should add themselves to a \a ServerBuilder instance through the
   36|       |/// \a InternalAddPluginFactory method.
   37|       |class ServerBuilderPlugin {
   38|       | public:
   39|      0|  virtual ~ServerBuilderPlugin() {}
   40|       |  virtual grpc::string name() = 0;
   41|       |
   42|       |  /// UpdateServerBuilder will be called at an early stage in
   43|       |  /// ServerBuilder::BuildAndStart(), right after the ServerBuilderOptions have
   44|       |  /// done their updates.
   45|      0|  virtual void UpdateServerBuilder(grpc_impl::ServerBuilder* builder) {}
   46|       |
   47|       |  /// InitServer will be called in ServerBuilder::BuildAndStart(), after the
   48|       |  /// Server instance is created.
   49|       |  virtual void InitServer(grpc_impl::ServerInitializer* si) = 0;
   50|       |
   51|       |  /// Finish will be called at the end of ServerBuilder::BuildAndStart().
   52|       |  virtual void Finish(grpc_impl::ServerInitializer* si) = 0;
   53|       |
   54|       |  /// ChangeArguments is an interface that can be used in
   55|       |  /// ServerBuilderOption::UpdatePlugins
   56|       |  virtual void ChangeArguments(const grpc::string& name, void* value) = 0;
   57|       |
   58|       |  /// UpdateChannelArguments will be called in ServerBuilder::BuildAndStart(),
   59|       |  /// before the Server instance is created.
   60|      0|  virtual void UpdateChannelArguments(grpc_impl::ChannelArguments* args) {}
   61|       |
   62|      0|  virtual bool has_sync_methods() const { return false; }
   63|      0|  virtual bool has_async_methods() const { return false; }
   64|       |};
   65|       |
   66|       |}  // namespace grpc
   67|       |
   68|       |#endif  // GRPCPP_IMPL_SERVER_BUILDER_PLUGIN_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/impl/server_initializer_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_IMPL_SERVER_INITIALIZER_IMPL_H
   20|       |#define GRPCPP_IMPL_SERVER_INITIALIZER_IMPL_H
   21|       |
   22|       |#include <memory>
   23|       |#include <vector>
   24|       |
   25|       |#include <grpcpp/server.h>
   26|       |
   27|       |namespace grpc {
   28|       |
   29|       |class Service;
   30|       |}  // namespace grpc
   31|       |namespace grpc_impl {
   32|       |class Server;
   33|       |
   34|       |class ServerInitializer {
   35|       | public:
   36|      0|  ServerInitializer(grpc::Server* server) : server_(server) {}
   37|       |
   38|      0|  bool RegisterService(std::shared_ptr<grpc::Service> service) {
   39|      0|    if (!server_->RegisterService(nullptr, service.get())) {
   40|      0|      return false;
   41|      0|    }
   42|      0|    default_services_.push_back(service);
   43|      0|    return true;
   44|      0|  }
   45|       |
   46|      0|  const std::vector<grpc::string>* GetServiceList() {
   47|      0|    return &server_->services_;
   48|      0|  }
   49|       |
   50|       | private:
   51|       |  grpc::Server* server_;
   52|       |  std::vector<std::shared_ptr<grpc::Service> > default_services_;
   53|       |};
   54|       |
   55|       |}  // namespace grpc_impl
   56|       |
   57|       |#endif  // GRPCPP_IMPL_SERVER_INITIALIZER_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/resource_quota_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_RESOURCE_QUOTA_IMPL_H
   20|       |#define GRPCPP_RESOURCE_QUOTA_IMPL_H
   21|       |
   22|       |struct grpc_resource_quota;
   23|       |
   24|       |#include <grpcpp/impl/codegen/config.h>
   25|       |#include <grpcpp/impl/codegen/grpc_library.h>
   26|       |
   27|       |namespace grpc_impl {
   28|       |
   29|       |/// ResourceQuota represents a bound on memory and thread usage by the gRPC
   30|       |/// library. A ResourceQuota can be attached to a server (via \a ServerBuilder),
   31|       |/// or a client channel (via \a ChannelArguments).
   32|       |/// gRPC will attempt to keep memory and threads used by all attached entities
   33|       |/// below the ResourceQuota bound.
   34|       |class ResourceQuota final : private ::grpc::GrpcLibraryCodegen {
   35|       | public:
   36|       |  /// \param name - a unique name for this ResourceQuota.
   37|       |  explicit ResourceQuota(const grpc::string& name);
   38|       |  ResourceQuota();
   39|       |  ~ResourceQuota();
   40|       |
   41|       |  /// Resize this \a ResourceQuota to a new size. If \a new_size is smaller
   42|       |  /// than the current size of the pool, memory usage will be monotonically
   43|       |  /// decreased until it falls under \a new_size.
   44|       |  /// No time bound is given for this to occur however.
   45|       |  ResourceQuota& Resize(size_t new_size);
   46|       |
   47|       |  /// Set the max number of threads that can be allocated from this
   48|       |  /// ResourceQuota object.
   49|       |  ///
   50|       |  /// If the new_max_threads value is smaller than the current value, no new
   51|       |  /// threads are allocated until the number of active threads fall below
   52|       |  /// new_max_threads. There is no time bound on when this may happen i.e none
   53|       |  /// of the current threads are forcefully destroyed and all threads run their
   54|       |  /// normal course.
   55|       |  ResourceQuota& SetMaxThreads(int new_max_threads);
   56|       |
   57|      0|  grpc_resource_quota* c_resource_quota() const { return impl_; }
   58|       |
   59|       | private:
   60|       |  ResourceQuota(const ResourceQuota& rhs);
   61|       |  ResourceQuota& operator=(const ResourceQuota& rhs);
   62|       |
   63|       |  grpc_resource_quota* const impl_;
   64|       |};
   65|       |
   66|       |}  // namespace grpc_impl
   67|       |
   68|       |#endif  // GRPCPP_RESOURCE_QUOTA_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/security/auth_metadata_processor_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_SECURITY_AUTH_METADATA_PROCESSOR_IMPL_H
   20|       |#define GRPCPP_SECURITY_AUTH_METADATA_PROCESSOR_IMPL_H
   21|       |
   22|       |#include <map>
   23|       |
   24|       |#include <grpcpp/security/auth_context.h>
   25|       |#include <grpcpp/support/status.h>
   26|       |#include <grpcpp/support/string_ref.h>
   27|       |
   28|       |namespace grpc_impl {
   29|       |
   30|       |/// Interface allowing custom server-side authorization based on credentials
   31|       |/// encoded in metadata.  Objects of this type can be passed to
   32|       |/// \a ServerCredentials::SetAuthMetadataProcessor().
   33|       |class AuthMetadataProcessor {
   34|       | public:
   35|       |  typedef std::multimap<grpc::string_ref, grpc::string_ref> InputMetadata;
   36|       |  typedef std::multimap<grpc::string, grpc::string> OutputMetadata;
   37|       |
   38|      0|  virtual ~AuthMetadataProcessor() {}
   39|       |
   40|       |  /// If this method returns true, the \a Process function will be scheduled in
   41|       |  /// a different thread from the one processing the call.
   42|      0|  virtual bool IsBlocking() const { return true; }
   43|       |
   44|       |  /// context is read/write: it contains the properties of the channel peer and
   45|       |  /// it is the job of the Process method to augment it with properties derived
   46|       |  /// from the passed-in auth_metadata.
   47|       |  /// consumed_auth_metadata needs to be filled with metadata that has been
   48|       |  /// consumed by the processor and will be removed from the call.
   49|       |  /// response_metadata is the metadata that will be sent as part of the
   50|       |  /// response.
   51|       |  /// If the return value is not Status::OK, the rpc call will be aborted with
   52|       |  /// the error code and error message sent back to the client.
   53|       |  virtual grpc::Status Process(const InputMetadata& auth_metadata,
   54|       |                               grpc::AuthContext* context,
   55|       |                               OutputMetadata* consumed_auth_metadata,
   56|       |                               OutputMetadata* response_metadata) = 0;
   57|       |};
   58|       |
   59|       |}  // namespace grpc_impl
   60|       |
   61|       |#endif  // GRPCPP_SECURITY_AUTH_METADATA_PROCESSOR_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/security/credentials.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_SECURITY_CREDENTIALS_H
   20|       |#define GRPCPP_SECURITY_CREDENTIALS_H
   21|       |
   22|       |#include <grpcpp/security/credentials_impl.h>
   23|       |
   24|       |namespace grpc {
   25|       |
   26|       |typedef ::grpc_impl::ChannelCredentials ChannelCredentials;
   27|       |typedef ::grpc_impl::CallCredentials CallCredentials;
   28|       |typedef ::grpc_impl::SslCredentialsOptions SslCredentialsOptions;
   29|       |typedef ::grpc_impl::SecureCallCredentials SecureCallCredentials;
   30|       |typedef ::grpc_impl::SecureChannelCredentials SecureChannelCredentials;
   31|       |
   32|       |static inline std::shared_ptr<grpc_impl::ChannelCredentials>
   33|      0|GoogleDefaultCredentials() {
   34|      0|  return ::grpc_impl::GoogleDefaultCredentials();
   35|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL24GoogleDefaultCredentialsEv
  ------------------
   36|       |
   37|       |static inline std::shared_ptr<ChannelCredentials> SslCredentials(
   38|      0|    const SslCredentialsOptions& options) {
   39|      0|  return ::grpc_impl::SslCredentials(options);
   40|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL14SslCredentialsERKN9grpc_impl21SslCredentialsOptionsE
  ------------------
   41|       |
   42|       |static inline std::shared_ptr<grpc_impl::CallCredentials>
   43|      0|GoogleComputeEngineCredentials() {
   44|      0|  return ::grpc_impl::GoogleComputeEngineCredentials();
   45|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL30GoogleComputeEngineCredentialsEv
  ------------------
   46|       |
   47|       |/// Constant for maximum auth token lifetime.
   48|       |constexpr long kMaxAuthTokenLifetimeSecs =
   49|       |    ::grpc_impl::kMaxAuthTokenLifetimeSecs;
   50|       |
   51|       |static inline std::shared_ptr<grpc_impl::CallCredentials>
   52|       |ServiceAccountJWTAccessCredentials(
   53|       |    const grpc::string& json_key,
   54|      0|    long token_lifetime_seconds = grpc::kMaxAuthTokenLifetimeSecs) {
   55|      0|  return ::grpc_impl::ServiceAccountJWTAccessCredentials(
   56|      0|      json_key, token_lifetime_seconds);
   57|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL34ServiceAccountJWTAccessCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEl
  ------------------
   58|       |
   59|       |static inline std::shared_ptr<grpc_impl::CallCredentials>
   60|      0|GoogleRefreshTokenCredentials(const grpc::string& json_refresh_token) {
   61|      0|  return ::grpc_impl::GoogleRefreshTokenCredentials(json_refresh_token);
   62|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL29GoogleRefreshTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
   63|       |
   64|       |static inline std::shared_ptr<grpc_impl::CallCredentials>
   65|      0|AccessTokenCredentials(const grpc::string& access_token) {
   66|      0|  return ::grpc_impl::AccessTokenCredentials(access_token);
   67|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL22AccessTokenCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE
  ------------------
   68|       |
   69|       |static inline std::shared_ptr<grpc_impl::CallCredentials> GoogleIAMCredentials(
   70|       |    const grpc::string& authorization_token,
   71|      0|    const grpc::string& authority_selector) {
   72|      0|  return ::grpc_impl::GoogleIAMCredentials(authorization_token,
   73|      0|                                           authority_selector);
   74|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL20GoogleIAMCredentialsERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8_
  ------------------
   75|       |
   76|       |static inline std::shared_ptr<ChannelCredentials> CompositeChannelCredentials(
   77|       |    const std::shared_ptr<ChannelCredentials>& channel_creds,
   78|      0|    const std::shared_ptr<CallCredentials>& call_creds) {
   79|      0|  return ::grpc_impl::CompositeChannelCredentials(channel_creds, call_creds);
   80|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL27CompositeChannelCredentialsERKNSt3__110shared_ptrIN9grpc_impl18ChannelCredentialsEEERKNS1_INS2_15CallCredentialsEEE
  ------------------
   81|       |
   82|       |static inline std::shared_ptr<grpc_impl::CallCredentials>
   83|       |CompositeCallCredentials(const std::shared_ptr<CallCredentials>& creds1,
   84|      0|                         const std::shared_ptr<CallCredentials>& creds2) {
   85|      0|  return ::grpc_impl::CompositeCallCredentials(creds1, creds2);
   86|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL24CompositeCallCredentialsERKNSt3__110shared_ptrIN9grpc_impl15CallCredentialsEEES6_
  ------------------
   87|       |
   88|       |static inline std::shared_ptr<grpc_impl::ChannelCredentials>
   89|      0|InsecureChannelCredentials() {
   90|      0|  return ::grpc_impl::InsecureChannelCredentials();
   91|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL26InsecureChannelCredentialsEv
  ------------------
   92|       |
   93|       |static inline std::shared_ptr<grpc_impl::ChannelCredentials>
   94|      0|CronetChannelCredentials(void* engine) {
   95|      0|  return ::grpc_impl::CronetChannelCredentials(engine);
   96|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL24CronetChannelCredentialsEPv
  ------------------
   97|       |
   98|       |typedef ::grpc_impl::MetadataCredentialsPlugin MetadataCredentialsPlugin;
   99|       |
  100|       |static inline std::shared_ptr<grpc_impl::CallCredentials>
  101|       |MetadataCredentialsFromPlugin(
  102|      0|    std::unique_ptr<MetadataCredentialsPlugin> plugin) {
  103|      0|  return ::grpc_impl::MetadataCredentialsFromPlugin(std::move(plugin));
  104|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL29MetadataCredentialsFromPluginENSt3__110unique_ptrIN9grpc_impl25MetadataCredentialsPluginENS0_14default_deleteIS3_EEEE
  ------------------
  105|       |
  106|       |namespace experimental {
  107|       |
  108|       |typedef ::grpc_impl::experimental::AltsCredentialsOptions
  109|       |    AltsCredentialsOptions;
  110|       |
  111|       |static inline std::shared_ptr<grpc_impl::ChannelCredentials> AltsCredentials(
  112|      0|    const AltsCredentialsOptions& options) {
  113|      0|  return ::grpc_impl::experimental::AltsCredentials(options);
  114|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpc12experimentalL15AltsCredentialsERKN9grpc_impl12experimental22AltsCredentialsOptionsE
  ------------------
  115|       |
  116|       |static inline std::shared_ptr<grpc_impl::ChannelCredentials> LocalCredentials(
  117|      0|    grpc_local_connect_type type) {
  118|      0|  return ::grpc_impl::experimental::LocalCredentials(type);
  119|      0|}
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: channel_cc.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: client_context.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: create_channel.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: credentials_cc.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: insecure_credentials.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: secure_credentials.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpc12experimentalL16LocalCredentialsE23grpc_local_connect_type
  ------------------
  120|       |
  121|       |}  // namespace experimental
  122|       |}  // namespace grpc
  123|       |
  124|       |#endif  // GRPCPP_SECURITY_CREDENTIALS_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/security/credentials_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_SECURITY_CREDENTIALS_IMPL_H
   20|       |#define GRPCPP_SECURITY_CREDENTIALS_IMPL_H
   21|       |
   22|       |#include <map>
   23|       |#include <memory>
   24|       |#include <vector>
   25|       |
   26|       |#include <grpc/grpc_security_constants.h>
   27|       |#include <grpcpp/channel.h>
   28|       |#include <grpcpp/impl/codegen/client_interceptor.h>
   29|       |#include <grpcpp/impl/codegen/grpc_library.h>
   30|       |#include <grpcpp/security/auth_context.h>
   31|       |#include <grpcpp/support/channel_arguments.h>
   32|       |#include <grpcpp/support/status.h>
   33|       |#include <grpcpp/support/string_ref.h>
   34|       |
   35|       |struct grpc_call;
   36|       |
   37|       |namespace grpc_impl {
   38|       |
   39|       |class ChannelCredentials;
   40|       |class CallCredentials;
   41|       |class SecureCallCredentials;
   42|       |class SecureChannelCredentials;
   43|       |
   44|       |std::shared_ptr<::grpc::Channel> CreateCustomChannelImpl(
   45|       |    const grpc::string& target,
   46|       |    const std::shared_ptr<ChannelCredentials>& creds,
   47|       |    const grpc::ChannelArguments& args);
   48|       |
   49|       |namespace experimental {
   50|       |std::shared_ptr<::grpc::Channel> CreateCustomChannelWithInterceptors(
   51|       |    const grpc::string& target,
   52|       |    const std::shared_ptr<ChannelCredentials>& creds,
   53|       |    const grpc::ChannelArguments& args,
   54|       |    std::vector<
   55|       |        std::unique_ptr<grpc::experimental::ClientInterceptorFactoryInterface>>
   56|       |        interceptor_creators);
   57|       |}
   58|       |
   59|       |/// A channel credentials object encapsulates all the state needed by a client
   60|       |/// to authenticate with a server for a given channel.
   61|       |/// It can make various assertions, e.g., about the clients identity, role
   62|       |/// for all the calls on that channel.
   63|       |///
   64|       |/// \see https://grpc.io/docs/guides/auth.html
   65|       |class ChannelCredentials : private grpc::GrpcLibraryCodegen {
   66|       | public:
   67|       |  ChannelCredentials();
   68|       |  ~ChannelCredentials();
   69|       |
   70|       | protected:
   71|       |  friend std::shared_ptr<ChannelCredentials> CompositeChannelCredentials(
   72|       |      const std::shared_ptr<ChannelCredentials>& channel_creds,
   73|       |      const std::shared_ptr<CallCredentials>& call_creds);
   74|       |
   75|       |  virtual SecureChannelCredentials* AsSecureCredentials() = 0;
   76|       |
   77|       | private:
   78|       |  friend std::shared_ptr<::grpc::Channel> CreateCustomChannelImpl(
   79|       |      const grpc::string& target,
   80|       |      const std::shared_ptr<ChannelCredentials>& creds,
   81|       |      const grpc::ChannelArguments& args);
   82|       |
   83|       |  friend std::shared_ptr<::grpc::Channel>
   84|       |  grpc_impl::experimental::CreateCustomChannelWithInterceptors(
   85|       |      const grpc::string& target,
   86|       |      const std::shared_ptr<ChannelCredentials>& creds,
   87|       |      const grpc::ChannelArguments& args,
   88|       |      std::vector<std::unique_ptr<
   89|       |          grpc::experimental::ClientInterceptorFactoryInterface>>
   90|       |          interceptor_creators);
   91|       |
   92|       |  virtual std::shared_ptr<::grpc::Channel> CreateChannelImpl(
   93|       |      const grpc::string& target, const grpc::ChannelArguments& args) = 0;
   94|       |
   95|       |  // This function should have been a pure virtual function, but it is
   96|       |  // implemented as a virtual function so that it does not break API.
   97|       |  virtual std::shared_ptr<::grpc::Channel> CreateChannelWithInterceptors(
   98|       |      const grpc::string& target, const grpc::ChannelArguments& args,
   99|       |      std::vector<std::unique_ptr<
  100|       |          grpc::experimental::ClientInterceptorFactoryInterface>>
  101|      0|          interceptor_creators) {
  102|      0|    return nullptr;
  103|      0|  }
  104|       |};
  105|       |
  106|       |/// A call credentials object encapsulates the state needed by a client to
  107|       |/// authenticate with a server for a given call on a channel.
  108|       |///
  109|       |/// \see https://grpc.io/docs/guides/auth.html
  110|       |class CallCredentials : private grpc::GrpcLibraryCodegen {
  111|       | public:
  112|       |  CallCredentials();
  113|       |  ~CallCredentials();
  114|       |
  115|       |  /// Apply this instance's credentials to \a call.
  116|       |  virtual bool ApplyToCall(grpc_call* call) = 0;
  117|       |
  118|       | protected:
  119|       |  friend std::shared_ptr<ChannelCredentials> CompositeChannelCredentials(
  120|       |      const std::shared_ptr<ChannelCredentials>& channel_creds,
  121|       |      const std::shared_ptr<CallCredentials>& call_creds);
  122|       |
  123|       |  friend std::shared_ptr<CallCredentials> CompositeCallCredentials(
  124|       |      const std::shared_ptr<CallCredentials>& creds1,
  125|       |      const std::shared_ptr<CallCredentials>& creds2);
  126|       |
  127|       |  virtual SecureCallCredentials* AsSecureCredentials() = 0;
  128|       |};
  129|       |
  130|       |/// Options used to build SslCredentials.
  131|       |struct SslCredentialsOptions {
  132|       |  /// The buffer containing the PEM encoding of the server root certificates. If
  133|       |  /// this parameter is empty, the default roots will be used.  The default
  134|       |  /// roots can be overridden using the \a GRPC_DEFAULT_SSL_ROOTS_FILE_PATH
  135|       |  /// environment variable pointing to a file on the file system containing the
  136|       |  /// roots.
  137|       |  grpc::string pem_root_certs;
  138|       |
  139|       |  /// The buffer containing the PEM encoding of the client's private key. This
  140|       |  /// parameter can be empty if the client does not have a private key.
  141|       |  grpc::string pem_private_key;
  142|       |
  143|       |  /// The buffer containing the PEM encoding of the client's certificate chain.
  144|       |  /// This parameter can be empty if the client does not have a certificate
  145|       |  /// chain.
  146|       |  grpc::string pem_cert_chain;
  147|       |};
  148|       |
  149|       |// Factories for building different types of Credentials The functions may
  150|       |// return empty shared_ptr when credentials cannot be created. If a
  151|       |// Credentials pointer is returned, it can still be invalid when used to create
  152|       |// a channel. A lame channel will be created then and all rpcs will fail on it.
  153|       |
  154|       |/// Builds credentials with reasonable defaults.
  155|       |///
  156|       |/// \warning Only use these credentials when connecting to a Google endpoint.
  157|       |/// Using these credentials to connect to any other service may result in this
  158|       |/// service being able to impersonate your client for requests to Google
  159|       |/// services.
  160|       |std::shared_ptr<ChannelCredentials> GoogleDefaultCredentials();
  161|       |
  162|       |/// Builds SSL Credentials given SSL specific options
  163|       |std::shared_ptr<ChannelCredentials> SslCredentials(
  164|       |    const SslCredentialsOptions& options);
  165|       |
  166|       |/// Builds credentials for use when running in GCE
  167|       |///
  168|       |/// \warning Only use these credentials when connecting to a Google endpoint.
  169|       |/// Using these credentials to connect to any other service may result in this
  170|       |/// service being able to impersonate your client for requests to Google
  171|       |/// services.
  172|       |std::shared_ptr<CallCredentials> GoogleComputeEngineCredentials();
  173|       |
  174|       |constexpr long kMaxAuthTokenLifetimeSecs = 3600;
  175|       |
  176|       |/// Builds Service Account JWT Access credentials.
  177|       |/// json_key is the JSON key string containing the client's private key.
  178|       |/// token_lifetime_seconds is the lifetime in seconds of each Json Web Token
  179|       |/// (JWT) created with this credentials. It should not exceed
  180|       |/// \a kMaxAuthTokenLifetimeSecs or will be cropped to this value.
  181|       |std::shared_ptr<CallCredentials> ServiceAccountJWTAccessCredentials(
  182|       |    const grpc::string& json_key,
  183|       |    long token_lifetime_seconds = grpc_impl::kMaxAuthTokenLifetimeSecs);
  184|       |
  185|       |/// Builds refresh token credentials.
  186|       |/// json_refresh_token is the JSON string containing the refresh token along
  187|       |/// with a client_id and client_secret.
  188|       |///
  189|       |/// \warning Only use these credentials when connecting to a Google endpoint.
  190|       |/// Using these credentials to connect to any other service may result in this
  191|       |/// service being able to impersonate your client for requests to Google
  192|       |/// services.
  193|       |std::shared_ptr<CallCredentials> GoogleRefreshTokenCredentials(
  194|       |    const grpc::string& json_refresh_token);
  195|       |
  196|       |/// Builds access token credentials.
  197|       |/// access_token is an oauth2 access token that was fetched using an out of band
  198|       |/// mechanism.
  199|       |///
  200|       |/// \warning Only use these credentials when connecting to a Google endpoint.
  201|       |/// Using these credentials to connect to any other service may result in this
  202|       |/// service being able to impersonate your client for requests to Google
  203|       |/// services.
  204|       |std::shared_ptr<CallCredentials> AccessTokenCredentials(
  205|       |    const grpc::string& access_token);
  206|       |
  207|       |/// Builds IAM credentials.
  208|       |///
  209|       |/// \warning Only use these credentials when connecting to a Google endpoint.
  210|       |/// Using these credentials to connect to any other service may result in this
  211|       |/// service being able to impersonate your client for requests to Google
  212|       |/// services.
  213|       |std::shared_ptr<CallCredentials> GoogleIAMCredentials(
  214|       |    const grpc::string& authorization_token,
  215|       |    const grpc::string& authority_selector);
  216|       |
  217|       |/// Combines a channel credentials and a call credentials into a composite
  218|       |/// channel credentials.
  219|       |std::shared_ptr<ChannelCredentials> CompositeChannelCredentials(
  220|       |    const std::shared_ptr<ChannelCredentials>& channel_creds,
  221|       |    const std::shared_ptr<CallCredentials>& call_creds);
  222|       |
  223|       |/// Combines two call credentials objects into a composite call credentials.
  224|       |std::shared_ptr<CallCredentials> CompositeCallCredentials(
  225|       |    const std::shared_ptr<CallCredentials>& creds1,
  226|       |    const std::shared_ptr<CallCredentials>& creds2);
  227|       |
  228|       |/// Credentials for an unencrypted, unauthenticated channel
  229|       |std::shared_ptr<ChannelCredentials> InsecureChannelCredentials();
  230|       |
  231|       |/// Credentials for a channel using Cronet.
  232|       |std::shared_ptr<ChannelCredentials> CronetChannelCredentials(void* engine);
  233|       |
  234|       |/// User defined metadata credentials.
  235|       |class MetadataCredentialsPlugin {
  236|       | public:
  237|      0|  virtual ~MetadataCredentialsPlugin() {}
  238|       |
  239|       |  /// If this method returns true, the Process function will be scheduled in
  240|       |  /// a different thread from the one processing the call.
  241|      0|  virtual bool IsBlocking() const { return true; }
  242|       |
  243|       |  /// Type of credentials this plugin is implementing.
  244|      0|  virtual const char* GetType() const { return ""; }
  245|       |
  246|       |  /// Gets the auth metatada produced by this plugin.
  247|       |  /// The fully qualified method name is:
  248|       |  /// service_url + "/" + method_name.
  249|       |  /// The channel_auth_context contains (among other things), the identity of
  250|       |  /// the server.
  251|       |  virtual grpc::Status GetMetadata(
  252|       |      grpc::string_ref service_url, grpc::string_ref method_name,
  253|       |      const grpc::AuthContext& channel_auth_context,
  254|       |      std::multimap<grpc::string, grpc::string>* metadata) = 0;
  255|       |};
  256|       |
  257|       |std::shared_ptr<CallCredentials> MetadataCredentialsFromPlugin(
  258|       |    std::unique_ptr<MetadataCredentialsPlugin> plugin);
  259|       |
  260|       |namespace experimental {
  261|       |
  262|       |/// Options used to build AltsCredentials.
  263|       |struct AltsCredentialsOptions {
  264|       |  /// service accounts of target endpoint that will be acceptable
  265|       |  /// by the client. If service accounts are provided and none of them matches
  266|       |  /// that of the server, authentication will fail.
  267|       |  std::vector<grpc::string> target_service_accounts;
  268|       |};
  269|       |
  270|       |/// Builds ALTS Credentials given ALTS specific options
  271|       |std::shared_ptr<ChannelCredentials> AltsCredentials(
  272|       |    const AltsCredentialsOptions& options);
  273|       |
  274|       |/// Builds Local Credentials.
  275|       |std::shared_ptr<ChannelCredentials> LocalCredentials(
  276|       |    grpc_local_connect_type type);
  277|       |
  278|       |}  // namespace experimental
  279|       |}  // namespace grpc_impl
  280|       |
  281|       |#endif  // GRPCPP_SECURITY_CREDENTIALS_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/security/server_credentials.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2019 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_SECURITY_SERVER_CREDENTIALS_H
   20|       |#define GRPCPP_SECURITY_SERVER_CREDENTIALS_H
   21|       |
   22|       |#include <grpcpp/security/server_credentials_impl.h>
   23|       |
   24|       |namespace grpc_impl {
   25|       |
   26|       |class Server;
   27|       |}  // namespace grpc_impl
   28|       |namespace grpc {
   29|       |
   30|       |typedef ::grpc_impl::ServerCredentials ServerCredentials;
   31|       |
   32|       |/// Options to create ServerCredentials with SSL
   33|       |struct SslServerCredentialsOptions {
   34|       |  /// \warning Deprecated
   35|       |  SslServerCredentialsOptions()
   36|       |      : force_client_auth(false),
   37|      0|        client_certificate_request(GRPC_SSL_DONT_REQUEST_CLIENT_CERTIFICATE) {}
   38|       |  SslServerCredentialsOptions(
   39|       |      grpc_ssl_client_certificate_request_type request_type)
   40|      0|      : force_client_auth(false), client_certificate_request(request_type) {}
   41|       |
   42|       |  struct PemKeyCertPair {
   43|       |    grpc::string private_key;
   44|       |    grpc::string cert_chain;
   45|       |  };
   46|       |  grpc::string pem_root_certs;
   47|       |  std::vector<PemKeyCertPair> pem_key_cert_pairs;
   48|       |  /// \warning Deprecated
   49|       |  bool force_client_auth;
   50|       |
   51|       |  /// If both \a force_client_auth and \a client_certificate_request
   52|       |  /// fields are set, \a force_client_auth takes effect, i.e.
   53|       |  /// \a REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_AND_VERIFY
   54|       |  /// will be enforced.
   55|       |  grpc_ssl_client_certificate_request_type client_certificate_request;
   56|       |};
   57|       |
   58|       |static inline std::shared_ptr<ServerCredentials> SslServerCredentials(
   59|      0|    const SslServerCredentialsOptions& options) {
   60|      0|  return ::grpc_impl::SslServerCredentials(options);
   61|      0|}
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZN4grpcL20SslServerCredentialsERKNS_27SslServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL20SslServerCredentialsERKNS_27SslServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL20SslServerCredentialsERKNS_27SslServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: insecure_server_credentials.cc:_ZN4grpcL20SslServerCredentialsERKNS_27SslServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: secure_server_credentials.cc:_ZN4grpcL20SslServerCredentialsERKNS_27SslServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZN4grpcL20SslServerCredentialsERKNS_27SslServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL20SslServerCredentialsERKNS_27SslServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZN4grpcL20SslServerCredentialsERKNS_27SslServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL20SslServerCredentialsERKNS_27SslServerCredentialsOptionsE
  ------------------
   62|       |
   63|      0|static inline std::shared_ptr<ServerCredentials> InsecureServerCredentials() {
   64|      0|  return ::grpc_impl::InsecureServerCredentials();
   65|      0|}
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZN4grpcL25InsecureServerCredentialsEv
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpcL25InsecureServerCredentialsEv
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpcL25InsecureServerCredentialsEv
  ------------------
  | Unexecuted instantiation: insecure_server_credentials.cc:_ZN4grpcL25InsecureServerCredentialsEv
  ------------------
  | Unexecuted instantiation: secure_server_credentials.cc:_ZN4grpcL25InsecureServerCredentialsEv
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZN4grpcL25InsecureServerCredentialsEv
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpcL25InsecureServerCredentialsEv
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZN4grpcL25InsecureServerCredentialsEv
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpcL25InsecureServerCredentialsEv
  ------------------
   66|       |
   67|       |namespace experimental {
   68|       |
   69|       |typedef ::grpc_impl::experimental::AltsServerCredentialsOptions
   70|       |    AltsServerCredentialsOptions;
   71|       |
   72|       |static inline std::shared_ptr<ServerCredentials> AltsServerCredentials(
   73|      0|    const AltsServerCredentialsOptions& options) {
   74|      0|  return ::grpc_impl::experimental::AltsServerCredentials(options);
   75|      0|}
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZN4grpc12experimentalL21AltsServerCredentialsERKN9grpc_impl12experimental28AltsServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpc12experimentalL21AltsServerCredentialsERKN9grpc_impl12experimental28AltsServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpc12experimentalL21AltsServerCredentialsERKN9grpc_impl12experimental28AltsServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: insecure_server_credentials.cc:_ZN4grpc12experimentalL21AltsServerCredentialsERKN9grpc_impl12experimental28AltsServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: secure_server_credentials.cc:_ZN4grpc12experimentalL21AltsServerCredentialsERKN9grpc_impl12experimental28AltsServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZN4grpc12experimentalL21AltsServerCredentialsERKN9grpc_impl12experimental28AltsServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpc12experimentalL21AltsServerCredentialsERKN9grpc_impl12experimental28AltsServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZN4grpc12experimentalL21AltsServerCredentialsERKN9grpc_impl12experimental28AltsServerCredentialsOptionsE
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpc12experimentalL21AltsServerCredentialsERKN9grpc_impl12experimental28AltsServerCredentialsOptionsE
  ------------------
   76|       |
   77|       |static inline std::shared_ptr<ServerCredentials> LocalServerCredentials(
   78|      0|    grpc_local_connect_type type) {
   79|      0|  return ::grpc_impl::experimental::LocalServerCredentials(type);
   80|      0|}
  ------------------
  | Unexecuted instantiation: async_generic_service.cc:_ZN4grpc12experimentalL22LocalServerCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: channel_arguments.cc:_ZN4grpc12experimentalL22LocalServerCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: default_health_check_service.cc:_ZN4grpc12experimentalL22LocalServerCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: insecure_server_credentials.cc:_ZN4grpc12experimentalL22LocalServerCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: secure_server_credentials.cc:_ZN4grpc12experimentalL22LocalServerCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: server_builder.cc:_ZN4grpc12experimentalL22LocalServerCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: server_cc.cc:_ZN4grpc12experimentalL22LocalServerCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: server_posix.cc:_ZN4grpc12experimentalL22LocalServerCredentialsE23grpc_local_connect_type
  ------------------
  | Unexecuted instantiation: version_cc.cc:_ZN4grpc12experimentalL22LocalServerCredentialsE23grpc_local_connect_type
  ------------------
   81|       |
   82|       |}  // namespace experimental
   83|       |}  // namespace grpc
   84|       |
   85|       |#endif  // GRPCPP_SECURITY_SERVER_CREDENTIALS_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/server_builder_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015-2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_SERVER_BUILDER_IMPL_H
   20|       |#define GRPCPP_SERVER_BUILDER_IMPL_H
   21|       |
   22|       |#include <climits>
   23|       |#include <map>
   24|       |#include <memory>
   25|       |#include <vector>
   26|       |
   27|       |#include <grpc/compression.h>
   28|       |#include <grpc/support/cpu.h>
   29|       |#include <grpc/support/workaround_list.h>
   30|       |#include <grpcpp/impl/channel_argument_option.h>
   31|       |#include <grpcpp/impl/codegen/server_interceptor.h>
   32|       |#include <grpcpp/impl/server_builder_option.h>
   33|       |#include <grpcpp/impl/server_builder_plugin.h>
   34|       |#include <grpcpp/server.h>
   35|       |#include <grpcpp/support/config.h>
   36|       |
   37|       |struct grpc_resource_quota;
   38|       |
   39|       |namespace grpc_impl {
   40|       |
   41|       |class CompletionQueue;
   42|       |class ResourceQuota;
   43|       |class Server;
   44|       |class ServerCompletionQueue;
   45|       |class ServerCredentials;
   46|       |}  // namespace grpc_impl
   47|       |namespace grpc {
   48|       |
   49|       |class AsyncGenericService;
   50|       |class Service;
   51|       |
   52|       |namespace testing {
   53|       |class ServerBuilderPluginTest;
   54|       |}  // namespace testing
   55|       |
   56|       |namespace experimental {
   57|       |class CallbackGenericService;
   58|       |}
   59|       |}  // namespace grpc
   60|       |namespace grpc_impl {
   61|       |
   62|       |/// A builder class for the creation and startup of \a grpc::Server instances.
   63|       |class ServerBuilder {
   64|       | public:
   65|       |  ServerBuilder();
   66|       |  virtual ~ServerBuilder();
   67|       |
   68|       |  //////////////////////////////////////////////////////////////////////////////
   69|       |  // Primary API's
   70|       |
   71|       |  /// Return a running server which is ready for processing calls.
   72|       |  /// Before calling, one typically needs to ensure that:
   73|       |  ///  1. a service is registered - so that the server knows what to serve
   74|       |  ///     (via RegisterService, or RegisterAsyncGenericService)
   75|       |  ///  2. a listening port has been added - so the server knows where to receive
   76|       |  ///     traffic (via AddListeningPort)
   77|       |  ///  3. [for async api only] completion queues have been added via
   78|       |  ///     AddCompletionQueue
   79|       |  virtual std::unique_ptr<grpc::Server> BuildAndStart();
   80|       |
   81|       |  /// Register a service. This call does not take ownership of the service.
   82|       |  /// The service must exist for the lifetime of the \a Server instance returned
   83|       |  /// by \a BuildAndStart().
   84|       |  /// Matches requests with any :authority
   85|       |  ServerBuilder& RegisterService(grpc::Service* service);
   86|       |
   87|       |  /// Enlists an endpoint \a addr (port with an optional IP address) to
   88|       |  /// bind the \a grpc::Server object to be created to.
   89|       |  ///
   90|       |  /// It can be invoked multiple times.
   91|       |  ///
   92|       |  /// \param addr_uri The address to try to bind to the server in URI form. If
   93|       |  /// the scheme name is omitted, "dns:///" is assumed. To bind to any address,
   94|       |  /// please use IPv6 any, i.e., [::]:<port>, which also accepts IPv4
   95|       |  /// connections.  Valid values include dns:///localhost:1234, /
   96|       |  /// 192.168.1.1:31416, dns:///[::1]:27182, etc.).
   97|       |  /// \param creds The credentials associated with the server.
   98|       |  /// \param selected_port[out] If not `nullptr`, gets populated with the port
   99|       |  /// number bound to the \a grpc::Server for the corresponding endpoint after
  100|       |  /// it is successfully bound by BuildAndStart(), 0 otherwise. AddListeningPort
  101|       |  /// does not modify this pointer.
  102|       |  ServerBuilder& AddListeningPort(
  103|       |      const grpc::string& addr_uri,
  104|       |      std::shared_ptr<grpc_impl::ServerCredentials> creds,
  105|       |      int* selected_port = nullptr);
  106|       |
  107|       |  /// Add a completion queue for handling asynchronous services.
  108|       |  ///
  109|       |  /// Best performance is typically obtained by using one thread per polling
  110|       |  /// completion queue.
  111|       |  ///
  112|       |  /// Caller is required to shutdown the server prior to shutting down the
  113|       |  /// returned completion queue. Caller is also required to drain the
  114|       |  /// completion queue after shutting it down. A typical usage scenario:
  115|       |  ///
  116|       |  /// // While building the server:
  117|       |  /// ServerBuilder builder;
  118|       |  /// ...
  119|       |  /// cq_ = builder.AddCompletionQueue();
  120|       |  /// server_ = builder.BuildAndStart();
  121|       |  ///
  122|       |  /// // While shutting down the server;
  123|       |  /// server_->Shutdown();
  124|       |  /// cq_->Shutdown();  // Always *after* the associated server's Shutdown()!
  125|       |  /// // Drain the cq_ that was created
  126|       |  /// void* ignored_tag;
  127|       |  /// bool ignored_ok;
  128|       |  /// while (cq_->Next(&ignored_tag, &ignored_ok)) { }
  129|       |  ///
  130|       |  /// \param is_frequently_polled This is an optional parameter to inform gRPC
  131|       |  /// library about whether this completion queue would be frequently polled
  132|       |  /// (i.e. by calling \a Next() or \a AsyncNext()). The default value is
  133|       |  /// 'true' and is the recommended setting. Setting this to 'false' (i.e.
  134|       |  /// not polling the completion queue frequently) will have a significantly
  135|       |  /// negative performance impact and hence should not be used in production
  136|       |  /// use cases.
  137|       |  std::unique_ptr<grpc_impl::ServerCompletionQueue> AddCompletionQueue(
  138|       |      bool is_frequently_polled = true);
  139|       |
  140|       |  //////////////////////////////////////////////////////////////////////////////
  141|       |  // Less commonly used RegisterService variants
  142|       |
  143|       |  /// Register a service. This call does not take ownership of the service.
  144|       |  /// The service must exist for the lifetime of the \a Server instance
  145|       |  /// returned by \a BuildAndStart(). Only matches requests with :authority \a
  146|       |  /// host
  147|       |  ServerBuilder& RegisterService(const grpc::string& host,
  148|       |                                 grpc::Service* service);
  149|       |
  150|       |  /// Register a generic service.
  151|       |  /// Matches requests with any :authority
  152|       |  /// This is mostly useful for writing generic gRPC Proxies where the exact
  153|       |  /// serialization format is unknown
  154|       |  ServerBuilder& RegisterAsyncGenericService(
  155|       |      grpc::AsyncGenericService* service);
  156|       |
  157|       |  //////////////////////////////////////////////////////////////////////////////
  158|       |  // Fine control knobs
  159|       |
  160|       |  /// Set max receive message size in bytes.
  161|       |  /// The default is GRPC_DEFAULT_MAX_RECV_MESSAGE_LENGTH.
  162|      0|  ServerBuilder& SetMaxReceiveMessageSize(int max_receive_message_size) {
  163|      0|    max_receive_message_size_ = max_receive_message_size;
  164|      0|    return *this;
  165|      0|  }
  166|       |
  167|       |  /// Set max send message size in bytes.
  168|       |  /// The default is GRPC_DEFAULT_MAX_SEND_MESSAGE_LENGTH.
  169|      0|  ServerBuilder& SetMaxSendMessageSize(int max_send_message_size) {
  170|      0|    max_send_message_size_ = max_send_message_size;
  171|      0|    return *this;
  172|      0|  }
  173|       |
  174|       |  /// \deprecated For backward compatibility.
  175|      0|  ServerBuilder& SetMaxMessageSize(int max_message_size) {
  176|      0|    return SetMaxReceiveMessageSize(max_message_size);
  177|      0|  }
  178|       |
  179|       |  /// Set the support status for compression algorithms. All algorithms are
  180|       |  /// enabled by default.
  181|       |  ///
  182|       |  /// Incoming calls compressed with an unsupported algorithm will fail with
  183|       |  /// \a GRPC_STATUS_UNIMPLEMENTED.
  184|       |  ServerBuilder& SetCompressionAlgorithmSupportStatus(
  185|       |      grpc_compression_algorithm algorithm, bool enabled);
  186|       |
  187|       |  /// The default compression level to use for all channel calls in the
  188|       |  /// absence of a call-specific level.
  189|       |  ServerBuilder& SetDefaultCompressionLevel(grpc_compression_level level);
  190|       |
  191|       |  /// The default compression algorithm to use for all channel calls in the
  192|       |  /// absence of a call-specific level. Note that it overrides any compression
  193|       |  /// level set by \a SetDefaultCompressionLevel.
  194|       |  ServerBuilder& SetDefaultCompressionAlgorithm(
  195|       |      grpc_compression_algorithm algorithm);
  196|       |
  197|       |  /// Set the attached buffer pool for this server
  198|       |  ServerBuilder& SetResourceQuota(
  199|       |      const grpc_impl::ResourceQuota& resource_quota);
  200|       |
  201|       |  ServerBuilder& SetOption(std::unique_ptr<grpc::ServerBuilderOption> option);
  202|       |
  203|       |  /// Options for synchronous servers.
  204|       |  enum SyncServerOption {
  205|       |    NUM_CQS,         ///< Number of completion queues.
  206|       |    MIN_POLLERS,     ///< Minimum number of polling threads.
  207|       |    MAX_POLLERS,     ///< Maximum number of polling threads.
  208|       |    CQ_TIMEOUT_MSEC  ///< Completion queue timeout in milliseconds.
  209|       |  };
  210|       |
  211|       |  /// Only useful if this is a Synchronous server.
  212|       |  ServerBuilder& SetSyncServerOption(SyncServerOption option, int value);
  213|       |
  214|       |  /// Add a channel argument (an escape hatch to tuning core library parameters
  215|       |  /// directly)
  216|       |  template <class T>
  217|      0|  ServerBuilder& AddChannelArgument(const grpc::string& arg, const T& value) {
  218|      0|    return SetOption(grpc::MakeChannelArgumentOption(arg, value));
  219|      0|  }
  220|       |
  221|       |  /// For internal use only: Register a ServerBuilderPlugin factory function.
  222|       |  static void InternalAddPluginFactory(
  223|       |      std::unique_ptr<grpc::ServerBuilderPlugin> (*CreatePlugin)());
  224|       |
  225|       |  /// Enable a server workaround. Do not use unless you know what the workaround
  226|       |  /// does. For explanation and detailed descriptions of workarounds, see
  227|       |  /// doc/workarounds.md.
  228|       |  ServerBuilder& EnableWorkaround(grpc_workaround_list id);
  229|       |
  230|       |  /// NOTE: class experimental_type is not part of the public API of this class.
  231|       |  /// TODO(yashykt): Integrate into public API when this is no longer
  232|       |  /// experimental.
  233|       |  class experimental_type {
  234|       |   public:
  235|       |    explicit experimental_type(grpc_impl::ServerBuilder* builder)
  236|      0|        : builder_(builder) {}
  237|       |
  238|       |    void SetInterceptorCreators(
  239|       |        std::vector<std::unique_ptr<
  240|       |            grpc::experimental::ServerInterceptorFactoryInterface>>
  241|      0|            interceptor_creators) {
  242|      0|      builder_->interceptor_creators_ = std::move(interceptor_creators);
  243|      0|    }
  244|       |
  245|       |    /// Register a generic service that uses the callback API.
  246|       |    /// Matches requests with any :authority
  247|       |    /// This is mostly useful for writing generic gRPC Proxies where the exact
  248|       |    /// serialization format is unknown
  249|       |    ServerBuilder& RegisterCallbackGenericService(
  250|       |        grpc::experimental::CallbackGenericService* service);
  251|       |
  252|       |   private:
  253|       |    ServerBuilder* builder_;
  254|       |  };
  255|       |
  256|       |  /// NOTE: The function experimental() is not stable public API. It is a view
  257|       |  /// to the experimental components of this class. It may be changed or removed
  258|       |  /// at any time.
  259|      0|  experimental_type experimental() { return experimental_type(this); }
  260|       |
  261|       | protected:
  262|       |  /// Experimental, to be deprecated
  263|       |  struct Port {
  264|       |    grpc::string addr;
  265|       |    std::shared_ptr<grpc_impl::ServerCredentials> creds;
  266|       |    int* selected_port;
  267|       |  };
  268|       |
  269|       |  /// Experimental, to be deprecated
  270|       |  typedef std::unique_ptr<grpc::string> HostString;
  271|       |  struct NamedService {
  272|      0|    explicit NamedService(grpc::Service* s) : service(s) {}
  273|       |    NamedService(const grpc::string& h, grpc::Service* s)
  274|      0|        : host(new grpc::string(h)), service(s) {}
  275|       |    HostString host;
  276|       |    grpc::Service* service;
  277|       |  };
  278|       |
  279|       |  /// Experimental, to be deprecated
  280|      0|  std::vector<Port> ports() { return ports_; }
  281|       |
  282|       |  /// Experimental, to be deprecated
  283|      0|  std::vector<NamedService*> services() {
  284|      0|    std::vector<NamedService*> service_refs;
  285|      0|    for (auto& ptr : services_) {
  286|      0|      service_refs.push_back(ptr.get());
  287|      0|    }
  288|      0|    return service_refs;
  289|      0|  }
  290|       |
  291|       |  /// Experimental, to be deprecated
  292|      0|  std::vector<grpc::ServerBuilderOption*> options() {
  293|      0|    std::vector<grpc::ServerBuilderOption*> option_refs;
  294|      0|    for (auto& ptr : options_) {
  295|      0|      option_refs.push_back(ptr.get());
  296|      0|    }
  297|      0|    return option_refs;
  298|      0|  }
  299|       |
  300|       | private:
  301|       |  friend class ::grpc::testing::ServerBuilderPluginTest;
  302|       |
  303|       |  struct SyncServerSettings {
  304|       |    SyncServerSettings()
  305|      0|        : num_cqs(1), min_pollers(1), max_pollers(2), cq_timeout_msec(10000) {}
  306|       |
  307|       |    /// Number of server completion queues to create to listen to incoming RPCs.
  308|       |    int num_cqs;
  309|       |
  310|       |    /// Minimum number of threads per completion queue that should be listening
  311|       |    /// to incoming RPCs.
  312|       |    int min_pollers;
  313|       |
  314|       |    /// Maximum number of threads per completion queue that can be listening to
  315|       |    /// incoming RPCs.
  316|       |    int max_pollers;
  317|       |
  318|       |    /// The timeout for server completion queue's AsyncNext call.
  319|       |    int cq_timeout_msec;
  320|       |  };
  321|       |
  322|       |  int max_receive_message_size_;
  323|       |  int max_send_message_size_;
  324|       |  std::vector<std::unique_ptr<grpc::ServerBuilderOption>> options_;
  325|       |  std::vector<std::unique_ptr<NamedService>> services_;
  326|       |  std::vector<Port> ports_;
  327|       |
  328|       |  SyncServerSettings sync_server_settings_;
  329|       |
  330|       |  /// List of completion queues added via \a AddCompletionQueue method.
  331|       |  std::vector<grpc_impl::ServerCompletionQueue*> cqs_;
  332|       |
  333|       |  std::shared_ptr<grpc_impl::ServerCredentials> creds_;
  334|       |  std::vector<std::unique_ptr<grpc::ServerBuilderPlugin>> plugins_;
  335|       |  grpc_resource_quota* resource_quota_;
  336|       |  grpc::AsyncGenericService* generic_service_{nullptr};
  337|       |  grpc::experimental::CallbackGenericService* callback_generic_service_{
  338|       |      nullptr};
  339|       |  struct {
  340|       |    bool is_set;
  341|       |    grpc_compression_level level;
  342|       |  } maybe_default_compression_level_;
  343|       |  struct {
  344|       |    bool is_set;
  345|       |    grpc_compression_algorithm algorithm;
  346|       |  } maybe_default_compression_algorithm_;
  347|       |  uint32_t enabled_compression_algorithms_bitset_;
  348|       |  std::vector<
  349|       |      std::unique_ptr<grpc::experimental::ServerInterceptorFactoryInterface>>
  350|       |      interceptor_creators_;
  351|       |};
  352|       |
  353|       |}  // namespace grpc_impl
  354|       |
  355|       |#endif  // GRPCPP_SERVER_BUILDER_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/server_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_SERVER_IMPL_H
   20|       |#define GRPCPP_SERVER_IMPL_H
   21|       |
   22|       |#include <condition_variable>
   23|       |#include <list>
   24|       |#include <memory>
   25|       |#include <mutex>
   26|       |#include <vector>
   27|       |
   28|       |#include <grpc/compression.h>
   29|       |#include <grpc/support/atm.h>
   30|       |#include <grpcpp/channel.h>
   31|       |#include <grpcpp/completion_queue.h>
   32|       |#include <grpcpp/health_check_service_interface.h>
   33|       |#include <grpcpp/impl/call.h>
   34|       |#include <grpcpp/impl/codegen/client_interceptor.h>
   35|       |#include <grpcpp/impl/codegen/grpc_library.h>
   36|       |#include <grpcpp/impl/codegen/server_interface.h>
   37|       |#include <grpcpp/impl/rpc_service_method.h>
   38|       |#include <grpcpp/security/server_credentials.h>
   39|       |#include <grpcpp/support/channel_arguments.h>
   40|       |#include <grpcpp/support/config.h>
   41|       |#include <grpcpp/support/status.h>
   42|       |
   43|       |struct grpc_server;
   44|       |
   45|       |namespace grpc {
   46|       |
   47|       |class AsyncGenericService;
   48|       |class ServerContext;
   49|       |
   50|       |}  // namespace grpc
   51|       |
   52|       |namespace grpc_impl {
   53|       |
   54|       |class ServerInitializer;
   55|       |
   56|       |/// Represents a gRPC server.
   57|       |///
   58|       |/// Use a \a grpc::ServerBuilder to create, configure, and start
   59|       |/// \a Server instances.
   60|       |class Server : public grpc::ServerInterface, private grpc::GrpcLibraryCodegen {
   61|       | public:
   62|       |  ~Server();
   63|       |
   64|       |  /// Block until the server shuts down.
   65|       |  ///
   66|       |  /// \warning The server must be either shutting down or some other thread must
   67|       |  /// call \a Shutdown for this function to ever return.
   68|       |  void Wait() override;
   69|       |
   70|       |  /// Global callbacks are a set of hooks that are called when server
   71|       |  /// events occur.  \a SetGlobalCallbacks method is used to register
   72|       |  /// the hooks with gRPC.  Note that
   73|       |  /// the \a GlobalCallbacks instance will be shared among all
   74|       |  /// \a Server instances in an application and can be set exactly
   75|       |  /// once per application.
   76|       |  class GlobalCallbacks {
   77|       |   public:
   78|      0|    virtual ~GlobalCallbacks() {}
   79|       |    /// Called before server is created.
   80|      0|    virtual void UpdateArguments(grpc::ChannelArguments* args) {}
   81|       |    /// Called before application callback for each synchronous server request
   82|       |    virtual void PreSynchronousRequest(grpc::ServerContext* context) = 0;
   83|       |    /// Called after application callback for each synchronous server request
   84|       |    virtual void PostSynchronousRequest(grpc::ServerContext* context) = 0;
   85|       |    /// Called before server is started.
   86|      0|    virtual void PreServerStart(Server* server) {}
   87|       |    /// Called after a server port is added.
   88|       |    virtual void AddPort(Server* server, const grpc::string& addr,
   89|      0|                         grpc::ServerCredentials* creds, int port) {}
   90|       |  };
   91|       |  /// Set the global callback object. Can only be called once per application.
   92|       |  /// Does not take ownership of callbacks, and expects the pointed to object
   93|       |  /// to be alive until all server objects in the process have been destroyed.
   94|       |  /// The same \a GlobalCallbacks object will be used throughout the
   95|       |  /// application and is shared among all \a Server objects.
   96|       |  static void SetGlobalCallbacks(GlobalCallbacks* callbacks);
   97|       |
   98|       |  /// Returns a \em raw pointer to the underlying \a grpc_server instance.
   99|       |  /// EXPERIMENTAL:  for internal/test use only
  100|       |  grpc_server* c_server();
  101|       |
  102|       |  /// Returns the health check service.
  103|      0|  grpc::HealthCheckServiceInterface* GetHealthCheckService() const {
  104|      0|    return health_check_service_.get();
  105|      0|  }
  106|       |
  107|       |  /// Establish a channel for in-process communication
  108|       |  std::shared_ptr<::grpc::Channel> InProcessChannel(
  109|       |      const grpc::ChannelArguments& args);
  110|       |
  111|       |  /// NOTE: class experimental_type is not part of the public API of this class.
  112|       |  /// TODO(yashykt): Integrate into public API when this is no longer
  113|       |  /// experimental.
  114|       |  class experimental_type {
  115|       |   public:
  116|      0|    explicit experimental_type(Server* server) : server_(server) {}
  117|       |
  118|       |    /// Establish a channel for in-process communication with client
  119|       |    /// interceptors
  120|       |    std::shared_ptr<::grpc::Channel> InProcessChannelWithInterceptors(
  121|       |        const grpc::ChannelArguments& args,
  122|       |        std::vector<std::unique_ptr<
  123|       |            grpc::experimental::ClientInterceptorFactoryInterface>>
  124|       |            interceptor_creators);
  125|       |
  126|       |   private:
  127|       |    Server* server_;
  128|       |  };
  129|       |
  130|       |  /// NOTE: The function experimental() is not stable public API. It is a view
  131|       |  /// to the experimental components of this class. It may be changed or removed
  132|       |  /// at any time.
  133|      0|  experimental_type experimental() { return experimental_type(this); }
  134|       |
  135|       | protected:
  136|       |  /// Register a service. This call does not take ownership of the service.
  137|       |  /// The service must exist for the lifetime of the Server instance.
  138|       |  bool RegisterService(const grpc::string* host,
  139|       |                       grpc::Service* service) override;
  140|       |
  141|       |  /// Try binding the server to the given \a addr endpoint
  142|       |  /// (port, and optionally including IP address to bind to).
  143|       |  ///
  144|       |  /// It can be invoked multiple times. Should be used before
  145|       |  /// starting the server.
  146|       |  ///
  147|       |  /// \param addr The address to try to bind to the server (eg, localhost:1234,
  148|       |  /// 192.168.1.1:31416, [::1]:27182, etc.).
  149|       |  /// \param creds The credentials associated with the server.
  150|       |  ///
  151|       |  /// \return bound port number on success, 0 on failure.
  152|       |  ///
  153|       |  /// \warning It is an error to call this method on an already started server.
  154|       |  int AddListeningPort(const grpc::string& addr,
  155|       |                       grpc::ServerCredentials* creds) override;
  156|       |
  157|       |  /// NOTE: This is *NOT* a public API. The server constructors are supposed to
  158|       |  /// be used by \a ServerBuilder class only. The constructor will be made
  159|       |  /// 'private' very soon.
  160|       |  ///
  161|       |  /// Server constructors. To be used by \a ServerBuilder only.
  162|       |  ///
  163|       |  /// \param max_message_size Maximum message length that the channel can
  164|       |  /// receive.
  165|       |  ///
  166|       |  /// \param args The channel args
  167|       |  ///
  168|       |  /// \param sync_server_cqs The completion queues to use if the server is a
  169|       |  /// synchronous server (or a hybrid server). The server polls for new RPCs on
  170|       |  /// these queues
  171|       |  ///
  172|       |  /// \param min_pollers The minimum number of polling threads per server
  173|       |  /// completion queue (in param sync_server_cqs) to use for listening to
  174|       |  /// incoming requests (used only in case of sync server)
  175|       |  ///
  176|       |  /// \param max_pollers The maximum number of polling threads per server
  177|       |  /// completion queue (in param sync_server_cqs) to use for listening to
  178|       |  /// incoming requests (used only in case of sync server)
  179|       |  ///
  180|       |  /// \param sync_cq_timeout_msec The timeout to use when calling AsyncNext() on
  181|       |  /// server completion queues passed via sync_server_cqs param.
  182|       |  Server(
  183|       |      int max_message_size, grpc::ChannelArguments* args,
  184|       |      std::shared_ptr<std::vector<std::unique_ptr<grpc::ServerCompletionQueue>>>
  185|       |          sync_server_cqs,
  186|       |      int min_pollers, int max_pollers, int sync_cq_timeout_msec,
  187|       |      grpc_resource_quota* server_rq = nullptr,
  188|       |      std::vector<std::unique_ptr<
  189|       |          grpc::experimental::ServerInterceptorFactoryInterface>>
  190|       |          interceptor_creators = std::vector<std::unique_ptr<
  191|       |              grpc::experimental::ServerInterceptorFactoryInterface>>());
  192|       |
  193|       |  /// Start the server.
  194|       |  ///
  195|       |  /// \param cqs Completion queues for handling asynchronous services. The
  196|       |  /// caller is required to keep all completion queues live until the server is
  197|       |  /// destroyed.
  198|       |  /// \param num_cqs How many completion queues does \a cqs hold.
  199|       |  void Start(grpc::ServerCompletionQueue** cqs, size_t num_cqs) override;
  200|       |
  201|      0|  grpc_server* server() override { return server_; }
  202|       |
  203|       | private:
  204|       |  std::vector<
  205|       |      std::unique_ptr<grpc::experimental::ServerInterceptorFactoryInterface>>*
  206|      0|  interceptor_creators() override {
  207|      0|    return &interceptor_creators_;
  208|      0|  }
  209|       |
  210|       |  friend class grpc::AsyncGenericService;
  211|       |  friend class grpc_impl::ServerBuilder;
  212|       |  friend class grpc_impl::ServerInitializer;
  213|       |
  214|       |  class SyncRequest;
  215|       |  class CallbackRequestBase;
  216|       |  template <class ServerContextType>
  217|       |  class CallbackRequest;
  218|       |  class UnimplementedAsyncRequest;
  219|       |  class UnimplementedAsyncResponse;
  220|       |
  221|       |  /// SyncRequestThreadManager is an implementation of ThreadManager. This class
  222|       |  /// is responsible for polling for incoming RPCs and calling the RPC handlers.
  223|       |  /// This is only used in case of a Sync server (i.e a server exposing a sync
  224|       |  /// interface)
  225|       |  class SyncRequestThreadManager;
  226|       |
  227|       |  /// Register a generic service. This call does not take ownership of the
  228|       |  /// service. The service must exist for the lifetime of the Server instance.
  229|       |  void RegisterAsyncGenericService(grpc::AsyncGenericService* service) override;
  230|       |
  231|       |  /// NOTE: class experimental_registration_type is not part of the public API
  232|       |  /// of this class
  233|       |  /// TODO(vjpai): Move these contents to the public API of Server when
  234|       |  ///              they are no longer experimental
  235|       |  class experimental_registration_type final
  236|       |      : public experimental_registration_interface {
  237|       |   public:
  238|      0|    explicit experimental_registration_type(Server* server) : server_(server) {}
  239|       |    void RegisterCallbackGenericService(
  240|      0|        grpc::experimental::CallbackGenericService* service) override {
  241|      0|      server_->RegisterCallbackGenericService(service);
  242|      0|    }
  243|       |
  244|       |   private:
  245|       |    Server* server_;
  246|       |  };
  247|       |
  248|       |  /// TODO(vjpai): Mark this override when experimental type above is deleted
  249|       |  void RegisterCallbackGenericService(
  250|       |      grpc::experimental::CallbackGenericService* service);
  251|       |
  252|       |  /// NOTE: The function experimental_registration() is not stable public API.
  253|       |  /// It is a view to the experimental components of this class. It may be
  254|       |  /// changed or removed at any time.
  255|      0|  experimental_registration_interface* experimental_registration() override {
  256|      0|    return &experimental_registration_;
  257|      0|  }
  258|       |
  259|       |  void PerformOpsOnCall(grpc::internal::CallOpSetInterface* ops,
  260|       |                        grpc::internal::Call* call) override;
  261|       |
  262|       |  void ShutdownInternal(gpr_timespec deadline) override;
  263|       |
  264|      0|  int max_receive_message_size() const override {
  265|      0|    return max_receive_message_size_;
  266|      0|  }
  267|       |
  268|       |  grpc::CompletionQueue* CallbackCQ() override;
  269|       |
  270|       |  grpc_impl::ServerInitializer* initializer();
  271|       |
  272|       |  // A vector of interceptor factory objects.
  273|       |  // This should be destroyed after health_check_service_ and this requirement
  274|       |  // is satisfied by declaring interceptor_creators_ before
  275|       |  // health_check_service_. (C++ mandates that member objects be destroyed in
  276|       |  // the reverse order of initialization.)
  277|       |  std::vector<
  278|       |      std::unique_ptr<grpc::experimental::ServerInterceptorFactoryInterface>>
  279|       |      interceptor_creators_;
  280|       |
  281|       |  const int max_receive_message_size_;
  282|       |
  283|       |  /// The following completion queues are ONLY used in case of Sync API
  284|       |  /// i.e. if the server has any services with sync methods. The server uses
  285|       |  /// these completion queues to poll for new RPCs
  286|       |  std::shared_ptr<std::vector<std::unique_ptr<grpc::ServerCompletionQueue>>>
  287|       |      sync_server_cqs_;
  288|       |
  289|       |  /// List of \a ThreadManager instances (one for each cq in
  290|       |  /// the \a sync_server_cqs)
  291|       |  std::vector<std::unique_ptr<SyncRequestThreadManager>> sync_req_mgrs_;
  292|       |
  293|       |  // Outstanding unmatched callback requests, indexed by method.
  294|       |  // NOTE: Using a gpr_atm rather than atomic_int because atomic_int isn't
  295|       |  //       copyable or movable and thus will cause compilation errors. We
  296|       |  //       actually only want to extend the vector before the threaded use
  297|       |  //       starts, but this is still a limitation.
  298|       |  std::vector<gpr_atm> callback_unmatched_reqs_count_;
  299|       |
  300|       |  // List of callback requests to start when server actually starts.
  301|       |  std::list<CallbackRequestBase*> callback_reqs_to_start_;
  302|       |
  303|       |  // For registering experimental callback generic service; remove when that
  304|       |  // method longer experimental
  305|       |  experimental_registration_type experimental_registration_{this};
  306|       |
  307|       |  // Server status
  308|       |  grpc::internal::Mutex mu_;
  309|       |  bool started_;
  310|       |  bool shutdown_;
  311|       |  bool shutdown_notified_;  // Was notify called on the shutdown_cv_
  312|       |
  313|       |  grpc::internal::CondVar shutdown_cv_;
  314|       |
  315|       |  // It is ok (but not required) to nest callback_reqs_mu_ under mu_ .
  316|       |  // Incrementing callback_reqs_outstanding_ is ok without a lock but it must be
  317|       |  // decremented under the lock in case it is the last request and enables the
  318|       |  // server shutdown. The increment is performance-critical since it happens
  319|       |  // during periods of increasing load; the decrement happens only when memory
  320|       |  // is maxed out, during server shutdown, or (possibly in a future version)
  321|       |  // during decreasing load, so it is less performance-critical.
  322|       |  grpc::internal::Mutex callback_reqs_mu_;
  323|       |  grpc::internal::CondVar callback_reqs_done_cv_;
  324|       |  std::atomic_int callback_reqs_outstanding_{0};
  325|       |
  326|       |  std::shared_ptr<GlobalCallbacks> global_callbacks_;
  327|       |
  328|       |  std::vector<grpc::string> services_;
  329|       |  bool has_async_generic_service_{false};
  330|       |  bool has_callback_generic_service_{false};
  331|       |
  332|       |  // Pointer to the wrapped grpc_server.
  333|       |  grpc_server* server_;
  334|       |
  335|       |  std::unique_ptr<grpc_impl::ServerInitializer> server_initializer_;
  336|       |
  337|       |  std::unique_ptr<grpc::HealthCheckServiceInterface> health_check_service_;
  338|       |  bool health_check_service_disabled_;
  339|       |
  340|       |  // When appropriate, use a default callback generic service to handle
  341|       |  // unimplemented methods
  342|       |  std::unique_ptr<grpc::experimental::CallbackGenericService>
  343|       |      unimplemented_service_;
  344|       |
  345|       |  // A special handler for resource exhausted in sync case
  346|       |  std::unique_ptr<grpc::internal::MethodHandler> resource_exhausted_handler_;
  347|       |
  348|       |  // Handler for callback generic service, if any
  349|       |  std::unique_ptr<grpc::internal::MethodHandler> generic_handler_;
  350|       |
  351|       |  // callback_cq_ references the callbackable completion queue associated
  352|       |  // with this server (if any). It is set on the first call to CallbackCQ().
  353|       |  // It is _not owned_ by the server; ownership belongs with its internal
  354|       |  // shutdown callback tag (invoked when the CQ is fully shutdown).
  355|       |  // It is protected by mu_
  356|       |  grpc::CompletionQueue* callback_cq_ = nullptr;
  357|       |};
  358|       |
  359|       |}  // namespace grpc_impl
  360|       |
  361|       |#endif  // GRPCPP_SERVER_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/include/grpcpp/support/channel_arguments_impl.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCPP_SUPPORT_CHANNEL_ARGUMENTS_IMPL_H
   20|       |#define GRPCPP_SUPPORT_CHANNEL_ARGUMENTS_IMPL_H
   21|       |
   22|       |#include <list>
   23|       |#include <vector>
   24|       |
   25|       |#include <grpc/compression.h>
   26|       |#include <grpc/grpc.h>
   27|       |#include <grpcpp/resource_quota.h>
   28|       |#include <grpcpp/support/config.h>
   29|       |
   30|       |namespace grpc {
   31|       |namespace testing {
   32|       |class ChannelArgumentsTest;
   33|       |}  // namespace testing
   34|       |}  // namespace grpc
   35|       |
   36|       |namespace grpc_impl {
   37|       |
   38|       |class SecureChannelCredentials;
   39|       |
   40|       |/// Options for channel creation. The user can use generic setters to pass
   41|       |/// key value pairs down to C channel creation code. For gRPC related options,
   42|       |/// concrete setters are provided.
   43|       |class ChannelArguments {
   44|       | public:
   45|       |  ChannelArguments();
   46|       |  ~ChannelArguments();
   47|       |
   48|       |  ChannelArguments(const ChannelArguments& other);
   49|      0|  ChannelArguments& operator=(ChannelArguments other) {
   50|      0|    Swap(other);
   51|      0|    return *this;
   52|      0|  }
   53|       |
   54|       |  void Swap(ChannelArguments& other);
   55|       |
   56|       |  /// Dump arguments in this instance to \a channel_args. Does not take
   57|       |  /// ownership of \a channel_args.
   58|       |  ///
   59|       |  /// Note that the underlying arguments are shared. Changes made to either \a
   60|       |  /// channel_args or this instance would be reflected on both.
   61|       |  void SetChannelArgs(grpc_channel_args* channel_args) const;
   62|       |
   63|       |  // gRPC specific channel argument setters
   64|       |  /// Set target name override for SSL host name checking. This option is for
   65|       |  /// testing only and should never be used in production.
   66|       |  void SetSslTargetNameOverride(const grpc::string& name);
   67|       |  // TODO(yangg) add flow control options
   68|       |  /// Set the compression algorithm for the channel.
   69|       |  void SetCompressionAlgorithm(grpc_compression_algorithm algorithm);
   70|       |
   71|       |  /// Set the grpclb fallback timeout (in ms) for the channel. If this amount
   72|       |  /// of time has passed but we have not gotten any non-empty \a serverlist from
   73|       |  /// the balancer, we will fall back to use the backend address(es) returned by
   74|       |  /// the resolver.
   75|       |  void SetGrpclbFallbackTimeout(int fallback_timeout);
   76|       |
   77|       |  /// For client channel's, the socket mutator operates on
   78|       |  /// "channel" sockets. For server's, the socket mutator operates
   79|       |  /// only on "listen" sockets.
   80|       |  /// TODO(apolcyn): allow socket mutators to also operate
   81|       |  /// on server "channel" sockets, and adjust the socket mutator
   82|       |  /// object to be more speficic about which type of socket
   83|       |  /// it should operate on.
   84|       |  void SetSocketMutator(grpc_socket_mutator* mutator);
   85|       |
   86|       |  /// Set the string to prepend to the user agent.
   87|       |  void SetUserAgentPrefix(const grpc::string& user_agent_prefix);
   88|       |
   89|       |  /// Set the buffer pool to be attached to the constructed channel.
   90|       |  void SetResourceQuota(const grpc::ResourceQuota& resource_quota);
   91|       |
   92|       |  /// Set the max receive and send message sizes.
   93|       |  void SetMaxReceiveMessageSize(int size);
   94|       |  void SetMaxSendMessageSize(int size);
   95|       |
   96|       |  /// Set LB policy name.
   97|       |  /// Note that if the name resolver returns only balancer addresses, the
   98|       |  /// grpclb LB policy will be used, regardless of what is specified here.
   99|       |  void SetLoadBalancingPolicyName(const grpc::string& lb_policy_name);
  100|       |
  101|       |  /// Set service config in JSON form.
  102|       |  /// Primarily meant for use in unit tests.
  103|       |  void SetServiceConfigJSON(const grpc::string& service_config_json);
  104|       |
  105|       |  // Generic channel argument setters. Only for advanced use cases.
  106|       |  /// Set an integer argument \a value under \a key.
  107|       |  void SetInt(const grpc::string& key, int value);
  108|       |
  109|       |  // Generic channel argument setter. Only for advanced use cases.
  110|       |  /// Set a pointer argument \a value under \a key. Owership is not transferred.
  111|       |  void SetPointer(const grpc::string& key, void* value);
  112|       |
  113|       |  void SetPointerWithVtable(const grpc::string& key, void* value,
  114|       |                            const grpc_arg_pointer_vtable* vtable);
  115|       |
  116|       |  /// Set a textual argument \a value under \a key.
  117|       |  void SetString(const grpc::string& key, const grpc::string& value);
  118|       |
  119|       |  /// Return (by value) a C \a grpc_channel_args structure which points to
  120|       |  /// arguments owned by this \a ChannelArguments instance
  121|      0|  grpc_channel_args c_channel_args() const {
  122|      0|    grpc_channel_args out;
  123|      0|    out.num_args = args_.size();
  124|      0|    out.args = args_.empty() ? NULL : const_cast<grpc_arg*>(&args_[0]);
  125|      0|    return out;
  126|      0|  }
  127|       |
  128|       | private:
  129|       |  friend class grpc_impl::SecureChannelCredentials;
  130|       |  friend class grpc::testing::ChannelArgumentsTest;
  131|       |
  132|       |  /// Default pointer argument operations.
  133|       |  struct PointerVtableMembers {
  134|      0|    static void* Copy(void* in) { return in; }
  135|      0|    static void Destroy(void* in) {}
  136|      0|    static int Compare(void* a, void* b) {
  137|      0|      if (a < b) return -1;
  138|      0|      if (a > b) return 1;
  139|      0|      return 0;
  140|      0|    }
  141|       |  };
  142|       |
  143|       |  // Returns empty string when it is not set.
  144|       |  grpc::string GetSslTargetNameOverride() const;
  145|       |
  146|       |  std::vector<grpc_arg> args_;
  147|       |  std::list<grpc::string> strings_;
  148|       |};
  149|       |
  150|       |}  // namespace grpc_impl
  151|       |
  152|       |#endif  // GRPCPP_SUPPORT_CHANNEL_ARGUMENTS_IMPL_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/channel/channel_args.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_CHANNEL_CHANNEL_ARGS_H
   20|       |#define GRPC_CORE_LIB_CHANNEL_CHANNEL_ARGS_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/grpc.h>
   25|       |
   26|       |// Channel args are intentionally immutable, to avoid the need for locking.
   27|       |
   28|       |/** Copy the arguments in \a src into a new instance */
   29|       |grpc_channel_args* grpc_channel_args_copy(const grpc_channel_args* src);
   30|       |
   31|       |/** Copy the arguments in \a src into a new instance, stably sorting keys */
   32|       |grpc_channel_args* grpc_channel_args_normalize(const grpc_channel_args* src);
   33|       |
   34|       |/** Copy the arguments in \a src and append \a to_add. If \a to_add is NULL, it
   35|       | * is equivalent to calling \a grpc_channel_args_copy. */
   36|       |grpc_channel_args* grpc_channel_args_copy_and_add(const grpc_channel_args* src,
   37|       |                                                  const grpc_arg* to_add,
   38|       |                                                  size_t num_to_add);
   39|       |
   40|       |/** Copies the arguments in \a src except for those whose keys are in
   41|       |    \a to_remove. */
   42|       |grpc_channel_args* grpc_channel_args_copy_and_remove(
   43|       |    const grpc_channel_args* src, const char** to_remove, size_t num_to_remove);
   44|       |
   45|       |/** Copies the arguments from \a src except for those whose keys are in
   46|       |    \a to_remove and appends the arguments in \a to_add. */
   47|       |grpc_channel_args* grpc_channel_args_copy_and_add_and_remove(
   48|       |    const grpc_channel_args* src, const char** to_remove, size_t num_to_remove,
   49|       |    const grpc_arg* to_add, size_t num_to_add);
   50|       |
   51|       |/** Perform the union of \a a and \a b, prioritizing \a a entries */
   52|       |grpc_channel_args* grpc_channel_args_union(const grpc_channel_args* a,
   53|       |                                           const grpc_channel_args* b);
   54|       |
   55|       |/** Destroy arguments created by \a grpc_channel_args_copy */
   56|       |void grpc_channel_args_destroy(grpc_channel_args* a);
   57|      0|inline void grpc_channel_args_destroy(const grpc_channel_args* a) {
   58|      0|  grpc_channel_args_destroy(const_cast<grpc_channel_args*>(a));
   59|      0|}
   60|       |
   61|       |int grpc_channel_args_compare(const grpc_channel_args* a,
   62|       |                              const grpc_channel_args* b);
   63|       |
   64|       |/** Returns the value of argument \a name from \a args, or NULL if not found. */
   65|       |const grpc_arg* grpc_channel_args_find(const grpc_channel_args* args,
   66|       |                                       const char* name);
   67|       |
   68|       |bool grpc_channel_args_want_minimal_stack(const grpc_channel_args* args);
   69|       |
   70|       |typedef struct grpc_integer_options {
   71|       |  int default_value;  // Return this if value is outside of expected bounds.
   72|       |  int min_value;
   73|       |  int max_value;
   74|       |} grpc_integer_options;
   75|       |
   76|       |/** Returns the value of \a arg, subject to the contraints in \a options. */
   77|       |int grpc_channel_arg_get_integer(const grpc_arg* arg,
   78|       |                                 const grpc_integer_options options);
   79|       |
   80|       |/** Returns the value of \a arg if \a arg is of type GRPC_ARG_STRING.
   81|       |    Otherwise, emits a warning log, and returns nullptr.
   82|       |    If arg is nullptr, returns nullptr, and does not emit a warning. */
   83|       |char* grpc_channel_arg_get_string(const grpc_arg* arg);
   84|       |
   85|       |bool grpc_channel_arg_get_bool(const grpc_arg* arg, bool default_value);
   86|       |
   87|       |// Helpers for creating channel args.
   88|       |grpc_arg grpc_channel_arg_string_create(char* name, char* value);
   89|       |grpc_arg grpc_channel_arg_integer_create(char* name, int value);
   90|       |grpc_arg grpc_channel_arg_pointer_create(char* name, void* value,
   91|       |                                         const grpc_arg_pointer_vtable* vtable);
   92|       |
   93|       |// Returns a string representing channel args in human-readable form.
   94|       |// Callers takes ownership of result.
   95|       |char* grpc_channel_args_string(const grpc_channel_args* args);
   96|       |
   97|       |#endif /* GRPC_CORE_LIB_CHANNEL_CHANNEL_ARGS_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/debug/trace.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_DEBUG_TRACE_H
   20|       |#define GRPC_CORE_LIB_DEBUG_TRACE_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/support/atm.h>
   25|       |#include <stdbool.h>
   26|       |
   27|       |#include "src/core/lib/gprpp/global_config.h"
   28|       |
   29|       |GPR_GLOBAL_CONFIG_DECLARE_STRING(grpc_trace);
   30|       |
   31|       |// TODO(veblush): Remove this deprecated function once codes depending on this
   32|       |// function are updated in the internal repo.
   33|       |void grpc_tracer_init(const char* env_var_name);
   34|       |
   35|       |void grpc_tracer_init();
   36|       |void grpc_tracer_shutdown(void);
   37|       |
   38|       |#if defined(__has_feature)
   39|       |#if __has_feature(thread_sanitizer)
   40|       |#define GRPC_THREADSAFE_TRACER
   41|       |#endif
   42|       |#endif
   43|       |
   44|       |namespace grpc_core {
   45|       |
   46|       |class TraceFlag;
   47|       |class TraceFlagList {
   48|       | public:
   49|       |  static bool Set(const char* name, bool enabled);
   50|       |  static void Add(TraceFlag* flag);
   51|       |
   52|       | private:
   53|       |  static void LogAllTracers();
   54|       |  static TraceFlag* root_tracer_;
   55|       |};
   56|       |
   57|       |namespace testing {
   58|       |void grpc_tracer_enable_flag(grpc_core::TraceFlag* flag);
   59|       |}
   60|       |
   61|       |class TraceFlag {
   62|       | public:
   63|       |  TraceFlag(bool default_enabled, const char* name);
   64|       |  // TraceFlag needs to be trivially destructible since it is used as global
   65|       |  // variable.
   66|       |  ~TraceFlag() = default;
   67|       |
   68|      0|  const char* name() const { return name_; }
   69|       |
   70|       |// Use the symbol GRPC_USE_TRACERS to determine if tracers will be enabled in
   71|       |// opt builds (tracers are always on in dbg builds). The default in OSS is for
   72|       |// tracers to be on since we support binary distributions of gRPC for the
   73|       |// wrapped language (wr don't want to force recompilation to get tracing).
   74|       |// Internally, however, for performance reasons, we compile them out by
   75|       |// default, since internal build systems make recompiling trivial.
   76|       |//
   77|       |// Prefer GRPC_TRACE_FLAG_ENABLED() macro instead of using enabled() directly.
   78|       |#define GRPC_USE_TRACERS  // tracers on by default in OSS
   79|       |#if defined(GRPC_USE_TRACERS) || !defined(NDEBUG)
   80|      0|  bool enabled() {
   81|       |#ifdef GRPC_THREADSAFE_TRACER
   82|       |    return gpr_atm_no_barrier_load(&value_) != 0;
   83|       |#else
   84|       |    return value_;
   85|      0|#endif  // GRPC_THREADSAFE_TRACER
   86|      0|  }
   87|       |#else
   88|       |  bool enabled() { return false; }
   89|       |#endif /* defined(GRPC_USE_TRACERS) || !defined(NDEBUG) */
   90|       |
   91|       | private:
   92|       |  friend void grpc_core::testing::grpc_tracer_enable_flag(TraceFlag* flag);
   93|       |  friend class TraceFlagList;
   94|       |
   95|       |  void set_enabled(bool enabled) {
   96|       |#ifdef GRPC_THREADSAFE_TRACER
   97|       |    gpr_atm_no_barrier_store(&value_, enabled);
   98|       |#else
   99|       |    value_ = enabled;
  100|       |#endif
  101|       |  }
  102|       |
  103|       |  TraceFlag* next_tracer_;
  104|       |  const char* const name_;
  105|       |#ifdef GRPC_THREADSAFE_TRACER
  106|       |  gpr_atm value_;
  107|       |#else
  108|       |  bool value_;
  109|       |#endif
  110|       |};
  111|       |
  112|       |#define GRPC_TRACE_FLAG_ENABLED(f) GPR_UNLIKELY((f).enabled())
  113|       |
  114|       |#ifndef NDEBUG
  115|       |typedef TraceFlag DebugOnlyTraceFlag;
  116|       |#else
  117|       |class DebugOnlyTraceFlag {
  118|       | public:
  119|       |  constexpr DebugOnlyTraceFlag(bool default_enabled, const char* name) {}
  120|       |  constexpr bool enabled() const { return false; }
  121|       |  constexpr const char* name() const { return "DebugOnlyTraceFlag"; }
  122|       |
  123|       | private:
  124|       |  void set_enabled(bool enabled) {}
  125|       |};
  126|       |#endif
  127|       |
  128|       |}  // namespace grpc_core
  129|       |
  130|       |#endif /* GRPC_CORE_LIB_DEBUG_TRACE_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gpr/tls_pthread.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPR_TLS_PTHREAD_H
   20|       |#define GRPC_CORE_LIB_GPR_TLS_PTHREAD_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/support/log.h> /* for GPR_ASSERT */
   25|       |#include <pthread.h>
   26|       |
   27|       |/** Thread local storage based on pthread library calls.
   28|       |   #include tls.h to use this - and see that file for documentation */
   29|       |
   30|       |struct gpr_pthread_thread_local {
   31|       |  pthread_key_t key;
   32|       |};
   33|       |
   34|       |/** Use GPR_TLS_DECL to declare tls static variables outside a class */
   35|       |#define GPR_TLS_DECL(name) static struct gpr_pthread_thread_local name = {0}
   36|       |
   37|       |/** Use GPR_TLS_CLASS_DECL to declare tls static variable members of a class.
   38|       | *  GPR_TLS_CLASS_DEF needs to be called to define this member. */
   39|       |#define GPR_TLS_CLASS_DECL(name) static struct gpr_pthread_thread_local name
   40|       |
   41|       |/** Use GPR_TLS_CLASS_DEF to declare tls static variable members of a class.
   42|       | *  GPR_TLS_CLASS_DEF needs to be called to define this member. */
   43|       |#define GPR_TLS_CLASS_DEF(name) struct gpr_pthread_thread_local name = {0}
   44|       |
   45|       |#define gpr_tls_init(tls) GPR_ASSERT(0 == pthread_key_create(&(tls)->key, NULL))
   46|       |#define gpr_tls_destroy(tls) pthread_key_delete((tls)->key)
   47|      0|#define gpr_tls_get(tls) ((intptr_t)pthread_getspecific((tls)->key))
   48|       |#ifdef __cplusplus
   49|       |extern "C" {
   50|       |#endif
   51|       |intptr_t gpr_tls_set(struct gpr_pthread_thread_local* tls, intptr_t value);
   52|       |#ifdef __cplusplus
   53|       |}
   54|       |#endif
   55|       |
   56|       |#endif /* GRPC_CORE_LIB_GPR_TLS_PTHREAD_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gpr/useful.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPR_USEFUL_H
   20|       |#define GRPC_CORE_LIB_GPR_USEFUL_H
   21|       |
   22|       |/** useful macros that don't belong anywhere else */
   23|       |
   24|       |#define GPR_MIN(a, b) ((a) < (b) ? (a) : (b))
   25|       |#define GPR_MAX(a, b) ((a) > (b) ? (a) : (b))
   26|       |#define GPR_CLAMP(a, min, max) ((a) < (min) ? (min) : (a) > (max) ? (max) : (a))
   27|       |/** rotl, rotr assume x is unsigned */
   28|       |#define GPR_ROTL(x, n) (((x) << (n)) | ((x) >> (sizeof(x) * 8 - (n))))
   29|       |#define GPR_ROTR(x, n) (((x) >> (n)) | ((x) << (sizeof(x) * 8 - (n))))
   30|       |
   31|       |#define GPR_ARRAY_SIZE(array) (sizeof(array) / sizeof(*(array)))
   32|       |
   33|       |#define GPR_SWAP(type, a, b) \
   34|       |  do {                       \
   35|       |    type x = a;              \
   36|       |    a = b;                   \
   37|       |    b = x;                   \
   38|       |  } while (0)
   39|       |
   40|       |/** Set the \a n-th bit of \a i (a mutable pointer). */
   41|      0|#define GPR_BITSET(i, n) ((*(i)) |= (1u << (n)))
   42|       |
   43|       |/** Clear the \a n-th bit of \a i (a mutable pointer). */
   44|      0|#define GPR_BITCLEAR(i, n) ((*(i)) &= ~(1u << (n)))
   45|       |
   46|       |/** Get the \a n-th bit of \a i */
   47|       |#define GPR_BITGET(i, n) (((i) & (1u << (n))) != 0)
   48|       |
   49|       |#define GPR_INTERNAL_HEXDIGIT_BITCOUNT(x)                        \
   50|       |  ((x) - (((x) >> 1) & 0x77777777) - (((x) >> 2) & 0x33333333) - \
   51|       |   (((x) >> 3) & 0x11111111))
   52|       |
   53|       |/** Returns number of bits set in bitset \a i */
   54|       |#define GPR_BITCOUNT(i)                          \
   55|       |  (((GPR_INTERNAL_HEXDIGIT_BITCOUNT(i) +         \
   56|       |     (GPR_INTERNAL_HEXDIGIT_BITCOUNT(i) >> 4)) & \
   57|       |    0x0f0f0f0f) %                                \
   58|       |   255)
   59|       |
   60|       |#define GPR_ICMP(a, b) ((a) < (b) ? -1 : ((a) > (b) ? 1 : 0))
   61|       |
   62|       |#define GPR_HASH_POINTER(x, range) \
   63|       |  ((((size_t)x) >> 4) ^ (((size_t)x) >> 9) ^ (((size_t)x) >> 14)) % (range)
   64|       |
   65|       |#endif /* GRPC_CORE_LIB_GPR_USEFUL_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/abstract.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_ABSTRACT_H
   20|       |#define GRPC_CORE_LIB_GPRPP_ABSTRACT_H
   21|       |
   22|       |// This is needed to support abstract base classes in the c core. Since gRPC
   23|       |// doesn't have a c++ runtime, it will hit a linker error on delete unless
   24|       |// we define a virtual operator delete. See this blog for more info:
   25|       |// https://eli.thegreenplace.net/2015/c-deleting-destructors-and-virtual-operator-delete/
   26|       |#define GRPC_ABSTRACT_BASE_CLASS \
   27|      0|  static void operator delete(void* p) { abort(); }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core19PolymorphicRefCountdlEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core22NonPolymorphicRefCountdlEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10OrphanabledlEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10ByteStreamdlEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core8internal24ThreadInternalsInterfacedlEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10HandshakerdlEPv
  ------------------
  | Unexecuted instantiation: _ZN23grpc_security_connectordlEPv
  ------------------
  | Unexecuted instantiation: _ZN31grpc_channel_security_connectordlEPv
  ------------------
  | Unexecuted instantiation: _ZN30grpc_server_security_connectordlEPv
  ------------------
  | Unexecuted instantiation: _ZN24grpc_channel_credentialsdlEPv
  ------------------
  | Unexecuted instantiation: _ZN21grpc_call_credentialsdlEPv
  ------------------
  | Unexecuted instantiation: _ZN23grpc_server_credentialsdlEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10RefCountedI23grpc_security_connectorNS_19PolymorphicRefCountEEdlEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10RefCountedI24grpc_channel_credentialsNS_19PolymorphicRefCountEEdlEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10RefCountedI21grpc_call_credentialsNS_19PolymorphicRefCountEEdlEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10RefCountedI23grpc_server_credentialsNS_19PolymorphicRefCountEEdlEPv
  ------------------
   28|       |
   29|       |// gRPC currently can't depend on libstdc++, so we can't use "= 0" for
   30|       |// pure virtual methods.  Instead, we use this macro.
   31|       |#define GRPC_ABSTRACT                                                        \
   32|       |  {                                                                          \
   33|       |    gpr_log(GPR_ERROR, "Function marked GRPC_ABSTRACT was not implemented"); \
   34|       |    GPR_ASSERT(false);                                                       \
   35|       |  }
   36|       |
   37|       |#endif /* GRPC_CORE_LIB_GPRPP_ABSTRACT_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/arena.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |// \file Arena based allocator
   20|       |// Allows very fast allocation of memory, but that memory cannot be freed until
   21|       |// the arena as a whole is freed
   22|       |// Tracks the total memory allocated against it, so that future arenas can
   23|       |// pre-allocate the right amount of memory
   24|       |
   25|       |#ifndef GRPC_CORE_LIB_GPRPP_ARENA_H
   26|       |#define GRPC_CORE_LIB_GPRPP_ARENA_H
   27|       |
   28|       |#include <grpc/support/port_platform.h>
   29|       |
   30|       |#include <new>
   31|       |#include <utility>
   32|       |
   33|       |#include <grpc/support/alloc.h>
   34|       |#include <grpc/support/sync.h>
   35|       |
   36|       |#include "src/core/lib/gpr/alloc.h"
   37|       |#include "src/core/lib/gpr/spinlock.h"
   38|       |#include "src/core/lib/gprpp/atomic.h"
   39|       |#include "src/core/lib/gprpp/pair.h"
   40|       |
   41|       |#include <stddef.h>
   42|       |
   43|       |namespace grpc_core {
   44|       |
   45|       |class Arena {
   46|       | public:
   47|       |  // Create an arena, with \a initial_size bytes in the first allocated buffer.
   48|       |  static Arena* Create(size_t initial_size);
   49|       |
   50|       |  // Create an arena, with \a initial_size bytes in the first allocated buffer,
   51|       |  // and return both a void pointer to the returned arena and a void* with the
   52|       |  // first allocation.
   53|       |  static Pair<Arena*, void*> CreateWithAlloc(size_t initial_size,
   54|       |                                             size_t alloc_size);
   55|       |
   56|       |  // Destroy an arena, returning the total number of bytes allocated.
   57|       |  size_t Destroy();
   58|       |  // Allocate \a size bytes from the arena.
   59|       |  void* Alloc(size_t size) {
   60|       |    static constexpr size_t base_size =
   61|       |        GPR_ROUND_UP_TO_ALIGNMENT_SIZE(sizeof(Arena));
   62|       |    size = GPR_ROUND_UP_TO_ALIGNMENT_SIZE(size);
   63|       |    size_t begin = total_used_.FetchAdd(size, MemoryOrder::RELAXED);
   64|       |    if (begin + size <= initial_zone_size_) {
   65|       |      return reinterpret_cast<char*>(this) + base_size + begin;
   66|       |    } else {
   67|       |      return AllocZone(size);
   68|       |    }
   69|       |  }
   70|       |
   71|       |  // TODO(roth): We currently assume that all callers need alignment of 16
   72|       |  // bytes, which may be wrong in some cases. When we have time, we should
   73|       |  // change this to instead use the alignment of the type being allocated by
   74|       |  // this method.
   75|       |  template <typename T, typename... Args>
   76|       |  T* New(Args&&... args) {
   77|       |    T* t = static_cast<T*>(Alloc(sizeof(T)));
   78|       |    new (t) T(std::forward<Args>(args)...);
   79|       |    return t;
   80|       |  }
   81|       |
   82|       | private:
   83|       |  struct Zone {
   84|       |    Zone* prev;
   85|       |  };
   86|       |
   87|       |  // Initialize an arena.
   88|       |  // Parameters:
   89|       |  //   initial_size: The initial size of the whole arena in bytes. These bytes
   90|       |  //   are contained within 'zone 0'. If the arena user ends up requiring more
   91|       |  //   memory than the arena contains in zone 0, subsequent zones are allocated
   92|       |  //   on demand and maintained in a tail-linked list.
   93|       |  //
   94|       |  //   initial_alloc: Optionally, construct the arena as though a call to
   95|       |  //   Alloc() had already been made for initial_alloc bytes. This provides a
   96|       |  //   quick optimization (avoiding an atomic fetch-add) for the common case
   97|       |  //   where we wish to create an arena and then perform an immediate
   98|       |  //   allocation.
   99|       |  explicit Arena(size_t initial_size, size_t initial_alloc = 0)
  100|      0|      : total_used_(initial_alloc), initial_zone_size_(initial_size) {}
  101|       |
  102|       |  ~Arena();
  103|       |
  104|       |  void* AllocZone(size_t size);
  105|       |
  106|       |  // Keep track of the total used size. We use this in our call sizing
  107|       |  // hysteresis.
  108|       |  Atomic<size_t> total_used_;
  109|       |  size_t initial_zone_size_;
  110|       |  gpr_spinlock arena_growth_spinlock_ = GPR_SPINLOCK_STATIC_INITIALIZER;
  111|       |  // If the initial arena allocation wasn't enough, we allocate additional zones
  112|       |  // in a reverse linked list. Each additional zone consists of (1) a pointer to
  113|       |  // the zone added before this zone (null if this is the first additional zone)
  114|       |  // and (2) the allocated memory. The arena itself maintains a pointer to the
  115|       |  // last zone; the zone list is reverse-walked during arena destruction only.
  116|       |  Zone* last_zone_ = nullptr;
  117|       |};
  118|       |
  119|       |}  // namespace grpc_core
  120|       |
  121|       |#endif /* GRPC_CORE_LIB_GPRPP_ARENA_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/atomic.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_ATOMIC_H
   20|       |#define GRPC_CORE_LIB_GPRPP_ATOMIC_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <atomic>
   25|       |
   26|       |#include <grpc/support/atm.h>
   27|       |
   28|       |namespace grpc_core {
   29|       |
   30|       |enum class MemoryOrder {
   31|       |  RELAXED = std::memory_order_relaxed,
   32|       |  CONSUME = std::memory_order_consume,
   33|       |  ACQUIRE = std::memory_order_acquire,
   34|       |  RELEASE = std::memory_order_release,
   35|       |  ACQ_REL = std::memory_order_acq_rel,
   36|       |  SEQ_CST = std::memory_order_seq_cst
   37|       |};
   38|       |
   39|       |template <typename T>
   40|       |class Atomic {
   41|       | public:
   42|      0|  explicit Atomic(T val = T()) : storage_(val) {}
   43|       |
   44|      0|  T Load(MemoryOrder order) const {
   45|      0|    return storage_.load(static_cast<std::memory_order>(order));
   46|      0|  }
   47|       |
   48|       |  void Store(T val, MemoryOrder order) {
   49|       |    storage_.store(val, static_cast<std::memory_order>(order));
   50|       |  }
   51|       |
   52|       |  bool CompareExchangeWeak(T* expected, T desired, MemoryOrder success,
   53|       |                           MemoryOrder failure) {
   54|       |    return GPR_ATM_INC_CAS_THEN(storage_.compare_exchange_weak(
   55|       |        *expected, desired, static_cast<std::memory_order>(success),
   56|       |        static_cast<std::memory_order>(failure)));
   57|       |  }
   58|       |
   59|       |  bool CompareExchangeStrong(T* expected, T desired, MemoryOrder success,
   60|       |                             MemoryOrder failure) {
   61|       |    return GPR_ATM_INC_CAS_THEN(storage_.compare_exchange_strong(
   62|       |        *expected, desired, static_cast<std::memory_order>(success),
   63|       |        static_cast<std::memory_order>(failure)));
   64|       |  }
   65|       |
   66|       |  template <typename Arg>
   67|      0|  T FetchAdd(Arg arg, MemoryOrder order = MemoryOrder::SEQ_CST) {
   68|      0|    return GPR_ATM_INC_ADD_THEN(storage_.fetch_add(
   69|      0|        static_cast<Arg>(arg), static_cast<std::memory_order>(order)));
   70|      0|  }
   71|       |
   72|       |  template <typename Arg>
   73|      0|  T FetchSub(Arg arg, MemoryOrder order = MemoryOrder::SEQ_CST) {
   74|      0|    return GPR_ATM_INC_ADD_THEN(storage_.fetch_sub(
   75|      0|        static_cast<Arg>(arg), static_cast<std::memory_order>(order)));
   76|      0|  }
   77|       |
   78|       |  // Atomically increment a counter only if the counter value is not zero.
   79|       |  // Returns true if increment took place; false if counter is zero.
   80|       |  bool IncrementIfNonzero(MemoryOrder load_order = MemoryOrder::ACQUIRE) {
   81|       |    T count = storage_.load(static_cast<std::memory_order>(load_order));
   82|       |    do {
   83|       |      // If zero, we are done (without an increment). If not, we must do a CAS
   84|       |      // to maintain the contract: do not increment the counter if it is already
   85|       |      // zero
   86|       |      if (count == 0) {
   87|       |        return false;
   88|       |      }
   89|       |    } while (!CompareExchangeWeak(&count, count + 1, MemoryOrder::ACQ_REL,
   90|       |                                  load_order));
   91|       |    return true;
   92|       |  }
   93|       |
   94|       | private:
   95|       |  std::atomic<T> storage_;
   96|       |};
   97|       |
   98|       |}  // namespace grpc_core
   99|       |
  100|       |#endif /* GRPC_CORE_LIB_GPRPP_ATOMIC_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/debug_location.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_DEBUG_LOCATION_H
   20|       |#define GRPC_CORE_LIB_GPRPP_DEBUG_LOCATION_H
   21|       |
   22|       |namespace grpc_core {
   23|       |
   24|       |// Used for tracking file and line where a call is made for debug builds.
   25|       |// No-op for non-debug builds.
   26|       |// Callers can use the DEBUG_LOCATION macro in either case.
   27|       |#ifndef NDEBUG
   28|       |class DebugLocation {
   29|       | public:
   30|      0|  DebugLocation(const char* file, int line) : file_(file), line_(line) {}
   31|      0|  bool Log() const { return true; }
   32|      0|  const char* file() const { return file_; }
   33|      0|  int line() const { return line_; }
   34|       |
   35|       | private:
   36|       |  const char* file_;
   37|       |  const int line_;
   38|       |};
   39|      0|#define DEBUG_LOCATION ::grpc_core::DebugLocation(__FILE__, __LINE__)
   40|       |#else
   41|       |class DebugLocation {
   42|       | public:
   43|       |  bool Log() const { return false; }
   44|       |  const char* file() const { return nullptr; }
   45|       |  int line() const { return -1; }
   46|       |};
   47|       |#define DEBUG_LOCATION ::grpc_core::DebugLocation()
   48|       |#endif
   49|       |
   50|       |}  // namespace grpc_core
   51|       |
   52|       |#endif /* GRPC_CORE_LIB_GPRPP_DEBUG_LOCATION_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/global_config_env.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2019 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_GLOBAL_CONFIG_ENV_H
   20|       |#define GRPC_CORE_LIB_GPRPP_GLOBAL_CONFIG_ENV_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include "src/core/lib/gprpp/global_config_generic.h"
   25|       |#include "src/core/lib/gprpp/memory.h"
   26|       |
   27|       |namespace grpc_core {
   28|       |
   29|       |typedef void (*GlobalConfigEnvErrorFunctionType)(const char* error_message);
   30|       |
   31|       |/*
   32|       | * Set global_config_env_error_function which is called when config system
   33|       | * encounters errors such as parsing error. What the default function does
   34|       | * is logging error message.
   35|       | */
   36|       |void SetGlobalConfigEnvErrorFunction(GlobalConfigEnvErrorFunctionType func);
   37|       |
   38|       |// Base class for all classes to access environment variables.
   39|       |class GlobalConfigEnv {
   40|       | protected:
   41|       |  // `name` should be writable and alive after constructor is called.
   42|      0|  constexpr explicit GlobalConfigEnv(char* name) : name_(name) {}
   43|       |
   44|       | public:
   45|       |  // Returns the value of `name` variable.
   46|       |  UniquePtr<char> GetValue();
   47|       |
   48|       |  // Sets the value of `name` variable.
   49|       |  void SetValue(const char* value);
   50|       |
   51|       |  // Unsets `name` variable.
   52|       |  void Unset();
   53|       |
   54|       | protected:
   55|       |  char* GetName();
   56|       |
   57|       | private:
   58|       |  char* name_;
   59|       |};
   60|       |
   61|       |class GlobalConfigEnvBool : public GlobalConfigEnv {
   62|       | public:
   63|       |  constexpr GlobalConfigEnvBool(char* name, bool default_value)
   64|      0|      : GlobalConfigEnv(name), default_value_(default_value) {}
   65|       |
   66|       |  bool Get();
   67|       |  void Set(bool value);
   68|       |
   69|       | private:
   70|       |  bool default_value_;
   71|       |};
   72|       |
   73|       |class GlobalConfigEnvInt32 : public GlobalConfigEnv {
   74|       | public:
   75|       |  constexpr GlobalConfigEnvInt32(char* name, int32_t default_value)
   76|      0|      : GlobalConfigEnv(name), default_value_(default_value) {}
   77|       |
   78|       |  int32_t Get();
   79|       |  void Set(int32_t value);
   80|       |
   81|       | private:
   82|       |  int32_t default_value_;
   83|       |};
   84|       |
   85|       |class GlobalConfigEnvString : public GlobalConfigEnv {
   86|       | public:
   87|       |  constexpr GlobalConfigEnvString(char* name, const char* default_value)
   88|      0|      : GlobalConfigEnv(name), default_value_(default_value) {}
   89|       |
   90|       |  UniquePtr<char> Get();
   91|       |  void Set(const char* value);
   92|       |
   93|       | private:
   94|       |  const char* default_value_;
   95|       |};
   96|       |
   97|       |}  // namespace grpc_core
   98|       |
   99|       |// Macros for defining global config instances using environment variables.
  100|       |// This defines a GlobalConfig*Type* instance with arguments for
  101|       |// mutable variable name and default value.
  102|       |// Mutable name (g_env_str_##name) is here for having an array
  103|       |// for the canonical name without dynamic allocation.
  104|       |// `help` argument is ignored for this implementation.
  105|       |
  106|       |#define GPR_GLOBAL_CONFIG_DEFINE_BOOL(name, default_value, help)         \
  107|       |  static char g_env_str_##name[] = #name;                                \
  108|       |  static ::grpc_core::GlobalConfigEnvBool g_env_##name(g_env_str_##name, \
  109|       |                                                       default_value);   \
  110|       |  bool gpr_global_config_get_##name() { return g_env_##name.Get(); }     \
  111|       |  void gpr_global_config_set_##name(bool value) { g_env_##name.Set(value); }
  112|       |
  113|       |#define GPR_GLOBAL_CONFIG_DEFINE_INT32(name, default_value, help)         \
  114|       |  static char g_env_str_##name[] = #name;                                 \
  115|       |  static ::grpc_core::GlobalConfigEnvInt32 g_env_##name(g_env_str_##name, \
  116|       |                                                        default_value);   \
  117|       |  int32_t gpr_global_config_get_##name() { return g_env_##name.Get(); }   \
  118|       |  void gpr_global_config_set_##name(int32_t value) { g_env_##name.Set(value); }
  119|       |
  120|       |#define GPR_GLOBAL_CONFIG_DEFINE_STRING(name, default_value, help)         \
  121|       |  static char g_env_str_##name[] = #name;                                  \
  122|       |  static ::grpc_core::GlobalConfigEnvString g_env_##name(g_env_str_##name, \
  123|       |                                                         default_value);   \
  124|       |  ::grpc_core::UniquePtr<char> gpr_global_config_get_##name() {            \
  125|       |    return g_env_##name.Get();                                             \
  126|       |  }                                                                        \
  127|       |  void gpr_global_config_set_##name(const char* value) {                   \
  128|       |    g_env_##name.Set(value);                                               \
  129|       |  }
  130|       |
  131|       |#endif /* GRPC_CORE_LIB_GPRPP_GLOBAL_CONFIG_ENV_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/inlined_vector.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_INLINED_VECTOR_H
   20|       |#define GRPC_CORE_LIB_GPRPP_INLINED_VECTOR_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <cassert>
   25|       |#include <cstring>
   26|       |
   27|       |#include "src/core/lib/gprpp/memory.h"
   28|       |
   29|       |namespace grpc_core {
   30|       |
   31|       |// NOTE: We eventually want to use absl::InlinedVector here.  However,
   32|       |// there are currently build problems that prevent us from using absl.
   33|       |// In the interim, we define a custom implementation as a place-holder,
   34|       |// with the intent to eventually replace this with the absl
   35|       |// implementation.
   36|       |//
   37|       |// This place-holder implementation does not implement the full set of
   38|       |// functionality from the absl version; it has just the methods that we
   39|       |// currently happen to need in gRPC.  If additional functionality is
   40|       |// needed before this gets replaced with the absl version, it can be
   41|       |// added, with the following proviso:
   42|       |//
   43|       |// ANY METHOD ADDED HERE MUST COMPLY WITH THE INTERFACE IN THE absl
   44|       |// IMPLEMENTATION!
   45|       |//
   46|       |// TODO(nnoble, roth): Replace this with absl::InlinedVector once we
   47|       |// integrate absl into the gRPC build system in a usable way.
   48|       |template <typename T, size_t N>
   49|       |class InlinedVector {
   50|       | public:
   51|       |  InlinedVector() { init_data(); }
   52|       |  ~InlinedVector() { destroy_elements(); }
   53|       |
   54|       |  // copy constructor
   55|       |  InlinedVector(const InlinedVector& v) {
   56|       |    init_data();
   57|       |    copy_from(v);
   58|       |  }
   59|       |
   60|       |  InlinedVector& operator=(const InlinedVector& v) {
   61|       |    if (this != &v) {
   62|       |      clear();
   63|       |      copy_from(v);
   64|       |    }
   65|       |    return *this;
   66|       |  }
   67|       |
   68|       |  // move constructor
   69|       |  InlinedVector(InlinedVector&& v) {
   70|       |    init_data();
   71|       |    move_from(v);
   72|       |  }
   73|       |
   74|       |  InlinedVector& operator=(InlinedVector&& v) {
   75|       |    if (this != &v) {
   76|       |      clear();
   77|       |      move_from(v);
   78|       |    }
   79|       |    return *this;
   80|       |  }
   81|       |
   82|       |  T* data() {
   83|       |    return dynamic_ != nullptr ? dynamic_ : reinterpret_cast<T*>(inline_);
   84|       |  }
   85|       |
   86|       |  const T* data() const {
   87|       |    return dynamic_ != nullptr ? dynamic_ : reinterpret_cast<const T*>(inline_);
   88|       |  }
   89|       |
   90|       |  T& operator[](size_t offset) {
   91|       |    assert(offset < size_);
   92|       |    return data()[offset];
   93|       |  }
   94|       |
   95|       |  const T& operator[](size_t offset) const {
   96|       |    assert(offset < size_);
   97|       |    return data()[offset];
   98|       |  }
   99|       |
  100|       |  void reserve(size_t capacity) {
  101|       |    if (capacity > capacity_) {
  102|       |      T* new_dynamic = static_cast<T*>(gpr_malloc(sizeof(T) * capacity));
  103|       |      move_elements(data(), new_dynamic, size_);
  104|       |      gpr_free(dynamic_);
  105|       |      dynamic_ = new_dynamic;
  106|       |      capacity_ = capacity;
  107|       |    }
  108|       |  }
  109|       |
  110|       |  template <typename... Args>
  111|       |  void emplace_back(Args&&... args) {
  112|       |    if (size_ == capacity_) {
  113|       |      reserve(capacity_ * 2);
  114|       |    }
  115|       |    new (&(data()[size_])) T(std::forward<Args>(args)...);
  116|       |    ++size_;
  117|       |  }
  118|       |
  119|       |  void push_back(const T& value) { emplace_back(value); }
  120|       |
  121|       |  void push_back(T&& value) { emplace_back(std::move(value)); }
  122|       |
  123|       |  void pop_back() {
  124|       |    assert(!empty());
  125|       |    size_t s = size();
  126|       |    T& value = data()[s - 1];
  127|       |    value.~T();
  128|       |    size_--;
  129|       |  }
  130|       |
  131|       |  size_t size() const { return size_; }
  132|       |  bool empty() const { return size_ == 0; }
  133|       |
  134|       |  size_t capacity() const { return capacity_; }
  135|       |
  136|      0|  void clear() {
  137|      0|    destroy_elements();
  138|      0|    init_data();
  139|      0|  }
  140|       |
  141|       | private:
  142|       |  void copy_from(const InlinedVector& v) {
  143|       |    // if v is allocated, make sure we have enough capacity.
  144|       |    if (v.dynamic_ != nullptr) {
  145|       |      reserve(v.capacity_);
  146|       |    }
  147|       |    // copy over elements
  148|       |    for (size_t i = 0; i < v.size_; ++i) {
  149|       |      new (&(data()[i])) T(v[i]);
  150|       |    }
  151|       |    // copy over metadata
  152|       |    size_ = v.size_;
  153|       |    capacity_ = v.capacity_;
  154|       |  }
  155|       |
  156|       |  void move_from(InlinedVector& v) {
  157|       |    // if v is allocated, then we steal its dynamic array; otherwise, we
  158|       |    // move the elements individually.
  159|       |    if (v.dynamic_ != nullptr) {
  160|       |      dynamic_ = v.dynamic_;
  161|       |    } else {
  162|       |      move_elements(v.data(), data(), v.size_);
  163|       |    }
  164|       |    // copy over metadata
  165|       |    size_ = v.size_;
  166|       |    capacity_ = v.capacity_;
  167|       |    // null out the original
  168|       |    v.init_data();
  169|       |  }
  170|       |
  171|       |  static void move_elements(T* src, T* dst, size_t num_elements) {
  172|       |    for (size_t i = 0; i < num_elements; ++i) {
  173|       |      new (&dst[i]) T(std::move(src[i]));
  174|       |      src[i].~T();
  175|       |    }
  176|       |  }
  177|       |
  178|      0|  void init_data() {
  179|      0|    dynamic_ = nullptr;
  180|      0|    size_ = 0;
  181|      0|    capacity_ = N;
  182|      0|  }
  183|       |
  184|       |  void destroy_elements() {
  185|       |    for (size_t i = 0; i < size_; ++i) {
  186|       |      T& value = data()[i];
  187|       |      value.~T();
  188|       |    }
  189|       |    gpr_free(dynamic_);
  190|       |  }
  191|       |
  192|       |  typename std::aligned_storage<sizeof(T)>::type inline_[N];
  193|       |  T* dynamic_;
  194|       |  size_t size_;
  195|       |  size_t capacity_;
  196|       |};
  197|       |
  198|       |}  // namespace grpc_core
  199|       |
  200|       |#endif /* GRPC_CORE_LIB_GPRPP_INLINED_VECTOR_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/memory.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_MEMORY_H
   20|       |#define GRPC_CORE_LIB_GPRPP_MEMORY_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/support/alloc.h>
   25|       |
   26|       |#include <limits>
   27|       |#include <memory>
   28|       |#include <utility>
   29|       |
   30|       |// Add this to a class that want to use Delete(), but has a private or
   31|       |// protected destructor.
   32|       |#define GPRC_ALLOW_CLASS_TO_USE_NON_PUBLIC_DELETE \
   33|       |  template <typename T>                           \
   34|       |  friend void grpc_core::Delete(T*);
   35|       |// Add this to a class that want to use New(), but has a private or
   36|       |// protected constructor.
   37|       |#define GPRC_ALLOW_CLASS_TO_USE_NON_PUBLIC_NEW \
   38|       |  template <typename T, typename... Args>      \
   39|       |  friend T* grpc_core::New(Args&&...);
   40|       |
   41|       |namespace grpc_core {
   42|       |
   43|       |// Alternative to new, since we cannot use it (for fear of libstdc++)
   44|       |template <typename T, typename... Args>
   45|       |inline T* New(Args&&... args) {
   46|       |  void* p = gpr_malloc(sizeof(T));
   47|       |  return new (p) T(std::forward<Args>(args)...);
   48|       |}
   49|       |
   50|       |// Alternative to delete, since we cannot use it (for fear of libstdc++)
   51|       |template <typename T>
   52|      0|inline void Delete(T* p) {
   53|      0|  if (p == nullptr) return;
   54|      0|  p->~T();
   55|      0|  gpr_free(p);
   56|      0|}
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core6DeleteINS_8internal24ThreadInternalsInterfaceEEEvPT_
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core6DeleteI17grpc_auth_contextEEvPT_
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core6DeleteI21grpc_call_credentialsEEvPT_
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core6DeleteI24grpc_channel_credentialsEEvPT_
  ------------------
   57|       |
   58|       |template <typename T>
   59|       |class DefaultDelete {
   60|       | public:
   61|       |  void operator()(T* p) { Delete(p); }
   62|       |};
   63|       |
   64|       |template <typename T, typename Deleter = DefaultDelete<T>>
   65|       |using UniquePtr = std::unique_ptr<T, Deleter>;
   66|       |
   67|       |template <typename T, typename... Args>
   68|       |inline UniquePtr<T> MakeUnique(Args&&... args) {
   69|       |  return UniquePtr<T>(New<T>(std::forward<Args>(args)...));
   70|       |}
   71|       |
   72|       |// an allocator that uses gpr_malloc/gpr_free
   73|       |template <class T>
   74|       |class Allocator {
   75|       | public:
   76|       |  typedef T value_type;
   77|       |  typedef T* pointer;
   78|       |  typedef const T* const_pointer;
   79|       |  typedef T& reference;
   80|       |  typedef const T& const_reference;
   81|       |  typedef std::size_t size_type;
   82|       |  typedef std::ptrdiff_t difference_type;
   83|       |  typedef std::false_type propagate_on_container_move_assignment;
   84|       |  template <class U>
   85|       |  struct rebind {
   86|       |    typedef Allocator<U> other;
   87|       |  };
   88|       |  typedef std::true_type is_always_equal;
   89|       |
   90|       |  pointer address(reference x) const { return &x; }
   91|       |  const_pointer address(const_reference x) const { return &x; }
   92|       |  pointer allocate(std::size_t n,
   93|       |                   std::allocator<void>::const_pointer hint = nullptr) {
   94|       |    return static_cast<pointer>(gpr_malloc(n * sizeof(T)));
   95|       |  }
   96|       |  void deallocate(T* p, std::size_t n) { gpr_free(p); }
   97|       |  size_t max_size() const {
   98|       |    return std::numeric_limits<size_type>::max() / sizeof(value_type);
   99|       |  }
  100|       |  void construct(pointer p, const_reference val) { new ((void*)p) T(val); }
  101|       |  template <class U, class... Args>
  102|       |  void construct(U* p, Args&&... args) {
  103|       |    ::new ((void*)p) U(std::forward<Args>(args)...);
  104|       |  }
  105|       |  void destroy(pointer p) { p->~T(); }
  106|       |  template <class U>
  107|       |  void destroy(U* p) {
  108|       |    p->~U();
  109|       |  }
  110|       |};
  111|       |
  112|       |}  // namespace grpc_core
  113|       |
  114|       |#endif /* GRPC_CORE_LIB_GPRPP_MEMORY_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/orphanable.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_ORPHANABLE_H
   20|       |#define GRPC_CORE_LIB_GPRPP_ORPHANABLE_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/support/log.h>
   25|       |#include <grpc/support/sync.h>
   26|       |
   27|       |#include <cinttypes>
   28|       |#include <memory>
   29|       |
   30|       |#include "src/core/lib/debug/trace.h"
   31|       |#include "src/core/lib/gprpp/abstract.h"
   32|       |#include "src/core/lib/gprpp/debug_location.h"
   33|       |#include "src/core/lib/gprpp/memory.h"
   34|       |#include "src/core/lib/gprpp/ref_counted.h"
   35|       |#include "src/core/lib/gprpp/ref_counted_ptr.h"
   36|       |
   37|       |namespace grpc_core {
   38|       |
   39|       |// A base class for orphanable objects, which have one external owner
   40|       |// but are not necessarily destroyed immediately when the external owner
   41|       |// gives up ownership.  Instead, the owner calls the object's Orphan()
   42|       |// method, and the object then takes responsibility for its own cleanup
   43|       |// and destruction.
   44|       |class Orphanable {
   45|       | public:
   46|       |  // Gives up ownership of the object.  The implementation must arrange
   47|       |  // to eventually destroy the object without further interaction from the
   48|       |  // caller.
   49|       |  virtual void Orphan() GRPC_ABSTRACT;
   50|       |
   51|       |  // Not copyable or movable.
   52|       |  Orphanable(const Orphanable&) = delete;
   53|       |  Orphanable& operator=(const Orphanable&) = delete;
   54|       |
   55|       |  GRPC_ABSTRACT_BASE_CLASS
   56|       |
   57|       | protected:
   58|      0|  Orphanable() {}
   59|      0|  virtual ~Orphanable() {}
   60|       |};
   61|       |
   62|       |template <typename T>
   63|       |class OrphanableDelete {
   64|       | public:
   65|      0|  void operator()(T* p) { p->Orphan(); }
   66|       |};
   67|       |
   68|       |template <typename T, typename Deleter = OrphanableDelete<T>>
   69|       |using OrphanablePtr = std::unique_ptr<T, Deleter>;
   70|       |
   71|       |template <typename T, typename... Args>
   72|       |inline OrphanablePtr<T> MakeOrphanable(Args&&... args) {
   73|       |  return OrphanablePtr<T>(New<T>(std::forward<Args>(args)...));
   74|       |}
   75|       |
   76|       |// A type of Orphanable with internal ref-counting.
   77|       |template <typename Child>
   78|       |class InternallyRefCounted : public Orphanable {
   79|       | public:
   80|       |  // Not copyable nor movable.
   81|       |  InternallyRefCounted(const InternallyRefCounted&) = delete;
   82|       |  InternallyRefCounted& operator=(const InternallyRefCounted&) = delete;
   83|       |
   84|       |  GRPC_ABSTRACT_BASE_CLASS
   85|       |
   86|       | protected:
   87|       |  GPRC_ALLOW_CLASS_TO_USE_NON_PUBLIC_DELETE
   88|       |
   89|       |  // Allow RefCountedPtr<> to access Unref() and IncrementRefCount().
   90|       |  template <typename T>
   91|       |  friend class RefCountedPtr;
   92|       |
   93|       |  // TraceFlagT is defined to accept both DebugOnlyTraceFlag and TraceFlag.
   94|       |  // Note: RefCount tracing is only enabled on debug builds, even when a
   95|       |  //       TraceFlag is used.
   96|       |  template <typename TraceFlagT = TraceFlag>
   97|       |  explicit InternallyRefCounted(TraceFlagT* trace_flag = nullptr,
   98|       |                                intptr_t initial_refcount = 1)
   99|       |      : refs_(initial_refcount, trace_flag) {}
  100|       |  virtual ~InternallyRefCounted() = default;
  101|       |
  102|       |  RefCountedPtr<Child> Ref() GRPC_MUST_USE_RESULT {
  103|       |    IncrementRefCount();
  104|       |    return RefCountedPtr<Child>(static_cast<Child*>(this));
  105|       |  }
  106|       |  RefCountedPtr<Child> Ref(const DebugLocation& location,
  107|       |                           const char* reason) GRPC_MUST_USE_RESULT {
  108|       |    IncrementRefCount(location, reason);
  109|       |    return RefCountedPtr<Child>(static_cast<Child*>(this));
  110|       |  }
  111|       |
  112|       |  void Unref() {
  113|       |    if (GPR_UNLIKELY(refs_.Unref())) {
  114|       |      Delete(static_cast<Child*>(this));
  115|       |    }
  116|       |  }
  117|       |  void Unref(const DebugLocation& location, const char* reason) {
  118|       |    if (GPR_UNLIKELY(refs_.Unref(location, reason))) {
  119|       |      Delete(static_cast<Child*>(this));
  120|       |    }
  121|       |  }
  122|       |
  123|       | private:
  124|       |  void IncrementRefCount() { refs_.Ref(); }
  125|       |  void IncrementRefCount(const DebugLocation& location, const char* reason) {
  126|       |    refs_.Ref(location, reason);
  127|       |  }
  128|       |
  129|       |  grpc_core::RefCount refs_;
  130|       |};
  131|       |
  132|       |}  // namespace grpc_core
  133|       |
  134|       |#endif /* GRPC_CORE_LIB_GPRPP_ORPHANABLE_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/ref_counted.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_REF_COUNTED_H
   20|       |#define GRPC_CORE_LIB_GPRPP_REF_COUNTED_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/support/atm.h>
   25|       |#include <grpc/support/log.h>
   26|       |#include <grpc/support/sync.h>
   27|       |
   28|       |#include <atomic>
   29|       |#include <cassert>
   30|       |#include <cinttypes>
   31|       |
   32|       |#include "src/core/lib/debug/trace.h"
   33|       |#include "src/core/lib/gprpp/abstract.h"
   34|       |#include "src/core/lib/gprpp/atomic.h"
   35|       |#include "src/core/lib/gprpp/debug_location.h"
   36|       |#include "src/core/lib/gprpp/memory.h"
   37|       |#include "src/core/lib/gprpp/ref_counted_ptr.h"
   38|       |
   39|       |namespace grpc_core {
   40|       |
   41|       |// PolymorphicRefCount enforces polymorphic destruction of RefCounted.
   42|       |class PolymorphicRefCount {
   43|       | public:
   44|       |  GRPC_ABSTRACT_BASE_CLASS
   45|       |
   46|       | protected:
   47|       |  GPRC_ALLOW_CLASS_TO_USE_NON_PUBLIC_DELETE
   48|       |
   49|       |  virtual ~PolymorphicRefCount() = default;
   50|       |};
   51|       |
   52|       |// NonPolymorphicRefCount does not enforce polymorphic destruction of
   53|       |// RefCounted. Please refer to grpc_core::RefCounted for more details, and
   54|       |// when in doubt use PolymorphicRefCount.
   55|       |class NonPolymorphicRefCount {
   56|       | public:
   57|       |  GRPC_ABSTRACT_BASE_CLASS
   58|       |
   59|       | protected:
   60|       |  GPRC_ALLOW_CLASS_TO_USE_NON_PUBLIC_DELETE
   61|       |
   62|       |  ~NonPolymorphicRefCount() = default;
   63|       |};
   64|       |
   65|       |// RefCount is a simple atomic ref-count.
   66|       |//
   67|       |// This is a C++ implementation of gpr_refcount, with inline functions. Due to
   68|       |// inline functions, this class is significantly more efficient than
   69|       |// gpr_refcount and should be preferred over gpr_refcount whenever possible.
   70|       |//
   71|       |// TODO(soheil): Remove gpr_refcount after submitting the GRFC and the paragraph
   72|       |//               above.
   73|       |class RefCount {
   74|       | public:
   75|       |  using Value = intptr_t;
   76|       |
   77|       |  // `init` is the initial refcount stored in this object.
   78|       |  //
   79|       |  // TraceFlagT is defined to accept both DebugOnlyTraceFlag and TraceFlag.
   80|       |  // Note: RefCount tracing is only enabled on debug builds, even when a
   81|       |  //       TraceFlag is used.
   82|       |  template <typename TraceFlagT = TraceFlag>
   83|       |  constexpr explicit RefCount(Value init = 1, TraceFlagT* trace_flag = nullptr)
   84|       |      :
   85|       |#ifndef NDEBUG
   86|       |        trace_flag_(trace_flag),
   87|       |#endif
   88|      0|        value_(init) {
   89|      0|  }
   90|       |
   91|       |  // Increases the ref-count by `n`.
   92|      0|  void Ref(Value n = 1) { value_.FetchAdd(n, MemoryOrder::RELAXED); }
   93|       |  void Ref(const DebugLocation& location, const char* reason, Value n = 1) {
   94|       |#ifndef NDEBUG
   95|       |    if (location.Log() && trace_flag_ != nullptr && trace_flag_->enabled()) {
   96|       |      const RefCount::Value old_refs = get();
   97|       |      gpr_log(GPR_INFO, "%s:%p %s:%d ref %" PRIdPTR " -> %" PRIdPTR " %s",
   98|       |              trace_flag_->name(), this, location.file(), location.line(),
   99|       |              old_refs, old_refs + n, reason);
  100|       |    }
  101|       |#endif
  102|       |    Ref(n);
  103|       |  }
  104|       |
  105|       |  // Similar to Ref() with an assert on the ref-count being non-zero.
  106|       |  void RefNonZero() {
  107|       |#ifndef NDEBUG
  108|       |    const Value prior = value_.FetchAdd(1, MemoryOrder::RELAXED);
  109|       |    assert(prior > 0);
  110|       |#else
  111|       |    Ref();
  112|       |#endif
  113|       |  }
  114|      0|  void RefNonZero(const DebugLocation& location, const char* reason) {
  115|      0|#ifndef NDEBUG
  116|      0|    if (location.Log() && trace_flag_ != nullptr && trace_flag_->enabled()) {
  117|      0|      const RefCount::Value old_refs = get();
  118|      0|      gpr_log(GPR_INFO, "%s:%p %s:%d ref %" PRIdPTR " -> %" PRIdPTR " %s",
  119|      0|              trace_flag_->name(), this, location.file(), location.line(),
  120|      0|              old_refs, old_refs + 1, reason);
  121|      0|    }
  122|      0|#endif
  123|      0|    RefNonZero();
  124|      0|  }
  125|       |
  126|       |  bool RefIfNonZero() { return value_.IncrementIfNonzero(); }
  127|       |
  128|      0|  bool RefIfNonZero(const DebugLocation& location, const char* reason) {
  129|      0|#ifndef NDEBUG
  130|      0|    if (location.Log() && trace_flag_ != nullptr && trace_flag_->enabled()) {
  131|      0|      const RefCount::Value old_refs = get();
  132|      0|      gpr_log(GPR_INFO,
  133|      0|              "%s:%p %s:%d ref_if_non_zero "
  134|      0|              "%" PRIdPTR " -> %" PRIdPTR " %s",
  135|      0|              trace_flag_->name(), this, location.file(), location.line(),
  136|      0|              old_refs, old_refs + 1, reason);
  137|      0|    }
  138|      0|#endif
  139|      0|    return RefIfNonZero();
  140|      0|  }
  141|       |
  142|       |  // Decrements the ref-count and returns true if the ref-count reaches 0.
  143|      0|  bool Unref() {
  144|      0|    const Value prior = value_.FetchSub(1, MemoryOrder::ACQ_REL);
  145|      0|    GPR_DEBUG_ASSERT(prior > 0);
  146|      0|    return prior == 1;
  147|      0|  }
  148|      0|  bool Unref(const DebugLocation& location, const char* reason) {
  149|      0|#ifndef NDEBUG
  150|      0|    if (location.Log() && trace_flag_ != nullptr && trace_flag_->enabled()) {
  151|      0|      const RefCount::Value old_refs = get();
  152|      0|      gpr_log(GPR_INFO, "%s:%p %s:%d unref %" PRIdPTR " -> %" PRIdPTR " %s",
  153|      0|              trace_flag_->name(), this, location.file(), location.line(),
  154|      0|              old_refs, old_refs - 1, reason);
  155|      0|    }
  156|      0|#endif
  157|      0|    return Unref();
  158|      0|  }
  159|       |
  160|       | private:
  161|      0|  Value get() const { return value_.Load(MemoryOrder::RELAXED); }
  162|       |
  163|       |#ifndef NDEBUG
  164|       |  TraceFlag* trace_flag_;
  165|       |#endif
  166|       |  Atomic<Value> value_;
  167|       |};
  168|       |
  169|       |// A base class for reference-counted objects.
  170|       |// New objects should be created via New() and start with a refcount of 1.
  171|       |// When the refcount reaches 0, the object will be deleted via Delete().
  172|       |//
  173|       |// This will commonly be used by CRTP (curiously-recurring template pattern)
  174|       |// e.g., class MyClass : public RefCounted<MyClass>
  175|       |//
  176|       |// Use PolymorphicRefCount and NonPolymorphicRefCount to select between
  177|       |// different implementations of RefCounted.
  178|       |//
  179|       |// Note that NonPolymorphicRefCount does not support polymorphic destruction.
  180|       |// So, use NonPolymorphicRefCount only when both of the following conditions
  181|       |// are guaranteed to hold:
  182|       |// (a) Child is a concrete leaf class in RefCounted<Child>, and
  183|       |// (b) you are gauranteed to call Unref only on concrete leaf classes and not
  184|       |//     their parents.
  185|       |//
  186|       |// The following example is illegal, because calling Unref() will not call
  187|       |// the dtor of Child.
  188|       |//
  189|       |//    class Parent : public RefCounted<Parent, NonPolymorphicRefCount> {}
  190|       |//    class Child : public Parent {}
  191|       |//
  192|       |//    Child* ch;
  193|       |//    ch->Unref();
  194|       |//
  195|       |template <typename Child, typename Impl = PolymorphicRefCount>
  196|       |class RefCounted : public Impl {
  197|       | public:
  198|      0|  RefCountedPtr<Child> Ref() GRPC_MUST_USE_RESULT {
  199|      0|    IncrementRefCount();
  200|      0|    return RefCountedPtr<Child>(static_cast<Child*>(this));
  201|      0|  }
  202|       |
  203|       |  RefCountedPtr<Child> Ref(const DebugLocation& location,
  204|       |                           const char* reason) GRPC_MUST_USE_RESULT {
  205|       |    IncrementRefCount(location, reason);
  206|       |    return RefCountedPtr<Child>(static_cast<Child*>(this));
  207|       |  }
  208|       |
  209|       |  // TODO(roth): Once all of our code is converted to C++ and can use
  210|       |  // RefCountedPtr<> instead of manual ref-counting, make this method
  211|       |  // private, since it will only be used by RefCountedPtr<>, which is a
  212|       |  // friend of this class.
  213|      0|  void Unref() {
  214|      0|    if (GPR_UNLIKELY(refs_.Unref())) {
  215|      0|      Delete(static_cast<Child*>(this));
  216|      0|    }
  217|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10RefCountedI17grpc_auth_contextNS_22NonPolymorphicRefCountEE5UnrefEv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10RefCountedI21grpc_call_credentialsNS_19PolymorphicRefCountEE5UnrefEv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10RefCountedI24grpc_channel_credentialsNS_19PolymorphicRefCountEE5UnrefEv
  ------------------
  218|      0|  void Unref(const DebugLocation& location, const char* reason) {
  219|      0|    if (GPR_UNLIKELY(refs_.Unref(location, reason))) {
  220|      0|      Delete(static_cast<Child*>(this));
  221|      0|    }
  222|      0|  }
  223|       |
  224|       |  // Not copyable nor movable.
  225|       |  RefCounted(const RefCounted&) = delete;
  226|       |  RefCounted& operator=(const RefCounted&) = delete;
  227|       |
  228|       |  GRPC_ABSTRACT_BASE_CLASS
  229|       |
  230|       | protected:
  231|       |  GPRC_ALLOW_CLASS_TO_USE_NON_PUBLIC_DELETE
  232|       |
  233|       |  // TraceFlagT is defined to accept both DebugOnlyTraceFlag and TraceFlag.
  234|       |  // Note: RefCount tracing is only enabled on debug builds, even when a
  235|       |  //       TraceFlag is used.
  236|       |  template <typename TraceFlagT = TraceFlag>
  237|       |  explicit RefCounted(TraceFlagT* trace_flag = nullptr,
  238|       |                      intptr_t initial_refcount = 1)
  239|       |      : refs_(initial_refcount, trace_flag) {}
  240|       |
  241|       |  // Note: Depending on the Impl used, this dtor can be implicitly virtual.
  242|       |  ~RefCounted() = default;
  243|       |
  244|       | private:
  245|       |  // Allow RefCountedPtr<> to access IncrementRefCount().
  246|       |  template <typename T>
  247|       |  friend class RefCountedPtr;
  248|       |
  249|      0|  void IncrementRefCount() { refs_.Ref(); }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10RefCountedI24grpc_channel_credentialsNS_19PolymorphicRefCountEE17IncrementRefCountEv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_core10RefCountedI17grpc_auth_contextNS_22NonPolymorphicRefCountEE17IncrementRefCountEv
  ------------------
  250|       |  void IncrementRefCount(const DebugLocation& location, const char* reason) {
  251|       |    refs_.Ref(location, reason);
  252|       |  }
  253|       |
  254|       |  RefCount refs_;
  255|       |};
  256|       |
  257|       |}  // namespace grpc_core
  258|       |
  259|       |#endif /* GRPC_CORE_LIB_GPRPP_REF_COUNTED_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/ref_counted_ptr.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_REF_COUNTED_PTR_H
   20|       |#define GRPC_CORE_LIB_GPRPP_REF_COUNTED_PTR_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <type_traits>
   25|       |#include <utility>
   26|       |
   27|       |#include "src/core/lib/gprpp/debug_location.h"
   28|       |#include "src/core/lib/gprpp/memory.h"
   29|       |
   30|       |namespace grpc_core {
   31|       |
   32|       |// A smart pointer class for objects that provide IncrementRefCount() and
   33|       |// Unref() methods, such as those provided by the RefCounted base class.
   34|       |template <typename T>
   35|       |class RefCountedPtr {
   36|       | public:
   37|       |  RefCountedPtr() {}
   38|      0|  RefCountedPtr(std::nullptr_t) {}
   39|       |
   40|       |  // If value is non-null, we take ownership of a ref to it.
   41|       |  template <typename Y>
   42|      0|  explicit RefCountedPtr(Y* value) {
   43|      0|    value_ = value;
   44|      0|  }
   45|       |
   46|       |  // Move ctors.
   47|       |  RefCountedPtr(RefCountedPtr&& other) {
   48|       |    value_ = other.value_;
   49|       |    other.value_ = nullptr;
   50|       |  }
   51|       |  template <typename Y>
   52|       |  RefCountedPtr(RefCountedPtr<Y>&& other) {
   53|       |    value_ = static_cast<T*>(other.value_);
   54|       |    other.value_ = nullptr;
   55|       |  }
   56|       |
   57|       |  // Move assignment.
   58|       |  RefCountedPtr& operator=(RefCountedPtr&& other) {
   59|       |    reset(other.value_);
   60|       |    other.value_ = nullptr;
   61|       |    return *this;
   62|       |  }
   63|       |  template <typename Y>
   64|       |  RefCountedPtr& operator=(RefCountedPtr<Y>&& other) {
   65|       |    reset(other.value_);
   66|       |    other.value_ = nullptr;
   67|       |    return *this;
   68|       |  }
   69|       |
   70|       |  // Copy ctors.
   71|       |  RefCountedPtr(const RefCountedPtr& other) {
   72|       |    if (other.value_ != nullptr) other.value_->IncrementRefCount();
   73|       |    value_ = other.value_;
   74|       |  }
   75|       |  template <typename Y>
   76|       |  RefCountedPtr(const RefCountedPtr<Y>& other) {
   77|       |    static_assert(std::has_virtual_destructor<T>::value,
   78|       |                  "T does not have a virtual dtor");
   79|       |    if (other.value_ != nullptr) other.value_->IncrementRefCount();
   80|       |    value_ = static_cast<T*>(other.value_);
   81|       |  }
   82|       |
   83|       |  // Copy assignment.
   84|       |  RefCountedPtr& operator=(const RefCountedPtr& other) {
   85|       |    // Note: Order of reffing and unreffing is important here in case value_
   86|       |    // and other.value_ are the same object.
   87|       |    if (other.value_ != nullptr) other.value_->IncrementRefCount();
   88|       |    reset(other.value_);
   89|       |    return *this;
   90|       |  }
   91|       |  template <typename Y>
   92|       |  RefCountedPtr& operator=(const RefCountedPtr<Y>& other) {
   93|       |    static_assert(std::has_virtual_destructor<T>::value,
   94|       |                  "T does not have a virtual dtor");
   95|       |    // Note: Order of reffing and unreffing is important here in case value_
   96|       |    // and other.value_ are the same object.
   97|       |    if (other.value_ != nullptr) other.value_->IncrementRefCount();
   98|       |    reset(other.value_);
   99|       |    return *this;
  100|       |  }
  101|       |
  102|      0|  ~RefCountedPtr() {
  103|      0|    if (value_ != nullptr) value_->Unref();
  104|      0|  }
  105|       |
  106|       |  // If value is non-null, we take ownership of a ref to it.
  107|       |  void reset(T* value = nullptr) {
  108|       |    if (value_ != nullptr) value_->Unref();
  109|       |    value_ = value;
  110|       |  }
  111|       |  void reset(const DebugLocation& location, const char* reason,
  112|      0|             T* value = nullptr) {
  113|      0|    if (value_ != nullptr) value_->Unref(location, reason);
  114|      0|    value_ = value;
  115|      0|  }
  116|       |  template <typename Y>
  117|       |  void reset(Y* value = nullptr) {
  118|       |    static_assert(std::has_virtual_destructor<T>::value,
  119|       |                  "T does not have a virtual dtor");
  120|       |    if (value_ != nullptr) value_->Unref();
  121|       |    value_ = static_cast<T*>(value);
  122|       |  }
  123|       |  template <typename Y>
  124|       |  void reset(const DebugLocation& location, const char* reason,
  125|       |             Y* value = nullptr) {
  126|       |    static_assert(std::has_virtual_destructor<T>::value,
  127|       |                  "T does not have a virtual dtor");
  128|       |    if (value_ != nullptr) value_->Unref(location, reason);
  129|       |    value_ = static_cast<T*>(value);
  130|       |  }
  131|       |
  132|       |  // TODO(roth): This method exists solely as a transition mechanism to allow
  133|       |  // us to pass a ref to idiomatic C code that does not use RefCountedPtr<>.
  134|       |  // Once all of our code has been converted to idiomatic C++, this
  135|       |  // method should go away.
  136|       |  T* release() {
  137|       |    T* value = value_;
  138|       |    value_ = nullptr;
  139|       |    return value;
  140|       |  }
  141|       |
  142|      0|  T* get() const { return value_; }
  143|       |
  144|       |  T& operator*() const { return *value_; }
  145|       |  T* operator->() const { return value_; }
  146|       |
  147|       |  template <typename Y>
  148|       |  bool operator==(const RefCountedPtr<Y>& other) const {
  149|       |    return value_ == other.value_;
  150|       |  }
  151|       |
  152|       |  template <typename Y>
  153|       |  bool operator==(const Y* other) const {
  154|       |    return value_ == other;
  155|       |  }
  156|       |
  157|      0|  bool operator==(std::nullptr_t) const { return value_ == nullptr; }
  158|       |
  159|       |  template <typename Y>
  160|       |  bool operator!=(const RefCountedPtr<Y>& other) const {
  161|       |    return value_ != other.value_;
  162|       |  }
  163|       |
  164|       |  template <typename Y>
  165|       |  bool operator!=(const Y* other) const {
  166|       |    return value_ != other;
  167|       |  }
  168|       |
  169|      0|  bool operator!=(std::nullptr_t) const { return value_ != nullptr; }
  170|       |
  171|       | private:
  172|       |  template <typename Y>
  173|       |  friend class RefCountedPtr;
  174|       |
  175|       |  T* value_ = nullptr;
  176|       |};
  177|       |
  178|       |template <typename T, typename... Args>
  179|       |inline RefCountedPtr<T> MakeRefCounted(Args&&... args) {
  180|       |  return RefCountedPtr<T>(New<T>(std::forward<Args>(args)...));
  181|       |}
  182|       |
  183|       |}  // namespace grpc_core
  184|       |
  185|       |#endif /* GRPC_CORE_LIB_GPRPP_REF_COUNTED_PTR_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/sync.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2019 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_SYNC_H
   20|       |#define GRPC_CORE_LIB_GPRPP_SYNC_H
   21|       |
   22|       |#include <grpc/impl/codegen/port_platform.h>
   23|       |
   24|       |#include <grpc/impl/codegen/log.h>
   25|       |#include <grpc/impl/codegen/sync.h>
   26|       |#include <grpc/support/sync.h>
   27|       |#include <grpc/support/time.h>
   28|       |
   29|       |// The core library is not accessible in C++ codegen headers, and vice versa.
   30|       |// Thus, we need to have duplicate headers with similar functionality.
   31|       |// Make sure any change to this file is also reflected in
   32|       |// include/grpcpp/impl/codegen/sync.h.
   33|       |//
   34|       |// Whenever possible, prefer using this file over <grpcpp/impl/codegen/sync.h>
   35|       |// since this file doesn't rely on g_core_codegen_interface and hence does not
   36|       |// pay the costs of virtual function calls.
   37|       |
   38|       |namespace grpc_core {
   39|       |
   40|       |class Mutex {
   41|       | public:
   42|      0|  Mutex() { gpr_mu_init(&mu_); }
   43|      0|  ~Mutex() { gpr_mu_destroy(&mu_); }
   44|       |
   45|       |  Mutex(const Mutex&) = delete;
   46|       |  Mutex& operator=(const Mutex&) = delete;
   47|       |
   48|      0|  gpr_mu* get() { return &mu_; }
   49|      0|  const gpr_mu* get() const { return &mu_; }
   50|       |
   51|       | private:
   52|       |  gpr_mu mu_;
   53|       |};
   54|       |
   55|       |// MutexLock is a std::
   56|       |class MutexLock {
   57|       | public:
   58|      0|  explicit MutexLock(Mutex* mu) : mu_(mu->get()) { gpr_mu_lock(mu_); }
   59|      0|  explicit MutexLock(gpr_mu* mu) : mu_(mu) { gpr_mu_lock(mu_); }
   60|      0|  ~MutexLock() { gpr_mu_unlock(mu_); }
   61|       |
   62|       |  MutexLock(const MutexLock&) = delete;
   63|       |  MutexLock& operator=(const MutexLock&) = delete;
   64|       |
   65|       | private:
   66|       |  gpr_mu* const mu_;
   67|       |};
   68|       |
   69|       |class ReleasableMutexLock {
   70|       | public:
   71|      0|  explicit ReleasableMutexLock(Mutex* mu) : mu_(mu->get()) { gpr_mu_lock(mu_); }
   72|      0|  explicit ReleasableMutexLock(gpr_mu* mu) : mu_(mu) { gpr_mu_lock(mu_); }
   73|      0|  ~ReleasableMutexLock() {
   74|      0|    if (!released_) gpr_mu_unlock(mu_);
   75|      0|  }
   76|       |
   77|       |  ReleasableMutexLock(const ReleasableMutexLock&) = delete;
   78|       |  ReleasableMutexLock& operator=(const ReleasableMutexLock&) = delete;
   79|       |
   80|      0|  void Lock() {
   81|      0|    GPR_DEBUG_ASSERT(released_);
   82|      0|    gpr_mu_lock(mu_);
   83|      0|    released_ = false;
   84|      0|  }
   85|       |
   86|      0|  void Unlock() {
   87|      0|    GPR_DEBUG_ASSERT(!released_);
   88|      0|    released_ = true;
   89|      0|    gpr_mu_unlock(mu_);
   90|      0|  }
   91|       |
   92|       | private:
   93|       |  gpr_mu* const mu_;
   94|       |  bool released_ = false;
   95|       |};
   96|       |
   97|       |class CondVar {
   98|       | public:
   99|      0|  CondVar() { gpr_cv_init(&cv_); }
  100|      0|  ~CondVar() { gpr_cv_destroy(&cv_); }
  101|       |
  102|       |  CondVar(const CondVar&) = delete;
  103|       |  CondVar& operator=(const CondVar&) = delete;
  104|       |
  105|      0|  void Signal() { gpr_cv_signal(&cv_); }
  106|      0|  void Broadcast() { gpr_cv_broadcast(&cv_); }
  107|       |
  108|      0|  int Wait(Mutex* mu) { return Wait(mu, gpr_inf_future(GPR_CLOCK_REALTIME)); }
  109|      0|  int Wait(Mutex* mu, const gpr_timespec& deadline) {
  110|      0|    return gpr_cv_wait(&cv_, mu->get(), deadline);
  111|      0|  }
  112|       |
  113|       |  template <typename Predicate>
  114|       |  void WaitUntil(Mutex* mu, Predicate pred) {
  115|       |    while (!pred()) {
  116|       |      Wait(mu, gpr_inf_future(GPR_CLOCK_REALTIME));
  117|       |    }
  118|       |  }
  119|       |
  120|       | private:
  121|       |  gpr_cv cv_;
  122|       |};
  123|       |
  124|       |}  // namespace grpc_core
  125|       |
  126|       |#endif /* GRPC_CORE_LIB_GPRPP_SYNC_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/gprpp/thd.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_GPRPP_THD_H
   20|       |#define GRPC_CORE_LIB_GPRPP_THD_H
   21|       |
   22|       |/** Internal thread interface. */
   23|       |
   24|       |#include <grpc/support/port_platform.h>
   25|       |
   26|       |#include <grpc/support/log.h>
   27|       |#include <grpc/support/sync.h>
   28|       |#include <grpc/support/thd_id.h>
   29|       |#include <grpc/support/time.h>
   30|       |
   31|       |#include "src/core/lib/gprpp/abstract.h"
   32|       |#include "src/core/lib/gprpp/memory.h"
   33|       |
   34|       |namespace grpc_core {
   35|       |namespace internal {
   36|       |
   37|       |/// Base class for platform-specific thread-state
   38|       |class ThreadInternalsInterface {
   39|       | public:
   40|      0|  virtual ~ThreadInternalsInterface() {}
   41|       |  virtual void Start() GRPC_ABSTRACT;
   42|       |  virtual void Join() GRPC_ABSTRACT;
   43|       |  GRPC_ABSTRACT_BASE_CLASS
   44|       |};
   45|       |
   46|       |}  // namespace internal
   47|       |
   48|       |class Thread {
   49|       | public:
   50|       |  class Options {
   51|       |   public:
   52|      1|    Options() : joinable_(true), tracked_(true) {}
   53|       |    /// Set whether the thread is joinable or detached.
   54|       |    Options& set_joinable(bool joinable) {
   55|       |      joinable_ = joinable;
   56|       |      return *this;
   57|       |    }
   58|      1|    bool joinable() const { return joinable_; }
   59|       |
   60|       |    /// Set whether the thread is tracked for fork support.
   61|       |    Options& set_tracked(bool tracked) {
   62|       |      tracked_ = tracked;
   63|       |      return *this;
   64|       |    }
   65|       |    bool tracked() const { return tracked_; }
   66|       |
   67|       |   private:
   68|       |    bool joinable_;
   69|       |    bool tracked_;
   70|       |  };
   71|       |  /// Default constructor only to allow use in structs that lack constructors
   72|       |  /// Does not produce a validly-constructed thread; must later
   73|       |  /// use placement new to construct a real thread. Does not init mu_ and cv_
   74|      1|  Thread() : state_(FAKE), impl_(nullptr) {}
   75|       |
   76|       |  /// Normal constructor to create a thread with name \a thd_name,
   77|       |  /// which will execute a thread based on function \a thd_body
   78|       |  /// with argument \a arg once it is started.
   79|       |  /// The optional \a success argument indicates whether the thread
   80|       |  /// is successfully created.
   81|       |  /// The optional \a options can be used to set the thread detachable.
   82|       |  Thread(const char* thd_name, void (*thd_body)(void* arg), void* arg,
   83|       |         bool* success = nullptr, const Options& options = Options());
   84|       |
   85|       |  /// Move constructor for thread. After this is called, the other thread
   86|       |  /// no longer represents a living thread object
   87|       |  Thread(Thread&& other)
   88|      0|      : state_(other.state_), impl_(other.impl_), options_(other.options_) {
   89|      0|    other.state_ = MOVED;
   90|      0|    other.impl_ = nullptr;
   91|      0|    other.options_ = Options();
   92|      0|  }
   93|       |
   94|       |  /// Move assignment operator for thread. After this is called, the other
   95|       |  /// thread no longer represents a living thread object. Not allowed if this
   96|       |  /// thread actually exists
   97|      0|  Thread& operator=(Thread&& other) {
   98|      0|    if (this != &other) {
   99|      0|      // TODO(vjpai): if we can be sure that all Thread's are actually
  100|      0|      // constructed, then we should assert GPR_ASSERT(impl_ == nullptr) here.
  101|      0|      // However, as long as threads come in structures that are
  102|      0|      // allocated via gpr_malloc, this will not be the case, so we cannot
  103|      0|      // assert it for the time being.
  104|      0|      state_ = other.state_;
  105|      0|      impl_ = other.impl_;
  106|      0|      options_ = other.options_;
  107|      0|      other.state_ = MOVED;
  108|      0|      other.impl_ = nullptr;
  109|      0|      other.options_ = Options();
  110|      0|    }
  111|      0|    return *this;
  112|      0|  }
  113|       |
  114|       |  /// The destructor is strictly optional; either the thread never came to life
  115|       |  /// and the constructor itself killed it, or it has already been joined and
  116|       |  /// the Join function kills it, or it was detached (non-joinable) and it has
  117|       |  /// run to completion and is now killing itself. The destructor shouldn't have
  118|       |  /// to do anything.
  119|      1|  ~Thread() { GPR_ASSERT(!options_.joinable() || impl_ == nullptr); }
  120|       |
  121|      0|  void Start() {
  122|      0|    if (impl_ != nullptr) {
  123|      0|      GPR_ASSERT(state_ == ALIVE);
  124|      0|      state_ = STARTED;
  125|      0|      impl_->Start();
  126|      0|      // If the Thread is not joinable, then the impl_ will cause the deletion
  127|      0|      // of this Thread object when the thread function completes. Since no
  128|      0|      // other operation is allowed to a detached thread after Start, there is
  129|      0|      // no need to change the value of the impl_ or state_ . The next operation
  130|      0|      // on this object will be the deletion, which will trigger the destructor.
  131|      0|    } else {
  132|      0|      GPR_ASSERT(state_ == FAILED);
  133|      0|    }
  134|      0|  }
  135|       |
  136|       |  // It is only legal to call Join if the Thread is created as joinable.
  137|      0|  void Join() {
  138|      0|    if (impl_ != nullptr) {
  139|      0|      impl_->Join();
  140|      0|      grpc_core::Delete(impl_);
  141|      0|      state_ = DONE;
  142|      0|      impl_ = nullptr;
  143|      0|    } else {
  144|      0|      GPR_ASSERT(state_ == FAILED);
  145|      0|    }
  146|      0|  }
  147|       |
  148|       | private:
  149|       |  Thread(const Thread&) = delete;
  150|       |  Thread& operator=(const Thread&) = delete;
  151|       |
  152|       |  /// The thread states are as follows:
  153|       |  /// FAKE -- just a dummy placeholder Thread created by the default constructor
  154|       |  /// ALIVE -- an actual thread of control exists associated with this thread
  155|       |  /// STARTED -- the thread of control has been started
  156|       |  /// DONE -- the thread of control has completed and been joined
  157|       |  /// FAILED -- the thread of control never came alive
  158|       |  /// MOVED -- contents were moved out and we're no longer tracking them
  159|       |  enum ThreadState { FAKE, ALIVE, STARTED, DONE, FAILED, MOVED };
  160|       |  ThreadState state_;
  161|       |  internal::ThreadInternalsInterface* impl_;
  162|       |  Options options_;
  163|       |};
  164|       |
  165|       |}  // namespace grpc_core
  166|       |
  167|       |#endif /* GRPC_CORE_LIB_GPRPP_THD_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/iomgr/call_combiner.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_IOMGR_CALL_COMBINER_H
   20|       |#define GRPC_CORE_LIB_IOMGR_CALL_COMBINER_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <stddef.h>
   25|       |
   26|       |#include <grpc/support/atm.h>
   27|       |
   28|       |#include "src/core/lib/gpr/mpscq.h"
   29|       |#include "src/core/lib/gprpp/inlined_vector.h"
   30|       |#include "src/core/lib/gprpp/ref_counted.h"
   31|       |#include "src/core/lib/gprpp/ref_counted_ptr.h"
   32|       |#include "src/core/lib/iomgr/closure.h"
   33|       |#include "src/core/lib/iomgr/dynamic_annotations.h"
   34|       |
   35|       |// A simple, lock-free mechanism for serializing activity related to a
   36|       |// single call.  This is similar to a combiner but is more lightweight.
   37|       |//
   38|       |// It requires the callback (or, in the common case where the callback
   39|       |// actually kicks off a chain of callbacks, the last callback in that
   40|       |// chain) to explicitly indicate (by calling GRPC_CALL_COMBINER_STOP())
   41|       |// when it is done with the action that was kicked off by the original
   42|       |// callback.
   43|       |
   44|       |namespace grpc_core {
   45|       |
   46|       |extern TraceFlag grpc_call_combiner_trace;
   47|       |
   48|       |class CallCombiner {
   49|       | public:
   50|       |  CallCombiner();
   51|       |  ~CallCombiner();
   52|       |
   53|       |#ifndef NDEBUG
   54|       |#define GRPC_CALL_COMBINER_START(call_combiner, closure, error, reason) \
   55|       |  (call_combiner)->Start((closure), (error), __FILE__, __LINE__, (reason))
   56|       |#define GRPC_CALL_COMBINER_STOP(call_combiner, reason) \
   57|       |  (call_combiner)->Stop(__FILE__, __LINE__, (reason))
   58|       |  /// Starts processing \a closure.
   59|       |  void Start(grpc_closure* closure, grpc_error* error, const char* file,
   60|       |             int line, const char* reason);
   61|       |  /// Yields the call combiner to the next closure in the queue, if any.
   62|       |  void Stop(const char* file, int line, const char* reason);
   63|       |#else
   64|       |#define GRPC_CALL_COMBINER_START(call_combiner, closure, error, reason) \
   65|       |  (call_combiner)->Start((closure), (error), (reason))
   66|       |#define GRPC_CALL_COMBINER_STOP(call_combiner, reason) \
   67|       |  (call_combiner)->Stop((reason))
   68|       |  /// Starts processing \a closure.
   69|       |  void Start(grpc_closure* closure, grpc_error* error, const char* reason);
   70|       |  /// Yields the call combiner to the next closure in the queue, if any.
   71|       |  void Stop(const char* reason);
   72|       |#endif
   73|       |
   74|       |  /// Registers \a closure to be invoked when Cancel() is called.
   75|       |  ///
   76|       |  /// Once a closure is registered, it will always be scheduled exactly
   77|       |  /// once; this allows the closure to hold references that will be freed
   78|       |  /// regardless of whether or not the call was cancelled.  If a cancellation
   79|       |  /// does occur, the closure will be scheduled with the cancellation error;
   80|       |  /// otherwise, it will be scheduled with GRPC_ERROR_NONE.
   81|       |  ///
   82|       |  /// The closure will be scheduled in the following cases:
   83|       |  /// - If Cancel() was called prior to registering the closure, it will be
   84|       |  ///   scheduled immediately with the cancelation error.
   85|       |  /// - If Cancel() is called after registering the closure, the closure will
   86|       |  ///   be scheduled with the cancellation error.
   87|       |  /// - If SetNotifyOnCancel() is called again to register a new cancellation
   88|       |  ///   closure, the previous cancellation closure will be scheduled with
   89|       |  ///   GRPC_ERROR_NONE.
   90|       |  ///
   91|       |  /// If \a closure is NULL, then no closure will be invoked on
   92|       |  /// cancellation; this effectively unregisters the previously set closure.
   93|       |  /// However, most filters will not need to explicitly unregister their
   94|       |  /// callbacks, as this is done automatically when the call is destroyed.
   95|       |  /// Filters that schedule the cancellation closure on ExecCtx do not need
   96|       |  /// to take a ref on the call stack to guarantee closure liveness. This is
   97|       |  /// done by explicitly flushing ExecCtx after the unregistration during
   98|       |  /// call destruction.
   99|       |  void SetNotifyOnCancel(grpc_closure* closure);
  100|       |
  101|       |  /// Indicates that the call has been cancelled.
  102|       |  void Cancel(grpc_error* error);
  103|       |
  104|       | private:
  105|       |  void ScheduleClosure(grpc_closure* closure, grpc_error* error);
  106|       |#ifdef GRPC_TSAN_ENABLED
  107|       |  static void TsanClosure(void* arg, grpc_error* error);
  108|       |#endif
  109|       |
  110|       |  gpr_atm size_ = 0;  // size_t, num closures in queue or currently executing
  111|       |  gpr_mpscq queue_;
  112|       |  // Either 0 (if not cancelled and no cancellation closure set),
  113|       |  // a grpc_closure* (if the lowest bit is 0),
  114|       |  // or a grpc_error* (if the lowest bit is 1).
  115|       |  gpr_atm cancel_state_ = 0;
  116|       |#ifdef GRPC_TSAN_ENABLED
  117|       |  // A fake ref-counted lock that is kept alive after the destruction of
  118|       |  // grpc_call_combiner, when we are running the original closure.
  119|       |  //
  120|       |  // Ideally we want to lock and unlock the call combiner as a pointer, when the
  121|       |  // callback is called. However, original_closure is free to trigger
  122|       |  // anything on the call combiner (including destruction of grpc_call).
  123|       |  // Thus, we need a ref-counted structure that can outlive the call combiner.
  124|       |  struct TsanLock : public RefCounted<TsanLock, NonPolymorphicRefCount> {
  125|       |    TsanLock() { TSAN_ANNOTATE_RWLOCK_CREATE(&taken); }
  126|       |    ~TsanLock() { TSAN_ANNOTATE_RWLOCK_DESTROY(&taken); }
  127|       |    // To avoid double-locking by the same thread, we should acquire/release
  128|       |    // the lock only when taken is false. On each acquire taken must be set to
  129|       |    // true.
  130|       |    std::atomic<bool> taken{false};
  131|       |  };
  132|       |  RefCountedPtr<TsanLock> tsan_lock_ = MakeRefCounted<TsanLock>();
  133|       |  grpc_closure tsan_closure_;
  134|       |  grpc_closure* original_closure_;
  135|       |#endif
  136|       |};
  137|       |
  138|       |// Helper for running a list of closures in a call combiner.
  139|       |//
  140|       |// Each callback running in the call combiner will eventually be
  141|       |// returned to the surface, at which point the surface will yield the
  142|       |// call combiner.  So when we are running in the call combiner and have
  143|       |// more than one callback to return to the surface, we need to re-enter
  144|       |// the call combiner for all but one of those callbacks.
  145|       |class CallCombinerClosureList {
  146|       | public:
  147|      0|  CallCombinerClosureList() {}
  148|       |
  149|       |  // Adds a closure to the list.  The closure must eventually result in
  150|       |  // the call combiner being yielded.
  151|      0|  void Add(grpc_closure* closure, grpc_error* error, const char* reason) {
  152|      0|    closures_.emplace_back(closure, error, reason);
  153|      0|  }
  154|       |
  155|       |  // Runs all closures in the call combiner and yields the call combiner.
  156|       |  //
  157|       |  // All but one of the closures in the list will be scheduled via
  158|       |  // GRPC_CALL_COMBINER_START(), and the remaining closure will be
  159|       |  // scheduled via GRPC_CLOSURE_SCHED(), which will eventually result in
  160|       |  // yielding the call combiner.  If the list is empty, then the call
  161|       |  // combiner will be yielded immediately.
  162|       |  void RunClosures(CallCombiner* call_combiner) {
  163|       |    if (closures_.empty()) {
  164|       |      GRPC_CALL_COMBINER_STOP(call_combiner, "no closures to schedule");
  165|       |      return;
  166|       |    }
  167|       |    for (size_t i = 1; i < closures_.size(); ++i) {
  168|       |      auto& closure = closures_[i];
  169|       |      GRPC_CALL_COMBINER_START(call_combiner, closure.closure, closure.error,
  170|       |                               closure.reason);
  171|       |    }
  172|       |    if (GRPC_TRACE_FLAG_ENABLED(grpc_call_combiner_trace)) {
  173|       |      gpr_log(GPR_INFO,
  174|       |              "CallCombinerClosureList executing closure while already "
  175|       |              "holding call_combiner %p: closure=%p error=%s reason=%s",
  176|       |              call_combiner, closures_[0].closure,
  177|       |              grpc_error_string(closures_[0].error), closures_[0].reason);
  178|       |    }
  179|       |    // This will release the call combiner.
  180|       |    GRPC_CLOSURE_SCHED(closures_[0].closure, closures_[0].error);
  181|       |    closures_.clear();
  182|       |  }
  183|       |
  184|       |  // Runs all closures in the call combiner, but does NOT yield the call
  185|       |  // combiner.  All closures will be scheduled via GRPC_CALL_COMBINER_START().
  186|       |  void RunClosuresWithoutYielding(CallCombiner* call_combiner) {
  187|       |    for (size_t i = 0; i < closures_.size(); ++i) {
  188|       |      auto& closure = closures_[i];
  189|       |      GRPC_CALL_COMBINER_START(call_combiner, closure.closure, closure.error,
  190|       |                               closure.reason);
  191|       |    }
  192|       |    closures_.clear();
  193|       |  }
  194|       |
  195|       |  size_t size() const { return closures_.size(); }
  196|       |
  197|       | private:
  198|       |  struct CallCombinerClosure {
  199|       |    grpc_closure* closure;
  200|       |    grpc_error* error;
  201|       |    const char* reason;
  202|       |
  203|       |    CallCombinerClosure(grpc_closure* closure, grpc_error* error,
  204|       |                        const char* reason)
  205|      0|        : closure(closure), error(error), reason(reason) {}
  206|       |  };
  207|       |
  208|       |  // There are generally a maximum of 6 closures to run in the call
  209|       |  // combiner, one for each pending op.
  210|       |  InlinedVector<CallCombinerClosure, 6> closures_;
  211|       |};
  212|       |
  213|       |}  // namespace grpc_core
  214|       |
  215|       |#endif /* GRPC_CORE_LIB_IOMGR_CALL_COMBINER_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/iomgr/closure.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_IOMGR_CLOSURE_H
   20|       |#define GRPC_CORE_LIB_IOMGR_CLOSURE_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <assert.h>
   25|       |#include <grpc/support/alloc.h>
   26|       |#include <grpc/support/log.h>
   27|       |#include <stdbool.h>
   28|       |#include "src/core/lib/gpr/mpscq.h"
   29|       |#include "src/core/lib/iomgr/error.h"
   30|       |#include "src/core/lib/profiling/timers.h"
   31|       |
   32|       |struct grpc_closure;
   33|       |typedef struct grpc_closure grpc_closure;
   34|       |
   35|       |extern grpc_core::DebugOnlyTraceFlag grpc_trace_closure;
   36|       |
   37|       |typedef struct grpc_closure_list {
   38|       |  grpc_closure* head;
   39|       |  grpc_closure* tail;
   40|       |} grpc_closure_list;
   41|       |
   42|       |/** gRPC Callback definition.
   43|       | *
   44|       | * \param arg Arbitrary input.
   45|       | * \param error GRPC_ERROR_NONE if no error occurred, otherwise some grpc_error
   46|       | *              describing what went wrong.
   47|       | *              Error contract: it is not the cb's job to unref this error;
   48|       | *              the closure scheduler will do that after the cb returns */
   49|       |typedef void (*grpc_iomgr_cb_func)(void* arg, grpc_error* error);
   50|       |
   51|       |typedef struct grpc_closure_scheduler grpc_closure_scheduler;
   52|       |
   53|       |typedef struct grpc_closure_scheduler_vtable {
   54|       |  /* NOTE: for all these functions, closure->scheduler == the scheduler that was
   55|       |           used to find this vtable */
   56|       |  void (*run)(grpc_closure* closure, grpc_error* error);
   57|       |  void (*sched)(grpc_closure* closure, grpc_error* error);
   58|       |  const char* name;
   59|       |} grpc_closure_scheduler_vtable;
   60|       |
   61|       |/** Abstract type that can schedule closures for execution */
   62|       |struct grpc_closure_scheduler {
   63|       |  const grpc_closure_scheduler_vtable* vtable;
   64|       |};
   65|       |
   66|       |/** A closure over a grpc_iomgr_cb_func. */
   67|       |struct grpc_closure {
   68|       |  /** Once queued, next indicates the next queued closure; before then, scratch
   69|       |   *  space */
   70|       |  union {
   71|       |    grpc_closure* next;
   72|       |    gpr_mpscq_node atm_next;
   73|       |    uintptr_t scratch;
   74|       |  } next_data;
   75|       |
   76|       |  /** Bound callback. */
   77|       |  grpc_iomgr_cb_func cb;
   78|       |
   79|       |  /** Arguments to be passed to "cb". */
   80|       |  void* cb_arg;
   81|       |
   82|       |  /** Scheduler to schedule against: nullptr to schedule against current
   83|       |     execution context */
   84|       |  grpc_closure_scheduler* scheduler;
   85|       |
   86|       |  /** Once queued, the result of the closure. Before then: scratch space */
   87|       |  union {
   88|       |    grpc_error* error;
   89|       |    uintptr_t scratch;
   90|       |  } error_data;
   91|       |
   92|       |// extra tracing and debugging for grpc_closure. This incurs a decent amount of
   93|       |// overhead per closure, so it must be enabled at compile time.
   94|       |#ifndef NDEBUG
   95|       |  bool scheduled;
   96|       |  bool run;  // true = run, false = scheduled
   97|       |  const char* file_created;
   98|       |  int line_created;
   99|       |  const char* file_initiated;
  100|       |  int line_initiated;
  101|       |#endif
  102|       |};
  103|       |
  104|       |#ifndef NDEBUG
  105|       |inline grpc_closure* grpc_closure_init(const char* file, int line,
  106|       |                                       grpc_closure* closure,
  107|       |                                       grpc_iomgr_cb_func cb, void* cb_arg,
  108|      0|                                       grpc_closure_scheduler* scheduler) {
  109|       |#else
  110|       |inline grpc_closure* grpc_closure_init(grpc_closure* closure,
  111|       |                                       grpc_iomgr_cb_func cb, void* cb_arg,
  112|       |                                       grpc_closure_scheduler* scheduler) {
  113|       |#endif
  114|       |  closure->cb = cb;
  115|      0|  closure->cb_arg = cb_arg;
  116|      0|  closure->scheduler = scheduler;
  117|      0|  closure->error_data.error = GRPC_ERROR_NONE;
  118|      0|#ifndef NDEBUG
  119|      0|  closure->scheduled = false;
  120|      0|  closure->file_initiated = nullptr;
  121|      0|  closure->line_initiated = 0;
  122|      0|  closure->run = false;
  123|      0|  closure->file_created = file;
  124|      0|  closure->line_created = line;
  125|      0|#endif
  126|      0|  return closure;
  127|      0|}
  128|       |
  129|       |/** Initializes \a closure with \a cb and \a cb_arg. Returns \a closure. */
  130|       |#ifndef NDEBUG
  131|       |#define GRPC_CLOSURE_INIT(closure, cb, cb_arg, scheduler) \
  132|      0|  grpc_closure_init(__FILE__, __LINE__, closure, cb, cb_arg, scheduler)
  ------------------
  | Unexecuted instantiation: _ZZN9grpc_impl8internal9AlarmImpl3SetEPNS_15CompletionQueueE12gpr_timespecPvENKUlS5_P10grpc_errorE_clES5_S7_
  ------------------
  | Unexecuted instantiation: _ZZZN9grpc_impl8internal9AlarmImpl3SetEPNS_15CompletionQueueE12gpr_timespecPvENKUlS5_P10grpc_errorE_clES5_S7_ENKUlS5_P18grpc_cq_completionE_clES5_SA_
  ------------------
  | Unexecuted instantiation: _ZZN9grpc_impl8internal9AlarmImpl3SetE12gpr_timespecNSt3__18functionIFvbEEEENKUlPvP10grpc_errorE_clES7_S9_
  ------------------
  133|       |#else
  134|       |#define GRPC_CLOSURE_INIT(closure, cb, cb_arg, scheduler) \
  135|       |  grpc_closure_init(closure, cb, cb_arg, scheduler)
  136|       |#endif
  137|       |
  138|       |namespace closure_impl {
  139|       |
  140|       |typedef struct {
  141|       |  grpc_iomgr_cb_func cb;
  142|       |  void* cb_arg;
  143|       |  grpc_closure wrapper;
  144|       |} wrapped_closure;
  145|       |
  146|      0|inline void closure_wrapper(void* arg, grpc_error* error) {
  147|      0|  wrapped_closure* wc = static_cast<wrapped_closure*>(arg);
  148|      0|  grpc_iomgr_cb_func cb = wc->cb;
  149|      0|  void* cb_arg = wc->cb_arg;
  150|      0|  gpr_free(wc);
  151|      0|  cb(cb_arg, error);
  152|      0|}
  153|       |
  154|       |}  // namespace closure_impl
  155|       |
  156|       |#ifndef NDEBUG
  157|       |inline grpc_closure* grpc_closure_create(const char* file, int line,
  158|       |                                         grpc_iomgr_cb_func cb, void* cb_arg,
  159|       |                                         grpc_closure_scheduler* scheduler) {
  160|       |#else
  161|       |inline grpc_closure* grpc_closure_create(grpc_iomgr_cb_func cb, void* cb_arg,
  162|       |                                         grpc_closure_scheduler* scheduler) {
  163|       |#endif
  164|       |  closure_impl::wrapped_closure* wc =
  165|       |      static_cast<closure_impl::wrapped_closure*>(gpr_malloc(sizeof(*wc)));
  166|       |  wc->cb = cb;
  167|       |  wc->cb_arg = cb_arg;
  168|       |#ifndef NDEBUG
  169|       |  grpc_closure_init(file, line, &wc->wrapper, closure_impl::closure_wrapper, wc,
  170|       |                    scheduler);
  171|       |#else
  172|       |  grpc_closure_init(&wc->wrapper, closure_impl::closure_wrapper, wc, scheduler);
  173|       |#endif
  174|       |  return &wc->wrapper;
  175|       |}
  176|       |
  177|       |/* Create a heap allocated closure: try to avoid except for very rare events */
  178|       |#ifndef NDEBUG
  179|       |#define GRPC_CLOSURE_CREATE(cb, cb_arg, scheduler) \
  180|       |  grpc_closure_create(__FILE__, __LINE__, cb, cb_arg, scheduler)
  181|       |#else
  182|       |#define GRPC_CLOSURE_CREATE(cb, cb_arg, scheduler) \
  183|       |  grpc_closure_create(cb, cb_arg, scheduler)
  184|       |#endif
  185|       |
  186|       |#define GRPC_CLOSURE_LIST_INIT \
  187|       |  { nullptr, nullptr }
  188|       |
  189|      0|inline void grpc_closure_list_init(grpc_closure_list* closure_list) {
  190|      0|  closure_list->head = closure_list->tail = nullptr;
  191|      0|}
  192|       |
  193|       |/** add \a closure to the end of \a list
  194|       |    and set \a closure's result to \a error
  195|       |    Returns true if \a list becomes non-empty */
  196|       |inline bool grpc_closure_list_append(grpc_closure_list* closure_list,
  197|       |                                     grpc_closure* closure, grpc_error* error) {
  198|       |  if (closure == nullptr) {
  199|       |    GRPC_ERROR_UNREF(error);
  200|       |    return false;
  201|       |  }
  202|       |  closure->error_data.error = error;
  203|       |  closure->next_data.next = nullptr;
  204|       |  bool was_empty = (closure_list->head == nullptr);
  205|       |  if (was_empty) {
  206|       |    closure_list->head = closure;
  207|       |  } else {
  208|       |    closure_list->tail->next_data.next = closure;
  209|       |  }
  210|       |  closure_list->tail = closure;
  211|       |  return was_empty;
  212|       |}
  213|       |
  214|       |/** force all success bits in \a list to false */
  215|       |inline void grpc_closure_list_fail_all(grpc_closure_list* list,
  216|       |                                       grpc_error* forced_failure) {
  217|       |  for (grpc_closure* c = list->head; c != nullptr; c = c->next_data.next) {
  218|       |    if (c->error_data.error == GRPC_ERROR_NONE) {
  219|       |      c->error_data.error = GRPC_ERROR_REF(forced_failure);
  220|       |    }
  221|       |  }
  222|       |  GRPC_ERROR_UNREF(forced_failure);
  223|       |}
  224|       |
  225|       |/** append all closures from \a src to \a dst and empty \a src. */
  226|       |inline void grpc_closure_list_move(grpc_closure_list* src,
  227|       |                                   grpc_closure_list* dst) {
  228|       |  if (src->head == nullptr) {
  229|       |    return;
  230|       |  }
  231|       |  if (dst->head == nullptr) {
  232|       |    *dst = *src;
  233|       |  } else {
  234|       |    dst->tail->next_data.next = src->head;
  235|       |    dst->tail = src->tail;
  236|       |  }
  237|       |  src->head = src->tail = nullptr;
  238|       |}
  239|       |
  240|       |/** return whether \a list is empty. */
  241|       |inline bool grpc_closure_list_empty(grpc_closure_list closure_list) {
  242|       |  return closure_list.head == nullptr;
  243|       |}
  244|       |
  245|       |#ifndef NDEBUG
  246|       |inline void grpc_closure_run(const char* file, int line, grpc_closure* c,
  247|       |                             grpc_error* error) {
  248|       |#else
  249|       |inline void grpc_closure_run(grpc_closure* c, grpc_error* error) {
  250|       |#endif
  251|       |  GPR_TIMER_SCOPE("grpc_closure_run", 0);
  252|       |  if (c != nullptr) {
  253|       |#ifndef NDEBUG
  254|       |    c->file_initiated = file;
  255|       |    c->line_initiated = line;
  256|       |    c->run = true;
  257|       |    GPR_ASSERT(c->cb != nullptr);
  258|       |#endif
  259|       |    c->scheduler->vtable->run(c, error);
  260|       |  } else {
  261|       |    GRPC_ERROR_UNREF(error);
  262|       |  }
  263|       |}
  264|       |
  265|       |/** Run a closure directly. Caller ensures that no locks are being held above.
  266|       | *  Note that calling this at the end of a closure callback function itself is
  267|       | *  by definition safe. */
  268|       |#ifndef NDEBUG
  269|       |#define GRPC_CLOSURE_RUN(closure, error) \
  270|       |  grpc_closure_run(__FILE__, __LINE__, closure, error)
  271|       |#else
  272|       |#define GRPC_CLOSURE_RUN(closure, error) grpc_closure_run(closure, error)
  273|       |#endif
  274|       |
  275|       |#ifndef NDEBUG
  276|       |inline void grpc_closure_sched(const char* file, int line, grpc_closure* c,
  277|       |                               grpc_error* error) {
  278|       |#else
  279|       |inline void grpc_closure_sched(grpc_closure* c, grpc_error* error) {
  280|       |#endif
  281|       |  GPR_TIMER_SCOPE("grpc_closure_sched", 0);
  282|       |  if (c != nullptr) {
  283|       |#ifndef NDEBUG
  284|       |    if (c->scheduled) {
  285|       |      gpr_log(GPR_ERROR,
  286|       |              "Closure already scheduled. (closure: %p, created: [%s:%d], "
  287|       |              "previously scheduled at: [%s: %d], newly scheduled at [%s: %d], "
  288|       |              "run?: %s",
  289|       |              c, c->file_created, c->line_created, c->file_initiated,
  290|       |              c->line_initiated, file, line, c->run ? "true" : "false");
  291|       |      abort();
  292|       |    }
  293|       |    c->scheduled = true;
  294|       |    c->file_initiated = file;
  295|       |    c->line_initiated = line;
  296|       |    c->run = false;
  297|       |    GPR_ASSERT(c->cb != nullptr);
  298|       |#endif
  299|       |    c->scheduler->vtable->sched(c, error);
  300|       |  } else {
  301|       |    GRPC_ERROR_UNREF(error);
  302|       |  }
  303|       |}
  304|       |
  305|       |/** Schedule a closure to be run. Does not need to be run from a safe point. */
  306|       |#ifndef NDEBUG
  307|       |#define GRPC_CLOSURE_SCHED(closure, error) \
  308|       |  grpc_closure_sched(__FILE__, __LINE__, closure, error)
  309|       |#else
  310|       |#define GRPC_CLOSURE_SCHED(closure, error) grpc_closure_sched(closure, error)
  311|       |#endif
  312|       |
  313|       |#ifndef NDEBUG
  314|       |inline void grpc_closure_list_sched(const char* file, int line,
  315|       |                                    grpc_closure_list* list) {
  316|       |#else
  317|       |inline void grpc_closure_list_sched(grpc_closure_list* list) {
  318|       |#endif
  319|       |  grpc_closure* c = list->head;
  320|       |  while (c != nullptr) {
  321|       |    grpc_closure* next = c->next_data.next;
  322|       |#ifndef NDEBUG
  323|       |    if (c->scheduled) {
  324|       |      gpr_log(GPR_ERROR,
  325|       |              "Closure already scheduled. (closure: %p, created: [%s:%d], "
  326|       |              "previously scheduled at: [%s: %d] run?: %s",
  327|       |              c, c->file_created, c->line_created, c->file_initiated,
  328|       |              c->line_initiated, c->run ? "true" : "false");
  329|       |      abort();
  330|       |    }
  331|       |    c->scheduled = true;
  332|       |    c->file_initiated = file;
  333|       |    c->line_initiated = line;
  334|       |    c->run = false;
  335|       |    GPR_ASSERT(c->cb != nullptr);
  336|       |#endif
  337|       |    c->scheduler->vtable->sched(c, c->error_data.error);
  338|       |    c = next;
  339|       |  }
  340|       |  list->head = list->tail = nullptr;
  341|       |}
  342|       |
  343|       |/** Schedule all closures in a list to be run. Does not need to be run from a
  344|       | * safe point. */
  345|       |#ifndef NDEBUG
  346|       |#define GRPC_CLOSURE_LIST_SCHED(closure_list) \
  347|       |  grpc_closure_list_sched(__FILE__, __LINE__, closure_list)
  348|       |#else
  349|       |#define GRPC_CLOSURE_LIST_SCHED(closure_list) \
  350|       |  grpc_closure_list_sched(closure_list)
  351|       |#endif
  352|       |
  353|       |#endif /* GRPC_CORE_LIB_IOMGR_CLOSURE_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/iomgr/error.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_IOMGR_ERROR_H
   20|       |#define GRPC_CORE_LIB_IOMGR_ERROR_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <inttypes.h>
   25|       |#include <stdbool.h>
   26|       |
   27|       |#include <grpc/slice.h>
   28|       |#include <grpc/status.h>
   29|       |#include <grpc/support/log.h>
   30|       |#include <grpc/support/time.h>
   31|       |
   32|       |#include "src/core/lib/debug/trace.h"
   33|       |#include "src/core/lib/gprpp/inlined_vector.h"
   34|       |
   35|       |/// Opaque representation of an error.
   36|       |/// See https://github.com/grpc/grpc/blob/master/doc/core/grpc-error.md for a
   37|       |/// full write up of this object.
   38|       |
   39|       |typedef struct grpc_error grpc_error;
   40|       |
   41|       |extern grpc_core::DebugOnlyTraceFlag grpc_trace_error_refcount;
   42|       |
   43|       |typedef enum {
   44|       |  /// 'errno' from the operating system
   45|       |  GRPC_ERROR_INT_ERRNO,
   46|       |  /// __LINE__ from the call site creating the error
   47|       |  GRPC_ERROR_INT_FILE_LINE,
   48|       |  /// stream identifier: for errors that are associated with an individual
   49|       |  /// wire stream
   50|       |  GRPC_ERROR_INT_STREAM_ID,
   51|       |  /// grpc status code representing this error
   52|       |  GRPC_ERROR_INT_GRPC_STATUS,
   53|       |  /// offset into some binary blob (usually represented by
   54|       |  /// GRPC_ERROR_STR_RAW_BYTES) where the error occurred
   55|       |  GRPC_ERROR_INT_OFFSET,
   56|       |  /// context sensitive index associated with the error
   57|       |  GRPC_ERROR_INT_INDEX,
   58|       |  /// context sensitive size associated with the error
   59|       |  GRPC_ERROR_INT_SIZE,
   60|       |  /// http2 error code associated with the error (see the HTTP2 RFC)
   61|       |  GRPC_ERROR_INT_HTTP2_ERROR,
   62|       |  /// TSI status code associated with the error
   63|       |  GRPC_ERROR_INT_TSI_CODE,
   64|       |  /// grpc_security_status associated with the error
   65|       |  GRPC_ERROR_INT_SECURITY_STATUS,
   66|       |  /// WSAGetLastError() reported when this error occurred
   67|       |  GRPC_ERROR_INT_WSA_ERROR,
   68|       |  /// File descriptor associated with this error
   69|       |  GRPC_ERROR_INT_FD,
   70|       |  /// HTTP status (i.e. 404)
   71|       |  GRPC_ERROR_INT_HTTP_STATUS,
   72|       |  /// context sensitive limit associated with the error
   73|       |  GRPC_ERROR_INT_LIMIT,
   74|       |  /// chttp2: did the error occur while a write was in progress
   75|       |  GRPC_ERROR_INT_OCCURRED_DURING_WRITE,
   76|       |
   77|       |  /// Must always be last
   78|       |  GRPC_ERROR_INT_MAX,
   79|       |} grpc_error_ints;
   80|       |
   81|       |typedef enum {
   82|       |  /// top-level textual description of this error
   83|       |  GRPC_ERROR_STR_DESCRIPTION,
   84|       |  /// source file in which this error occurred
   85|       |  GRPC_ERROR_STR_FILE,
   86|       |  /// operating system description of this error
   87|       |  GRPC_ERROR_STR_OS_ERROR,
   88|       |  /// syscall that generated this error
   89|       |  GRPC_ERROR_STR_SYSCALL,
   90|       |  /// peer that we were trying to communicate when this error occurred
   91|       |  GRPC_ERROR_STR_TARGET_ADDRESS,
   92|       |  /// grpc status message associated with this error
   93|       |  GRPC_ERROR_STR_GRPC_MESSAGE,
   94|       |  /// hex dump (or similar) with the data that generated this error
   95|       |  GRPC_ERROR_STR_RAW_BYTES,
   96|       |  /// tsi error string associated with this error
   97|       |  GRPC_ERROR_STR_TSI_ERROR,
   98|       |  /// filename that we were trying to read/write when this error occurred
   99|       |  GRPC_ERROR_STR_FILENAME,
  100|       |  /// which data was queued for writing when the error occurred
  101|       |  GRPC_ERROR_STR_QUEUED_BUFFERS,
  102|       |  /// key associated with the error
  103|       |  GRPC_ERROR_STR_KEY,
  104|       |  /// value associated with the error
  105|       |  GRPC_ERROR_STR_VALUE,
  106|       |
  107|       |  /// Must always be last
  108|       |  GRPC_ERROR_STR_MAX,
  109|       |} grpc_error_strs;
  110|       |
  111|       |typedef enum {
  112|       |  /// timestamp of error creation
  113|       |  GRPC_ERROR_TIME_CREATED,
  114|       |
  115|       |  /// Must always be last
  116|       |  GRPC_ERROR_TIME_MAX,
  117|       |} grpc_error_times;
  118|       |
  119|       |/// The following "special" errors can be propagated without allocating memory.
  120|       |/// They are always even so that other code (particularly combiner locks,
  121|       |/// polling engines) can safely use the lower bit for themselves.
  122|       |
  123|      0|#define GRPC_ERROR_NONE ((grpc_error*)NULL)
  124|       |#define GRPC_ERROR_RESERVED_1 ((grpc_error*)1)
  125|       |#define GRPC_ERROR_OOM ((grpc_error*)2)
  126|       |#define GRPC_ERROR_RESERVED_2 ((grpc_error*)3)
  127|       |#define GRPC_ERROR_CANCELLED ((grpc_error*)4)
  128|       |#define GRPC_ERROR_SPECIAL_MAX GRPC_ERROR_CANCELLED
  129|       |
  130|       |inline bool grpc_error_is_special(struct grpc_error* err) {
  131|       |  return err <= GRPC_ERROR_SPECIAL_MAX;
  132|       |}
  133|       |
  134|       |// debug only toggles that allow for a sanity to check that ensures we will
  135|       |// never create any errors in the per-RPC hotpath.
  136|       |void grpc_disable_error_creation();
  137|       |void grpc_enable_error_creation();
  138|       |
  139|       |const char* grpc_error_string(grpc_error* error);
  140|       |
  141|       |/// Create an error - but use GRPC_ERROR_CREATE instead
  142|       |grpc_error* grpc_error_create(const char* file, int line,
  143|       |                              const grpc_slice& desc, grpc_error** referencing,
  144|       |                              size_t num_referencing);
  145|       |/// Create an error (this is the preferred way of generating an error that is
  146|       |///   not due to a system call - for system calls, use GRPC_OS_ERROR or
  147|       |///   GRPC_WSA_ERROR as appropriate)
  148|       |/// \a referencing is an array of num_referencing elements indicating one or
  149|       |/// more errors that are believed to have contributed to this one
  150|       |/// err = grpc_error_create(x, y, z, r, nr) is equivalent to:
  151|       |///   err = grpc_error_create(x, y, z, NULL, 0);
  152|       |///   for (i=0; i<nr; i++) err = grpc_error_add_child(err, r[i]);
  153|       |#define GRPC_ERROR_CREATE_FROM_STATIC_STRING(desc)                           \
  154|       |  grpc_error_create(__FILE__, __LINE__, grpc_slice_from_static_string(desc), \
  155|       |                    NULL, 0)
  156|       |#define GRPC_ERROR_CREATE_FROM_COPIED_STRING(desc)                           \
  157|       |  grpc_error_create(__FILE__, __LINE__, grpc_slice_from_copied_string(desc), \
  158|       |                    NULL, 0)
  159|       |
  160|       |// Create an error that references some other errors. This function adds a
  161|       |// reference to each error in errs - it does not consume an existing reference
  162|       |#define GRPC_ERROR_CREATE_REFERENCING_FROM_STATIC_STRING(desc, errs, count)  \
  163|       |  grpc_error_create(__FILE__, __LINE__, grpc_slice_from_static_string(desc), \
  164|       |                    errs, count)
  165|       |#define GRPC_ERROR_CREATE_REFERENCING_FROM_COPIED_STRING(desc, errs, count)  \
  166|       |  grpc_error_create(__FILE__, __LINE__, grpc_slice_from_copied_string(desc), \
  167|       |                    errs, count)
  168|       |
  169|       |#define GRPC_ERROR_CREATE_FROM_VECTOR(desc, error_list) \
  170|       |  grpc_error_create_from_vector(__FILE__, __LINE__, desc, error_list)
  171|       |
  172|       |#ifndef NDEBUG
  173|       |grpc_error* grpc_error_do_ref(grpc_error* err, const char* file, int line);
  174|       |void grpc_error_do_unref(grpc_error* err, const char* file, int line);
  175|       |inline grpc_error* grpc_error_ref(grpc_error* err, const char* file, int line) {
  176|       |  if (grpc_error_is_special(err)) return err;
  177|       |  return grpc_error_do_ref(err, file, line);
  178|       |}
  179|       |inline void grpc_error_unref(grpc_error* err, const char* file, int line) {
  180|       |  if (grpc_error_is_special(err)) return;
  181|       |  grpc_error_do_unref(err, file, line);
  182|       |}
  183|       |#define GRPC_ERROR_REF(err) grpc_error_ref(err, __FILE__, __LINE__)
  184|       |#define GRPC_ERROR_UNREF(err) grpc_error_unref(err, __FILE__, __LINE__)
  185|       |#else
  186|       |grpc_error* grpc_error_do_ref(grpc_error* err);
  187|       |void grpc_error_do_unref(grpc_error* err);
  188|       |inline grpc_error* grpc_error_ref(grpc_error* err) {
  189|       |  if (grpc_error_is_special(err)) return err;
  190|       |  return grpc_error_do_ref(err);
  191|       |}
  192|       |inline void grpc_error_unref(grpc_error* err) {
  193|       |  if (grpc_error_is_special(err)) return;
  194|       |  grpc_error_do_unref(err);
  195|       |}
  196|       |#define GRPC_ERROR_REF(err) grpc_error_ref(err)
  197|       |#define GRPC_ERROR_UNREF(err) grpc_error_unref(err)
  198|       |#endif
  199|       |
  200|       |// Consumes all the errors in the vector and forms a referencing error from
  201|       |// them. If the vector is empty, return GRPC_ERROR_NONE.
  202|       |template <size_t N>
  203|       |static grpc_error* grpc_error_create_from_vector(
  204|       |    const char* file, int line, const char* desc,
  205|       |    grpc_core::InlinedVector<grpc_error*, N>* error_list) {
  206|       |  grpc_error* error = GRPC_ERROR_NONE;
  207|       |  if (error_list->size() != 0) {
  208|       |    error = grpc_error_create(file, line, grpc_slice_from_static_string(desc),
  209|       |                              error_list->data(), error_list->size());
  210|       |    // Remove refs to all errors in error_list.
  211|       |    for (size_t i = 0; i < error_list->size(); i++) {
  212|       |      GRPC_ERROR_UNREF((*error_list)[i]);
  213|       |    }
  214|       |    error_list->clear();
  215|       |  }
  216|       |  return error;
  217|       |}
  218|       |
  219|       |grpc_error* grpc_error_set_int(grpc_error* src, grpc_error_ints which,
  220|       |                               intptr_t value) GRPC_MUST_USE_RESULT;
  221|       |/// It is an error to pass nullptr as `p`. Caller should allocate a dummy
  222|       |/// intptr_t for `p`, even if the value of `p` is not used.
  223|       |bool grpc_error_get_int(grpc_error* error, grpc_error_ints which, intptr_t* p);
  224|       |/// This call takes ownership of the slice; the error is responsible for
  225|       |/// eventually unref-ing it.
  226|       |grpc_error* grpc_error_set_str(grpc_error* src, grpc_error_strs which,
  227|       |                               const grpc_slice& str) GRPC_MUST_USE_RESULT;
  228|       |/// Returns false if the specified string is not set.
  229|       |/// Caller does NOT own the slice.
  230|       |bool grpc_error_get_str(grpc_error* error, grpc_error_strs which,
  231|       |                        grpc_slice* s);
  232|       |
  233|       |/// Add a child error: an error that is believed to have contributed to this
  234|       |/// error occurring. Allows root causing high level errors from lower level
  235|       |/// errors that contributed to them. The src error takes ownership of the
  236|       |/// child error.
  237|       |///
  238|       |/// Edge Conditions -
  239|       |/// 1) If either of \a src or \a child is GRPC_ERROR_NONE, returns a reference
  240|       |/// to the other argument. 2) If both \a src and \a child are GRPC_ERROR_NONE,
  241|       |/// returns GRPC_ERROR_NONE. 3) If \a src and \a child point to the same error,
  242|       |/// returns a single reference. (Note that, 2 references should have been
  243|       |/// received to the error in this case.)
  244|       |grpc_error* grpc_error_add_child(grpc_error* src,
  245|       |                                 grpc_error* child) GRPC_MUST_USE_RESULT;
  246|       |
  247|       |grpc_error* grpc_os_error(const char* file, int line, int err,
  248|       |                          const char* call_name) GRPC_MUST_USE_RESULT;
  249|       |
  250|       |inline grpc_error* grpc_assert_never_ok(grpc_error* error) {
  251|       |  GPR_ASSERT(error != GRPC_ERROR_NONE);
  252|       |  return error;
  253|       |}
  254|       |
  255|       |/// create an error associated with errno!=0 (an 'operating system' error)
  256|       |#define GRPC_OS_ERROR(err, call_name) \
  257|       |  grpc_assert_never_ok(grpc_os_error(__FILE__, __LINE__, err, call_name))
  258|       |grpc_error* grpc_wsa_error(const char* file, int line, int err,
  259|       |                           const char* call_name) GRPC_MUST_USE_RESULT;
  260|       |/// windows only: create an error associated with WSAGetLastError()!=0
  261|       |#define GRPC_WSA_ERROR(err, call_name) \
  262|       |  grpc_wsa_error(__FILE__, __LINE__, err, call_name)
  263|       |
  264|       |bool grpc_log_if_error(const char* what, grpc_error* error, const char* file,
  265|       |                       int line);
  266|       |#define GRPC_LOG_IF_ERROR(what, error) \
  267|      0|  grpc_log_if_error((what), (error), __FILE__, __LINE__)
  268|       |
  269|       |#endif /* GRPC_CORE_LIB_IOMGR_ERROR_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/iomgr/exec_ctx.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_IOMGR_EXEC_CTX_H
   20|       |#define GRPC_CORE_LIB_IOMGR_EXEC_CTX_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/impl/codegen/grpc_types.h>
   25|       |#include <grpc/support/atm.h>
   26|       |#include <grpc/support/cpu.h>
   27|       |#include <grpc/support/log.h>
   28|       |
   29|       |#include "src/core/lib/gpr/tls.h"
   30|       |#include "src/core/lib/gprpp/fork.h"
   31|       |#include "src/core/lib/iomgr/closure.h"
   32|       |
   33|       |typedef int64_t grpc_millis;
   34|       |
   35|       |#define GRPC_MILLIS_INF_FUTURE INT64_MAX
   36|       |#define GRPC_MILLIS_INF_PAST INT64_MIN
   37|       |
   38|       |/** A combiner represents a list of work to be executed later.
   39|       |    Forward declared here to avoid a circular dependency with combiner.h. */
   40|       |typedef struct grpc_combiner grpc_combiner;
   41|       |
   42|       |/* This exec_ctx is ready to return: either pre-populated, or cached as soon as
   43|       |   the finish_check returns true */
   44|      0|#define GRPC_EXEC_CTX_FLAG_IS_FINISHED 1
   45|       |/* The exec_ctx's thread is (potentially) owned by a call or channel: care
   46|       |   should be given to not delete said call/channel from this exec_ctx */
   47|       |#define GRPC_EXEC_CTX_FLAG_THREAD_RESOURCE_LOOP 2
   48|       |/* This exec ctx was initialized by an internal thread, and should not
   49|       |   be counted by fork handlers */
   50|      0|#define GRPC_EXEC_CTX_FLAG_IS_INTERNAL_THREAD 4
   51|       |
   52|       |/* This application callback exec ctx was initialized by an internal thread, and
   53|       |   should not be counted by fork handlers */
   54|      0|#define GRPC_APP_CALLBACK_EXEC_CTX_FLAG_IS_INTERNAL_THREAD 1
   55|       |
   56|       |extern grpc_closure_scheduler* grpc_schedule_on_exec_ctx;
   57|       |
   58|       |gpr_timespec grpc_millis_to_timespec(grpc_millis millis, gpr_clock_type clock);
   59|       |grpc_millis grpc_timespec_to_millis_round_down(gpr_timespec timespec);
   60|       |grpc_millis grpc_timespec_to_millis_round_up(gpr_timespec timespec);
   61|       |
   62|       |namespace grpc_core {
   63|       |/** Execution context.
   64|       | *  A bag of data that collects information along a callstack.
   65|       | *  It is created on the stack at core entry points (public API or iomgr), and
   66|       | *  stored internally as a thread-local variable.
   67|       | *
   68|       | *  Generally, to create an exec_ctx instance, add the following line at the top
   69|       | *  of the public API entry point or at the start of a thread's work function :
   70|       | *
   71|       | *  grpc_core::ExecCtx exec_ctx;
   72|       | *
   73|       | *  Access the created ExecCtx instance using :
   74|       | *  grpc_core::ExecCtx::Get()
   75|       | *
   76|       | *  Specific responsibilities (this may grow in the future):
   77|       | *  - track a list of core work that needs to be delayed until the base of the
   78|       | *    call stack (this provides a convenient mechanism to run callbacks
   79|       | *    without worrying about locking issues)
   80|       | *  - provide a decision maker (via IsReadyToFinish) that provides a
   81|       | *    signal as to whether a borrowed thread should continue to do work or
   82|       | *    should actively try to finish up and get this thread back to its owner
   83|       | *
   84|       | *  CONVENTIONS:
   85|       | *  - Instance of this must ALWAYS be constructed on the stack, never
   86|       | *    heap allocated.
   87|       | *  - Do not pass exec_ctx as a parameter to a function. Always access it using
   88|       | *    grpc_core::ExecCtx::Get().
   89|       | *  - NOTE: In the future, the convention is likely to change to allow only one
   90|       | *          ExecCtx on a thread's stack at the same time. The TODO below
   91|       | *          discusses this plan in more detail.
   92|       | *
   93|       | * TODO(yashykt): Only allow one "active" ExecCtx on a thread at the same time.
   94|       | *                Stage 1: If a new one is created on the stack, it should just
   95|       | *                pass-through to the underlying ExecCtx deeper in the thread's
   96|       | *                stack.
   97|       | *                Stage 2: Assert if a 2nd one is ever created on the stack
   98|       | *                since that implies a core re-entry outside of application
   99|       | *                callbacks.
  100|       | */
  101|       |class ExecCtx {
  102|       | public:
  103|       |  /** Default Constructor */
  104|       |
  105|      0|  ExecCtx() : flags_(GRPC_EXEC_CTX_FLAG_IS_FINISHED) {
  106|      0|    grpc_core::Fork::IncExecCtxCount();
  107|      0|    Set(this);
  108|      0|  }
  109|       |
  110|       |  /** Parameterised Constructor */
  111|       |  ExecCtx(uintptr_t fl) : flags_(fl) {
  112|       |    if (!(GRPC_EXEC_CTX_FLAG_IS_INTERNAL_THREAD & flags_)) {
  113|       |      grpc_core::Fork::IncExecCtxCount();
  114|       |    }
  115|       |    Set(this);
  116|       |  }
  117|       |
  118|       |  /** Destructor */
  119|      0|  virtual ~ExecCtx() {
  120|      0|    flags_ |= GRPC_EXEC_CTX_FLAG_IS_FINISHED;
  121|      0|    Flush();
  122|      0|    Set(last_exec_ctx_);
  123|      0|    if (!(GRPC_EXEC_CTX_FLAG_IS_INTERNAL_THREAD & flags_)) {
  124|      0|      grpc_core::Fork::DecExecCtxCount();
  125|      0|    }
  126|      0|  }
  127|       |
  128|       |  /** Disallow copy and assignment operators */
  129|       |  ExecCtx(const ExecCtx&) = delete;
  130|       |  ExecCtx& operator=(const ExecCtx&) = delete;
  131|       |
  132|       |  unsigned starting_cpu() const { return starting_cpu_; }
  133|       |
  134|       |  struct CombinerData {
  135|       |    /* currently active combiner: updated only via combiner.c */
  136|       |    grpc_combiner* active_combiner;
  137|       |    /* last active combiner in the active combiner list */
  138|       |    grpc_combiner* last_combiner;
  139|       |  };
  140|       |
  141|       |  /** Only to be used by grpc-combiner code */
  142|       |  CombinerData* combiner_data() { return &combiner_data_; }
  143|       |
  144|       |  /** Return pointer to grpc_closure_list */
  145|       |  grpc_closure_list* closure_list() { return &closure_list_; }
  146|       |
  147|       |  /** Return flags */
  148|       |  uintptr_t flags() { return flags_; }
  149|       |
  150|       |  /** Checks if there is work to be done */
  151|       |  bool HasWork() {
  152|       |    return combiner_data_.active_combiner != nullptr ||
  153|       |           !grpc_closure_list_empty(closure_list_);
  154|       |  }
  155|       |
  156|       |  /** Flush any work that has been enqueued onto this grpc_exec_ctx.
  157|       |   *  Caller must guarantee that no interfering locks are held.
  158|       |   *  Returns true if work was performed, false otherwise.
  159|       |   */
  160|       |  bool Flush();
  161|       |
  162|       |  /** Returns true if we'd like to leave this execution context as soon as
  163|       |   *  possible: useful for deciding whether to do something more or not
  164|       |   *  depending on outside context.
  165|       |   */
  166|       |  bool IsReadyToFinish() {
  167|       |    if ((flags_ & GRPC_EXEC_CTX_FLAG_IS_FINISHED) == 0) {
  168|       |      if (CheckReadyToFinish()) {
  169|       |        flags_ |= GRPC_EXEC_CTX_FLAG_IS_FINISHED;
  170|       |        return true;
  171|       |      }
  172|       |      return false;
  173|       |    } else {
  174|       |      return true;
  175|       |    }
  176|       |  }
  177|       |
  178|       |  /** Returns the stored current time relative to start if valid,
  179|       |   *  otherwise refreshes the stored time, sets it valid and returns the new
  180|       |   *  value.
  181|       |   */
  182|       |  grpc_millis Now();
  183|       |
  184|       |  /** Invalidates the stored time value. A new time value will be set on calling
  185|       |   *  Now().
  186|       |   */
  187|      0|  void InvalidateNow() { now_is_valid_ = false; }
  188|       |
  189|       |  /** To be used only by shutdown code in iomgr */
  190|      0|  void SetNowIomgrShutdown() {
  191|      0|    now_ = GRPC_MILLIS_INF_FUTURE;
  192|      0|    now_is_valid_ = true;
  193|      0|  }
  194|       |
  195|       |  /** To be used only for testing.
  196|       |   *  Sets the now value.
  197|       |   */
  198|      0|  void TestOnlySetNow(grpc_millis new_val) {
  199|      0|    now_ = new_val;
  200|      0|    now_is_valid_ = true;
  201|      0|  }
  202|       |
  203|       |  static void TestOnlyGlobalInit(gpr_timespec new_val);
  204|       |
  205|       |  /** Global initialization for ExecCtx. Called by iomgr. */
  206|       |  static void GlobalInit(void);
  207|       |
  208|       |  /** Global shutdown for ExecCtx. Called by iomgr. */
  209|      0|  static void GlobalShutdown(void) { gpr_tls_destroy(&exec_ctx_); }
  210|       |
  211|       |  /** Gets pointer to current exec_ctx. */
  212|      0|  static ExecCtx* Get() {
  213|      0|    return reinterpret_cast<ExecCtx*>(gpr_tls_get(&exec_ctx_));
  214|      0|  }
  215|       |
  216|      0|  static void Set(ExecCtx* exec_ctx) {
  217|      0|    gpr_tls_set(&exec_ctx_, reinterpret_cast<intptr_t>(exec_ctx));
  218|      0|  }
  219|       |
  220|       | protected:
  221|       |  /** Check if ready to finish. */
  222|      0|  virtual bool CheckReadyToFinish() { return false; }
  223|       |
  224|       |  /** Disallow delete on ExecCtx. */
  225|      0|  static void operator delete(void* p) { abort(); }
  226|       |
  227|       | private:
  228|       |  /** Set exec_ctx_ to exec_ctx. */
  229|       |
  230|       |  grpc_closure_list closure_list_ = GRPC_CLOSURE_LIST_INIT;
  231|       |  CombinerData combiner_data_ = {nullptr, nullptr};
  232|       |  uintptr_t flags_;
  233|       |
  234|       |  unsigned starting_cpu_ = gpr_cpu_current_cpu();
  235|       |
  236|       |  bool now_is_valid_ = false;
  237|       |  grpc_millis now_ = 0;
  238|       |
  239|       |  GPR_TLS_CLASS_DECL(exec_ctx_);
  240|       |  ExecCtx* last_exec_ctx_ = Get();
  241|       |};
  242|       |
  243|       |/** Application-callback execution context.
  244|       | *  A bag of data that collects information along a callstack.
  245|       | *  It is created on the stack at core entry points, and stored internally
  246|       | *  as a thread-local variable.
  247|       | *
  248|       | *  There are three key differences between this structure and ExecCtx:
  249|       | *    1. ApplicationCallbackExecCtx builds a list of application-level
  250|       | *       callbacks, but ExecCtx builds a list of internal callbacks to invoke.
  251|       | *    2. ApplicationCallbackExecCtx invokes its callbacks only at destruction;
  252|       | *       there is no explicit Flush method.
  253|       | *    3. If more than one ApplicationCallbackExecCtx is created on the thread's
  254|       | *       stack, only the one closest to the base of the stack is actually
  255|       | *       active and this is the only one that enqueues application callbacks.
  256|       | *       (Unlike ExecCtx, it is not feasible to prevent multiple of these on the
  257|       | *       stack since the executing application callback may itself enter core.
  258|       | *       However, the new one created will just pass callbacks through to the
  259|       | *       base one and those will not be executed until the return to the
  260|       | *       destructor of the base one, preventing unlimited stack growth.)
  261|       | *
  262|       | *  This structure exists because application callbacks may themselves cause a
  263|       | *  core re-entry (e.g., through a public API call) and if that call in turn
  264|       | *  causes another application-callback, there could be arbitrarily growing
  265|       | *  stacks of core re-entries. Instead, any application callbacks instead should
  266|       | *  not be invoked until other core work is done and other application callbacks
  267|       | *  have completed. To accomplish this, any application callback should be
  268|       | *  enqueued using grpc_core::ApplicationCallbackExecCtx::Enqueue .
  269|       | *
  270|       | *  CONVENTIONS:
  271|       | *  - Instances of this must ALWAYS be constructed on the stack, never
  272|       | *    heap allocated.
  273|       | *  - Instances of this are generally constructed before ExecCtx when needed.
  274|       | *    The only exception is for ExecCtx's that are explicitly flushed and
  275|       | *    that survive beyond the scope of the function that can cause application
  276|       | *    callbacks to be invoked (e.g., in the timer thread).
  277|       | *
  278|       | *  Generally, core entry points that may trigger application-level callbacks
  279|       | *  will have the following declarations:
  280|       | *
  281|       | *  grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
  282|       | *  grpc_core::ExecCtx exec_ctx;
  283|       | *
  284|       | *  This ordering is important to make sure that the ApplicationCallbackExecCtx
  285|       | *  is destroyed after the ExecCtx (to prevent the re-entry problem described
  286|       | *  above, as well as making sure that ExecCtx core callbacks are invoked first)
  287|       | *
  288|       | */
  289|       |
  290|       |class ApplicationCallbackExecCtx {
  291|       | public:
  292|       |  /** Default Constructor */
  293|      0|  ApplicationCallbackExecCtx() { Set(this, flags_); }
  294|       |
  295|       |  /** Parameterised Constructor */
  296|      0|  ApplicationCallbackExecCtx(uintptr_t fl) : flags_(fl) { Set(this, flags_); }
  297|       |
  298|      0|  ~ApplicationCallbackExecCtx() {
  299|      0|    if (reinterpret_cast<ApplicationCallbackExecCtx*>(
  300|      0|            gpr_tls_get(&callback_exec_ctx_)) == this) {
  301|      0|      while (head_ != nullptr) {
  302|      0|        auto* f = head_;
  303|      0|        head_ = f->internal_next;
  304|      0|        if (f->internal_next == nullptr) {
  305|      0|          tail_ = nullptr;
  306|      0|        }
  307|      0|        (*f->functor_run)(f, f->internal_success);
  308|      0|      }
  309|      0|      gpr_tls_set(&callback_exec_ctx_, reinterpret_cast<intptr_t>(nullptr));
  310|      0|      if (!(GRPC_APP_CALLBACK_EXEC_CTX_FLAG_IS_INTERNAL_THREAD & flags_)) {
  311|      0|        grpc_core::Fork::DecExecCtxCount();
  312|      0|      }
  313|      0|    } else {
  314|      0|      GPR_DEBUG_ASSERT(head_ == nullptr);
  315|      0|      GPR_DEBUG_ASSERT(tail_ == nullptr);
  316|      0|    }
  317|      0|  }
  318|       |
  319|      0|  static void Set(ApplicationCallbackExecCtx* exec_ctx, uintptr_t flags) {
  320|      0|    if (reinterpret_cast<ApplicationCallbackExecCtx*>(
  321|      0|            gpr_tls_get(&callback_exec_ctx_)) == nullptr) {
  322|      0|      if (!(GRPC_APP_CALLBACK_EXEC_CTX_FLAG_IS_INTERNAL_THREAD & flags)) {
  323|      0|        grpc_core::Fork::IncExecCtxCount();
  324|      0|      }
  325|      0|      gpr_tls_set(&callback_exec_ctx_, reinterpret_cast<intptr_t>(exec_ctx));
  326|      0|    }
  327|      0|  }
  328|       |
  329|       |  static void Enqueue(grpc_experimental_completion_queue_functor* functor,
  330|       |                      int is_success) {
  331|       |    functor->internal_success = is_success;
  332|       |    functor->internal_next = nullptr;
  333|       |
  334|       |    auto* ctx = reinterpret_cast<ApplicationCallbackExecCtx*>(
  335|       |        gpr_tls_get(&callback_exec_ctx_));
  336|       |
  337|       |    if (ctx->head_ == nullptr) {
  338|       |      ctx->head_ = functor;
  339|       |    }
  340|       |    if (ctx->tail_ != nullptr) {
  341|       |      ctx->tail_->internal_next = functor;
  342|       |    }
  343|       |    ctx->tail_ = functor;
  344|       |  }
  345|       |
  346|       |  /** Global initialization for ApplicationCallbackExecCtx. Called by init. */
  347|       |  static void GlobalInit(void) { gpr_tls_init(&callback_exec_ctx_); }
  348|       |
  349|       |  /** Global shutdown for ApplicationCallbackExecCtx. Called by init. */
  350|      0|  static void GlobalShutdown(void) { gpr_tls_destroy(&callback_exec_ctx_); }
  351|       |
  352|       | private:
  353|       |  uintptr_t flags_{0u};
  354|       |  grpc_experimental_completion_queue_functor* head_{nullptr};
  355|       |  grpc_experimental_completion_queue_functor* tail_{nullptr};
  356|       |  GPR_TLS_CLASS_DECL(callback_exec_ctx_);
  357|       |};
  358|       |}  // namespace grpc_core
  359|       |
  360|       |#endif /* GRPC_CORE_LIB_IOMGR_EXEC_CTX_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/profiling/timers.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_PROFILING_TIMERS_H
   20|       |#define GRPC_CORE_LIB_PROFILING_TIMERS_H
   21|       |
   22|       |void gpr_timers_global_init(void);
   23|       |void gpr_timers_global_destroy(void);
   24|       |
   25|       |void gpr_timer_add_mark(const char* tagstr, int important, const char* file,
   26|       |                        int line);
   27|       |void gpr_timer_begin(const char* tagstr, int important, const char* file,
   28|       |                     int line);
   29|       |void gpr_timer_end(const char* tagstr, int important, const char* file,
   30|       |                   int line);
   31|       |
   32|       |void gpr_timers_set_log_filename(const char* filename);
   33|       |
   34|       |void gpr_timer_set_enabled(int enabled);
   35|       |
   36|       |#if !(defined(GRPC_STAP_PROFILER) + defined(GRPC_BASIC_PROFILER) + \
   37|       |      defined(GRPC_CUSTOM_PROFILER))
   38|       |/* No profiling. No-op all the things. */
   39|       |#define GPR_TIMER_MARK(tag, important) \
   40|       |  do {                                 \
   41|       |  } while (0)
   42|       |
   43|       |#define GPR_TIMER_SCOPE(tag, important) \
   44|      0|  do {                                  \
   45|      0|  } while (0)
   46|       |
   47|       |#else /* at least one profiler requested... */
   48|       |/* ... hopefully only one. */
   49|       |#if defined(GRPC_STAP_PROFILER) && defined(GRPC_BASIC_PROFILER)
   50|       |#error "GRPC_STAP_PROFILER and GRPC_BASIC_PROFILER are mutually exclusive."
   51|       |#endif
   52|       |#if defined(GRPC_STAP_PROFILER) && defined(GRPC_CUSTOM_PROFILER)
   53|       |#error "GRPC_STAP_PROFILER and GRPC_CUSTOM_PROFILER are mutually exclusive."
   54|       |#endif
   55|       |#if defined(GRPC_CUSTOM_PROFILER) && defined(GRPC_BASIC_PROFILER)
   56|       |#error "GRPC_CUSTOM_PROFILER and GRPC_BASIC_PROFILER are mutually exclusive."
   57|       |#endif
   58|       |
   59|       |/* Generic profiling interface. */
   60|       |#define GPR_TIMER_MARK(tag, important) \
   61|       |  gpr_timer_add_mark(tag, important, __FILE__, __LINE__);
   62|       |
   63|       |#ifdef GRPC_STAP_PROFILER
   64|       |/* Empty placeholder for now. */
   65|       |#endif /* GRPC_STAP_PROFILER */
   66|       |
   67|       |#ifdef GRPC_BASIC_PROFILER
   68|       |/* Empty placeholder for now. */
   69|       |#endif /* GRPC_BASIC_PROFILER */
   70|       |
   71|       |namespace grpc {
   72|       |class ProfileScope {
   73|       | public:
   74|       |  ProfileScope(const char* desc, bool important, const char* file, int line)
   75|       |      : desc_(desc) {
   76|       |    gpr_timer_begin(desc_, important ? 1 : 0, file, line);
   77|       |  }
   78|       |  ~ProfileScope() { gpr_timer_end(desc_, 0, "n/a", 0); }
   79|       |
   80|       | private:
   81|       |  const char* const desc_;
   82|       |};
   83|       |}  // namespace grpc
   84|       |
   85|       |#define GPR_TIMER_SCOPE_NAME_INTERNAL(prefix, line) prefix##line
   86|       |#define GPR_TIMER_SCOPE_NAME(prefix, line) \
   87|       |  GPR_TIMER_SCOPE_NAME_INTERNAL(prefix, line)
   88|       |#define GPR_TIMER_SCOPE(tag, important)                                 \
   89|       |  ::grpc::ProfileScope GPR_TIMER_SCOPE_NAME(_profile_scope_, __LINE__)( \
   90|       |      (tag), (important), __FILE__, __LINE__)
   91|       |
   92|       |#endif /* at least one profiler requested. */
   93|       |
   94|       |#endif /* GRPC_CORE_LIB_PROFILING_TIMERS_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/security/context/security_context.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_SECURITY_CONTEXT_SECURITY_CONTEXT_H
   20|       |#define GRPC_CORE_LIB_SECURITY_CONTEXT_SECURITY_CONTEXT_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include "src/core/lib/gprpp/arena.h"
   25|       |#include "src/core/lib/gprpp/ref_counted.h"
   26|       |#include "src/core/lib/gprpp/ref_counted_ptr.h"
   27|       |#include "src/core/lib/iomgr/pollset.h"
   28|       |#include "src/core/lib/security/credentials/credentials.h"
   29|       |
   30|       |extern grpc_core::DebugOnlyTraceFlag grpc_trace_auth_context_refcount;
   31|       |
   32|       |/* --- grpc_auth_context ---
   33|       |
   34|       |   High level authentication context object. Can optionally be chained. */
   35|       |
   36|       |/* Property names are always NULL terminated. */
   37|       |
   38|       |struct grpc_auth_property_array {
   39|       |  grpc_auth_property* array = nullptr;
   40|       |  size_t count = 0;
   41|       |  size_t capacity = 0;
   42|       |};
   43|       |
   44|       |void grpc_auth_property_reset(grpc_auth_property* property);
   45|       |
   46|       |// This type is forward declared as a C struct and we cannot define it as a
   47|       |// class. Otherwise, compiler will complain about type mismatch due to
   48|       |// -Wmismatched-tags.
   49|       |struct grpc_auth_context
   50|       |    : public grpc_core::RefCounted<grpc_auth_context,
   51|       |                                   grpc_core::NonPolymorphicRefCount> {
   52|       | public:
   53|       |  explicit grpc_auth_context(
   54|       |      grpc_core::RefCountedPtr<grpc_auth_context> chained)
   55|       |      : grpc_core::RefCounted<grpc_auth_context,
   56|       |                              grpc_core::NonPolymorphicRefCount>(
   57|       |            &grpc_trace_auth_context_refcount),
   58|       |        chained_(std::move(chained)) {
   59|       |    if (chained_ != nullptr) {
   60|       |      peer_identity_property_name_ = chained_->peer_identity_property_name_;
   61|       |    }
   62|       |  }
   63|       |
   64|      0|  ~grpc_auth_context() {
   65|      0|    chained_.reset(DEBUG_LOCATION, "chained");
   66|      0|    if (properties_.array != nullptr) {
   67|      0|      for (size_t i = 0; i < properties_.count; i++) {
   68|      0|        grpc_auth_property_reset(&properties_.array[i]);
   69|      0|      }
   70|      0|      gpr_free(properties_.array);
   71|      0|    }
   72|      0|  }
   73|       |
   74|       |  const grpc_auth_context* chained() const { return chained_.get(); }
   75|       |  const grpc_auth_property_array& properties() const { return properties_; }
   76|       |
   77|       |  bool is_authenticated() const {
   78|       |    return peer_identity_property_name_ != nullptr;
   79|       |  }
   80|       |  const char* peer_identity_property_name() const {
   81|       |    return peer_identity_property_name_;
   82|       |  }
   83|      0|  void set_peer_identity_property_name(const char* name) {
   84|      0|    peer_identity_property_name_ = name;
   85|      0|  }
   86|       |
   87|       |  void ensure_capacity();
   88|       |  void add_property(const char* name, const char* value, size_t value_length);
   89|       |  void add_cstring_property(const char* name, const char* value);
   90|       |
   91|       | private:
   92|       |  grpc_core::RefCountedPtr<grpc_auth_context> chained_;
   93|       |  grpc_auth_property_array properties_;
   94|       |  const char* peer_identity_property_name_ = nullptr;
   95|       |};
   96|       |
   97|       |/* --- grpc_security_context_extension ---
   98|       |
   99|       |   Extension to the security context that may be set in a filter and accessed
  100|       |   later by a higher level method on a grpc_call object. */
  101|       |
  102|       |struct grpc_security_context_extension {
  103|       |  void* instance = nullptr;
  104|       |  void (*destroy)(void*) = nullptr;
  105|       |};
  106|       |
  107|       |/* --- grpc_client_security_context ---
  108|       |
  109|       |   Internal client-side security context. */
  110|       |
  111|       |struct grpc_client_security_context {
  112|       |  explicit grpc_client_security_context(
  113|       |      grpc_core::RefCountedPtr<grpc_call_credentials> creds)
  114|      0|      : creds(std::move(creds)) {}
  115|       |  ~grpc_client_security_context();
  116|       |
  117|       |  grpc_core::RefCountedPtr<grpc_call_credentials> creds;
  118|       |  grpc_core::RefCountedPtr<grpc_auth_context> auth_context;
  119|       |  grpc_security_context_extension extension;
  120|       |};
  121|       |
  122|       |grpc_client_security_context* grpc_client_security_context_create(
  123|       |    grpc_core::Arena* arena, grpc_call_credentials* creds);
  124|       |void grpc_client_security_context_destroy(void* ctx);
  125|       |
  126|       |/* --- grpc_server_security_context ---
  127|       |
  128|       |   Internal server-side security context. */
  129|       |
  130|       |struct grpc_server_security_context {
  131|       |  grpc_server_security_context() = default;
  132|       |  ~grpc_server_security_context();
  133|       |
  134|       |  grpc_core::RefCountedPtr<grpc_auth_context> auth_context;
  135|       |  grpc_security_context_extension extension;
  136|       |};
  137|       |
  138|       |grpc_server_security_context* grpc_server_security_context_create(
  139|       |    grpc_core::Arena* arena);
  140|       |void grpc_server_security_context_destroy(void* ctx);
  141|       |
  142|       |/* --- Channel args for auth context --- */
  143|       |#define GRPC_AUTH_CONTEXT_ARG "grpc.auth_context"
  144|       |
  145|       |grpc_arg grpc_auth_context_to_arg(grpc_auth_context* c);
  146|       |grpc_auth_context* grpc_auth_context_from_arg(const grpc_arg* arg);
  147|       |grpc_auth_context* grpc_find_auth_context_in_args(
  148|       |    const grpc_channel_args* args);
  149|       |
  150|       |#endif /* GRPC_CORE_LIB_SECURITY_CONTEXT_SECURITY_CONTEXT_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/security/credentials/credentials.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_SECURITY_CREDENTIALS_CREDENTIALS_H
   20|       |#define GRPC_CORE_LIB_SECURITY_CREDENTIALS_CREDENTIALS_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/grpc.h>
   25|       |#include <grpc/grpc_security.h>
   26|       |#include <grpc/support/sync.h>
   27|       |#include "src/core/lib/transport/metadata_batch.h"
   28|       |
   29|       |#include "src/core/lib/gprpp/ref_counted.h"
   30|       |#include "src/core/lib/http/httpcli.h"
   31|       |#include "src/core/lib/http/parser.h"
   32|       |#include "src/core/lib/iomgr/polling_entity.h"
   33|       |#include "src/core/lib/security/security_connector/security_connector.h"
   34|       |
   35|       |struct grpc_http_response;
   36|       |
   37|       |/* --- Constants. --- */
   38|       |
   39|       |typedef enum {
   40|       |  GRPC_CREDENTIALS_OK = 0,
   41|       |  GRPC_CREDENTIALS_ERROR
   42|       |} grpc_credentials_status;
   43|       |
   44|       |#define GRPC_FAKE_TRANSPORT_SECURITY_TYPE "fake"
   45|       |
   46|       |#define GRPC_CHANNEL_CREDENTIALS_TYPE_SSL "Ssl"
   47|       |#define GRPC_CHANNEL_CREDENTIALS_TYPE_FAKE_TRANSPORT_SECURITY \
   48|       |  "FakeTransportSecurity"
   49|       |#define GRPC_CHANNEL_CREDENTIALS_TYPE_GOOGLE_DEFAULT "GoogleDefault"
   50|       |
   51|       |#define GRPC_CALL_CREDENTIALS_TYPE_OAUTH2 "Oauth2"
   52|       |#define GRPC_CALL_CREDENTIALS_TYPE_JWT "Jwt"
   53|       |#define GRPC_CALL_CREDENTIALS_TYPE_IAM "Iam"
   54|       |#define GRPC_CALL_CREDENTIALS_TYPE_COMPOSITE "Composite"
   55|       |
   56|       |#define GRPC_AUTHORIZATION_METADATA_KEY "authorization"
   57|       |#define GRPC_IAM_AUTHORIZATION_TOKEN_METADATA_KEY \
   58|       |  "x-goog-iam-authorization-token"
   59|       |#define GRPC_IAM_AUTHORITY_SELECTOR_METADATA_KEY "x-goog-iam-authority-selector"
   60|       |
   61|       |#define GRPC_SECURE_TOKEN_REFRESH_THRESHOLD_SECS 60
   62|       |
   63|       |#define GRPC_COMPUTE_ENGINE_METADATA_HOST "metadata.google.internal."
   64|       |#define GRPC_COMPUTE_ENGINE_METADATA_TOKEN_PATH \
   65|       |  "/computeMetadata/v1/instance/service-accounts/default/token"
   66|       |
   67|       |#define GRPC_GOOGLE_OAUTH2_SERVICE_HOST "www.googleapis.com"
   68|       |#define GRPC_GOOGLE_OAUTH2_SERVICE_TOKEN_PATH "/oauth2/v3/token"
   69|       |
   70|       |#define GRPC_SERVICE_ACCOUNT_POST_BODY_PREFIX                         \
   71|       |  "grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&" \
   72|       |  "assertion="
   73|       |
   74|       |#define GRPC_REFRESH_TOKEN_POST_BODY_FORMAT_STRING \
   75|       |  "client_id=%s&client_secret=%s&refresh_token=%s&grant_type=refresh_token"
   76|       |
   77|       |/* --- Google utils --- */
   78|       |
   79|       |/* It is the caller's responsibility to gpr_free the result if not NULL. */
   80|       |char* grpc_get_well_known_google_credentials_file_path(void);
   81|       |
   82|       |/* Implementation function for the different platforms. */
   83|       |char* grpc_get_well_known_google_credentials_file_path_impl(void);
   84|       |
   85|       |/* Override for testing only. Not thread-safe */
   86|       |typedef char* (*grpc_well_known_credentials_path_getter)(void);
   87|       |void grpc_override_well_known_credentials_path_getter(
   88|       |    grpc_well_known_credentials_path_getter getter);
   89|       |
   90|       |/* --- grpc_channel_credentials. --- */
   91|       |
   92|       |#define GRPC_ARG_CHANNEL_CREDENTIALS "grpc.channel_credentials"
   93|       |
   94|       |// This type is forward declared as a C struct and we cannot define it as a
   95|       |// class. Otherwise, compiler will complain about type mismatch due to
   96|       |// -Wmismatched-tags.
   97|       |struct grpc_channel_credentials
   98|       |    : grpc_core::RefCounted<grpc_channel_credentials> {
   99|       | public:
  100|      0|  explicit grpc_channel_credentials(const char* type) : type_(type) {}
  101|       |  virtual ~grpc_channel_credentials() = default;
  102|       |
  103|       |  // Creates a security connector for the channel. May also create new channel
  104|       |  // args for the channel to be used in place of the passed in const args if
  105|       |  // returned non NULL. In that case the caller is responsible for destroying
  106|       |  // new_args after channel creation.
  107|       |  virtual grpc_core::RefCountedPtr<grpc_channel_security_connector>
  108|       |  create_security_connector(
  109|       |      grpc_core::RefCountedPtr<grpc_call_credentials> call_creds,
  110|       |      const char* target, const grpc_channel_args* args,
  111|       |      grpc_channel_args** new_args) {
  112|       |    // Tell clang-tidy that call_creds cannot be passed as const-ref.
  113|       |    call_creds.reset();
  114|       |    GRPC_ABSTRACT;
  115|       |  }
  116|       |
  117|       |  // Creates a version of the channel credentials without any attached call
  118|       |  // credentials. This can be used in order to open a channel to a non-trusted
  119|       |  // gRPC load balancer.
  120|       |  virtual grpc_core::RefCountedPtr<grpc_channel_credentials>
  121|       |  duplicate_without_call_credentials() {
  122|       |    // By default we just increment the refcount.
  123|       |    return Ref();
  124|       |  }
  125|       |
  126|       |  // Allows credentials to optionally modify a parent channel's args.
  127|       |  // By default, leave channel args as is. The callee takes ownership
  128|       |  // of the passed-in channel args, and the caller takes ownership
  129|       |  // of the returned channel args.
  130|       |  virtual grpc_channel_args* update_arguments(grpc_channel_args* args) {
  131|       |    return args;
  132|       |  }
  133|       |
  134|       |  const char* type() const { return type_; }
  135|       |
  136|       |  GRPC_ABSTRACT_BASE_CLASS
  137|       |
  138|       | private:
  139|       |  const char* type_;
  140|       |};
  141|       |
  142|       |/* Util to encapsulate the channel credentials in a channel arg. */
  143|       |grpc_arg grpc_channel_credentials_to_arg(grpc_channel_credentials* credentials);
  144|       |
  145|       |/* Util to get the channel credentials from a channel arg. */
  146|       |grpc_channel_credentials* grpc_channel_credentials_from_arg(
  147|       |    const grpc_arg* arg);
  148|       |
  149|       |/* Util to find the channel credentials from channel args. */
  150|       |grpc_channel_credentials* grpc_channel_credentials_find_in_args(
  151|       |    const grpc_channel_args* args);
  152|       |
  153|       |/* --- grpc_credentials_mdelem_array. --- */
  154|       |
  155|       |typedef struct {
  156|       |  grpc_mdelem* md = nullptr;
  157|       |  size_t size = 0;
  158|       |} grpc_credentials_mdelem_array;
  159|       |
  160|       |/// Takes a new ref to \a md.
  161|       |void grpc_credentials_mdelem_array_add(grpc_credentials_mdelem_array* list,
  162|       |                                       grpc_mdelem md);
  163|       |
  164|       |/// Appends all elements from \a src to \a dst, taking a new ref to each one.
  165|       |void grpc_credentials_mdelem_array_append(grpc_credentials_mdelem_array* dst,
  166|       |                                          grpc_credentials_mdelem_array* src);
  167|       |
  168|       |void grpc_credentials_mdelem_array_destroy(grpc_credentials_mdelem_array* list);
  169|       |
  170|       |/* --- grpc_call_credentials. --- */
  171|       |
  172|       |// This type is forward declared as a C struct and we cannot define it as a
  173|       |// class. Otherwise, compiler will complain about type mismatch due to
  174|       |// -Wmismatched-tags.
  175|       |struct grpc_call_credentials
  176|       |    : public grpc_core::RefCounted<grpc_call_credentials> {
  177|       | public:
  178|      0|  explicit grpc_call_credentials(const char* type) : type_(type) {}
  179|       |  virtual ~grpc_call_credentials() = default;
  180|       |
  181|       |  // Returns true if completed synchronously, in which case \a error will
  182|       |  // be set to indicate the result.  Otherwise, \a on_request_metadata will
  183|       |  // be invoked asynchronously when complete.  \a md_array will be populated
  184|       |  // with the resulting metadata once complete.
  185|       |  virtual bool get_request_metadata(grpc_polling_entity* pollent,
  186|       |                                    grpc_auth_metadata_context context,
  187|       |                                    grpc_credentials_mdelem_array* md_array,
  188|       |                                    grpc_closure* on_request_metadata,
  189|       |                                    grpc_error** error) GRPC_ABSTRACT;
  190|       |
  191|       |  // Cancels a pending asynchronous operation started by
  192|       |  // grpc_call_credentials_get_request_metadata() with the corresponding
  193|       |  // value of \a md_array.
  194|       |  virtual void cancel_get_request_metadata(
  195|       |      grpc_credentials_mdelem_array* md_array, grpc_error* error) GRPC_ABSTRACT;
  196|       |
  197|       |  const char* type() const { return type_; }
  198|       |
  199|       |  GRPC_ABSTRACT_BASE_CLASS
  200|       |
  201|       | private:
  202|       |  const char* type_;
  203|       |};
  204|       |
  205|       |/* Metadata-only credentials with the specified key and value where
  206|       |   asynchronicity can be simulated for testing. */
  207|       |grpc_call_credentials* grpc_md_only_test_credentials_create(
  208|       |    const char* md_key, const char* md_value, bool is_async);
  209|       |
  210|       |/* --- grpc_server_credentials. --- */
  211|       |
  212|       |// This type is forward declared as a C struct and we cannot define it as a
  213|       |// class. Otherwise, compiler will complain about type mismatch due to
  214|       |// -Wmismatched-tags.
  215|       |struct grpc_server_credentials
  216|       |    : public grpc_core::RefCounted<grpc_server_credentials> {
  217|       | public:
  218|      0|  explicit grpc_server_credentials(const char* type) : type_(type) {}
  219|       |
  220|      0|  virtual ~grpc_server_credentials() { DestroyProcessor(); }
  221|       |
  222|       |  virtual grpc_core::RefCountedPtr<grpc_server_security_connector>
  223|       |  create_security_connector() GRPC_ABSTRACT;
  224|       |
  225|       |  const char* type() const { return type_; }
  226|       |
  227|       |  const grpc_auth_metadata_processor& auth_metadata_processor() const {
  228|       |    return processor_;
  229|       |  }
  230|       |  void set_auth_metadata_processor(
  231|       |      const grpc_auth_metadata_processor& processor);
  232|       |
  233|       |  GRPC_ABSTRACT_BASE_CLASS
  234|       |
  235|       | private:
  236|       |  void DestroyProcessor() {
  237|       |    if (processor_.destroy != nullptr && processor_.state != nullptr) {
  238|       |      processor_.destroy(processor_.state);
  239|       |    }
  240|       |  }
  241|       |
  242|       |  const char* type_;
  243|       |  grpc_auth_metadata_processor processor_ =
  244|       |      grpc_auth_metadata_processor();  // Zero-initialize the C struct.
  245|       |};
  246|       |
  247|       |#define GRPC_SERVER_CREDENTIALS_ARG "grpc.server_credentials"
  248|       |
  249|       |grpc_arg grpc_server_credentials_to_arg(grpc_server_credentials* c);
  250|       |grpc_server_credentials* grpc_server_credentials_from_arg(const grpc_arg* arg);
  251|       |grpc_server_credentials* grpc_find_server_credentials_in_args(
  252|       |    const grpc_channel_args* args);
  253|       |
  254|       |/* -- Credentials Metadata Request. -- */
  255|       |
  256|       |struct grpc_credentials_metadata_request {
  257|       |  explicit grpc_credentials_metadata_request(
  258|       |      grpc_core::RefCountedPtr<grpc_call_credentials> creds)
  259|      0|      : creds(std::move(creds)) {}
  260|      0|  ~grpc_credentials_metadata_request() {
  261|      0|    grpc_http_response_destroy(&response);
  262|      0|  }
  263|       |
  264|       |  grpc_core::RefCountedPtr<grpc_call_credentials> creds;
  265|       |  grpc_http_response response;
  266|       |};
  267|       |
  268|       |inline grpc_credentials_metadata_request*
  269|       |grpc_credentials_metadata_request_create(
  270|       |    grpc_core::RefCountedPtr<grpc_call_credentials> creds) {
  271|       |  return grpc_core::New<grpc_credentials_metadata_request>(std::move(creds));
  272|       |}
  273|       |
  274|       |inline void grpc_credentials_metadata_request_destroy(
  275|      0|    grpc_credentials_metadata_request* r) {
  276|      0|  grpc_core::Delete(r);
  277|      0|}
  278|       |
  279|       |#endif /* GRPC_CORE_LIB_SECURITY_CREDENTIALS_CREDENTIALS_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/security/security_connector/security_connector.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_SECURITY_SECURITY_CONNECTOR_SECURITY_CONNECTOR_H
   20|       |#define GRPC_CORE_LIB_SECURITY_SECURITY_CONNECTOR_SECURITY_CONNECTOR_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <stdbool.h>
   25|       |
   26|       |#include <grpc/grpc_security.h>
   27|       |
   28|       |#include "src/core/lib/channel/handshaker.h"
   29|       |#include "src/core/lib/gprpp/ref_counted.h"
   30|       |#include "src/core/lib/iomgr/endpoint.h"
   31|       |#include "src/core/lib/iomgr/pollset.h"
   32|       |#include "src/core/lib/iomgr/tcp_server.h"
   33|       |#include "src/core/tsi/ssl_transport_security.h"
   34|       |#include "src/core/tsi/transport_security_interface.h"
   35|       |
   36|       |extern grpc_core::DebugOnlyTraceFlag grpc_trace_security_connector_refcount;
   37|       |
   38|       |typedef enum { GRPC_SECURITY_OK = 0, GRPC_SECURITY_ERROR } grpc_security_status;
   39|       |
   40|       |/* --- security_connector object. ---
   41|       |
   42|       |    A security connector object represents away to configure the underlying
   43|       |    transport security mechanism and check the resulting trusted peer.  */
   44|       |
   45|       |#define GRPC_ARG_SECURITY_CONNECTOR "grpc.security_connector"
   46|       |
   47|       |class grpc_security_connector
   48|       |    : public grpc_core::RefCounted<grpc_security_connector> {
   49|       | public:
   50|       |  explicit grpc_security_connector(const char* url_scheme)
   51|       |      : grpc_core::RefCounted<grpc_security_connector>(
   52|       |            &grpc_trace_security_connector_refcount),
   53|      0|        url_scheme_(url_scheme) {}
   54|       |  virtual ~grpc_security_connector() = default;
   55|       |
   56|       |  /* Check the peer. Callee takes ownership of the peer object.
   57|       |     When done, sets *auth_context and invokes on_peer_checked. */
   58|       |  virtual void check_peer(
   59|       |      tsi_peer peer, grpc_endpoint* ep,
   60|       |      grpc_core::RefCountedPtr<grpc_auth_context>* auth_context,
   61|       |      grpc_closure* on_peer_checked) GRPC_ABSTRACT;
   62|       |
   63|       |  /* Compares two security connectors. */
   64|       |  virtual int cmp(const grpc_security_connector* other) const GRPC_ABSTRACT;
   65|       |
   66|       |  const char* url_scheme() const { return url_scheme_; }
   67|       |
   68|       |  GRPC_ABSTRACT_BASE_CLASS
   69|       |
   70|       | private:
   71|       |  const char* url_scheme_;
   72|       |};
   73|       |
   74|       |/* Util to encapsulate the connector in a channel arg. */
   75|       |grpc_arg grpc_security_connector_to_arg(grpc_security_connector* sc);
   76|       |
   77|       |/* Util to get the connector from a channel arg. */
   78|       |grpc_security_connector* grpc_security_connector_from_arg(const grpc_arg* arg);
   79|       |
   80|       |/* Util to find the connector from channel args. */
   81|       |grpc_security_connector* grpc_security_connector_find_in_args(
   82|       |    const grpc_channel_args* args);
   83|       |
   84|       |/* --- channel_security_connector object. ---
   85|       |
   86|       |    A channel security connector object represents a way to configure the
   87|       |    underlying transport security mechanism on the client side.  */
   88|       |
   89|       |class grpc_channel_security_connector : public grpc_security_connector {
   90|       | public:
   91|       |  grpc_channel_security_connector(
   92|       |      const char* url_scheme,
   93|       |      grpc_core::RefCountedPtr<grpc_channel_credentials> channel_creds,
   94|       |      grpc_core::RefCountedPtr<grpc_call_credentials> request_metadata_creds);
   95|       |  ~grpc_channel_security_connector() override;
   96|       |
   97|       |  /// Checks that the host that will be set for a call is acceptable.
   98|       |  /// Returns true if completed synchronously, in which case \a error will
   99|       |  /// be set to indicate the result.  Otherwise, \a on_call_host_checked
  100|       |  /// will be invoked when complete.
  101|       |  virtual bool check_call_host(const char* host,
  102|       |                               grpc_auth_context* auth_context,
  103|       |                               grpc_closure* on_call_host_checked,
  104|       |                               grpc_error** error) GRPC_ABSTRACT;
  105|       |  /// Cancels a pending asychronous call to
  106|       |  /// grpc_channel_security_connector_check_call_host() with
  107|       |  /// \a on_call_host_checked as its callback.
  108|       |  virtual void cancel_check_call_host(grpc_closure* on_call_host_checked,
  109|       |                                      grpc_error* error) GRPC_ABSTRACT;
  110|       |  /// Registers handshakers with \a handshake_mgr.
  111|       |  virtual void add_handshakers(grpc_pollset_set* interested_parties,
  112|       |                               grpc_core::HandshakeManager* handshake_mgr)
  113|       |      GRPC_ABSTRACT;
  114|       |
  115|       |  const grpc_channel_credentials* channel_creds() const {
  116|       |    return channel_creds_.get();
  117|       |  }
  118|       |  grpc_channel_credentials* mutable_channel_creds() {
  119|       |    return channel_creds_.get();
  120|       |  }
  121|       |  const grpc_call_credentials* request_metadata_creds() const {
  122|       |    return request_metadata_creds_.get();
  123|       |  }
  124|       |  grpc_call_credentials* mutable_request_metadata_creds() {
  125|       |    return request_metadata_creds_.get();
  126|       |  }
  127|       |
  128|       |  GRPC_ABSTRACT_BASE_CLASS
  129|       |
  130|       | protected:
  131|       |  // Helper methods to be used in subclasses.
  132|       |  int channel_security_connector_cmp(
  133|       |      const grpc_channel_security_connector* other) const;
  134|       |
  135|       | private:
  136|       |  grpc_core::RefCountedPtr<grpc_channel_credentials> channel_creds_;
  137|       |  grpc_core::RefCountedPtr<grpc_call_credentials> request_metadata_creds_;
  138|       |};
  139|       |
  140|       |/* --- server_security_connector object. ---
  141|       |
  142|       |    A server security connector object represents a way to configure the
  143|       |    underlying transport security mechanism on the server side.  */
  144|       |
  145|       |class grpc_server_security_connector : public grpc_security_connector {
  146|       | public:
  147|       |  grpc_server_security_connector(
  148|       |      const char* url_scheme,
  149|       |      grpc_core::RefCountedPtr<grpc_server_credentials> server_creds);
  150|       |  ~grpc_server_security_connector() override = default;
  151|       |
  152|       |  virtual void add_handshakers(grpc_pollset_set* interested_parties,
  153|       |                               grpc_core::HandshakeManager* handshake_mgr)
  154|       |      GRPC_ABSTRACT;
  155|       |
  156|       |  const grpc_server_credentials* server_creds() const {
  157|       |    return server_creds_.get();
  158|       |  }
  159|       |  grpc_server_credentials* mutable_server_creds() {
  160|       |    return server_creds_.get();
  161|       |  }
  162|       |
  163|       |  GRPC_ABSTRACT_BASE_CLASS
  164|       |
  165|       | protected:
  166|       |  // Helper methods to be used in subclasses.
  167|       |  int server_security_connector_cmp(
  168|       |      const grpc_server_security_connector* other) const;
  169|       |
  170|       | private:
  171|       |  grpc_core::RefCountedPtr<grpc_server_credentials> server_creds_;
  172|       |};
  173|       |
  174|       |#endif /* GRPC_CORE_LIB_SECURITY_SECURITY_CONNECTOR_SECURITY_CONNECTOR_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/slice/slice_internal.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_SLICE_SLICE_INTERNAL_H
   20|       |#define GRPC_CORE_LIB_SLICE_SLICE_INTERNAL_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/slice.h>
   25|       |#include <grpc/slice_buffer.h>
   26|       |#include <string.h>
   27|       |
   28|       |#include "src/core/lib/gpr/murmur_hash.h"
   29|       |#include "src/core/lib/gprpp/ref_counted.h"
   30|       |#include "src/core/lib/transport/static_metadata.h"
   31|       |
   32|       |// Interned slices have specific fast-path operations for hashing. To inline
   33|       |// these operations, we need to forward declare them here.
   34|       |extern uint32_t grpc_static_metadata_hash_values[GRPC_STATIC_MDSTR_COUNT];
   35|       |extern uint32_t g_hash_seed;
   36|       |
   37|       |// grpc_slice_refcount : A reference count for grpc_slice.
   38|       |//
   39|       |// Non-inlined grpc_slice objects are refcounted. Historically this was
   40|       |// implemented via grpc_slice_refcount, a C-style polymorphic class using a
   41|       |// manually managed vtable of operations. Subclasses would define their own
   42|       |// vtable; the 'virtual' methods (ref, unref, equals and hash) would simply call
   43|       |// the function pointers in the vtable as necessary.
   44|       |//
   45|       |// Unfortunately, this leads to some inefficiencies in the generated code that
   46|       |// can be improved upon. For example, equality checking for interned slices is a
   47|       |// simple equality check on the refcount pointer. With the vtable approach, this
   48|       |// would translate to roughly the following (high-level) instructions:
   49|       |//
   50|       |// grpc_slice_equals(slice1, slice2):
   51|       |//   load vtable->eq -> eq_func
   52|       |//   call eq_func(slice1, slice2)
   53|       |//
   54|       |// interned_slice_equals(slice1, slice2)
   55|       |//   load slice1.ref -> r1
   56|       |//   load slice2.ref -> r2
   57|       |//   cmp r1, r2 -> retval
   58|       |//   ret retval
   59|       |//
   60|       |// This leads to a function call for a function defined in another translation
   61|       |// unit, which imposes memory barriers, which reduces the compiler's ability to
   62|       |// optimize (in addition to the added overhead of call/ret). Additionally, it
   63|       |// may be harder to reason about branch prediction when we're jumping to
   64|       |// essentially arbitrarily provided function pointers.
   65|       |//
   66|       |// In addition, it is arguable that while virtualization was helpful for
   67|       |// Equals()/Hash() methods, that it was fundamentally unnecessary for
   68|       |// Ref()/Unref().
   69|       |//
   70|       |// Instead, grpc_slice_refcount provides the same functionality as the C-style
   71|       |// virtual class, but in a de-virtualized manner - Eq(), Hash(), Ref() and
   72|       |// Unref() are provided within this header file. Fastpaths for Eq()/Hash()
   73|       |// (interned and static metadata slices), as well as the Ref() operation, can
   74|       |// all be inlined without any memory barriers.
   75|       |//
   76|       |// It does this by:
   77|       |// 1. Using grpc_core::RefCount<> (header-only) for Ref/Unref. Two special cases
   78|       |//    need support: No-op ref/unref (eg. static metadata slices) and stream
   79|       |//    slice references (where all the slices share the streamref). This is in
   80|       |//    addition to the normal case of '1 slice, 1 ref'.
   81|       |//    To support these cases, we explicitly track a nullable pointer to the
   82|       |//    underlying RefCount<>. No-op ref/unref is used by checking the pointer for
   83|       |//    null, and doing nothing if it is. Both stream slice refs and 'normal'
   84|       |//    slices use the same path for Ref/Unref (by targeting the non-null
   85|       |//    pointer).
   86|       |//
   87|       |// 2. introducing the notion of grpc_slice_refcount::Type. This describes if a
   88|       |//    slice ref is used by a static metadata slice, an interned slice, or other
   89|       |//    slices. We switch on the slice ref type in order to provide fastpaths for
   90|       |//    Equals() and Hash().
   91|       |//
   92|       |// In total, this saves us roughly 1-2% latency for unary calls, with smaller
   93|       |// calls benefitting. The effect is present, but not as useful, for larger calls
   94|       |// where the cost of sending the data dominates.
   95|       |struct grpc_slice_refcount {
   96|       | public:
   97|       |  enum class Type {
   98|       |    STATIC,    // Refcount for a static metadata slice.
   99|       |    INTERNED,  // Refcount for an interned slice.
  100|       |    REGULAR    // Refcount for non-static-metadata, non-interned slices.
  101|       |  };
  102|       |  typedef void (*DestroyerFn)(void*);
  103|       |
  104|       |  grpc_slice_refcount() = default;
  105|       |
  106|      0|  explicit grpc_slice_refcount(grpc_slice_refcount* sub) : sub_refcount_(sub) {}
  107|       |  // Regular constructor for grpc_slice_refcount.
  108|       |  //
  109|       |  // Parameters:
  110|       |  //  1. grpc_slice_refcount::Type type
  111|       |  //  Whether we are the refcount for a static
  112|       |  //  metadata slice, an interned slice, or any other kind of slice.
  113|       |  //
  114|       |  //  2. RefCount* ref
  115|       |  //  The pointer to the actual underlying grpc_core::RefCount. Rather than
  116|       |  //  performing struct offset computations as in the original implementation to
  117|       |  //  get to the refcount, which requires a virtual method, we devirtualize by
  118|       |  //  using a nullable pointer to allow a single pair of Ref/Unref methods.
  119|       |  //
  120|       |  //  3. DestroyerFn destroyer_fn
  121|       |  //  Called when the refcount goes to 0, with destroyer_arg as parameter.
  122|       |  //
  123|       |  //  4. void* destroyer_arg
  124|       |  //  Argument for the virtualized destructor.
  125|       |  //
  126|       |  //  5. grpc_slice_refcount* sub
  127|       |  //  Argument used for interned slices.
  128|       |  grpc_slice_refcount(grpc_slice_refcount::Type type, grpc_core::RefCount* ref,
  129|       |                      DestroyerFn destroyer_fn, void* destroyer_arg,
  130|       |                      grpc_slice_refcount* sub)
  131|       |      : ref_(ref),
  132|       |        ref_type_(type),
  133|       |        sub_refcount_(sub),
  134|       |        dest_fn_(destroyer_fn),
  135|      0|        destroy_fn_arg_(destroyer_arg) {}
  136|       |  // Initializer for static refcounts.
  137|       |  grpc_slice_refcount(grpc_slice_refcount* sub, Type type)
  138|       |      : ref_type_(type), sub_refcount_(sub) {}
  139|       |
  140|       |  Type GetType() const { return ref_type_; }
  141|       |
  142|       |  int Eq(const grpc_slice& a, const grpc_slice& b);
  143|       |
  144|       |  uint32_t Hash(const grpc_slice& slice);
  145|       |  void Ref() {
  146|       |    if (ref_ == nullptr) return;
  147|       |    ref_->RefNonZero();
  148|       |  }
  149|       |  void Unref() {
  150|       |    if (ref_ == nullptr) return;
  151|       |    if (ref_->Unref()) {
  152|       |      dest_fn_(destroy_fn_arg_);
  153|       |    }
  154|       |  }
  155|       |
  156|       |  grpc_slice_refcount* sub_refcount() const { return sub_refcount_; }
  157|       |
  158|       | private:
  159|       |  grpc_core::RefCount* ref_ = nullptr;
  160|       |  const Type ref_type_ = Type::REGULAR;
  161|       |  grpc_slice_refcount* sub_refcount_ = this;
  162|       |  DestroyerFn dest_fn_ = nullptr;
  163|       |  void* destroy_fn_arg_ = nullptr;
  164|       |};
  165|       |
  166|       |namespace grpc_core {
  167|       |
  168|       |struct InternedSliceRefcount {
  169|      0|  static void Destroy(void* arg) {
  170|      0|    auto* rc = static_cast<InternedSliceRefcount*>(arg);
  171|      0|    rc->~InternedSliceRefcount();
  172|      0|    gpr_free(rc);
  173|      0|  }
  174|       |
  175|       |  InternedSliceRefcount(size_t length, uint32_t hash,
  176|       |                        InternedSliceRefcount* bucket_next)
  177|       |      : base(grpc_slice_refcount::Type::INTERNED, &refcnt, Destroy, this, &sub),
  178|       |        sub(grpc_slice_refcount::Type::REGULAR, &refcnt, Destroy, this, &sub),
  179|       |        length(length),
  180|       |        hash(hash),
  181|      0|        bucket_next(bucket_next) {}
  182|       |
  183|       |  ~InternedSliceRefcount();
  184|       |
  185|       |  grpc_slice_refcount base;
  186|       |  grpc_slice_refcount sub;
  187|       |  const size_t length;
  188|       |  RefCount refcnt;
  189|       |  const uint32_t hash;
  190|       |  InternedSliceRefcount* bucket_next;
  191|       |};
  192|       |
  193|       |}  // namespace grpc_core
  194|       |
  195|       |inline int grpc_slice_refcount::Eq(const grpc_slice& a, const grpc_slice& b) {
  196|       |  switch (ref_type_) {
  197|       |    case Type::STATIC:
  198|       |      return GRPC_STATIC_METADATA_INDEX(a) == GRPC_STATIC_METADATA_INDEX(b);
  199|       |    case Type::INTERNED:
  200|       |      return a.refcount == b.refcount;
  201|       |    case Type::REGULAR:
  202|       |      break;
  203|       |  }
  204|       |  if (GRPC_SLICE_LENGTH(a) != GRPC_SLICE_LENGTH(b)) return false;
  205|       |  if (GRPC_SLICE_LENGTH(a) == 0) return true;
  206|       |  return 0 == memcmp(GRPC_SLICE_START_PTR(a), GRPC_SLICE_START_PTR(b),
  207|       |                     GRPC_SLICE_LENGTH(a));
  208|       |}
  209|       |
  210|       |inline uint32_t grpc_slice_refcount::Hash(const grpc_slice& slice) {
  211|       |  switch (ref_type_) {
  212|       |    case Type::STATIC:
  213|       |      return ::grpc_static_metadata_hash_values[GRPC_STATIC_METADATA_INDEX(
  214|       |          slice)];
  215|       |    case Type::INTERNED:
  216|       |      return reinterpret_cast<grpc_core::InternedSliceRefcount*>(slice.refcount)
  217|       |          ->hash;
  218|       |    case Type::REGULAR:
  219|       |      break;
  220|       |  }
  221|       |  return gpr_murmur_hash3(GRPC_SLICE_START_PTR(slice), GRPC_SLICE_LENGTH(slice),
  222|       |                          g_hash_seed);
  223|       |}
  224|       |
  225|       |inline const grpc_slice& grpc_slice_ref_internal(const grpc_slice& slice) {
  226|       |  if (slice.refcount) {
  227|       |    slice.refcount->Ref();
  228|       |  }
  229|       |  return slice;
  230|       |}
  231|       |
  232|       |inline void grpc_slice_unref_internal(const grpc_slice& slice) {
  233|       |  if (slice.refcount) {
  234|       |    slice.refcount->Unref();
  235|       |  }
  236|       |}
  237|       |
  238|       |void grpc_slice_buffer_reset_and_unref_internal(grpc_slice_buffer* sb);
  239|       |void grpc_slice_buffer_partial_unref_internal(grpc_slice_buffer* sb,
  240|       |                                              size_t idx);
  241|       |void grpc_slice_buffer_destroy_internal(grpc_slice_buffer* sb);
  242|       |
  243|       |/* Check if a slice is interned */
  244|       |bool grpc_slice_is_interned(const grpc_slice& slice);
  245|       |
  246|       |void grpc_slice_intern_init(void);
  247|       |void grpc_slice_intern_shutdown(void);
  248|       |void grpc_test_only_set_slice_hash_seed(uint32_t key);
  249|       |// if slice matches a static slice, returns the static slice
  250|       |// otherwise returns the passed in slice (without reffing it)
  251|       |// used for surface boundaries where we might receive an un-interned static
  252|       |// string
  253|       |grpc_slice grpc_slice_maybe_static_intern(grpc_slice slice,
  254|       |                                          bool* returned_slice_is_different);
  255|       |uint32_t grpc_static_slice_hash(grpc_slice s);
  256|       |int grpc_static_slice_eq(grpc_slice a, grpc_slice b);
  257|       |
  258|       |// Returns the memory used by this slice, not counting the slice structure
  259|       |// itself. This means that inlined and slices from static strings will return
  260|       |// 0. All other slices will return the size of the allocated chars.
  261|       |size_t grpc_slice_memory_usage(grpc_slice s);
  262|       |
  263|       |#endif /* GRPC_CORE_LIB_SLICE_SLICE_INTERNAL_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/surface/completion_queue.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015-2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_SURFACE_COMPLETION_QUEUE_H
   20|       |#define GRPC_CORE_LIB_SURFACE_COMPLETION_QUEUE_H
   21|       |
   22|       |/* Internal API for completion queues */
   23|       |
   24|       |#include <grpc/support/port_platform.h>
   25|       |
   26|       |#include <grpc/grpc.h>
   27|       |#include "src/core/lib/debug/trace.h"
   28|       |#include "src/core/lib/gprpp/abstract.h"
   29|       |#include "src/core/lib/iomgr/pollset.h"
   30|       |
   31|       |/* These trace flags default to 1. The corresponding lines are only traced
   32|       |   if grpc_api_trace is also truthy */
   33|       |extern grpc_core::TraceFlag grpc_cq_pluck_trace;
   34|       |extern grpc_core::TraceFlag grpc_trace_operation_failures;
   35|       |extern grpc_core::DebugOnlyTraceFlag grpc_trace_pending_tags;
   36|       |extern grpc_core::DebugOnlyTraceFlag grpc_trace_cq_refcount;
   37|       |
   38|       |typedef struct grpc_cq_completion {
   39|       |  gpr_mpscq_node node;
   40|       |
   41|       |  /** user supplied tag */
   42|       |  void* tag;
   43|       |  /** done callback - called when this queue element is no longer
   44|       |      needed by the completion queue */
   45|       |  void (*done)(void* done_arg, struct grpc_cq_completion* c);
   46|       |  void* done_arg;
   47|       |  /** next pointer; low bit is used to indicate success or not */
   48|       |  uintptr_t next;
   49|       |} grpc_cq_completion;
   50|       |
   51|       |#ifndef NDEBUG
   52|       |void grpc_cq_internal_ref(grpc_completion_queue* cc, const char* reason,
   53|       |                          const char* file, int line);
   54|       |void grpc_cq_internal_unref(grpc_completion_queue* cc, const char* reason,
   55|       |                            const char* file, int line);
   56|       |#define GRPC_CQ_INTERNAL_REF(cc, reason) \
   57|      0|  grpc_cq_internal_ref(cc, reason, __FILE__, __LINE__)
   58|       |#define GRPC_CQ_INTERNAL_UNREF(cc, reason) \
   59|       |  grpc_cq_internal_unref(cc, reason, __FILE__, __LINE__)
   60|       |#else
   61|       |void grpc_cq_internal_ref(grpc_completion_queue* cc);
   62|       |void grpc_cq_internal_unref(grpc_completion_queue* cc);
   63|       |#define GRPC_CQ_INTERNAL_REF(cc, reason) grpc_cq_internal_ref(cc)
   64|       |#define GRPC_CQ_INTERNAL_UNREF(cc, reason) grpc_cq_internal_unref(cc)
   65|       |#endif
   66|       |
   67|       |/* Initializes global variables used by completion queues */
   68|       |void grpc_cq_global_init();
   69|       |
   70|       |/* Flag that an operation is beginning: the completion channel will not finish
   71|       |   shutdown until a corrensponding grpc_cq_end_* call is made.
   72|       |   \a tag is currently used only in debug builds. Return true on success, and
   73|       |   false if completion_queue has been shutdown. */
   74|       |bool grpc_cq_begin_op(grpc_completion_queue* cc, void* tag);
   75|       |
   76|       |/* Queue a GRPC_OP_COMPLETED operation; tag must correspond to the tag passed to
   77|       |   grpc_cq_begin_op */
   78|       |void grpc_cq_end_op(grpc_completion_queue* cc, void* tag, grpc_error* error,
   79|       |                    void (*done)(void* done_arg, grpc_cq_completion* storage),
   80|       |                    void* done_arg, grpc_cq_completion* storage);
   81|       |
   82|       |grpc_pollset* grpc_cq_pollset(grpc_completion_queue* cc);
   83|       |
   84|       |bool grpc_cq_can_listen(grpc_completion_queue* cc);
   85|       |
   86|       |grpc_cq_completion_type grpc_get_cq_completion_type(grpc_completion_queue* cc);
   87|       |
   88|       |int grpc_get_cq_poll_num(grpc_completion_queue* cc);
   89|       |
   90|       |grpc_completion_queue* grpc_completion_queue_create_internal(
   91|       |    grpc_cq_completion_type completion_type, grpc_cq_polling_type polling_type,
   92|       |    grpc_experimental_completion_queue_functor* shutdown_callback);
   93|       |
   94|       |#endif /* GRPC_CORE_LIB_SURFACE_COMPLETION_QUEUE_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/transport/byte_stream.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_TRANSPORT_BYTE_STREAM_H
   20|       |#define GRPC_CORE_LIB_TRANSPORT_BYTE_STREAM_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <grpc/slice_buffer.h>
   25|       |#include "src/core/lib/gprpp/abstract.h"
   26|       |#include "src/core/lib/gprpp/orphanable.h"
   27|       |#include "src/core/lib/iomgr/closure.h"
   28|       |
   29|       |/** Internal bit flag for grpc_begin_message's \a flags signaling the use of
   30|       | * compression for the message */
   31|       |#define GRPC_WRITE_INTERNAL_COMPRESS (0x80000000u)
   32|       |/** Mask of all valid internal flags. */
   33|       |#define GRPC_WRITE_INTERNAL_USED_MASK (GRPC_WRITE_INTERNAL_COMPRESS)
   34|       |
   35|       |namespace grpc_core {
   36|       |
   37|       |class ByteStream : public Orphanable {
   38|       | public:
   39|      0|  virtual ~ByteStream() {}
   40|       |
   41|       |  // Returns true if the bytes are available immediately (in which case
   42|       |  // on_complete will not be called), or false if the bytes will be available
   43|       |  // asynchronously (in which case on_complete will be called when they
   44|       |  // are available).
   45|       |  //
   46|       |  // max_size_hint can be set as a hint as to the maximum number
   47|       |  // of bytes that would be acceptable to read.
   48|       |  virtual bool Next(size_t max_size_hint,
   49|       |                    grpc_closure* on_complete) GRPC_ABSTRACT;
   50|       |
   51|       |  // Returns the next slice in the byte stream when it is available, as
   52|       |  // indicated by Next().
   53|       |  //
   54|       |  // Once a slice is returned into *slice, it is owned by the caller.
   55|       |  virtual grpc_error* Pull(grpc_slice* slice) GRPC_ABSTRACT;
   56|       |
   57|       |  // Shuts down the byte stream.
   58|       |  //
   59|       |  // If there is a pending call to on_complete from Next(), it will be
   60|       |  // invoked with the error passed to Shutdown().
   61|       |  //
   62|       |  // The next call to Pull() (if any) will return the error passed to
   63|       |  // Shutdown().
   64|       |  virtual void Shutdown(grpc_error* error) GRPC_ABSTRACT;
   65|       |
   66|       |  uint32_t length() const { return length_; }
   67|       |  uint32_t flags() const { return flags_; }
   68|       |
   69|      0|  void set_flags(uint32_t flags) { flags_ = flags; }
   70|       |
   71|       |  GRPC_ABSTRACT_BASE_CLASS
   72|       |
   73|       | protected:
   74|       |  ByteStream(uint32_t length, uint32_t flags)
   75|      0|      : length_(length), flags_(flags) {}
   76|       |
   77|       | private:
   78|       |  const uint32_t length_;
   79|       |  uint32_t flags_;
   80|       |};
   81|       |
   82|       |//
   83|       |// SliceBufferByteStream
   84|       |//
   85|       |// A ByteStream that wraps a slice buffer.
   86|       |//
   87|       |
   88|       |class SliceBufferByteStream : public ByteStream {
   89|       | public:
   90|       |  // Removes all slices in slice_buffer, leaving it empty.
   91|       |  SliceBufferByteStream(grpc_slice_buffer* slice_buffer, uint32_t flags);
   92|       |
   93|       |  ~SliceBufferByteStream();
   94|       |
   95|       |  void Orphan() override;
   96|       |
   97|       |  bool Next(size_t max_size_hint, grpc_closure* on_complete) override;
   98|       |  grpc_error* Pull(grpc_slice* slice) override;
   99|       |  void Shutdown(grpc_error* error) override;
  100|       |
  101|       | private:
  102|       |  grpc_slice_buffer backing_buffer_;
  103|       |  size_t cursor_ = 0;
  104|       |  grpc_error* shutdown_error_ = GRPC_ERROR_NONE;
  105|       |};
  106|       |
  107|       |//
  108|       |// CachingByteStream
  109|       |//
  110|       |// A ByteStream that that wraps an underlying byte stream but caches
  111|       |// the resulting slices in a slice buffer.  If an initial attempt fails
  112|       |// without fully draining the underlying stream, a new caching stream
  113|       |// can be created from the same underlying cache, in which case it will
  114|       |// return whatever is in the backing buffer before continuing to read the
  115|       |// underlying stream.
  116|       |//
  117|       |// NOTE: No synchronization is done, so it is not safe to have multiple
  118|       |// CachingByteStreams simultaneously drawing from the same underlying
  119|       |// ByteStreamCache at the same time.
  120|       |//
  121|       |
  122|       |class ByteStreamCache {
  123|       | public:
  124|       |  class CachingByteStream : public ByteStream {
  125|       |   public:
  126|       |    explicit CachingByteStream(ByteStreamCache* cache);
  127|       |
  128|       |    ~CachingByteStream();
  129|       |
  130|       |    void Orphan() override;
  131|       |
  132|       |    bool Next(size_t max_size_hint, grpc_closure* on_complete) override;
  133|       |    grpc_error* Pull(grpc_slice* slice) override;
  134|       |    void Shutdown(grpc_error* error) override;
  135|       |
  136|       |    // Resets the byte stream to the start of the underlying stream.
  137|       |    void Reset();
  138|       |
  139|       |   private:
  140|       |    ByteStreamCache* cache_;
  141|       |    size_t cursor_ = 0;
  142|       |    size_t offset_ = 0;
  143|       |    grpc_error* shutdown_error_ = GRPC_ERROR_NONE;
  144|       |  };
  145|       |
  146|       |  explicit ByteStreamCache(OrphanablePtr<ByteStream> underlying_stream);
  147|       |
  148|       |  ~ByteStreamCache();
  149|       |
  150|       |  // Must not be destroyed while still in use by a CachingByteStream.
  151|       |  void Destroy();
  152|       |
  153|       |  grpc_slice_buffer* cache_buffer() { return &cache_buffer_; }
  154|       |
  155|       | private:
  156|       |  OrphanablePtr<ByteStream> underlying_stream_;
  157|       |  uint32_t length_;
  158|       |  uint32_t flags_;
  159|       |  grpc_slice_buffer cache_buffer_;
  160|       |};
  161|       |
  162|       |}  // namespace grpc_core
  163|       |
  164|       |#endif /* GRPC_CORE_LIB_TRANSPORT_BYTE_STREAM_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/transport/metadata.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_TRANSPORT_METADATA_H
   20|       |#define GRPC_CORE_LIB_TRANSPORT_METADATA_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include "include/grpc/impl/codegen/log.h"
   25|       |
   26|       |#include <grpc/grpc.h>
   27|       |#include <grpc/slice.h>
   28|       |
   29|       |#include "src/core/lib/debug/trace.h"
   30|       |#include "src/core/lib/gpr/useful.h"
   31|       |#include "src/core/lib/gprpp/atomic.h"
   32|       |#include "src/core/lib/gprpp/sync.h"
   33|       |
   34|       |extern grpc_core::DebugOnlyTraceFlag grpc_trace_metadata;
   35|       |
   36|       |/* This file provides a mechanism for tracking metadata through the grpc stack.
   37|       |   It's not intended for consumption outside of the library.
   38|       |
   39|       |   Metadata is tracked in the context of a grpc_mdctx. For the time being there
   40|       |   is one of these per-channel, avoiding cross channel interference with memory
   41|       |   use and lock contention.
   42|       |
   43|       |   The context tracks unique strings (grpc_mdstr) and pairs of strings
   44|       |   (grpc_mdelem). Any of these objects can be checked for equality by comparing
   45|       |   their pointers. These objects are reference counted.
   46|       |
   47|       |   grpc_mdelem can additionally store a (non-NULL) user data pointer. This
   48|       |   pointer is intended to be used to cache semantic meaning of a metadata
   49|       |   element. For example, an OAuth token may cache the credentials it represents
   50|       |   and the time at which it expires in the mdelem user data.
   51|       |
   52|       |   Combining this metadata cache and the hpack compression table allows us to
   53|       |   simply lookup complete preparsed objects quickly, incurring a few atomic
   54|       |   ops per metadata element on the fast path.
   55|       |
   56|       |   grpc_mdelem instances MAY live longer than their refcount implies, and are
   57|       |   garbage collected periodically, meaning cached data can easily outlive a
   58|       |   single request.
   59|       |
   60|       |   STATIC METADATA: in static_metadata.h we declare a set of static metadata.
   61|       |   These mdelems and mdstrs are available via pre-declared code generated macros
   62|       |   and are available to code anywhere between grpc_init() and grpc_shutdown().
   63|       |   They are not refcounted, but can be passed to _ref and _unref functions
   64|       |   declared here - in which case those functions are effectively no-ops. */
   65|       |
   66|       |/* Forward declarations */
   67|       |typedef struct grpc_mdelem grpc_mdelem;
   68|       |
   69|       |/* if changing this, make identical changes in:
   70|       |   - grpc_core::{InternedMetadata, AllocatedMetadata}
   71|       |   - grpc_metadata in grpc_types.h */
   72|       |typedef struct grpc_mdelem_data {
   73|       |  const grpc_slice key;
   74|       |  const grpc_slice value;
   75|       |  /* there is a private part to this in metadata.c */
   76|       |} grpc_mdelem_data;
   77|       |
   78|       |/* GRPC_MDELEM_STORAGE_* enum values that can be treated as interned always have
   79|       |   this bit set in their integer value */
   80|       |#define GRPC_MDELEM_STORAGE_INTERNED_BIT 1
   81|       |
   82|       |typedef enum {
   83|       |  /* memory pointed to by grpc_mdelem::payload is owned by an external system */
   84|       |  GRPC_MDELEM_STORAGE_EXTERNAL = 0,
   85|       |  /* memory pointed to by grpc_mdelem::payload is interned by the metadata
   86|       |     system */
   87|       |  GRPC_MDELEM_STORAGE_INTERNED = GRPC_MDELEM_STORAGE_INTERNED_BIT,
   88|       |  /* memory pointed to by grpc_mdelem::payload is allocated by the metadata
   89|       |     system */
   90|       |  GRPC_MDELEM_STORAGE_ALLOCATED = 2,
   91|       |  /* memory is in the static metadata table */
   92|       |  GRPC_MDELEM_STORAGE_STATIC = 2 | GRPC_MDELEM_STORAGE_INTERNED_BIT,
   93|       |} grpc_mdelem_data_storage;
   94|       |
   95|       |struct grpc_mdelem {
   96|       |  /* a grpc_mdelem_data* generally, with the two lower bits signalling memory
   97|       |     ownership as per grpc_mdelem_data_storage */
   98|       |  uintptr_t payload;
   99|       |};
  100|       |
  101|       |#define GRPC_MDELEM_DATA(md) ((grpc_mdelem_data*)((md).payload & ~(uintptr_t)3))
  102|       |#define GRPC_MDELEM_STORAGE(md) \
  103|       |  ((grpc_mdelem_data_storage)((md).payload & (uintptr_t)3))
  104|       |#ifdef __cplusplus
  105|       |#define GRPC_MAKE_MDELEM(data, storage) \
  106|       |  (grpc_mdelem{((uintptr_t)(data)) | ((uintptr_t)storage)})
  107|       |#else
  108|       |#define GRPC_MAKE_MDELEM(data, storage) \
  109|       |  ((grpc_mdelem){((uintptr_t)(data)) | ((uintptr_t)storage)})
  110|       |#endif
  111|       |#define GRPC_MDELEM_IS_INTERNED(md)          \
  112|       |  ((grpc_mdelem_data_storage)((md).payload & \
  113|       |                              (uintptr_t)GRPC_MDELEM_STORAGE_INTERNED_BIT))
  114|       |
  115|       |/* Unrefs the slices. */
  116|       |grpc_mdelem grpc_mdelem_from_slices(const grpc_slice& key,
  117|       |                                    const grpc_slice& value);
  118|       |
  119|       |/* Cheaply convert a grpc_metadata to a grpc_mdelem; may use the grpc_metadata
  120|       |   object as backing storage (so lifetimes should align) */
  121|       |grpc_mdelem grpc_mdelem_from_grpc_metadata(grpc_metadata* metadata);
  122|       |
  123|       |/* Does not unref the slices; if a new non-interned mdelem is needed, allocates
  124|       |   one if compatible_external_backing_store is NULL, or uses
  125|       |   compatible_external_backing_store if it is non-NULL (in which case it's the
  126|       |   users responsibility to ensure that it outlives usage) */
  127|       |grpc_mdelem grpc_mdelem_create(
  128|       |    const grpc_slice& key, const grpc_slice& value,
  129|       |    grpc_mdelem_data* compatible_external_backing_store);
  130|       |
  131|       |#define GRPC_MDKEY(md) (GRPC_MDELEM_DATA(md)->key)
  132|       |#define GRPC_MDVALUE(md) (GRPC_MDELEM_DATA(md)->value)
  133|       |
  134|       |bool grpc_mdelem_eq(grpc_mdelem a, grpc_mdelem b);
  135|       |/* Often we compare metadata where we know a-priori that the second parameter is
  136|       | * static, and that the keys match. This most commonly happens when processing
  137|       | * metadata batch callouts in initial/trailing filters. In this case, fastpath
  138|       | * grpc_mdelem_eq and remove unnecessary checks. */
  139|       |inline bool grpc_mdelem_static_value_eq(grpc_mdelem a, grpc_mdelem b_static) {
  140|       |  if (a.payload == b_static.payload) return true;
  141|       |  return grpc_slice_eq(GRPC_MDVALUE(a), GRPC_MDVALUE(b_static));
  142|       |}
  143|       |
  144|       |/* Mutator and accessor for grpc_mdelem user data. The destructor function
  145|       |   is used as a type tag and is checked during user_data fetch. */
  146|       |void* grpc_mdelem_get_user_data(grpc_mdelem md, void (*if_destroy_func)(void*));
  147|       |void* grpc_mdelem_set_user_data(grpc_mdelem md, void (*destroy_func)(void*),
  148|       |                                void* data);
  149|       |
  150|       |// Defined in metadata.cc.
  151|       |struct mdtab_shard;
  152|       |
  153|       |#ifndef NDEBUG
  154|       |void grpc_mdelem_trace_ref(void* md, const grpc_slice& key,
  155|       |                           const grpc_slice& value, intptr_t refcnt,
  156|       |                           const char* file, int line);
  157|       |void grpc_mdelem_trace_unref(void* md, const grpc_slice& key,
  158|       |                             const grpc_slice& value, intptr_t refcnt,
  159|       |                             const char* file, int line);
  160|       |#endif
  161|       |namespace grpc_core {
  162|       |
  163|       |typedef void (*destroy_user_data_func)(void* data);
  164|       |
  165|       |struct UserData {
  166|       |  Mutex mu_user_data;
  167|       |  grpc_core::Atomic<destroy_user_data_func> destroy_user_data;
  168|       |  grpc_core::Atomic<void*> data;
  169|       |};
  170|       |
  171|       |class InternedMetadata {
  172|       | public:
  173|       |  struct BucketLink {
  174|      0|    explicit BucketLink(InternedMetadata* md) : next(md) {}
  175|       |
  176|       |    InternedMetadata* next = nullptr;
  177|       |  };
  178|       |
  179|       |  InternedMetadata(const grpc_slice& key, const grpc_slice& value,
  180|       |                   uint32_t hash, InternedMetadata* next);
  181|       |  ~InternedMetadata();
  182|       |
  183|       |#ifndef NDEBUG
  184|       |  void Ref(const char* file, int line) {
  185|       |    grpc_mdelem_trace_ref(this, key_, value_, RefValue(), file, line);
  186|       |    const intptr_t prior = refcnt_.FetchAdd(1, MemoryOrder::RELAXED);
  187|       |    GPR_ASSERT(prior > 0);
  188|       |  }
  189|       |  bool Unref(const char* file, int line) {
  190|       |    grpc_mdelem_trace_unref(this, key_, value_, RefValue(), file, line);
  191|       |    return Unref();
  192|       |  }
  193|       |#else
  194|       |  // We define a naked Ref() in the else-clause to make sure we don't
  195|       |  // inadvertently skip the assert on debug builds.
  196|       |  void Ref() {
  197|       |    /* we can assume the ref count is >= 1 as the application is calling
  198|       |       this function - meaning that no adjustment to mdtab_free is necessary,
  199|       |       simplifying the logic here to be just an atomic increment */
  200|       |    refcnt_.FetchAdd(1, MemoryOrder::RELAXED);
  201|       |  }
  202|       |#endif  // ifndef NDEBUG
  203|       |  bool Unref() {
  204|       |    const intptr_t prior = refcnt_.FetchSub(1, MemoryOrder::ACQ_REL);
  205|       |    GPR_DEBUG_ASSERT(prior > 0);
  206|       |    return prior == 1;
  207|       |  }
  208|       |
  209|       |  void RefWithShardLocked(mdtab_shard* shard);
  210|       |  const grpc_slice& key() const { return key_; }
  211|       |  const grpc_slice& value() const { return value_; }
  212|       |  UserData* user_data() { return &user_data_; }
  213|       |  uint32_t hash() { return hash_; }
  214|       |  InternedMetadata* bucket_next() { return link_.next; }
  215|      0|  void set_bucket_next(InternedMetadata* md) { link_.next = md; }
  216|       |
  217|       |  static size_t CleanupLinkedMetadata(BucketLink* head);
  218|       |
  219|       | private:
  220|       |  bool AllRefsDropped() { return refcnt_.Load(MemoryOrder::ACQUIRE) == 0; }
  221|       |  bool FirstRef() { return refcnt_.FetchAdd(1, MemoryOrder::RELAXED) == 0; }
  222|       |  intptr_t RefValue() { return refcnt_.Load(MemoryOrder::RELAXED); }
  223|       |
  224|       |  /* must be byte compatible with grpc_mdelem_data */
  225|       |  grpc_slice key_;
  226|       |  grpc_slice value_;
  227|       |
  228|       |  /* private only data */
  229|       |  grpc_core::Atomic<intptr_t> refcnt_;
  230|       |  uint32_t hash_;
  231|       |
  232|       |  UserData user_data_;
  233|       |
  234|       |  BucketLink link_;
  235|       |};
  236|       |
  237|       |/* Shadow structure for grpc_mdelem_data for allocated elements */
  238|       |class AllocatedMetadata {
  239|       | public:
  240|       |  AllocatedMetadata(const grpc_slice& key, const grpc_slice& value);
  241|       |  ~AllocatedMetadata();
  242|       |
  243|      0|  const grpc_slice& key() const { return key_; }
  244|      0|  const grpc_slice& value() const { return value_; }
  245|       |  UserData* user_data() { return &user_data_; }
  246|       |
  247|       |#ifndef NDEBUG
  248|      0|  void Ref(const char* file, int line) {
  249|      0|    grpc_mdelem_trace_ref(this, key_, value_, RefValue(), file, line);
  250|      0|    Ref();
  251|      0|  }
  252|       |  bool Unref(const char* file, int line) {
  253|       |    grpc_mdelem_trace_unref(this, key_, value_, RefValue(), file, line);
  254|       |    return Unref();
  255|       |  }
  256|       |#endif  // ifndef NDEBUG
  257|      0|  void Ref() {
  258|      0|    /* we can assume the ref count is >= 1 as the application is calling
  259|      0|       this function - meaning that no adjustment to mdtab_free is necessary,
  260|      0|       simplifying the logic here to be just an atomic increment */
  261|      0|    refcnt_.FetchAdd(1, MemoryOrder::RELAXED);
  262|      0|  }
  263|       |  bool Unref() {
  264|       |    const intptr_t prior = refcnt_.FetchSub(1, MemoryOrder::ACQ_REL);
  265|       |    GPR_DEBUG_ASSERT(prior > 0);
  266|       |    return prior == 1;
  267|       |  }
  268|       |
  269|       | private:
  270|       |  intptr_t RefValue() { return refcnt_.Load(MemoryOrder::RELAXED); }
  271|       |
  272|       |  /* must be byte compatible with grpc_mdelem_data */
  273|       |  grpc_slice key_;
  274|       |  grpc_slice value_;
  275|       |
  276|       |  /* private only data */
  277|       |  grpc_core::Atomic<intptr_t> refcnt_;
  278|       |
  279|       |  UserData user_data_;
  280|       |};
  281|       |
  282|       |}  // namespace grpc_core
  283|       |
  284|       |#ifndef NDEBUG
  285|       |#define GRPC_MDELEM_REF(s) grpc_mdelem_ref((s), __FILE__, __LINE__)
  286|       |inline grpc_mdelem grpc_mdelem_ref(grpc_mdelem gmd, const char* file,
  287|       |                                   int line) {
  288|       |#else  // ifndef NDEBUG
  289|       |#define GRPC_MDELEM_REF(s) grpc_mdelem_ref((s))
  290|       |inline grpc_mdelem grpc_mdelem_ref(grpc_mdelem gmd) {
  291|       |#endif  // ifndef NDEBUG
  292|       |  switch (GRPC_MDELEM_STORAGE(gmd)) {
  293|       |    case GRPC_MDELEM_STORAGE_EXTERNAL:
  294|       |    case GRPC_MDELEM_STORAGE_STATIC:
  295|       |      break;
  296|       |    case GRPC_MDELEM_STORAGE_INTERNED: {
  297|       |      auto* md =
  298|       |          reinterpret_cast<grpc_core::InternedMetadata*> GRPC_MDELEM_DATA(gmd);
  299|       |      /* use C assert to have this removed in opt builds */
  300|       |#ifndef NDEBUG
  301|       |      md->Ref(file, line);
  302|       |#else
  303|       |      md->Ref();
  304|       |#endif
  305|       |      break;
  306|       |    }
  307|       |    case GRPC_MDELEM_STORAGE_ALLOCATED: {
  308|       |      auto* md =
  309|       |          reinterpret_cast<grpc_core::AllocatedMetadata*> GRPC_MDELEM_DATA(gmd);
  310|       |#ifndef NDEBUG
  311|       |      md->Ref(file, line);
  312|       |#else
  313|       |      md->Ref();
  314|       |#endif
  315|       |      break;
  316|       |    }
  317|       |  }
  318|       |  return gmd;
  319|       |}
  320|       |
  321|       |#ifndef NDEBUG
  322|       |#define GRPC_MDELEM_UNREF(s) grpc_mdelem_unref((s), __FILE__, __LINE__)
  323|       |void grpc_mdelem_do_unref(grpc_mdelem gmd, const char* file, int line);
  324|       |inline void grpc_mdelem_unref(grpc_mdelem gmd, const char* file, int line) {
  325|       |#else
  326|       |#define GRPC_MDELEM_UNREF(s) grpc_mdelem_unref((s))
  327|       |void grpc_mdelem_do_unref(grpc_mdelem gmd);
  328|       |inline void grpc_mdelem_unref(grpc_mdelem gmd) {
  329|       |#endif
  330|       |  switch (GRPC_MDELEM_STORAGE(gmd)) {
  331|       |    case GRPC_MDELEM_STORAGE_EXTERNAL:
  332|       |    case GRPC_MDELEM_STORAGE_STATIC:
  333|       |      return;
  334|       |    case GRPC_MDELEM_STORAGE_INTERNED:
  335|       |    case GRPC_MDELEM_STORAGE_ALLOCATED:
  336|       |#ifndef NDEBUG
  337|       |      grpc_mdelem_do_unref(gmd, file, line);
  338|       |#else
  339|       |      grpc_mdelem_do_unref(gmd);
  340|       |#endif
  341|       |      return;
  342|       |  }
  343|       |}
  344|       |
  345|       |#define GRPC_MDNULL GRPC_MAKE_MDELEM(NULL, GRPC_MDELEM_STORAGE_EXTERNAL)
  346|       |#define GRPC_MDISNULL(md) (GRPC_MDELEM_DATA(md) == NULL)
  347|       |
  348|       |/* We add 32 bytes of padding as per RFC-7540 section 6.5.2. */
  349|       |#define GRPC_MDELEM_LENGTH(e)                                                  \
  350|       |  (GRPC_SLICE_LENGTH(GRPC_MDKEY((e))) + GRPC_SLICE_LENGTH(GRPC_MDVALUE((e))) + \
  351|       |   32)
  352|       |
  353|       |#define GRPC_MDSTR_KV_HASH(k_hash, v_hash) (GPR_ROTL((k_hash), 2) ^ (v_hash))
  354|       |
  355|       |void grpc_mdctx_global_init(void);
  356|       |void grpc_mdctx_global_shutdown();
  357|       |
  358|       |#endif /* GRPC_CORE_LIB_TRANSPORT_METADATA_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/transport/metadata_batch.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_TRANSPORT_METADATA_BATCH_H
   20|       |#define GRPC_CORE_LIB_TRANSPORT_METADATA_BATCH_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <stdbool.h>
   25|       |
   26|       |#include <grpc/grpc.h>
   27|       |#include <grpc/slice.h>
   28|       |#include <grpc/support/time.h>
   29|       |#include "src/core/lib/iomgr/exec_ctx.h"
   30|       |#include "src/core/lib/transport/metadata.h"
   31|       |#include "src/core/lib/transport/static_metadata.h"
   32|       |
   33|       |typedef struct grpc_linked_mdelem {
   34|      0|  grpc_linked_mdelem() {}
   35|       |
   36|       |  grpc_mdelem md;
   37|       |  struct grpc_linked_mdelem* next = nullptr;
   38|       |  struct grpc_linked_mdelem* prev = nullptr;
   39|       |  void* reserved;
   40|       |} grpc_linked_mdelem;
   41|       |
   42|       |typedef struct grpc_mdelem_list {
   43|       |  size_t count;
   44|       |  size_t default_count;  // Number of default keys.
   45|       |  grpc_linked_mdelem* head;
   46|       |  grpc_linked_mdelem* tail;
   47|       |} grpc_mdelem_list;
   48|       |
   49|       |typedef struct grpc_metadata_batch {
   50|       |  /** Metadata elements in this batch */
   51|       |  grpc_mdelem_list list;
   52|       |  grpc_metadata_batch_callouts idx;
   53|       |  /** Used to calculate grpc-timeout at the point of sending,
   54|       |      or GRPC_MILLIS_INF_FUTURE if this batch does not need to send a
   55|       |      grpc-timeout */
   56|       |  grpc_millis deadline;
   57|       |} grpc_metadata_batch;
   58|       |
   59|       |void grpc_metadata_batch_init(grpc_metadata_batch* batch);
   60|       |void grpc_metadata_batch_destroy(grpc_metadata_batch* batch);
   61|       |void grpc_metadata_batch_clear(grpc_metadata_batch* batch);
   62|       |bool grpc_metadata_batch_is_empty(grpc_metadata_batch* batch);
   63|       |
   64|       |/* Returns the transport size of the batch. */
   65|       |size_t grpc_metadata_batch_size(grpc_metadata_batch* batch);
   66|       |
   67|       |/** Remove \a storage from the batch, unreffing the mdelem contained */
   68|       |void grpc_metadata_batch_remove(grpc_metadata_batch* batch,
   69|       |                                grpc_linked_mdelem* storage);
   70|       |
   71|       |/** Substitute a new mdelem for an old value */
   72|       |grpc_error* grpc_metadata_batch_substitute(grpc_metadata_batch* batch,
   73|       |                                           grpc_linked_mdelem* storage,
   74|       |                                           grpc_mdelem new_value);
   75|       |
   76|       |void grpc_metadata_batch_set_value(grpc_linked_mdelem* storage,
   77|       |                                   const grpc_slice& value);
   78|       |
   79|       |/** Add \a storage to the beginning of \a batch. storage->md is
   80|       |    assumed to be valid.
   81|       |    \a storage is owned by the caller and must survive for the
   82|       |    lifetime of batch. This usually means it should be around
   83|       |    for the lifetime of the call. */
   84|       |grpc_error* grpc_metadata_batch_link_head(grpc_metadata_batch* batch,
   85|       |                                          grpc_linked_mdelem* storage)
   86|       |    GRPC_MUST_USE_RESULT;
   87|       |
   88|       |/** Add \a storage to the end of \a batch. storage->md is
   89|       |    assumed to be valid.
   90|       |    \a storage is owned by the caller and must survive for the
   91|       |    lifetime of batch. This usually means it should be around
   92|       |    for the lifetime of the call. */
   93|       |grpc_error* grpc_metadata_batch_link_tail(grpc_metadata_batch* batch,
   94|       |                                          grpc_linked_mdelem* storage)
   95|       |    GRPC_MUST_USE_RESULT;
   96|       |
   97|       |/** Add \a elem_to_add as the first element in \a batch, using
   98|       |    \a storage as backing storage for the linked list element.
   99|       |    \a storage is owned by the caller and must survive for the
  100|       |    lifetime of batch. This usually means it should be around
  101|       |    for the lifetime of the call.
  102|       |    Takes ownership of \a elem_to_add */
  103|       |grpc_error* grpc_metadata_batch_add_head(
  104|       |    grpc_metadata_batch* batch, grpc_linked_mdelem* storage,
  105|       |    grpc_mdelem elem_to_add) GRPC_MUST_USE_RESULT;
  106|       |
  107|       |/** Add \a elem_to_add as the last element in \a batch, using
  108|       |    \a storage as backing storage for the linked list element.
  109|       |    \a storage is owned by the caller and must survive for the
  110|       |    lifetime of batch. This usually means it should be around
  111|       |    for the lifetime of the call.
  112|       |    Takes ownership of \a elem_to_add */
  113|       |grpc_error* grpc_metadata_batch_add_tail(
  114|       |    grpc_metadata_batch* batch, grpc_linked_mdelem* storage,
  115|       |    grpc_mdelem elem_to_add) GRPC_MUST_USE_RESULT;
  116|       |
  117|       |grpc_error* grpc_attach_md_to_error(grpc_error* src, grpc_mdelem md);
  118|       |
  119|       |typedef struct {
  120|       |  grpc_error* error;
  121|       |  grpc_mdelem md;
  122|       |} grpc_filtered_mdelem;
  123|       |
  124|       |#define GRPC_FILTERED_ERROR(error) \
  125|       |  { (error), GRPC_MDNULL }
  126|       |#define GRPC_FILTERED_MDELEM(md) \
  127|       |  { GRPC_ERROR_NONE, (md) }
  128|       |#define GRPC_FILTERED_REMOVE() \
  129|       |  { GRPC_ERROR_NONE, GRPC_MDNULL }
  130|       |
  131|       |typedef grpc_filtered_mdelem (*grpc_metadata_batch_filter_func)(
  132|       |    void* user_data, grpc_mdelem elem);
  133|       |grpc_error* grpc_metadata_batch_filter(
  134|       |    grpc_metadata_batch* batch, grpc_metadata_batch_filter_func func,
  135|       |    void* user_data, const char* composite_error_string) GRPC_MUST_USE_RESULT;
  136|       |
  137|       |#ifndef NDEBUG
  138|       |void grpc_metadata_batch_assert_ok(grpc_metadata_batch* comd);
  139|       |#else
  140|       |#define grpc_metadata_batch_assert_ok(comd) \
  141|       |  do {                                      \
  142|       |  } while (0)
  143|       |#endif
  144|       |
  145|       |/// Copies \a src to \a dst.  \a storage must point to an array of
  146|       |/// \a grpc_linked_mdelem structs of at least the same size as \a src.
  147|       |void grpc_metadata_batch_copy(grpc_metadata_batch* src,
  148|       |                              grpc_metadata_batch* dst,
  149|       |                              grpc_linked_mdelem* storage);
  150|       |
  151|       |void grpc_metadata_batch_move(grpc_metadata_batch* src,
  152|       |                              grpc_metadata_batch* dst);
  153|       |
  154|       |#endif /* GRPC_CORE_LIB_TRANSPORT_METADATA_BATCH_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/lib/transport/transport.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_LIB_TRANSPORT_TRANSPORT_H
   20|       |#define GRPC_CORE_LIB_TRANSPORT_TRANSPORT_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include <stddef.h>
   25|       |
   26|       |#include "src/core/lib/channel/context.h"
   27|       |#include "src/core/lib/gprpp/arena.h"
   28|       |#include "src/core/lib/iomgr/call_combiner.h"
   29|       |#include "src/core/lib/iomgr/endpoint.h"
   30|       |#include "src/core/lib/iomgr/polling_entity.h"
   31|       |#include "src/core/lib/iomgr/pollset.h"
   32|       |#include "src/core/lib/iomgr/pollset_set.h"
   33|       |#include "src/core/lib/slice/slice_internal.h"
   34|       |#include "src/core/lib/transport/byte_stream.h"
   35|       |#include "src/core/lib/transport/metadata_batch.h"
   36|       |
   37|       |/* Minimum and maximum protocol accepted versions. */
   38|       |#define GRPC_PROTOCOL_VERSION_MAX_MAJOR 2
   39|       |#define GRPC_PROTOCOL_VERSION_MAX_MINOR 1
   40|       |#define GRPC_PROTOCOL_VERSION_MIN_MAJOR 2
   41|       |#define GRPC_PROTOCOL_VERSION_MIN_MINOR 1
   42|       |
   43|       |/* forward declarations */
   44|       |
   45|       |typedef struct grpc_transport grpc_transport;
   46|       |
   47|       |/* grpc_stream doesn't actually exist. It's used as a typesafe
   48|       |   opaque pointer for whatever data the transport wants to track
   49|       |   for a stream. */
   50|       |typedef struct grpc_stream grpc_stream;
   51|       |
   52|       |extern grpc_core::DebugOnlyTraceFlag grpc_trace_stream_refcount;
   53|       |
   54|       |typedef struct grpc_stream_refcount {
   55|       |  grpc_core::RefCount refs;
   56|       |  grpc_closure destroy;
   57|       |#ifndef NDEBUG
   58|       |  const char* object_type;
   59|       |#endif
   60|       |  grpc_slice_refcount slice_refcount;
   61|       |} grpc_stream_refcount;
   62|       |
   63|       |#ifndef NDEBUG
   64|       |void grpc_stream_ref_init(grpc_stream_refcount* refcount, int initial_refs,
   65|       |                          grpc_iomgr_cb_func cb, void* cb_arg,
   66|       |                          const char* object_type);
   67|       |#define GRPC_STREAM_REF_INIT(rc, ir, cb, cb_arg, objtype) \
   68|       |  grpc_stream_ref_init(rc, ir, cb, cb_arg, objtype)
   69|       |#else
   70|       |void grpc_stream_ref_init(grpc_stream_refcount* refcount, int initial_refs,
   71|       |                          grpc_iomgr_cb_func cb, void* cb_arg);
   72|       |#define GRPC_STREAM_REF_INIT(rc, ir, cb, cb_arg, objtype) \
   73|       |  grpc_stream_ref_init(rc, ir, cb, cb_arg)
   74|       |#endif
   75|       |
   76|       |#ifndef NDEBUG
   77|       |inline void grpc_stream_ref(grpc_stream_refcount* refcount,
   78|       |                            const char* reason) {
   79|       |  if (grpc_trace_stream_refcount.enabled()) {
   80|       |    gpr_log(GPR_DEBUG, "%s %p:%p REF %s", refcount->object_type, refcount,
   81|       |            refcount->destroy.cb_arg, reason);
   82|       |  }
   83|       |#else
   84|       |inline void grpc_stream_ref(grpc_stream_refcount* refcount) {
   85|       |#endif
   86|       |  refcount->refs.RefNonZero();
   87|       |}
   88|       |
   89|       |void grpc_stream_destroy(grpc_stream_refcount* refcount);
   90|       |
   91|       |#ifndef NDEBUG
   92|       |inline void grpc_stream_unref(grpc_stream_refcount* refcount,
   93|       |                              const char* reason) {
   94|       |  if (grpc_trace_stream_refcount.enabled()) {
   95|       |    gpr_log(GPR_DEBUG, "%s %p:%p UNREF %s", refcount->object_type, refcount,
   96|       |            refcount->destroy.cb_arg, reason);
   97|       |  }
   98|       |#else
   99|       |inline void grpc_stream_unref(grpc_stream_refcount* refcount) {
  100|       |#endif
  101|       |  if (GPR_UNLIKELY(refcount->refs.Unref())) {
  102|       |    grpc_stream_destroy(refcount);
  103|       |  }
  104|       |}
  105|       |
  106|       |/* Wrap a buffer that is owned by some stream object into a slice that shares
  107|       |   the same refcount */
  108|       |grpc_slice grpc_slice_from_stream_owned_buffer(grpc_stream_refcount* refcount,
  109|       |                                               void* buffer, size_t length);
  110|       |
  111|       |struct grpc_transport_one_way_stats {
  112|       |  uint64_t framing_bytes = 0;
  113|       |  uint64_t data_bytes = 0;
  114|       |  uint64_t header_bytes = 0;
  115|       |};
  116|       |
  117|       |struct grpc_transport_stream_stats {
  118|       |  grpc_transport_one_way_stats incoming;
  119|       |  grpc_transport_one_way_stats outgoing;
  120|       |};
  121|       |
  122|       |void grpc_transport_move_one_way_stats(grpc_transport_one_way_stats* from,
  123|       |                                       grpc_transport_one_way_stats* to);
  124|       |
  125|       |void grpc_transport_move_stats(grpc_transport_stream_stats* from,
  126|       |                               grpc_transport_stream_stats* to);
  127|       |
  128|       |// This struct (which is present in both grpc_transport_stream_op_batch
  129|       |// and grpc_transport_op_batch) is a convenience to allow filters or
  130|       |// transports to schedule a closure related to a particular batch without
  131|       |// having to allocate memory.  The general pattern is to initialize the
  132|       |// closure with the callback arg set to the batch and extra_arg set to
  133|       |// whatever state is associated with the handler (e.g., the call element
  134|       |// or the transport stream object).
  135|       |//
  136|       |// Note that this can only be used by the current handler of a given
  137|       |// batch on the way down the stack (i.e., whichever filter or transport is
  138|       |// currently handling the batch).  Once a filter or transport passes control
  139|       |// of the batch to the next handler, it cannot depend on the contents of
  140|       |// this struct anymore, because the next handler may reuse it.
  141|       |struct grpc_handler_private_op_data {
  142|       |  void* extra_arg = nullptr;
  143|       |  grpc_closure closure;
  144|      0|  grpc_handler_private_op_data() { memset(&closure, 0, sizeof(closure)); }
  145|       |};
  146|       |
  147|       |typedef struct grpc_transport_stream_op_batch_payload
  148|       |    grpc_transport_stream_op_batch_payload;
  149|       |
  150|       |/* Transport stream op: a set of operations to perform on a transport
  151|       |   against a single stream */
  152|       |struct grpc_transport_stream_op_batch {
  153|       |  grpc_transport_stream_op_batch()
  154|       |      : send_initial_metadata(false),
  155|       |        send_trailing_metadata(false),
  156|       |        send_message(false),
  157|       |        recv_initial_metadata(false),
  158|       |        recv_message(false),
  159|       |        recv_trailing_metadata(false),
  160|       |        cancel_stream(false),
  161|      0|        is_traced(false) {}
  162|       |
  163|       |  /** Should be scheduled when all of the non-recv operations in the batch
  164|       |      are complete.
  165|       |
  166|       |      The recv ops (recv_initial_metadata, recv_message, and
  167|       |      recv_trailing_metadata) each have their own callbacks.  If a batch
  168|       |      contains both recv ops and non-recv ops, on_complete should be
  169|       |      scheduled as soon as the non-recv ops are complete, regardless of
  170|       |      whether or not the recv ops are complete.  If a batch contains
  171|       |      only recv ops, on_complete can be null. */
  172|       |  grpc_closure* on_complete = nullptr;
  173|       |
  174|       |  /** Values for the stream op (fields set are determined by flags above) */
  175|       |  grpc_transport_stream_op_batch_payload* payload = nullptr;
  176|       |
  177|       |  /** Send initial metadata to the peer, from the provided metadata batch. */
  178|       |  bool send_initial_metadata : 1;
  179|       |
  180|       |  /** Send trailing metadata to the peer, from the provided metadata batch. */
  181|       |  bool send_trailing_metadata : 1;
  182|       |
  183|       |  /** Send message data to the peer, from the provided byte stream. */
  184|       |  bool send_message : 1;
  185|       |
  186|       |  /** Receive initial metadata from the stream, into provided metadata batch. */
  187|       |  bool recv_initial_metadata : 1;
  188|       |
  189|       |  /** Receive message data from the stream, into provided byte stream. */
  190|       |  bool recv_message : 1;
  191|       |
  192|       |  /** Receive trailing metadata from the stream, into provided metadata batch.
  193|       |   */
  194|       |  bool recv_trailing_metadata : 1;
  195|       |
  196|       |  /** Cancel this stream with the provided error */
  197|       |  bool cancel_stream : 1;
  198|       |
  199|       |  /** Is this stream traced */
  200|       |  bool is_traced : 1;
  201|       |
  202|       |  /***************************************************************************
  203|       |   * remaining fields are initialized and used at the discretion of the
  204|       |   * current handler of the op */
  205|       |
  206|       |  grpc_handler_private_op_data handler_private;
  207|       |};
  208|       |
  209|       |struct grpc_transport_stream_op_batch_payload {
  210|       |  explicit grpc_transport_stream_op_batch_payload(
  211|       |      grpc_call_context_element* context)
  212|      0|      : context(context) {}
  213|      0|  ~grpc_transport_stream_op_batch_payload() {
  214|      0|    // We don't really own `send_message`, so release ownership and let the
  215|      0|    // owner clean the data.
  216|      0|    send_message.send_message.release();
  217|      0|  }
  218|       |
  219|       |  struct {
  220|       |    grpc_metadata_batch* send_initial_metadata = nullptr;
  221|       |    /** Iff send_initial_metadata != NULL, flags associated with
  222|       |        send_initial_metadata: a bitfield of GRPC_INITIAL_METADATA_xxx */
  223|       |    uint32_t send_initial_metadata_flags = 0;
  224|       |    // If non-NULL, will be set by the transport to the peer string (a char*).
  225|       |    // The transport retains ownership of the string.
  226|       |    // Note: This pointer may be used by the transport after the
  227|       |    // send_initial_metadata op is completed.  It must remain valid
  228|       |    // until the call is destroyed.
  229|       |    gpr_atm* peer_string = nullptr;
  230|       |  } send_initial_metadata;
  231|       |
  232|       |  struct {
  233|       |    grpc_metadata_batch* send_trailing_metadata = nullptr;
  234|       |  } send_trailing_metadata;
  235|       |
  236|       |  struct {
  237|       |    // The transport (or a filter that decides to return a failure before
  238|       |    // the op gets down to the transport) takes ownership.
  239|       |    // The batch's on_complete will not be called until after the byte
  240|       |    // stream is orphaned.
  241|       |    grpc_core::OrphanablePtr<grpc_core::ByteStream> send_message;
  242|       |  } send_message;
  243|       |
  244|       |  struct {
  245|       |    grpc_metadata_batch* recv_initial_metadata = nullptr;
  246|       |    // Flags are used only on the server side.  If non-null, will be set to
  247|       |    // a bitfield of the GRPC_INITIAL_METADATA_xxx macros (e.g., to
  248|       |    // indicate if the call is idempotent).
  249|       |    uint32_t* recv_flags = nullptr;
  250|       |    /** Should be enqueued when initial metadata is ready to be processed. */
  251|       |    grpc_closure* recv_initial_metadata_ready = nullptr;
  252|       |    // If not NULL, will be set to true if trailing metadata is
  253|       |    // immediately available.  This may be a signal that we received a
  254|       |    // Trailers-Only response.
  255|       |    bool* trailing_metadata_available = nullptr;
  256|       |    // If non-NULL, will be set by the transport to the peer string (a char*).
  257|       |    // The transport retains ownership of the string.
  258|       |    // Note: This pointer may be used by the transport after the
  259|       |    // recv_initial_metadata op is completed.  It must remain valid
  260|       |    // until the call is destroyed.
  261|       |    gpr_atm* peer_string = nullptr;
  262|       |  } recv_initial_metadata;
  263|       |
  264|       |  struct {
  265|       |    // Will be set by the transport to point to the byte stream
  266|       |    // containing a received message.
  267|       |    // Will be NULL if trailing metadata is received instead of a message.
  268|       |    grpc_core::OrphanablePtr<grpc_core::ByteStream>* recv_message = nullptr;
  269|       |    /** Should be enqueued when one message is ready to be processed. */
  270|       |    grpc_closure* recv_message_ready = nullptr;
  271|       |  } recv_message;
  272|       |
  273|       |  struct {
  274|       |    grpc_metadata_batch* recv_trailing_metadata = nullptr;
  275|       |    grpc_transport_stream_stats* collect_stats = nullptr;
  276|       |    /** Should be enqueued when initial metadata is ready to be processed. */
  277|       |    grpc_closure* recv_trailing_metadata_ready = nullptr;
  278|       |  } recv_trailing_metadata;
  279|       |
  280|       |  /** Forcefully close this stream.
  281|       |      The HTTP2 semantics should be:
  282|       |      - server side: if cancel_error has GRPC_ERROR_INT_GRPC_STATUS, and
  283|       |        trailing metadata has not been sent, send trailing metadata with status
  284|       |        and message from cancel_error (use grpc_error_get_status) followed by
  285|       |        a RST_STREAM with error=GRPC_CHTTP2_NO_ERROR to force a full close
  286|       |      - at all other times: use grpc_error_get_status to get a status code, and
  287|       |        convert to a HTTP2 error code using
  288|       |        grpc_chttp2_grpc_status_to_http2_error. Send a RST_STREAM with this
  289|       |        error. */
  290|       |  struct {
  291|       |    // Error contract: the transport that gets this op must cause cancel_error
  292|       |    //                 to be unref'ed after processing it
  293|       |    grpc_error* cancel_error = GRPC_ERROR_NONE;
  294|       |  } cancel_stream;
  295|       |
  296|       |  /* Indexes correspond to grpc_context_index enum values */
  297|       |  grpc_call_context_element* context;
  298|       |};
  299|       |
  300|       |/** Transport op: a set of operations to perform on a transport as a whole */
  301|       |typedef struct grpc_transport_op {
  302|       |  /** Called when processing of this op is done. */
  303|       |  grpc_closure* on_consumed = nullptr;
  304|       |  /** connectivity monitoring - set connectivity_state to NULL to unsubscribe */
  305|       |  grpc_closure* on_connectivity_state_change = nullptr;
  306|       |  grpc_connectivity_state* connectivity_state = nullptr;
  307|       |  /** should the transport be disconnected
  308|       |   * Error contract: the transport that gets this op must cause
  309|       |   *                 disconnect_with_error to be unref'ed after processing it */
  310|       |  grpc_error* disconnect_with_error = nullptr;
  311|       |  /** what should the goaway contain?
  312|       |   * Error contract: the transport that gets this op must cause
  313|       |   *                 goaway_error to be unref'ed after processing it */
  314|       |  grpc_error* goaway_error = nullptr;
  315|       |  /** set the callback for accepting new streams;
  316|       |      this is a permanent callback, unlike the other one-shot closures.
  317|       |      If true, the callback is set to set_accept_stream_fn, with its
  318|       |      user_data argument set to set_accept_stream_user_data */
  319|       |  bool set_accept_stream = false;
  320|       |  void (*set_accept_stream_fn)(void* user_data, grpc_transport* transport,
  321|       |                               const void* server_data) = nullptr;
  322|       |  void* set_accept_stream_user_data = nullptr;
  323|       |  /** add this transport to a pollset */
  324|       |  grpc_pollset* bind_pollset = nullptr;
  325|       |  /** add this transport to a pollset_set */
  326|       |  grpc_pollset_set* bind_pollset_set = nullptr;
  327|       |  /** send a ping, if either on_initiate or on_ack is not NULL */
  328|       |  struct {
  329|       |    /** Ping may be delayed by the transport, on_initiate callback will be
  330|       |        called when the ping is actually being sent. */
  331|       |    grpc_closure* on_initiate = nullptr;
  332|       |    /** Called when the ping ack is received */
  333|       |    grpc_closure* on_ack = nullptr;
  334|       |  } send_ping;
  335|       |  // If true, will reset the channel's connection backoff.
  336|       |  bool reset_connect_backoff = false;
  337|       |
  338|       |  /***************************************************************************
  339|       |   * remaining fields are initialized and used at the discretion of the
  340|       |   * transport implementation */
  341|       |
  342|       |  grpc_handler_private_op_data handler_private;
  343|       |} grpc_transport_op;
  344|       |
  345|       |/* Returns the amount of memory required to store a grpc_stream for this
  346|       |   transport */
  347|       |size_t grpc_transport_stream_size(grpc_transport* transport);
  348|       |
  349|       |/* Initialize transport data for a stream.
  350|       |
  351|       |   Returns 0 on success, any other (transport-defined) value for failure.
  352|       |   May assume that stream contains all-zeros.
  353|       |
  354|       |   Arguments:
  355|       |     transport   - the transport on which to create this stream
  356|       |     stream      - a pointer to uninitialized memory to initialize
  357|       |     server_data - either NULL for a client initiated stream, or a pointer
  358|       |                   supplied from the accept_stream callback function */
  359|       |int grpc_transport_init_stream(grpc_transport* transport, grpc_stream* stream,
  360|       |                               grpc_stream_refcount* refcount,
  361|       |                               const void* server_data,
  362|       |                               grpc_core::Arena* arena);
  363|       |
  364|       |void grpc_transport_set_pops(grpc_transport* transport, grpc_stream* stream,
  365|       |                             grpc_polling_entity* pollent);
  366|       |
  367|       |/* Destroy transport data for a stream.
  368|       |
  369|       |   Requires: a recv_batch with final_state == GRPC_STREAM_CLOSED has been
  370|       |   received by the up-layer. Must not be called in the same call stack as
  371|       |   recv_frame.
  372|       |
  373|       |   Arguments:
  374|       |     transport - the transport on which to create this stream
  375|       |     stream    - the grpc_stream to destroy (memory is still owned by the
  376|       |                 caller, but any child memory must be cleaned up) */
  377|       |void grpc_transport_destroy_stream(grpc_transport* transport,
  378|       |                                   grpc_stream* stream,
  379|       |                                   grpc_closure* then_schedule_closure);
  380|       |
  381|       |void grpc_transport_stream_op_batch_finish_with_failure(
  382|       |    grpc_transport_stream_op_batch* op, grpc_error* error,
  383|       |    grpc_core::CallCombiner* call_combiner);
  384|       |
  385|       |char* grpc_transport_stream_op_batch_string(grpc_transport_stream_op_batch* op);
  386|       |char* grpc_transport_op_string(grpc_transport_op* op);
  387|       |
  388|       |/* Send a batch of operations on a transport
  389|       |
  390|       |   Takes ownership of any objects contained in ops.
  391|       |
  392|       |   Arguments:
  393|       |     transport - the transport on which to initiate the stream
  394|       |     stream    - the stream on which to send the operations. This must be
  395|       |                 non-NULL and previously initialized by the same transport.
  396|       |     op        - a grpc_transport_stream_op_batch specifying the op to perform
  397|       |   */
  398|       |void grpc_transport_perform_stream_op(grpc_transport* transport,
  399|       |                                      grpc_stream* stream,
  400|       |                                      grpc_transport_stream_op_batch* op);
  401|       |
  402|       |void grpc_transport_perform_op(grpc_transport* transport,
  403|       |                               grpc_transport_op* op);
  404|       |
  405|       |/* Send a ping on a transport
  406|       |
  407|       |   Calls cb with user data when a response is received. */
  408|       |void grpc_transport_ping(grpc_transport* transport, grpc_closure* cb);
  409|       |
  410|       |/* Advise peer of pending connection termination. */
  411|       |void grpc_transport_goaway(grpc_transport* transport, grpc_status_code status,
  412|       |                           grpc_slice debug_data);
  413|       |
  414|       |/* Destroy the transport */
  415|       |void grpc_transport_destroy(grpc_transport* transport);
  416|       |
  417|       |/* Get the endpoint used by \a transport */
  418|       |grpc_endpoint* grpc_transport_get_endpoint(grpc_transport* transport);
  419|       |
  420|       |/* Allocate a grpc_transport_op, and preconfigure the on_consumed closure to
  421|       |   \a on_consumed and then delete the returned transport op */
  422|       |grpc_transport_op* grpc_make_transport_op(grpc_closure* on_consumed);
  423|       |/* Allocate a grpc_transport_stream_op_batch, and preconfigure the on_consumed
  424|       |   closure
  425|       |   to \a on_consumed and then delete the returned transport op */
  426|       |grpc_transport_stream_op_batch* grpc_make_transport_stream_op(
  427|       |    grpc_closure* on_consumed);
  428|       |
  429|       |#endif /* GRPC_CORE_LIB_TRANSPORT_TRANSPORT_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/core/tsi/ssl_transport_security.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_H
   20|       |#define GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_H
   21|       |
   22|       |#include <grpc/support/port_platform.h>
   23|       |
   24|       |#include "src/core/tsi/transport_security_interface.h"
   25|       |
   26|       |/* Value for the TSI_CERTIFICATE_TYPE_PEER_PROPERTY property for X509 certs. */
   27|       |#define TSI_X509_CERTIFICATE_TYPE "X509"
   28|       |
   29|       |/* This property is of type TSI_PEER_PROPERTY_STRING.  */
   30|       |#define TSI_X509_SUBJECT_COMMON_NAME_PEER_PROPERTY "x509_subject_common_name"
   31|       |#define TSI_X509_SUBJECT_ALTERNATIVE_NAME_PEER_PROPERTY \
   32|       |  "x509_subject_alternative_name"
   33|       |#define TSI_SSL_SESSION_REUSED_PEER_PROPERTY "ssl_session_reused"
   34|       |
   35|       |#define TSI_X509_PEM_CERT_PROPERTY "x509_pem_cert"
   36|       |
   37|       |#define TSI_SSL_ALPN_SELECTED_PROTOCOL "ssl_alpn_selected_protocol"
   38|       |
   39|       |/* --- tsi_ssl_root_certs_store object ---
   40|       |
   41|       |   This object stores SSL root certificates. It can be shared by multiple SSL
   42|       |   context. */
   43|       |typedef struct tsi_ssl_root_certs_store tsi_ssl_root_certs_store;
   44|       |
   45|       |/* Given a NULL-terminated string containing the PEM encoding of the root
   46|       |   certificates, creates a tsi_ssl_root_certs_store object. */
   47|       |tsi_ssl_root_certs_store* tsi_ssl_root_certs_store_create(
   48|       |    const char* pem_roots);
   49|       |
   50|       |/* Destroys the tsi_ssl_root_certs_store object. */
   51|       |void tsi_ssl_root_certs_store_destroy(tsi_ssl_root_certs_store* self);
   52|       |
   53|       |/* --- tsi_ssl_session_cache object ---
   54|       |
   55|       |   Cache for SSL sessions for sessions resumption.  */
   56|       |
   57|       |typedef struct tsi_ssl_session_cache tsi_ssl_session_cache;
   58|       |
   59|       |/* Create LRU cache for SSL sessions with \a capacity.  */
   60|       |tsi_ssl_session_cache* tsi_ssl_session_cache_create_lru(size_t capacity);
   61|       |
   62|       |/* Increment reference counter of \a cache.  */
   63|       |void tsi_ssl_session_cache_ref(tsi_ssl_session_cache* cache);
   64|       |
   65|       |/* Decrement reference counter of \a cache.  */
   66|       |void tsi_ssl_session_cache_unref(tsi_ssl_session_cache* cache);
   67|       |
   68|       |/* --- tsi_ssl_client_handshaker_factory object ---
   69|       |
   70|       |   This object creates a client tsi_handshaker objects implemented in terms of
   71|       |   the TLS 1.2 specificiation.  */
   72|       |
   73|       |typedef struct tsi_ssl_client_handshaker_factory
   74|       |    tsi_ssl_client_handshaker_factory;
   75|       |
   76|       |/* Object that holds a private key / certificate chain pair in PEM format. */
   77|       |typedef struct {
   78|       |  /* private_key is the NULL-terminated string containing the PEM encoding of
   79|       |     the client's private key. */
   80|       |  const char* private_key;
   81|       |
   82|       |  /* cert_chain is the NULL-terminated string containing the PEM encoding of
   83|       |     the client's certificate chain. */
   84|       |  const char* cert_chain;
   85|       |} tsi_ssl_pem_key_cert_pair;
   86|       |
   87|       |/* TO BE DEPRECATED.
   88|       |   Creates a client handshaker factory.
   89|       |   - pem_key_cert_pair is a pointer to the object containing client's private
   90|       |     key and certificate chain. This parameter can be NULL if the client does
   91|       |     not have such a key/cert pair.
   92|       |   - pem_roots_cert is the NULL-terminated string containing the PEM encoding of
   93|       |     the server root certificates.
   94|       |   - cipher_suites contains an optional list of the ciphers that the client
   95|       |     supports. The format of this string is described in:
   96|       |     https://www.openssl.org/docs/apps/ciphers.html.
   97|       |     This parameter can be set to NULL to use the default set of ciphers.
   98|       |     TODO(jboeuf): Revisit the format of this parameter.
   99|       |   - alpn_protocols is an array containing the NULL terminated protocol names
  100|       |     that the handshakers created with this factory support. This parameter can
  101|       |     be NULL.
  102|       |   - num_alpn_protocols is the number of alpn protocols and associated lengths
  103|       |     specified. If this parameter is 0, the other alpn parameters must be NULL.
  104|       |   - factory is the address of the factory pointer to be created.
  105|       |
  106|       |   - This method returns TSI_OK on success or TSI_INVALID_PARAMETER in the case
  107|       |     where a parameter is invalid.  */
  108|       |tsi_result tsi_create_ssl_client_handshaker_factory(
  109|       |    const tsi_ssl_pem_key_cert_pair* pem_key_cert_pair,
  110|       |    const char* pem_root_certs, const char* cipher_suites,
  111|       |    const char** alpn_protocols, uint16_t num_alpn_protocols,
  112|       |    tsi_ssl_client_handshaker_factory** factory);
  113|       |
  114|       |struct tsi_ssl_client_handshaker_options {
  115|       |  /* pem_key_cert_pair is a pointer to the object containing client's private
  116|       |     key and certificate chain. This parameter can be NULL if the client does
  117|       |     not have such a key/cert pair. */
  118|       |  const tsi_ssl_pem_key_cert_pair* pem_key_cert_pair;
  119|       |  /* pem_roots_cert is the NULL-terminated string containing the PEM encoding of
  120|       |     the client root certificates. */
  121|       |  const char* pem_root_certs;
  122|       |  /* root_store is a pointer to the ssl_root_certs_store object. If root_store
  123|       |    is not nullptr and SSL implementation permits, root_store will be used as
  124|       |    root certificates. Otherwise, pem_roots_cert will be used to load server
  125|       |    root certificates. */
  126|       |  const tsi_ssl_root_certs_store* root_store;
  127|       |  /* cipher_suites contains an optional list of the ciphers that the client
  128|       |     supports. The format of this string is described in:
  129|       |     https://www.openssl.org/docs/apps/ciphers.html.
  130|       |     This parameter can be set to NULL to use the default set of ciphers.
  131|       |     TODO(jboeuf): Revisit the format of this parameter. */
  132|       |  const char* cipher_suites;
  133|       |  /* alpn_protocols is an array containing the NULL terminated protocol names
  134|       |     that the handshakers created with this factory support. This parameter can
  135|       |     be NULL. */
  136|       |  const char** alpn_protocols;
  137|       |  /* num_alpn_protocols is the number of alpn protocols and associated lengths
  138|       |     specified. If this parameter is 0, the other alpn parameters must be
  139|       |     NULL. */
  140|       |  size_t num_alpn_protocols;
  141|       |  /* ssl_session_cache is a cache for reusable client-side sessions. */
  142|       |  tsi_ssl_session_cache* session_cache;
  143|       |
  144|       |  tsi_ssl_client_handshaker_options()
  145|       |      : pem_key_cert_pair(nullptr),
  146|       |        pem_root_certs(nullptr),
  147|       |        root_store(nullptr),
  148|       |        cipher_suites(nullptr),
  149|       |        alpn_protocols(nullptr),
  150|       |        num_alpn_protocols(0),
  151|      0|        session_cache(nullptr) {}
  152|       |};
  153|       |
  154|       |/* Creates a client handshaker factory.
  155|       |   - options is the options used to create a factory.
  156|       |   - factory is the address of the factory pointer to be created.
  157|       |
  158|       |   - This method returns TSI_OK on success or TSI_INVALID_PARAMETER in the case
  159|       |     where a parameter is invalid. */
  160|       |tsi_result tsi_create_ssl_client_handshaker_factory_with_options(
  161|       |    const tsi_ssl_client_handshaker_options* options,
  162|       |    tsi_ssl_client_handshaker_factory** factory);
  163|       |
  164|       |/* Creates a client handshaker.
  165|       |  - self is the factory from which the handshaker will be created.
  166|       |  - server_name_indication indicates the name of the server the client is
  167|       |    trying to connect to which will be relayed to the server using the SNI
  168|       |    extension.
  169|       |  - handshaker is the address of the handshaker pointer to be created.
  170|       |
  171|       |  - This method returns TSI_OK on success or TSI_INVALID_PARAMETER in the case
  172|       |    where a parameter is invalid.  */
  173|       |tsi_result tsi_ssl_client_handshaker_factory_create_handshaker(
  174|       |    tsi_ssl_client_handshaker_factory* self, const char* server_name_indication,
  175|       |    tsi_handshaker** handshaker);
  176|       |
  177|       |/* Decrements reference count of the handshaker factory. Handshaker factory will
  178|       | * be destroyed once no references exist. */
  179|       |void tsi_ssl_client_handshaker_factory_unref(
  180|       |    tsi_ssl_client_handshaker_factory* factory);
  181|       |
  182|       |/* --- tsi_ssl_server_handshaker_factory object ---
  183|       |
  184|       |   This object creates a client tsi_handshaker objects implemented in terms of
  185|       |   the TLS 1.2 specificiation.  */
  186|       |
  187|       |typedef struct tsi_ssl_server_handshaker_factory
  188|       |    tsi_ssl_server_handshaker_factory;
  189|       |
  190|       |/* TO BE DEPRECATED.
  191|       |   Creates a server handshaker factory.
  192|       |   - pem_key_cert_pairs is an array private key / certificate chains of the
  193|       |     server.
  194|       |   - num_key_cert_pairs is the number of items in the pem_key_cert_pairs array.
  195|       |   - pem_root_certs is the NULL-terminated string containing the PEM encoding
  196|       |     of the client root certificates. This parameter may be NULL if the server
  197|       |     does not want the client to be authenticated with SSL.
  198|       |   - cipher_suites contains an optional list of the ciphers that the server
  199|       |     supports. The format of this string is described in:
  200|       |     https://www.openssl.org/docs/apps/ciphers.html.
  201|       |     This parameter can be set to NULL to use the default set of ciphers.
  202|       |     TODO(jboeuf): Revisit the format of this parameter.
  203|       |   - alpn_protocols is an array containing the NULL terminated protocol names
  204|       |     that the handshakers created with this factory support. This parameter can
  205|       |     be NULL.
  206|       |   - num_alpn_protocols is the number of alpn protocols and associated lengths
  207|       |     specified. If this parameter is 0, the other alpn parameters must be NULL.
  208|       |   - factory is the address of the factory pointer to be created.
  209|       |
  210|       |   - This method returns TSI_OK on success or TSI_INVALID_PARAMETER in the case
  211|       |     where a parameter is invalid.  */
  212|       |tsi_result tsi_create_ssl_server_handshaker_factory(
  213|       |    const tsi_ssl_pem_key_cert_pair* pem_key_cert_pairs,
  214|       |    size_t num_key_cert_pairs, const char* pem_client_root_certs,
  215|       |    int force_client_auth, const char* cipher_suites,
  216|       |    const char** alpn_protocols, uint16_t num_alpn_protocols,
  217|       |    tsi_ssl_server_handshaker_factory** factory);
  218|       |
  219|       |/* TO BE DEPRECATED.
  220|       |   Same as tsi_create_ssl_server_handshaker_factory method except uses
  221|       |   tsi_client_certificate_request_type to support more ways to handle client
  222|       |   certificate authentication.
  223|       |   - client_certificate_request, if set to non-zero will force the client to
  224|       |     authenticate with an SSL cert. Note that this option is ignored if
  225|       |     pem_client_root_certs is NULL or pem_client_roots_certs_size is 0 */
  226|       |tsi_result tsi_create_ssl_server_handshaker_factory_ex(
  227|       |    const tsi_ssl_pem_key_cert_pair* pem_key_cert_pairs,
  228|       |    size_t num_key_cert_pairs, const char* pem_client_root_certs,
  229|       |    tsi_client_certificate_request_type client_certificate_request,
  230|       |    const char* cipher_suites, const char** alpn_protocols,
  231|       |    uint16_t num_alpn_protocols, tsi_ssl_server_handshaker_factory** factory);
  232|       |
  233|       |struct tsi_ssl_server_handshaker_options {
  234|       |  /* pem_key_cert_pairs is an array private key / certificate chains of the
  235|       |     server. */
  236|       |  const tsi_ssl_pem_key_cert_pair* pem_key_cert_pairs;
  237|       |  /* num_key_cert_pairs is the number of items in the pem_key_cert_pairs
  238|       |     array. */
  239|       |  size_t num_key_cert_pairs;
  240|       |  /* pem_root_certs is the NULL-terminated string containing the PEM encoding
  241|       |     of the server root certificates. This parameter may be NULL if the server
  242|       |     does not want the client to be authenticated with SSL. */
  243|       |  const char* pem_client_root_certs;
  244|       |  /* client_certificate_request, if set to non-zero will force the client to
  245|       |     authenticate with an SSL cert. Note that this option is ignored if
  246|       |     pem_client_root_certs is NULL or pem_client_roots_certs_size is 0. */
  247|       |  tsi_client_certificate_request_type client_certificate_request;
  248|       |  /* cipher_suites contains an optional list of the ciphers that the server
  249|       |     supports. The format of this string is described in:
  250|       |     https://www.openssl.org/docs/apps/ciphers.html.
  251|       |     This parameter can be set to NULL to use the default set of ciphers.
  252|       |     TODO(jboeuf): Revisit the format of this parameter. */
  253|       |  const char* cipher_suites;
  254|       |  /* alpn_protocols is an array containing the NULL terminated protocol names
  255|       |     that the handshakers created with this factory support. This parameter can
  256|       |     be NULL. */
  257|       |  const char** alpn_protocols;
  258|       |  /* num_alpn_protocols is the number of alpn protocols and associated lengths
  259|       |     specified. If this parameter is 0, the other alpn parameters must be
  260|       |     NULL. */
  261|       |  uint16_t num_alpn_protocols;
  262|       |  /* session_ticket_key is optional key for encrypting session keys. If paramter
  263|       |     is not specified it must be NULL. */
  264|       |  const char* session_ticket_key;
  265|       |  /* session_ticket_key_size is a size of session ticket encryption key. */
  266|       |  size_t session_ticket_key_size;
  267|       |
  268|       |  tsi_ssl_server_handshaker_options()
  269|       |      : pem_key_cert_pairs(nullptr),
  270|       |        num_key_cert_pairs(0),
  271|       |        pem_client_root_certs(nullptr),
  272|       |        client_certificate_request(TSI_DONT_REQUEST_CLIENT_CERTIFICATE),
  273|       |        cipher_suites(nullptr),
  274|       |        alpn_protocols(nullptr),
  275|       |        num_alpn_protocols(0),
  276|       |        session_ticket_key(nullptr),
  277|      0|        session_ticket_key_size(0) {}
  278|       |};
  279|       |
  280|       |/* Creates a server handshaker factory.
  281|       |   - options is the options used to create a factory.
  282|       |   - factory is the address of the factory pointer to be created.
  283|       |
  284|       |   - This method returns TSI_OK on success or TSI_INVALID_PARAMETER in the case
  285|       |     where a parameter is invalid. */
  286|       |tsi_result tsi_create_ssl_server_handshaker_factory_with_options(
  287|       |    const tsi_ssl_server_handshaker_options* options,
  288|       |    tsi_ssl_server_handshaker_factory** factory);
  289|       |
  290|       |/* Creates a server handshaker.
  291|       |  - self is the factory from which the handshaker will be created.
  292|       |  - handshaker is the address of the handshaker pointer to be created.
  293|       |
  294|       |  - This method returns TSI_OK on success or TSI_INVALID_PARAMETER in the case
  295|       |    where a parameter is invalid.  */
  296|       |tsi_result tsi_ssl_server_handshaker_factory_create_handshaker(
  297|       |    tsi_ssl_server_handshaker_factory* self, tsi_handshaker** handshaker);
  298|       |
  299|       |/* Decrements reference count of the handshaker factory. Handshaker factory will
  300|       | * be destroyed once no references exist. */
  301|       |void tsi_ssl_server_handshaker_factory_unref(
  302|       |    tsi_ssl_server_handshaker_factory* self);
  303|       |
  304|       |/* Util that checks that an ssl peer matches a specific name.
  305|       |   Still TODO(jboeuf):
  306|       |   - handle mixed case.
  307|       |   - handle %encoded chars.
  308|       |   - handle public suffix wildchar more strictly (e.g. *.co.uk) */
  309|       |int tsi_ssl_peer_matches_name(const tsi_peer* peer, const char* name);
  310|       |
  311|       |/* --- Testing support. ---
  312|       |
  313|       |   These functions and typedefs are not intended to be used outside of testing.
  314|       |   */
  315|       |
  316|       |/* Base type of client and server handshaker factories. */
  317|       |typedef struct tsi_ssl_handshaker_factory tsi_ssl_handshaker_factory;
  318|       |
  319|       |/* Function pointer to handshaker_factory destructor. */
  320|       |typedef void (*tsi_ssl_handshaker_factory_destructor)(
  321|       |    tsi_ssl_handshaker_factory* factory);
  322|       |
  323|       |/* Virtual table for tsi_ssl_handshaker_factory. */
  324|       |typedef struct {
  325|       |  tsi_ssl_handshaker_factory_destructor destroy;
  326|       |} tsi_ssl_handshaker_factory_vtable;
  327|       |
  328|       |/* Set destructor of handshaker_factory to new_destructor, returns previous
  329|       |   destructor. */
  330|       |const tsi_ssl_handshaker_factory_vtable* tsi_ssl_handshaker_factory_swap_vtable(
  331|       |    tsi_ssl_handshaker_factory* factory,
  332|       |    tsi_ssl_handshaker_factory_vtable* new_vtable);
  333|       |
  334|       |#endif /* GRPC_CORE_TSI_SSL_TRANSPORT_SECURITY_H */

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/channel_cc.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/channel.h>
   20|       |
   21|       |#include <cstring>
   22|       |#include <memory>
   23|       |#include <mutex>
   24|       |
   25|       |#include <grpc/grpc.h>
   26|       |#include <grpc/slice.h>
   27|       |#include <grpc/support/alloc.h>
   28|       |#include <grpc/support/log.h>
   29|       |#include <grpc/support/sync.h>
   30|       |#include <grpc/support/time.h>
   31|       |#include <grpcpp/client_context.h>
   32|       |#include <grpcpp/completion_queue.h>
   33|       |#include <grpcpp/impl/call.h>
   34|       |#include <grpcpp/impl/codegen/call_op_set.h>
   35|       |#include <grpcpp/impl/codegen/completion_queue_tag.h>
   36|       |#include <grpcpp/impl/grpc_library.h>
   37|       |#include <grpcpp/impl/rpc_method.h>
   38|       |#include <grpcpp/security/credentials.h>
   39|       |#include <grpcpp/support/channel_arguments.h>
   40|       |#include <grpcpp/support/config.h>
   41|       |#include <grpcpp/support/status.h>
   42|       |#include "src/core/lib/gpr/string.h"
   43|       |#include "src/core/lib/surface/completion_queue.h"
   44|       |
   45|       |void grpc::experimental::ChannelResetConnectionBackoff(
   46|      0|    ::grpc::Channel* channel) {
   47|      0|  grpc_impl::experimental::ChannelResetConnectionBackoff(channel);
   48|      0|}
   49|       |
   50|       |namespace grpc_impl {
   51|       |
   52|       |static ::grpc::internal::GrpcLibraryInitializer g_gli_initializer;
   53|       |Channel::Channel(const grpc::string& host, grpc_channel* channel,
   54|       |                 std::vector<std::unique_ptr<
   55|       |                     ::grpc::experimental::ClientInterceptorFactoryInterface>>
   56|       |                     interceptor_creators)
   57|      0|    : host_(host), c_channel_(channel) {
   58|      0|  interceptor_creators_ = std::move(interceptor_creators);
   59|      0|  g_gli_initializer.summon();
   60|      0|}
   61|       |
   62|      0|Channel::~Channel() {
   63|      0|  grpc_channel_destroy(c_channel_);
   64|      0|  if (callback_cq_ != nullptr) {
   65|      0|    callback_cq_->Shutdown();
   66|      0|  }
   67|      0|}
   68|       |
   69|       |namespace {
   70|       |
   71|      0|inline grpc_slice SliceFromArray(const char* arr, size_t len) {
   72|      0|  return ::grpc::g_core_codegen_interface->grpc_slice_from_copied_buffer(arr,
   73|      0|                                                                         len);
   74|      0|}
   75|       |
   76|       |grpc::string GetChannelInfoField(grpc_channel* channel,
   77|       |                                 grpc_channel_info* channel_info,
   78|      0|                                 char*** channel_info_field) {
   79|      0|  char* value = nullptr;
   80|      0|  memset(channel_info, 0, sizeof(*channel_info));
   81|      0|  *channel_info_field = &value;
   82|      0|  grpc_channel_get_info(channel, channel_info);
   83|      0|  if (value == nullptr) return "";
   84|      0|  grpc::string result = value;
   85|      0|  gpr_free(value);
   86|      0|  return result;
   87|      0|}
   88|       |
   89|       |}  // namespace
   90|       |
   91|      0|grpc::string Channel::GetLoadBalancingPolicyName() const {
   92|      0|  grpc_channel_info channel_info;
   93|      0|  return GetChannelInfoField(c_channel_, &channel_info,
   94|      0|                             &channel_info.lb_policy_name);
   95|      0|}
   96|       |
   97|      0|grpc::string Channel::GetServiceConfigJSON() const {
   98|      0|  grpc_channel_info channel_info;
   99|      0|  return GetChannelInfoField(c_channel_, &channel_info,
  100|      0|                             &channel_info.service_config_json);
  101|      0|}
  102|       |
  103|       |namespace experimental {
  104|       |
  105|      0|void ChannelResetConnectionBackoff(Channel* channel) {
  106|      0|  grpc_channel_reset_connect_backoff(channel->c_channel_);
  107|      0|}
  108|       |
  109|       |}  // namespace experimental
  110|       |
  111|       |::grpc::internal::Call Channel::CreateCallInternal(
  112|       |    const ::grpc::internal::RpcMethod& method, ::grpc::ClientContext* context,
  113|      0|    ::grpc::CompletionQueue* cq, size_t interceptor_pos) {
  114|      0|  const bool kRegistered = method.channel_tag() && context->authority().empty();
  115|      0|  grpc_call* c_call = nullptr;
  116|      0|  if (kRegistered) {
  117|      0|    c_call = grpc_channel_create_registered_call(
  118|      0|        c_channel_, context->propagate_from_call_,
  119|      0|        context->propagation_options_.c_bitmask(), cq->cq(),
  120|      0|        method.channel_tag(), context->raw_deadline(), nullptr);
  121|      0|  } else {
  122|      0|    const ::grpc::string* host_str = nullptr;
  123|      0|    if (!context->authority_.empty()) {
  124|      0|      host_str = &context->authority_;
  125|      0|    } else if (!host_.empty()) {
  126|      0|      host_str = &host_;
  127|      0|    }
  128|      0|    grpc_slice method_slice =
  129|      0|        SliceFromArray(method.name(), strlen(method.name()));
  130|      0|    grpc_slice host_slice;
  131|      0|    if (host_str != nullptr) {
  132|      0|      host_slice = ::grpc::SliceFromCopiedString(*host_str);
  133|      0|    }
  134|      0|    c_call = grpc_channel_create_call(
  135|      0|        c_channel_, context->propagate_from_call_,
  136|      0|        context->propagation_options_.c_bitmask(), cq->cq(), method_slice,
  137|      0|        host_str == nullptr ? nullptr : &host_slice, context->raw_deadline(),
  138|      0|        nullptr);
  139|      0|    grpc_slice_unref(method_slice);
  140|      0|    if (host_str != nullptr) {
  141|      0|      grpc_slice_unref(host_slice);
  142|      0|    }
  143|      0|  }
  144|      0|  grpc_census_call_set_context(c_call, context->census_context());
  145|      0|
  146|      0|  // ClientRpcInfo should be set before call because set_call also checks
  147|      0|  // whether the call has been cancelled, and if the call was cancelled, we
  148|      0|  // should notify the interceptors too/
  149|      0|  auto* info =
  150|      0|      context->set_client_rpc_info(method.name(), method.method_type(), this,
  151|      0|                                   interceptor_creators_, interceptor_pos);
  152|      0|  context->set_call(c_call, shared_from_this());
  153|      0|
  154|      0|  return ::grpc::internal::Call(c_call, this, cq, info);
  155|      0|}
  156|       |
  157|       |::grpc::internal::Call Channel::CreateCall(
  158|       |    const ::grpc::internal::RpcMethod& method, ::grpc::ClientContext* context,
  159|      0|    ::grpc::CompletionQueue* cq) {
  160|      0|  return CreateCallInternal(method, context, cq, 0);
  161|      0|}
  162|       |
  163|       |void Channel::PerformOpsOnCall(::grpc::internal::CallOpSetInterface* ops,
  164|      0|                               ::grpc::internal::Call* call) {
  165|      0|  ops->FillOps(
  166|      0|      call);  // Make a copy of call. It's fine since Call just has pointers
  167|      0|}
  168|       |
  169|      0|void* Channel::RegisterMethod(const char* method) {
  170|      0|  return grpc_channel_register_call(
  171|      0|      c_channel_, method, host_.empty() ? nullptr : host_.c_str(), nullptr);
  172|      0|}
  173|       |
  174|      0|grpc_connectivity_state Channel::GetState(bool try_to_connect) {
  175|      0|  return grpc_channel_check_connectivity_state(c_channel_, try_to_connect);
  176|      0|}
  177|       |
  178|       |namespace {
  179|       |
  180|       |class TagSaver final : public ::grpc::internal::CompletionQueueTag {
  181|       | public:
  182|      0|  explicit TagSaver(void* tag) : tag_(tag) {}
  183|      0|  ~TagSaver() override {}
  184|      0|  bool FinalizeResult(void** tag, bool* status) override {
  185|      0|    *tag = tag_;
  186|      0|    delete this;
  187|      0|    return true;
  188|      0|  }
  189|       |
  190|       | private:
  191|       |  void* tag_;
  192|       |};
  193|       |
  194|       |}  // namespace
  195|       |
  196|       |void Channel::NotifyOnStateChangeImpl(grpc_connectivity_state last_observed,
  197|       |                                      gpr_timespec deadline,
  198|      0|                                      ::grpc::CompletionQueue* cq, void* tag) {
  199|      0|  TagSaver* tag_saver = new TagSaver(tag);
  200|      0|  grpc_channel_watch_connectivity_state(c_channel_, last_observed, deadline,
  201|      0|                                        cq->cq(), tag_saver);
  202|      0|}
  203|       |
  204|       |bool Channel::WaitForStateChangeImpl(grpc_connectivity_state last_observed,
  205|      0|                                     gpr_timespec deadline) {
  206|      0|  ::grpc::CompletionQueue cq;
  207|      0|  bool ok = false;
  208|      0|  void* tag = nullptr;
  209|      0|  NotifyOnStateChangeImpl(last_observed, deadline, &cq, nullptr);
  210|      0|  cq.Next(&tag, &ok);
  211|      0|  GPR_ASSERT(tag == nullptr);
  212|      0|  return ok;
  213|      0|}
  214|       |
  215|       |namespace {
  216|       |class ShutdownCallback : public grpc_experimental_completion_queue_functor {
  217|       | public:
  218|      0|  ShutdownCallback() { functor_run = &ShutdownCallback::Run; }
  219|       |  // TakeCQ takes ownership of the cq into the shutdown callback
  220|       |  // so that the shutdown callback will be responsible for destroying it
  221|      0|  void TakeCQ(::grpc::CompletionQueue* cq) { cq_ = cq; }
  222|       |
  223|       |  // The Run function will get invoked by the completion queue library
  224|       |  // when the shutdown is actually complete
  225|      0|  static void Run(grpc_experimental_completion_queue_functor* cb, int) {
  226|      0|    auto* callback = static_cast<ShutdownCallback*>(cb);
  227|      0|    delete callback->cq_;
  228|      0|    delete callback;
  229|      0|  }
  230|       |
  231|       | private:
  232|       |  ::grpc::CompletionQueue* cq_ = nullptr;
  233|       |};
  234|       |}  // namespace
  235|       |
  236|      0|::grpc::CompletionQueue* Channel::CallbackCQ() {
  237|      0|  // TODO(vjpai): Consider using a single global CQ for the default CQ
  238|      0|  // if there is no explicit per-channel CQ registered
  239|      0|  grpc::internal::MutexLock l(&mu_);
  240|      0|  if (callback_cq_ == nullptr) {
  241|      0|    auto* shutdown_callback = new ShutdownCallback;
  242|      0|    callback_cq_ = new ::grpc::CompletionQueue(grpc_completion_queue_attributes{
  243|      0|        GRPC_CQ_CURRENT_VERSION, GRPC_CQ_CALLBACK, GRPC_CQ_DEFAULT_POLLING,
  244|      0|        shutdown_callback});
  245|      0|
  246|      0|    // Transfer ownership of the new cq to its own shutdown callback
  247|      0|    shutdown_callback->TakeCQ(callback_cq_);
  248|      0|  }
  249|      0|  return callback_cq_;
  250|      0|}
  251|       |
  252|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/client_context.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/client_context.h>
   20|       |
   21|       |#include <grpc/compression.h>
   22|       |#include <grpc/grpc.h>
   23|       |#include <grpc/support/alloc.h>
   24|       |#include <grpc/support/log.h>
   25|       |#include <grpc/support/string_util.h>
   26|       |
   27|       |#include <grpcpp/impl/codegen/interceptor_common.h>
   28|       |#include <grpcpp/impl/codegen/sync.h>
   29|       |#include <grpcpp/impl/grpc_library.h>
   30|       |#include <grpcpp/security/credentials.h>
   31|       |#include <grpcpp/server_context.h>
   32|       |#include <grpcpp/support/time.h>
   33|       |
   34|       |namespace grpc_impl {
   35|       |
   36|       |class Channel;
   37|       |}
   38|       |
   39|       |namespace grpc {
   40|       |
   41|       |class DefaultGlobalClientCallbacks final
   42|       |    : public ClientContext::GlobalCallbacks {
   43|       | public:
   44|      0|  ~DefaultGlobalClientCallbacks() override {}
   45|      0|  void DefaultConstructor(ClientContext* context) override {}
   46|      0|  void Destructor(ClientContext* context) override {}
   47|       |};
   48|       |
   49|       |static internal::GrpcLibraryInitializer g_gli_initializer;
   50|       |static DefaultGlobalClientCallbacks* g_default_client_callbacks =
   51|       |    new DefaultGlobalClientCallbacks();
   52|       |static ClientContext::GlobalCallbacks* g_client_callbacks =
   53|       |    g_default_client_callbacks;
   54|       |
   55|       |ClientContext::ClientContext()
   56|       |    : initial_metadata_received_(false),
   57|       |      wait_for_ready_(false),
   58|       |      wait_for_ready_explicitly_set_(false),
   59|       |      idempotent_(false),
   60|       |      cacheable_(false),
   61|       |      call_(nullptr),
   62|       |      call_canceled_(false),
   63|       |      deadline_(gpr_inf_future(GPR_CLOCK_REALTIME)),
   64|       |      census_context_(nullptr),
   65|       |      propagate_from_call_(nullptr),
   66|       |      compression_algorithm_(GRPC_COMPRESS_NONE),
   67|      0|      initial_metadata_corked_(false) {
   68|      0|  g_client_callbacks->DefaultConstructor(this);
   69|      0|}
   70|       |
   71|      0|ClientContext::~ClientContext() {
   72|      0|  if (call_) {
   73|      0|    grpc_call_unref(call_);
   74|      0|  }
   75|      0|  g_client_callbacks->Destructor(this);
   76|      0|}
   77|       |
   78|       |std::unique_ptr<ClientContext> ClientContext::FromServerContext(
   79|      0|    const ServerContext& context, PropagationOptions options) {
   80|      0|  std::unique_ptr<ClientContext> ctx(new ClientContext);
   81|      0|  ctx->propagate_from_call_ = context.call_;
   82|      0|  ctx->propagation_options_ = options;
   83|      0|  return ctx;
   84|      0|}
   85|       |
   86|       |void ClientContext::AddMetadata(const grpc::string& meta_key,
   87|      0|                                const grpc::string& meta_value) {
   88|      0|  send_initial_metadata_.insert(std::make_pair(meta_key, meta_value));
   89|      0|}
   90|       |
   91|       |void ClientContext::set_call(
   92|      0|    grpc_call* call, const std::shared_ptr<::grpc_impl::Channel>& channel) {
   93|      0|  grpc::internal::MutexLock lock(&mu_);
   94|      0|  GPR_ASSERT(call_ == nullptr);
   95|      0|  call_ = call;
   96|      0|  channel_ = channel;
   97|      0|  if (creds_ && !creds_->ApplyToCall(call_)) {
   98|      0|    // TODO(yashykt): should interceptors also see this status?
   99|      0|    SendCancelToInterceptors();
  100|      0|    grpc_call_cancel_with_status(call, GRPC_STATUS_CANCELLED,
  101|      0|                                 "Failed to set credentials to rpc.", nullptr);
  102|      0|  }
  103|      0|  if (call_canceled_) {
  104|      0|    SendCancelToInterceptors();
  105|      0|    grpc_call_cancel(call_, nullptr);
  106|      0|  }
  107|      0|}
  108|       |
  109|       |void ClientContext::set_compression_algorithm(
  110|      0|    grpc_compression_algorithm algorithm) {
  111|      0|  compression_algorithm_ = algorithm;
  112|      0|  const char* algorithm_name = nullptr;
  113|      0|  if (!grpc_compression_algorithm_name(algorithm, &algorithm_name)) {
  114|      0|    gpr_log(GPR_ERROR, "Name for compression algorithm '%d' unknown.",
  115|      0|            algorithm);
  116|      0|    abort();
  117|      0|  }
  118|      0|  GPR_ASSERT(algorithm_name != nullptr);
  119|      0|  AddMetadata(GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY, algorithm_name);
  120|      0|}
  121|       |
  122|      0|void ClientContext::TryCancel() {
  123|      0|  grpc::internal::MutexLock lock(&mu_);
  124|      0|  if (call_) {
  125|      0|    SendCancelToInterceptors();
  126|      0|    grpc_call_cancel(call_, nullptr);
  127|      0|  } else {
  128|      0|    call_canceled_ = true;
  129|      0|  }
  130|      0|}
  131|       |
  132|      0|void ClientContext::SendCancelToInterceptors() {
  133|      0|  internal::CancelInterceptorBatchMethods cancel_methods;
  134|      0|  for (size_t i = 0; i < rpc_info_.interceptors_.size(); i++) {
  135|      0|    rpc_info_.RunInterceptor(&cancel_methods, i);
  136|      0|  }
  137|      0|}
  138|       |
  139|      0|grpc::string ClientContext::peer() const {
  140|      0|  grpc::string peer;
  141|      0|  if (call_) {
  142|      0|    char* c_peer = grpc_call_get_peer(call_);
  143|      0|    peer = c_peer;
  144|      0|    gpr_free(c_peer);
  145|      0|  }
  146|      0|  return peer;
  147|      0|}
  148|       |
  149|      0|void ClientContext::SetGlobalCallbacks(GlobalCallbacks* client_callbacks) {
  150|      0|  GPR_ASSERT(g_client_callbacks == g_default_client_callbacks);
  151|      0|  GPR_ASSERT(client_callbacks != nullptr);
  152|      0|  GPR_ASSERT(client_callbacks != g_default_client_callbacks);
  153|      0|  g_client_callbacks = client_callbacks;
  154|      0|}
  155|       |
  156|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/client_interceptor.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2018 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/impl/codegen/client_interceptor.h>
   20|       |
   21|       |namespace grpc {
   22|       |
   23|       |namespace internal {
   24|       |experimental::ClientInterceptorFactoryInterface*
   25|       |    g_global_client_interceptor_factory = nullptr;
   26|       |}
   27|       |
   28|       |namespace experimental {
   29|       |void RegisterGlobalClientInterceptorFactory(
   30|      0|    ClientInterceptorFactoryInterface* factory) {
   31|      0|  if (internal::g_global_client_interceptor_factory != nullptr) {
   32|      0|    GPR_ASSERT(false &&
   33|      0|               "It is illegal to call RegisterGlobalClientInterceptorFactory "
   34|      0|               "multiple times.");
   35|      0|  }
   36|      0|  internal::g_global_client_interceptor_factory = factory;
   37|      0|}
   38|       |
   39|       |// For testing purposes only.
   40|      0|void TestOnlyResetGlobalClientInterceptorFactory() {
   41|      0|  internal::g_global_client_interceptor_factory = nullptr;
   42|      0|}
   43|       |}  // namespace experimental
   44|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/create_channel.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <memory>
   20|       |
   21|       |#include <grpcpp/channel.h>
   22|       |#include <grpcpp/create_channel.h>
   23|       |#include <grpcpp/impl/grpc_library.h>
   24|       |#include <grpcpp/security/credentials.h>
   25|       |#include <grpcpp/support/channel_arguments.h>
   26|       |
   27|       |#include "src/cpp/client/create_channel_internal.h"
   28|       |
   29|       |namespace grpc_impl {
   30|       |std::shared_ptr<grpc::Channel> CreateChannelImpl(
   31|       |    const grpc::string& target,
   32|      0|    const std::shared_ptr<grpc::ChannelCredentials>& creds) {
   33|      0|  return CreateCustomChannelImpl(target, creds, grpc::ChannelArguments());
   34|      0|}
   35|       |
   36|       |std::shared_ptr<grpc::Channel> CreateCustomChannelImpl(
   37|       |    const grpc::string& target,
   38|       |    const std::shared_ptr<grpc::ChannelCredentials>& creds,
   39|      0|    const grpc::ChannelArguments& args) {
   40|      0|  grpc::GrpcLibraryCodegen
   41|      0|      init_lib;  // We need to call init in case of a bad creds.
   42|      0|  return creds ? creds->CreateChannelImpl(target, args)
   43|      0|               : grpc::CreateChannelInternal(
   44|      0|                     "",
   45|      0|                     grpc_lame_client_channel_create(
   46|      0|                         nullptr, GRPC_STATUS_INVALID_ARGUMENT,
   47|      0|                         "Invalid credentials."),
   48|      0|                     std::vector<std::unique_ptr<
   49|      0|                         grpc::experimental::
   50|      0|                             ClientInterceptorFactoryInterface>>());
   51|      0|}
   52|       |
   53|       |namespace experimental {
   54|       |/// Create a new \em custom \a Channel pointing to \a target with \a
   55|       |/// interceptors being invoked per call.
   56|       |///
   57|       |/// \warning For advanced use and testing ONLY. Override default channel
   58|       |/// arguments only if necessary.
   59|       |///
   60|       |/// \param target The URI of the endpoint to connect to.
   61|       |/// \param creds Credentials to use for the created channel. If it does not
   62|       |/// hold an object or is invalid, a lame channel (one on which all operations
   63|       |/// fail) is returned.
   64|       |/// \param args Options for channel creation.
   65|       |std::shared_ptr<grpc::Channel> CreateCustomChannelWithInterceptors(
   66|       |    const grpc::string& target,
   67|       |    const std::shared_ptr<grpc::ChannelCredentials>& creds,
   68|       |    const grpc::ChannelArguments& args,
   69|       |    std::vector<
   70|       |        std::unique_ptr<grpc::experimental::ClientInterceptorFactoryInterface>>
   71|      0|        interceptor_creators) {
   72|      0|  return creds ? creds->CreateChannelWithInterceptors(
   73|      0|                     target, args, std::move(interceptor_creators))
   74|      0|               : ::grpc::CreateChannelInternal(
   75|      0|                     "",
   76|      0|                     grpc_lame_client_channel_create(
   77|      0|                         nullptr, GRPC_STATUS_INVALID_ARGUMENT,
   78|      0|                         "Invalid credentials."),
   79|      0|                     std::move(interceptor_creators));
   80|      0|}
   81|       |}  // namespace experimental
   82|       |
   83|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/create_channel_internal.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <memory>
   20|       |
   21|       |#include <grpcpp/channel.h>
   22|       |
   23|       |struct grpc_channel;
   24|       |
   25|       |namespace grpc {
   26|       |
   27|       |std::shared_ptr<Channel> CreateChannelInternal(
   28|       |    const grpc::string& host, grpc_channel* c_channel,
   29|       |    std::vector<std::unique_ptr<
   30|       |        ::grpc::experimental::ClientInterceptorFactoryInterface>>
   31|      0|        interceptor_creators) {
   32|      0|  return std::shared_ptr<Channel>(
   33|      0|      new Channel(host, c_channel, std::move(interceptor_creators)));
   34|      0|}
   35|       |
   36|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/credentials_cc.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/impl/grpc_library.h>
   20|       |#include <grpcpp/security/credentials.h>
   21|       |
   22|       |namespace grpc_impl {
   23|       |
   24|       |static grpc::internal::GrpcLibraryInitializer g_gli_initializer;
   25|      0|ChannelCredentials::ChannelCredentials() { g_gli_initializer.summon(); }
   26|       |
   27|      0|ChannelCredentials::~ChannelCredentials() {}
   28|       |
   29|      0|CallCredentials::CallCredentials() { g_gli_initializer.summon(); }
   30|       |
   31|      0|CallCredentials::~CallCredentials() {}
   32|       |
   33|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/generic_stub.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <functional>
   20|       |
   21|       |#include <grpcpp/generic/generic_stub.h>
   22|       |#include <grpcpp/impl/rpc_method.h>
   23|       |#include <grpcpp/support/client_callback.h>
   24|       |
   25|       |namespace grpc_impl {
   26|       |
   27|       |namespace {
   28|       |std::unique_ptr<grpc::GenericClientAsyncReaderWriter> CallInternal(
   29|       |    grpc::ChannelInterface* channel, grpc::ClientContext* context,
   30|       |    const grpc::string& method, grpc::CompletionQueue* cq, bool start,
   31|      0|    void* tag) {
   32|      0|  return std::unique_ptr<grpc::GenericClientAsyncReaderWriter>(
   33|      0|      grpc::internal::ClientAsyncReaderWriterFactory<grpc::ByteBuffer,
   34|      0|                                                     grpc::ByteBuffer>::
   35|      0|          Create(channel, cq,
   36|      0|                 grpc::internal::RpcMethod(
   37|      0|                     method.c_str(), grpc::internal::RpcMethod::BIDI_STREAMING),
   38|      0|                 context, start, tag));
   39|      0|}
   40|       |
   41|       |}  // namespace
   42|       |
   43|       |// begin a call to a named method
   44|       |std::unique_ptr<grpc::GenericClientAsyncReaderWriter> GenericStub::Call(
   45|       |    grpc::ClientContext* context, const grpc::string& method,
   46|      0|    grpc::CompletionQueue* cq, void* tag) {
   47|      0|  return CallInternal(channel_.get(), context, method, cq, true, tag);
   48|      0|}
   49|       |
   50|       |// setup a call to a named method
   51|       |std::unique_ptr<grpc::GenericClientAsyncReaderWriter> GenericStub::PrepareCall(
   52|       |    grpc::ClientContext* context, const grpc::string& method,
   53|      0|    grpc::CompletionQueue* cq) {
   54|      0|  return CallInternal(channel_.get(), context, method, cq, false, nullptr);
   55|      0|}
   56|       |
   57|       |// setup a unary call to a named method
   58|       |std::unique_ptr<grpc::GenericClientAsyncResponseReader>
   59|       |GenericStub::PrepareUnaryCall(grpc::ClientContext* context,
   60|       |                              const grpc::string& method,
   61|       |                              const grpc::ByteBuffer& request,
   62|      0|                              grpc::CompletionQueue* cq) {
   63|      0|  return std::unique_ptr<grpc::GenericClientAsyncResponseReader>(
   64|      0|      grpc::internal::ClientAsyncResponseReaderFactory<
   65|      0|          grpc::ByteBuffer>::Create(channel_.get(), cq,
   66|      0|                                    grpc::internal::RpcMethod(
   67|      0|                                        method.c_str(),
   68|      0|                                        grpc::internal::RpcMethod::NORMAL_RPC),
   69|      0|                                    context, request, false));
   70|      0|}
   71|       |
   72|       |void GenericStub::experimental_type::UnaryCall(
   73|       |    grpc::ClientContext* context, const grpc::string& method,
   74|       |    const grpc::ByteBuffer* request, grpc::ByteBuffer* response,
   75|      0|    std::function<void(grpc::Status)> on_completion) {
   76|      0|  grpc::internal::CallbackUnaryCall(
   77|      0|      stub_->channel_.get(),
   78|      0|      grpc::internal::RpcMethod(method.c_str(),
   79|      0|                                grpc::internal::RpcMethod::NORMAL_RPC),
   80|      0|      context, request, response, std::move(on_completion));
   81|      0|}
   82|       |
   83|       |void GenericStub::experimental_type::PrepareBidiStreamingCall(
   84|       |    grpc::ClientContext* context, const grpc::string& method,
   85|       |    grpc::experimental::ClientBidiReactor<grpc::ByteBuffer, grpc::ByteBuffer>*
   86|      0|        reactor) {
   87|      0|  grpc::internal::ClientCallbackReaderWriterFactory<
   88|      0|      grpc::ByteBuffer,
   89|      0|      grpc::ByteBuffer>::Create(stub_->channel_.get(),
   90|      0|                                grpc::internal::RpcMethod(
   91|      0|                                    method.c_str(),
   92|      0|                                    grpc::internal::RpcMethod::BIDI_STREAMING),
   93|      0|                                context, reactor);
   94|      0|}
   95|       |
   96|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/insecure_credentials.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/security/credentials.h>
   20|       |
   21|       |#include <grpc/grpc.h>
   22|       |#include <grpc/support/log.h>
   23|       |#include <grpcpp/channel.h>
   24|       |#include <grpcpp/security/credentials.h>
   25|       |#include <grpcpp/support/channel_arguments.h>
   26|       |#include <grpcpp/support/config.h>
   27|       |#include "src/cpp/client/create_channel_internal.h"
   28|       |
   29|       |namespace grpc_impl {
   30|       |
   31|       |namespace {
   32|       |class InsecureChannelCredentialsImpl final : public ChannelCredentials {
   33|       | public:
   34|       |  std::shared_ptr<::grpc::Channel> CreateChannelImpl(
   35|      0|      const grpc::string& target, const grpc::ChannelArguments& args) override {
   36|      0|    return CreateChannelWithInterceptors(
   37|      0|        target, args,
   38|      0|        std::vector<std::unique_ptr<
   39|      0|            grpc::experimental::ClientInterceptorFactoryInterface>>());
   40|      0|  }
   41|       |
   42|       |  std::shared_ptr<::grpc::Channel> CreateChannelWithInterceptors(
   43|       |      const grpc::string& target, const grpc::ChannelArguments& args,
   44|       |      std::vector<std::unique_ptr<
   45|       |          grpc::experimental::ClientInterceptorFactoryInterface>>
   46|      0|          interceptor_creators) override {
   47|      0|    grpc_channel_args channel_args;
   48|      0|    args.SetChannelArgs(&channel_args);
   49|      0|    return ::grpc::CreateChannelInternal(
   50|      0|        "",
   51|      0|        grpc_insecure_channel_create(target.c_str(), &channel_args, nullptr),
   52|      0|        std::move(interceptor_creators));
   53|      0|  }
   54|       |
   55|      0|  SecureChannelCredentials* AsSecureCredentials() override { return nullptr; }
   56|       |};
   57|       |}  // namespace
   58|       |
   59|      0|std::shared_ptr<ChannelCredentials> InsecureChannelCredentials() {
   60|      0|  return std::shared_ptr<ChannelCredentials>(
   61|      0|      new InsecureChannelCredentialsImpl());
   62|      0|}
   63|       |
   64|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/secure_credentials.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include "src/cpp/client/secure_credentials.h"
   20|       |#include <grpc/support/log.h>
   21|       |#include <grpc/support/string_util.h>
   22|       |#include <grpcpp/channel.h>
   23|       |#include <grpcpp/impl/grpc_library.h>
   24|       |#include <grpcpp/support/channel_arguments.h>
   25|       |#include "src/cpp/client/create_channel_internal.h"
   26|       |#include "src/cpp/common/secure_auth_context.h"
   27|       |
   28|       |namespace grpc_impl {
   29|       |
   30|       |static grpc::internal::GrpcLibraryInitializer g_gli_initializer;
   31|       |SecureChannelCredentials::SecureChannelCredentials(
   32|       |    grpc_channel_credentials* c_creds)
   33|      0|    : c_creds_(c_creds) {
   34|      0|  g_gli_initializer.summon();
   35|      0|}
   36|       |
   37|       |std::shared_ptr<grpc::Channel> SecureChannelCredentials::CreateChannelImpl(
   38|      0|    const grpc::string& target, const grpc::ChannelArguments& args) {
   39|      0|  return CreateChannelWithInterceptors(
   40|      0|      target, args,
   41|      0|      std::vector<std::unique_ptr<
   42|      0|          grpc::experimental::ClientInterceptorFactoryInterface>>());
   43|      0|}
   44|       |
   45|       |std::shared_ptr<grpc::Channel>
   46|       |SecureChannelCredentials::CreateChannelWithInterceptors(
   47|       |    const grpc::string& target, const grpc::ChannelArguments& args,
   48|       |    std::vector<
   49|       |        std::unique_ptr<grpc::experimental::ClientInterceptorFactoryInterface>>
   50|      0|        interceptor_creators) {
   51|      0|  grpc_channel_args channel_args;
   52|      0|  args.SetChannelArgs(&channel_args);
   53|      0|  return ::grpc::CreateChannelInternal(
   54|      0|      args.GetSslTargetNameOverride(),
   55|      0|      grpc_secure_channel_create(c_creds_, target.c_str(), &channel_args,
   56|      0|                                 nullptr),
   57|      0|      std::move(interceptor_creators));
   58|      0|}
   59|       |
   60|       |SecureCallCredentials::SecureCallCredentials(grpc_call_credentials* c_creds)
   61|      0|    : c_creds_(c_creds) {
   62|      0|  g_gli_initializer.summon();
   63|      0|}
   64|       |
   65|      0|bool SecureCallCredentials::ApplyToCall(grpc_call* call) {
   66|      0|  return grpc_call_set_credentials(call, c_creds_) == GRPC_CALL_OK;
   67|      0|}
   68|       |
   69|       |namespace {
   70|       |std::shared_ptr<ChannelCredentials> WrapChannelCredentials(
   71|      0|    grpc_channel_credentials* creds) {
   72|      0|  return creds == nullptr ? nullptr
   73|      0|                          : std::shared_ptr<ChannelCredentials>(
   74|      0|                                new SecureChannelCredentials(creds));
   75|      0|}
   76|       |
   77|       |std::shared_ptr<CallCredentials> WrapCallCredentials(
   78|      0|    grpc_call_credentials* creds) {
   79|      0|  return creds == nullptr ? nullptr
   80|      0|                          : std::shared_ptr<CallCredentials>(
   81|      0|                                new SecureCallCredentials(creds));
   82|      0|}
   83|       |}  // namespace
   84|       |
   85|      0|std::shared_ptr<ChannelCredentials> GoogleDefaultCredentials() {
   86|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
   87|      0|  return WrapChannelCredentials(grpc_google_default_credentials_create());
   88|      0|}
   89|       |
   90|       |// Builds SSL Credentials given SSL specific options
   91|       |std::shared_ptr<ChannelCredentials> SslCredentials(
   92|      0|    const SslCredentialsOptions& options) {
   93|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
   94|      0|  grpc_ssl_pem_key_cert_pair pem_key_cert_pair = {
   95|      0|      options.pem_private_key.c_str(), options.pem_cert_chain.c_str()};
   96|      0|
   97|      0|  grpc_channel_credentials* c_creds = grpc_ssl_credentials_create(
   98|      0|      options.pem_root_certs.empty() ? nullptr : options.pem_root_certs.c_str(),
   99|      0|      options.pem_private_key.empty() ? nullptr : &pem_key_cert_pair, nullptr,
  100|      0|      nullptr);
  101|      0|  return WrapChannelCredentials(c_creds);
  102|      0|}
  103|       |
  104|       |namespace experimental {
  105|       |
  106|       |// Builds ALTS Credentials given ALTS specific options
  107|       |std::shared_ptr<ChannelCredentials> AltsCredentials(
  108|      0|    const AltsCredentialsOptions& options) {
  109|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
  110|      0|  grpc_alts_credentials_options* c_options =
  111|      0|      grpc_alts_credentials_client_options_create();
  112|      0|  for (auto service_account = options.target_service_accounts.begin();
  113|      0|       service_account != options.target_service_accounts.end();
  114|      0|       service_account++) {
  115|      0|    grpc_alts_credentials_client_options_add_target_service_account(
  116|      0|        c_options, service_account->c_str());
  117|      0|  }
  118|      0|  grpc_channel_credentials* c_creds = grpc_alts_credentials_create(c_options);
  119|      0|  grpc_alts_credentials_options_destroy(c_options);
  120|      0|  return WrapChannelCredentials(c_creds);
  121|      0|}
  122|       |
  123|       |// Builds Local Credentials
  124|       |std::shared_ptr<ChannelCredentials> LocalCredentials(
  125|      0|    grpc_local_connect_type type) {
  126|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
  127|      0|  return WrapChannelCredentials(grpc_local_credentials_create(type));
  128|      0|}
  129|       |
  130|       |}  // namespace experimental
  131|       |
  132|       |// Builds credentials for use when running in GCE
  133|      0|std::shared_ptr<CallCredentials> GoogleComputeEngineCredentials() {
  134|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
  135|      0|  return WrapCallCredentials(
  136|      0|      grpc_google_compute_engine_credentials_create(nullptr));
  137|      0|}
  138|       |
  139|       |// Builds JWT credentials.
  140|       |std::shared_ptr<CallCredentials> ServiceAccountJWTAccessCredentials(
  141|      0|    const grpc::string& json_key, long token_lifetime_seconds) {
  142|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
  143|      0|  if (token_lifetime_seconds <= 0) {
  144|      0|    gpr_log(GPR_ERROR,
  145|      0|            "Trying to create JWTCredentials with non-positive lifetime");
  146|      0|    return WrapCallCredentials(nullptr);
  147|      0|  }
  148|      0|  gpr_timespec lifetime =
  149|      0|      gpr_time_from_seconds(token_lifetime_seconds, GPR_TIMESPAN);
  150|      0|  return WrapCallCredentials(grpc_service_account_jwt_access_credentials_create(
  151|      0|      json_key.c_str(), lifetime, nullptr));
  152|      0|}
  153|       |
  154|       |// Builds refresh token credentials.
  155|       |std::shared_ptr<CallCredentials> GoogleRefreshTokenCredentials(
  156|      0|    const grpc::string& json_refresh_token) {
  157|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
  158|      0|  return WrapCallCredentials(grpc_google_refresh_token_credentials_create(
  159|      0|      json_refresh_token.c_str(), nullptr));
  160|      0|}
  161|       |
  162|       |// Builds access token credentials.
  163|       |std::shared_ptr<CallCredentials> AccessTokenCredentials(
  164|      0|    const grpc::string& access_token) {
  165|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
  166|      0|  return WrapCallCredentials(
  167|      0|      grpc_access_token_credentials_create(access_token.c_str(), nullptr));
  168|      0|}
  169|       |
  170|       |// Builds IAM credentials.
  171|       |std::shared_ptr<CallCredentials> GoogleIAMCredentials(
  172|       |    const grpc::string& authorization_token,
  173|      0|    const grpc::string& authority_selector) {
  174|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
  175|      0|  return WrapCallCredentials(grpc_google_iam_credentials_create(
  176|      0|      authorization_token.c_str(), authority_selector.c_str(), nullptr));
  177|      0|}
  178|       |
  179|       |// Combines one channel credentials and one call credentials into a channel
  180|       |// composite credentials.
  181|       |std::shared_ptr<ChannelCredentials> CompositeChannelCredentials(
  182|       |    const std::shared_ptr<ChannelCredentials>& channel_creds,
  183|      0|    const std::shared_ptr<CallCredentials>& call_creds) {
  184|      0|  // Note that we are not saving shared_ptrs to the two credentials passed in
  185|      0|  // here. This is OK because the underlying C objects (i.e., channel_creds and
  186|      0|  // call_creds) into grpc_composite_credentials_create will see their refcounts
  187|      0|  // incremented.
  188|      0|  SecureChannelCredentials* s_channel_creds =
  189|      0|      channel_creds->AsSecureCredentials();
  190|      0|  SecureCallCredentials* s_call_creds = call_creds->AsSecureCredentials();
  191|      0|  if (s_channel_creds && s_call_creds) {
  192|      0|    return WrapChannelCredentials(grpc_composite_channel_credentials_create(
  193|      0|        s_channel_creds->GetRawCreds(), s_call_creds->GetRawCreds(), nullptr));
  194|      0|  }
  195|      0|  return nullptr;
  196|      0|}
  197|       |
  198|       |std::shared_ptr<CallCredentials> CompositeCallCredentials(
  199|       |    const std::shared_ptr<CallCredentials>& creds1,
  200|      0|    const std::shared_ptr<CallCredentials>& creds2) {
  201|      0|  SecureCallCredentials* s_creds1 = creds1->AsSecureCredentials();
  202|      0|  SecureCallCredentials* s_creds2 = creds2->AsSecureCredentials();
  203|      0|  if (s_creds1 != nullptr && s_creds2 != nullptr) {
  204|      0|    return WrapCallCredentials(grpc_composite_call_credentials_create(
  205|      0|        s_creds1->GetRawCreds(), s_creds2->GetRawCreds(), nullptr));
  206|      0|  }
  207|      0|  return nullptr;
  208|      0|}
  209|       |
  210|       |std::shared_ptr<grpc_impl::CallCredentials> MetadataCredentialsFromPlugin(
  211|      0|    std::unique_ptr<MetadataCredentialsPlugin> plugin) {
  212|      0|  grpc::GrpcLibraryCodegen init;  // To call grpc_init().
  213|      0|  const char* type = plugin->GetType();
  214|      0|  grpc::MetadataCredentialsPluginWrapper* wrapper =
  215|      0|      new grpc::MetadataCredentialsPluginWrapper(std::move(plugin));
  216|      0|  grpc_metadata_credentials_plugin c_plugin = {
  217|      0|      grpc::MetadataCredentialsPluginWrapper::GetMetadata,
  218|      0|      grpc::MetadataCredentialsPluginWrapper::Destroy, wrapper, type};
  219|      0|  return WrapCallCredentials(
  220|      0|      grpc_metadata_credentials_create_from_plugin(c_plugin, nullptr));
  221|      0|}
  222|       |
  223|       |}  // namespace grpc_impl
  224|       |
  225|       |namespace grpc {
  226|       |
  227|      0|void MetadataCredentialsPluginWrapper::Destroy(void* wrapper) {
  228|      0|  if (wrapper == nullptr) return;
  229|      0|  MetadataCredentialsPluginWrapper* w =
  230|      0|      static_cast<MetadataCredentialsPluginWrapper*>(wrapper);
  231|      0|  delete w;
  232|      0|}
  233|       |
  234|       |int MetadataCredentialsPluginWrapper::GetMetadata(
  235|       |    void* wrapper, grpc_auth_metadata_context context,
  236|       |    grpc_credentials_plugin_metadata_cb cb, void* user_data,
  237|       |    grpc_metadata creds_md[GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX],
  238|       |    size_t* num_creds_md, grpc_status_code* status,
  239|      0|    const char** error_details) {
  240|      0|  GPR_ASSERT(wrapper);
  241|      0|  MetadataCredentialsPluginWrapper* w =
  242|      0|      static_cast<MetadataCredentialsPluginWrapper*>(wrapper);
  243|      0|  if (!w->plugin_) {
  244|      0|    *num_creds_md = 0;
  245|      0|    *status = GRPC_STATUS_OK;
  246|      0|    *error_details = nullptr;
  247|      0|    return true;
  248|      0|  }
  249|      0|  if (w->plugin_->IsBlocking()) {
  250|      0|    // Asynchronous return.
  251|      0|    w->thread_pool_->Add([w, context, cb, user_data] {
  252|      0|      w->MetadataCredentialsPluginWrapper::InvokePlugin(
  253|      0|          context, cb, user_data, nullptr, nullptr, nullptr, nullptr);
  254|      0|    });
  255|      0|    return 0;
  256|      0|  } else {
  257|      0|    // Synchronous return.
  258|      0|    w->InvokePlugin(context, cb, user_data, creds_md, num_creds_md, status,
  259|      0|                    error_details);
  260|      0|    return 1;
  261|      0|  }
  262|      0|}
  263|       |
  264|       |namespace {
  265|       |
  266|      0|void UnrefMetadata(const std::vector<grpc_metadata>& md) {
  267|      0|  for (auto it = md.begin(); it != md.end(); ++it) {
  268|      0|    grpc_slice_unref(it->key);
  269|      0|    grpc_slice_unref(it->value);
  270|      0|  }
  271|      0|}
  272|       |
  273|       |}  // namespace
  274|       |
  275|       |void MetadataCredentialsPluginWrapper::InvokePlugin(
  276|       |    grpc_auth_metadata_context context, grpc_credentials_plugin_metadata_cb cb,
  277|       |    void* user_data, grpc_metadata creds_md[4], size_t* num_creds_md,
  278|      0|    grpc_status_code* status_code, const char** error_details) {
  279|      0|  std::multimap<grpc::string, grpc::string> metadata;
  280|      0|
  281|      0|  // const_cast is safe since the SecureAuthContext only inc/dec the refcount
  282|      0|  // and the object is passed as a const ref to plugin_->GetMetadata.
  283|      0|  SecureAuthContext cpp_channel_auth_context(
  284|      0|      const_cast<grpc_auth_context*>(context.channel_auth_context));
  285|      0|
  286|      0|  Status status = plugin_->GetMetadata(context.service_url, context.method_name,
  287|      0|                                       cpp_channel_auth_context, &metadata);
  288|      0|  std::vector<grpc_metadata> md;
  289|      0|  for (auto it = metadata.begin(); it != metadata.end(); ++it) {
  290|      0|    grpc_metadata md_entry;
  291|      0|    md_entry.key = SliceFromCopiedString(it->first);
  292|      0|    md_entry.value = SliceFromCopiedString(it->second);
  293|      0|    md_entry.flags = 0;
  294|      0|    md.push_back(md_entry);
  295|      0|  }
  296|      0|  if (creds_md != nullptr) {
  297|      0|    // Synchronous return.
  298|      0|    if (md.size() > GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX) {
  299|      0|      *num_creds_md = 0;
  300|      0|      *status_code = GRPC_STATUS_INTERNAL;
  301|      0|      *error_details = gpr_strdup(
  302|      0|          "blocking plugin credentials returned too many metadata keys");
  303|      0|      UnrefMetadata(md);
  304|      0|    } else {
  305|      0|      for (const auto& elem : md) {
  306|      0|        creds_md[*num_creds_md].key = elem.key;
  307|      0|        creds_md[*num_creds_md].value = elem.value;
  308|      0|        creds_md[*num_creds_md].flags = elem.flags;
  309|      0|        ++(*num_creds_md);
  310|      0|      }
  311|      0|      *status_code = static_cast<grpc_status_code>(status.error_code());
  312|      0|      *error_details =
  313|      0|          status.ok() ? nullptr : gpr_strdup(status.error_message().c_str());
  314|      0|    }
  315|      0|  } else {
  316|      0|    // Asynchronous return.
  317|      0|    cb(user_data, md.empty() ? nullptr : &md[0], md.size(),
  318|      0|       static_cast<grpc_status_code>(status.error_code()),
  319|      0|       status.error_message().c_str());
  320|      0|    UnrefMetadata(md);
  321|      0|  }
  322|      0|}
  323|       |
  324|       |MetadataCredentialsPluginWrapper::MetadataCredentialsPluginWrapper(
  325|       |    std::unique_ptr<MetadataCredentialsPlugin> plugin)
  326|      0|    : thread_pool_(CreateDefaultThreadPool()), plugin_(std::move(plugin)) {}
  327|       |
  328|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/client/secure_credentials.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_INTERNAL_CPP_CLIENT_SECURE_CREDENTIALS_H
   20|       |#define GRPC_INTERNAL_CPP_CLIENT_SECURE_CREDENTIALS_H
   21|       |
   22|       |#include <grpc/grpc_security.h>
   23|       |
   24|       |#include <grpcpp/security/credentials.h>
   25|       |#include <grpcpp/support/config.h>
   26|       |
   27|       |#include "src/core/lib/security/credentials/credentials.h"
   28|       |#include "src/cpp/server/thread_pool_interface.h"
   29|       |
   30|       |namespace grpc_impl {
   31|       |
   32|       |class Channel;
   33|       |
   34|       |class SecureChannelCredentials final : public ChannelCredentials {
   35|       | public:
   36|       |  explicit SecureChannelCredentials(grpc_channel_credentials* c_creds);
   37|      0|  ~SecureChannelCredentials() {
   38|      0|    if (c_creds_ != nullptr) c_creds_->Unref();
   39|      0|  }
   40|      0|  grpc_channel_credentials* GetRawCreds() { return c_creds_; }
   41|       |
   42|       |  std::shared_ptr<::grpc::Channel> CreateChannelImpl(
   43|       |      const grpc::string& target, const grpc::ChannelArguments& args) override;
   44|       |
   45|      0|  SecureChannelCredentials* AsSecureCredentials() override { return this; }
   46|       |
   47|       | private:
   48|       |  std::shared_ptr<::grpc::Channel> CreateChannelWithInterceptors(
   49|       |      const grpc::string& target, const grpc::ChannelArguments& args,
   50|       |      std::vector<std::unique_ptr<
   51|       |          ::grpc::experimental::ClientInterceptorFactoryInterface>>
   52|       |          interceptor_creators) override;
   53|       |  grpc_channel_credentials* const c_creds_;
   54|       |};
   55|       |
   56|       |class SecureCallCredentials final : public CallCredentials {
   57|       | public:
   58|       |  explicit SecureCallCredentials(grpc_call_credentials* c_creds);
   59|      0|  ~SecureCallCredentials() {
   60|      0|    if (c_creds_ != nullptr) c_creds_->Unref();
   61|      0|  }
   62|      0|  grpc_call_credentials* GetRawCreds() { return c_creds_; }
   63|       |
   64|       |  bool ApplyToCall(grpc_call* call) override;
   65|      0|  SecureCallCredentials* AsSecureCredentials() override { return this; }
   66|       |
   67|       | private:
   68|       |  grpc_call_credentials* const c_creds_;
   69|       |};
   70|       |
   71|       |}  // namespace grpc_impl
   72|       |
   73|       |namespace grpc {
   74|       |
   75|       |class MetadataCredentialsPluginWrapper final : private GrpcLibraryCodegen {
   76|       | public:
   77|       |  static void Destroy(void* wrapper);
   78|       |  static int GetMetadata(
   79|       |      void* wrapper, grpc_auth_metadata_context context,
   80|       |      grpc_credentials_plugin_metadata_cb cb, void* user_data,
   81|       |      grpc_metadata creds_md[GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX],
   82|       |      size_t* num_creds_md, grpc_status_code* status,
   83|       |      const char** error_details);
   84|       |
   85|       |  explicit MetadataCredentialsPluginWrapper(
   86|       |      std::unique_ptr<MetadataCredentialsPlugin> plugin);
   87|       |
   88|       | private:
   89|       |  void InvokePlugin(
   90|       |      grpc_auth_metadata_context context,
   91|       |      grpc_credentials_plugin_metadata_cb cb, void* user_data,
   92|       |      grpc_metadata creds_md[GRPC_METADATA_CREDENTIALS_PLUGIN_SYNC_MAX],
   93|       |      size_t* num_creds_md, grpc_status_code* status_code,
   94|       |      const char** error_details);
   95|       |  std::unique_ptr<ThreadPoolInterface> thread_pool_;
   96|       |  std::unique_ptr<MetadataCredentialsPlugin> plugin_;
   97|       |};
   98|       |
   99|       |}  // namespace grpc
  100|       |
  101|       |#endif  // GRPC_INTERNAL_CPP_CLIENT_SECURE_CREDENTIALS_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/alarm.cc:
    1|       |/*
    2|       | * Copyright 2018 gRPC authors.
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *     http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | *
   16|       | */
   17|       |
   18|       |#include <grpcpp/alarm.h>
   19|       |
   20|       |#include <memory>
   21|       |
   22|       |#include <grpc/support/log.h>
   23|       |#include <grpc/support/port_platform.h>
   24|       |#include <grpcpp/completion_queue.h>
   25|       |#include <grpcpp/impl/grpc_library.h>
   26|       |#include <grpcpp/support/time.h>
   27|       |#include "src/core/lib/iomgr/exec_ctx.h"
   28|       |#include "src/core/lib/iomgr/timer.h"
   29|       |#include "src/core/lib/surface/completion_queue.h"
   30|       |
   31|       |#include <grpc/support/log.h>
   32|       |#include "src/core/lib/debug/trace.h"
   33|       |
   34|       |namespace grpc_impl {
   35|       |
   36|       |namespace internal {
   37|       |class AlarmImpl : public ::grpc::internal::CompletionQueueTag {
   38|       | public:
   39|      0|  AlarmImpl() : cq_(nullptr), tag_(nullptr) {
   40|      0|    gpr_ref_init(&refs_, 1);
   41|      0|    grpc_timer_init_unset(&timer_);
   42|      0|  }
   43|      0|  ~AlarmImpl() {}
   44|      0|  bool FinalizeResult(void** tag, bool* status) override {
   45|      0|    *tag = tag_;
   46|      0|    Unref();
   47|      0|    return true;
   48|      0|  }
   49|      0|  void Set(::grpc::CompletionQueue* cq, gpr_timespec deadline, void* tag) {
   50|      0|    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
   51|      0|    grpc_core::ExecCtx exec_ctx;
   52|      0|    GRPC_CQ_INTERNAL_REF(cq->cq(), "alarm");
   53|      0|    cq_ = cq->cq();
   54|      0|    tag_ = tag;
   55|      0|    GPR_ASSERT(grpc_cq_begin_op(cq_, this));
   56|      0|    GRPC_CLOSURE_INIT(&on_alarm_,
   57|      0|                      [](void* arg, grpc_error* error) {
   58|      0|                        // queue the op on the completion queue
   59|      0|                        AlarmImpl* alarm = static_cast<AlarmImpl*>(arg);
   60|      0|                        alarm->Ref();
   61|      0|                        // Preserve the cq and reset the cq_ so that the alarm
   62|      0|                        // can be reset when the alarm tag is delivered.
   63|      0|                        grpc_completion_queue* cq = alarm->cq_;
   64|      0|                        alarm->cq_ = nullptr;
   65|      0|                        grpc_cq_end_op(
   66|      0|                            cq, alarm, error,
   67|      0|                            [](void* arg, grpc_cq_completion* completion) {},
   68|      0|                            arg, &alarm->completion_);
   69|      0|                        GRPC_CQ_INTERNAL_UNREF(cq, "alarm");
   70|      0|                      },
   71|      0|                      this, grpc_schedule_on_exec_ctx);
   72|      0|    grpc_timer_init(&timer_, grpc_timespec_to_millis_round_up(deadline),
   73|      0|                    &on_alarm_);
   74|      0|  }
   75|      0|  void Set(gpr_timespec deadline, std::function<void(bool)> f) {
   76|      0|    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
   77|      0|    grpc_core::ExecCtx exec_ctx;
   78|      0|    // Don't use any CQ at all. Instead just use the timer to fire the function
   79|      0|    callback_ = std::move(f);
   80|      0|    Ref();
   81|      0|    GRPC_CLOSURE_INIT(&on_alarm_,
   82|      0|                      [](void* arg, grpc_error* error) {
   83|      0|                        AlarmImpl* alarm = static_cast<AlarmImpl*>(arg);
   84|      0|                        alarm->callback_(error == GRPC_ERROR_NONE);
   85|      0|                        alarm->Unref();
   86|      0|                      },
   87|      0|                      this, grpc_schedule_on_exec_ctx);
   88|      0|    grpc_timer_init(&timer_, grpc_timespec_to_millis_round_up(deadline),
   89|      0|                    &on_alarm_);
   90|      0|  }
   91|      0|  void Cancel() {
   92|      0|    grpc_core::ApplicationCallbackExecCtx callback_exec_ctx;
   93|      0|    grpc_core::ExecCtx exec_ctx;
   94|      0|    grpc_timer_cancel(&timer_);
   95|      0|  }
   96|      0|  void Destroy() {
   97|      0|    Cancel();
   98|      0|    Unref();
   99|      0|  }
  100|       |
  101|       | private:
  102|      0|  void Ref() { gpr_ref(&refs_); }
  103|      0|  void Unref() {
  104|      0|    if (gpr_unref(&refs_)) {
  105|      0|      delete this;
  106|      0|    }
  107|      0|  }
  108|       |
  109|       |  grpc_timer timer_;
  110|       |  gpr_refcount refs_;
  111|       |  grpc_closure on_alarm_;
  112|       |  grpc_cq_completion completion_;
  113|       |  // completion queue where events about this alarm will be posted
  114|       |  grpc_completion_queue* cq_;
  115|       |  void* tag_;
  116|       |  std::function<void(bool)> callback_;
  117|       |};
  118|       |}  // namespace internal
  119|       |
  120|       |static ::grpc::internal::GrpcLibraryInitializer g_gli_initializer;
  121|       |
  122|      0|Alarm::Alarm() : alarm_(new internal::AlarmImpl()) {
  123|      0|  g_gli_initializer.summon();
  124|      0|}
  125|       |
  126|       |void Alarm::SetInternal(::grpc::CompletionQueue* cq, gpr_timespec deadline,
  127|      0|                        void* tag) {
  128|      0|  // Note that we know that alarm_ is actually an internal::AlarmImpl
  129|      0|  // but we declared it as the base pointer to avoid a forward declaration
  130|      0|  // or exposing core data structures in the C++ public headers.
  131|      0|  // Thus it is safe to use a static_cast to the subclass here, and the
  132|      0|  // C++ style guide allows us to do so in this case
  133|      0|  static_cast<internal::AlarmImpl*>(alarm_)->Set(cq, deadline, tag);
  134|      0|}
  135|       |
  136|      0|void Alarm::SetInternal(gpr_timespec deadline, std::function<void(bool)> f) {
  137|      0|  // Note that we know that alarm_ is actually an internal::AlarmImpl
  138|      0|  // but we declared it as the base pointer to avoid a forward declaration
  139|      0|  // or exposing core data structures in the C++ public headers.
  140|      0|  // Thus it is safe to use a static_cast to the subclass here, and the
  141|      0|  // C++ style guide allows us to do so in this case
  142|      0|  static_cast<internal::AlarmImpl*>(alarm_)->Set(deadline, std::move(f));
  143|      0|}
  144|       |
  145|      0|Alarm::~Alarm() {
  146|      0|  if (alarm_ != nullptr) {
  147|      0|    static_cast<internal::AlarmImpl*>(alarm_)->Destroy();
  148|      0|  }
  149|      0|}
  150|       |
  151|      0|void Alarm::Cancel() { static_cast<internal::AlarmImpl*>(alarm_)->Cancel(); }
  152|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/auth_property_iterator.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/security/auth_context.h>
   20|       |
   21|       |#include <grpc/grpc_security.h>
   22|       |
   23|       |namespace grpc {
   24|       |
   25|       |AuthPropertyIterator::AuthPropertyIterator()
   26|      0|    : property_(nullptr), ctx_(nullptr), index_(0), name_(nullptr) {}
   27|       |
   28|       |AuthPropertyIterator::AuthPropertyIterator(
   29|       |    const grpc_auth_property* property, const grpc_auth_property_iterator* iter)
   30|       |    : property_(property),
   31|       |      ctx_(iter->ctx),
   32|       |      index_(iter->index),
   33|      0|      name_(iter->name) {}
   34|       |
   35|      0|AuthPropertyIterator::~AuthPropertyIterator() {}
   36|       |
   37|      0|AuthPropertyIterator& AuthPropertyIterator::operator++() {
   38|      0|  grpc_auth_property_iterator iter = {ctx_, index_, name_};
   39|      0|  property_ = grpc_auth_property_iterator_next(&iter);
   40|      0|  ctx_ = iter.ctx;
   41|      0|  index_ = iter.index;
   42|      0|  name_ = iter.name;
   43|      0|  return *this;
   44|      0|}
   45|       |
   46|      0|AuthPropertyIterator AuthPropertyIterator::operator++(int) {
   47|      0|  AuthPropertyIterator tmp(*this);
   48|      0|  operator++();
   49|      0|  return tmp;
   50|      0|}
   51|       |
   52|      0|bool AuthPropertyIterator::operator==(const AuthPropertyIterator& rhs) const {
   53|      0|  if (property_ == nullptr || rhs.property_ == nullptr) {
   54|      0|    return property_ == rhs.property_;
   55|      0|  } else {
   56|      0|    return index_ == rhs.index_;
   57|      0|  }
   58|      0|}
   59|       |
   60|      0|bool AuthPropertyIterator::operator!=(const AuthPropertyIterator& rhs) const {
   61|      0|  return !operator==(rhs);
   62|      0|}
   63|       |
   64|      0|const AuthProperty AuthPropertyIterator::operator*() {
   65|      0|  return std::pair<grpc::string_ref, grpc::string_ref>(
   66|      0|      property_->name,
   67|      0|      grpc::string_ref(property_->value, property_->value_length));
   68|      0|}
   69|       |
   70|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/channel_arguments.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |#include <grpcpp/support/channel_arguments.h>
   19|       |
   20|       |#include <sstream>
   21|       |
   22|       |#include <grpc/impl/codegen/grpc_types.h>
   23|       |#include <grpc/support/log.h>
   24|       |#include <grpcpp/grpcpp.h>
   25|       |#include <grpcpp/resource_quota.h>
   26|       |#include "src/core/lib/channel/channel_args.h"
   27|       |#include "src/core/lib/iomgr/exec_ctx.h"
   28|       |#include "src/core/lib/iomgr/socket_mutator.h"
   29|       |
   30|       |namespace grpc_impl {
   31|       |
   32|      0|ChannelArguments::ChannelArguments() {
   33|      0|  // This will be ignored if used on the server side.
   34|      0|  SetString(GRPC_ARG_PRIMARY_USER_AGENT_STRING, "grpc-c++/" + grpc::Version());
   35|      0|}
   36|       |
   37|       |ChannelArguments::ChannelArguments(const ChannelArguments& other)
   38|      0|    : strings_(other.strings_) {
   39|      0|  args_.reserve(other.args_.size());
   40|      0|  auto list_it_dst = strings_.begin();
   41|      0|  auto list_it_src = other.strings_.begin();
   42|      0|  for (auto a = other.args_.begin(); a != other.args_.end(); ++a) {
   43|      0|    grpc_arg ap;
   44|      0|    ap.type = a->type;
   45|      0|    GPR_ASSERT(list_it_src->c_str() == a->key);
   46|      0|    ap.key = const_cast<char*>(list_it_dst->c_str());
   47|      0|    ++list_it_src;
   48|      0|    ++list_it_dst;
   49|      0|    switch (a->type) {
   50|      0|      case GRPC_ARG_INTEGER:
   51|      0|        ap.value.integer = a->value.integer;
   52|      0|        break;
   53|      0|      case GRPC_ARG_STRING:
   54|      0|        GPR_ASSERT(list_it_src->c_str() == a->value.string);
   55|      0|        ap.value.string = const_cast<char*>(list_it_dst->c_str());
   56|      0|        ++list_it_src;
   57|      0|        ++list_it_dst;
   58|      0|        break;
   59|      0|      case GRPC_ARG_POINTER:
   60|      0|        ap.value.pointer = a->value.pointer;
   61|      0|        ap.value.pointer.p = a->value.pointer.vtable->copy(ap.value.pointer.p);
   62|      0|        break;
   63|      0|    }
   64|      0|    args_.push_back(ap);
   65|      0|  }
   66|      0|}
   67|       |
   68|      0|ChannelArguments::~ChannelArguments() {
   69|      0|  grpc_core::ExecCtx exec_ctx;
   70|      0|  for (auto it = args_.begin(); it != args_.end(); ++it) {
   71|      0|    if (it->type == GRPC_ARG_POINTER) {
   72|      0|      it->value.pointer.vtable->destroy(it->value.pointer.p);
   73|      0|    }
   74|      0|  }
   75|      0|}
   76|       |
   77|      0|void ChannelArguments::Swap(ChannelArguments& other) {
   78|      0|  args_.swap(other.args_);
   79|      0|  strings_.swap(other.strings_);
   80|      0|}
   81|       |
   82|       |void ChannelArguments::SetCompressionAlgorithm(
   83|      0|    grpc_compression_algorithm algorithm) {
   84|      0|  SetInt(GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM, algorithm);
   85|      0|}
   86|       |
   87|      0|void ChannelArguments::SetGrpclbFallbackTimeout(int fallback_timeout) {
   88|      0|  SetInt(GRPC_ARG_GRPCLB_FALLBACK_TIMEOUT_MS, fallback_timeout);
   89|      0|}
   90|       |
   91|      0|void ChannelArguments::SetSocketMutator(grpc_socket_mutator* mutator) {
   92|      0|  if (!mutator) {
   93|      0|    return;
   94|      0|  }
   95|      0|  grpc_arg mutator_arg = grpc_socket_mutator_to_arg(mutator);
   96|      0|  bool replaced = false;
   97|      0|  grpc_core::ExecCtx exec_ctx;
   98|      0|  for (auto it = args_.begin(); it != args_.end(); ++it) {
   99|      0|    if (it->type == mutator_arg.type &&
  100|      0|        grpc::string(it->key) == grpc::string(mutator_arg.key)) {
  101|      0|      GPR_ASSERT(!replaced);
  102|      0|      it->value.pointer.vtable->destroy(it->value.pointer.p);
  103|      0|      it->value.pointer = mutator_arg.value.pointer;
  104|      0|      replaced = true;
  105|      0|    }
  106|      0|  }
  107|      0|
  108|      0|  if (!replaced) {
  109|      0|    strings_.push_back(grpc::string(mutator_arg.key));
  110|      0|    args_.push_back(mutator_arg);
  111|      0|    args_.back().key = const_cast<char*>(strings_.back().c_str());
  112|      0|  }
  113|      0|}
  114|       |
  115|       |// Note: a second call to this will add in front the result of the first call.
  116|       |// An example is calling this on a copy of ChannelArguments which already has a
  117|       |// prefix. The user can build up a prefix string by calling this multiple times,
  118|       |// each with more significant identifier.
  119|       |void ChannelArguments::SetUserAgentPrefix(
  120|      0|    const grpc::string& user_agent_prefix) {
  121|      0|  if (user_agent_prefix.empty()) {
  122|      0|    return;
  123|      0|  }
  124|      0|  bool replaced = false;
  125|      0|  auto strings_it = strings_.begin();
  126|      0|  for (auto it = args_.begin(); it != args_.end(); ++it) {
  127|      0|    const grpc_arg& arg = *it;
  128|      0|    ++strings_it;
  129|      0|    if (arg.type == GRPC_ARG_STRING) {
  130|      0|      if (grpc::string(arg.key) == GRPC_ARG_PRIMARY_USER_AGENT_STRING) {
  131|      0|        GPR_ASSERT(arg.value.string == strings_it->c_str());
  132|      0|        *(strings_it) = user_agent_prefix + " " + arg.value.string;
  133|      0|        it->value.string = const_cast<char*>(strings_it->c_str());
  134|      0|        replaced = true;
  135|      0|        break;
  136|      0|      }
  137|      0|      ++strings_it;
  138|      0|    }
  139|      0|  }
  140|      0|  if (!replaced) {
  141|      0|    SetString(GRPC_ARG_PRIMARY_USER_AGENT_STRING, user_agent_prefix);
  142|      0|  }
  143|      0|}
  144|       |
  145|       |void ChannelArguments::SetResourceQuota(
  146|      0|    const grpc_impl::ResourceQuota& resource_quota) {
  147|      0|  SetPointerWithVtable(GRPC_ARG_RESOURCE_QUOTA,
  148|      0|                       resource_quota.c_resource_quota(),
  149|      0|                       grpc_resource_quota_arg_vtable());
  150|      0|}
  151|       |
  152|      0|void ChannelArguments::SetMaxReceiveMessageSize(int size) {
  153|      0|  SetInt(GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH, size);
  154|      0|}
  155|       |
  156|      0|void ChannelArguments::SetMaxSendMessageSize(int size) {
  157|      0|  SetInt(GRPC_ARG_MAX_SEND_MESSAGE_LENGTH, size);
  158|      0|}
  159|       |
  160|       |void ChannelArguments::SetLoadBalancingPolicyName(
  161|      0|    const grpc::string& lb_policy_name) {
  162|      0|  SetString(GRPC_ARG_LB_POLICY_NAME, lb_policy_name);
  163|      0|}
  164|       |
  165|       |void ChannelArguments::SetServiceConfigJSON(
  166|      0|    const grpc::string& service_config_json) {
  167|      0|  SetString(GRPC_ARG_SERVICE_CONFIG, service_config_json);
  168|      0|}
  169|       |
  170|      0|void ChannelArguments::SetInt(const grpc::string& key, int value) {
  171|      0|  grpc_arg arg;
  172|      0|  arg.type = GRPC_ARG_INTEGER;
  173|      0|  strings_.push_back(key);
  174|      0|  arg.key = const_cast<char*>(strings_.back().c_str());
  175|      0|  arg.value.integer = value;
  176|      0|
  177|      0|  args_.push_back(arg);
  178|      0|}
  179|       |
  180|      0|void ChannelArguments::SetPointer(const grpc::string& key, void* value) {
  181|      0|  static const grpc_arg_pointer_vtable vtable = {
  182|      0|      &PointerVtableMembers::Copy, &PointerVtableMembers::Destroy,
  183|      0|      &PointerVtableMembers::Compare};
  184|      0|  SetPointerWithVtable(key, value, &vtable);
  185|      0|}
  186|       |
  187|       |void ChannelArguments::SetPointerWithVtable(
  188|       |    const grpc::string& key, void* value,
  189|      0|    const grpc_arg_pointer_vtable* vtable) {
  190|      0|  grpc_arg arg;
  191|      0|  arg.type = GRPC_ARG_POINTER;
  192|      0|  strings_.push_back(key);
  193|      0|  arg.key = const_cast<char*>(strings_.back().c_str());
  194|      0|  arg.value.pointer.p = vtable->copy(value);
  195|      0|  arg.value.pointer.vtable = vtable;
  196|      0|  args_.push_back(arg);
  197|      0|}
  198|       |
  199|       |void ChannelArguments::SetString(const grpc::string& key,
  200|      0|                                 const grpc::string& value) {
  201|      0|  grpc_arg arg;
  202|      0|  arg.type = GRPC_ARG_STRING;
  203|      0|  strings_.push_back(key);
  204|      0|  arg.key = const_cast<char*>(strings_.back().c_str());
  205|      0|  strings_.push_back(value);
  206|      0|  arg.value.string = const_cast<char*>(strings_.back().c_str());
  207|      0|
  208|      0|  args_.push_back(arg);
  209|      0|}
  210|       |
  211|      0|void ChannelArguments::SetChannelArgs(grpc_channel_args* channel_args) const {
  212|      0|  channel_args->num_args = args_.size();
  213|      0|  if (channel_args->num_args > 0) {
  214|      0|    channel_args->args = const_cast<grpc_arg*>(&args_[0]);
  215|      0|  }
  216|      0|}
  217|       |
  218|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/channel_filter.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <string.h>
   20|       |
   21|       |#include "src/core/lib/channel/channel_stack.h"
   22|       |#include "src/cpp/common/channel_filter.h"
   23|       |
   24|       |#include <grpcpp/impl/codegen/slice.h>
   25|       |
   26|       |namespace grpc {
   27|       |
   28|       |// MetadataBatch
   29|       |
   30|       |grpc_linked_mdelem* MetadataBatch::AddMetadata(const string& key,
   31|      0|                                               const string& value) {
   32|      0|  grpc_linked_mdelem* storage = new grpc_linked_mdelem;
   33|      0|  memset(storage, 0, sizeof(grpc_linked_mdelem));
   34|      0|  storage->md = grpc_mdelem_from_slices(SliceFromCopiedString(key),
   35|      0|                                        SliceFromCopiedString(value));
   36|      0|  GRPC_LOG_IF_ERROR("MetadataBatch::AddMetadata",
   37|      0|                    grpc_metadata_batch_link_head(batch_, storage));
   38|      0|  return storage;
   39|      0|}
   40|       |
   41|       |// ChannelData
   42|       |
   43|       |void ChannelData::StartTransportOp(grpc_channel_element* elem,
   44|      0|                                   TransportOp* op) {
   45|      0|  grpc_channel_next_op(elem, op->op());
   46|      0|}
   47|       |
   48|       |void ChannelData::GetInfo(grpc_channel_element* elem,
   49|      0|                          const grpc_channel_info* channel_info) {
   50|      0|  grpc_channel_next_get_info(elem, channel_info);
   51|      0|}
   52|       |
   53|       |// CallData
   54|       |
   55|       |void CallData::StartTransportStreamOpBatch(grpc_call_element* elem,
   56|      0|                                           TransportStreamOpBatch* op) {
   57|      0|  grpc_call_next_op(elem, op->op());
   58|      0|}
   59|       |
   60|       |void CallData::SetPollsetOrPollsetSet(grpc_call_element* elem,
   61|      0|                                      grpc_polling_entity* pollent) {
   62|      0|  grpc_call_stack_ignore_set_pollset_or_pollset_set(elem, pollent);
   63|      0|}
   64|       |
   65|       |// internal code used by RegisterChannelFilter()
   66|       |
   67|       |namespace internal {
   68|       |
   69|       |// Note: Implicitly initialized to nullptr due to static lifetime.
   70|       |std::vector<FilterRecord>* channel_filters;
   71|       |
   72|       |namespace {
   73|       |
   74|      0|bool MaybeAddFilter(grpc_channel_stack_builder* builder, void* arg) {
   75|      0|  const FilterRecord& filter = *static_cast<FilterRecord*>(arg);
   76|      0|  if (filter.include_filter) {
   77|      0|    const grpc_channel_args* args =
   78|      0|        grpc_channel_stack_builder_get_channel_arguments(builder);
   79|      0|    if (!filter.include_filter(*args)) return true;
   80|      0|  }
   81|      0|  return grpc_channel_stack_builder_prepend_filter(builder, &filter.filter,
   82|      0|                                                   nullptr, nullptr);
   83|      0|}
   84|       |
   85|       |}  // namespace
   86|       |
   87|      0|void ChannelFilterPluginInit() {
   88|      0|  for (size_t i = 0; i < channel_filters->size(); ++i) {
   89|      0|    FilterRecord& filter = (*channel_filters)[i];
   90|      0|    grpc_channel_init_register_stage(filter.stack_type, filter.priority,
   91|      0|                                     MaybeAddFilter, (void*)&filter);
   92|      0|  }
   93|      0|}
   94|       |
   95|      0|void ChannelFilterPluginShutdown() {}
   96|       |
   97|       |}  // namespace internal
   98|       |
   99|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/channel_filter.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPCXX_CHANNEL_FILTER_H
   20|       |#define GRPCXX_CHANNEL_FILTER_H
   21|       |
   22|       |#include <grpc/grpc.h>
   23|       |#include <grpc/support/alloc.h>
   24|       |#include <grpcpp/impl/codegen/config.h>
   25|       |
   26|       |#include <functional>
   27|       |#include <vector>
   28|       |
   29|       |#include "src/core/lib/channel/channel_stack.h"
   30|       |#include "src/core/lib/surface/channel_init.h"
   31|       |#include "src/core/lib/transport/metadata_batch.h"
   32|       |
   33|       |/// An interface to define filters.
   34|       |///
   35|       |/// To define a filter, implement a subclass of each of \c CallData and
   36|       |/// \c ChannelData. Then register the filter using something like this:
   37|       |/// \code{.cpp}
   38|       |///   RegisterChannelFilter<MyChannelDataSubclass, MyCallDataSubclass>(
   39|       |///       "name-of-filter", GRPC_SERVER_CHANNEL, INT_MAX, nullptr);
   40|       |/// \endcode
   41|       |
   42|       |namespace grpc {
   43|       |
   44|       |/// A C++ wrapper for the \c grpc_metadata_batch struct.
   45|       |class MetadataBatch {
   46|       | public:
   47|       |  /// Borrows a pointer to \a batch, but does NOT take ownership.
   48|       |  /// The caller must ensure that \a batch continues to exist for as
   49|       |  /// long as the MetadataBatch object does.
   50|      0|  explicit MetadataBatch(grpc_metadata_batch* batch) : batch_(batch) {}
   51|       |
   52|      0|  grpc_metadata_batch* batch() const { return batch_; }
   53|       |
   54|       |  /// Adds metadata and returns the newly allocated storage.
   55|       |  /// The caller takes ownership of the result, which must exist for the
   56|       |  /// lifetime of the gRPC call.
   57|       |  grpc_linked_mdelem* AddMetadata(const string& key, const string& value);
   58|       |
   59|       |  class const_iterator : public std::iterator<std::bidirectional_iterator_tag,
   60|       |                                              const grpc_mdelem> {
   61|       |   public:
   62|      0|    const grpc_mdelem& operator*() const { return elem_->md; }
   63|      0|    const grpc_mdelem operator->() const { return elem_->md; }
   64|       |
   65|      0|    const_iterator& operator++() {
   66|      0|      elem_ = elem_->next;
   67|      0|      return *this;
   68|      0|    }
   69|      0|    const_iterator operator++(int) {
   70|      0|      const_iterator tmp(*this);
   71|      0|      operator++();
   72|      0|      return tmp;
   73|      0|    }
   74|      0|    const_iterator& operator--() {
   75|      0|      elem_ = elem_->prev;
   76|      0|      return *this;
   77|      0|    }
   78|      0|    const_iterator operator--(int) {
   79|      0|      const_iterator tmp(*this);
   80|      0|      operator--();
   81|      0|      return tmp;
   82|      0|    }
   83|       |
   84|      0|    bool operator==(const const_iterator& other) const {
   85|      0|      return elem_ == other.elem_;
   86|      0|    }
   87|      0|    bool operator!=(const const_iterator& other) const {
   88|      0|      return elem_ != other.elem_;
   89|      0|    }
   90|       |
   91|       |   private:
   92|       |    friend class MetadataBatch;
   93|      0|    explicit const_iterator(grpc_linked_mdelem* elem) : elem_(elem) {}
   94|       |
   95|       |    grpc_linked_mdelem* elem_;
   96|       |  };
   97|       |
   98|      0|  const_iterator begin() const { return const_iterator(batch_->list.head); }
   99|      0|  const_iterator end() const { return const_iterator(nullptr); }
  100|       |
  101|       | private:
  102|       |  grpc_metadata_batch* batch_;  // Not owned.
  103|       |};
  104|       |
  105|       |/// A C++ wrapper for the \c grpc_transport_op struct.
  106|       |class TransportOp {
  107|       | public:
  108|       |  /// Borrows a pointer to \a op, but does NOT take ownership.
  109|       |  /// The caller must ensure that \a op continues to exist for as
  110|       |  /// long as the TransportOp object does.
  111|      0|  explicit TransportOp(grpc_transport_op* op) : op_(op) {}
  112|       |
  113|      0|  grpc_transport_op* op() const { return op_; }
  114|       |
  115|       |  // TODO(roth): Add a C++ wrapper for grpc_error?
  116|      0|  grpc_error* disconnect_with_error() const {
  117|      0|    return op_->disconnect_with_error;
  118|      0|  }
  119|      0|  bool send_goaway() const { return op_->goaway_error != GRPC_ERROR_NONE; }
  120|       |
  121|       |  // TODO(roth): Add methods for additional fields as needed.
  122|       |
  123|       | private:
  124|       |  grpc_transport_op* op_;  // Not owned.
  125|       |};
  126|       |
  127|       |/// A C++ wrapper for the \c grpc_transport_stream_op_batch struct.
  128|       |class TransportStreamOpBatch {
  129|       | public:
  130|       |  /// Borrows a pointer to \a op, but does NOT take ownership.
  131|       |  /// The caller must ensure that \a op continues to exist for as
  132|       |  /// long as the TransportStreamOpBatch object does.
  133|       |  explicit TransportStreamOpBatch(grpc_transport_stream_op_batch* op)
  134|       |      : op_(op),
  135|       |        send_initial_metadata_(
  136|       |            op->send_initial_metadata
  137|       |                ? op->payload->send_initial_metadata.send_initial_metadata
  138|       |                : nullptr),
  139|       |        send_trailing_metadata_(
  140|       |            op->send_trailing_metadata
  141|       |                ? op->payload->send_trailing_metadata.send_trailing_metadata
  142|       |                : nullptr),
  143|       |        recv_initial_metadata_(
  144|       |            op->recv_initial_metadata
  145|       |                ? op->payload->recv_initial_metadata.recv_initial_metadata
  146|       |                : nullptr),
  147|       |        recv_trailing_metadata_(
  148|       |            op->recv_trailing_metadata
  149|       |                ? op->payload->recv_trailing_metadata.recv_trailing_metadata
  150|      0|                : nullptr) {}
  151|       |
  152|      0|  grpc_transport_stream_op_batch* op() const { return op_; }
  153|       |
  154|      0|  grpc_closure* on_complete() const { return op_->on_complete; }
  155|      0|  void set_on_complete(grpc_closure* closure) { op_->on_complete = closure; }
  156|       |
  157|      0|  MetadataBatch* send_initial_metadata() {
  158|      0|    return op_->send_initial_metadata ? &send_initial_metadata_ : nullptr;
  159|      0|  }
  160|      0|  MetadataBatch* send_trailing_metadata() {
  161|      0|    return op_->send_trailing_metadata ? &send_trailing_metadata_ : nullptr;
  162|      0|  }
  163|      0|  MetadataBatch* recv_initial_metadata() {
  164|      0|    return op_->recv_initial_metadata ? &recv_initial_metadata_ : nullptr;
  165|      0|  }
  166|      0|  MetadataBatch* recv_trailing_metadata() {
  167|      0|    return op_->recv_trailing_metadata ? &recv_trailing_metadata_ : nullptr;
  168|      0|  }
  169|       |
  170|      0|  uint32_t* send_initial_metadata_flags() const {
  171|      0|    return op_->send_initial_metadata ? &op_->payload->send_initial_metadata
  172|      0|                                             .send_initial_metadata_flags
  173|      0|                                      : nullptr;
  174|      0|  }
  175|       |
  176|      0|  grpc_closure* recv_initial_metadata_ready() const {
  177|      0|    return op_->recv_initial_metadata
  178|      0|               ? op_->payload->recv_initial_metadata.recv_initial_metadata_ready
  179|      0|               : nullptr;
  180|      0|  }
  181|      0|  void set_recv_initial_metadata_ready(grpc_closure* closure) {
  182|      0|    op_->payload->recv_initial_metadata.recv_initial_metadata_ready = closure;
  183|      0|  }
  184|       |
  185|      0|  grpc_core::OrphanablePtr<grpc_core::ByteStream>* send_message() const {
  186|      0|    return op_->send_message ? &op_->payload->send_message.send_message
  187|      0|                             : nullptr;
  188|      0|  }
  189|       |  void set_send_message(
  190|      0|      grpc_core::OrphanablePtr<grpc_core::ByteStream> send_message) {
  191|      0|    op_->send_message = true;
  192|      0|    op_->payload->send_message.send_message = std::move(send_message);
  193|      0|  }
  194|       |
  195|      0|  grpc_core::OrphanablePtr<grpc_core::ByteStream>* recv_message() const {
  196|      0|    return op_->recv_message ? op_->payload->recv_message.recv_message
  197|      0|                             : nullptr;
  198|      0|  }
  199|       |  void set_recv_message(
  200|      0|      grpc_core::OrphanablePtr<grpc_core::ByteStream>* recv_message) {
  201|      0|    op_->recv_message = true;
  202|      0|    op_->payload->recv_message.recv_message = recv_message;
  203|      0|  }
  204|       |
  205|      0|  census_context* get_census_context() const {
  206|      0|    return static_cast<census_context*>(
  207|      0|        op_->payload->context[GRPC_CONTEXT_TRACING].value);
  208|      0|  }
  209|       |
  210|      0|  const gpr_atm* get_peer_string() const {
  211|      0|    if (op_->send_initial_metadata &&
  212|      0|        op_->payload->send_initial_metadata.peer_string != nullptr) {
  213|      0|      return op_->payload->send_initial_metadata.peer_string;
  214|      0|    } else if (op_->recv_initial_metadata &&
  215|      0|               op_->payload->recv_initial_metadata.peer_string != nullptr) {
  216|      0|      return op_->payload->recv_initial_metadata.peer_string;
  217|      0|    } else {
  218|      0|      return nullptr;
  219|      0|    }
  220|      0|  }
  221|       |
  222|       | private:
  223|       |  grpc_transport_stream_op_batch* op_;  // Not owned.
  224|       |  MetadataBatch send_initial_metadata_;
  225|       |  MetadataBatch send_trailing_metadata_;
  226|       |  MetadataBatch recv_initial_metadata_;
  227|       |  MetadataBatch recv_trailing_metadata_;
  228|       |};
  229|       |
  230|       |/// Represents channel data.
  231|       |class ChannelData {
  232|       | public:
  233|      0|  ChannelData() {}
  234|      0|  virtual ~ChannelData() {}
  235|       |
  236|       |  // TODO(roth): Come up with a more C++-like API for the channel element.
  237|       |
  238|       |  /// Initializes the channel data.
  239|       |  virtual grpc_error* Init(grpc_channel_element* elem,
  240|      0|                           grpc_channel_element_args* args) {
  241|      0|    return GRPC_ERROR_NONE;
  242|      0|  }
  243|       |
  244|       |  // Called before destruction.
  245|      0|  virtual void Destroy(grpc_channel_element* elem) {}
  246|       |
  247|       |  virtual void StartTransportOp(grpc_channel_element* elem, TransportOp* op);
  248|       |
  249|       |  virtual void GetInfo(grpc_channel_element* elem,
  250|       |                       const grpc_channel_info* channel_info);
  251|       |};
  252|       |
  253|       |/// Represents call data.
  254|       |class CallData {
  255|       | public:
  256|      0|  CallData() {}
  257|      0|  virtual ~CallData() {}
  258|       |
  259|       |  // TODO(roth): Come up with a more C++-like API for the call element.
  260|       |
  261|       |  /// Initializes the call data.
  262|       |  virtual grpc_error* Init(grpc_call_element* elem,
  263|      0|                           const grpc_call_element_args* args) {
  264|      0|    return GRPC_ERROR_NONE;
  265|      0|  }
  266|       |
  267|       |  // Called before destruction.
  268|       |  virtual void Destroy(grpc_call_element* elem,
  269|       |                       const grpc_call_final_info* final_info,
  270|      0|                       grpc_closure* then_call_closure) {}
  271|       |
  272|       |  /// Starts a new stream operation.
  273|       |  virtual void StartTransportStreamOpBatch(grpc_call_element* elem,
  274|       |                                           TransportStreamOpBatch* op);
  275|       |
  276|       |  /// Sets a pollset or pollset set.
  277|       |  virtual void SetPollsetOrPollsetSet(grpc_call_element* elem,
  278|       |                                      grpc_polling_entity* pollent);
  279|       |};
  280|       |
  281|       |namespace internal {
  282|       |
  283|       |// Defines static members for passing to C core.
  284|       |// Members of this class correspond to the members of the C
  285|       |// grpc_channel_filter struct.
  286|       |template <typename ChannelDataType, typename CallDataType>
  287|       |class ChannelFilter final {
  288|       | public:
  289|       |  static const size_t channel_data_size = sizeof(ChannelDataType);
  290|       |
  291|       |  static grpc_error* InitChannelElement(grpc_channel_element* elem,
  292|       |                                        grpc_channel_element_args* args) {
  293|       |    // Construct the object in the already-allocated memory.
  294|       |    ChannelDataType* channel_data = new (elem->channel_data) ChannelDataType();
  295|       |    return channel_data->Init(elem, args);
  296|       |  }
  297|       |
  298|       |  static void DestroyChannelElement(grpc_channel_element* elem) {
  299|       |    ChannelDataType* channel_data =
  300|       |        static_cast<ChannelDataType*>(elem->channel_data);
  301|       |    channel_data->Destroy(elem);
  302|       |    channel_data->~ChannelDataType();
  303|       |  }
  304|       |
  305|       |  static void StartTransportOp(grpc_channel_element* elem,
  306|       |                               grpc_transport_op* op) {
  307|       |    ChannelDataType* channel_data =
  308|       |        static_cast<ChannelDataType*>(elem->channel_data);
  309|       |    TransportOp op_wrapper(op);
  310|       |    channel_data->StartTransportOp(elem, &op_wrapper);
  311|       |  }
  312|       |
  313|       |  static void GetChannelInfo(grpc_channel_element* elem,
  314|       |                             const grpc_channel_info* channel_info) {
  315|       |    ChannelDataType* channel_data =
  316|       |        static_cast<ChannelDataType*>(elem->channel_data);
  317|       |    channel_data->GetInfo(elem, channel_info);
  318|       |  }
  319|       |
  320|       |  static const size_t call_data_size = sizeof(CallDataType);
  321|       |
  322|       |  static grpc_error* InitCallElement(grpc_call_element* elem,
  323|       |                                     const grpc_call_element_args* args) {
  324|       |    // Construct the object in the already-allocated memory.
  325|       |    CallDataType* call_data = new (elem->call_data) CallDataType();
  326|       |    return call_data->Init(elem, args);
  327|       |  }
  328|       |
  329|       |  static void DestroyCallElement(grpc_call_element* elem,
  330|       |                                 const grpc_call_final_info* final_info,
  331|       |                                 grpc_closure* then_call_closure) {
  332|       |    CallDataType* call_data = static_cast<CallDataType*>(elem->call_data);
  333|       |    call_data->Destroy(elem, final_info, then_call_closure);
  334|       |    call_data->~CallDataType();
  335|       |  }
  336|       |
  337|       |  static void StartTransportStreamOpBatch(grpc_call_element* elem,
  338|       |                                          grpc_transport_stream_op_batch* op) {
  339|       |    CallDataType* call_data = static_cast<CallDataType*>(elem->call_data);
  340|       |    TransportStreamOpBatch op_wrapper(op);
  341|       |    call_data->StartTransportStreamOpBatch(elem, &op_wrapper);
  342|       |  }
  343|       |
  344|       |  static void SetPollsetOrPollsetSet(grpc_call_element* elem,
  345|       |                                     grpc_polling_entity* pollent) {
  346|       |    CallDataType* call_data = static_cast<CallDataType*>(elem->call_data);
  347|       |    call_data->SetPollsetOrPollsetSet(elem, pollent);
  348|       |  }
  349|       |};
  350|       |
  351|       |struct FilterRecord {
  352|       |  grpc_channel_stack_type stack_type;
  353|       |  int priority;
  354|       |  std::function<bool(const grpc_channel_args&)> include_filter;
  355|       |  grpc_channel_filter filter;
  356|       |};
  357|       |extern std::vector<FilterRecord>* channel_filters;
  358|       |
  359|       |void ChannelFilterPluginInit();
  360|       |void ChannelFilterPluginShutdown();
  361|       |
  362|       |}  // namespace internal
  363|       |
  364|       |/// Registers a new filter.
  365|       |/// Must be called by only one thread at a time.
  366|       |/// The \a include_filter argument specifies a function that will be called
  367|       |/// to determine at run-time whether or not to add the filter. If the
  368|       |/// value is nullptr, the filter will be added unconditionally.
  369|       |/// If the channel stack type is GRPC_CLIENT_SUBCHANNEL, the caller should
  370|       |/// ensure that subchannels with different filter lists will always have
  371|       |/// different channel args. This requires setting a channel arg in case the
  372|       |/// registration function relies on some condition other than channel args to
  373|       |/// decide whether to add a filter or not.
  374|       |template <typename ChannelDataType, typename CallDataType>
  375|       |void RegisterChannelFilter(
  376|       |    const char* name, grpc_channel_stack_type stack_type, int priority,
  377|       |    std::function<bool(const grpc_channel_args&)> include_filter) {
  378|       |  // If we haven't been called before, initialize channel_filters and
  379|       |  // call grpc_register_plugin().
  380|       |  if (internal::channel_filters == nullptr) {
  381|       |    grpc_register_plugin(internal::ChannelFilterPluginInit,
  382|       |                         internal::ChannelFilterPluginShutdown);
  383|       |    internal::channel_filters = new std::vector<internal::FilterRecord>();
  384|       |  }
  385|       |  // Add an entry to channel_filters. The filter will be added when the
  386|       |  // C-core initialization code calls ChannelFilterPluginInit().
  387|       |  typedef internal::ChannelFilter<ChannelDataType, CallDataType> FilterType;
  388|       |  internal::FilterRecord filter_record = {
  389|       |      stack_type,
  390|       |      priority,
  391|       |      include_filter,
  392|       |      {FilterType::StartTransportStreamOpBatch, FilterType::StartTransportOp,
  393|       |       FilterType::call_data_size, FilterType::InitCallElement,
  394|       |       FilterType::SetPollsetOrPollsetSet, FilterType::DestroyCallElement,
  395|       |       FilterType::channel_data_size, FilterType::InitChannelElement,
  396|       |       FilterType::DestroyChannelElement, FilterType::GetChannelInfo, name}};
  397|       |  internal::channel_filters->push_back(filter_record);
  398|       |}
  399|       |
  400|       |}  // namespace grpc
  401|       |
  402|       |#endif  // GRPCXX_CHANNEL_FILTER_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/completion_queue_cc.cc:
    1|       |/*
    2|       | * Copyright 2015 gRPC authors.
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *     http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | *
   16|       | */
   17|       |
   18|       |#include <grpcpp/completion_queue.h>
   19|       |
   20|       |#include <memory>
   21|       |
   22|       |#include <grpc/grpc.h>
   23|       |#include <grpc/support/log.h>
   24|       |#include <grpcpp/impl/grpc_library.h>
   25|       |#include <grpcpp/support/time.h>
   26|       |
   27|       |namespace grpc_impl {
   28|       |
   29|       |static ::grpc::internal::GrpcLibraryInitializer g_gli_initializer;
   30|       |
   31|       |// 'CompletionQueue' constructor can safely call GrpcLibraryCodegen(false) here
   32|       |// i.e not have GrpcLibraryCodegen call grpc_init(). This is because, to create
   33|       |// a 'grpc_completion_queue' instance (which is being passed as the input to
   34|       |// this constructor), one must have already called grpc_init().
   35|       |CompletionQueue::CompletionQueue(grpc_completion_queue* take)
   36|      0|    : GrpcLibraryCodegen(false), cq_(take) {
   37|      0|  InitialAvalanching();
   38|      0|}
   39|       |
   40|      0|void CompletionQueue::Shutdown() {
   41|      0|  g_gli_initializer.summon();
   42|      0|  CompleteAvalanching();
   43|      0|}
   44|       |
   45|       |CompletionQueue::NextStatus CompletionQueue::AsyncNextInternal(
   46|      0|    void** tag, bool* ok, gpr_timespec deadline) {
   47|      0|  for (;;) {
   48|      0|    auto ev = grpc_completion_queue_next(cq_, deadline, nullptr);
   49|      0|    switch (ev.type) {
   50|      0|      case GRPC_QUEUE_TIMEOUT:
   51|      0|        return TIMEOUT;
   52|      0|      case GRPC_QUEUE_SHUTDOWN:
   53|      0|        return SHUTDOWN;
   54|      0|      case GRPC_OP_COMPLETE:
   55|      0|        auto core_cq_tag =
   56|      0|            static_cast<::grpc::internal::CompletionQueueTag*>(ev.tag);
   57|      0|        *ok = ev.success != 0;
   58|      0|        *tag = core_cq_tag;
   59|      0|        if (core_cq_tag->FinalizeResult(tag, ok)) {
   60|      0|          return GOT_EVENT;
   61|      0|        }
   62|      0|        break;
   63|      0|    }
   64|      0|  }
   65|      0|}
   66|       |
   67|       |CompletionQueue::CompletionQueueTLSCache::CompletionQueueTLSCache(
   68|       |    CompletionQueue* cq)
   69|      0|    : cq_(cq), flushed_(false) {
   70|      0|  grpc_completion_queue_thread_local_cache_init(cq_->cq_);
   71|      0|}
   72|       |
   73|      0|CompletionQueue::CompletionQueueTLSCache::~CompletionQueueTLSCache() {
   74|      0|  GPR_ASSERT(flushed_);
   75|      0|}
   76|       |
   77|      0|bool CompletionQueue::CompletionQueueTLSCache::Flush(void** tag, bool* ok) {
   78|      0|  int res = 0;
   79|      0|  void* res_tag;
   80|      0|  flushed_ = true;
   81|      0|  if (grpc_completion_queue_thread_local_cache_flush(cq_->cq_, &res_tag,
   82|      0|                                                     &res)) {
   83|      0|    auto core_cq_tag =
   84|      0|        static_cast<::grpc::internal::CompletionQueueTag*>(res_tag);
   85|      0|    *ok = res == 1;
   86|      0|    if (core_cq_tag->FinalizeResult(tag, ok)) {
   87|      0|      return true;
   88|      0|    }
   89|      0|  }
   90|      0|  return false;
   91|      0|}
   92|       |
   93|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/core_codegen.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/impl/codegen/core_codegen.h>
   20|       |
   21|       |#include <stdlib.h>
   22|       |
   23|       |#include <grpc/byte_buffer.h>
   24|       |#include <grpc/byte_buffer_reader.h>
   25|       |#include <grpc/grpc.h>
   26|       |#include <grpc/slice.h>
   27|       |#include <grpc/slice_buffer.h>
   28|       |#include <grpc/support/alloc.h>
   29|       |#include <grpc/support/log.h>
   30|       |#include <grpc/support/port_platform.h>
   31|       |#include <grpc/support/sync.h>
   32|       |#include <grpcpp/support/config.h>
   33|       |
   34|       |#include "src/core/lib/profiling/timers.h"
   35|       |
   36|       |struct grpc_byte_buffer;
   37|       |
   38|       |namespace grpc {
   39|       |
   40|       |const grpc_completion_queue_factory*
   41|       |CoreCodegen::grpc_completion_queue_factory_lookup(
   42|      0|    const grpc_completion_queue_attributes* attributes) {
   43|      0|  return ::grpc_completion_queue_factory_lookup(attributes);
   44|      0|}
   45|       |
   46|       |grpc_completion_queue* CoreCodegen::grpc_completion_queue_create(
   47|       |    const grpc_completion_queue_factory* factory,
   48|      0|    const grpc_completion_queue_attributes* attributes, void* reserved) {
   49|      0|  return ::grpc_completion_queue_create(factory, attributes, reserved);
   50|      0|}
   51|       |
   52|       |grpc_completion_queue* CoreCodegen::grpc_completion_queue_create_for_next(
   53|      0|    void* reserved) {
   54|      0|  return ::grpc_completion_queue_create_for_next(reserved);
   55|      0|}
   56|       |
   57|       |grpc_completion_queue* CoreCodegen::grpc_completion_queue_create_for_pluck(
   58|      0|    void* reserved) {
   59|      0|  return ::grpc_completion_queue_create_for_pluck(reserved);
   60|      0|}
   61|       |
   62|      0|void CoreCodegen::grpc_completion_queue_shutdown(grpc_completion_queue* cq) {
   63|      0|  ::grpc_completion_queue_shutdown(cq);
   64|      0|}
   65|       |
   66|      0|void CoreCodegen::grpc_completion_queue_destroy(grpc_completion_queue* cq) {
   67|      0|  ::grpc_completion_queue_destroy(cq);
   68|      0|}
   69|       |
   70|       |grpc_event CoreCodegen::grpc_completion_queue_pluck(grpc_completion_queue* cq,
   71|       |                                                    void* tag,
   72|       |                                                    gpr_timespec deadline,
   73|      0|                                                    void* reserved) {
   74|      0|  return ::grpc_completion_queue_pluck(cq, tag, deadline, reserved);
   75|      0|}
   76|       |
   77|      0|void* CoreCodegen::gpr_malloc(size_t size) { return ::gpr_malloc(size); }
   78|       |
   79|      0|void CoreCodegen::gpr_free(void* p) { return ::gpr_free(p); }
   80|       |
   81|      0|void CoreCodegen::grpc_init() { ::grpc_init(); }
   82|      0|void CoreCodegen::grpc_shutdown() { ::grpc_shutdown(); }
   83|       |
   84|      0|void CoreCodegen::gpr_mu_init(gpr_mu* mu) { ::gpr_mu_init(mu); }
   85|      0|void CoreCodegen::gpr_mu_destroy(gpr_mu* mu) { ::gpr_mu_destroy(mu); }
   86|      0|void CoreCodegen::gpr_mu_lock(gpr_mu* mu) { ::gpr_mu_lock(mu); }
   87|      0|void CoreCodegen::gpr_mu_unlock(gpr_mu* mu) { ::gpr_mu_unlock(mu); }
   88|      0|void CoreCodegen::gpr_cv_init(gpr_cv* cv) { ::gpr_cv_init(cv); }
   89|      0|void CoreCodegen::gpr_cv_destroy(gpr_cv* cv) { ::gpr_cv_destroy(cv); }
   90|       |int CoreCodegen::gpr_cv_wait(gpr_cv* cv, gpr_mu* mu,
   91|      0|                             gpr_timespec abs_deadline) {
   92|      0|  return ::gpr_cv_wait(cv, mu, abs_deadline);
   93|      0|}
   94|      0|void CoreCodegen::gpr_cv_signal(gpr_cv* cv) { ::gpr_cv_signal(cv); }
   95|      0|void CoreCodegen::gpr_cv_broadcast(gpr_cv* cv) { ::gpr_cv_broadcast(cv); }
   96|       |
   97|      0|grpc_byte_buffer* CoreCodegen::grpc_byte_buffer_copy(grpc_byte_buffer* bb) {
   98|      0|  return ::grpc_byte_buffer_copy(bb);
   99|      0|}
  100|       |
  101|      0|void CoreCodegen::grpc_byte_buffer_destroy(grpc_byte_buffer* bb) {
  102|      0|  ::grpc_byte_buffer_destroy(bb);
  103|      0|}
  104|       |
  105|      0|size_t CoreCodegen::grpc_byte_buffer_length(grpc_byte_buffer* bb) {
  106|      0|  return ::grpc_byte_buffer_length(bb);
  107|      0|}
  108|       |
  109|       |grpc_call_error CoreCodegen::grpc_call_start_batch(grpc_call* call,
  110|       |                                                   const grpc_op* ops,
  111|       |                                                   size_t nops, void* tag,
  112|      0|                                                   void* reserved) {
  113|      0|  return ::grpc_call_start_batch(call, ops, nops, tag, reserved);
  114|      0|}
  115|       |
  116|       |grpc_call_error CoreCodegen::grpc_call_cancel_with_status(
  117|       |    grpc_call* call, grpc_status_code status, const char* description,
  118|      0|    void* reserved) {
  119|      0|  return ::grpc_call_cancel_with_status(call, status, description, reserved);
  120|      0|}
  121|      0|void CoreCodegen::grpc_call_ref(grpc_call* call) { ::grpc_call_ref(call); }
  122|      0|void CoreCodegen::grpc_call_unref(grpc_call* call) { ::grpc_call_unref(call); }
  123|      0|void* CoreCodegen::grpc_call_arena_alloc(grpc_call* call, size_t length) {
  124|      0|  return ::grpc_call_arena_alloc(call, length);
  125|      0|}
  126|       |
  127|       |int CoreCodegen::grpc_byte_buffer_reader_init(grpc_byte_buffer_reader* reader,
  128|      0|                                              grpc_byte_buffer* buffer) {
  129|      0|  return ::grpc_byte_buffer_reader_init(reader, buffer);
  130|      0|}
  131|       |
  132|       |void CoreCodegen::grpc_byte_buffer_reader_destroy(
  133|      0|    grpc_byte_buffer_reader* reader) {
  134|      0|  ::grpc_byte_buffer_reader_destroy(reader);
  135|      0|}
  136|       |
  137|       |int CoreCodegen::grpc_byte_buffer_reader_next(grpc_byte_buffer_reader* reader,
  138|      0|                                              grpc_slice* slice) {
  139|      0|  return ::grpc_byte_buffer_reader_next(reader, slice);
  140|      0|}
  141|       |
  142|       |int CoreCodegen::grpc_byte_buffer_reader_peek(grpc_byte_buffer_reader* reader,
  143|      0|                                              grpc_slice** slice) {
  144|      0|  return ::grpc_byte_buffer_reader_peek(reader, slice);
  145|      0|}
  146|       |
  147|       |grpc_byte_buffer* CoreCodegen::grpc_raw_byte_buffer_create(grpc_slice* slice,
  148|      0|                                                           size_t nslices) {
  149|      0|  return ::grpc_raw_byte_buffer_create(slice, nslices);
  150|      0|}
  151|       |
  152|       |grpc_slice CoreCodegen::grpc_slice_new_with_user_data(void* p, size_t len,
  153|       |                                                      void (*destroy)(void*),
  154|      0|                                                      void* user_data) {
  155|      0|  return ::grpc_slice_new_with_user_data(p, len, destroy, user_data);
  156|      0|}
  157|       |
  158|       |grpc_slice CoreCodegen::grpc_slice_new_with_len(void* p, size_t len,
  159|       |                                                void (*destroy)(void*,
  160|      0|                                                                size_t)) {
  161|      0|  return ::grpc_slice_new_with_len(p, len, destroy);
  162|      0|}
  163|       |
  164|      0|grpc_slice CoreCodegen::grpc_empty_slice() { return ::grpc_empty_slice(); }
  165|       |
  166|      0|grpc_slice CoreCodegen::grpc_slice_malloc(size_t length) {
  167|      0|  return ::grpc_slice_malloc(length);
  168|      0|}
  169|       |
  170|      0|void CoreCodegen::grpc_slice_unref(grpc_slice slice) {
  171|      0|  ::grpc_slice_unref(slice);
  172|      0|}
  173|       |
  174|      0|grpc_slice CoreCodegen::grpc_slice_ref(grpc_slice slice) {
  175|      0|  return ::grpc_slice_ref(slice);
  176|      0|}
  177|       |
  178|      0|grpc_slice CoreCodegen::grpc_slice_split_tail(grpc_slice* s, size_t split) {
  179|      0|  return ::grpc_slice_split_tail(s, split);
  180|      0|}
  181|       |
  182|      0|grpc_slice CoreCodegen::grpc_slice_split_head(grpc_slice* s, size_t split) {
  183|      0|  return ::grpc_slice_split_head(s, split);
  184|      0|}
  185|       |
  186|      0|grpc_slice CoreCodegen::grpc_slice_sub(grpc_slice s, size_t begin, size_t end) {
  187|      0|  return ::grpc_slice_sub(s, begin, end);
  188|      0|}
  189|       |
  190|       |grpc_slice CoreCodegen::grpc_slice_from_static_buffer(const void* buffer,
  191|      0|                                                      size_t length) {
  192|      0|  return ::grpc_slice_from_static_buffer(buffer, length);
  193|      0|}
  194|       |
  195|       |grpc_slice CoreCodegen::grpc_slice_from_copied_buffer(const void* buffer,
  196|      0|                                                      size_t length) {
  197|      0|  return ::grpc_slice_from_copied_buffer(static_cast<const char*>(buffer),
  198|      0|                                         length);
  199|      0|}
  200|       |
  201|       |void CoreCodegen::grpc_slice_buffer_add(grpc_slice_buffer* sb,
  202|      0|                                        grpc_slice slice) {
  203|      0|  ::grpc_slice_buffer_add(sb, slice);
  204|      0|}
  205|       |
  206|      0|void CoreCodegen::grpc_slice_buffer_pop(grpc_slice_buffer* sb) {
  207|      0|  ::grpc_slice_buffer_pop(sb);
  208|      0|}
  209|       |
  210|      0|void CoreCodegen::grpc_metadata_array_init(grpc_metadata_array* array) {
  211|      0|  ::grpc_metadata_array_init(array);
  212|      0|}
  213|       |
  214|      0|void CoreCodegen::grpc_metadata_array_destroy(grpc_metadata_array* array) {
  215|      0|  ::grpc_metadata_array_destroy(array);
  216|      0|}
  217|       |
  218|      0|const Status& CoreCodegen::ok() { return grpc::Status::OK; }
  219|       |
  220|      0|const Status& CoreCodegen::cancelled() { return grpc::Status::CANCELLED; }
  221|       |
  222|      0|gpr_timespec CoreCodegen::gpr_inf_future(gpr_clock_type type) {
  223|      0|  return ::gpr_inf_future(type);
  224|      0|}
  225|       |
  226|      0|gpr_timespec CoreCodegen::gpr_time_0(gpr_clock_type type) {
  227|      0|  return ::gpr_time_0(type);
  228|      0|}
  229|       |
  230|       |void CoreCodegen::assert_fail(const char* failed_assertion, const char* file,
  231|      0|                              int line) {
  232|      0|  gpr_log(file, line, GPR_LOG_SEVERITY_ERROR, "assertion failed: %s",
  233|      0|          failed_assertion);
  234|      0|  abort();
  235|      0|}
  236|       |
  237|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/resource_quota_cc.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpc/grpc.h>
   20|       |#include <grpcpp/resource_quota.h>
   21|       |
   22|       |namespace grpc_impl {
   23|       |
   24|      0|ResourceQuota::ResourceQuota() : impl_(grpc_resource_quota_create(nullptr)) {}
   25|       |
   26|       |ResourceQuota::ResourceQuota(const grpc::string& name)
   27|      0|    : impl_(grpc_resource_quota_create(name.c_str())) {}
   28|       |
   29|      0|ResourceQuota::~ResourceQuota() { grpc_resource_quota_unref(impl_); }
   30|       |
   31|      0|ResourceQuota& ResourceQuota::Resize(size_t new_size) {
   32|      0|  grpc_resource_quota_resize(impl_, new_size);
   33|      0|  return *this;
   34|      0|}
   35|       |
   36|      0|ResourceQuota& ResourceQuota::SetMaxThreads(int new_max_threads) {
   37|      0|  grpc_resource_quota_set_max_threads(impl_, new_max_threads);
   38|      0|  return *this;
   39|      0|}
   40|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/secure_auth_context.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include "src/cpp/common/secure_auth_context.h"
   20|       |
   21|       |#include <grpc/grpc_security.h>
   22|       |
   23|       |namespace grpc {
   24|       |
   25|      0|std::vector<grpc::string_ref> SecureAuthContext::GetPeerIdentity() const {
   26|      0|  if (ctx_ == nullptr) {
   27|      0|    return std::vector<grpc::string_ref>();
   28|      0|  }
   29|      0|  grpc_auth_property_iterator iter =
   30|      0|      grpc_auth_context_peer_identity(ctx_.get());
   31|      0|  std::vector<grpc::string_ref> identity;
   32|      0|  const grpc_auth_property* property = nullptr;
   33|      0|  while ((property = grpc_auth_property_iterator_next(&iter))) {
   34|      0|    identity.push_back(
   35|      0|        grpc::string_ref(property->value, property->value_length));
   36|      0|  }
   37|      0|  return identity;
   38|      0|}
   39|       |
   40|      0|grpc::string SecureAuthContext::GetPeerIdentityPropertyName() const {
   41|      0|  if (ctx_ == nullptr) {
   42|      0|    return "";
   43|      0|  }
   44|      0|  const char* name = grpc_auth_context_peer_identity_property_name(ctx_.get());
   45|      0|  return name == nullptr ? "" : name;
   46|      0|}
   47|       |
   48|       |std::vector<grpc::string_ref> SecureAuthContext::FindPropertyValues(
   49|      0|    const grpc::string& name) const {
   50|      0|  if (ctx_ == nullptr) {
   51|      0|    return std::vector<grpc::string_ref>();
   52|      0|  }
   53|      0|  grpc_auth_property_iterator iter =
   54|      0|      grpc_auth_context_find_properties_by_name(ctx_.get(), name.c_str());
   55|      0|  const grpc_auth_property* property = nullptr;
   56|      0|  std::vector<grpc::string_ref> values;
   57|      0|  while ((property = grpc_auth_property_iterator_next(&iter))) {
   58|      0|    values.push_back(grpc::string_ref(property->value, property->value_length));
   59|      0|  }
   60|      0|  return values;
   61|      0|}
   62|       |
   63|      0|AuthPropertyIterator SecureAuthContext::begin() const {
   64|      0|  if (ctx_ != nullptr) {
   65|      0|    grpc_auth_property_iterator iter =
   66|      0|        grpc_auth_context_property_iterator(ctx_.get());
   67|      0|    const grpc_auth_property* property =
   68|      0|        grpc_auth_property_iterator_next(&iter);
   69|      0|    return AuthPropertyIterator(property, &iter);
   70|      0|  } else {
   71|      0|    return end();
   72|      0|  }
   73|      0|}
   74|       |
   75|      0|AuthPropertyIterator SecureAuthContext::end() const {
   76|      0|  return AuthPropertyIterator();
   77|      0|}
   78|       |
   79|       |void SecureAuthContext::AddProperty(const grpc::string& key,
   80|      0|                                    const grpc::string_ref& value) {
   81|      0|  if (ctx_ == nullptr) return;
   82|      0|  grpc_auth_context_add_property(ctx_.get(), key.c_str(), value.data(),
   83|      0|                                 value.size());
   84|      0|}
   85|       |
   86|      0|bool SecureAuthContext::SetPeerIdentityPropertyName(const grpc::string& name) {
   87|      0|  if (ctx_ == nullptr) return false;
   88|      0|  return grpc_auth_context_set_peer_identity_property_name(ctx_.get(),
   89|      0|                                                           name.c_str()) != 0;
   90|      0|}
   91|       |
   92|      0|bool SecureAuthContext::IsPeerAuthenticated() const {
   93|      0|  if (ctx_ == nullptr) return false;
   94|      0|  return grpc_auth_context_peer_is_authenticated(ctx_.get()) != 0;
   95|      0|}
   96|       |
   97|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/secure_auth_context.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_INTERNAL_CPP_COMMON_SECURE_AUTH_CONTEXT_H
   20|       |#define GRPC_INTERNAL_CPP_COMMON_SECURE_AUTH_CONTEXT_H
   21|       |
   22|       |#include <grpcpp/security/auth_context.h>
   23|       |
   24|       |#include "src/core/lib/gprpp/ref_counted_ptr.h"
   25|       |#include "src/core/lib/security/context/security_context.h"
   26|       |
   27|       |namespace grpc {
   28|       |
   29|       |class SecureAuthContext final : public AuthContext {
   30|       | public:
   31|       |  explicit SecureAuthContext(grpc_auth_context* ctx)
   32|      0|      : ctx_(ctx != nullptr ? ctx->Ref() : nullptr) {}
   33|       |
   34|      0|  ~SecureAuthContext() override = default;
   35|       |
   36|       |  bool IsPeerAuthenticated() const override;
   37|       |
   38|       |  std::vector<grpc::string_ref> GetPeerIdentity() const override;
   39|       |
   40|       |  grpc::string GetPeerIdentityPropertyName() const override;
   41|       |
   42|       |  std::vector<grpc::string_ref> FindPropertyValues(
   43|       |      const grpc::string& name) const override;
   44|       |
   45|       |  AuthPropertyIterator begin() const override;
   46|       |
   47|       |  AuthPropertyIterator end() const override;
   48|       |
   49|       |  void AddProperty(const grpc::string& key,
   50|       |                   const grpc::string_ref& value) override;
   51|       |
   52|       |  virtual bool SetPeerIdentityPropertyName(const grpc::string& name) override;
   53|       |
   54|       | private:
   55|       |  grpc_core::RefCountedPtr<grpc_auth_context> ctx_;
   56|       |};
   57|       |
   58|       |}  // namespace grpc
   59|       |
   60|       |#endif  // GRPC_INTERNAL_CPP_COMMON_SECURE_AUTH_CONTEXT_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/secure_channel_arguments.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/support/channel_arguments.h>
   20|       |
   21|       |#include <grpc/grpc_security.h>
   22|       |#include "src/core/lib/channel/channel_args.h"
   23|       |
   24|       |namespace grpc_impl {
   25|       |
   26|      0|void ChannelArguments::SetSslTargetNameOverride(const grpc::string& name) {
   27|      0|  SetString(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG, name);
   28|      0|}
   29|       |
   30|      0|grpc::string ChannelArguments::GetSslTargetNameOverride() const {
   31|      0|  for (unsigned int i = 0; i < args_.size(); i++) {
   32|      0|    if (grpc::string(GRPC_SSL_TARGET_NAME_OVERRIDE_ARG) == args_[i].key) {
   33|      0|      return args_[i].value.string;
   34|      0|    }
   35|      0|  }
   36|      0|  return "";
   37|      0|}
   38|       |
   39|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/secure_create_auth_context.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |#include <memory>
   19|       |
   20|       |#include <grpc/grpc.h>
   21|       |#include <grpc/grpc_security.h>
   22|       |#include <grpcpp/security/auth_context.h>
   23|       |#include "src/core/lib/gprpp/ref_counted_ptr.h"
   24|       |#include "src/cpp/common/secure_auth_context.h"
   25|       |
   26|       |namespace grpc {
   27|       |
   28|      0|std::shared_ptr<const AuthContext> CreateAuthContext(grpc_call* call) {
   29|      0|  if (call == nullptr) {
   30|      0|    return std::shared_ptr<const AuthContext>();
   31|      0|  }
   32|      0|  grpc_core::RefCountedPtr<grpc_auth_context> ctx(grpc_call_auth_context(call));
   33|      0|  return std::make_shared<SecureAuthContext>(ctx.get());
   34|      0|}
   35|       |
   36|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/common/version_cc.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |/* This file is autogenerated from:
   20|       |   templates/src/core/surface/version.c.template */
   21|       |
   22|       |#include <grpcpp/grpcpp.h>
   23|       |
   24|       |namespace grpc {
   25|      0|grpc::string Version() { return "1.21.0"; }
   26|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/async_generic_service.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/generic/async_generic_service.h>
   20|       |
   21|       |#include <grpcpp/server.h>
   22|       |
   23|       |namespace grpc {
   24|       |
   25|       |void AsyncGenericService::RequestCall(
   26|       |    GenericServerContext* ctx, GenericServerAsyncReaderWriter* reader_writer,
   27|       |    CompletionQueue* call_cq, ServerCompletionQueue* notification_cq,
   28|      0|    void* tag) {
   29|      0|  server_->RequestAsyncGenericCall(ctx, reader_writer, call_cq, notification_cq,
   30|      0|                                   tag);
   31|      0|}
   32|       |
   33|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/channel_argument_option.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2017 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/impl/channel_argument_option.h>
   20|       |
   21|       |namespace grpc {
   22|       |
   23|       |std::unique_ptr<ServerBuilderOption> MakeChannelArgumentOption(
   24|      0|    const grpc::string& name, const grpc::string& value) {
   25|      0|  class StringOption final : public ServerBuilderOption {
   26|      0|   public:
   27|      0|    StringOption(const grpc::string& name, const grpc::string& value)
   28|      0|        : name_(name), value_(value) {}
   29|      0|
   30|      0|    virtual void UpdateArguments(ChannelArguments* args) override {
   31|      0|      args->SetString(name_, value_);
   32|      0|    }
   33|      0|    virtual void UpdatePlugins(
   34|      0|        std::vector<std::unique_ptr<ServerBuilderPlugin>>* plugins) override {}
   35|      0|
   36|      0|   private:
   37|      0|    const grpc::string name_;
   38|      0|    const grpc::string value_;
   39|      0|  };
   40|      0|  return std::unique_ptr<ServerBuilderOption>(new StringOption(name, value));
   41|      0|}
   42|       |
   43|       |std::unique_ptr<ServerBuilderOption> MakeChannelArgumentOption(
   44|      0|    const grpc::string& name, int value) {
   45|      0|  class IntOption final : public ServerBuilderOption {
   46|      0|   public:
   47|      0|    IntOption(const grpc::string& name, int value)
   48|      0|        : name_(name), value_(value) {}
   49|      0|
   50|      0|    virtual void UpdateArguments(ChannelArguments* args) override {
   51|      0|      args->SetInt(name_, value_);
   52|      0|    }
   53|      0|    virtual void UpdatePlugins(
   54|      0|        std::vector<std::unique_ptr<ServerBuilderPlugin>>* plugins) override {}
   55|      0|
   56|      0|   private:
   57|      0|    const grpc::string name_;
   58|      0|    const int value_;
   59|      0|  };
   60|      0|  return std::unique_ptr<ServerBuilderOption>(new IntOption(name, value));
   61|      0|}
   62|       |
   63|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/create_default_thread_pool.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpc/support/cpu.h>
   20|       |
   21|       |#include "src/cpp/server/dynamic_thread_pool.h"
   22|       |
   23|       |#ifndef GRPC_CUSTOM_DEFAULT_THREAD_POOL
   24|       |
   25|       |namespace grpc {
   26|       |namespace {
   27|       |
   28|      0|ThreadPoolInterface* CreateDefaultThreadPoolImpl() {
   29|      0|  int cores = gpr_cpu_num_cores();
   30|      0|  if (!cores) cores = 4;
   31|      0|  return new DynamicThreadPool(cores);
   32|      0|}
   33|       |
   34|       |CreateThreadPoolFunc g_ctp_impl = CreateDefaultThreadPoolImpl;
   35|       |
   36|       |}  // namespace
   37|       |
   38|      0|ThreadPoolInterface* CreateDefaultThreadPool() { return g_ctp_impl(); }
   39|       |
   40|      0|void SetCreateThreadPool(CreateThreadPoolFunc func) { g_ctp_impl = func; }
   41|       |
   42|       |}  // namespace grpc
   43|       |
   44|       |#endif  // !GRPC_CUSTOM_DEFAULT_THREAD_POOL

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/dynamic_thread_pool.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include "src/cpp/server/dynamic_thread_pool.h"
   20|       |
   21|       |#include <mutex>
   22|       |
   23|       |#include <grpc/support/log.h>
   24|       |#include <grpcpp/impl/codegen/sync.h>
   25|       |
   26|       |#include "src/core/lib/gprpp/thd.h"
   27|       |
   28|       |namespace grpc {
   29|       |
   30|       |DynamicThreadPool::DynamicThread::DynamicThread(DynamicThreadPool* pool)
   31|       |    : pool_(pool),
   32|       |      thd_("grpcpp_dynamic_pool",
   33|      0|           [](void* th) {
   34|      0|             static_cast<DynamicThreadPool::DynamicThread*>(th)->ThreadFunc();
   35|      0|           },
   36|      0|           this) {
   37|      0|  thd_.Start();
   38|      0|}
   39|      0|DynamicThreadPool::DynamicThread::~DynamicThread() { thd_.Join(); }
   40|       |
   41|      0|void DynamicThreadPool::DynamicThread::ThreadFunc() {
   42|      0|  pool_->ThreadFunc();
   43|      0|  // Now that we have killed ourselves, we should reduce the thread count
   44|      0|  grpc_core::MutexLock lock(&pool_->mu_);
   45|      0|  pool_->nthreads_--;
   46|      0|  // Move ourselves to dead list
   47|      0|  pool_->dead_threads_.push_back(this);
   48|      0|
   49|      0|  if ((pool_->shutdown_) && (pool_->nthreads_ == 0)) {
   50|      0|    pool_->shutdown_cv_.Signal();
   51|      0|  }
   52|      0|}
   53|       |
   54|      0|void DynamicThreadPool::ThreadFunc() {
   55|      0|  for (;;) {
   56|      0|    // Wait until work is available or we are shutting down.
   57|      0|    grpc_core::ReleasableMutexLock lock(&mu_);
   58|      0|    if (!shutdown_ && callbacks_.empty()) {
   59|      0|      // If there are too many threads waiting, then quit this thread
   60|      0|      if (threads_waiting_ >= reserve_threads_) {
   61|      0|        break;
   62|      0|      }
   63|      0|      threads_waiting_++;
   64|      0|      cv_.Wait(&mu_);
   65|      0|      threads_waiting_--;
   66|      0|    }
   67|      0|    // Drain callbacks before considering shutdown to ensure all work
   68|      0|    // gets completed.
   69|      0|    if (!callbacks_.empty()) {
   70|      0|      auto cb = callbacks_.front();
   71|      0|      callbacks_.pop();
   72|      0|      lock.Unlock();
   73|      0|      cb();
   74|      0|    } else if (shutdown_) {
   75|      0|      break;
   76|      0|    }
   77|      0|  }
   78|      0|}
   79|       |
   80|       |DynamicThreadPool::DynamicThreadPool(int reserve_threads)
   81|       |    : shutdown_(false),
   82|       |      reserve_threads_(reserve_threads),
   83|       |      nthreads_(0),
   84|      0|      threads_waiting_(0) {
   85|      0|  for (int i = 0; i < reserve_threads_; i++) {
   86|      0|    grpc_core::MutexLock lock(&mu_);
   87|      0|    nthreads_++;
   88|      0|    new DynamicThread(this);
   89|      0|  }
   90|      0|}
   91|       |
   92|      0|void DynamicThreadPool::ReapThreads(std::list<DynamicThread*>* tlist) {
   93|      0|  for (auto t = tlist->begin(); t != tlist->end(); t = tlist->erase(t)) {
   94|      0|    delete *t;
   95|      0|  }
   96|      0|}
   97|       |
   98|      0|DynamicThreadPool::~DynamicThreadPool() {
   99|      0|  grpc_core::MutexLock lock(&mu_);
  100|      0|  shutdown_ = true;
  101|      0|  cv_.Broadcast();
  102|      0|  while (nthreads_ != 0) {
  103|      0|    shutdown_cv_.Wait(&mu_);
  104|      0|  }
  105|      0|  ReapThreads(&dead_threads_);
  106|      0|}
  107|       |
  108|      0|void DynamicThreadPool::Add(const std::function<void()>& callback) {
  109|      0|  grpc_core::MutexLock lock(&mu_);
  110|      0|  // Add works to the callbacks list
  111|      0|  callbacks_.push(callback);
  112|      0|  // Increase pool size or notify as needed
  113|      0|  if (threads_waiting_ == 0) {
  114|      0|    // Kick off a new thread
  115|      0|    nthreads_++;
  116|      0|    new DynamicThread(this);
  117|      0|  } else {
  118|      0|    cv_.Signal();
  119|      0|  }
  120|      0|  // Also use this chance to harvest dead threads
  121|      0|  if (!dead_threads_.empty()) {
  122|      0|    ReapThreads(&dead_threads_);
  123|      0|  }
  124|      0|}
  125|       |
  126|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/health/default_health_check_service.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <memory>
   20|       |#include <mutex>
   21|       |
   22|       |#include <grpc/slice.h>
   23|       |#include <grpc/support/alloc.h>
   24|       |#include <grpc/support/log.h>
   25|       |#include <grpcpp/impl/codegen/method_handler_impl.h>
   26|       |
   27|       |#include <nanopb/pb_decode.h>
   28|       |#include <nanopb/pb_encode.h>
   29|       |#include "src/core/ext/filters/client_channel/health/health.pb.h"
   30|       |#include "src/cpp/server/health/default_health_check_service.h"
   31|       |
   32|       |namespace grpc {
   33|       |
   34|       |//
   35|       |// DefaultHealthCheckService
   36|       |//
   37|       |
   38|      0|DefaultHealthCheckService::DefaultHealthCheckService() {
   39|      0|  services_map_[""].SetServingStatus(SERVING);
   40|      0|}
   41|       |
   42|       |void DefaultHealthCheckService::SetServingStatus(
   43|      0|    const grpc::string& service_name, bool serving) {
   44|      0|  grpc_core::MutexLock lock(&mu_);
   45|      0|  if (shutdown_) {
   46|      0|    // Set to NOT_SERVING in case service_name is not in the map.
   47|      0|    serving = false;
   48|      0|  }
   49|      0|  services_map_[service_name].SetServingStatus(serving ? SERVING : NOT_SERVING);
   50|      0|}
   51|       |
   52|      0|void DefaultHealthCheckService::SetServingStatus(bool serving) {
   53|      0|  const ServingStatus status = serving ? SERVING : NOT_SERVING;
   54|      0|  grpc_core::MutexLock lock(&mu_);
   55|      0|  if (shutdown_) {
   56|      0|    return;
   57|      0|  }
   58|      0|  for (auto& p : services_map_) {
   59|      0|    ServiceData& service_data = p.second;
   60|      0|    service_data.SetServingStatus(status);
   61|      0|  }
   62|      0|}
   63|       |
   64|      0|void DefaultHealthCheckService::Shutdown() {
   65|      0|  grpc_core::MutexLock lock(&mu_);
   66|      0|  if (shutdown_) {
   67|      0|    return;
   68|      0|  }
   69|      0|  shutdown_ = true;
   70|      0|  for (auto& p : services_map_) {
   71|      0|    ServiceData& service_data = p.second;
   72|      0|    service_data.SetServingStatus(NOT_SERVING);
   73|      0|  }
   74|      0|}
   75|       |
   76|       |DefaultHealthCheckService::ServingStatus
   77|       |DefaultHealthCheckService::GetServingStatus(
   78|      0|    const grpc::string& service_name) const {
   79|      0|  grpc_core::MutexLock lock(&mu_);
   80|      0|  auto it = services_map_.find(service_name);
   81|      0|  if (it == services_map_.end()) {
   82|      0|    return NOT_FOUND;
   83|      0|  }
   84|      0|  const ServiceData& service_data = it->second;
   85|      0|  return service_data.GetServingStatus();
   86|      0|}
   87|       |
   88|       |void DefaultHealthCheckService::RegisterCallHandler(
   89|       |    const grpc::string& service_name,
   90|      0|    std::shared_ptr<HealthCheckServiceImpl::CallHandler> handler) {
   91|      0|  grpc_core::MutexLock lock(&mu_);
   92|      0|  ServiceData& service_data = services_map_[service_name];
   93|      0|  service_data.AddCallHandler(handler /* copies ref */);
   94|      0|  HealthCheckServiceImpl::CallHandler* h = handler.get();
   95|      0|  h->SendHealth(std::move(handler), service_data.GetServingStatus());
   96|      0|}
   97|       |
   98|       |void DefaultHealthCheckService::UnregisterCallHandler(
   99|       |    const grpc::string& service_name,
  100|      0|    const std::shared_ptr<HealthCheckServiceImpl::CallHandler>& handler) {
  101|      0|  grpc_core::MutexLock lock(&mu_);
  102|      0|  auto it = services_map_.find(service_name);
  103|      0|  if (it == services_map_.end()) return;
  104|      0|  ServiceData& service_data = it->second;
  105|      0|  service_data.RemoveCallHandler(handler);
  106|      0|  if (service_data.Unused()) {
  107|      0|    services_map_.erase(it);
  108|      0|  }
  109|      0|}
  110|       |
  111|       |DefaultHealthCheckService::HealthCheckServiceImpl*
  112|       |DefaultHealthCheckService::GetHealthCheckService(
  113|      0|    std::unique_ptr<ServerCompletionQueue> cq) {
  114|      0|  GPR_ASSERT(impl_ == nullptr);
  115|      0|  impl_.reset(new HealthCheckServiceImpl(this, std::move(cq)));
  116|      0|  return impl_.get();
  117|      0|}
  118|       |
  119|       |//
  120|       |// DefaultHealthCheckService::ServiceData
  121|       |//
  122|       |
  123|       |void DefaultHealthCheckService::ServiceData::SetServingStatus(
  124|      0|    ServingStatus status) {
  125|      0|  status_ = status;
  126|      0|  for (auto& call_handler : call_handlers_) {
  127|      0|    call_handler->SendHealth(call_handler /* copies ref */, status);
  128|      0|  }
  129|      0|}
  130|       |
  131|       |void DefaultHealthCheckService::ServiceData::AddCallHandler(
  132|      0|    std::shared_ptr<HealthCheckServiceImpl::CallHandler> handler) {
  133|      0|  call_handlers_.insert(std::move(handler));
  134|      0|}
  135|       |
  136|       |void DefaultHealthCheckService::ServiceData::RemoveCallHandler(
  137|      0|    const std::shared_ptr<HealthCheckServiceImpl::CallHandler>& handler) {
  138|      0|  call_handlers_.erase(handler);
  139|      0|}
  140|       |
  141|       |//
  142|       |// DefaultHealthCheckService::HealthCheckServiceImpl
  143|       |//
  144|       |
  145|       |namespace {
  146|       |const char kHealthCheckMethodName[] = "/grpc.health.v1.Health/Check";
  147|       |const char kHealthWatchMethodName[] = "/grpc.health.v1.Health/Watch";
  148|       |}  // namespace
  149|       |
  150|       |DefaultHealthCheckService::HealthCheckServiceImpl::HealthCheckServiceImpl(
  151|       |    DefaultHealthCheckService* database,
  152|       |    std::unique_ptr<ServerCompletionQueue> cq)
  153|      0|    : database_(database), cq_(std::move(cq)) {
  154|      0|  // Add Check() method.
  155|      0|  AddMethod(new internal::RpcServiceMethod(
  156|      0|      kHealthCheckMethodName, internal::RpcMethod::NORMAL_RPC, nullptr));
  157|      0|  // Add Watch() method.
  158|      0|  AddMethod(new internal::RpcServiceMethod(
  159|      0|      kHealthWatchMethodName, internal::RpcMethod::SERVER_STREAMING, nullptr));
  160|      0|  // Create serving thread.
  161|      0|  thread_ = std::unique_ptr<::grpc_core::Thread>(
  162|      0|      new ::grpc_core::Thread("grpc_health_check_service", Serve, this));
  163|      0|}
  164|       |
  165|      0|DefaultHealthCheckService::HealthCheckServiceImpl::~HealthCheckServiceImpl() {
  166|      0|  // We will reach here after the server starts shutting down.
  167|      0|  shutdown_ = true;
  168|      0|  {
  169|      0|    grpc_core::MutexLock lock(&cq_shutdown_mu_);
  170|      0|    cq_->Shutdown();
  171|      0|  }
  172|      0|  thread_->Join();
  173|      0|}
  174|       |
  175|      0|void DefaultHealthCheckService::HealthCheckServiceImpl::StartServingThread() {
  176|      0|  // Request the calls we're interested in.
  177|      0|  // We do this before starting the serving thread, so that we know it's
  178|      0|  // done before server startup is complete.
  179|      0|  CheckCallHandler::CreateAndStart(cq_.get(), database_, this);
  180|      0|  WatchCallHandler::CreateAndStart(cq_.get(), database_, this);
  181|      0|  // Start serving thread.
  182|      0|  thread_->Start();
  183|      0|}
  184|       |
  185|      0|void DefaultHealthCheckService::HealthCheckServiceImpl::Serve(void* arg) {
  186|      0|  HealthCheckServiceImpl* service =
  187|      0|      reinterpret_cast<HealthCheckServiceImpl*>(arg);
  188|      0|  void* tag;
  189|      0|  bool ok;
  190|      0|  while (true) {
  191|      0|    if (!service->cq_->Next(&tag, &ok)) {
  192|      0|      // The completion queue is shutting down.
  193|      0|      GPR_ASSERT(service->shutdown_);
  194|      0|      break;
  195|      0|    }
  196|      0|    auto* next_step = static_cast<CallableTag*>(tag);
  197|      0|    next_step->Run(ok);
  198|      0|  }
  199|      0|}
  200|       |
  201|       |bool DefaultHealthCheckService::HealthCheckServiceImpl::DecodeRequest(
  202|      0|    const ByteBuffer& request, grpc::string* service_name) {
  203|      0|  std::vector<Slice> slices;
  204|      0|  if (!request.Dump(&slices).ok()) return false;
  205|      0|  uint8_t* request_bytes = nullptr;
  206|      0|  size_t request_size = 0;
  207|      0|  grpc_health_v1_HealthCheckRequest request_struct;
  208|      0|  request_struct.has_service = false;
  209|      0|  if (slices.size() == 1) {
  210|      0|    request_bytes = const_cast<uint8_t*>(slices[0].begin());
  211|      0|    request_size = slices[0].size();
  212|      0|  } else if (slices.size() > 1) {
  213|      0|    request_bytes = static_cast<uint8_t*>(gpr_malloc(request.Length()));
  214|      0|    uint8_t* copy_to = request_bytes;
  215|      0|    for (size_t i = 0; i < slices.size(); i++) {
  216|      0|      memcpy(copy_to, slices[i].begin(), slices[i].size());
  217|      0|      copy_to += slices[i].size();
  218|      0|    }
  219|      0|  }
  220|      0|  pb_istream_t istream = pb_istream_from_buffer(request_bytes, request_size);
  221|      0|  bool decode_status = pb_decode(
  222|      0|      &istream, grpc_health_v1_HealthCheckRequest_fields, &request_struct);
  223|      0|  if (slices.size() > 1) {
  224|      0|    gpr_free(request_bytes);
  225|      0|  }
  226|      0|  if (!decode_status) return false;
  227|      0|  *service_name = request_struct.has_service ? request_struct.service : "";
  228|      0|  return true;
  229|      0|}
  230|       |
  231|       |bool DefaultHealthCheckService::HealthCheckServiceImpl::EncodeResponse(
  232|      0|    ServingStatus status, ByteBuffer* response) {
  233|      0|  grpc_health_v1_HealthCheckResponse response_struct;
  234|      0|  response_struct.has_status = true;
  235|      0|  response_struct.status =
  236|      0|      status == NOT_FOUND
  237|      0|          ? grpc_health_v1_HealthCheckResponse_ServingStatus_SERVICE_UNKNOWN
  238|      0|          : status == SERVING
  239|      0|                ? grpc_health_v1_HealthCheckResponse_ServingStatus_SERVING
  240|      0|                : grpc_health_v1_HealthCheckResponse_ServingStatus_NOT_SERVING;
  241|      0|  pb_ostream_t ostream;
  242|      0|  memset(&ostream, 0, sizeof(ostream));
  243|      0|  pb_encode(&ostream, grpc_health_v1_HealthCheckResponse_fields,
  244|      0|            &response_struct);
  245|      0|  grpc_slice response_slice = grpc_slice_malloc(ostream.bytes_written);
  246|      0|  ostream = pb_ostream_from_buffer(GRPC_SLICE_START_PTR(response_slice),
  247|      0|                                   GRPC_SLICE_LENGTH(response_slice));
  248|      0|  bool encode_status = pb_encode(
  249|      0|      &ostream, grpc_health_v1_HealthCheckResponse_fields, &response_struct);
  250|      0|  if (!encode_status) return false;
  251|      0|  Slice encoded_response(response_slice, Slice::STEAL_REF);
  252|      0|  ByteBuffer response_buffer(&encoded_response, 1);
  253|      0|  response->Swap(&response_buffer);
  254|      0|  return true;
  255|      0|}
  256|       |
  257|       |//
  258|       |// DefaultHealthCheckService::HealthCheckServiceImpl::CheckCallHandler
  259|       |//
  260|       |
  261|       |void DefaultHealthCheckService::HealthCheckServiceImpl::CheckCallHandler::
  262|       |    CreateAndStart(ServerCompletionQueue* cq,
  263|       |                   DefaultHealthCheckService* database,
  264|      0|                   HealthCheckServiceImpl* service) {
  265|      0|  std::shared_ptr<CallHandler> self =
  266|      0|      std::make_shared<CheckCallHandler>(cq, database, service);
  267|      0|  CheckCallHandler* handler = static_cast<CheckCallHandler*>(self.get());
  268|      0|  {
  269|      0|    grpc_core::MutexLock lock(&service->cq_shutdown_mu_);
  270|      0|    if (service->shutdown_) return;
  271|      0|    // Request a Check() call.
  272|      0|    handler->next_ =
  273|      0|        CallableTag(std::bind(&CheckCallHandler::OnCallReceived, handler,
  274|      0|                              std::placeholders::_1, std::placeholders::_2),
  275|      0|                    std::move(self));
  276|      0|    service->RequestAsyncUnary(0, &handler->ctx_, &handler->request_,
  277|      0|                               &handler->writer_, cq, cq, &handler->next_);
  278|      0|  }
  279|      0|}
  280|       |
  281|       |DefaultHealthCheckService::HealthCheckServiceImpl::CheckCallHandler::
  282|       |    CheckCallHandler(ServerCompletionQueue* cq,
  283|       |                     DefaultHealthCheckService* database,
  284|       |                     HealthCheckServiceImpl* service)
  285|      0|    : cq_(cq), database_(database), service_(service), writer_(&ctx_) {}
  286|       |
  287|       |void DefaultHealthCheckService::HealthCheckServiceImpl::CheckCallHandler::
  288|      0|    OnCallReceived(std::shared_ptr<CallHandler> self, bool ok) {
  289|      0|  if (!ok) {
  290|      0|    // The value of ok being false means that the server is shutting down.
  291|      0|    return;
  292|      0|  }
  293|      0|  // Spawn a new handler instance to serve the next new client. Every handler
  294|      0|  // instance will deallocate itself when it's done.
  295|      0|  CreateAndStart(cq_, database_, service_);
  296|      0|  // Process request.
  297|      0|  gpr_log(GPR_DEBUG, "[HCS %p] Health check started for handler %p", service_,
  298|      0|          this);
  299|      0|  grpc::string service_name;
  300|      0|  grpc::Status status = Status::OK;
  301|      0|  ByteBuffer response;
  302|      0|  if (!service_->DecodeRequest(request_, &service_name)) {
  303|      0|    status = Status(StatusCode::INVALID_ARGUMENT, "could not parse request");
  304|      0|  } else {
  305|      0|    ServingStatus serving_status = database_->GetServingStatus(service_name);
  306|      0|    if (serving_status == NOT_FOUND) {
  307|      0|      status = Status(StatusCode::NOT_FOUND, "service name unknown");
  308|      0|    } else if (!service_->EncodeResponse(serving_status, &response)) {
  309|      0|      status = Status(StatusCode::INTERNAL, "could not encode response");
  310|      0|    }
  311|      0|  }
  312|      0|  // Send response.
  313|      0|  {
  314|      0|    grpc_core::MutexLock lock(&service_->cq_shutdown_mu_);
  315|      0|    if (!service_->shutdown_) {
  316|      0|      next_ =
  317|      0|          CallableTag(std::bind(&CheckCallHandler::OnFinishDone, this,
  318|      0|                                std::placeholders::_1, std::placeholders::_2),
  319|      0|                      std::move(self));
  320|      0|      if (status.ok()) {
  321|      0|        writer_.Finish(response, status, &next_);
  322|      0|      } else {
  323|      0|        writer_.FinishWithError(status, &next_);
  324|      0|      }
  325|      0|    }
  326|      0|  }
  327|      0|}
  328|       |
  329|       |void DefaultHealthCheckService::HealthCheckServiceImpl::CheckCallHandler::
  330|      0|    OnFinishDone(std::shared_ptr<CallHandler> self, bool ok) {
  331|      0|  if (ok) {
  332|      0|    gpr_log(GPR_DEBUG, "[HCS %p] Health check call finished for handler %p",
  333|      0|            service_, this);
  334|      0|  }
  335|      0|  self.reset();  // To appease clang-tidy.
  336|      0|}
  337|       |
  338|       |//
  339|       |// DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler
  340|       |//
  341|       |
  342|       |void DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  343|       |    CreateAndStart(ServerCompletionQueue* cq,
  344|       |                   DefaultHealthCheckService* database,
  345|      0|                   HealthCheckServiceImpl* service) {
  346|      0|  std::shared_ptr<CallHandler> self =
  347|      0|      std::make_shared<WatchCallHandler>(cq, database, service);
  348|      0|  WatchCallHandler* handler = static_cast<WatchCallHandler*>(self.get());
  349|      0|  {
  350|      0|    grpc_core::MutexLock lock(&service->cq_shutdown_mu_);
  351|      0|    if (service->shutdown_) return;
  352|      0|    // Request AsyncNotifyWhenDone().
  353|      0|    handler->on_done_notified_ =
  354|      0|        CallableTag(std::bind(&WatchCallHandler::OnDoneNotified, handler,
  355|      0|                              std::placeholders::_1, std::placeholders::_2),
  356|      0|                    self /* copies ref */);
  357|      0|    handler->ctx_.AsyncNotifyWhenDone(&handler->on_done_notified_);
  358|      0|    // Request a Watch() call.
  359|      0|    handler->next_ =
  360|      0|        CallableTag(std::bind(&WatchCallHandler::OnCallReceived, handler,
  361|      0|                              std::placeholders::_1, std::placeholders::_2),
  362|      0|                    std::move(self));
  363|      0|    service->RequestAsyncServerStreaming(1, &handler->ctx_, &handler->request_,
  364|      0|                                         &handler->stream_, cq, cq,
  365|      0|                                         &handler->next_);
  366|      0|  }
  367|      0|}
  368|       |
  369|       |DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  370|       |    WatchCallHandler(ServerCompletionQueue* cq,
  371|       |                     DefaultHealthCheckService* database,
  372|       |                     HealthCheckServiceImpl* service)
  373|      0|    : cq_(cq), database_(database), service_(service), stream_(&ctx_) {}
  374|       |
  375|       |void DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  376|      0|    OnCallReceived(std::shared_ptr<CallHandler> self, bool ok) {
  377|      0|  if (!ok) {
  378|      0|    // Server shutting down.
  379|      0|    //
  380|      0|    // AsyncNotifyWhenDone() needs to be called before the call starts, but the
  381|      0|    // tag will not pop out if the call never starts (
  382|      0|    // https://github.com/grpc/grpc/issues/10136). So we need to manually
  383|      0|    // release the ownership of the handler in this case.
  384|      0|    GPR_ASSERT(on_done_notified_.ReleaseHandler() != nullptr);
  385|      0|    return;
  386|      0|  }
  387|      0|  // Spawn a new handler instance to serve the next new client. Every handler
  388|      0|  // instance will deallocate itself when it's done.
  389|      0|  CreateAndStart(cq_, database_, service_);
  390|      0|  // Parse request.
  391|      0|  if (!service_->DecodeRequest(request_, &service_name_)) {
  392|      0|    SendFinish(std::move(self),
  393|      0|               Status(StatusCode::INVALID_ARGUMENT, "could not parse request"));
  394|      0|    return;
  395|      0|  }
  396|      0|  // Register the call for updates to the service.
  397|      0|  gpr_log(GPR_DEBUG,
  398|      0|          "[HCS %p] Health watch started for service \"%s\" (handler: %p)",
  399|      0|          service_, service_name_.c_str(), this);
  400|      0|  database_->RegisterCallHandler(service_name_, std::move(self));
  401|      0|}
  402|       |
  403|       |void DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  404|      0|    SendHealth(std::shared_ptr<CallHandler> self, ServingStatus status) {
  405|      0|  grpc_core::MutexLock lock(&send_mu_);
  406|      0|  // If there's already a send in flight, cache the new status, and
  407|      0|  // we'll start a new send for it when the one in flight completes.
  408|      0|  if (send_in_flight_) {
  409|      0|    pending_status_ = status;
  410|      0|    return;
  411|      0|  }
  412|      0|  // Start a send.
  413|      0|  SendHealthLocked(std::move(self), status);
  414|      0|}
  415|       |
  416|       |void DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  417|      0|    SendHealthLocked(std::shared_ptr<CallHandler> self, ServingStatus status) {
  418|      0|  send_in_flight_ = true;
  419|      0|  // Construct response.
  420|      0|  ByteBuffer response;
  421|      0|  bool success = service_->EncodeResponse(status, &response);
  422|      0|  // Grab shutdown lock and send response.
  423|      0|  grpc_core::MutexLock cq_lock(&service_->cq_shutdown_mu_);
  424|      0|  if (service_->shutdown_) {
  425|      0|    SendFinishLocked(std::move(self), Status::CANCELLED);
  426|      0|    return;
  427|      0|  }
  428|      0|  if (!success) {
  429|      0|    SendFinishLocked(std::move(self),
  430|      0|                     Status(StatusCode::INTERNAL, "could not encode response"));
  431|      0|    return;
  432|      0|  }
  433|      0|  next_ = CallableTag(std::bind(&WatchCallHandler::OnSendHealthDone, this,
  434|      0|                                std::placeholders::_1, std::placeholders::_2),
  435|      0|                      std::move(self));
  436|      0|  stream_.Write(response, &next_);
  437|      0|}
  438|       |
  439|       |void DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  440|      0|    OnSendHealthDone(std::shared_ptr<CallHandler> self, bool ok) {
  441|      0|  if (!ok) {
  442|      0|    SendFinish(std::move(self), Status::CANCELLED);
  443|      0|    return;
  444|      0|  }
  445|      0|  grpc_core::MutexLock lock(&send_mu_);
  446|      0|  send_in_flight_ = false;
  447|      0|  // If we got a new status since we started the last send, start a
  448|      0|  // new send for it.
  449|      0|  if (pending_status_ != NOT_FOUND) {
  450|      0|    auto status = pending_status_;
  451|      0|    pending_status_ = NOT_FOUND;
  452|      0|    SendHealthLocked(std::move(self), status);
  453|      0|  }
  454|      0|}
  455|       |
  456|       |void DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  457|      0|    SendFinish(std::shared_ptr<CallHandler> self, const Status& status) {
  458|      0|  if (finish_called_) return;
  459|      0|  grpc_core::MutexLock cq_lock(&service_->cq_shutdown_mu_);
  460|      0|  if (service_->shutdown_) return;
  461|      0|  SendFinishLocked(std::move(self), status);
  462|      0|}
  463|       |
  464|       |void DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  465|      0|    SendFinishLocked(std::shared_ptr<CallHandler> self, const Status& status) {
  466|      0|  on_finish_done_ =
  467|      0|      CallableTag(std::bind(&WatchCallHandler::OnFinishDone, this,
  468|      0|                            std::placeholders::_1, std::placeholders::_2),
  469|      0|                  std::move(self));
  470|      0|  stream_.Finish(status, &on_finish_done_);
  471|      0|  finish_called_ = true;
  472|      0|}
  473|       |
  474|       |void DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  475|      0|    OnFinishDone(std::shared_ptr<CallHandler> self, bool ok) {
  476|      0|  if (ok) {
  477|      0|    gpr_log(GPR_DEBUG,
  478|      0|            "[HCS %p] Health watch call finished (service_name: \"%s\", "
  479|      0|            "handler: %p).",
  480|      0|            service_, service_name_.c_str(), this);
  481|      0|  }
  482|      0|  self.reset();  // To appease clang-tidy.
  483|      0|}
  484|       |
  485|       |// TODO(roth): This method currently assumes that there will be only one
  486|       |// thread polling the cq and invoking the corresponding callbacks.  If
  487|       |// that changes, we will need to add synchronization here.
  488|       |void DefaultHealthCheckService::HealthCheckServiceImpl::WatchCallHandler::
  489|      0|    OnDoneNotified(std::shared_ptr<CallHandler> self, bool ok) {
  490|      0|  GPR_ASSERT(ok);
  491|      0|  gpr_log(GPR_DEBUG,
  492|      0|          "[HCS %p] Health watch call is notified done (handler: %p, "
  493|      0|          "is_cancelled: %d).",
  494|      0|          service_, this, static_cast<int>(ctx_.IsCancelled()));
  495|      0|  database_->UnregisterCallHandler(service_name_, self);
  496|      0|  SendFinish(std::move(self), Status::CANCELLED);
  497|      0|}
  498|       |
  499|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/health/default_health_check_service.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_INTERNAL_CPP_SERVER_DEFAULT_HEALTH_CHECK_SERVICE_H
   20|       |#define GRPC_INTERNAL_CPP_SERVER_DEFAULT_HEALTH_CHECK_SERVICE_H
   21|       |
   22|       |#include <atomic>
   23|       |#include <mutex>
   24|       |#include <set>
   25|       |
   26|       |#include <grpc/support/log.h>
   27|       |#include <grpcpp/grpcpp.h>
   28|       |#include <grpcpp/health_check_service_interface.h>
   29|       |#include <grpcpp/impl/codegen/async_generic_service.h>
   30|       |#include <grpcpp/impl/codegen/async_unary_call.h>
   31|       |#include <grpcpp/impl/codegen/service_type.h>
   32|       |#include <grpcpp/support/byte_buffer.h>
   33|       |
   34|       |#include "src/core/lib/gprpp/sync.h"
   35|       |#include "src/core/lib/gprpp/thd.h"
   36|       |
   37|       |namespace grpc {
   38|       |
   39|       |// Default implementation of HealthCheckServiceInterface. Server will create and
   40|       |// own it.
   41|       |class DefaultHealthCheckService final : public HealthCheckServiceInterface {
   42|       | public:
   43|       |  enum ServingStatus { NOT_FOUND, SERVING, NOT_SERVING };
   44|       |
   45|       |  // The service impl to register with the server.
   46|       |  class HealthCheckServiceImpl : public Service {
   47|       |   public:
   48|       |    // Base class for call handlers.
   49|       |    class CallHandler {
   50|       |     public:
   51|      0|      virtual ~CallHandler() = default;
   52|       |      virtual void SendHealth(std::shared_ptr<CallHandler> self,
   53|       |                              ServingStatus status) = 0;
   54|       |    };
   55|       |
   56|       |    HealthCheckServiceImpl(DefaultHealthCheckService* database,
   57|       |                           std::unique_ptr<ServerCompletionQueue> cq);
   58|       |
   59|       |    ~HealthCheckServiceImpl();
   60|       |
   61|       |    void StartServingThread();
   62|       |
   63|       |   private:
   64|       |    // A tag that can be called with a bool argument. It's tailored for
   65|       |    // CallHandler's use. Before being used, it should be constructed with a
   66|       |    // method of CallHandler and a shared pointer to the handler. The
   67|       |    // shared pointer will be moved to the invoked function and the function
   68|       |    // can only be invoked once. That makes ref counting of the handler easier,
   69|       |    // because the shared pointer is not bound to the function and can be gone
   70|       |    // once the invoked function returns (if not used any more).
   71|       |    class CallableTag {
   72|       |     public:
   73|       |      using HandlerFunction =
   74|       |          std::function<void(std::shared_ptr<CallHandler>, bool)>;
   75|       |
   76|      0|      CallableTag() {}
   77|       |
   78|       |      CallableTag(HandlerFunction func, std::shared_ptr<CallHandler> handler)
   79|      0|          : handler_function_(std::move(func)), handler_(std::move(handler)) {
   80|      0|        GPR_ASSERT(handler_function_ != nullptr);
   81|      0|        GPR_ASSERT(handler_ != nullptr);
   82|      0|      }
   83|       |
   84|       |      // Runs the tag. This should be called only once. The handler is no
   85|       |      // longer owned by this tag after this method is invoked.
   86|      0|      void Run(bool ok) {
   87|      0|        GPR_ASSERT(handler_function_ != nullptr);
   88|      0|        GPR_ASSERT(handler_ != nullptr);
   89|      0|        handler_function_(std::move(handler_), ok);
   90|      0|      }
   91|       |
   92|       |      // Releases and returns the shared pointer to the handler.
   93|      0|      std::shared_ptr<CallHandler> ReleaseHandler() {
   94|      0|        return std::move(handler_);
   95|      0|      }
   96|       |
   97|       |     private:
   98|       |      HandlerFunction handler_function_ = nullptr;
   99|       |      std::shared_ptr<CallHandler> handler_;
  100|       |    };
  101|       |
  102|       |    // Call handler for Check method.
  103|       |    // Each handler takes care of one call. It contains per-call data and it
  104|       |    // will access the members of the parent class (i.e.,
  105|       |    // DefaultHealthCheckService) for per-service health data.
  106|       |    class CheckCallHandler : public CallHandler {
  107|       |     public:
  108|       |      // Instantiates a CheckCallHandler and requests the next health check
  109|       |      // call. The handler object will manage its own lifetime, so no action is
  110|       |      // needed from the caller any more regarding that object.
  111|       |      static void CreateAndStart(ServerCompletionQueue* cq,
  112|       |                                 DefaultHealthCheckService* database,
  113|       |                                 HealthCheckServiceImpl* service);
  114|       |
  115|       |      // This ctor is public because we want to use std::make_shared<> in
  116|       |      // CreateAndStart(). This ctor shouldn't be used elsewhere.
  117|       |      CheckCallHandler(ServerCompletionQueue* cq,
  118|       |                       DefaultHealthCheckService* database,
  119|       |                       HealthCheckServiceImpl* service);
  120|       |
  121|       |      // Not used for Check.
  122|       |      void SendHealth(std::shared_ptr<CallHandler> self,
  123|      0|                      ServingStatus status) override {}
  124|       |
  125|       |     private:
  126|       |      // Called when we receive a call.
  127|       |      // Spawns a new handler so that we can keep servicing future calls.
  128|       |      void OnCallReceived(std::shared_ptr<CallHandler> self, bool ok);
  129|       |
  130|       |      // Called when Finish() is done.
  131|       |      void OnFinishDone(std::shared_ptr<CallHandler> self, bool ok);
  132|       |
  133|       |      // The members passed down from HealthCheckServiceImpl.
  134|       |      ServerCompletionQueue* cq_;
  135|       |      DefaultHealthCheckService* database_;
  136|       |      HealthCheckServiceImpl* service_;
  137|       |
  138|       |      ByteBuffer request_;
  139|       |      GenericServerAsyncResponseWriter writer_;
  140|       |      ServerContext ctx_;
  141|       |
  142|       |      CallableTag next_;
  143|       |    };
  144|       |
  145|       |    // Call handler for Watch method.
  146|       |    // Each handler takes care of one call. It contains per-call data and it
  147|       |    // will access the members of the parent class (i.e.,
  148|       |    // DefaultHealthCheckService) for per-service health data.
  149|       |    class WatchCallHandler : public CallHandler {
  150|       |     public:
  151|       |      // Instantiates a WatchCallHandler and requests the next health check
  152|       |      // call. The handler object will manage its own lifetime, so no action is
  153|       |      // needed from the caller any more regarding that object.
  154|       |      static void CreateAndStart(ServerCompletionQueue* cq,
  155|       |                                 DefaultHealthCheckService* database,
  156|       |                                 HealthCheckServiceImpl* service);
  157|       |
  158|       |      // This ctor is public because we want to use std::make_shared<> in
  159|       |      // CreateAndStart(). This ctor shouldn't be used elsewhere.
  160|       |      WatchCallHandler(ServerCompletionQueue* cq,
  161|       |                       DefaultHealthCheckService* database,
  162|       |                       HealthCheckServiceImpl* service);
  163|       |
  164|       |      void SendHealth(std::shared_ptr<CallHandler> self,
  165|       |                      ServingStatus status) override;
  166|       |
  167|       |     private:
  168|       |      // Called when we receive a call.
  169|       |      // Spawns a new handler so that we can keep servicing future calls.
  170|       |      void OnCallReceived(std::shared_ptr<CallHandler> self, bool ok);
  171|       |
  172|       |      // Requires holding send_mu_.
  173|       |      void SendHealthLocked(std::shared_ptr<CallHandler> self,
  174|       |                            ServingStatus status);
  175|       |
  176|       |      // When sending a health result finishes.
  177|       |      void OnSendHealthDone(std::shared_ptr<CallHandler> self, bool ok);
  178|       |
  179|       |      void SendFinish(std::shared_ptr<CallHandler> self, const Status& status);
  180|       |
  181|       |      // Requires holding service_->cq_shutdown_mu_.
  182|       |      void SendFinishLocked(std::shared_ptr<CallHandler> self,
  183|       |                            const Status& status);
  184|       |
  185|       |      // Called when Finish() is done.
  186|       |      void OnFinishDone(std::shared_ptr<CallHandler> self, bool ok);
  187|       |
  188|       |      // Called when AsyncNotifyWhenDone() notifies us.
  189|       |      void OnDoneNotified(std::shared_ptr<CallHandler> self, bool ok);
  190|       |
  191|       |      // The members passed down from HealthCheckServiceImpl.
  192|       |      ServerCompletionQueue* cq_;
  193|       |      DefaultHealthCheckService* database_;
  194|       |      HealthCheckServiceImpl* service_;
  195|       |
  196|       |      ByteBuffer request_;
  197|       |      grpc::string service_name_;
  198|       |      GenericServerAsyncWriter stream_;
  199|       |      ServerContext ctx_;
  200|       |
  201|       |      grpc_core::Mutex send_mu_;
  202|       |      bool send_in_flight_ = false;               // Guarded by mu_.
  203|       |      ServingStatus pending_status_ = NOT_FOUND;  // Guarded by mu_.
  204|       |
  205|       |      bool finish_called_ = false;
  206|       |      CallableTag next_;
  207|       |      CallableTag on_done_notified_;
  208|       |      CallableTag on_finish_done_;
  209|       |    };
  210|       |
  211|       |    // Handles the incoming requests and drives the completion queue in a loop.
  212|       |    static void Serve(void* arg);
  213|       |
  214|       |    // Returns true on success.
  215|       |    static bool DecodeRequest(const ByteBuffer& request,
  216|       |                              grpc::string* service_name);
  217|       |    static bool EncodeResponse(ServingStatus status, ByteBuffer* response);
  218|       |
  219|       |    // Needed to appease Windows compilers, which don't seem to allow
  220|       |    // nested classes to access protected members in the parent's
  221|       |    // superclass.
  222|       |    using Service::RequestAsyncServerStreaming;
  223|       |    using Service::RequestAsyncUnary;
  224|       |
  225|       |    DefaultHealthCheckService* database_;
  226|       |    std::unique_ptr<ServerCompletionQueue> cq_;
  227|       |
  228|       |    // To synchronize the operations related to shutdown state of cq_, so that
  229|       |    // we don't enqueue new tags into cq_ after it is already shut down.
  230|       |    grpc_core::Mutex cq_shutdown_mu_;
  231|       |    std::atomic_bool shutdown_{false};
  232|       |    std::unique_ptr<::grpc_core::Thread> thread_;
  233|       |  };
  234|       |
  235|       |  DefaultHealthCheckService();
  236|       |
  237|       |  void SetServingStatus(const grpc::string& service_name,
  238|       |                        bool serving) override;
  239|       |  void SetServingStatus(bool serving) override;
  240|       |
  241|       |  void Shutdown() override;
  242|       |
  243|       |  ServingStatus GetServingStatus(const grpc::string& service_name) const;
  244|       |
  245|       |  HealthCheckServiceImpl* GetHealthCheckService(
  246|       |      std::unique_ptr<ServerCompletionQueue> cq);
  247|       |
  248|       | private:
  249|       |  // Stores the current serving status of a service and any call
  250|       |  // handlers registered for updates when the service's status changes.
  251|       |  class ServiceData {
  252|       |   public:
  253|       |    void SetServingStatus(ServingStatus status);
  254|      0|    ServingStatus GetServingStatus() const { return status_; }
  255|       |    void AddCallHandler(
  256|       |        std::shared_ptr<HealthCheckServiceImpl::CallHandler> handler);
  257|       |    void RemoveCallHandler(
  258|       |        const std::shared_ptr<HealthCheckServiceImpl::CallHandler>& handler);
  259|      0|    bool Unused() const {
  260|      0|      return call_handlers_.empty() && status_ == NOT_FOUND;
  261|      0|    }
  262|       |
  263|       |   private:
  264|       |    ServingStatus status_ = NOT_FOUND;
  265|       |    std::set<std::shared_ptr<HealthCheckServiceImpl::CallHandler>>
  266|       |        call_handlers_;
  267|       |  };
  268|       |
  269|       |  void RegisterCallHandler(
  270|       |      const grpc::string& service_name,
  271|       |      std::shared_ptr<HealthCheckServiceImpl::CallHandler> handler);
  272|       |
  273|       |  void UnregisterCallHandler(
  274|       |      const grpc::string& service_name,
  275|       |      const std::shared_ptr<HealthCheckServiceImpl::CallHandler>& handler);
  276|       |
  277|       |  mutable grpc_core::Mutex mu_;
  278|       |  bool shutdown_ = false;                             // Guarded by mu_.
  279|       |  std::map<grpc::string, ServiceData> services_map_;  // Guarded by mu_.
  280|       |  std::unique_ptr<HealthCheckServiceImpl> impl_;
  281|       |};
  282|       |
  283|       |}  // namespace grpc
  284|       |
  285|       |#endif  // GRPC_INTERNAL_CPP_SERVER_DEFAULT_HEALTH_CHECK_SERVICE_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/health/health_check_service.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/health_check_service_interface_impl.h>
   20|       |
   21|       |namespace grpc_impl {
   22|       |namespace {
   23|       |bool g_grpc_default_health_check_service_enabled = false;
   24|       |}  // namespace
   25|       |
   26|      0|bool DefaultHealthCheckServiceEnabled() {
   27|      0|  return g_grpc_default_health_check_service_enabled;
   28|      0|}
   29|       |
   30|      0|void EnableDefaultHealthCheckService(bool enable) {
   31|      0|  g_grpc_default_health_check_service_enabled = enable;
   32|      0|}
   33|       |
   34|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/health/health_check_service_server_builder_option.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/ext/health_check_service_server_builder_option.h>
   20|       |
   21|       |namespace grpc {
   22|       |
   23|       |HealthCheckServiceServerBuilderOption::HealthCheckServiceServerBuilderOption(
   24|       |    std::unique_ptr<HealthCheckServiceInterface> hc)
   25|      0|    : hc_(std::move(hc)) {}
   26|       |// Hand over hc_ to the server.
   27|       |void HealthCheckServiceServerBuilderOption::UpdateArguments(
   28|      0|    ChannelArguments* args) {
   29|      0|  args->SetPointer(kHealthCheckServiceInterfaceArg, hc_.release());
   30|      0|}
   31|       |
   32|       |void HealthCheckServiceServerBuilderOption::UpdatePlugins(
   33|      0|    std::vector<std::unique_ptr<ServerBuilderPlugin>>* plugins) {}
   34|       |
   35|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/insecure_server_credentials.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/security/server_credentials.h>
   20|       |
   21|       |#include <grpc/grpc.h>
   22|       |#include <grpc/support/log.h>
   23|       |
   24|       |namespace grpc_impl {
   25|       |namespace {
   26|       |class InsecureServerCredentialsImpl final : public ServerCredentials {
   27|       | public:
   28|      0|  int AddPortToServer(const grpc::string& addr, grpc_server* server) override {
   29|      0|    return grpc_server_add_insecure_http2_port(server, addr.c_str());
   30|      0|  }
   31|       |  void SetAuthMetadataProcessor(
   32|      0|      const std::shared_ptr<grpc::AuthMetadataProcessor>& processor) override {
   33|      0|    (void)processor;
   34|      0|    GPR_ASSERT(0);  // Should not be called on InsecureServerCredentials.
   35|      0|  }
   36|       |};
   37|       |}  // namespace
   38|       |
   39|      0|std::shared_ptr<ServerCredentials> InsecureServerCredentials() {
   40|      0|  return std::shared_ptr<ServerCredentials>(
   41|      0|      new InsecureServerCredentialsImpl());
   42|      0|}
   43|       |
   44|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/secure_server_credentials.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <functional>
   20|       |#include <map>
   21|       |#include <memory>
   22|       |
   23|       |#include <grpcpp/impl/codegen/slice.h>
   24|       |#include <grpcpp/security/auth_metadata_processor.h>
   25|       |
   26|       |#include "src/cpp/common/secure_auth_context.h"
   27|       |#include "src/cpp/server/secure_server_credentials.h"
   28|       |
   29|       |namespace grpc {
   30|       |
   31|      0|void AuthMetadataProcessorAyncWrapper::Destroy(void* wrapper) {
   32|      0|  auto* w = static_cast<AuthMetadataProcessorAyncWrapper*>(wrapper);
   33|      0|  delete w;
   34|      0|}
   35|       |
   36|       |void AuthMetadataProcessorAyncWrapper::Process(
   37|       |    void* wrapper, grpc_auth_context* context, const grpc_metadata* md,
   38|      0|    size_t num_md, grpc_process_auth_metadata_done_cb cb, void* user_data) {
   39|      0|  auto* w = static_cast<AuthMetadataProcessorAyncWrapper*>(wrapper);
   40|      0|  if (!w->processor_) {
   41|      0|    // Early exit.
   42|      0|    cb(user_data, nullptr, 0, nullptr, 0, GRPC_STATUS_OK, nullptr);
   43|      0|    return;
   44|      0|  }
   45|      0|  if (w->processor_->IsBlocking()) {
   46|      0|    w->thread_pool_->Add([w, context, md, num_md, cb, user_data] {
   47|      0|      w->AuthMetadataProcessorAyncWrapper::InvokeProcessor(context, md, num_md,
   48|      0|                                                           cb, user_data);
   49|      0|    });
   50|      0|  } else {
   51|      0|    // invoke directly.
   52|      0|    w->InvokeProcessor(context, md, num_md, cb, user_data);
   53|      0|  }
   54|      0|}
   55|       |
   56|       |void AuthMetadataProcessorAyncWrapper::InvokeProcessor(
   57|       |    grpc_auth_context* ctx, const grpc_metadata* md, size_t num_md,
   58|      0|    grpc_process_auth_metadata_done_cb cb, void* user_data) {
   59|      0|  AuthMetadataProcessor::InputMetadata metadata;
   60|      0|  for (size_t i = 0; i < num_md; i++) {
   61|      0|    metadata.insert(std::make_pair(StringRefFromSlice(&md[i].key),
   62|      0|                                   StringRefFromSlice(&md[i].value)));
   63|      0|  }
   64|      0|  SecureAuthContext context(ctx);
   65|      0|  AuthMetadataProcessor::OutputMetadata consumed_metadata;
   66|      0|  AuthMetadataProcessor::OutputMetadata response_metadata;
   67|      0|
   68|      0|  Status status = processor_->Process(metadata, &context, &consumed_metadata,
   69|      0|                                      &response_metadata);
   70|      0|
   71|      0|  std::vector<grpc_metadata> consumed_md;
   72|      0|  for (auto it = consumed_metadata.begin(); it != consumed_metadata.end();
   73|      0|       ++it) {
   74|      0|    grpc_metadata md_entry;
   75|      0|    md_entry.key = SliceReferencingString(it->first);
   76|      0|    md_entry.value = SliceReferencingString(it->second);
   77|      0|    md_entry.flags = 0;
   78|      0|    consumed_md.push_back(md_entry);
   79|      0|  }
   80|      0|  std::vector<grpc_metadata> response_md;
   81|      0|  for (auto it = response_metadata.begin(); it != response_metadata.end();
   82|      0|       ++it) {
   83|      0|    grpc_metadata md_entry;
   84|      0|    md_entry.key = SliceReferencingString(it->first);
   85|      0|    md_entry.value = SliceReferencingString(it->second);
   86|      0|    md_entry.flags = 0;
   87|      0|    response_md.push_back(md_entry);
   88|      0|  }
   89|      0|  auto consumed_md_data = consumed_md.empty() ? nullptr : &consumed_md[0];
   90|      0|  auto response_md_data = response_md.empty() ? nullptr : &response_md[0];
   91|      0|  cb(user_data, consumed_md_data, consumed_md.size(), response_md_data,
   92|      0|     response_md.size(), static_cast<grpc_status_code>(status.error_code()),
   93|      0|     status.error_message().c_str());
   94|      0|}
   95|       |
   96|       |}  // namespace grpc
   97|       |
   98|       |namespace grpc_impl {
   99|       |
  100|       |int SecureServerCredentials::AddPortToServer(const grpc::string& addr,
  101|      0|                                             grpc_server* server) {
  102|      0|  return grpc_server_add_secure_http2_port(server, addr.c_str(), creds_);
  103|      0|}
  104|       |
  105|       |void SecureServerCredentials::SetAuthMetadataProcessor(
  106|      0|    const std::shared_ptr<grpc::AuthMetadataProcessor>& processor) {
  107|      0|  auto* wrapper = new grpc::AuthMetadataProcessorAyncWrapper(processor);
  108|      0|  grpc_server_credentials_set_auth_metadata_processor(
  109|      0|      creds_, {grpc::AuthMetadataProcessorAyncWrapper::Process,
  110|      0|               grpc::AuthMetadataProcessorAyncWrapper::Destroy, wrapper});
  111|      0|}
  112|       |
  113|       |std::shared_ptr<ServerCredentials> SslServerCredentials(
  114|      0|    const grpc::SslServerCredentialsOptions& options) {
  115|      0|  std::vector<grpc_ssl_pem_key_cert_pair> pem_key_cert_pairs;
  116|      0|  for (auto key_cert_pair = options.pem_key_cert_pairs.begin();
  117|      0|       key_cert_pair != options.pem_key_cert_pairs.end(); key_cert_pair++) {
  118|      0|    grpc_ssl_pem_key_cert_pair p = {key_cert_pair->private_key.c_str(),
  119|      0|                                    key_cert_pair->cert_chain.c_str()};
  120|      0|    pem_key_cert_pairs.push_back(p);
  121|      0|  }
  122|      0|  grpc_server_credentials* c_creds = grpc_ssl_server_credentials_create_ex(
  123|      0|      options.pem_root_certs.empty() ? nullptr : options.pem_root_certs.c_str(),
  124|      0|      pem_key_cert_pairs.empty() ? nullptr : &pem_key_cert_pairs[0],
  125|      0|      pem_key_cert_pairs.size(),
  126|      0|      options.force_client_auth
  127|      0|          ? GRPC_SSL_REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_AND_VERIFY
  128|      0|          : options.client_certificate_request,
  129|      0|      nullptr);
  130|      0|  return std::shared_ptr<ServerCredentials>(
  131|      0|      new SecureServerCredentials(c_creds));
  132|      0|}
  133|       |
  134|       |namespace experimental {
  135|       |
  136|       |std::shared_ptr<ServerCredentials> AltsServerCredentials(
  137|      0|    const AltsServerCredentialsOptions& options) {
  138|      0|  grpc_alts_credentials_options* c_options =
  139|      0|      grpc_alts_credentials_server_options_create();
  140|      0|  grpc_server_credentials* c_creds =
  141|      0|      grpc_alts_server_credentials_create(c_options);
  142|      0|  grpc_alts_credentials_options_destroy(c_options);
  143|      0|  return std::shared_ptr<ServerCredentials>(
  144|      0|      new SecureServerCredentials(c_creds));
  145|      0|}
  146|       |
  147|       |std::shared_ptr<ServerCredentials> LocalServerCredentials(
  148|      0|    grpc_local_connect_type type) {
  149|      0|  return std::shared_ptr<ServerCredentials>(
  150|      0|      new SecureServerCredentials(grpc_local_server_credentials_create(type)));
  151|      0|}
  152|       |
  153|       |}  // namespace experimental
  154|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/secure_server_credentials.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_INTERNAL_CPP_SERVER_SECURE_SERVER_CREDENTIALS_H
   20|       |#define GRPC_INTERNAL_CPP_SERVER_SECURE_SERVER_CREDENTIALS_H
   21|       |
   22|       |#include <memory>
   23|       |
   24|       |#include <grpcpp/security/server_credentials.h>
   25|       |
   26|       |#include <grpc/grpc_security.h>
   27|       |
   28|       |#include "src/cpp/server/thread_pool_interface.h"
   29|       |
   30|       |namespace grpc_impl {
   31|       |
   32|       |class SecureServerCredentials;
   33|       |}  // namespace grpc_impl
   34|       |
   35|       |namespace grpc {
   36|       |
   37|       |typedef ::grpc_impl::SecureServerCredentials SecureServerCredentials;
   38|       |
   39|       |class AuthMetadataProcessorAyncWrapper final {
   40|       | public:
   41|       |  static void Destroy(void* wrapper);
   42|       |
   43|       |  static void Process(void* wrapper, grpc_auth_context* context,
   44|       |                      const grpc_metadata* md, size_t num_md,
   45|       |                      grpc_process_auth_metadata_done_cb cb, void* user_data);
   46|       |
   47|       |  AuthMetadataProcessorAyncWrapper(
   48|       |      const std::shared_ptr<AuthMetadataProcessor>& processor)
   49|      0|      : thread_pool_(CreateDefaultThreadPool()), processor_(processor) {}
   50|       |
   51|       | private:
   52|       |  void InvokeProcessor(grpc_auth_context* context, const grpc_metadata* md,
   53|       |                       size_t num_md, grpc_process_auth_metadata_done_cb cb,
   54|       |                       void* user_data);
   55|       |  std::unique_ptr<ThreadPoolInterface> thread_pool_;
   56|       |  std::shared_ptr<AuthMetadataProcessor> processor_;
   57|       |};
   58|       |
   59|       |}  // namespace grpc
   60|       |
   61|       |namespace grpc_impl {
   62|       |
   63|       |class SecureServerCredentials final : public ServerCredentials {
   64|       | public:
   65|       |  explicit SecureServerCredentials(grpc_server_credentials* creds)
   66|      0|      : creds_(creds) {}
   67|      0|  ~SecureServerCredentials() override {
   68|      0|    grpc_server_credentials_release(creds_);
   69|      0|  }
   70|       |
   71|       |  int AddPortToServer(const grpc::string& addr, grpc_server* server) override;
   72|       |
   73|       |  void SetAuthMetadataProcessor(
   74|       |      const std::shared_ptr<grpc::AuthMetadataProcessor>& processor) override;
   75|       |
   76|       | private:
   77|       |  grpc_server_credentials* creds_;
   78|       |  std::unique_ptr<grpc::AuthMetadataProcessorAyncWrapper> processor_;
   79|       |};
   80|       |
   81|       |}  // namespace grpc_impl
   82|       |
   83|       |#endif  // GRPC_INTERNAL_CPP_SERVER_SECURE_SERVER_CREDENTIALS_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/server_builder.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015-2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/server_builder.h>
   20|       |
   21|       |#include <grpc/support/cpu.h>
   22|       |#include <grpc/support/log.h>
   23|       |#include <grpcpp/impl/service_type.h>
   24|       |#include <grpcpp/resource_quota.h>
   25|       |#include <grpcpp/server.h>
   26|       |
   27|       |#include <utility>
   28|       |
   29|       |#include "src/core/lib/gpr/useful.h"
   30|       |#include "src/cpp/server/thread_pool_interface.h"
   31|       |
   32|       |namespace grpc_impl {
   33|       |
   34|       |static std::vector<std::unique_ptr<grpc::ServerBuilderPlugin> (*)()>*
   35|       |    g_plugin_factory_list;
   36|       |static gpr_once once_init_plugin_list = GPR_ONCE_INIT;
   37|       |
   38|      0|static void do_plugin_list_init(void) {
   39|      0|  g_plugin_factory_list =
   40|      0|      new std::vector<std::unique_ptr<grpc::ServerBuilderPlugin> (*)()>();
   41|      0|}
   42|       |
   43|       |ServerBuilder::ServerBuilder()
   44|       |    : max_receive_message_size_(INT_MIN),
   45|       |      max_send_message_size_(INT_MIN),
   46|       |      sync_server_settings_(SyncServerSettings()),
   47|      0|      resource_quota_(nullptr) {
   48|      0|  gpr_once_init(&once_init_plugin_list, do_plugin_list_init);
   49|      0|  for (auto it = g_plugin_factory_list->begin();
   50|      0|       it != g_plugin_factory_list->end(); it++) {
   51|      0|    auto& factory = *it;
   52|      0|    plugins_.emplace_back(factory());
   53|      0|  }
   54|      0|
   55|      0|  // all compression algorithms enabled by default.
   56|      0|  enabled_compression_algorithms_bitset_ =
   57|      0|      (1u << GRPC_COMPRESS_ALGORITHMS_COUNT) - 1;
   58|      0|  memset(&maybe_default_compression_level_, 0,
   59|      0|         sizeof(maybe_default_compression_level_));
   60|      0|  memset(&maybe_default_compression_algorithm_, 0,
   61|      0|         sizeof(maybe_default_compression_algorithm_));
   62|      0|}
   63|       |
   64|      0|ServerBuilder::~ServerBuilder() {
   65|      0|  if (resource_quota_ != nullptr) {
   66|      0|    grpc_resource_quota_unref(resource_quota_);
   67|      0|  }
   68|      0|}
   69|       |
   70|       |std::unique_ptr<grpc::ServerCompletionQueue> ServerBuilder::AddCompletionQueue(
   71|      0|    bool is_frequently_polled) {
   72|      0|  grpc::ServerCompletionQueue* cq = new grpc::ServerCompletionQueue(
   73|      0|      GRPC_CQ_NEXT,
   74|      0|      is_frequently_polled ? GRPC_CQ_DEFAULT_POLLING : GRPC_CQ_NON_LISTENING,
   75|      0|      nullptr);
   76|      0|  cqs_.push_back(cq);
   77|      0|  return std::unique_ptr<grpc::ServerCompletionQueue>(cq);
   78|      0|}
   79|       |
   80|      0|ServerBuilder& ServerBuilder::RegisterService(grpc::Service* service) {
   81|      0|  services_.emplace_back(new NamedService(service));
   82|      0|  return *this;
   83|      0|}
   84|       |
   85|       |ServerBuilder& ServerBuilder::RegisterService(const grpc::string& addr,
   86|      0|                                              grpc::Service* service) {
   87|      0|  services_.emplace_back(new NamedService(addr, service));
   88|      0|  return *this;
   89|      0|}
   90|       |
   91|       |ServerBuilder& ServerBuilder::RegisterAsyncGenericService(
   92|      0|    grpc::AsyncGenericService* service) {
   93|      0|  if (generic_service_ || callback_generic_service_) {
   94|      0|    gpr_log(GPR_ERROR,
   95|      0|            "Adding multiple generic services is unsupported for now. "
   96|      0|            "Dropping the service %p",
   97|      0|            (void*)service);
   98|      0|  } else {
   99|      0|    generic_service_ = service;
  100|      0|  }
  101|      0|  return *this;
  102|      0|}
  103|       |
  104|       |ServerBuilder& ServerBuilder::experimental_type::RegisterCallbackGenericService(
  105|      0|    grpc::experimental::CallbackGenericService* service) {
  106|      0|  if (builder_->generic_service_ || builder_->callback_generic_service_) {
  107|      0|    gpr_log(GPR_ERROR,
  108|      0|            "Adding multiple generic services is unsupported for now. "
  109|      0|            "Dropping the service %p",
  110|      0|            (void*)service);
  111|      0|  } else {
  112|      0|    builder_->callback_generic_service_ = service;
  113|      0|  }
  114|      0|  return *builder_;
  115|      0|}
  116|       |
  117|       |ServerBuilder& ServerBuilder::SetOption(
  118|      0|    std::unique_ptr<grpc::ServerBuilderOption> option) {
  119|      0|  options_.push_back(std::move(option));
  120|      0|  return *this;
  121|      0|}
  122|       |
  123|       |ServerBuilder& ServerBuilder::SetSyncServerOption(
  124|      0|    ServerBuilder::SyncServerOption option, int val) {
  125|      0|  switch (option) {
  126|      0|    case NUM_CQS:
  127|      0|      sync_server_settings_.num_cqs = val;
  128|      0|      break;
  129|      0|    case MIN_POLLERS:
  130|      0|      sync_server_settings_.min_pollers = val;
  131|      0|      break;
  132|      0|    case MAX_POLLERS:
  133|      0|      sync_server_settings_.max_pollers = val;
  134|      0|      break;
  135|      0|    case CQ_TIMEOUT_MSEC:
  136|      0|      sync_server_settings_.cq_timeout_msec = val;
  137|      0|      break;
  138|      0|  }
  139|      0|  return *this;
  140|      0|}
  141|       |
  142|       |ServerBuilder& ServerBuilder::SetCompressionAlgorithmSupportStatus(
  143|      0|    grpc_compression_algorithm algorithm, bool enabled) {
  144|      0|  if (enabled) {
  145|      0|    GPR_BITSET(&enabled_compression_algorithms_bitset_, algorithm);
  146|      0|  } else {
  147|      0|    GPR_BITCLEAR(&enabled_compression_algorithms_bitset_, algorithm);
  148|      0|  }
  149|      0|  return *this;
  150|      0|}
  151|       |
  152|       |ServerBuilder& ServerBuilder::SetDefaultCompressionLevel(
  153|      0|    grpc_compression_level level) {
  154|      0|  maybe_default_compression_level_.is_set = true;
  155|      0|  maybe_default_compression_level_.level = level;
  156|      0|  return *this;
  157|      0|}
  158|       |
  159|       |ServerBuilder& ServerBuilder::SetDefaultCompressionAlgorithm(
  160|      0|    grpc_compression_algorithm algorithm) {
  161|      0|  maybe_default_compression_algorithm_.is_set = true;
  162|      0|  maybe_default_compression_algorithm_.algorithm = algorithm;
  163|      0|  return *this;
  164|      0|}
  165|       |
  166|       |ServerBuilder& ServerBuilder::SetResourceQuota(
  167|      0|    const grpc_impl::ResourceQuota& resource_quota) {
  168|      0|  if (resource_quota_ != nullptr) {
  169|      0|    grpc_resource_quota_unref(resource_quota_);
  170|      0|  }
  171|      0|  resource_quota_ = resource_quota.c_resource_quota();
  172|      0|  grpc_resource_quota_ref(resource_quota_);
  173|      0|  return *this;
  174|      0|}
  175|       |
  176|       |ServerBuilder& ServerBuilder::AddListeningPort(
  177|       |    const grpc::string& addr_uri,
  178|      0|    std::shared_ptr<grpc::ServerCredentials> creds, int* selected_port) {
  179|      0|  const grpc::string uri_scheme = "dns:";
  180|      0|  grpc::string addr = addr_uri;
  181|      0|  if (addr_uri.compare(0, uri_scheme.size(), uri_scheme) == 0) {
  182|      0|    size_t pos = uri_scheme.size();
  183|      0|    while (addr_uri[pos] == '/') ++pos;  // Skip slashes.
  184|      0|    addr = addr_uri.substr(pos);
  185|      0|  }
  186|      0|  Port port = {addr, std::move(creds), selected_port};
  187|      0|  ports_.push_back(port);
  188|      0|  return *this;
  189|      0|}
  190|       |
  191|      0|std::unique_ptr<grpc::Server> ServerBuilder::BuildAndStart() {
  192|      0|  grpc::ChannelArguments args;
  193|      0|  for (auto option = options_.begin(); option != options_.end(); ++option) {
  194|      0|    (*option)->UpdateArguments(&args);
  195|      0|    (*option)->UpdatePlugins(&plugins_);
  196|      0|  }
  197|      0|
  198|      0|  for (auto plugin = plugins_.begin(); plugin != plugins_.end(); plugin++) {
  199|      0|    (*plugin)->UpdateServerBuilder(this);
  200|      0|    (*plugin)->UpdateChannelArguments(&args);
  201|      0|  }
  202|      0|
  203|      0|  if (max_receive_message_size_ >= -1) {
  204|      0|    args.SetInt(GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH, max_receive_message_size_);
  205|      0|  }
  206|      0|
  207|      0|  // The default message size is -1 (max), so no need to explicitly set it for
  208|      0|  // -1.
  209|      0|  if (max_send_message_size_ >= 0) {
  210|      0|    args.SetInt(GRPC_ARG_MAX_SEND_MESSAGE_LENGTH, max_send_message_size_);
  211|      0|  }
  212|      0|
  213|      0|  args.SetInt(GRPC_COMPRESSION_CHANNEL_ENABLED_ALGORITHMS_BITSET,
  214|      0|              enabled_compression_algorithms_bitset_);
  215|      0|  if (maybe_default_compression_level_.is_set) {
  216|      0|    args.SetInt(GRPC_COMPRESSION_CHANNEL_DEFAULT_LEVEL,
  217|      0|                maybe_default_compression_level_.level);
  218|      0|  }
  219|      0|  if (maybe_default_compression_algorithm_.is_set) {
  220|      0|    args.SetInt(GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM,
  221|      0|                maybe_default_compression_algorithm_.algorithm);
  222|      0|  }
  223|      0|
  224|      0|  if (resource_quota_ != nullptr) {
  225|      0|    args.SetPointerWithVtable(GRPC_ARG_RESOURCE_QUOTA, resource_quota_,
  226|      0|                              grpc_resource_quota_arg_vtable());
  227|      0|  }
  228|      0|
  229|      0|  // == Determine if the server has any syncrhonous methods ==
  230|      0|  bool has_sync_methods = false;
  231|      0|  for (auto it = services_.begin(); it != services_.end(); ++it) {
  232|      0|    if ((*it)->service->has_synchronous_methods()) {
  233|      0|      has_sync_methods = true;
  234|      0|      break;
  235|      0|    }
  236|      0|  }
  237|      0|
  238|      0|  if (!has_sync_methods) {
  239|      0|    for (auto plugin = plugins_.begin(); plugin != plugins_.end(); plugin++) {
  240|      0|      if ((*plugin)->has_sync_methods()) {
  241|      0|        has_sync_methods = true;
  242|      0|        break;
  243|      0|      }
  244|      0|    }
  245|      0|  }
  246|      0|
  247|      0|  // If this is a Sync server, i.e a server expositing sync API, then the server
  248|      0|  // needs to create some completion queues to listen for incoming requests.
  249|      0|  // 'sync_server_cqs' are those internal completion queues.
  250|      0|  //
  251|      0|  // This is different from the completion queues added to the server via
  252|      0|  // ServerBuilder's AddCompletionQueue() method (those completion queues
  253|      0|  // are in 'cqs_' member variable of ServerBuilder object)
  254|      0|  std::shared_ptr<std::vector<std::unique_ptr<grpc::ServerCompletionQueue>>>
  255|      0|      sync_server_cqs(
  256|      0|          std::make_shared<
  257|      0|              std::vector<std::unique_ptr<grpc::ServerCompletionQueue>>>());
  258|      0|
  259|      0|  bool has_frequently_polled_cqs = false;
  260|      0|  for (auto it = cqs_.begin(); it != cqs_.end(); ++it) {
  261|      0|    if ((*it)->IsFrequentlyPolled()) {
  262|      0|      has_frequently_polled_cqs = true;
  263|      0|      break;
  264|      0|    }
  265|      0|  }
  266|      0|
  267|      0|  // == Determine if the server has any callback methods ==
  268|      0|  bool has_callback_methods = false;
  269|      0|  for (auto it = services_.begin(); it != services_.end(); ++it) {
  270|      0|    if ((*it)->service->has_callback_methods()) {
  271|      0|      has_callback_methods = true;
  272|      0|      has_frequently_polled_cqs = true;
  273|      0|      break;
  274|      0|    }
  275|      0|  }
  276|      0|
  277|      0|  const bool is_hybrid_server = has_sync_methods && has_frequently_polled_cqs;
  278|      0|
  279|      0|  if (has_sync_methods) {
  280|      0|    grpc_cq_polling_type polling_type =
  281|      0|        is_hybrid_server ? GRPC_CQ_NON_POLLING : GRPC_CQ_DEFAULT_POLLING;
  282|      0|
  283|      0|    // Create completion queues to listen to incoming rpc requests
  284|      0|    for (int i = 0; i < sync_server_settings_.num_cqs; i++) {
  285|      0|      sync_server_cqs->emplace_back(
  286|      0|          new grpc::ServerCompletionQueue(GRPC_CQ_NEXT, polling_type, nullptr));
  287|      0|    }
  288|      0|  }
  289|      0|
  290|      0|  // TODO(vjpai): Add a section here for plugins once they can support callback
  291|      0|  // methods
  292|      0|
  293|      0|  if (has_sync_methods) {
  294|      0|    // This is a Sync server
  295|      0|    gpr_log(GPR_INFO,
  296|      0|            "Synchronous server. Num CQs: %d, Min pollers: %d, Max Pollers: "
  297|      0|            "%d, CQ timeout (msec): %d",
  298|      0|            sync_server_settings_.num_cqs, sync_server_settings_.min_pollers,
  299|      0|            sync_server_settings_.max_pollers,
  300|      0|            sync_server_settings_.cq_timeout_msec);
  301|      0|  }
  302|      0|
  303|      0|  if (has_callback_methods) {
  304|      0|    gpr_log(GPR_INFO, "Callback server.");
  305|      0|  }
  306|      0|
  307|      0|  std::unique_ptr<grpc::Server> server(new grpc::Server(
  308|      0|      max_receive_message_size_, &args, sync_server_cqs,
  309|      0|      sync_server_settings_.min_pollers, sync_server_settings_.max_pollers,
  310|      0|      sync_server_settings_.cq_timeout_msec, resource_quota_,
  311|      0|      std::move(interceptor_creators_)));
  312|      0|
  313|      0|  grpc_impl::ServerInitializer* initializer = server->initializer();
  314|      0|
  315|      0|  // Register all the completion queues with the server. i.e
  316|      0|  //  1. sync_server_cqs: internal completion queues created IF this is a sync
  317|      0|  //     server
  318|      0|  //  2. cqs_: Completion queues added via AddCompletionQueue() call
  319|      0|
  320|      0|  for (auto it = sync_server_cqs->begin(); it != sync_server_cqs->end(); ++it) {
  321|      0|    grpc_server_register_completion_queue(server->server_, (*it)->cq(),
  322|      0|                                          nullptr);
  323|      0|    has_frequently_polled_cqs = true;
  324|      0|  }
  325|      0|
  326|      0|  if (has_callback_methods || callback_generic_service_ != nullptr) {
  327|      0|    auto* cq = server->CallbackCQ();
  328|      0|    grpc_server_register_completion_queue(server->server_, cq->cq(), nullptr);
  329|      0|  }
  330|      0|
  331|      0|  // cqs_ contains the completion queue added by calling the ServerBuilder's
  332|      0|  // AddCompletionQueue() API. Some of them may not be frequently polled (i.e by
  333|      0|  // calling Next() or AsyncNext()) and hence are not safe to be used for
  334|      0|  // listening to incoming channels. Such completion queues must be registered
  335|      0|  // as non-listening queues
  336|      0|  for (auto it = cqs_.begin(); it != cqs_.end(); ++it) {
  337|      0|    grpc_server_register_completion_queue(server->server_, (*it)->cq(),
  338|      0|                                          nullptr);
  339|      0|  }
  340|      0|
  341|      0|  if (!has_frequently_polled_cqs) {
  342|      0|    gpr_log(GPR_ERROR,
  343|      0|            "At least one of the completion queues must be frequently polled");
  344|      0|    return nullptr;
  345|      0|  }
  346|      0|
  347|      0|  for (auto service = services_.begin(); service != services_.end();
  348|      0|       service++) {
  349|      0|    if (!server->RegisterService((*service)->host.get(), (*service)->service)) {
  350|      0|      return nullptr;
  351|      0|    }
  352|      0|  }
  353|      0|
  354|      0|  for (auto plugin = plugins_.begin(); plugin != plugins_.end(); plugin++) {
  355|      0|    (*plugin)->InitServer(initializer);
  356|      0|  }
  357|      0|
  358|      0|  if (generic_service_) {
  359|      0|    server->RegisterAsyncGenericService(generic_service_);
  360|      0|  } else if (callback_generic_service_) {
  361|      0|    server->RegisterCallbackGenericService(callback_generic_service_);
  362|      0|  } else {
  363|      0|    for (auto it = services_.begin(); it != services_.end(); ++it) {
  364|      0|      if ((*it)->service->has_generic_methods()) {
  365|      0|        gpr_log(GPR_ERROR,
  366|      0|                "Some methods were marked generic but there is no "
  367|      0|                "generic service registered.");
  368|      0|        return nullptr;
  369|      0|      }
  370|      0|    }
  371|      0|  }
  372|      0|
  373|      0|  bool added_port = false;
  374|      0|  for (auto port = ports_.begin(); port != ports_.end(); port++) {
  375|      0|    int r = server->AddListeningPort(port->addr, port->creds.get());
  376|      0|    if (!r) {
  377|      0|      if (added_port) server->Shutdown();
  378|      0|      return nullptr;
  379|      0|    }
  380|      0|    added_port = true;
  381|      0|    if (port->selected_port != nullptr) {
  382|      0|      *port->selected_port = r;
  383|      0|    }
  384|      0|  }
  385|      0|
  386|      0|  auto cqs_data = cqs_.empty() ? nullptr : &cqs_[0];
  387|      0|  server->Start(cqs_data, cqs_.size());
  388|      0|
  389|      0|  for (auto plugin = plugins_.begin(); plugin != plugins_.end(); plugin++) {
  390|      0|    (*plugin)->Finish(initializer);
  391|      0|  }
  392|      0|
  393|      0|  return server;
  394|      0|}
  395|       |
  396|       |void ServerBuilder::InternalAddPluginFactory(
  397|      0|    std::unique_ptr<grpc::ServerBuilderPlugin> (*CreatePlugin)()) {
  398|      0|  gpr_once_init(&once_init_plugin_list, do_plugin_list_init);
  399|      0|  (*g_plugin_factory_list).push_back(CreatePlugin);
  400|      0|}
  401|       |
  402|      0|ServerBuilder& ServerBuilder::EnableWorkaround(grpc_workaround_list id) {
  403|      0|  switch (id) {
  404|      0|    case GRPC_WORKAROUND_ID_CRONET_COMPRESSION:
  405|      0|      return AddChannelArgument(GRPC_ARG_WORKAROUND_CRONET_COMPRESSION, 1);
  406|      0|    default:
  407|      0|      gpr_log(GPR_ERROR, "Workaround %u does not exist or is obsolete.", id);
  408|      0|      return *this;
  409|      0|  }
  410|      0|}
  411|       |
  412|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/server_cc.cc:
    1|       |/*
    2|       | * Copyright 2015 gRPC authors.
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *     http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | *
   16|       | */
   17|       |
   18|       |#include <grpcpp/server.h>
   19|       |
   20|       |#include <cstdlib>
   21|       |#include <sstream>
   22|       |#include <type_traits>
   23|       |#include <utility>
   24|       |
   25|       |#include <grpc/grpc.h>
   26|       |#include <grpc/support/alloc.h>
   27|       |#include <grpc/support/log.h>
   28|       |#include <grpcpp/completion_queue.h>
   29|       |#include <grpcpp/generic/async_generic_service.h>
   30|       |#include <grpcpp/impl/codegen/async_unary_call.h>
   31|       |#include <grpcpp/impl/codegen/call.h>
   32|       |#include <grpcpp/impl/codegen/completion_queue_tag.h>
   33|       |#include <grpcpp/impl/codegen/server_interceptor.h>
   34|       |#include <grpcpp/impl/grpc_library.h>
   35|       |#include <grpcpp/impl/method_handler_impl.h>
   36|       |#include <grpcpp/impl/rpc_service_method.h>
   37|       |#include <grpcpp/impl/server_initializer.h>
   38|       |#include <grpcpp/impl/service_type.h>
   39|       |#include <grpcpp/security/server_credentials.h>
   40|       |#include <grpcpp/server_context.h>
   41|       |#include <grpcpp/support/time.h>
   42|       |
   43|       |#include "src/core/ext/transport/inproc/inproc_transport.h"
   44|       |#include "src/core/lib/iomgr/exec_ctx.h"
   45|       |#include "src/core/lib/profiling/timers.h"
   46|       |#include "src/core/lib/surface/call.h"
   47|       |#include "src/core/lib/surface/completion_queue.h"
   48|       |#include "src/cpp/client/create_channel_internal.h"
   49|       |#include "src/cpp/server/health/default_health_check_service.h"
   50|       |#include "src/cpp/thread_manager/thread_manager.h"
   51|       |
   52|       |namespace grpc {
   53|       |namespace {
   54|       |
   55|       |// The default value for maximum number of threads that can be created in the
   56|       |// sync server. This value of INT_MAX is chosen to match the default behavior if
   57|       |// no ResourceQuota is set. To modify the max number of threads in a sync
   58|       |// server, pass a custom ResourceQuota object  (with the desired number of
   59|       |// max-threads set) to the server builder.
   60|      0|#define DEFAULT_MAX_SYNC_SERVER_THREADS INT_MAX
   61|       |
   62|       |// How many callback requests of each method should we pre-register at start
   63|      0|#define DEFAULT_CALLBACK_REQS_PER_METHOD 512
   64|       |
   65|       |// What is the (soft) limit for outstanding requests in the server
   66|      0|#define SOFT_MAXIMUM_CALLBACK_REQS_OUTSTANDING 30000
   67|       |
   68|       |// If the number of unmatched requests for a method drops below this amount, try
   69|       |// to allocate extra unless it pushes the total number of callbacks above the
   70|       |// soft maximum
   71|      0|#define SOFT_MINIMUM_SPARE_CALLBACK_REQS_PER_METHOD 128
   72|       |
   73|       |class DefaultGlobalCallbacks final : public Server::GlobalCallbacks {
   74|       | public:
   75|      0|  ~DefaultGlobalCallbacks() override {}
   76|      0|  void PreSynchronousRequest(ServerContext* context) override {}
   77|      0|  void PostSynchronousRequest(ServerContext* context) override {}
   78|       |};
   79|       |
   80|       |std::shared_ptr<Server::GlobalCallbacks> g_callbacks = nullptr;
   81|       |gpr_once g_once_init_callbacks = GPR_ONCE_INIT;
   82|       |
   83|      0|void InitGlobalCallbacks() {
   84|      0|  if (!g_callbacks) {
   85|      0|    g_callbacks.reset(new DefaultGlobalCallbacks());
   86|      0|  }
   87|      0|}
   88|       |
   89|       |class ShutdownTag : public internal::CompletionQueueTag {
   90|       | public:
   91|      0|  bool FinalizeResult(void** tag, bool* status) { return false; }
   92|       |};
   93|       |
   94|       |class DummyTag : public internal::CompletionQueueTag {
   95|       | public:
   96|      0|  bool FinalizeResult(void** tag, bool* status) { return true; }
   97|       |};
   98|       |
   99|       |class UnimplementedAsyncRequestContext {
  100|       | protected:
  101|      0|  UnimplementedAsyncRequestContext() : generic_stream_(&server_context_) {}
  102|       |
  103|       |  GenericServerContext server_context_;
  104|       |  GenericServerAsyncReaderWriter generic_stream_;
  105|       |};
  106|       |
  107|       |}  // namespace
  108|       |
  109|       |ServerInterface::BaseAsyncRequest::BaseAsyncRequest(
  110|       |    ServerInterface* server, ServerContext* context,
  111|       |    internal::ServerAsyncStreamingInterface* stream, CompletionQueue* call_cq,
  112|       |    ServerCompletionQueue* notification_cq, void* tag, bool delete_on_finalize)
  113|       |    : server_(server),
  114|       |      context_(context),
  115|       |      stream_(stream),
  116|       |      call_cq_(call_cq),
  117|       |      notification_cq_(notification_cq),
  118|       |      tag_(tag),
  119|       |      delete_on_finalize_(delete_on_finalize),
  120|       |      call_(nullptr),
  121|      0|      done_intercepting_(false) {
  122|      0|  /* Set up interception state partially for the receive ops. call_wrapper_ is
  123|      0|   * not filled at this point, but it will be filled before the interceptors are
  124|      0|   * run. */
  125|      0|  interceptor_methods_.SetCall(&call_wrapper_);
  126|      0|  interceptor_methods_.SetReverse();
  127|      0|  call_cq_->RegisterAvalanching();  // This op will trigger more ops
  128|      0|}
  129|       |
  130|      0|ServerInterface::BaseAsyncRequest::~BaseAsyncRequest() {
  131|      0|  call_cq_->CompleteAvalanching();
  132|      0|}
  133|       |
  134|       |bool ServerInterface::BaseAsyncRequest::FinalizeResult(void** tag,
  135|      0|                                                       bool* status) {
  136|      0|  if (done_intercepting_) {
  137|      0|    *tag = tag_;
  138|      0|    if (delete_on_finalize_) {
  139|      0|      delete this;
  140|      0|    }
  141|      0|    return true;
  142|      0|  }
  143|      0|  context_->set_call(call_);
  144|      0|  context_->cq_ = call_cq_;
  145|      0|  if (call_wrapper_.call() == nullptr) {
  146|      0|    // Fill it since it is empty.
  147|      0|    call_wrapper_ = internal::Call(
  148|      0|        call_, server_, call_cq_, server_->max_receive_message_size(), nullptr);
  149|      0|  }
  150|      0|
  151|      0|  // just the pointers inside call are copied here
  152|      0|  stream_->BindCall(&call_wrapper_);
  153|      0|
  154|      0|  if (*status && call_ && call_wrapper_.server_rpc_info()) {
  155|      0|    done_intercepting_ = true;
  156|      0|    // Set interception point for RECV INITIAL METADATA
  157|      0|    interceptor_methods_.AddInterceptionHookPoint(
  158|      0|        experimental::InterceptionHookPoints::POST_RECV_INITIAL_METADATA);
  159|      0|    interceptor_methods_.SetRecvInitialMetadata(&context_->client_metadata_);
  160|      0|    if (interceptor_methods_.RunInterceptors(
  161|      0|            [this]() { ContinueFinalizeResultAfterInterception(); })) {
  162|      0|      // There are no interceptors to run. Continue
  163|      0|    } else {
  164|      0|      // There were interceptors to be run, so
  165|      0|      // ContinueFinalizeResultAfterInterception will be run when interceptors
  166|      0|      // are done.
  167|      0|      return false;
  168|      0|    }
  169|      0|  }
  170|      0|  if (*status && call_) {
  171|      0|    context_->BeginCompletionOp(&call_wrapper_, nullptr, nullptr);
  172|      0|  }
  173|      0|  *tag = tag_;
  174|      0|  if (delete_on_finalize_) {
  175|      0|    delete this;
  176|      0|  }
  177|      0|  return true;
  178|      0|}
  179|       |
  180|       |void ServerInterface::BaseAsyncRequest::
  181|      0|    ContinueFinalizeResultAfterInterception() {
  182|      0|  context_->BeginCompletionOp(&call_wrapper_, nullptr, nullptr);
  183|      0|  // Queue a tag which will be returned immediately
  184|      0|  grpc_core::ExecCtx exec_ctx;
  185|      0|  grpc_cq_begin_op(notification_cq_->cq(), this);
  186|      0|  grpc_cq_end_op(
  187|      0|      notification_cq_->cq(), this, GRPC_ERROR_NONE,
  188|      0|      [](void* arg, grpc_cq_completion* completion) { delete completion; },
  189|      0|      nullptr, new grpc_cq_completion());
  190|      0|}
  191|       |
  192|       |ServerInterface::RegisteredAsyncRequest::RegisteredAsyncRequest(
  193|       |    ServerInterface* server, ServerContext* context,
  194|       |    internal::ServerAsyncStreamingInterface* stream, CompletionQueue* call_cq,
  195|       |    ServerCompletionQueue* notification_cq, void* tag, const char* name,
  196|       |    internal::RpcMethod::RpcType type)
  197|       |    : BaseAsyncRequest(server, context, stream, call_cq, notification_cq, tag,
  198|       |                       true),
  199|       |      name_(name),
  200|      0|      type_(type) {}
  201|       |
  202|       |void ServerInterface::RegisteredAsyncRequest::IssueRequest(
  203|       |    void* registered_method, grpc_byte_buffer** payload,
  204|      0|    ServerCompletionQueue* notification_cq) {
  205|      0|  GPR_ASSERT(GRPC_CALL_OK == grpc_server_request_registered_call(
  206|      0|                                 server_->server(), registered_method, &call_,
  207|      0|                                 &context_->deadline_,
  208|      0|                                 context_->client_metadata_.arr(), payload,
  209|      0|                                 call_cq_->cq(), notification_cq->cq(), this));
  210|      0|}
  211|       |
  212|       |ServerInterface::GenericAsyncRequest::GenericAsyncRequest(
  213|       |    ServerInterface* server, GenericServerContext* context,
  214|       |    internal::ServerAsyncStreamingInterface* stream, CompletionQueue* call_cq,
  215|       |    ServerCompletionQueue* notification_cq, void* tag, bool delete_on_finalize)
  216|       |    : BaseAsyncRequest(server, context, stream, call_cq, notification_cq, tag,
  217|      0|                       delete_on_finalize) {
  218|      0|  grpc_call_details_init(&call_details_);
  219|      0|  GPR_ASSERT(notification_cq);
  220|      0|  GPR_ASSERT(call_cq);
  221|      0|  GPR_ASSERT(GRPC_CALL_OK == grpc_server_request_call(
  222|      0|                                 server->server(), &call_, &call_details_,
  223|      0|                                 context->client_metadata_.arr(), call_cq->cq(),
  224|      0|                                 notification_cq->cq(), this));
  225|      0|}
  226|       |
  227|       |bool ServerInterface::GenericAsyncRequest::FinalizeResult(void** tag,
  228|      0|                                                          bool* status) {
  229|      0|  // If we are done intercepting, there is nothing more for us to do
  230|      0|  if (done_intercepting_) {
  231|      0|    return BaseAsyncRequest::FinalizeResult(tag, status);
  232|      0|  }
  233|      0|  // TODO(yangg) remove the copy here.
  234|      0|  if (*status) {
  235|      0|    static_cast<GenericServerContext*>(context_)->method_ =
  236|      0|        StringFromCopiedSlice(call_details_.method);
  237|      0|    static_cast<GenericServerContext*>(context_)->host_ =
  238|      0|        StringFromCopiedSlice(call_details_.host);
  239|      0|    context_->deadline_ = call_details_.deadline;
  240|      0|  }
  241|      0|  grpc_slice_unref(call_details_.method);
  242|      0|  grpc_slice_unref(call_details_.host);
  243|      0|  call_wrapper_ = internal::Call(
  244|      0|      call_, server_, call_cq_, server_->max_receive_message_size(),
  245|      0|      context_->set_server_rpc_info(
  246|      0|          static_cast<GenericServerContext*>(context_)->method_.c_str(),
  247|      0|          internal::RpcMethod::BIDI_STREAMING,
  248|      0|          *server_->interceptor_creators()));
  249|      0|  return BaseAsyncRequest::FinalizeResult(tag, status);
  250|      0|}
  251|       |
  252|       |namespace {
  253|       |class ShutdownCallback : public grpc_experimental_completion_queue_functor {
  254|       | public:
  255|      0|  ShutdownCallback() { functor_run = &ShutdownCallback::Run; }
  256|       |  // TakeCQ takes ownership of the cq into the shutdown callback
  257|       |  // so that the shutdown callback will be responsible for destroying it
  258|      0|  void TakeCQ(CompletionQueue* cq) { cq_ = cq; }
  259|       |
  260|       |  // The Run function will get invoked by the completion queue library
  261|       |  // when the shutdown is actually complete
  262|      0|  static void Run(grpc_experimental_completion_queue_functor* cb, int) {
  263|      0|    auto* callback = static_cast<ShutdownCallback*>(cb);
  264|      0|    delete callback->cq_;
  265|      0|    delete callback;
  266|      0|  }
  267|       |
  268|       | private:
  269|       |  CompletionQueue* cq_ = nullptr;
  270|       |};
  271|       |}  // namespace
  272|       |
  273|       |}  // namespace grpc
  274|       |
  275|       |namespace grpc_impl {
  276|       |
  277|       |/// Use private inheritance rather than composition only to establish order
  278|       |/// of construction, since the public base class should be constructed after the
  279|       |/// elements belonging to the private base class are constructed. This is not
  280|       |/// possible using true composition.
  281|       |class Server::UnimplementedAsyncRequest final
  282|       |    : private grpc::UnimplementedAsyncRequestContext,
  283|       |      public GenericAsyncRequest {
  284|       | public:
  285|       |  UnimplementedAsyncRequest(Server* server, grpc::ServerCompletionQueue* cq)
  286|       |      : GenericAsyncRequest(server, &server_context_, &generic_stream_, cq, cq,
  287|       |                            nullptr, false),
  288|       |        server_(server),
  289|      0|        cq_(cq) {}
  290|       |
  291|       |  bool FinalizeResult(void** tag, bool* status) override;
  292|       |
  293|      0|  grpc::ServerContext* context() { return &server_context_; }
  294|      0|  grpc::GenericServerAsyncReaderWriter* stream() { return &generic_stream_; }
  295|       |
  296|       | private:
  297|       |  Server* const server_;
  298|       |  grpc::ServerCompletionQueue* const cq_;
  299|       |};
  300|       |
  301|       |/// UnimplementedAsyncResponse should not post user-visible completions to the
  302|       |/// C++ completion queue, but is generated as a CQ event by the core
  303|       |class Server::UnimplementedAsyncResponse final
  304|       |    : public grpc::internal::CallOpSet<
  305|       |          grpc::internal::CallOpSendInitialMetadata,
  306|       |          grpc::internal::CallOpServerSendStatus> {
  307|       | public:
  308|       |  UnimplementedAsyncResponse(UnimplementedAsyncRequest* request);
  309|      0|  ~UnimplementedAsyncResponse() { delete request_; }
  310|       |
  311|      0|  bool FinalizeResult(void** tag, bool* status) override {
  312|      0|    if (grpc::internal::CallOpSet<
  313|      0|            grpc::internal::CallOpSendInitialMetadata,
  314|      0|            grpc::internal::CallOpServerSendStatus>::FinalizeResult(tag,
  315|      0|                                                                    status)) {
  316|      0|      delete this;
  317|      0|    } else {
  318|      0|      // The tag was swallowed due to interception. We will see it again.
  319|      0|    }
  320|      0|    return false;
  321|      0|  }
  322|       |
  323|       | private:
  324|       |  UnimplementedAsyncRequest* const request_;
  325|       |};
  326|       |
  327|       |class Server::SyncRequest final : public grpc::internal::CompletionQueueTag {
  328|       | public:
  329|       |  SyncRequest(grpc::internal::RpcServiceMethod* method, void* method_tag)
  330|       |      : method_(method),
  331|       |        method_tag_(method_tag),
  332|       |        in_flight_(false),
  333|       |        has_request_payload_(method->method_type() ==
  334|       |                                 grpc::internal::RpcMethod::NORMAL_RPC ||
  335|       |                             method->method_type() ==
  336|       |                                 grpc::internal::RpcMethod::SERVER_STREAMING),
  337|       |        call_details_(nullptr),
  338|      0|        cq_(nullptr) {
  339|      0|    grpc_metadata_array_init(&request_metadata_);
  340|      0|  }
  341|       |
  342|      0|  ~SyncRequest() {
  343|      0|    if (call_details_) {
  344|      0|      delete call_details_;
  345|      0|    }
  346|      0|    grpc_metadata_array_destroy(&request_metadata_);
  347|      0|  }
  348|       |
  349|      0|  void SetupRequest() { cq_ = grpc_completion_queue_create_for_pluck(nullptr); }
  350|       |
  351|      0|  void TeardownRequest() {
  352|      0|    grpc_completion_queue_destroy(cq_);
  353|      0|    cq_ = nullptr;
  354|      0|  }
  355|       |
  356|      0|  void Request(grpc_server* server, grpc_completion_queue* notify_cq) {
  357|      0|    GPR_ASSERT(cq_ && !in_flight_);
  358|      0|    in_flight_ = true;
  359|      0|    if (method_tag_) {
  360|      0|      if (grpc_server_request_registered_call(
  361|      0|              server, method_tag_, &call_, &deadline_, &request_metadata_,
  362|      0|              has_request_payload_ ? &request_payload_ : nullptr, cq_,
  363|      0|              notify_cq, this) != GRPC_CALL_OK) {
  364|      0|        TeardownRequest();
  365|      0|        return;
  366|      0|      }
  367|      0|    } else {
  368|      0|      if (!call_details_) {
  369|      0|        call_details_ = new grpc_call_details;
  370|      0|        grpc_call_details_init(call_details_);
  371|      0|      }
  372|      0|      if (grpc_server_request_call(server, &call_, call_details_,
  373|      0|                                   &request_metadata_, cq_, notify_cq,
  374|      0|                                   this) != GRPC_CALL_OK) {
  375|      0|        TeardownRequest();
  376|      0|        return;
  377|      0|      }
  378|      0|    }
  379|      0|  }
  380|       |
  381|      0|  void PostShutdownCleanup() {
  382|      0|    if (call_) {
  383|      0|      grpc_call_unref(call_);
  384|      0|      call_ = nullptr;
  385|      0|    }
  386|      0|    if (cq_) {
  387|      0|      grpc_completion_queue_destroy(cq_);
  388|      0|      cq_ = nullptr;
  389|      0|    }
  390|      0|  }
  391|       |
  392|      0|  bool FinalizeResult(void** tag, bool* status) override {
  393|      0|    if (!*status) {
  394|      0|      grpc_completion_queue_destroy(cq_);
  395|      0|      cq_ = nullptr;
  396|      0|    }
  397|      0|    if (call_details_) {
  398|      0|      deadline_ = call_details_->deadline;
  399|      0|      grpc_call_details_destroy(call_details_);
  400|      0|      grpc_call_details_init(call_details_);
  401|      0|    }
  402|      0|    return true;
  403|      0|  }
  404|       |
  405|       |  // The CallData class represents a call that is "active" as opposed
  406|       |  // to just being requested. It wraps and takes ownership of the cq from
  407|       |  // the call request
  408|       |  class CallData final {
  409|       |   public:
  410|       |    explicit CallData(Server* server, SyncRequest* mrd)
  411|       |        : cq_(mrd->cq_),
  412|       |          ctx_(mrd->deadline_, &mrd->request_metadata_),
  413|       |          has_request_payload_(mrd->has_request_payload_),
  414|       |          request_payload_(has_request_payload_ ? mrd->request_payload_
  415|       |                                                : nullptr),
  416|       |          request_(nullptr),
  417|       |          method_(mrd->method_),
  418|       |          call_(
  419|       |              mrd->call_, server, &cq_, server->max_receive_message_size(),
  420|       |              ctx_.set_server_rpc_info(method_->name(), method_->method_type(),
  421|       |                                       server->interceptor_creators_)),
  422|       |          server_(server),
  423|       |          global_callbacks_(nullptr),
  424|      0|          resources_(false) {
  425|      0|      ctx_.set_call(mrd->call_);
  426|      0|      ctx_.cq_ = &cq_;
  427|      0|      GPR_ASSERT(mrd->in_flight_);
  428|      0|      mrd->in_flight_ = false;
  429|      0|      mrd->request_metadata_.count = 0;
  430|      0|    }
  431|       |
  432|      0|    ~CallData() {
  433|      0|      if (has_request_payload_ && request_payload_) {
  434|      0|        grpc_byte_buffer_destroy(request_payload_);
  435|      0|      }
  436|      0|    }
  437|       |
  438|       |    void Run(const std::shared_ptr<GlobalCallbacks>& global_callbacks,
  439|      0|             bool resources) {
  440|      0|      global_callbacks_ = global_callbacks;
  441|      0|      resources_ = resources;
  442|      0|
  443|      0|      interceptor_methods_.SetCall(&call_);
  444|      0|      interceptor_methods_.SetReverse();
  445|      0|      // Set interception point for RECV INITIAL METADATA
  446|      0|      interceptor_methods_.AddInterceptionHookPoint(
  447|      0|          grpc::experimental::InterceptionHookPoints::
  448|      0|              POST_RECV_INITIAL_METADATA);
  449|      0|      interceptor_methods_.SetRecvInitialMetadata(&ctx_.client_metadata_);
  450|      0|
  451|      0|      if (has_request_payload_) {
  452|      0|        // Set interception point for RECV MESSAGE
  453|      0|        auto* handler = resources_ ? method_->handler()
  454|      0|                                   : server_->resource_exhausted_handler_.get();
  455|      0|        request_ = handler->Deserialize(call_.call(), request_payload_,
  456|      0|                                        &request_status_, nullptr);
  457|      0|
  458|      0|        request_payload_ = nullptr;
  459|      0|        interceptor_methods_.AddInterceptionHookPoint(
  460|      0|            grpc::experimental::InterceptionHookPoints::POST_RECV_MESSAGE);
  461|      0|        interceptor_methods_.SetRecvMessage(request_, nullptr);
  462|      0|      }
  463|      0|
  464|      0|      if (interceptor_methods_.RunInterceptors(
  465|      0|              [this]() { ContinueRunAfterInterception(); })) {
  466|      0|        ContinueRunAfterInterception();
  467|      0|      } else {
  468|      0|        // There were interceptors to be run, so ContinueRunAfterInterception
  469|      0|        // will be run when interceptors are done.
  470|      0|      }
  471|      0|    }
  472|       |
  473|      0|    void ContinueRunAfterInterception() {
  474|      0|      {
  475|      0|        ctx_.BeginCompletionOp(&call_, nullptr, nullptr);
  476|      0|        global_callbacks_->PreSynchronousRequest(&ctx_);
  477|      0|        auto* handler = resources_ ? method_->handler()
  478|      0|                                   : server_->resource_exhausted_handler_.get();
  479|      0|        handler->RunHandler(grpc::internal::MethodHandler::HandlerParameter(
  480|      0|            &call_, &ctx_, request_, request_status_, nullptr, nullptr));
  481|      0|        request_ = nullptr;
  482|      0|        global_callbacks_->PostSynchronousRequest(&ctx_);
  483|      0|
  484|      0|        cq_.Shutdown();
  485|      0|
  486|      0|        grpc::internal::CompletionQueueTag* op_tag = ctx_.GetCompletionOpTag();
  487|      0|        cq_.TryPluck(op_tag, gpr_inf_future(GPR_CLOCK_REALTIME));
  488|      0|
  489|      0|        /* Ensure the cq_ is shutdown */
  490|      0|        grpc::DummyTag ignored_tag;
  491|      0|        GPR_ASSERT(cq_.Pluck(&ignored_tag) == false);
  492|      0|      }
  493|      0|      delete this;
  494|      0|    }
  495|       |
  496|       |   private:
  497|       |    grpc::CompletionQueue cq_;
  498|       |    grpc::ServerContext ctx_;
  499|       |    const bool has_request_payload_;
  500|       |    grpc_byte_buffer* request_payload_;
  501|       |    void* request_;
  502|       |    grpc::Status request_status_;
  503|       |    grpc::internal::RpcServiceMethod* const method_;
  504|       |    grpc::internal::Call call_;
  505|       |    Server* server_;
  506|       |    std::shared_ptr<GlobalCallbacks> global_callbacks_;
  507|       |    bool resources_;
  508|       |    grpc::internal::InterceptorBatchMethodsImpl interceptor_methods_;
  509|       |  };
  510|       |
  511|       | private:
  512|       |  grpc::internal::RpcServiceMethod* const method_;
  513|       |  void* const method_tag_;
  514|       |  bool in_flight_;
  515|       |  const bool has_request_payload_;
  516|       |  grpc_call* call_;
  517|       |  grpc_call_details* call_details_;
  518|       |  gpr_timespec deadline_;
  519|       |  grpc_metadata_array request_metadata_;
  520|       |  grpc_byte_buffer* request_payload_;
  521|       |  grpc_completion_queue* cq_;
  522|       |};
  523|       |
  524|       |class Server::CallbackRequestBase : public grpc::internal::CompletionQueueTag {
  525|       | public:
  526|      0|  virtual ~CallbackRequestBase() {}
  527|       |  virtual bool Request() = 0;
  528|       |};
  529|       |
  530|       |template <class ServerContextType>
  531|       |class Server::CallbackRequest final : public Server::CallbackRequestBase {
  532|       | public:
  533|       |  static_assert(std::is_base_of<grpc::ServerContext, ServerContextType>::value,
  534|       |                "ServerContextType must be derived from ServerContext");
  535|       |
  536|       |  // The constructor needs to know the server for this callback request and its
  537|       |  // index in the server's request count array to allow for proper dynamic
  538|       |  // requesting of incoming RPCs. For codegen services, the values of method and
  539|       |  // method_tag represent the defined characteristics of the method being
  540|       |  // requested. For generic services, method and method_tag are nullptr since
  541|       |  // these services don't have pre-defined methods or method registration tags.
  542|       |  CallbackRequest(Server* server, size_t method_idx,
  543|       |                  grpc::internal::RpcServiceMethod* method, void* method_tag)
  544|       |      : server_(server),
  545|       |        method_index_(method_idx),
  546|       |        method_(method),
  547|       |        method_tag_(method_tag),
  548|       |        has_request_payload_(
  549|       |            method_ != nullptr &&
  550|       |            (method->method_type() == grpc::internal::RpcMethod::NORMAL_RPC ||
  551|       |             method->method_type() ==
  552|       |                 grpc::internal::RpcMethod::SERVER_STREAMING)),
  553|       |        cq_(server->CallbackCQ()),
  554|      0|        tag_(this) {
  555|      0|    server_->callback_reqs_outstanding_++;
  556|      0|    Setup();
  557|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEEC2EPS0_mPNS2_8internal16RpcServiceMethodEPv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEEC2EPS0_mPNS2_8internal16RpcServiceMethodEPv
  ------------------
  558|       |
  559|      0|  ~CallbackRequest() {
  560|      0|    Clear();
  561|      0|
  562|      0|    // The counter of outstanding requests must be decremented
  563|      0|    // under a lock in case it causes the server shutdown.
  564|      0|    grpc::internal::MutexLock l(&server_->callback_reqs_mu_);
  565|      0|    if (--server_->callback_reqs_outstanding_ == 0) {
  566|      0|      server_->callback_reqs_done_cv_.Signal();
  567|      0|    }
  568|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEED2Ev
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEED2Ev
  ------------------
  569|       |
  570|      0|  bool Request() override {
  571|      0|    if (method_tag_) {
  572|      0|      if (GRPC_CALL_OK !=
  573|      0|          grpc_server_request_registered_call(
  574|      0|              server_->c_server(), method_tag_, &call_, &deadline_,
  575|      0|              &request_metadata_,
  576|      0|              has_request_payload_ ? &request_payload_ : nullptr, cq_->cq(),
  577|      0|              cq_->cq(), static_cast<void*>(&tag_))) {
  578|      0|        return false;
  579|      0|      }
  580|      0|    } else {
  581|      0|      if (!call_details_) {
  582|      0|        call_details_ = new grpc_call_details;
  583|      0|        grpc_call_details_init(call_details_);
  584|      0|      }
  585|      0|      if (grpc_server_request_call(server_->c_server(), &call_, call_details_,
  586|      0|                                   &request_metadata_, cq_->cq(), cq_->cq(),
  587|      0|                                   static_cast<void*>(&tag_)) != GRPC_CALL_OK) {
  588|      0|        return false;
  589|      0|      }
  590|      0|    }
  591|      0|    return true;
  592|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEE7RequestEv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEE7RequestEv
  ------------------
  593|       |
  594|       |  // Needs specialization to account for different processing of metadata
  595|       |  // in generic API
  596|       |  bool FinalizeResult(void** tag, bool* status) override;
  597|       |
  598|       | private:
  599|       |  // method_name needs to be specialized between named method and generic
  600|       |  const char* method_name() const;
  601|       |
  602|       |  class CallbackCallTag : public grpc_experimental_completion_queue_functor {
  603|       |   public:
  604|       |    CallbackCallTag(Server::CallbackRequest<ServerContextType>* req)
  605|      0|        : req_(req) {
  606|      0|      functor_run = &CallbackCallTag::StaticRun;
  607|      0|    }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEE15CallbackCallTagC2EPS4_
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEE15CallbackCallTagC2EPS4_
  ------------------
  608|       |
  609|       |    // force_run can not be performed on a tag if operations using this tag
  610|       |    // have been sent to PerformOpsOnCall. It is intended for error conditions
  611|       |    // that are detected before the operations are internally processed.
  612|       |    void force_run(bool ok) { Run(ok); }
  613|       |
  614|       |   private:
  615|       |    Server::CallbackRequest<ServerContextType>* req_;
  616|       |    grpc::internal::Call* call_;
  617|       |
  618|       |    static void StaticRun(grpc_experimental_completion_queue_functor* cb,
  619|      0|                          int ok) {
  620|      0|      static_cast<CallbackCallTag*>(cb)->Run(static_cast<bool>(ok));
  621|      0|    }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEE15CallbackCallTag9StaticRunEP42grpc_experimental_completion_queue_functori
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEE15CallbackCallTag9StaticRunEP42grpc_experimental_completion_queue_functori
  ------------------
  622|      0|    void Run(bool ok) {
  623|      0|      void* ignored = req_;
  624|      0|      bool new_ok = ok;
  625|      0|      GPR_ASSERT(!req_->FinalizeResult(&ignored, &new_ok));
  626|      0|      GPR_ASSERT(ignored == req_);
  627|      0|
  628|      0|      int count =
  629|      0|          static_cast<int>(gpr_atm_no_barrier_fetch_add(
  630|      0|              &req_->server_
  631|      0|                   ->callback_unmatched_reqs_count_[req_->method_index_],
  632|      0|              -1)) -
  633|      0|          1;
  634|      0|      if (!ok) {
  635|      0|        // The call has been shutdown.
  636|      0|        // Delete its contents to free up the request.
  637|      0|        delete req_;
  638|      0|        return;
  639|      0|      }
  640|      0|
  641|      0|      // If this was the last request in the list or it is below the soft
  642|      0|      // minimum and there are spare requests available, set up a new one.
  643|      0|      if (count == 0 || (count < SOFT_MINIMUM_SPARE_CALLBACK_REQS_PER_METHOD &&
  644|      0|                         req_->server_->callback_reqs_outstanding_ <
  645|      0|                             SOFT_MAXIMUM_CALLBACK_REQS_OUTSTANDING)) {
  646|      0|        auto* new_req = new CallbackRequest<ServerContextType>(
  647|      0|            req_->server_, req_->method_index_, req_->method_,
  648|      0|            req_->method_tag_);
  649|      0|        if (!new_req->Request()) {
  650|      0|          // The server must have just decided to shutdown.
  651|      0|          gpr_atm_no_barrier_fetch_add(
  652|      0|              &new_req->server_
  653|      0|                   ->callback_unmatched_reqs_count_[new_req->method_index_],
  654|      0|              -1);
  655|      0|          delete new_req;
  656|      0|        }
  657|      0|      }
  658|      0|
  659|      0|      // Bind the call, deadline, and metadata from what we got
  660|      0|      req_->ctx_.set_call(req_->call_);
  661|      0|      req_->ctx_.cq_ = req_->cq_;
  662|      0|      req_->ctx_.BindDeadlineAndMetadata(req_->deadline_,
  663|      0|                                         &req_->request_metadata_);
  664|      0|      req_->request_metadata_.count = 0;
  665|      0|
  666|      0|      // Create a C++ Call to control the underlying core call
  667|      0|      call_ =
  668|      0|          new (grpc_call_arena_alloc(req_->call_, sizeof(grpc::internal::Call)))
  669|      0|              grpc::internal::Call(
  670|      0|                  req_->call_, req_->server_, req_->cq_,
  671|      0|                  req_->server_->max_receive_message_size(),
  672|      0|                  req_->ctx_.set_server_rpc_info(
  673|      0|                      req_->method_name(),
  674|      0|                      (req_->method_ != nullptr)
  675|      0|                          ? req_->method_->method_type()
  676|      0|                          : grpc::internal::RpcMethod::BIDI_STREAMING,
  677|      0|                      req_->server_->interceptor_creators_));
  678|      0|
  679|      0|      req_->interceptor_methods_.SetCall(call_);
  680|      0|      req_->interceptor_methods_.SetReverse();
  681|      0|      // Set interception point for RECV INITIAL METADATA
  682|      0|      req_->interceptor_methods_.AddInterceptionHookPoint(
  683|      0|          grpc::experimental::InterceptionHookPoints::
  684|      0|              POST_RECV_INITIAL_METADATA);
  685|      0|      req_->interceptor_methods_.SetRecvInitialMetadata(
  686|      0|          &req_->ctx_.client_metadata_);
  687|      0|
  688|      0|      if (req_->has_request_payload_) {
  689|      0|        // Set interception point for RECV MESSAGE
  690|      0|        req_->request_ = req_->method_->handler()->Deserialize(
  691|      0|            req_->call_, req_->request_payload_, &req_->request_status_,
  692|      0|            &req_->handler_data_);
  693|      0|        req_->request_payload_ = nullptr;
  694|      0|        req_->interceptor_methods_.AddInterceptionHookPoint(
  695|      0|            grpc::experimental::InterceptionHookPoints::POST_RECV_MESSAGE);
  696|      0|        req_->interceptor_methods_.SetRecvMessage(req_->request_, nullptr);
  697|      0|      }
  698|      0|
  699|      0|      if (req_->interceptor_methods_.RunInterceptors(
  700|      0|              [this] { ContinueRunAfterInterception(); })) {
  ------------------
  | Unexecuted instantiation: _ZZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEE15CallbackCallTag3RunEbENKUlvE_clEv
  ------------------
  | Unexecuted instantiation: _ZZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEE15CallbackCallTag3RunEbENKUlvE_clEv
  ------------------
  701|      0|        ContinueRunAfterInterception();
  702|      0|      } else {
  703|      0|        // There were interceptors to be run, so ContinueRunAfterInterception
  704|      0|        // will be run when interceptors are done.
  705|      0|      }
  706|      0|    }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEE15CallbackCallTag3RunEb
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEE15CallbackCallTag3RunEb
  ------------------
  707|      0|    void ContinueRunAfterInterception() {
  708|      0|      auto* handler = (req_->method_ != nullptr)
  709|      0|                          ? req_->method_->handler()
  710|      0|                          : req_->server_->generic_handler_.get();
  711|      0|      handler->RunHandler(grpc::internal::MethodHandler::HandlerParameter(
  712|      0|          call_, &req_->ctx_, req_->request_, req_->request_status_,
  713|      0|          req_->handler_data_, [this] {
  714|      0|            // Recycle this request if there aren't too many outstanding.
  715|      0|            // Note that we don't have to worry about a case where there
  716|      0|            // are no requests waiting to match for this method since that
  717|      0|            // is already taken care of when binding a request to a call.
  718|      0|            // TODO(vjpai): Also don't recycle this request if the dynamic
  719|      0|            //              load no longer justifies it. Consider measuring
  720|      0|            //              dynamic load and setting a target accordingly.
  721|      0|            if (req_->server_->callback_reqs_outstanding_ <
  722|      0|                SOFT_MAXIMUM_CALLBACK_REQS_OUTSTANDING) {
  723|      0|              req_->Clear();
  724|      0|              req_->Setup();
  725|      0|            } else {
  726|      0|              // We can free up this request because there are too many
  727|      0|              delete req_;
  728|      0|              return;
  729|      0|            }
  730|      0|            if (!req_->Request()) {
  731|      0|              // The server must have just decided to shutdown.
  732|      0|              delete req_;
  733|      0|            }
  734|      0|          }));
  ------------------
  | Unexecuted instantiation: _ZZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEE15CallbackCallTag28ContinueRunAfterInterceptionEvENKUlvE_clEv
  ------------------
  | Unexecuted instantiation: _ZZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEE15CallbackCallTag28ContinueRunAfterInterceptionEvENKUlvE_clEv
  ------------------
  735|      0|    }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEE15CallbackCallTag28ContinueRunAfterInterceptionEv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEE15CallbackCallTag28ContinueRunAfterInterceptionEv
  ------------------
  736|       |  };
  737|       |
  738|      0|  void Clear() {
  739|      0|    if (call_details_) {
  740|      0|      delete call_details_;
  741|      0|      call_details_ = nullptr;
  742|      0|    }
  743|      0|    grpc_metadata_array_destroy(&request_metadata_);
  744|      0|    if (has_request_payload_ && request_payload_) {
  745|      0|      grpc_byte_buffer_destroy(request_payload_);
  746|      0|    }
  747|      0|    ctx_.Clear();
  748|      0|    interceptor_methods_.ClearState();
  749|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEE5ClearEv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEE5ClearEv
  ------------------
  750|       |
  751|      0|  void Setup() {
  752|      0|    gpr_atm_no_barrier_fetch_add(
  753|      0|        &server_->callback_unmatched_reqs_count_[method_index_], 1);
  754|      0|    grpc_metadata_array_init(&request_metadata_);
  755|      0|    ctx_.Setup(gpr_inf_future(GPR_CLOCK_REALTIME));
  756|      0|    request_payload_ = nullptr;
  757|      0|    request_ = nullptr;
  758|      0|    handler_data_ = nullptr;
  759|      0|    request_status_ = grpc::Status();
  760|      0|  }
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc13ServerContextEE5SetupEv
  ------------------
  | Unexecuted instantiation: _ZN9grpc_impl6Server15CallbackRequestIN4grpc20GenericServerContextEE5SetupEv
  ------------------
  761|       |
  762|       |  Server* const server_;
  763|       |  const size_t method_index_;
  764|       |  grpc::internal::RpcServiceMethod* const method_;
  765|       |  void* const method_tag_;
  766|       |  const bool has_request_payload_;
  767|       |  grpc_byte_buffer* request_payload_;
  768|       |  void* request_;
  769|       |  void* handler_data_;
  770|       |  grpc::Status request_status_;
  771|       |  grpc_call_details* call_details_ = nullptr;
  772|       |  grpc_call* call_;
  773|       |  gpr_timespec deadline_;
  774|       |  grpc_metadata_array request_metadata_;
  775|       |  grpc::CompletionQueue* cq_;
  776|       |  CallbackCallTag tag_;
  777|       |  ServerContextType ctx_;
  778|       |  grpc::internal::InterceptorBatchMethodsImpl interceptor_methods_;
  779|       |};
  780|       |
  781|       |template <>
  782|       |bool Server::CallbackRequest<grpc::ServerContext>::FinalizeResult(
  783|      0|    void** tag, bool* status) {
  784|      0|  return false;
  785|      0|}
  786|       |
  787|       |template <>
  788|       |bool Server::CallbackRequest<grpc::GenericServerContext>::FinalizeResult(
  789|      0|    void** tag, bool* status) {
  790|      0|  if (*status) {
  791|      0|    // TODO(yangg) remove the copy here
  792|      0|    ctx_.method_ = grpc::StringFromCopiedSlice(call_details_->method);
  793|      0|    ctx_.host_ = grpc::StringFromCopiedSlice(call_details_->host);
  794|      0|  }
  795|      0|  grpc_slice_unref(call_details_->method);
  796|      0|  grpc_slice_unref(call_details_->host);
  797|      0|  return false;
  798|      0|}
  799|       |
  800|       |template <>
  801|      0|const char* Server::CallbackRequest<grpc::ServerContext>::method_name() const {
  802|      0|  return method_->name();
  803|      0|}
  804|       |
  805|       |template <>
  806|       |const char* Server::CallbackRequest<grpc::GenericServerContext>::method_name()
  807|      0|    const {
  808|      0|  return ctx_.method().c_str();
  809|      0|}
  810|       |
  811|       |// Implementation of ThreadManager. Each instance of SyncRequestThreadManager
  812|       |// manages a pool of threads that poll for incoming Sync RPCs and call the
  813|       |// appropriate RPC handlers
  814|       |class Server::SyncRequestThreadManager : public grpc::ThreadManager {
  815|       | public:
  816|       |  SyncRequestThreadManager(Server* server, grpc::CompletionQueue* server_cq,
  817|       |                           std::shared_ptr<GlobalCallbacks> global_callbacks,
  818|       |                           grpc_resource_quota* rq, int min_pollers,
  819|       |                           int max_pollers, int cq_timeout_msec)
  820|       |      : ThreadManager("SyncServer", rq, min_pollers, max_pollers),
  821|       |        server_(server),
  822|       |        server_cq_(server_cq),
  823|       |        cq_timeout_msec_(cq_timeout_msec),
  824|      0|        global_callbacks_(std::move(global_callbacks)) {}
  825|       |
  826|      0|  WorkStatus PollForWork(void** tag, bool* ok) override {
  827|      0|    *tag = nullptr;
  828|      0|    // TODO(ctiller): workaround for GPR_TIMESPAN based deadlines not working
  829|      0|    // right now
  830|      0|    gpr_timespec deadline =
  831|      0|        gpr_time_add(gpr_now(GPR_CLOCK_MONOTONIC),
  832|      0|                     gpr_time_from_millis(cq_timeout_msec_, GPR_TIMESPAN));
  833|      0|
  834|      0|    switch (server_cq_->AsyncNext(tag, ok, deadline)) {
  835|      0|      case grpc::CompletionQueue::TIMEOUT:
  836|      0|        return TIMEOUT;
  837|      0|      case grpc::CompletionQueue::SHUTDOWN:
  838|      0|        return SHUTDOWN;
  839|      0|      case grpc::CompletionQueue::GOT_EVENT:
  840|      0|        return WORK_FOUND;
  841|      0|    }
  842|      0|
  843|      0|    GPR_UNREACHABLE_CODE(return TIMEOUT);
  844|      0|  }
  845|       |
  846|      0|  void DoWork(void* tag, bool ok, bool resources) override {
  847|      0|    SyncRequest* sync_req = static_cast<SyncRequest*>(tag);
  848|      0|
  849|      0|    if (!sync_req) {
  850|      0|      // No tag. Nothing to work on. This is an unlikley scenario and possibly a
  851|      0|      // bug in RPC Manager implementation.
  852|      0|      gpr_log(GPR_ERROR, "Sync server. DoWork() was called with NULL tag");
  853|      0|      return;
  854|      0|    }
  855|      0|
  856|      0|    if (ok) {
  857|      0|      // Calldata takes ownership of the completion queue and interceptors
  858|      0|      // inside sync_req
  859|      0|      auto* cd = new SyncRequest::CallData(server_, sync_req);
  860|      0|      // Prepare for the next request
  861|      0|      if (!IsShutdown()) {
  862|      0|        sync_req->SetupRequest();  // Create new completion queue for sync_req
  863|      0|        sync_req->Request(server_->c_server(), server_cq_->cq());
  864|      0|      }
  865|      0|
  866|      0|      GPR_TIMER_SCOPE("cd.Run()", 0);
  867|      0|      cd->Run(global_callbacks_, resources);
  868|      0|    }
  869|      0|    // TODO (sreek) If ok is false here (which it isn't in case of
  870|      0|    // grpc_request_registered_call), we should still re-queue the request
  871|      0|    // object
  872|      0|  }
  873|       |
  874|      0|  void AddSyncMethod(grpc::internal::RpcServiceMethod* method, void* tag) {
  875|      0|    sync_requests_.emplace_back(new SyncRequest(method, tag));
  876|      0|  }
  877|       |
  878|      0|  void AddUnknownSyncMethod() {
  879|      0|    if (!sync_requests_.empty()) {
  880|      0|      unknown_method_.reset(new grpc::internal::RpcServiceMethod(
  881|      0|          "unknown", grpc::internal::RpcMethod::BIDI_STREAMING,
  882|      0|          new grpc::internal::UnknownMethodHandler));
  883|      0|      sync_requests_.emplace_back(
  884|      0|          new SyncRequest(unknown_method_.get(), nullptr));
  885|      0|    }
  886|      0|  }
  887|       |
  888|      0|  void Shutdown() override {
  889|      0|    ThreadManager::Shutdown();
  890|      0|    server_cq_->Shutdown();
  891|      0|  }
  892|       |
  893|      0|  void Wait() override {
  894|      0|    ThreadManager::Wait();
  895|      0|    // Drain any pending items from the queue
  896|      0|    void* tag;
  897|      0|    bool ok;
  898|      0|    while (server_cq_->Next(&tag, &ok)) {
  899|      0|      if (ok) {
  900|      0|        // If a request was pulled off the queue, it means that the thread
  901|      0|        // handling the request added it to the completion queue after shutdown
  902|      0|        // was called - because the thread had already started and checked the
  903|      0|        // shutdown flag before shutdown was called. In this case, we simply
  904|      0|        // clean it up here, *after* calling wait on all the worker threads, at
  905|      0|        // which point we are certain no in-flight requests will add more to the
  906|      0|        // queue. This fixes an intermittent memory leak on shutdown.
  907|      0|        SyncRequest* sync_req = static_cast<SyncRequest*>(tag);
  908|      0|        sync_req->PostShutdownCleanup();
  909|      0|      }
  910|      0|    }
  911|      0|  }
  912|       |
  913|      0|  void Start() {
  914|      0|    if (!sync_requests_.empty()) {
  915|      0|      for (auto m = sync_requests_.begin(); m != sync_requests_.end(); m++) {
  916|      0|        (*m)->SetupRequest();
  917|      0|        (*m)->Request(server_->c_server(), server_cq_->cq());
  918|      0|      }
  919|      0|
  920|      0|      Initialize();  // ThreadManager's Initialize()
  921|      0|    }
  922|      0|  }
  923|       |
  924|       | private:
  925|       |  Server* server_;
  926|       |  grpc::CompletionQueue* server_cq_;
  927|       |  int cq_timeout_msec_;
  928|       |  std::vector<std::unique_ptr<SyncRequest>> sync_requests_;
  929|       |  std::unique_ptr<grpc::internal::RpcServiceMethod> unknown_method_;
  930|       |  std::shared_ptr<Server::GlobalCallbacks> global_callbacks_;
  931|       |};
  932|       |
  933|       |static grpc::internal::GrpcLibraryInitializer g_gli_initializer;
  934|       |Server::Server(
  935|       |    int max_receive_message_size, grpc::ChannelArguments* args,
  936|       |    std::shared_ptr<std::vector<std::unique_ptr<grpc::ServerCompletionQueue>>>
  937|       |        sync_server_cqs,
  938|       |    int min_pollers, int max_pollers, int sync_cq_timeout_msec,
  939|       |    grpc_resource_quota* server_rq,
  940|       |    std::vector<
  941|       |        std::unique_ptr<grpc::experimental::ServerInterceptorFactoryInterface>>
  942|       |        interceptor_creators)
  943|       |    : interceptor_creators_(std::move(interceptor_creators)),
  944|       |      max_receive_message_size_(max_receive_message_size),
  945|       |      sync_server_cqs_(std::move(sync_server_cqs)),
  946|       |      started_(false),
  947|       |      shutdown_(false),
  948|       |      shutdown_notified_(false),
  949|       |      server_(nullptr),
  950|       |      server_initializer_(new grpc_impl::ServerInitializer(this)),
  951|      0|      health_check_service_disabled_(false) {
  952|      0|  g_gli_initializer.summon();
  953|      0|  gpr_once_init(&grpc::g_once_init_callbacks, grpc::InitGlobalCallbacks);
  954|      0|  global_callbacks_ = grpc::g_callbacks;
  955|      0|  global_callbacks_->UpdateArguments(args);
  956|      0|
  957|      0|  if (sync_server_cqs_ != nullptr) {
  958|      0|    bool default_rq_created = false;
  959|      0|    if (server_rq == nullptr) {
  960|      0|      server_rq = grpc_resource_quota_create("SyncServer-default-rq");
  961|      0|      grpc_resource_quota_set_max_threads(server_rq,
  962|      0|                                          DEFAULT_MAX_SYNC_SERVER_THREADS);
  963|      0|      default_rq_created = true;
  964|      0|    }
  965|      0|
  966|      0|    for (const auto& it : *sync_server_cqs_) {
  967|      0|      sync_req_mgrs_.emplace_back(new SyncRequestThreadManager(
  968|      0|          this, it.get(), global_callbacks_, server_rq, min_pollers,
  969|      0|          max_pollers, sync_cq_timeout_msec));
  970|      0|    }
  971|      0|
  972|      0|    if (default_rq_created) {
  973|      0|      grpc_resource_quota_unref(server_rq);
  974|      0|    }
  975|      0|  }
  976|      0|
  977|      0|  grpc_channel_args channel_args;
  978|      0|  args->SetChannelArgs(&channel_args);
  979|      0|
  980|      0|  for (size_t i = 0; i < channel_args.num_args; i++) {
  981|      0|    if (0 == strcmp(channel_args.args[i].key,
  982|      0|                    grpc::kHealthCheckServiceInterfaceArg)) {
  983|      0|      if (channel_args.args[i].value.pointer.p == nullptr) {
  984|      0|        health_check_service_disabled_ = true;
  985|      0|      } else {
  986|      0|        health_check_service_.reset(
  987|      0|            static_cast<grpc::HealthCheckServiceInterface*>(
  988|      0|                channel_args.args[i].value.pointer.p));
  989|      0|      }
  990|      0|      break;
  991|      0|    }
  992|      0|  }
  993|      0|
  994|      0|  server_ = grpc_server_create(&channel_args, nullptr);
  995|      0|}
  996|       |
  997|      0|Server::~Server() {
  998|      0|  {
  999|      0|    grpc::internal::ReleasableMutexLock lock(&mu_);
 1000|      0|    if (callback_cq_ != nullptr) {
 1001|      0|      callback_cq_->Shutdown();
 1002|      0|    }
 1003|      0|    if (started_ && !shutdown_) {
 1004|      0|      lock.Unlock();
 1005|      0|      Shutdown();
 1006|      0|    } else if (!started_) {
 1007|      0|      // Shutdown the completion queues
 1008|      0|      for (auto it = sync_req_mgrs_.begin(); it != sync_req_mgrs_.end(); it++) {
 1009|      0|        (*it)->Shutdown();
 1010|      0|      }
 1011|      0|    }
 1012|      0|  }
 1013|      0|
 1014|      0|  grpc_server_destroy(server_);
 1015|      0|  for (auto& per_method_count : callback_unmatched_reqs_count_) {
 1016|      0|    // There should be no more unmatched callbacks for any method
 1017|      0|    // as each request is failed by Shutdown. Check that this actually
 1018|      0|    // happened
 1019|      0|    GPR_ASSERT(static_cast<int>(gpr_atm_no_barrier_load(&per_method_count)) ==
 1020|      0|               0);
 1021|      0|  }
 1022|      0|}
 1023|       |
 1024|      0|void Server::SetGlobalCallbacks(GlobalCallbacks* callbacks) {
 1025|      0|  GPR_ASSERT(!grpc::g_callbacks);
 1026|      0|  GPR_ASSERT(callbacks);
 1027|      0|  grpc::g_callbacks.reset(callbacks);
 1028|      0|}
 1029|       |
 1030|      0|grpc_server* Server::c_server() { return server_; }
 1031|       |
 1032|       |std::shared_ptr<grpc::Channel> Server::InProcessChannel(
 1033|      0|    const grpc::ChannelArguments& args) {
 1034|      0|  grpc_channel_args channel_args = args.c_channel_args();
 1035|      0|  return grpc::CreateChannelInternal(
 1036|      0|      "inproc", grpc_inproc_channel_create(server_, &channel_args, nullptr),
 1037|      0|      std::vector<std::unique_ptr<
 1038|      0|          grpc::experimental::ClientInterceptorFactoryInterface>>());
 1039|      0|}
 1040|       |
 1041|       |std::shared_ptr<grpc::Channel>
 1042|       |Server::experimental_type::InProcessChannelWithInterceptors(
 1043|       |    const grpc::ChannelArguments& args,
 1044|       |    std::vector<
 1045|       |        std::unique_ptr<grpc::experimental::ClientInterceptorFactoryInterface>>
 1046|      0|        interceptor_creators) {
 1047|      0|  grpc_channel_args channel_args = args.c_channel_args();
 1048|      0|  return grpc::CreateChannelInternal(
 1049|      0|      "inproc",
 1050|      0|      grpc_inproc_channel_create(server_->server_, &channel_args, nullptr),
 1051|      0|      std::move(interceptor_creators));
 1052|      0|}
 1053|       |
 1054|       |static grpc_server_register_method_payload_handling PayloadHandlingForMethod(
 1055|      0|    grpc::internal::RpcServiceMethod* method) {
 1056|      0|  switch (method->method_type()) {
 1057|      0|    case grpc::internal::RpcMethod::NORMAL_RPC:
 1058|      0|    case grpc::internal::RpcMethod::SERVER_STREAMING:
 1059|      0|      return GRPC_SRM_PAYLOAD_READ_INITIAL_BYTE_BUFFER;
 1060|      0|    case grpc::internal::RpcMethod::CLIENT_STREAMING:
 1061|      0|    case grpc::internal::RpcMethod::BIDI_STREAMING:
 1062|      0|      return GRPC_SRM_PAYLOAD_NONE;
 1063|      0|  }
 1064|      0|  GPR_UNREACHABLE_CODE(return GRPC_SRM_PAYLOAD_NONE;);
 1065|      0|}
 1066|       |
 1067|      0|bool Server::RegisterService(const grpc::string* host, grpc::Service* service) {
 1068|      0|  bool has_async_methods = service->has_async_methods();
 1069|      0|  if (has_async_methods) {
 1070|      0|    GPR_ASSERT(service->server_ == nullptr &&
 1071|      0|               "Can only register an asynchronous service against one server.");
 1072|      0|    service->server_ = this;
 1073|      0|  }
 1074|      0|
 1075|      0|  const char* method_name = nullptr;
 1076|      0|
 1077|      0|  for (auto it = service->methods_.begin(); it != service->methods_.end();
 1078|      0|       ++it) {
 1079|      0|    if (it->get() == nullptr) {  // Handled by generic service if any.
 1080|      0|      continue;
 1081|      0|    }
 1082|      0|
 1083|      0|    grpc::internal::RpcServiceMethod* method = it->get();
 1084|      0|    void* method_registration_tag = grpc_server_register_method(
 1085|      0|        server_, method->name(), host ? host->c_str() : nullptr,
 1086|      0|        PayloadHandlingForMethod(method), 0);
 1087|      0|    if (method_registration_tag == nullptr) {
 1088|      0|      gpr_log(GPR_DEBUG, "Attempt to register %s multiple times",
 1089|      0|              method->name());
 1090|      0|      return false;
 1091|      0|    }
 1092|      0|
 1093|      0|    if (method->handler() == nullptr) {  // Async method without handler
 1094|      0|      method->set_server_tag(method_registration_tag);
 1095|      0|    } else if (method->api_type() ==
 1096|      0|               grpc::internal::RpcServiceMethod::ApiType::SYNC) {
 1097|      0|      for (auto it = sync_req_mgrs_.begin(); it != sync_req_mgrs_.end(); it++) {
 1098|      0|        (*it)->AddSyncMethod(method, method_registration_tag);
 1099|      0|      }
 1100|      0|    } else {
 1101|      0|      // a callback method. Register at least some callback requests
 1102|      0|      callback_unmatched_reqs_count_.push_back(0);
 1103|      0|      auto method_index = callback_unmatched_reqs_count_.size() - 1;
 1104|      0|      // TODO(vjpai): Register these dynamically based on need
 1105|      0|      for (int i = 0; i < DEFAULT_CALLBACK_REQS_PER_METHOD; i++) {
 1106|      0|        callback_reqs_to_start_.push_back(
 1107|      0|            new CallbackRequest<grpc::ServerContext>(this, method_index, method,
 1108|      0|                                                     method_registration_tag));
 1109|      0|      }
 1110|      0|      // Enqueue it so that it will be Request'ed later after all request
 1111|      0|      // matchers are created at core server startup
 1112|      0|    }
 1113|      0|
 1114|      0|    method_name = method->name();
 1115|      0|  }
 1116|      0|
 1117|      0|  // Parse service name.
 1118|      0|  if (method_name != nullptr) {
 1119|      0|    std::stringstream ss(method_name);
 1120|      0|    grpc::string service_name;
 1121|      0|    if (std::getline(ss, service_name, '/') &&
 1122|      0|        std::getline(ss, service_name, '/')) {
 1123|      0|      services_.push_back(service_name);
 1124|      0|    }
 1125|      0|  }
 1126|      0|  return true;
 1127|      0|}
 1128|       |
 1129|      0|void Server::RegisterAsyncGenericService(grpc::AsyncGenericService* service) {
 1130|      0|  GPR_ASSERT(service->server_ == nullptr &&
 1131|      0|             "Can only register an async generic service against one server.");
 1132|      0|  service->server_ = this;
 1133|      0|  has_async_generic_service_ = true;
 1134|      0|}
 1135|       |
 1136|       |void Server::RegisterCallbackGenericService(
 1137|      0|    grpc::experimental::CallbackGenericService* service) {
 1138|      0|  GPR_ASSERT(
 1139|      0|      service->server_ == nullptr &&
 1140|      0|      "Can only register a callback generic service against one server.");
 1141|      0|  service->server_ = this;
 1142|      0|  has_callback_generic_service_ = true;
 1143|      0|  generic_handler_.reset(service->Handler());
 1144|      0|
 1145|      0|  callback_unmatched_reqs_count_.push_back(0);
 1146|      0|  auto method_index = callback_unmatched_reqs_count_.size() - 1;
 1147|      0|  // TODO(vjpai): Register these dynamically based on need
 1148|      0|  for (int i = 0; i < DEFAULT_CALLBACK_REQS_PER_METHOD; i++) {
 1149|      0|    callback_reqs_to_start_.push_back(
 1150|      0|        new CallbackRequest<grpc::GenericServerContext>(this, method_index,
 1151|      0|                                                        nullptr, nullptr));
 1152|      0|  }
 1153|      0|}
 1154|       |
 1155|       |int Server::AddListeningPort(const grpc::string& addr,
 1156|      0|                             grpc::ServerCredentials* creds) {
 1157|      0|  GPR_ASSERT(!started_);
 1158|      0|  int port = creds->AddPortToServer(addr, server_);
 1159|      0|  global_callbacks_->AddPort(this, addr, creds, port);
 1160|      0|  return port;
 1161|      0|}
 1162|       |
 1163|      0|void Server::Start(grpc::ServerCompletionQueue** cqs, size_t num_cqs) {
 1164|      0|  GPR_ASSERT(!started_);
 1165|      0|  global_callbacks_->PreServerStart(this);
 1166|      0|  started_ = true;
 1167|      0|
 1168|      0|  // Only create default health check service when user did not provide an
 1169|      0|  // explicit one.
 1170|      0|  grpc::ServerCompletionQueue* health_check_cq = nullptr;
 1171|      0|  grpc::DefaultHealthCheckService::HealthCheckServiceImpl*
 1172|      0|      default_health_check_service_impl = nullptr;
 1173|      0|  if (health_check_service_ == nullptr && !health_check_service_disabled_ &&
 1174|      0|      grpc::DefaultHealthCheckServiceEnabled()) {
 1175|      0|    auto* default_hc_service = new grpc::DefaultHealthCheckService;
 1176|      0|    health_check_service_.reset(default_hc_service);
 1177|      0|    // We create a non-polling CQ to avoid impacting application
 1178|      0|    // performance.  This ensures that we don't introduce thread hops
 1179|      0|    // for application requests that wind up on this CQ, which is polled
 1180|      0|    // in its own thread.
 1181|      0|    health_check_cq = new grpc::ServerCompletionQueue(
 1182|      0|        GRPC_CQ_NEXT, GRPC_CQ_NON_POLLING, nullptr);
 1183|      0|    grpc_server_register_completion_queue(server_, health_check_cq->cq(),
 1184|      0|                                          nullptr);
 1185|      0|    default_health_check_service_impl =
 1186|      0|        default_hc_service->GetHealthCheckService(
 1187|      0|            std::unique_ptr<grpc::ServerCompletionQueue>(health_check_cq));
 1188|      0|    RegisterService(nullptr, default_health_check_service_impl);
 1189|      0|  }
 1190|      0|
 1191|      0|  // If this server uses callback methods, then create a callback generic
 1192|      0|  // service to handle any unimplemented methods using the default reactor
 1193|      0|  // creator
 1194|      0|  if (!callback_reqs_to_start_.empty() && !has_callback_generic_service_) {
 1195|      0|    unimplemented_service_.reset(
 1196|      0|        new grpc::experimental::CallbackGenericService);
 1197|      0|    RegisterCallbackGenericService(unimplemented_service_.get());
 1198|      0|  }
 1199|      0|
 1200|      0|  grpc_server_start(server_);
 1201|      0|
 1202|      0|  if (!has_async_generic_service_ && !has_callback_generic_service_) {
 1203|      0|    for (auto it = sync_req_mgrs_.begin(); it != sync_req_mgrs_.end(); it++) {
 1204|      0|      (*it)->AddUnknownSyncMethod();
 1205|      0|    }
 1206|      0|
 1207|      0|    for (size_t i = 0; i < num_cqs; i++) {
 1208|      0|      if (cqs[i]->IsFrequentlyPolled()) {
 1209|      0|        new UnimplementedAsyncRequest(this, cqs[i]);
 1210|      0|      }
 1211|      0|    }
 1212|      0|    if (health_check_cq != nullptr) {
 1213|      0|      new UnimplementedAsyncRequest(this, health_check_cq);
 1214|      0|    }
 1215|      0|  }
 1216|      0|
 1217|      0|  // If this server has any support for synchronous methods (has any sync
 1218|      0|  // server CQs), make sure that we have a ResourceExhausted handler
 1219|      0|  // to deal with the case of thread exhaustion
 1220|      0|  if (sync_server_cqs_ != nullptr && !sync_server_cqs_->empty()) {
 1221|      0|    resource_exhausted_handler_.reset(
 1222|      0|        new grpc::internal::ResourceExhaustedHandler);
 1223|      0|  }
 1224|      0|
 1225|      0|  for (auto it = sync_req_mgrs_.begin(); it != sync_req_mgrs_.end(); it++) {
 1226|      0|    (*it)->Start();
 1227|      0|  }
 1228|      0|
 1229|      0|  for (auto* cbreq : callback_reqs_to_start_) {
 1230|      0|    GPR_ASSERT(cbreq->Request());
 1231|      0|  }
 1232|      0|  callback_reqs_to_start_.clear();
 1233|      0|
 1234|      0|  if (default_health_check_service_impl != nullptr) {
 1235|      0|    default_health_check_service_impl->StartServingThread();
 1236|      0|  }
 1237|      0|}
 1238|       |
 1239|      0|void Server::ShutdownInternal(gpr_timespec deadline) {
 1240|      0|  grpc::internal::MutexLock lock(&mu_);
 1241|      0|  if (shutdown_) {
 1242|      0|    return;
 1243|      0|  }
 1244|      0|
 1245|      0|  shutdown_ = true;
 1246|      0|
 1247|      0|  /// The completion queue to use for server shutdown completion notification
 1248|      0|  grpc::CompletionQueue shutdown_cq;
 1249|      0|  grpc::ShutdownTag shutdown_tag;  // Dummy shutdown tag
 1250|      0|  grpc_server_shutdown_and_notify(server_, shutdown_cq.cq(), &shutdown_tag);
 1251|      0|
 1252|      0|  shutdown_cq.Shutdown();
 1253|      0|
 1254|      0|  void* tag;
 1255|      0|  bool ok;
 1256|      0|  grpc::CompletionQueue::NextStatus status =
 1257|      0|      shutdown_cq.AsyncNext(&tag, &ok, deadline);
 1258|      0|
 1259|      0|  // If this timed out, it means we are done with the grace period for a clean
 1260|      0|  // shutdown. We should force a shutdown now by cancelling all inflight calls
 1261|      0|  if (status == grpc::CompletionQueue::NextStatus::TIMEOUT) {
 1262|      0|    grpc_server_cancel_all_calls(server_);
 1263|      0|  }
 1264|      0|  // Else in case of SHUTDOWN or GOT_EVENT, it means that the server has
 1265|      0|  // successfully shutdown
 1266|      0|
 1267|      0|  // Shutdown all ThreadManagers. This will try to gracefully stop all the
 1268|      0|  // threads in the ThreadManagers (once they process any inflight requests)
 1269|      0|  for (auto it = sync_req_mgrs_.begin(); it != sync_req_mgrs_.end(); it++) {
 1270|      0|    (*it)->Shutdown();  // ThreadManager's Shutdown()
 1271|      0|  }
 1272|      0|
 1273|      0|  // Wait for threads in all ThreadManagers to terminate
 1274|      0|  for (auto it = sync_req_mgrs_.begin(); it != sync_req_mgrs_.end(); it++) {
 1275|      0|    (*it)->Wait();
 1276|      0|  }
 1277|      0|
 1278|      0|  // Wait for all outstanding callback requests to complete
 1279|      0|  // (whether waiting for a match or already active).
 1280|      0|  // We know that no new requests will be created after this point
 1281|      0|  // because they are only created at server startup time or when
 1282|      0|  // we have a successful match on a request. During the shutdown phase,
 1283|      0|  // requests that have not yet matched will be failed rather than
 1284|      0|  // allowed to succeed, which will cause the server to delete the
 1285|      0|  // request and decrement the count. Possibly a request will match before
 1286|      0|  // the shutdown but then find that shutdown has already started by the
 1287|      0|  // time it tries to register a new request. In that case, the registration
 1288|      0|  // will report a failure, indicating a shutdown and again we won't end
 1289|      0|  // up incrementing the counter.
 1290|      0|  {
 1291|      0|    grpc::internal::MutexLock cblock(&callback_reqs_mu_);
 1292|      0|    callback_reqs_done_cv_.WaitUntil(
 1293|      0|        &callback_reqs_mu_, [this] { return callback_reqs_outstanding_ == 0; });
 1294|      0|  }
 1295|      0|
 1296|      0|  // Drain the shutdown queue (if the previous call to AsyncNext() timed out
 1297|      0|  // and we didn't remove the tag from the queue yet)
 1298|      0|  while (shutdown_cq.Next(&tag, &ok)) {
 1299|      0|    // Nothing to be done here. Just ignore ok and tag values
 1300|      0|  }
 1301|      0|
 1302|      0|  shutdown_notified_ = true;
 1303|      0|  shutdown_cv_.Broadcast();
 1304|      0|}
 1305|       |
 1306|      0|void Server::Wait() {
 1307|      0|  grpc::internal::MutexLock lock(&mu_);
 1308|      0|  while (started_ && !shutdown_notified_) {
 1309|      0|    shutdown_cv_.Wait(&mu_);
 1310|      0|  }
 1311|      0|}
 1312|       |
 1313|       |void Server::PerformOpsOnCall(grpc::internal::CallOpSetInterface* ops,
 1314|      0|                              grpc::internal::Call* call) {
 1315|      0|  ops->FillOps(call);
 1316|      0|}
 1317|       |
 1318|       |bool Server::UnimplementedAsyncRequest::FinalizeResult(void** tag,
 1319|      0|                                                       bool* status) {
 1320|      0|  if (GenericAsyncRequest::FinalizeResult(tag, status)) {
 1321|      0|    // We either had no interceptors run or we are done intercepting
 1322|      0|    if (*status) {
 1323|      0|      new UnimplementedAsyncRequest(server_, cq_);
 1324|      0|      new UnimplementedAsyncResponse(this);
 1325|      0|    } else {
 1326|      0|      delete this;
 1327|      0|    }
 1328|      0|  } else {
 1329|      0|    // The tag was swallowed due to interception. We will see it again.
 1330|      0|  }
 1331|      0|  return false;
 1332|      0|}
 1333|       |
 1334|       |Server::UnimplementedAsyncResponse::UnimplementedAsyncResponse(
 1335|       |    UnimplementedAsyncRequest* request)
 1336|      0|    : request_(request) {
 1337|      0|  grpc::Status status(grpc::StatusCode::UNIMPLEMENTED, "");
 1338|      0|  grpc::internal::UnknownMethodHandler::FillOps(request_->context(), this);
 1339|      0|  request_->stream()->call_.PerformOps(this);
 1340|      0|}
 1341|       |
 1342|      0|grpc::ServerInitializer* Server::initializer() {
 1343|      0|  return server_initializer_.get();
 1344|      0|}
 1345|       |
 1346|      0|grpc::CompletionQueue* Server::CallbackCQ() {
 1347|      0|  // TODO(vjpai): Consider using a single global CQ for the default CQ
 1348|      0|  // if there is no explicit per-server CQ registered
 1349|      0|  grpc::internal::MutexLock l(&mu_);
 1350|      0|  if (callback_cq_ == nullptr) {
 1351|      0|    auto* shutdown_callback = new grpc::ShutdownCallback;
 1352|      0|    callback_cq_ = new grpc::CompletionQueue(grpc_completion_queue_attributes{
 1353|      0|        GRPC_CQ_CURRENT_VERSION, GRPC_CQ_CALLBACK, GRPC_CQ_DEFAULT_POLLING,
 1354|      0|        shutdown_callback});
 1355|      0|
 1356|      0|    // Transfer ownership of the new cq to its own shutdown callback
 1357|      0|    shutdown_callback->TakeCQ(callback_cq_);
 1358|      0|  }
 1359|      0|  return callback_cq_;
 1360|      0|}
 1361|       |
 1362|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/server_context.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/server_context.h>
   20|       |#include <grpcpp/support/server_callback.h>
   21|       |
   22|       |#include <algorithm>
   23|       |#include <mutex>
   24|       |#include <utility>
   25|       |
   26|       |#include <grpc/compression.h>
   27|       |#include <grpc/grpc.h>
   28|       |#include <grpc/load_reporting.h>
   29|       |#include <grpc/support/alloc.h>
   30|       |#include <grpc/support/log.h>
   31|       |#include <grpcpp/completion_queue.h>
   32|       |#include <grpcpp/impl/call.h>
   33|       |#include <grpcpp/support/time.h>
   34|       |
   35|       |#include "src/core/lib/gprpp/ref_counted.h"
   36|       |#include "src/core/lib/gprpp/sync.h"
   37|       |#include "src/core/lib/surface/call.h"
   38|       |
   39|       |namespace grpc {
   40|       |
   41|       |// CompletionOp
   42|       |
   43|       |class ServerContext::CompletionOp final : public internal::CallOpSetInterface {
   44|       | public:
   45|       |  // initial refs: one in the server context, one in the cq
   46|       |  // must ref the call before calling constructor and after deleting this
   47|       |  CompletionOp(internal::Call* call, internal::ServerReactor* reactor)
   48|       |      : call_(*call),
   49|       |        reactor_(reactor),
   50|       |        has_tag_(false),
   51|       |        tag_(nullptr),
   52|       |        core_cq_tag_(this),
   53|       |        refs_(2),
   54|       |        finalized_(false),
   55|       |        cancelled_(0),
   56|      0|        done_intercepting_(false) {}
   57|       |
   58|       |  // CompletionOp isn't copyable or movable
   59|       |  CompletionOp(const CompletionOp&) = delete;
   60|       |  CompletionOp& operator=(const CompletionOp&) = delete;
   61|       |  CompletionOp(CompletionOp&&) = delete;
   62|       |  CompletionOp& operator=(CompletionOp&&) = delete;
   63|       |
   64|      0|  ~CompletionOp() {
   65|      0|    if (call_.server_rpc_info()) {
   66|      0|      call_.server_rpc_info()->Unref();
   67|      0|    }
   68|      0|  }
   69|       |
   70|       |  void FillOps(internal::Call* call) override;
   71|       |
   72|       |  // This should always be arena allocated in the call, so override delete.
   73|       |  // But this class is not trivially destructible, so must actually call delete
   74|       |  // before allowing the arena to be freed
   75|      0|  static void operator delete(void* ptr, std::size_t size) {
   76|      0|    assert(size == sizeof(CompletionOp));
   77|      0|  }
   78|       |
   79|       |  // This operator should never be called as the memory should be freed as part
   80|       |  // of the arena destruction. It only exists to provide a matching operator
   81|       |  // delete to the operator new so that some compilers will not complain (see
   82|       |  // https://github.com/grpc/grpc/issues/11301) Note at the time of adding this
   83|       |  // there are no tests catching the compiler warning.
   84|      0|  static void operator delete(void*, void*) { assert(0); }
   85|       |
   86|       |  bool FinalizeResult(void** tag, bool* status) override;
   87|       |
   88|      0|  bool CheckCancelled(CompletionQueue* cq) {
   89|      0|    cq->TryPluck(this);
   90|      0|    return CheckCancelledNoPluck();
   91|      0|  }
   92|      0|  bool CheckCancelledAsync() { return CheckCancelledNoPluck(); }
   93|       |
   94|      0|  void set_tag(void* tag) {
   95|      0|    has_tag_ = true;
   96|      0|    tag_ = tag;
   97|      0|  }
   98|       |
   99|      0|  void SetCancelCallback(std::function<void()> callback) {
  100|      0|    grpc_core::MutexLock lock(&mu_);
  101|      0|
  102|      0|    if (finalized_ && (cancelled_ != 0)) {
  103|      0|      callback();
  104|      0|      return;
  105|      0|    }
  106|      0|
  107|      0|    cancel_callback_ = std::move(callback);
  108|      0|  }
  109|       |
  110|      0|  void ClearCancelCallback() {
  111|      0|    grpc_core::MutexLock g(&mu_);
  112|      0|    cancel_callback_ = nullptr;
  113|      0|  }
  114|       |
  115|      0|  void set_core_cq_tag(void* core_cq_tag) { core_cq_tag_ = core_cq_tag; }
  116|       |
  117|      0|  void* core_cq_tag() override { return core_cq_tag_; }
  118|       |
  119|       |  void Unref();
  120|       |
  121|       |  // This will be called while interceptors are run if the RPC is a hijacked
  122|       |  // RPC. This should set hijacking state for each of the ops.
  123|      0|  void SetHijackingState() override {
  124|      0|    /* Servers don't allow hijacking */
  125|      0|    GPR_CODEGEN_ASSERT(false);
  126|      0|  }
  127|       |
  128|       |  /* Should be called after interceptors are done running */
  129|      0|  void ContinueFillOpsAfterInterception() override {}
  130|       |
  131|       |  /* Should be called after interceptors are done running on the finalize result
  132|       |   * path */
  133|      0|  void ContinueFinalizeResultAfterInterception() override {
  134|      0|    done_intercepting_ = true;
  135|      0|    if (!has_tag_) {
  136|      0|      /* We don't have a tag to return. */
  137|      0|      Unref();
  138|      0|      return;
  139|      0|    }
  140|      0|    /* Start a dummy op so that we can return the tag */
  141|      0|    GPR_CODEGEN_ASSERT(
  142|      0|        GRPC_CALL_OK ==
  143|      0|        grpc_call_start_batch(call_.call(), nullptr, 0, core_cq_tag_, nullptr));
  144|      0|  }
  145|       |
  146|       | private:
  147|      0|  bool CheckCancelledNoPluck() {
  148|      0|    grpc_core::MutexLock lock(&mu_);
  149|      0|    return finalized_ ? (cancelled_ != 0) : false;
  150|      0|  }
  151|       |
  152|       |  internal::Call call_;
  153|       |  internal::ServerReactor* const reactor_;
  154|       |  bool has_tag_;
  155|       |  void* tag_;
  156|       |  void* core_cq_tag_;
  157|       |  grpc_core::RefCount refs_;
  158|       |  grpc_core::Mutex mu_;
  159|       |  bool finalized_;
  160|       |  int cancelled_;  // This is an int (not bool) because it is passed to core
  161|       |  std::function<void()> cancel_callback_;
  162|       |  bool done_intercepting_;
  163|       |  internal::InterceptorBatchMethodsImpl interceptor_methods_;
  164|       |};
  165|       |
  166|      0|void ServerContext::CompletionOp::Unref() {
  167|      0|  if (refs_.Unref()) {
  168|      0|    grpc_call* call = call_.call();
  169|      0|    delete this;
  170|      0|    grpc_call_unref(call);
  171|      0|  }
  172|      0|}
  173|       |
  174|      0|void ServerContext::CompletionOp::FillOps(internal::Call* call) {
  175|      0|  grpc_op ops;
  176|      0|  ops.op = GRPC_OP_RECV_CLOSE_ON_SERVER;
  177|      0|  ops.data.recv_close_on_server.cancelled = &cancelled_;
  178|      0|  ops.flags = 0;
  179|      0|  ops.reserved = nullptr;
  180|      0|  interceptor_methods_.SetCall(&call_);
  181|      0|  interceptor_methods_.SetReverse();
  182|      0|  interceptor_methods_.SetCallOpSetInterface(this);
  183|      0|  GPR_ASSERT(GRPC_CALL_OK == grpc_call_start_batch(call->call(), &ops, 1,
  184|      0|                                                   core_cq_tag_, nullptr));
  185|      0|  /* No interceptors to run here */
  186|      0|}
  187|       |
  188|      0|bool ServerContext::CompletionOp::FinalizeResult(void** tag, bool* status) {
  189|      0|  bool ret = false;
  190|      0|  grpc_core::ReleasableMutexLock lock(&mu_);
  191|      0|  if (done_intercepting_) {
  192|      0|    /* We are done intercepting. */
  193|      0|    if (has_tag_) {
  194|      0|      *tag = tag_;
  195|      0|      ret = true;
  196|      0|    }
  197|      0|    Unref();
  198|      0|    return ret;
  199|      0|  }
  200|      0|  finalized_ = true;
  201|      0|
  202|      0|  // If for some reason the incoming status is false, mark that as a
  203|      0|  // cancellation.
  204|      0|  // TODO(vjpai): does this ever happen?
  205|      0|  if (!*status) {
  206|      0|    cancelled_ = 1;
  207|      0|  }
  208|      0|
  209|      0|  // Decide whether to call the cancel callback before releasing the lock
  210|      0|  bool call_cancel = (cancelled_ != 0);
  211|      0|
  212|      0|  // If it's a unary cancel callback, call it under the lock so that it doesn't
  213|      0|  // race with ClearCancelCallback. Although we don't normally call callbacks
  214|      0|  // under a lock, this is a special case since the user needs a guarantee that
  215|      0|  // the callback won't issue or run after ClearCancelCallback has returned.
  216|      0|  // This requirement imposes certain restrictions on the callback, documented
  217|      0|  // in the API comments of SetCancelCallback.
  218|      0|  if (cancel_callback_) {
  219|      0|    cancel_callback_();
  220|      0|  }
  221|      0|
  222|      0|  // Release the lock since we may call a callback and interceptors now.
  223|      0|  lock.Unlock();
  224|      0|
  225|      0|  if (call_cancel && reactor_ != nullptr) {
  226|      0|    reactor_->MaybeCallOnCancel();
  227|      0|  }
  228|      0|  /* Add interception point and run through interceptors */
  229|      0|  interceptor_methods_.AddInterceptionHookPoint(
  230|      0|      experimental::InterceptionHookPoints::POST_RECV_CLOSE);
  231|      0|  if (interceptor_methods_.RunInterceptors()) {
  232|      0|    /* No interceptors were run */
  233|      0|    if (has_tag_) {
  234|      0|      *tag = tag_;
  235|      0|      ret = true;
  236|      0|    }
  237|      0|    Unref();
  238|      0|    return ret;
  239|      0|  }
  240|      0|  /* There are interceptors to be run. Return false for now */
  241|      0|  return false;
  242|      0|}
  243|       |
  244|       |// ServerContext body
  245|       |
  246|      0|ServerContext::ServerContext() { Setup(gpr_inf_future(GPR_CLOCK_REALTIME)); }
  247|       |
  248|      0|ServerContext::ServerContext(gpr_timespec deadline, grpc_metadata_array* arr) {
  249|      0|  Setup(deadline);
  250|      0|  std::swap(*client_metadata_.arr(), *arr);
  251|      0|}
  252|       |
  253|      0|void ServerContext::Setup(gpr_timespec deadline) {
  254|      0|  completion_op_ = nullptr;
  255|      0|  has_notify_when_done_tag_ = false;
  256|      0|  async_notify_when_done_tag_ = nullptr;
  257|      0|  deadline_ = deadline;
  258|      0|  call_ = nullptr;
  259|      0|  cq_ = nullptr;
  260|      0|  sent_initial_metadata_ = false;
  261|      0|  compression_level_set_ = false;
  262|      0|  has_pending_ops_ = false;
  263|      0|  rpc_info_ = nullptr;
  264|      0|}
  265|       |
  266|       |void ServerContext::BindDeadlineAndMetadata(gpr_timespec deadline,
  267|      0|                                            grpc_metadata_array* arr) {
  268|      0|  deadline_ = deadline;
  269|      0|  std::swap(*client_metadata_.arr(), *arr);
  270|      0|}
  271|       |
  272|      0|ServerContext::~ServerContext() { Clear(); }
  273|       |
  274|      0|void ServerContext::Clear() {
  275|      0|  auth_context_.reset();
  276|      0|  initial_metadata_.clear();
  277|      0|  trailing_metadata_.clear();
  278|      0|  client_metadata_.Reset();
  279|      0|  if (completion_op_) {
  280|      0|    completion_op_->Unref();
  281|      0|    completion_op_ = nullptr;
  282|      0|    completion_tag_.Clear();
  283|      0|  }
  284|      0|  if (rpc_info_) {
  285|      0|    rpc_info_->Unref();
  286|      0|    rpc_info_ = nullptr;
  287|      0|  }
  288|      0|  if (call_) {
  289|      0|    auto* call = call_;
  290|      0|    call_ = nullptr;
  291|      0|    grpc_call_unref(call);
  292|      0|  }
  293|      0|}
  294|       |
  295|       |void ServerContext::BeginCompletionOp(internal::Call* call,
  296|       |                                      std::function<void(bool)> callback,
  297|      0|                                      internal::ServerReactor* reactor) {
  298|      0|  GPR_ASSERT(!completion_op_);
  299|      0|  if (rpc_info_) {
  300|      0|    rpc_info_->Ref();
  301|      0|  }
  302|      0|  grpc_call_ref(call->call());
  303|      0|  completion_op_ =
  304|      0|      new (grpc_call_arena_alloc(call->call(), sizeof(CompletionOp)))
  305|      0|          CompletionOp(call, reactor);
  306|      0|  if (callback != nullptr) {
  307|      0|    completion_tag_.Set(call->call(), std::move(callback), completion_op_);
  308|      0|    completion_op_->set_core_cq_tag(&completion_tag_);
  309|      0|    completion_op_->set_tag(completion_op_);
  310|      0|  } else if (has_notify_when_done_tag_) {
  311|      0|    completion_op_->set_tag(async_notify_when_done_tag_);
  312|      0|  }
  313|      0|  call->PerformOps(completion_op_);
  314|      0|}
  315|       |
  316|      0|internal::CompletionQueueTag* ServerContext::GetCompletionOpTag() {
  317|      0|  return static_cast<internal::CompletionQueueTag*>(completion_op_);
  318|      0|}
  319|       |
  320|       |void ServerContext::AddInitialMetadata(const grpc::string& key,
  321|      0|                                       const grpc::string& value) {
  322|      0|  initial_metadata_.insert(std::make_pair(key, value));
  323|      0|}
  324|       |
  325|       |void ServerContext::AddTrailingMetadata(const grpc::string& key,
  326|      0|                                        const grpc::string& value) {
  327|      0|  trailing_metadata_.insert(std::make_pair(key, value));
  328|      0|}
  329|       |
  330|      0|void ServerContext::TryCancel() const {
  331|      0|  internal::CancelInterceptorBatchMethods cancel_methods;
  332|      0|  if (rpc_info_) {
  333|      0|    for (size_t i = 0; i < rpc_info_->interceptors_.size(); i++) {
  334|      0|      rpc_info_->RunInterceptor(&cancel_methods, i);
  335|      0|    }
  336|      0|  }
  337|      0|  grpc_call_error err = grpc_call_cancel_with_status(
  338|      0|      call_, GRPC_STATUS_CANCELLED, "Cancelled on the server side", nullptr);
  339|      0|  if (err != GRPC_CALL_OK) {
  340|      0|    gpr_log(GPR_ERROR, "TryCancel failed with: %d", err);
  341|      0|  }
  342|      0|}
  343|       |
  344|      0|void ServerContext::SetCancelCallback(std::function<void()> callback) {
  345|      0|  completion_op_->SetCancelCallback(std::move(callback));
  346|      0|}
  347|       |
  348|      0|void ServerContext::ClearCancelCallback() {
  349|      0|  completion_op_->ClearCancelCallback();
  350|      0|}
  351|       |
  352|      0|bool ServerContext::IsCancelled() const {
  353|      0|  if (completion_tag_) {
  354|      0|    // When using callback API, this result is always valid.
  355|      0|    return completion_op_->CheckCancelledAsync();
  356|      0|  } else if (has_notify_when_done_tag_) {
  357|      0|    // When using async API, the result is only valid
  358|      0|    // if the tag has already been delivered at the completion queue
  359|      0|    return completion_op_ && completion_op_->CheckCancelledAsync();
  360|      0|  } else {
  361|      0|    // when using sync API, the result is always valid
  362|      0|    return completion_op_ && completion_op_->CheckCancelled(cq_);
  363|      0|  }
  364|      0|}
  365|       |
  366|       |void ServerContext::set_compression_algorithm(
  367|      0|    grpc_compression_algorithm algorithm) {
  368|      0|  compression_algorithm_ = algorithm;
  369|      0|  const char* algorithm_name = nullptr;
  370|      0|  if (!grpc_compression_algorithm_name(algorithm, &algorithm_name)) {
  371|      0|    gpr_log(GPR_ERROR, "Name for compression algorithm '%d' unknown.",
  372|      0|            algorithm);
  373|      0|    abort();
  374|      0|  }
  375|      0|  GPR_ASSERT(algorithm_name != nullptr);
  376|      0|  AddInitialMetadata(GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY, algorithm_name);
  377|      0|}
  378|       |
  379|      0|grpc::string ServerContext::peer() const {
  380|      0|  grpc::string peer;
  381|      0|  if (call_) {
  382|      0|    char* c_peer = grpc_call_get_peer(call_);
  383|      0|    peer = c_peer;
  384|      0|    gpr_free(c_peer);
  385|      0|  }
  386|      0|  return peer;
  387|      0|}
  388|       |
  389|      0|const struct census_context* ServerContext::census_context() const {
  390|      0|  return grpc_census_call_get_context(call_);
  391|      0|}
  392|       |
  393|       |void ServerContext::SetLoadReportingCosts(
  394|      0|    const std::vector<grpc::string>& cost_data) {
  395|      0|  if (call_ == nullptr) return;
  396|      0|  for (const auto& cost_datum : cost_data) {
  397|      0|    AddTrailingMetadata(GRPC_LB_COST_MD_KEY, cost_datum);
  398|      0|  }
  399|      0|}
  400|       |
  401|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/server_credentials.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpcpp/security/server_credentials_impl.h>
   20|       |
   21|       |namespace grpc_impl {
   22|       |
   23|      0|ServerCredentials::~ServerCredentials() {}
   24|       |
   25|       |}  // namespace grpc_impl

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/server/thread_pool_interface.h:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#ifndef GRPC_INTERNAL_CPP_THREAD_POOL_INTERFACE_H
   20|       |#define GRPC_INTERNAL_CPP_THREAD_POOL_INTERFACE_H
   21|       |
   22|       |#include <functional>
   23|       |
   24|       |namespace grpc {
   25|       |
   26|       |// A thread pool interface for running callbacks.
   27|       |class ThreadPoolInterface {
   28|       | public:
   29|      0|  virtual ~ThreadPoolInterface() {}
   30|       |
   31|       |  // Schedule the given callback for execution.
   32|       |  virtual void Add(const std::function<void()>& callback) = 0;
   33|       |};
   34|       |
   35|       |// Allows different codebases to use their own thread pool impls
   36|       |typedef ThreadPoolInterface* (*CreateThreadPoolFunc)(void);
   37|       |void SetCreateThreadPool(CreateThreadPoolFunc func);
   38|       |
   39|       |ThreadPoolInterface* CreateDefaultThreadPool();
   40|       |
   41|       |}  // namespace grpc
   42|       |
   43|       |#endif  // GRPC_INTERNAL_CPP_THREAD_POOL_INTERFACE_H

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/thread_manager/thread_manager.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2016 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include "src/cpp/thread_manager/thread_manager.h"
   20|       |
   21|       |#include <climits>
   22|       |#include <mutex>
   23|       |
   24|       |#include <grpc/support/log.h>
   25|       |#include "src/core/lib/gprpp/thd.h"
   26|       |#include "src/core/lib/iomgr/exec_ctx.h"
   27|       |
   28|       |namespace grpc {
   29|       |
   30|       |ThreadManager::WorkerThread::WorkerThread(ThreadManager* thd_mgr)
   31|      0|    : thd_mgr_(thd_mgr) {
   32|      0|  // Make thread creation exclusive with respect to its join happening in
   33|      0|  // ~WorkerThread().
   34|      0|  thd_ = grpc_core::Thread(
   35|      0|      "grpcpp_sync_server",
   36|      0|      [](void* th) { static_cast<ThreadManager::WorkerThread*>(th)->Run(); },
   37|      0|      this);
   38|      0|  thd_.Start();
   39|      0|}
   40|       |
   41|      0|void ThreadManager::WorkerThread::Run() {
   42|      0|  thd_mgr_->MainWorkLoop();
   43|      0|  thd_mgr_->MarkAsCompleted(this);
   44|      0|}
   45|       |
   46|      0|ThreadManager::WorkerThread::~WorkerThread() {
   47|      0|  // Don't join until the thread is fully constructed.
   48|      0|  thd_.Join();
   49|      0|}
   50|       |
   51|       |ThreadManager::ThreadManager(const char* name,
   52|       |                             grpc_resource_quota* resource_quota,
   53|       |                             int min_pollers, int max_pollers)
   54|       |    : shutdown_(false),
   55|       |      num_pollers_(0),
   56|       |      min_pollers_(min_pollers),
   57|       |      max_pollers_(max_pollers == -1 ? INT_MAX : max_pollers),
   58|       |      num_threads_(0),
   59|      0|      max_active_threads_sofar_(0) {
   60|      0|  resource_user_ = grpc_resource_user_create(resource_quota, name);
   61|      0|}
   62|       |
   63|      0|ThreadManager::~ThreadManager() {
   64|      0|  {
   65|      0|    grpc_core::MutexLock lock(&mu_);
   66|      0|    GPR_ASSERT(num_threads_ == 0);
   67|      0|  }
   68|      0|
   69|      0|  grpc_core::ExecCtx exec_ctx;  // grpc_resource_user_unref needs an exec_ctx
   70|      0|  grpc_resource_user_unref(resource_user_);
   71|      0|  CleanupCompletedThreads();
   72|      0|}
   73|       |
   74|      0|void ThreadManager::Wait() {
   75|      0|  grpc_core::MutexLock lock(&mu_);
   76|      0|  while (num_threads_ != 0) {
   77|      0|    shutdown_cv_.Wait(&mu_);
   78|      0|  }
   79|      0|}
   80|       |
   81|      0|void ThreadManager::Shutdown() {
   82|      0|  grpc_core::MutexLock lock(&mu_);
   83|      0|  shutdown_ = true;
   84|      0|}
   85|       |
   86|      0|bool ThreadManager::IsShutdown() {
   87|      0|  grpc_core::MutexLock lock(&mu_);
   88|      0|  return shutdown_;
   89|      0|}
   90|       |
   91|      0|int ThreadManager::GetMaxActiveThreadsSoFar() {
   92|      0|  grpc_core::MutexLock list_lock(&list_mu_);
   93|      0|  return max_active_threads_sofar_;
   94|      0|}
   95|       |
   96|      0|void ThreadManager::MarkAsCompleted(WorkerThread* thd) {
   97|      0|  {
   98|      0|    grpc_core::MutexLock list_lock(&list_mu_);
   99|      0|    completed_threads_.push_back(thd);
  100|      0|  }
  101|      0|
  102|      0|  {
  103|      0|    grpc_core::MutexLock lock(&mu_);
  104|      0|    num_threads_--;
  105|      0|    if (num_threads_ == 0) {
  106|      0|      shutdown_cv_.Signal();
  107|      0|    }
  108|      0|  }
  109|      0|
  110|      0|  // Give a thread back to the resource quota
  111|      0|  grpc_resource_user_free_threads(resource_user_, 1);
  112|      0|}
  113|       |
  114|      0|void ThreadManager::CleanupCompletedThreads() {
  115|      0|  std::list<WorkerThread*> completed_threads;
  116|      0|  {
  117|      0|    // swap out the completed threads list: allows other threads to clean up
  118|      0|    // more quickly
  119|      0|    grpc_core::MutexLock lock(&list_mu_);
  120|      0|    completed_threads.swap(completed_threads_);
  121|      0|  }
  122|      0|  for (auto thd : completed_threads) delete thd;
  123|      0|}
  124|       |
  125|      0|void ThreadManager::Initialize() {
  126|      0|  if (!grpc_resource_user_allocate_threads(resource_user_, min_pollers_)) {
  127|      0|    gpr_log(GPR_ERROR,
  128|      0|            "No thread quota available to even create the minimum required "
  129|      0|            "polling threads (i.e %d). Unable to start the thread manager",
  130|      0|            min_pollers_);
  131|      0|    abort();
  132|      0|  }
  133|      0|
  134|      0|  {
  135|      0|    grpc_core::MutexLock lock(&mu_);
  136|      0|    num_pollers_ = min_pollers_;
  137|      0|    num_threads_ = min_pollers_;
  138|      0|    max_active_threads_sofar_ = min_pollers_;
  139|      0|  }
  140|      0|
  141|      0|  for (int i = 0; i < min_pollers_; i++) {
  142|      0|    new WorkerThread(this);
  143|      0|  }
  144|      0|}
  145|       |
  146|      0|void ThreadManager::MainWorkLoop() {
  147|      0|  while (true) {
  148|      0|    void* tag;
  149|      0|    bool ok;
  150|      0|    WorkStatus work_status = PollForWork(&tag, &ok);
  151|      0|
  152|      0|    grpc_core::ReleasableMutexLock lock(&mu_);
  153|      0|    // Reduce the number of pollers by 1 and check what happened with the poll
  154|      0|    num_pollers_--;
  155|      0|    bool done = false;
  156|      0|    switch (work_status) {
  157|      0|      case TIMEOUT:
  158|      0|        // If we timed out and we have more pollers than we need (or we are
  159|      0|        // shutdown), finish this thread
  160|      0|        if (shutdown_ || num_pollers_ > max_pollers_) done = true;
  161|      0|        break;
  162|      0|      case SHUTDOWN:
  163|      0|        // If the thread manager is shutdown, finish this thread
  164|      0|        done = true;
  165|      0|        break;
  166|      0|      case WORK_FOUND:
  167|      0|        // If we got work and there are now insufficient pollers and there is
  168|      0|        // quota available to create a new thread, start a new poller thread
  169|      0|        bool resource_exhausted = false;
  170|      0|        if (!shutdown_ && num_pollers_ < min_pollers_) {
  171|      0|          if (grpc_resource_user_allocate_threads(resource_user_, 1)) {
  172|      0|            // We can allocate a new poller thread
  173|      0|            num_pollers_++;
  174|      0|            num_threads_++;
  175|      0|            if (num_threads_ > max_active_threads_sofar_) {
  176|      0|              max_active_threads_sofar_ = num_threads_;
  177|      0|            }
  178|      0|            // Drop lock before spawning thread to avoid contention
  179|      0|            lock.Unlock();
  180|      0|            new WorkerThread(this);
  181|      0|          } else if (num_pollers_ > 0) {
  182|      0|            // There is still at least some thread polling, so we can go on
  183|      0|            // even though we are below the number of pollers that we would
  184|      0|            // like to have (min_pollers_)
  185|      0|            lock.Unlock();
  186|      0|          } else {
  187|      0|            // There are no pollers to spare and we couldn't allocate
  188|      0|            // a new thread, so resources are exhausted!
  189|      0|            lock.Unlock();
  190|      0|            resource_exhausted = true;
  191|      0|          }
  192|      0|        } else {
  193|      0|          // There are a sufficient number of pollers available so we can do
  194|      0|          // the work and continue polling with our existing poller threads
  195|      0|          lock.Unlock();
  196|      0|        }
  197|      0|        // Lock is always released at this point - do the application work
  198|      0|        // or return resource exhausted if there is new work but we couldn't
  199|      0|        // get a thread in which to do it.
  200|      0|        DoWork(tag, ok, !resource_exhausted);
  201|      0|        // Take the lock again to check post conditions
  202|      0|        lock.Lock();
  203|      0|        // If we're shutdown, we should finish at this point.
  204|      0|        if (shutdown_) done = true;
  205|      0|        break;
  206|      0|    }
  207|      0|    // If we decided to finish the thread, break out of the while loop
  208|      0|    if (done) break;
  209|      0|
  210|      0|    // Otherwise go back to polling as long as it doesn't exceed max_pollers_
  211|      0|    //
  212|      0|    // **WARNING**:
  213|      0|    // There is a possibility of threads thrashing here (i.e excessive thread
  214|      0|    // shutdowns and creations than the ideal case). This happens if max_poller_
  215|      0|    // count is small and the rate of incoming requests is also small. In such
  216|      0|    // scenarios we can possibly configure max_pollers_ to a higher value and/or
  217|      0|    // increase the cq timeout.
  218|      0|    //
  219|      0|    // However, not doing this check here and unconditionally incrementing
  220|      0|    // num_pollers (and hoping that the system will eventually settle down) has
  221|      0|    // far worse consequences i.e huge number of threads getting created to the
  222|      0|    // point of thread-exhaustion. For example: if the incoming request rate is
  223|      0|    // very high, all the polling threads will return very quickly from
  224|      0|    // PollForWork() with WORK_FOUND. They all briefly decrement num_pollers_
  225|      0|    // counter thereby possibly - and briefly - making it go below min_pollers;
  226|      0|    // This will most likely result in the creation of a new poller since
  227|      0|    // num_pollers_ dipped below min_pollers_.
  228|      0|    //
  229|      0|    // Now, If we didn't do the max_poller_ check here, all these threads will
  230|      0|    // go back to doing PollForWork() and the whole cycle repeats (with a new
  231|      0|    // thread being added in each cycle). Once the total number of threads in
  232|      0|    // the system crosses a certain threshold (around ~1500), there is heavy
  233|      0|    // contention on mutexes (the mu_ here or the mutexes in gRPC core like the
  234|      0|    // pollset mutex) that makes DoWork() take longer to finish thereby causing
  235|      0|    // new poller threads to be created even faster. This results in a thread
  236|      0|    // avalanche.
  237|      0|    if (num_pollers_ < max_pollers_) {
  238|      0|      num_pollers_++;
  239|      0|    } else {
  240|      0|      break;
  241|      0|    }
  242|      0|  };
  243|      0|
  244|      0|  // This thread is exiting. Do some cleanup work i.e delete already completed
  245|      0|  // worker threads
  246|      0|  CleanupCompletedThreads();
  247|      0|
  248|      0|  // If we are here, either ThreadManager is shutting down or it already has
  249|      0|  // enough threads.
  250|      0|}
  251|       |
  252|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/util/byte_buffer_cc.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpc/byte_buffer.h>
   20|       |#include <grpc/byte_buffer_reader.h>
   21|       |#include <grpcpp/impl/grpc_library.h>
   22|       |#include <grpcpp/support/byte_buffer.h>
   23|       |
   24|       |namespace grpc {
   25|       |
   26|       |static internal::GrpcLibraryInitializer g_gli_initializer;
   27|       |
   28|      0|Status ByteBuffer::Dump(std::vector<Slice>* slices) const {
   29|      0|  slices->clear();
   30|      0|  if (!buffer_) {
   31|      0|    return Status(StatusCode::FAILED_PRECONDITION, "Buffer not initialized");
   32|      0|  }
   33|      0|  grpc_byte_buffer_reader reader;
   34|      0|  if (!grpc_byte_buffer_reader_init(&reader, buffer_)) {
   35|      0|    return Status(StatusCode::INTERNAL,
   36|      0|                  "Couldn't initialize byte buffer reader");
   37|      0|  }
   38|      0|  grpc_slice s;
   39|      0|  while (grpc_byte_buffer_reader_next(&reader, &s)) {
   40|      0|    slices->push_back(Slice(s, Slice::STEAL_REF));
   41|      0|  }
   42|      0|  grpc_byte_buffer_reader_destroy(&reader);
   43|      0|  return Status::OK;
   44|      0|}
   45|       |
   46|       |}  // namespace grpc

/Users/aafraneokese/Documents/Learn IoS Features/Functionality/Architecture /MVVM Example/LoginDemo/Pods/gRPC-C++/src/cpp/util/time_cc.cc:
    1|       |/*
    2|       | *
    3|       | * Copyright 2015 gRPC authors.
    4|       | *
    5|       | * Licensed under the Apache License, Version 2.0 (the "License");
    6|       | * you may not use this file except in compliance with the License.
    7|       | * You may obtain a copy of the License at
    8|       | *
    9|       | *     http://www.apache.org/licenses/LICENSE-2.0
   10|       | *
   11|       | * Unless required by applicable law or agreed to in writing, software
   12|       | * distributed under the License is distributed on an "AS IS" BASIS,
   13|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   14|       | * See the License for the specific language governing permissions and
   15|       | * limitations under the License.
   16|       | *
   17|       | */
   18|       |
   19|       |#include <grpc/support/time.h>
   20|       |#include <grpcpp/support/config.h>
   21|       |#include <grpcpp/support/time.h>
   22|       |
   23|       |using std::chrono::duration_cast;
   24|       |using std::chrono::high_resolution_clock;
   25|       |using std::chrono::nanoseconds;
   26|       |using std::chrono::seconds;
   27|       |using std::chrono::system_clock;
   28|       |
   29|       |namespace grpc {
   30|       |
   31|       |void Timepoint2Timespec(const system_clock::time_point& from,
   32|      0|                        gpr_timespec* to) {
   33|      0|  system_clock::duration deadline = from.time_since_epoch();
   34|      0|  seconds secs = duration_cast<seconds>(deadline);
   35|      0|  if (from == system_clock::time_point::max() ||
   36|      0|      secs.count() >= gpr_inf_future(GPR_CLOCK_REALTIME).tv_sec ||
   37|      0|      secs.count() < 0) {
   38|      0|    *to = gpr_inf_future(GPR_CLOCK_REALTIME);
   39|      0|    return;
   40|      0|  }
   41|      0|  nanoseconds nsecs = duration_cast<nanoseconds>(deadline - secs);
   42|      0|  to->tv_sec = static_cast<int64_t>(secs.count());
   43|      0|  to->tv_nsec = static_cast<int32_t>(nsecs.count());
   44|      0|  to->clock_type = GPR_CLOCK_REALTIME;
   45|      0|}
   46|       |
   47|       |void TimepointHR2Timespec(const high_resolution_clock::time_point& from,
   48|      0|                          gpr_timespec* to) {
   49|      0|  high_resolution_clock::duration deadline = from.time_since_epoch();
   50|      0|  seconds secs = duration_cast<seconds>(deadline);
   51|      0|  if (from == high_resolution_clock::time_point::max() ||
   52|      0|      secs.count() >= gpr_inf_future(GPR_CLOCK_REALTIME).tv_sec ||
   53|      0|      secs.count() < 0) {
   54|      0|    *to = gpr_inf_future(GPR_CLOCK_REALTIME);
   55|      0|    return;
   56|      0|  }
   57|      0|  nanoseconds nsecs = duration_cast<nanoseconds>(deadline - secs);
   58|      0|  to->tv_sec = static_cast<int64_t>(secs.count());
   59|      0|  to->tv_nsec = static_cast<int32_t>(nsecs.count());
   60|      0|  to->clock_type = GPR_CLOCK_REALTIME;
   61|      0|}
   62|       |
   63|      0|system_clock::time_point Timespec2Timepoint(gpr_timespec t) {
   64|      0|  if (gpr_time_cmp(t, gpr_inf_future(t.clock_type)) == 0) {
   65|      0|    return system_clock::time_point::max();
   66|      0|  }
   67|      0|  t = gpr_convert_clock_type(t, GPR_CLOCK_REALTIME);
   68|      0|  system_clock::time_point tp;
   69|      0|  tp += duration_cast<system_clock::time_point::duration>(seconds(t.tv_sec));
   70|      0|  tp +=
   71|      0|      duration_cast<system_clock::time_point::duration>(nanoseconds(t.tv_nsec));
   72|      0|  return tp;
   73|      0|}
   74|       |
   75|       |}  // namespace grpc

