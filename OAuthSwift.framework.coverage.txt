/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/Collection+OAuthSwift.swift:
    1|       |//
    2|       |//  Collection+OAuthSwift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by phimage on 02/10/16.
    6|       |//  Copyright © 2016 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Collection where Self.Iterator.Element == UInt8, Self.Index == Int {
   12|       |
   13|      0|    var toUInt32: UInt32 {
   14|      0|        assert(self.count > 3)
   15|      0|        // XXX optimize do the job only for the first one...
   16|      0|        return toUInt32Array()[0]
   17|      0|    }
   18|       |
   19|      0|    func toUInt32Array() -> [UInt32] {
   20|      0|        var result = [UInt32]()
   21|      0|        result.reserveCapacity(16)
   22|      0|        for idx in stride(from: self.startIndex, to: self.endIndex, by: MemoryLayout<UInt32>.size) {
   23|      0|            var val: UInt32 = 0
   24|      0|            val |= self.count > 3 ? UInt32(self[idx.advanced(by: 3)]) << 24 : 0
   25|      0|            val |= self.count > 2 ? UInt32(self[idx.advanced(by: 2)]) << 16 : 0
   26|      0|            val |= self.count > 1 ? UInt32(self[idx.advanced(by: 1)]) << 8  : 0
   27|      0|            //swiftlint:disable:next empty_count
   28|      0|            val |= self.count > 0 ? UInt32(self[idx]) : 0
   29|      0|            result.append(val)
   30|      0|        }
   31|      0|
   32|      0|        return result
   33|      0|    }
   34|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/Data+OAuthSwift.swift:
    1|       |//
    2|       |//  Data+OAuthSwift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 1/28/15.
    6|       |//  Copyright (c) 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Data {
   12|       |
   13|      0|    internal init(data: Data) {
   14|      0|        self.init()
   15|      0|        self.append(data)
   16|      0|    }
   17|       |
   18|      0|    internal mutating func append(_ bytes: [UInt8]) {
   19|      0|        self.append(bytes, count: bytes.count)
   20|      0|    }
   21|      0|    internal mutating func append(_ byte: UInt8) {
   22|      0|        append([byte])
   23|      0|    }
   24|      0|    internal mutating func append(_ byte: UInt16) {
   25|      0|        append(UInt8(byte >> 0 & 0xFF))
   26|      0|        append(UInt8(byte >> 8 & 0xFF))
   27|      0|    }
   28|      0|    internal  mutating func append(_ byte: UInt32) {
   29|      0|        append(UInt16(byte >>  0 & 0xFFFF))
   30|      0|        append(UInt16(byte >> 16 & 0xFFFF))
   31|      0|    }
   32|      0|    internal mutating func append(_  byte: UInt64) {
   33|      0|        append(UInt32(byte >>  0 & 0xFFFFFFFF))
   34|      0|        append(UInt32(byte >> 32 & 0xFFFFFFFF))
   35|      0|    }
   36|       |
   37|      0|    var bytes: [UInt8] {
   38|      0|        return Array(self)
   39|      0|        /* let count = self.count / MemoryLayout<UInt8>.size
   40|      0|         var bytesArray = [UInt8](repeating: 0, count: count)
   41|      0|        self.copyBytes(to:&bytesArray, count: count * MemoryLayout<UInt8>.size)
   42|      0|        return bytesArray*/
   43|      0|    }
   44|       |
   45|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/Dictionary+OAuthSwift.swift:
    1|       |//
    2|       |//  Dictionary+OAuthSwift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 6/21/14.
    6|       |//  Copyright (c) 2014 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Dictionary {
   12|       |
   13|      0|    func join(_ other: Dictionary) -> Dictionary {
   14|      0|        var joinedDictionary = Dictionary()
   15|      0|
   16|      0|        for (key, value) in self {
   17|      0|            joinedDictionary.updateValue(value, forKey: key)
   18|      0|        }
   19|      0|
   20|      0|        for (key, value) in other {
   21|      0|            joinedDictionary.updateValue(value, forKey: key)
   22|      0|        }
   23|      0|
   24|      0|        return joinedDictionary
   25|      0|    }
   26|       |
   27|      0|    var urlEncodedQuery: String {
   28|      0|        var parts = [String]()
   29|      0|
   30|      0|        for (key, value) in self {
   31|      0|            let keyString = "\(key)".urlEncoded
   32|      0|            let valueString = "\(value)".urlEncoded
   33|      0|            let query = "\(keyString)=\(valueString)"
   34|      0|            parts.append(query)
   35|      0|        }
   36|      0|
   37|      0|        return parts.joined(separator: "&")
   38|      0|    }
   39|       |
   40|      0|    mutating func merge<K, V>(_ dictionaries: Dictionary<K, V>...) {
   41|      0|        for dict in dictionaries {
   42|      0|            for (key, value) in dict {
   43|      0|                if let v = value as? Value, let k = key as? Key {
   44|      0|                    self.updateValue(v, forKey: k)
   45|      0|                }
   46|      0|            }
   47|      0|        }
   48|      0|    }
   49|       |
   50|      0|    func map<K: Hashable, V> (_ transform: (Key, Value) -> (K, V)) -> [K: V] {
   51|      0|        var results: [K: V] = [:]
   52|      0|        for k in self.keys {
   53|      0|            if let value = self[ k ] {
   54|      0|                let (u, w) = transform(k, value)
   55|      0|                results.updateValue(w, forKey: u)
   56|      0|            }
   57|      0|        }
   58|      0|        return results
   59|      0|    }
   60|       |}
   61|       |
   62|       |extension Dictionary {
   63|       |    @available(swift, introduced: 3.2, obsoleted: 4.0)
   64|      0|    public func filter(_ isIncluded: (Key, Value) throws -> Bool) rethrows -> [Key: Value] {
   65|      0|        var resultDictionary = [Key: Value](minimumCapacity: count)
   66|      0|        for (key, value) in self {
   67|      0|            if try isIncluded(key, value) {
   68|      0|                resultDictionary[key] = value
   69|      0|            }
   70|      0|        }
   71|      0|        return resultDictionary
   72|      0|    }
   73|       |}
   74|       |
   75|      0|func +=<K, V> (left: inout [K: V], right: [K: V]) { left.merge(right) }
   76|      0|func +<K, V> (left: [K: V], right: [K: V]) -> [K: V] { return left.join(right) }
   77|      0|func +=<K, V> (left: inout [K: V]?, right: [K: V]) {
   78|      0|    if left != nil { left?.merge(right) } else { left = right }
   79|      0|}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/HMAC.swift:
    1|       |//
    2|       |//  HMAC.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 1/28/15.
    6|       |//  Copyright (c) 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |open class HMAC {
   12|       |
   13|       |    let key: [UInt8] = []
   14|       |
   15|      0|    class internal func sha1(key: Data, message: Data) -> Data? {
   16|      0|        let blockSize = 64
   17|      0|        var key = key.bytes
   18|      0|        let message = message.bytes
   19|      0|
   20|      0|        if key.count > blockSize {
   21|      0|            key = SHA1(key).calculate()
   22|      0|        } else if key.count < blockSize { // padding
   23|      0|            key += [UInt8](repeating: 0, count: blockSize - key.count)
   24|      0|        }
   25|      0|
   26|      0|        var ipad = [UInt8](repeating: 0x36, count: blockSize)
   27|      0|        for idx in key.indices {
   28|      0|            ipad[idx] = key[idx] ^ ipad[idx]
   29|      0|        }
   30|      0|
   31|      0|        var opad = [UInt8](repeating: 0x5c, count: blockSize)
   32|      0|        for idx in key.indices {
   33|      0|            opad[idx] = key[idx] ^ opad[idx]
   34|      0|        }
   35|      0|
   36|      0|        let ipadAndMessageHash = SHA1(ipad + message).calculate()
   37|      0|        let mac = SHA1(opad + ipadAndMessageHash).calculate()
   38|      0|
   39|      0|        return Data(bytes: UnsafePointer<UInt8>(mac), count: mac.count)
   40|      0|
   41|      0|    }
   42|       |
   43|       |}
   44|       |
   45|       |extension HMAC: OAuthSwiftSignatureDelegate {
   46|      0|    public static func sign(hashMethod: OAuthSwiftHashMethod, key: Data, message: Data) -> Data? {
   47|      0|        switch hashMethod {
   48|      0|        case .sha1:
   49|      0|            return sha1(key: key, message: message)
   50|      0|        case .none:
   51|      0|            assertionFailure("Must no sign with none")
   52|      0|            return nil
   53|      0|        }
   54|      0|    }
   55|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/Int+OAuthSwift.swift:
    1|       |//
    2|       |//  Int+OAuthSwift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 1/28/15.
    6|       |//  Copyright (c) 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Int {
   12|      0|    public func bytes(_ totalBytes: Int = MemoryLayout<Int>.size) -> [UInt8] {
   13|      0|        return arrayOfBytes(self, length: totalBytes)
   14|      0|    }
   15|       |}
   16|       |
   17|      0|private func arrayOfBytes<T>(_ value: T, length: Int? = nil) -> [UInt8] {
   18|      0|    let totalBytes = length ?? MemoryLayout<T>.size
   19|      0|
   20|      0|    let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
   21|      0|    valuePointer.pointee = value
   22|      0|
   23|      0|    let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
   24|      0|    var bytes = [UInt8](repeating: 0, count: totalBytes)
   25|      0|    for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
   26|      0|        bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
   27|      0|    }
   28|      0|
   29|      0|    valuePointer.deinitialize(count: 1)
   30|      0|    valuePointer.deallocate()
   31|      0|
   32|      0|    return bytes
   33|      0|}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/NSError+OAuthSwift.swift:
    1|       |//
    2|       |//  NSError+OAuthSwift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Goessler, Florian on 04/04/16.
    6|       |//  Copyright © 2016 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public extension NSError {
   12|       |
   13|       |    /// Checks the headers contained in the userInfo whether this error was caused by an 
   14|       |    /// expired/invalid access token.
   15|       |    ///
   16|       |    /// Criteria for invalid token error: WWW-Authenticate header contains a field "error" with
   17|       |    /// value "invalid_token".
   18|       |    ///
   19|       |    /// Also implements a special handling for the Facebook API, which indicates invalid tokens in a 
   20|       |    /// different manner. See https://developers.facebook.com/docs/graph-api/using-graph-api#errors
   21|      0|	public var isExpiredToken: Bool {
   22|      0|        guard self.domain == NSURLErrorDomain else {
   23|      0|            return false
   24|      0|        }
   25|      0|		if self.code == 401 {
   26|      0|			if let reponseHeaders = self.userInfo["Response-Headers"] as? [String: String],
   27|      0|				let authenticateHeader = reponseHeaders["WWW-Authenticate"] ?? reponseHeaders["Www-Authenticate"] {
   28|      0|				let headerDictionary = authenticateHeader.headerDictionary
   29|      0|				if let error = headerDictionary["error"], error == "invalid_token" || error == "expired_token" || error == "\"invalid_token\"" {
   30|      0|					return true
   31|      0|				}
   32|      0|			}
   33|      0|            if let body = self.userInfo["Response-Body"] as? String,
   34|      0|                let bodyData = body.data(using: OAuthSwiftDataEncoding),
   35|      0|                let json = try? JSONSerialization.jsonObject(with: bodyData, options: []),
   36|      0|                let jsonDic = json as? [String: AnyObject] {
   37|      0|                if let error = jsonDic["error"] as? String, error == "invalid_token" || error == "expired_token" || error == "\"invalid_token\"" {
   38|      0|                    return true
   39|      0|                }
   40|      0|                if let errors = jsonDic["errors"] as? [[String: AnyObject]] {
   41|      0|                    for error in errors {
   42|      0|                        if let errorType = error["errorType"] as? String, errorType == "invalid_token" {
   43|      0|                            return true
   44|      0|                        }
   45|      0|                    }
   46|      0|                }
   47|      0|            }
   48|      0|		}
   49|      0|
   50|      0|        // Detect access token expiration errors from facebook
   51|      0|        // Docu: https://developers.facebook.com/docs/graph-api/using-graph-api#errors
   52|      0|        if self.code == 400 {
   53|      0|            if let urlString = self.userInfo[NSURLErrorFailingURLErrorKey] as? String, urlString.contains("graph.facebook.com") {
   54|      0|                if let body = self.userInfo["Response-Body"] as? String,
   55|      0|                    let bodyData = body.data(using: OAuthSwiftDataEncoding),
   56|      0|                    let json = try? JSONSerialization.jsonObject(with: bodyData, options: []),
   57|      0|                    let jsonDic = json as? [String: AnyObject] {
   58|      0|                    let errorCode = jsonDic["error"]?["code"] as? Int
   59|      0|                    let errorSubCode = jsonDic["error"]?["error_subcode"] as? Int
   60|      0|                    if (errorCode == 102 && errorSubCode == nil) || errorSubCode == 463 || errorSubCode == 467 {
   61|      0|                        return true
   62|      0|                    }
   63|      0|                }
   64|      0|            }
   65|      0|        }
   66|      0|
   67|      0|		return false
   68|      0|	}
   69|       |
   70|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuth1Swift.swift:
    1|       |//
    2|       |//  OAuth1Swift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 6/22/14.
    6|       |//  Copyright (c) 2014 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |open class OAuth1Swift: OAuthSwift {
   12|       |
   13|       |    /// If your oauth provider doesn't provide `oauth_verifier`
   14|       |    /// set this value to true (default: false)
   15|       |    open var allowMissingOAuthVerifier: Bool = false
   16|       |
   17|       |    /// Optionally add callback URL to authorize Url (default: false)
   18|       |    open var addCallbackURLToAuthorizeURL: Bool = false
   19|       |
   20|       |    var consumerKey: String
   21|       |    var consumerSecret: String
   22|       |    var requestTokenUrl: String
   23|       |    var authorizeUrl: String
   24|       |    var accessTokenUrl: String
   25|       |
   26|       |    // MARK: init
   27|      0|    public init(consumerKey: String, consumerSecret: String, requestTokenUrl: URLConvertible, authorizeUrl: URLConvertible, accessTokenUrl: URLConvertible) {
   28|      0|        self.consumerKey = consumerKey
   29|      0|        self.consumerSecret = consumerSecret
   30|      0|        self.requestTokenUrl = requestTokenUrl.string
   31|      0|        self.authorizeUrl = authorizeUrl.string
   32|      0|        self.accessTokenUrl = accessTokenUrl.string
   33|      0|        super.init(consumerKey: consumerKey, consumerSecret: consumerSecret)
   34|      0|        self.client.credential.version = .oauth1
   35|      0|    }
   36|       |
   37|      0|    public convenience override init(consumerKey: String, consumerSecret: String) {
   38|      0|        self.init(consumerKey: consumerKey, consumerSecret: consumerSecret, requestTokenUrl: "", authorizeUrl: "", accessTokenUrl: "")
   39|      0|    }
   40|       |
   41|      0|    public convenience init?(parameters: ConfigParameters) {
   42|      0|        guard let consumerKey = parameters["consumerKey"], let consumerSecret = parameters["consumerSecret"],
   43|      0|            let requestTokenUrl = parameters["requestTokenUrl"], let authorizeUrl = parameters["authorizeUrl"], let accessTokenUrl = parameters["accessTokenUrl"] else {
   44|      0|            return nil
   45|      0|        }
   46|      0|        self.init(consumerKey: consumerKey, consumerSecret: consumerSecret,
   47|      0|          requestTokenUrl: requestTokenUrl,
   48|      0|          authorizeUrl: authorizeUrl,
   49|      0|          accessTokenUrl: accessTokenUrl)
   50|      0|    }
   51|       |
   52|      0|    open var parameters: ConfigParameters {
   53|      0|        return [
   54|      0|            "consumerKey": consumerKey,
   55|      0|            "consumerSecret": consumerSecret,
   56|      0|            "requestTokenUrl": requestTokenUrl,
   57|      0|            "authorizeUrl": authorizeUrl,
   58|      0|            "accessTokenUrl": accessTokenUrl
   59|      0|        ]
   60|      0|    }
   61|       |
   62|       |    // MARK: functions
   63|       |    // 0. Start
   64|       |    @discardableResult
   65|      0|    open func authorize(withCallbackURL url: URLConvertible, headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: FailureHandler?) -> OAuthSwiftRequestHandle? {
   66|      0|        guard let callbackURL = url.url else {
   67|      0|            failure?(OAuthSwiftError.encodingError(urlString: url.string))
   68|      0|            return nil
   69|      0|        }
   70|      0|        self.postOAuthRequestToken(callbackURL: callbackURL, headers: headers, success: { [unowned self] credential, _, _ in
   71|      0|
   72|      0|            self.observeCallback { [weak self] url in
   73|      0|                guard let this = self else { OAuthSwift.retainError(failure); return }
   74|      0|                var responseParameters = [String: String]()
   75|      0|                if let query = url.query {
   76|      0|                    responseParameters += query.parametersFromQueryString
   77|      0|                }
   78|      0|                if let fragment = url.fragment, !fragment.isEmpty {
   79|      0|                    responseParameters += fragment.parametersFromQueryString
   80|      0|                }
   81|      0|                if let token = responseParameters["token"] {
   82|      0|                    responseParameters["oauth_token"] = token
   83|      0|                }
   84|      0|
   85|      0|                if let token = responseParameters["oauth_token"], !token.isEmpty {
   86|      0|                    this.client.credential.oauthToken = token.safeStringByRemovingPercentEncoding
   87|      0|                    if let oauth_verifier = responseParameters["oauth_verifier"] {
   88|      0|                        this.client.credential.oauthVerifier = oauth_verifier.safeStringByRemovingPercentEncoding
   89|      0|                    } else {
   90|      0|                        if !this.allowMissingOAuthVerifier {
   91|      0|                            failure?(OAuthSwiftError.configurationError(message: "Missing oauth_verifier. Maybe use allowMissingOAuthVerifier=true"))
   92|      0|                            return
   93|      0|                        }
   94|      0|                    }
   95|      0|                    this.postOAuthAccessTokenWithRequestToken(success: success, failure: failure)
   96|      0|                } else {
   97|      0|                    failure?(OAuthSwiftError.missingToken)
   98|      0|                    return
   99|      0|                }
  100|      0|            }
  101|      0|            // 2. Authorize
  102|      0|            if let token = credential.oauthToken.urlQueryEncoded {
  103|      0|                var urlString = self.authorizeUrl + (self.authorizeUrl.contains("?") ? "&" : "?")
  104|      0|                urlString += "oauth_token=\(token)"
  105|      0|                if self.addCallbackURLToAuthorizeURL {
  106|      0|                    urlString += "&oauth_callback=\(callbackURL.absoluteString)"
  107|      0|                }
  108|      0|                if let queryURL = URL(string: urlString) {
  109|      0|                    self.authorizeURLHandler.handle(queryURL)
  110|      0|                } else {
  111|      0|                    failure?(OAuthSwiftError.encodingError(urlString: urlString))
  112|      0|                }
  113|      0|            } else {
  114|      0|                failure?(OAuthSwiftError.encodingError(urlString: credential.oauthToken)) //TODO specific error
  115|      0|            }
  116|      0|
  117|      0|        }, failure: failure)
  118|      0|
  119|      0|        return self
  120|      0|    }
  121|       |
  122|       |    // 1. Request token
  123|      0|    func postOAuthRequestToken(callbackURL: URL, headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: FailureHandler?) {
  124|      0|        var parameters = [String: Any]()
  125|      0|        parameters["oauth_callback"] = callbackURL.absoluteString
  126|      0|
  127|      0|        if let handle = self.client.post(
  128|      0|            self.requestTokenUrl, parameters: parameters, headers: headers,
  129|      0|            success: { [weak self] response in
  130|      0|                guard let this = self else { OAuthSwift.retainError(failure); return }
  131|      0|                let parameters = response.string?.parametersFromQueryString ?? [:]
  132|      0|                if let oauthToken = parameters["oauth_token"] {
  133|      0|                    this.client.credential.oauthToken = oauthToken.safeStringByRemovingPercentEncoding
  134|      0|                }
  135|      0|                if let oauthTokenSecret=parameters["oauth_token_secret"] {
  136|      0|                    this.client.credential.oauthTokenSecret = oauthTokenSecret.safeStringByRemovingPercentEncoding
  137|      0|                }
  138|      0|                success(this.client.credential, response, parameters)
  139|      0|            }, failure: failure
  140|      0|            ) {
  141|      0|            self.putHandle(handle, withKey: UUID().uuidString)
  142|      0|        }
  143|      0|    }
  144|       |
  145|       |    // 3. Get Access token
  146|      0|    func postOAuthAccessTokenWithRequestToken(success: @escaping TokenSuccessHandler, failure: FailureHandler?) {
  147|      0|        var parameters = [String: Any]()
  148|      0|        parameters["oauth_token"] = self.client.credential.oauthToken
  149|      0|        if !self.allowMissingOAuthVerifier {
  150|      0|            parameters["oauth_verifier"] = self.client.credential.oauthVerifier
  151|      0|        }
  152|      0|
  153|      0|        if let handle = self.client.post(
  154|      0|            self.accessTokenUrl, parameters: parameters,
  155|      0|            success: { [weak self] response in
  156|      0|                guard let this = self else { OAuthSwift.retainError(failure); return }
  157|      0|                let parameters = response.string?.parametersFromQueryString ?? [:]
  158|      0|                if let oauthToken = parameters["oauth_token"] {
  159|      0|                    this.client.credential.oauthToken = oauthToken.safeStringByRemovingPercentEncoding
  160|      0|                }
  161|      0|                if let oauthTokenSecret = parameters["oauth_token_secret"] {
  162|      0|                    this.client.credential.oauthTokenSecret = oauthTokenSecret.safeStringByRemovingPercentEncoding
  163|      0|                }
  164|      0|                success(this.client.credential, response, parameters)
  165|      0|            }, failure: failure
  166|      0|            ) {
  167|      0|            self.putHandle(handle, withKey: UUID().uuidString)
  168|      0|        }
  169|      0|    }
  170|       |
  171|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuth2Swift.swift:
    1|       |//
    2|       |//  OAuth2Swift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 6/22/14.
    6|       |//  Copyright (c) 2014 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |open class OAuth2Swift: OAuthSwift {
   12|       |
   13|       |    /// If your oauth provider need to use basic authentification
   14|       |    /// set value to true (default: false)
   15|       |    open var accessTokenBasicAuthentification = false
   16|       |
   17|       |    /// Set to true to deactivate state check. Be careful of CSRF
   18|       |    open var allowMissingStateCheck: Bool = false
   19|       |
   20|       |    /// Encode callback url, some services require it to be encoded.
   21|       |    open var encodeCallbackURL: Bool = false
   22|       |
   23|       |    /// Encode callback url inside the query, this is second encoding phase when the entire query string gets assembled. In rare 
   24|       |    /// cases, like with Imgur, the url needs to be encoded only once and this value needs to be set to `false`.
   25|       |    open var encodeCallbackURLQuery: Bool = true
   26|       |
   27|       |    var consumerKey: String
   28|       |    var consumerSecret: String
   29|       |    var authorizeUrl: String
   30|       |    var accessTokenUrl: String?
   31|       |    var responseType: String
   32|       |    var contentType: String?
   33|       |    // RFC7636 PKCE
   34|       |    var codeVerifier: String?
   35|       |
   36|       |    // MARK: init
   37|      0|    public convenience init(consumerKey: String, consumerSecret: String, authorizeUrl: URLConvertible, accessTokenUrl: URLConvertible, responseType: String) {
   38|      0|        self.init(consumerKey: consumerKey, consumerSecret: consumerSecret, authorizeUrl: authorizeUrl, responseType: responseType)
   39|      0|        self.accessTokenUrl = accessTokenUrl.string
   40|      0|    }
   41|       |
   42|      0|    public convenience init(consumerKey: String, consumerSecret: String, authorizeUrl: URLConvertible, accessTokenUrl: URLConvertible, responseType: String, contentType: String) {
   43|      0|        self.init(consumerKey: consumerKey, consumerSecret: consumerSecret, authorizeUrl: authorizeUrl, responseType: responseType)
   44|      0|        self.accessTokenUrl = accessTokenUrl.string
   45|      0|        self.contentType = contentType
   46|      0|    }
   47|       |
   48|      0|    public init(consumerKey: String, consumerSecret: String, authorizeUrl: URLConvertible, responseType: String) {
   49|      0|        self.consumerKey = consumerKey
   50|      0|        self.consumerSecret = consumerSecret
   51|      0|        self.authorizeUrl = authorizeUrl.string
   52|      0|        self.responseType = responseType
   53|      0|        super.init(consumerKey: consumerKey, consumerSecret: consumerSecret)
   54|      0|        self.client.credential.version = .oauth2
   55|      0|    }
   56|       |
   57|      0|    public convenience init?(parameters: ConfigParameters) {
   58|      0|        guard let consumerKey = parameters["consumerKey"], let consumerSecret = parameters["consumerSecret"],
   59|      0|              let responseType = parameters["responseType"], let authorizeUrl = parameters["authorizeUrl"] else {
   60|      0|            return nil
   61|      0|        }
   62|      0|        if let accessTokenUrl = parameters["accessTokenUrl"] {
   63|      0|            self.init(consumerKey: consumerKey, consumerSecret: consumerSecret,
   64|      0|                authorizeUrl: authorizeUrl, accessTokenUrl: accessTokenUrl, responseType: responseType)
   65|      0|        } else {
   66|      0|            self.init(consumerKey: consumerKey, consumerSecret: consumerSecret,
   67|      0|                authorizeUrl: authorizeUrl, responseType: responseType)
   68|      0|        }
   69|      0|    }
   70|       |
   71|      0|    open var parameters: ConfigParameters {
   72|      0|        return [
   73|      0|            "consumerKey": consumerKey,
   74|      0|            "consumerSecret": consumerSecret,
   75|      0|            "authorizeUrl": authorizeUrl,
   76|      0|            "accessTokenUrl": accessTokenUrl ?? "",
   77|      0|            "responseType": responseType
   78|      0|        ]
   79|      0|    }
   80|       |
   81|       |    // MARK: functions
   82|       |    @discardableResult
   83|      0|    open func authorize(withCallbackURL callbackURL: URLConvertible?, scope: String, state: String, parameters: Parameters = [:], headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: FailureHandler?) -> OAuthSwiftRequestHandle? {
   84|      0|        if let url = callbackURL, url.url == nil {
   85|      0|            failure?(OAuthSwiftError.encodingError(urlString: url.string))
   86|      0|            return nil
   87|      0|        }
   88|      0|        self.observeCallback { [weak self] url in
   89|      0|            guard let this = self else {
   90|      0|                OAuthSwift.retainError(failure)
   91|      0|                return
   92|      0|            }
   93|      0|            var responseParameters = [String: String]()
   94|      0|            if let query = url.query {
   95|      0|                responseParameters += query.parametersFromQueryString
   96|      0|            }
   97|      0|            if let fragment = url.fragment, !fragment.isEmpty {
   98|      0|                responseParameters += fragment.parametersFromQueryString
   99|      0|            }
  100|      0|            if let accessToken = responseParameters["access_token"] {
  101|      0|                this.client.credential.oauthToken = accessToken.safeStringByRemovingPercentEncoding
  102|      0|                if let expiresIn: String = responseParameters["expires_in"], let offset = Double(expiresIn) {
  103|      0|                    this.client.credential.oauthTokenExpiresAt = Date(timeInterval: offset, since: Date())
  104|      0|                }
  105|      0|                success(this.client.credential, nil, responseParameters)
  106|      0|            } else if let code = responseParameters["code"] {
  107|      0|                if !this.allowMissingStateCheck {
  108|      0|                    guard let responseState = responseParameters["state"] else {
  109|      0|                        failure?(OAuthSwiftError.missingState)
  110|      0|                        return
  111|      0|                    }
  112|      0|                    if responseState != state {
  113|      0|                        failure?(OAuthSwiftError.stateNotEqual(state: state, responseState: responseState))
  114|      0|                        return
  115|      0|                    }
  116|      0|                }
  117|      0|                let callbackURLEncoded: URL?
  118|      0|                if let callbackURL = callbackURL {
  119|      0|                    callbackURLEncoded = callbackURL.encodedURL // XXX do not known why to re-encode, maybe if string only?
  120|      0|                } else {
  121|      0|                    callbackURLEncoded = nil
  122|      0|                }
  123|      0|                if let handle = this.postOAuthAccessTokenWithRequestToken(
  124|      0|                    byCode: code.safeStringByRemovingPercentEncoding,
  125|      0|                    callbackURL: callbackURLEncoded, headers: headers, success: success, failure: failure) {
  126|      0|                    this.putHandle(handle, withKey: UUID().uuidString)
  127|      0|                }
  128|      0|            } else if let error = responseParameters["error"] {
  129|      0|                let description = responseParameters["error_description"] ?? ""
  130|      0|                let message = NSLocalizedString(error, comment: description)
  131|      0|                failure?(OAuthSwiftError.serverError(message: message))
  132|      0|            } else {
  133|      0|                let message = "No access_token, no code and no error provided by server"
  134|      0|                failure?(OAuthSwiftError.serverError(message: message))
  135|      0|            }
  136|      0|        }
  137|      0|
  138|      0|        var queryErrorString = ""
  139|      0|        let encodeError: (String, String) -> Void = { name, value in
  140|      0|            if let newQuery = queryErrorString.urlQueryByAppending(parameter: name, value: value, encode: false) {
  141|      0|                queryErrorString = newQuery
  142|      0|            }
  143|      0|        }
  144|      0|
  145|      0|        var queryString: String? = ""
  146|      0|        queryString = queryString?.urlQueryByAppending(parameter: "client_id", value: self.consumerKey, encodeError)
  147|      0|        if let callbackURL = callbackURL {
  148|      0|            let value = self.encodeCallbackURL ? callbackURL.string.urlEncoded : callbackURL.string
  149|      0|            queryString = queryString?.urlQueryByAppending(parameter: "redirect_uri", value: value, encode: self.encodeCallbackURLQuery, encodeError)
  150|      0|        }
  151|      0|        queryString = queryString?.urlQueryByAppending(parameter: "response_type", value: self.responseType, encodeError)
  152|      0|        queryString = queryString?.urlQueryByAppending(parameter: "scope", value: scope, encodeError)
  153|      0|        queryString = queryString?.urlQueryByAppending(parameter: "state", value: state, encodeError)
  154|      0|
  155|      0|        for (name, value) in parameters {
  156|      0|            queryString = queryString?.urlQueryByAppending(parameter: name, value: "\(value)", encodeError)
  157|      0|        }
  158|      0|
  159|      0|        if let queryString = queryString {
  160|      0|            let urlString = self.authorizeUrl.urlByAppending(query: queryString)
  161|      0|            if let url: URL = URL(string: urlString) {
  162|      0|                self.authorizeURLHandler.handle(url)
  163|      0|                return self
  164|      0|            } else {
  165|      0|                failure?(OAuthSwiftError.encodingError(urlString: urlString))
  166|      0|            }
  167|      0|        } else {
  168|      0|            let urlString = self.authorizeUrl.urlByAppending(query: queryErrorString)
  169|      0|            failure?(OAuthSwiftError.encodingError(urlString: urlString))
  170|      0|        }
  171|      0|        self.cancel() // ie. remove the observer.
  172|      0|        return nil
  173|      0|    }
  174|       |
  175|      0|    open func postOAuthAccessTokenWithRequestToken(byCode code: String, callbackURL: URL?, headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: FailureHandler?) -> OAuthSwiftRequestHandle? {
  176|      0|        var parameters = OAuthSwift.Parameters()
  177|      0|        parameters["client_id"] = self.consumerKey
  178|      0|        parameters["client_secret"] = self.consumerSecret
  179|      0|        parameters["code"] = code
  180|      0|        parameters["grant_type"] = "authorization_code"
  181|      0|
  182|      0|        // PKCE - extra parameter
  183|      0|        if let codeVerifier = self.codeVerifier {
  184|      0|            parameters["code_verifier"] = codeVerifier
  185|      0|        }
  186|      0|
  187|      0|        if let callbackURL = callbackURL {
  188|      0|            parameters["redirect_uri"] = callbackURL.absoluteString.safeStringByRemovingPercentEncoding
  189|      0|        }
  190|      0|
  191|      0|        return requestOAuthAccessToken(withParameters: parameters, headers: headers, success: success, failure: failure)
  192|      0|    }
  193|       |
  194|       |    @discardableResult
  195|      0|    open func renewAccessToken(withRefreshToken refreshToken: String, parameters: OAuthSwift.Parameters? = nil, headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: FailureHandler?) -> OAuthSwiftRequestHandle? {
  196|      0|        var parameters = parameters ?? OAuthSwift.Parameters()
  197|      0|        parameters["client_id"] = self.consumerKey
  198|      0|        parameters["client_secret"] = self.consumerSecret
  199|      0|        parameters["refresh_token"] = refreshToken
  200|      0|        parameters["grant_type"] = "refresh_token"
  201|      0|
  202|      0|        return requestOAuthAccessToken(withParameters: parameters, headers: headers, success: success, failure: failure)
  203|      0|    }
  204|       |
  205|      0|    fileprivate func requestOAuthAccessToken(withParameters parameters: OAuthSwift.Parameters, headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: FailureHandler?) -> OAuthSwiftRequestHandle? {
  206|      0|        let successHandler: OAuthSwiftHTTPRequest.SuccessHandler = { [weak self] response in
  207|      0|            guard let this = self else {
  208|      0|                OAuthSwift.retainError(failure)
  209|      0|                return
  210|      0|            }
  211|      0|            let responseJSON: Any? = try? response.jsonObject(options: .mutableContainers)
  212|      0|
  213|      0|            let responseParameters: OAuthSwift.Parameters
  214|      0|
  215|      0|            if let jsonDico = responseJSON as? [String: Any] {
  216|      0|                responseParameters = jsonDico
  217|      0|            } else {
  218|      0|                responseParameters = response.string?.parametersFromQueryString ?? [:]
  219|      0|            }
  220|      0|
  221|      0|            guard let accessToken = responseParameters["access_token"] as? String else {
  222|      0|                let message = NSLocalizedString("Could not get Access Token", comment: "Due to an error in the OAuth2 process, we couldn't get a valid token.")
  223|      0|                failure?(OAuthSwiftError.serverError(message: message))
  224|      0|                return
  225|      0|            }
  226|      0|
  227|      0|            if let refreshToken = responseParameters["refresh_token"] as? String {
  228|      0|                this.client.credential.oauthRefreshToken = refreshToken.safeStringByRemovingPercentEncoding
  229|      0|            }
  230|      0|
  231|      0|            if let expiresIn = responseParameters["expires_in"] as? String, let offset = Double(expiresIn) {
  232|      0|                this.client.credential.oauthTokenExpiresAt = Date(timeInterval: offset, since: Date())
  233|      0|            } else if let expiresIn = responseParameters["expires_in"] as? Double {
  234|      0|                this.client.credential.oauthTokenExpiresAt = Date(timeInterval: expiresIn, since: Date())
  235|      0|            }
  236|      0|
  237|      0|            this.client.credential.oauthToken = accessToken.safeStringByRemovingPercentEncoding
  238|      0|            success(this.client.credential, response, responseParameters)
  239|      0|        }
  240|      0|
  241|      0|        guard let accessTokenUrl = accessTokenUrl else {
  242|      0|            let message = NSLocalizedString("access token url not defined", comment: "access token url not defined with code type auth")
  243|      0|            failure?(OAuthSwiftError.configurationError(message: message))
  244|      0|            return nil
  245|      0|        }
  246|      0|
  247|      0|        if self.contentType == "multipart/form-data" {
  248|      0|            // Request new access token by disabling check on current token expiration. This is safe because the implementation wants the user to retrieve a new token.
  249|      0|            return self.client.postMultiPartRequest(accessTokenUrl, method: .POST, parameters: parameters, headers: headers, checkTokenExpiration: false, success: successHandler, failure: failure)
  250|      0|        } else {
  251|      0|            // special headers
  252|      0|            var finalHeaders: OAuthSwift.Headers? = headers
  253|      0|            if accessTokenBasicAuthentification {
  254|      0|
  255|      0|                let authentification = "\(self.consumerKey):\(self.consumerSecret)".data(using: String.Encoding.utf8)
  256|      0|                if let base64Encoded = authentification?.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0)) {
  257|      0|                    finalHeaders += ["Authorization": "Basic \(base64Encoded)"] as OAuthSwift.Headers
  258|      0|                }
  259|      0|            }
  260|      0|
  261|      0|            // Request new access token by disabling check on current token expiration. This is safe because the implementation wants the user to retrieve a new token.
  262|      0|            return self.client.request(accessTokenUrl, method: .POST, parameters: parameters, headers: finalHeaders, checkTokenExpiration: false, success: successHandler, failure: failure)
  263|      0|        }
  264|      0|    }
  265|       |
  266|       |    /**
  267|       |     Convenience method to start a request that must be authorized with the previously retrieved access token.
  268|       |     Since OAuth 2 requires support for the access token refresh mechanism, this method will take care to automatically
  269|       |     refresh the token if needed such that the developer only has to be concerned about the outcome of the request.
  270|       |     
  271|       |     - parameter url:            The url for the request.
  272|       |     - parameter method:         The HTTP method to use.
  273|       |     - parameter parameters:     The request's parameters.
  274|       |     - parameter headers:        The request's headers.
  275|       |     - parameter renewHeaders:   The request's headers if renewing. If nil, the `headers`` are used when renewing.
  276|       |     - parameter body:           The request's HTTP body.
  277|       |     - parameter onTokenRenewal: Optional callback triggered in case the access token renewal was required in order to properly authorize the request.
  278|       |     - parameter success:        The success block. Takes the successfull response and data as parameter.
  279|       |     - parameter failure:        The failure block. Takes the error as parameter.
  280|       |     */
  281|       |    @discardableResult
  282|      0|    open func startAuthorizedRequest(_ url: URLConvertible, method: OAuthSwiftHTTPRequest.Method, parameters: OAuthSwift.Parameters, headers: OAuthSwift.Headers? = nil, renewHeaders: OAuthSwift.Headers? = nil, body: Data? = nil, onTokenRenewal: TokenRenewedHandler? = nil, success: @escaping OAuthSwiftHTTPRequest.SuccessHandler, failure: @escaping OAuthSwiftHTTPRequest.FailureHandler) -> OAuthSwiftRequestHandle? {
  283|      0|        // build request
  284|      0|        return self.client.request(url, method: method, parameters: parameters, headers: headers, body: body, success: success) { (error) in
  285|      0|            switch error {
  286|      0|
  287|      0|            case OAuthSwiftError.tokenExpired:
  288|      0|                _ = self.renewAccessToken(withRefreshToken: self.client.credential.oauthRefreshToken, headers: renewHeaders ?? headers, success: { (credential, _, _) in
  289|      0|                    // Ommit response parameters so they don't override the original ones
  290|      0|                    // We have successfully renewed the access token.
  291|      0|
  292|      0|                    // If provided, fire the onRenewal closure
  293|      0|                    if let renewalCallBack = onTokenRenewal {
  294|      0|                        renewalCallBack(credential)
  295|      0|                    }
  296|      0|
  297|      0|                    // Reauthorize the request again, this time with a brand new access token ready to be used.
  298|      0|                    _ = self.startAuthorizedRequest(url, method: method, parameters: parameters, headers: headers, body: body, onTokenRenewal: onTokenRenewal, success: success, failure: failure)
  299|      0|                }, failure: failure)
  300|      0|            default:
  301|      0|                failure(error)
  302|      0|            }
  303|      0|        }
  304|      0|    }
  305|       |
  306|       |	// OAuth 2.0 Specification: https://tools.ietf.org/html/draft-ietf-oauth-v2-13#section-4.3
  307|       |    @discardableResult
  308|      0|    open func authorize(username: String, password: String, scope: String?, headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: @escaping OAuthSwiftHTTPRequest.FailureHandler) -> OAuthSwiftRequestHandle? {
  309|      0|
  310|      0|        var parameters = OAuthSwift.Parameters()
  311|      0|        parameters["client_id"] = self.consumerKey
  312|      0|        parameters["client_secret"] = self.consumerSecret
  313|      0|        parameters["username"] = username
  314|      0|        parameters["password"] = password
  315|      0|        parameters["grant_type"] = "password"
  316|      0|
  317|      0|        if let scope = scope {
  318|      0|            parameters["scope"] = scope
  319|      0|        }
  320|      0|
  321|      0|        return requestOAuthAccessToken(
  322|      0|            withParameters: parameters,
  323|      0|            headers: headers,
  324|      0|            success: success,
  325|      0|            failure: failure
  326|      0|        )
  327|      0|    }
  328|       |
  329|       |    @discardableResult
  330|      0|    open func authorize(deviceToken deviceCode: String, grantType: String = "http://oauth.net/grant_type/device/1.0", success: @escaping TokenSuccessHandler, failure: @escaping OAuthSwiftHTTPRequest.FailureHandler) -> OAuthSwiftRequestHandle? {
  331|      0|        var parameters = OAuthSwift.Parameters()
  332|      0|        parameters["client_id"] = self.consumerKey
  333|      0|        parameters["client_secret"] = self.consumerSecret
  334|      0|        parameters["code"] = deviceCode
  335|      0|        parameters["grant_type"] = grantType
  336|      0|
  337|      0|        return requestOAuthAccessToken(
  338|      0|            withParameters: parameters,
  339|      0|            success: success,
  340|      0|            failure: failure
  341|      0|        )
  342|      0|    }
  343|       |
  344|       |    /// use RFC7636 PKCE credentials - convenience method
  345|       |    @discardableResult
  346|      0|    open func authorize(withCallbackURL url: URLConvertible, scope: String, state: String, codeChallenge: String, codeChallengeMethod: String = "S256", codeVerifier: String, parameters: Parameters = [:], headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: FailureHandler?) -> OAuthSwiftRequestHandle? {
  347|      0|        guard let callbackURL = url.url else {
  348|      0|            failure?(OAuthSwiftError.encodingError(urlString: url.string))
  349|      0|            return nil
  350|      0|        }
  351|      0|
  352|      0|        // remember code_verifier
  353|      0|        self.codeVerifier = codeVerifier
  354|      0|        // PKCE - extra parameter
  355|      0|        var pkceParameters = Parameters()
  356|      0|        pkceParameters["code_challenge"] = codeChallenge
  357|      0|        pkceParameters["code_challenge_method"] = codeChallengeMethod
  358|      0|
  359|      0|        return authorize(withCallbackURL: callbackURL, scope: scope, state: state, parameters: parameters + pkceParameters, headers: headers, success: success, failure: failure)
  360|      0|    }
  361|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuthSwift.swift:
    1|       |//
    2|       |//  OAuthSwift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by phimage on 04/12/15.
    6|       |//  Copyright © 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |open class OAuthSwift: NSObject, OAuthSwiftRequestHandle {
   12|       |
   13|       |    // MARK: Properties
   14|       |
   15|       |    /// Client to make signed request
   16|       |    open var client: OAuthSwiftClient
   17|       |    /// Version of the protocol
   18|      0|    open var version: OAuthSwiftCredential.Version { return self.client.credential.version }
   19|       |
   20|       |    /// Handle the authorize url into a web view or browser
   21|       |    open var authorizeURLHandler: OAuthSwiftURLHandlerType = OAuthSwiftOpenURLExternally.sharedInstance
   22|       |
   23|       |    fileprivate var currentRequests: [String: OAuthSwiftRequestHandle] = [:]
   24|       |
   25|       |    // MARK: init
   26|      0|    init(consumerKey: String, consumerSecret: String) {
   27|      0|        self.client = OAuthSwiftClient(consumerKey: consumerKey, consumerSecret: consumerSecret)
   28|      0|    }
   29|       |
   30|       |    // MARK: callback notification
   31|       |    struct CallbackNotification {
   32|       |        @available(*, deprecated: 0.5, message: "Use Notification.Name.OAuthSwiftHandleCallbackURL")
   33|       |        static let notificationName = Notification.Name(rawValue: "OAuthSwiftCallbackNotificationName")
   34|       |        static let optionsURLKey = "OAuthSwiftCallbackNotificationOptionsURLKey"
   35|       |    }
   36|       |
   37|       |    /// Handle callback url which contains now token information
   38|      0|    open class func handle(url: URL) {
   39|      0|        let notification = Notification(name: NSNotification.Name.OAuthSwiftHandleCallbackURL, object: nil,
   40|      0|            userInfo: [CallbackNotification.optionsURLKey: url])
   41|      0|        notificationCenter.post(notification)
   42|      0|    }
   43|       |
   44|       |    var observer: NSObjectProtocol?
   45|      0|    open class var notificationCenter: NotificationCenter {
   46|      0|        return NotificationCenter.default
   47|      0|    }
   48|      0|    open class var notificationQueue: OperationQueue {
   49|      0|        return OperationQueue.main
   50|      0|    }
   51|       |
   52|      0|    func observeCallback(_ block: @escaping (_ url: URL) -> Void) {
   53|      0|        self.observer = OAuthSwift.notificationCenter.addObserver(forName: NSNotification.Name.OAuthSwiftHandleCallbackURL, object: nil, queue: OperationQueue.main) { [weak self] notification in
   54|      0|            self?.removeCallbackNotificationObserver()
   55|      0|
   56|      0|            if let urlFromUserInfo = notification.userInfo?[CallbackNotification.optionsURLKey] as? URL {
   57|      0|                block(urlFromUserInfo)
   58|      0|            } else {
   59|      0|                // Internal error
   60|      0|                assertionFailure()
   61|      0|            }
   62|      0|        }
   63|      0|    }
   64|       |
   65|       |    /// Remove internal observer on authentification
   66|      0|    public func removeCallbackNotificationObserver() {
   67|      0|        if let observer = self.observer {
   68|      0|            OAuthSwift.notificationCenter.removeObserver(observer)
   69|      0|        }
   70|      0|    }
   71|       |
   72|       |    /// Function to call when web view is dismissed without authentification
   73|      0|    public func cancel() {
   74|      0|        self.removeCallbackNotificationObserver()
   75|      0|        for (_, request) in self.currentRequests {
   76|      0|            request.cancel()
   77|      0|        }
   78|      0|        self.currentRequests = [:]
   79|      0|    }
   80|       |
   81|      0|    func putHandle(_ handle: OAuthSwiftRequestHandle, withKey key: String) {
   82|      0|        // self.currentRequests[withKey] = handle
   83|      0|        // TODO before storing handle, find a way to remove it when network request end (ie. all failure and success ie. complete)
   84|      0|    }
   85|       |
   86|       |    /// Run block in main thread
   87|      0|    static func main(block: @escaping () -> Void) {
   88|      0|        if Thread.isMainThread {
   89|      0|            block()
   90|      0|        } else {
   91|      0|            DispatchQueue.main.async {
   92|      0|                block()
   93|      0|            }
   94|      0|        }
   95|      0|    }
   96|       |
   97|       |}
   98|       |
   99|       |// MARK: - alias
  100|       |extension OAuthSwift {
  101|       |
  102|       |    public typealias Parameters = [String: Any]
  103|       |    public typealias Headers = [String: String]
  104|       |    public typealias ConfigParameters = [String: String]
  105|       |    /// MARK: callback alias
  106|       |    public typealias TokenSuccess = (credential: OAuthSwiftCredential, response: OAuthSwiftResponse?, parameters: Parameters)
  107|       |    public typealias TokenSuccessHandler = (_ credential: OAuthSwiftCredential, _ response: OAuthSwiftResponse?, _ parameters: Parameters) -> Void
  108|       |    public typealias FailureHandler = (_ error: OAuthSwiftError) -> Void
  109|       |    public typealias TokenRenewedHandler = (_ credential: OAuthSwiftCredential) -> Void
  110|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuthSwiftClient.swift:
    1|       |//
    2|       |//  OAuthSwiftClient.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 6/21/14.
    6|       |//  Copyright (c) 2014 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public var OAuthSwiftDataEncoding: String.Encoding = .utf8
   12|       |
   13|       |@objc public protocol OAuthSwiftRequestHandle {
   14|       |    func cancel()
   15|       |}
   16|       |
   17|       |open class OAuthSwiftClient: NSObject {
   18|       |
   19|       |    fileprivate(set) open var credential: OAuthSwiftCredential
   20|       |    open var paramsLocation: OAuthSwiftHTTPRequest.ParamsLocation = .authorizationHeader
   21|       |    /// Contains default URL session configuration
   22|       |    open var sessionFactory = URLSessionFactory()
   23|       |
   24|       |    static let separator: String = "\r\n"
   25|      0|    static var separatorData: Data = {
   26|      0|        return OAuthSwiftClient.separator.data(using: OAuthSwiftDataEncoding)!
   27|      0|    }()
   28|       |
   29|       |    // MARK: init
   30|      0|    public init(credential: OAuthSwiftCredential) {
   31|      0|        self.credential = credential
   32|      0|    }
   33|       |
   34|      0|    public convenience init(consumerKey: String, consumerSecret: String, version: OAuthSwiftCredential.Version = .oauth1) {
   35|      0|        let credential = OAuthSwiftCredential(consumerKey: consumerKey, consumerSecret: consumerSecret)
   36|      0|        credential.version = version
   37|      0|        self.init(credential: credential)
   38|      0|    }
   39|       |
   40|      0|    public convenience init(consumerKey: String, consumerSecret: String, oauthToken: String, oauthTokenSecret: String, version: OAuthSwiftCredential.Version) {
   41|      0|        self.init(consumerKey: consumerKey, consumerSecret: consumerSecret, version: version)
   42|      0|        self.credential.oauthToken = oauthToken
   43|      0|        self.credential.oauthTokenSecret = oauthTokenSecret
   44|      0|    }
   45|       |
   46|       |    // MARK: client methods
   47|       |    @discardableResult
   48|      0|    open func get(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.FailureHandler?) -> OAuthSwiftRequestHandle? {
   49|      0|        return self.request(url, method: .GET, parameters: parameters, headers: headers, success: success, failure: failure)
   50|      0|    }
   51|       |
   52|       |    @discardableResult
   53|      0|    open func post(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, body: Data? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.FailureHandler?) -> OAuthSwiftRequestHandle? {
   54|      0|        return self.request(url, method: .POST, parameters: parameters, headers: headers, body: body, success: success, failure: failure)
   55|      0|    }
   56|       |
   57|       |    @discardableResult
   58|      0|    open func put(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, body: Data? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.FailureHandler?) -> OAuthSwiftRequestHandle? {
   59|      0|        return self.request(url, method: .PUT, parameters: parameters, headers: headers, body: body, success: success, failure: failure)
   60|      0|    }
   61|       |
   62|       |    @discardableResult
   63|      0|    open func delete(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.FailureHandler?) -> OAuthSwiftRequestHandle? {
   64|      0|        return self.request(url, method: .DELETE, parameters: parameters, headers: headers, success: success, failure: failure)
   65|      0|    }
   66|       |
   67|       |    @discardableResult
   68|      0|    open func patch(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.FailureHandler?) -> OAuthSwiftRequestHandle? {
   69|      0|        return self.request(url, method: .PATCH, parameters: parameters, headers: headers, success: success, failure: failure)
   70|      0|    }
   71|       |
   72|       |    @discardableResult
   73|      0|    open func request(_ url: URLConvertible, method: OAuthSwiftHTTPRequest.Method, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, body: Data? = nil, checkTokenExpiration: Bool = true, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.FailureHandler?) -> OAuthSwiftRequestHandle? {
   74|      0|
   75|      0|        if checkTokenExpiration && self.credential.isTokenExpired() {
   76|      0|            failure?(OAuthSwiftError.tokenExpired(error: nil))
   77|      0|            return nil
   78|      0|        }
   79|      0|
   80|      0|        guard url.url != nil else {
   81|      0|            failure?(OAuthSwiftError.encodingError(urlString: url.string))
   82|      0|            return nil
   83|      0|        }
   84|      0|
   85|      0|        if let request = makeRequest(url, method: method, parameters: parameters, headers: headers, body: body) {
   86|      0|            request.start(success: success, failure: failure)
   87|      0|            return request
   88|      0|        }
   89|      0|        return nil
   90|      0|    }
   91|       |
   92|      0|    open func makeRequest(_ request: URLRequest) -> OAuthSwiftHTTPRequest {
   93|      0|        let request = OAuthSwiftHTTPRequest(request: request, paramsLocation: self.paramsLocation, sessionFactory: self.sessionFactory)
   94|      0|        request.config.updateRequest(credential: self.credential)
   95|      0|        return request
   96|      0|    }
   97|       |
   98|      0|    open func makeRequest(_ url: URLConvertible, method: OAuthSwiftHTTPRequest.Method, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, body: Data? = nil) -> OAuthSwiftHTTPRequest? {
   99|      0|        guard let url = url.url else {
  100|      0|            return nil // XXX failure not thrown here
  101|      0|        }
  102|      0|
  103|      0|        let request = OAuthSwiftHTTPRequest(url: url, method: method, parameters: parameters, paramsLocation: self.paramsLocation, httpBody: body, headers: headers ?? [:], sessionFactory: self.sessionFactory)
  104|      0|        request.config.updateRequest(credential: self.credential)
  105|      0|        return request
  106|      0|    }
  107|       |
  108|       |    @discardableResult
  109|      0|    public func postImage(_ url: URLConvertible, parameters: OAuthSwift.Parameters, image: Data, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.FailureHandler?) -> OAuthSwiftRequestHandle? {
  110|      0|        return self.multiPartRequest(url: url, method: .POST, parameters: parameters, image: image, success: success, failure: failure)
  111|      0|    }
  112|       |
  113|      0|    open func makeMultiPartRequest(_ url: URLConvertible, method: OAuthSwiftHTTPRequest.Method, parameters: OAuthSwift.Parameters = [:], multiparts: [OAuthSwiftMultipartData] = [], headers: OAuthSwift.Headers? = nil) -> OAuthSwiftHTTPRequest? {
  114|      0|        let boundary = "AS-boundary-\(arc4random())-\(arc4random())"
  115|      0|        let type = "multipart/form-data; boundary=\(boundary)"
  116|      0|        let body = self.multiDataFromObject(parameters, multiparts: multiparts, boundary: boundary)
  117|      0|
  118|      0|        var finalHeaders = [kHTTPHeaderContentType: type]
  119|      0|        finalHeaders += headers ?? [:]
  120|      0|
  121|      0|        return makeRequest(url, method: method, parameters: parameters, headers: finalHeaders, body: body)
  122|      0|    }
  123|       |
  124|      0|    func multiPartRequest(url: URLConvertible, method: OAuthSwiftHTTPRequest.Method, parameters: OAuthSwift.Parameters, image: Data, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.FailureHandler?) -> OAuthSwiftRequestHandle? {
  125|      0|        let multiparts = [ OAuthSwiftMultipartData(name: "media", data: image, fileName: "file", mimeType: "image/jpeg") ]
  126|      0|        guard let request = makeMultiPartRequest(url, method: method, parameters: parameters, multiparts: multiparts) else {
  127|      0|            return nil
  128|      0|        }
  129|      0|        request.start(success: success, failure: failure)
  130|      0|        return request
  131|      0|    }
  132|       |
  133|      0|    open func multiPartBody(from inputParameters: OAuthSwift.Parameters, boundary: String) -> Data {
  134|      0|        var parameters = OAuthSwift.Parameters()
  135|      0|        var multiparts = [OAuthSwiftMultipartData]()
  136|      0|
  137|      0|        for (key, value) in inputParameters {
  138|      0|            if  let data = value as? Data, key == "media" {
  139|      0|                let sectionType = "image/jpeg"
  140|      0|                let sectionFilename = "file"
  141|      0|                multiparts.append(OAuthSwiftMultipartData(name: key, data: data, fileName: sectionFilename, mimeType: sectionType))
  142|      0|            } else {
  143|      0|                parameters[key] = value
  144|      0|            }
  145|      0|        }
  146|      0|
  147|      0|        return multiDataFromObject(parameters, multiparts: multiparts, boundary: boundary)
  148|      0|    }
  149|       |
  150|       |    @discardableResult
  151|      0|    open func postMultiPartRequest(_ url: URLConvertible, method: OAuthSwiftHTTPRequest.Method, parameters: OAuthSwift.Parameters, headers: OAuthSwift.Headers? = nil, multiparts: [OAuthSwiftMultipartData] = [], checkTokenExpiration: Bool = true, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.FailureHandler?) -> OAuthSwiftRequestHandle? {
  152|      0|
  153|      0|        if checkTokenExpiration && self.credential.isTokenExpired() {
  154|      0|            failure?(OAuthSwiftError.tokenExpired(error: nil))
  155|      0|            return nil
  156|      0|        }
  157|      0|
  158|      0|        if let request = makeMultiPartRequest(url, method: method, parameters: parameters, multiparts: multiparts, headers: headers) {
  159|      0|            request.start(success: success, failure: failure)
  160|      0|            return request
  161|      0|        }
  162|      0|        return nil
  163|      0|    }
  164|       |
  165|      0|    func multiDataFromObject(_ object: OAuthSwift.Parameters, multiparts: [OAuthSwiftMultipartData], boundary: String) -> Data {
  166|      0|        var data = Data()
  167|      0|
  168|      0|        let prefixString = "--\(boundary)\r\n"
  169|      0|        let prefixData = prefixString.data(using: OAuthSwiftDataEncoding)!
  170|      0|
  171|      0|        for (key, value) in object {
  172|      0|            guard let valueData = "\(value)".data(using: OAuthSwiftDataEncoding) else {
  173|      0|                continue
  174|      0|            }
  175|      0|            data.append(prefixData)
  176|      0|            let multipartData = OAuthSwiftMultipartData(name: key, data: valueData, fileName: nil, mimeType: nil)
  177|      0|            data.append(multipartData, encoding: OAuthSwiftDataEncoding, separatorData: OAuthSwiftClient.separatorData)
  178|      0|        }
  179|      0|
  180|      0|        for multipart in multiparts {
  181|      0|            data.append(prefixData)
  182|      0|            data.append(multipart, encoding: OAuthSwiftDataEncoding, separatorData: OAuthSwiftClient.separatorData)
  183|      0|        }
  184|      0|
  185|      0|        let endingString = "--\(boundary)--\r\n"
  186|      0|        let endingData = endingString.data(using: OAuthSwiftDataEncoding)!
  187|      0|        data.append(endingData)
  188|      0|
  189|      0|        return data
  190|      0|    }
  191|       |
  192|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuthSwiftCredential.swift:
    1|       |//
    2|       |//  OAuthSwiftCredential.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 6/22/14.
    6|       |//  Copyright (c) 2014 Dongri Jin. All rights reserved.
    7|       |//
    8|       |import Foundation
    9|       |
   10|       |/// Allow to customize computed headers
   11|       |public protocol OAuthSwiftCredentialHeadersFactory {
   12|       |    func make(_ url: URL, method: OAuthSwiftHTTPRequest.Method, parameters: OAuthSwift.Parameters, body: Data?) -> [String: String]
   13|       |}
   14|       |
   15|       |/// Allow to sign
   16|       |// swiftlint:disable:next class_delegate_protocol
   17|       |public protocol OAuthSwiftSignatureDelegate {
   18|       |    static func sign(hashMethod: OAuthSwiftHashMethod, key: Data, message: Data) -> Data?
   19|       |}
   20|       |
   21|       |// The hash method used.
   22|       |public enum OAuthSwiftHashMethod: String {
   23|       |    case sha1
   24|       |    case none
   25|       |
   26|      0|    func hash(data: Data) -> Data? {
   27|      0|        switch self {
   28|      0|        case .sha1:
   29|      0|            let mac = SHA1(data).calculate()
   30|      0|            return Data(bytes: UnsafePointer<UInt8>(mac), count: mac.count)
   31|      0|        case .none:
   32|      0|            return data
   33|      0|        }
   34|      0|    }
   35|       |}
   36|       |
   37|       |/// The credential for authentification
   38|       |open class OAuthSwiftCredential: NSObject, NSSecureCoding, Codable {
   39|       |
   40|       |    public static let supportsSecureCoding = true
   41|       |
   42|       |    public enum Version: Codable {
   43|       |        case oauth1, oauth2
   44|       |
   45|      0|        public var shortVersion: String {
   46|      0|            switch self {
   47|      0|            case .oauth1:
   48|      0|                return "1.0"
   49|      0|            case .oauth2:
   50|      0|                return "2.0"
   51|      0|            }
   52|      0|        }
   53|       |
   54|      0|        var toInt32: Int32 {
   55|      0|            switch self {
   56|      0|            case .oauth1:
   57|      0|                return 1
   58|      0|            case .oauth2:
   59|      0|                return 2
   60|      0|            }
   61|      0|        }
   62|       |
   63|      0|        init(_ value: Int32) {
   64|      0|            switch value {
   65|      0|            case 1:
   66|      0|                self = .oauth1
   67|      0|            case 2:
   68|      0|                self = .oauth2
   69|      0|            default:
   70|      0|                self = .oauth1
   71|      0|            }
   72|      0|        }
   73|       |
   74|      0|        public func encode(to encoder: Encoder) throws {
   75|      0|            var container = encoder.singleValueContainer()
   76|      0|            try container.encode(self.toInt32)
   77|      0|        }
   78|       |
   79|      0|        public init(from decoder: Decoder) throws {
   80|      0|            self.init(try decoder.singleValueContainer().decode(Int32.self))
   81|      0|        }
   82|       |    }
   83|       |
   84|       |    public enum SignatureMethod: String {
   85|       |        case HMAC_SHA1 = "HMAC-SHA1"
   86|       |        case RSA_SHA1 = "RSA-SHA1"
   87|       |        case PLAINTEXT = "PLAINTEXT"
   88|       |
   89|       |        public static var delegates: [SignatureMethod: OAuthSwiftSignatureDelegate.Type] =
   90|       |            [HMAC_SHA1: HMAC.self]
   91|       |
   92|      0|        var hashMethod: OAuthSwiftHashMethod {
   93|      0|            switch self {
   94|      0|            case .HMAC_SHA1, .RSA_SHA1:
   95|      0|                return .sha1
   96|      0|            case .PLAINTEXT:
   97|      0|                return .none
   98|      0|            }
   99|      0|        }
  100|       |
  101|      0|        func sign(key: Data, message: Data) -> Data? {
  102|      0|            if let delegate = SignatureMethod.delegates[self] {
  103|      0|                return delegate.sign(hashMethod: self.hashMethod, key: key, message: message)
  104|      0|            }
  105|      0|            assert(self == .PLAINTEXT, "No signature method installed for \(self)")
  106|      0|            return message
  107|      0|        }
  108|       |
  109|       |    }
  110|       |
  111|       |    // MARK: attributes
  112|       |    open internal(set) var consumerKey = ""
  113|       |    open internal(set) var consumerSecret = ""
  114|       |    open var oauthToken = ""
  115|       |    open var oauthRefreshToken = ""
  116|       |    open var oauthTokenSecret = ""
  117|       |    open var oauthTokenExpiresAt: Date?
  118|       |    open internal(set) var oauthVerifier = ""
  119|       |    open var version: Version = .oauth1
  120|       |    open var signatureMethod: SignatureMethod = .HMAC_SHA1
  121|       |
  122|       |    /// hook to replace headers creation
  123|       |    open var headersFactory: OAuthSwiftCredentialHeadersFactory?
  124|       |
  125|       |    // MARK: init
  126|      0|    override init() {
  127|      0|    }
  128|       |
  129|      0|    public init(consumerKey: String, consumerSecret: String) {
  130|      0|        self.consumerKey = consumerKey
  131|      0|        self.consumerSecret = consumerSecret
  132|      0|    }
  133|       |
  134|       |    // MARK: NSCoding protocol
  135|       |    fileprivate struct NSCodingKeys {
  136|       |        static let bundleId = Bundle.main.bundleIdentifier
  137|       |            ?? Bundle(for: OAuthSwiftCredential.self).bundleIdentifier
  138|       |            ?? ""
  139|       |        static let base = bundleId + "."
  140|       |        static let consumerKey = base + "comsumer_key"
  141|       |        static let consumerSecret = base + "consumer_secret"
  142|       |        static let oauthToken = base + "oauth_token"
  143|       |        static let oauthRefreshToken = base + "oauth_refresh_token"
  144|       |        static let oauthTokenExpiresAt = base + "oauth_token_expires_at"
  145|       |        static let oauthTokenSecret = base + "oauth_token_secret"
  146|       |        static let oauthVerifier = base + "oauth_verifier"
  147|       |        static let version = base + "version"
  148|       |        static let signatureMethod = base + "signatureMethod"
  149|       |    }
  150|       |
  151|       |    /// Cannot declare a required initializer within an extension.
  152|       |    /// extension OAuthSwiftCredential: NSCoding {
  153|      0|    public required convenience init?(coder decoder: NSCoder) {
  154|      0|
  155|      0|        guard let consumerKey = decoder
  156|      0|            .decodeObject(of: NSString.self,
  157|      0|                          forKey: NSCodingKeys.consumerKey) as String? else {
  158|      0|            if #available(iOS 9, OSX 10.11, *) {
  159|      0|                let error = CocoaError.error(.coderValueNotFound)
  160|      0|                decoder.failWithError(error)
  161|      0|            }
  162|      0|            return nil
  163|      0|        }
  164|      0|
  165|      0|        guard let consumerSecret = decoder
  166|      0|            .decodeObject(of: NSString.self,
  167|      0|                          forKey: NSCodingKeys.consumerSecret) as String? else {
  168|      0|            if #available(iOS 9, OSX 10.11, *) {
  169|      0|                let error = CocoaError.error(.coderValueNotFound)
  170|      0|                decoder.failWithError(error)
  171|      0|            }
  172|      0|            return nil
  173|      0|        }
  174|      0|        self.init(consumerKey: consumerKey, consumerSecret: consumerSecret)
  175|      0|
  176|      0|        guard let oauthToken = decoder
  177|      0|            .decodeObject(of: NSString.self,
  178|      0|                          forKey: NSCodingKeys.oauthToken) as String? else {
  179|      0|            if #available(iOS 9, OSX 10.11, *) {
  180|      0|                let error = CocoaError.error(.coderValueNotFound)
  181|      0|                decoder.failWithError(error)
  182|      0|            }
  183|      0|            return nil
  184|      0|        }
  185|      0|        self.oauthToken = oauthToken
  186|      0|
  187|      0|        guard let oauthRefreshToken = decoder
  188|      0|            .decodeObject(of: NSString.self,
  189|      0|                          forKey: NSCodingKeys.oauthRefreshToken) as String? else {
  190|      0|            if #available(iOS 9, OSX 10.11, *) {
  191|      0|                let error = CocoaError.error(.coderValueNotFound)
  192|      0|                decoder.failWithError(error)
  193|      0|            }
  194|      0|            return nil
  195|      0|        }
  196|      0|        self.oauthRefreshToken = oauthRefreshToken
  197|      0|
  198|      0|        guard let oauthTokenSecret = decoder
  199|      0|            .decodeObject(of: NSString.self,
  200|      0|                          forKey: NSCodingKeys.oauthTokenSecret) as String? else {
  201|      0|            if #available(iOS 9, OSX 10.11, *) {
  202|      0|                let error = CocoaError.error(.coderValueNotFound)
  203|      0|                decoder.failWithError(error)
  204|      0|            }
  205|      0|            return nil
  206|      0|        }
  207|      0|        self.oauthTokenSecret = oauthTokenSecret
  208|      0|
  209|      0|        guard let oauthVerifier = decoder
  210|      0|            .decodeObject(of: NSString.self,
  211|      0|                          forKey: NSCodingKeys.oauthVerifier) as String? else {
  212|      0|            if #available(iOS 9, OSX 10.11, *) {
  213|      0|                    let error = CocoaError.error(.coderValueNotFound)
  214|      0|                    decoder.failWithError(error)
  215|      0|            }
  216|      0|            return nil
  217|      0|        }
  218|      0|        self.oauthVerifier = oauthVerifier
  219|      0|
  220|      0|        self.oauthTokenExpiresAt = decoder
  221|      0|            .decodeObject(of: NSDate.self, forKey: NSCodingKeys.oauthTokenExpiresAt) as Date?
  222|      0|        self.version = Version(decoder.decodeInt32(forKey: NSCodingKeys.version))
  223|      0|        if case .oauth1 = version {
  224|      0|            self.signatureMethod = SignatureMethod(rawValue: (decoder.decodeObject(of: NSString.self, forKey: NSCodingKeys.signatureMethod) as String?) ?? "HMAC_SHA1") ?? .HMAC_SHA1
  225|      0|        }
  226|      0|    }
  227|       |
  228|      0|    open func encode(with coder: NSCoder) {
  229|      0|        coder.encode(self.consumerKey, forKey: NSCodingKeys.consumerKey)
  230|      0|        coder.encode(self.consumerSecret, forKey: NSCodingKeys.consumerSecret)
  231|      0|        coder.encode(self.oauthToken, forKey: NSCodingKeys.oauthToken)
  232|      0|        coder.encode(self.oauthRefreshToken, forKey: NSCodingKeys.oauthRefreshToken)
  233|      0|        coder.encode(self.oauthTokenSecret, forKey: NSCodingKeys.oauthTokenSecret)
  234|      0|        coder.encode(self.oauthVerifier, forKey: NSCodingKeys.oauthVerifier)
  235|      0|        coder.encode(self.oauthTokenExpiresAt, forKey: NSCodingKeys.oauthTokenExpiresAt)
  236|      0|        coder.encode(self.version.toInt32, forKey: NSCodingKeys.version)
  237|      0|        if case .oauth1 = version {
  238|      0|            coder.encode(self.signatureMethod.rawValue, forKey: NSCodingKeys.signatureMethod)
  239|      0|        }
  240|      0|    }
  241|       |    // } // End NSCoding extension
  242|       |
  243|       |    // MARK: Codable protocol
  244|       |    enum CodingKeys: String, CodingKey {
  245|       |        case consumerKey
  246|       |        case consumerSecret
  247|       |        case oauthToken
  248|       |        case oauthRefreshToken
  249|       |        case oauthTokenSecret
  250|       |        case oauthVerifier
  251|       |        case oauthTokenExpiresAt
  252|       |        case version
  253|       |        case signatureMethodRawValue
  254|       |    }
  255|       |
  256|      0|    public func encode(to encoder: Encoder) throws {
  257|      0|        var container = encoder.container(keyedBy: CodingKeys.self)
  258|      0|        try container.encode(self.consumerKey, forKey: .consumerKey)
  259|      0|        try container.encode(self.consumerSecret, forKey: .consumerSecret)
  260|      0|        try container.encode(self.oauthToken, forKey: .oauthToken)
  261|      0|        try container.encode(self.oauthRefreshToken, forKey: .oauthRefreshToken)
  262|      0|        try container.encode(self.oauthTokenSecret, forKey: .oauthTokenSecret)
  263|      0|        try container.encode(self.oauthVerifier, forKey: .oauthVerifier)
  264|      0|        try container.encodeIfPresent(self.oauthTokenExpiresAt, forKey: .oauthTokenExpiresAt)
  265|      0|        try container.encode(self.version, forKey: .version)
  266|      0|        if case .oauth1 = version {
  267|      0|            try container.encode(self.signatureMethod.rawValue, forKey: .signatureMethodRawValue)
  268|      0|        }
  269|      0|    }
  270|       |
  271|      0|    public required convenience init(from decoder: Decoder) throws {
  272|      0|        let container = try decoder.container(keyedBy: CodingKeys.self)
  273|      0|
  274|      0|        self.init()
  275|      0|
  276|      0|        self.consumerKey = try container.decode(String.self, forKey: .consumerKey)
  277|      0|        self.consumerSecret = try container.decode(String.self, forKey: .consumerSecret)
  278|      0|
  279|      0|        self.oauthToken = try container.decode(type(of: self.oauthToken), forKey: .oauthToken)
  280|      0|        self.oauthRefreshToken = try container.decode(type(of: self.oauthRefreshToken), forKey: .oauthRefreshToken)
  281|      0|        self.oauthTokenSecret = try container.decode(type(of: self.oauthTokenSecret), forKey: .oauthTokenSecret)
  282|      0|        self.oauthVerifier = try container.decode(type(of: self.oauthVerifier), forKey: .oauthVerifier)
  283|      0|        self.oauthTokenExpiresAt = try container.decodeIfPresent(Date.self, forKey: .oauthTokenExpiresAt)
  284|      0|        self.version = try container.decode(type(of: self.version), forKey: .version)
  285|      0|
  286|      0|        if case .oauth1 = version {
  287|      0|            self.signatureMethod = SignatureMethod(rawValue: try container.decode(type(of: self.signatureMethod.rawValue), forKey: .signatureMethodRawValue))!
  288|      0|        }
  289|      0|    }
  290|       |
  291|       |    // MARK: functions
  292|       |    /// for OAuth1 parameters must contains sorted query parameters and url must not contains query parameters
  293|      0|    open func makeHeaders(_ url: URL, method: OAuthSwiftHTTPRequest.Method, parameters: OAuthSwift.Parameters, body: Data? = nil) -> [String: String] {
  294|      0|        if let factory = headersFactory {
  295|      0|            return factory.make(url, method: method, parameters: parameters, body: body)
  296|      0|        }
  297|      0|        switch self.version {
  298|      0|        case .oauth1:
  299|      0|            return ["Authorization": self.authorizationHeader(method: method, url: url, parameters: parameters, body: body)]
  300|      0|        case .oauth2:
  301|      0|            return self.oauthToken.isEmpty ? [:] : ["Authorization": "Bearer \(self.oauthToken)"]
  302|      0|        }
  303|      0|    }
  304|       |
  305|      0|    open func authorizationHeader(method: OAuthSwiftHTTPRequest.Method, url: URL, parameters: OAuthSwift.Parameters, body: Data? = nil) -> String {
  306|      0|        let timestamp = String(Int64(Date().timeIntervalSince1970))
  307|      0|        let nonce = OAuthSwiftCredential.generateNonce()
  308|      0|        return self.authorizationHeader(method: method, url: url, parameters: parameters, body: body, timestamp: timestamp, nonce: nonce)
  309|      0|    }
  310|       |
  311|      0|    open class func generateNonce() -> String {
  312|      0|        let uuidString: String = UUID().uuidString
  313|      0|        return uuidString[0..<8]
  314|      0|    }
  315|       |
  316|      0|    open func authorizationHeader(method: OAuthSwiftHTTPRequest.Method, url: URL, parameters: OAuthSwift.Parameters, body: Data? = nil, timestamp: String, nonce: String) -> String {
  317|      0|        assert(self.version == .oauth1)
  318|      0|        let authorizationParameters = self.authorizationParametersWithSignature(method: method, url: url, parameters: parameters, body: body, timestamp: timestamp, nonce: nonce)
  319|      0|
  320|      0|        var parameterComponents = authorizationParameters.urlEncodedQuery.components(separatedBy: "&") as [String]
  321|      0|        parameterComponents.sort { $0 < $1 }
  322|      0|
  323|      0|        var headerComponents = [String]()
  324|      0|        for component in parameterComponents {
  325|      0|            let subcomponent = component.components(separatedBy: "=") as [String]
  326|      0|            if subcomponent.count == 2 {
  327|      0|                headerComponents.append("\(subcomponent[0])=\"\(subcomponent[1])\"")
  328|      0|            }
  329|      0|        }
  330|      0|
  331|      0|        return "OAuth " + headerComponents.joined(separator: ", ")
  332|      0|    }
  333|       |
  334|      0|    open func authorizationParametersWithSignature(method: OAuthSwiftHTTPRequest.Method, url: URL, parameters: OAuthSwift.Parameters, body: Data? = nil) -> OAuthSwift.Parameters {
  335|      0|        let timestamp = String(Int64(Date().timeIntervalSince1970))
  336|      0|        let nonce = OAuthSwiftCredential.generateNonce()
  337|      0|        return self.authorizationParametersWithSignature(method: method, url: url, parameters: parameters, body: body, timestamp: timestamp, nonce: nonce)
  338|      0|    }
  339|       |
  340|      0|    open func authorizationParametersWithSignature(method: OAuthSwiftHTTPRequest.Method, url: URL, parameters: OAuthSwift.Parameters, body: Data? = nil, timestamp: String, nonce: String) -> OAuthSwift.Parameters {
  341|      0|        var authorizationParameters = self.authorizationParameters(body, timestamp: timestamp, nonce: nonce)
  342|      0|
  343|      0|        for (key, value) in parameters {
  344|      0|            if key.hasPrefix("oauth_") {
  345|      0|                authorizationParameters.updateValue(value, forKey: key)
  346|      0|            }
  347|      0|        }
  348|      0|
  349|      0|        let combinedParameters = authorizationParameters.join(parameters)
  350|      0|
  351|      0|        authorizationParameters["oauth_signature"] = self.signature(method: method, url: url, parameters: combinedParameters)
  352|      0|
  353|      0|        return authorizationParameters
  354|      0|    }
  355|       |
  356|      0|    open func authorizationParameters(_ body: Data?, timestamp: String, nonce: String) -> OAuthSwift.Parameters {
  357|      0|        var authorizationParameters = OAuthSwift.Parameters()
  358|      0|        authorizationParameters["oauth_version"] = self.version.shortVersion
  359|      0|        authorizationParameters["oauth_signature_method"] =  self.signatureMethod.rawValue
  360|      0|        authorizationParameters["oauth_consumer_key"] = self.consumerKey
  361|      0|        authorizationParameters["oauth_timestamp"] = timestamp
  362|      0|        authorizationParameters["oauth_nonce"] = nonce
  363|      0|        if let b = body, let hash = self.signatureMethod.hashMethod.hash(data: b) {
  364|      0|            authorizationParameters["oauth_body_hash"] = hash.base64EncodedString(options: [])
  365|      0|        }
  366|      0|
  367|      0|        if !self.oauthToken.isEmpty {
  368|      0|            authorizationParameters["oauth_token"] = self.oauthToken
  369|      0|        }
  370|      0|        return authorizationParameters
  371|      0|    }
  372|       |
  373|      0|    open func signature(method: OAuthSwiftHTTPRequest.Method, url: URL, parameters: OAuthSwift.Parameters) -> String {
  374|      0|        let encodedTokenSecret = self.oauthTokenSecret.urlEncoded
  375|      0|        let encodedConsumerSecret = self.consumerSecret.urlEncoded
  376|      0|
  377|      0|        let signingKey = "\(encodedConsumerSecret)&\(encodedTokenSecret)"
  378|      0|
  379|      0|        var parameterComponents = parameters.urlEncodedQuery.components(separatedBy: "&")
  380|      0|        parameterComponents.sort {
  381|      0|            let p0 = $0.components(separatedBy: "=")
  382|      0|            let p1 = $1.components(separatedBy: "=")
  383|      0|            if p0.first == p1.first { return p0.last ?? "" < p1.last ?? "" }
  384|      0|            return p0.first ?? "" < p1.first ?? ""
  385|      0|        }
  386|      0|
  387|      0|        let parameterString = parameterComponents.joined(separator: "&")
  388|      0|        let encodedParameterString = parameterString.urlEncoded
  389|      0|
  390|      0|        let encodedURL = url.absoluteString.urlEncoded
  391|      0|
  392|      0|        let signatureBaseString = "\(method)&\(encodedURL)&\(encodedParameterString)"
  393|      0|
  394|      0|        let key = signingKey.data(using: .utf8)!
  395|      0|        let msg = signatureBaseString.data(using: .utf8)!
  396|      0|
  397|      0|        let sha1 = self.signatureMethod.sign(key: key, message: msg)!
  398|      0|        return sha1.base64EncodedString(options: [])
  399|      0|    }
  400|       |
  401|      0|    open func isTokenExpired() -> Bool {
  402|      0|        if let expiresDate = oauthTokenExpiresAt {
  403|      0|            return expiresDate <= Date()
  404|      0|        }
  405|      0|
  406|      0|        // If no expires date is available we assume the token is still valid since it doesn't have an expiration date to check with.
  407|      0|        return false
  408|      0|    }
  409|       |
  410|       |    // MARK: Equatable
  411|       |
  412|      0|    override open func isEqual(_ object: Any?) -> Bool {
  413|      0|        guard let rhs = object as? OAuthSwiftCredential else {
  414|      0|            return false
  415|      0|        }
  416|      0|        let lhs = self
  417|      0|        return lhs.consumerKey == rhs.consumerKey
  418|      0|            && lhs.consumerSecret == rhs.consumerSecret
  419|      0|            && lhs.oauthToken == rhs.oauthToken
  420|      0|            && lhs.oauthRefreshToken == rhs.oauthRefreshToken
  421|      0|            && lhs.oauthTokenSecret == rhs.oauthTokenSecret
  422|      0|            && lhs.oauthTokenExpiresAt == rhs.oauthTokenExpiresAt
  423|      0|            && lhs.oauthVerifier == rhs.oauthVerifier
  424|      0|            && lhs.version == rhs.version
  425|      0|            && lhs.signatureMethod == rhs.signatureMethod
  426|      0|    }
  427|       |
  428|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuthSwiftError.swift:
    1|       |//
    2|       |//  OAuthSwiftError.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by phimage on 02/10/16.
    6|       |//  Copyright © 2016 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |// MARK: - OAuthSwift errors
   12|       |public enum OAuthSwiftError: Error {
   13|       |
   14|       |    /// Configuration problem with oauth provider.
   15|       |    case configurationError(message: String)
   16|       |    /// State missing from request (you can set allowMissingStateCheck = true to ignore)
   17|       |    case missingState
   18|       |    /// Returned state value is wrong
   19|       |    case stateNotEqual(state: String, responseState: String)
   20|       |    /// Error from server
   21|       |    case serverError(message: String)
   22|       |    /// Failed to create URL \(urlString) not convertible to URL, please encode
   23|       |    case encodingError(urlString: String)
   24|       |    /// Failed to create request with \(urlString)
   25|       |    case requestCreation(message: String)
   26|       |    /// Authentification failed. No token
   27|       |    case missingToken
   28|       |    /// Please retain OAuthSwift object or handle
   29|       |    case retain
   30|       |    /// Request cancelled
   31|       |    case cancelled
   32|       |
   33|       |    /// Generic request error
   34|       |    case requestError(error: Error, request: URLRequest)
   35|       |    /// The provided token is expired, retrieve new token by using the refresh token
   36|       |    case tokenExpired(error: Error?)
   37|       |    /// If the user has not either allowed or denied the request yet, the authorization server will return the authorization_pending error.
   38|       |    case authorizationPending(error: Error, request: URLRequest)
   39|       |    /// If the device is polling too frequently, the authorization server will return the slow_down error.
   40|       |    case slowDown(error: Error, request: URLRequest)
   41|       |    /// If the user denies the request.
   42|       |    case accessDenied(error: Error, request: URLRequest)
   43|       |
   44|       |    public static let Domain = "OAuthSwiftError"
   45|       |    public static let ResponseDataKey = "OAuthSwiftError.response.data"
   46|       |    public static let ResponseKey = "OAuthSwiftError.response"
   47|       |
   48|       |    fileprivate enum Code: Int {
   49|       |        case configurationError = -1
   50|       |        case tokenExpired = -2
   51|       |        case missingState = -3
   52|       |        case stateNotEqual = -4
   53|       |        case serverError = -5
   54|       |        case encodingError = -6
   55|       |        case authorizationPending = -7
   56|       |        case requestCreation = -8
   57|       |        case missingToken = -9
   58|       |        case retain = -10
   59|       |        case requestError = -11
   60|       |        case cancelled = -12
   61|       |        case slowDown = -13
   62|       |        case accessDenied = -14
   63|       |    }
   64|       |
   65|      0|    fileprivate var code: Code {
   66|      0|        switch self {
   67|      0|        case .configurationError: return Code.configurationError
   68|      0|        case .tokenExpired: return Code.tokenExpired
   69|      0|        case .missingState: return Code.missingState
   70|      0|        case .stateNotEqual: return Code.stateNotEqual
   71|      0|        case .serverError: return Code.serverError
   72|      0|        case .encodingError: return Code.encodingError
   73|      0|        case .cancelled : return Code.cancelled
   74|      0|        case .requestCreation: return Code.requestCreation
   75|      0|        case .missingToken: return Code.missingToken
   76|      0|        case .retain: return Code.retain
   77|      0|        case .requestError: return Code.requestError
   78|      0|        case .authorizationPending: return Code.authorizationPending
   79|      0|        case .slowDown: return Code.slowDown
   80|      0|        case .accessDenied: return Code.accessDenied
   81|      0|        }
   82|      0|    }
   83|       |
   84|      0|    public var underlyingError: Error? {
   85|      0|        switch self {
   86|      0|        case .tokenExpired(let e): return e
   87|      0|        case .requestError(let e, _): return e
   88|      0|        case .authorizationPending(let e, _): return e
   89|      0|        case .slowDown(let e, _): return e
   90|      0|        case .accessDenied(let e, _): return e
   91|      0|        default: return nil
   92|      0|        }
   93|      0|    }
   94|       |
   95|      0|    public var underlyingMessage: String? {
   96|      0|        switch self {
   97|      0|        case .serverError(let m): return m
   98|      0|        case .configurationError(let m): return m
   99|      0|        case .requestCreation(let m): return m
  100|      0|        default: return nil
  101|      0|        }
  102|      0|    }
  103|       |
  104|       |}
  105|       |
  106|       |extension OAuthSwiftError: CustomStringConvertible {
  107|       |
  108|      0|    public var description: String {
  109|      0|        switch self {
  110|      0|        case .configurationError(let m): return "configurationError[\(m)]"
  111|      0|        case .tokenExpired(let e): return "tokenExpired[\(String(describing: e))]"
  112|      0|        case .missingState: return "missingState"
  113|      0|        case .stateNotEqual(let s, let e): return "stateNotEqual[\(s)<>\(e)]"
  114|      0|        case .serverError(let m): return "serverError[\(m)]"
  115|      0|        case .encodingError(let urlString): return "encodingError[\(urlString)]"
  116|      0|        case .requestCreation(let m): return "requestCreation[\(m)]"
  117|      0|        case .missingToken: return "missingToken"
  118|      0|        case .retain: return "retain"
  119|      0|        case .requestError(let e, _): return "requestError[\(e)]"
  120|      0|        case .slowDown : return "slowDown"
  121|      0|        case .accessDenied : return "accessDenied"
  122|      0|        case .authorizationPending: return "authorizationPending"
  123|      0|        case .cancelled : return "cancelled"
  124|      0|        }
  125|      0|    }
  126|       |}
  127|       |
  128|       |extension OAuthSwift {
  129|       |
  130|      0|    static func retainError(_ failureHandler: FailureHandler?) {
  131|      0|        #if !OAUTH_NO_RETAIN_ERROR
  132|      0|            failureHandler?(OAuthSwiftError.retain)
  133|      0|        #endif
  134|      0|    }
  135|       |
  136|       |}
  137|       |
  138|       |// MARK: NSError
  139|       |extension OAuthSwiftError: CustomNSError {
  140|       |
  141|      0|    public static var errorDomain: String { return OAuthSwiftError.Domain }
  142|       |
  143|      0|    public var errorCode: Int { return self.code.rawValue }
  144|       |
  145|       |    /// The user-info dictionary.
  146|      0|    public var errorUserInfo: [String: Any] {
  147|      0|        switch self {
  148|      0|        case .configurationError(let m): return ["message": m]
  149|      0|        case .serverError(let m): return ["message": m]
  150|      0|        case .requestCreation(let m): return ["message": m]
  151|      0|
  152|      0|        case .tokenExpired(let e): return ["error": e as Any]
  153|      0|        case .requestError(let e, let request): return ["error": e, "request": request]
  154|      0|        case .authorizationPending(let e, let request): return ["error": e, "request": request]
  155|      0|        case .slowDown(let e, let request): return ["error": e, "request": request]
  156|      0|        case .accessDenied(let e, let request): return ["error": e, "request": request]
  157|      0|
  158|      0|        case .encodingError(let urlString): return ["url": urlString]
  159|      0|
  160|      0|        case .stateNotEqual(let s, let e): return ["state": s, "expected": e]
  161|      0|        default: return [:]
  162|      0|        }
  163|      0|    }
  164|       |
  165|      0|    public var _code: Int {
  166|      0|        return self.code.rawValue
  167|      0|    }
  168|      0|    public var _domain: String {
  169|      0|        return OAuthSwiftError.Domain
  170|      0|    }
  171|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuthSwiftHTTPRequest.swift:
    1|       |//
    2|       |//  OAuthSwiftHTTPRequest.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 6/21/14.
    6|       |//  Copyright (c) 2014 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |let kHTTPHeaderContentType = "Content-Type"
   12|       |
   13|       |open class OAuthSwiftHTTPRequest: NSObject, OAuthSwiftRequestHandle {
   14|       |
   15|       |    public typealias SuccessHandler = (_ response: OAuthSwiftResponse) -> Void
   16|       |    public typealias FailureHandler = (_ error: OAuthSwiftError) -> Void
   17|       |
   18|       |    /// HTTP request method
   19|       |    /// https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods
   20|       |    public enum Method: String {
   21|       |        case GET, POST, PUT, DELETE, PATCH, HEAD //, OPTIONS, TRACE, CONNECT
   22|       |
   23|      0|        var isBody: Bool {
   24|      0|            return self == .POST || self == .PUT || self == .PATCH
   25|      0|        }
   26|       |    }
   27|       |
   28|       |    /// Where the additional parameters will be injected
   29|       |    @objc public enum ParamsLocation: Int {
   30|       |        case authorizationHeader, /*FormEncodedBody,*/ requestURIQuery
   31|       |    }
   32|       |
   33|       |    public var config: Config
   34|       |
   35|       |    private var request: URLRequest?
   36|       |    private var task: URLSessionTask?
   37|       |    private var session: URLSession!
   38|       |
   39|       |    fileprivate var cancelRequested = false
   40|       |
   41|      0|    public static var executionContext: (@escaping () -> Void) -> Void = { block in
   42|      0|        return DispatchQueue.main.async(execute: block)
   43|      0|    }
   44|       |
   45|       |    // MARK: INIT
   46|       |
   47|      0|    convenience init(url: URL, method: Method = .GET, parameters: OAuthSwift.Parameters = [:], paramsLocation: ParamsLocation = .authorizationHeader, httpBody: Data? = nil, headers: OAuthSwift.Headers = [:], sessionFactory: URLSessionFactory = .default) {
   48|      0|        self.init(config: Config(url: url, httpMethod: method, httpBody: httpBody, headers: headers, parameters: parameters, paramsLocation: paramsLocation, sessionFactory: sessionFactory))
   49|      0|    }
   50|       |
   51|      0|    convenience init(request: URLRequest, paramsLocation: ParamsLocation = .authorizationHeader, sessionFactory: URLSessionFactory = .default) {
   52|      0|        self.init(config: Config(urlRequest: request, paramsLocation: paramsLocation, sessionFactory: sessionFactory))
   53|      0|    }
   54|       |
   55|      0|    init(config: Config) {
   56|      0|        self.config = config
   57|      0|    }
   58|       |
   59|       |    /// START request
   60|      0|    func start(success: SuccessHandler?, failure: FailureHandler?) {
   61|      0|        guard request == nil else { return } // Don't start the same request twice!
   62|      0|
   63|      0|        let successHandler = success
   64|      0|        let failureHandler = failure
   65|      0|
   66|      0|        do {
   67|      0|            self.request = try self.makeRequest()
   68|      0|        } catch let error as NSError {
   69|      0|            failureHandler?(OAuthSwiftError.requestCreation(message: error.localizedDescription))
   70|      0|            self.request = nil
   71|      0|            return
   72|      0|        }
   73|      0|
   74|      0|        OAuthSwiftHTTPRequest.executionContext {
   75|      0|            // perform lock here to prevent cancel calls on another thread while creating the request
   76|      0|            objc_sync_enter(self)
   77|      0|            defer { objc_sync_exit(self) }
   78|      0|            if self.cancelRequested {
   79|      0|                return
   80|      0|            }
   81|      0|
   82|      0|            self.session = self.config.sessionFactory.build()
   83|      0|            let usedRequest = self.request!
   84|      0|
   85|      0|            if self.config.sessionFactory.useDataTaskClosure {
   86|      0|                let completionHandler: (Data?, URLResponse?, Error?) -> Void = { data, resp, error in
   87|      0|                    OAuthSwiftHTTPRequest.completionHandler(successHandler: success,
   88|      0|                                                            failureHandler: failure,
   89|      0|                                                            request: usedRequest,
   90|      0|                                                            data: data,
   91|      0|                                                            resp: resp,
   92|      0|                                                            error: error)
   93|      0|                }
   94|      0|                self.task = self.session.dataTask(with: usedRequest, completionHandler: completionHandler)
   95|      0|            } else {
   96|      0|                self.task = self.session.dataTask(with: usedRequest)
   97|      0|            }
   98|      0|
   99|      0|            self.task?.resume()
  100|      0|            self.session.finishTasksAndInvalidate()
  101|      0|
  102|      0|            #if os(iOS)
  103|      0|                #if !OAUTH_APP_EXTENSIONS
  104|      0|                    UIApplication.shared.isNetworkActivityIndicatorVisible = self.config.sessionFactory.isNetworkActivityIndicatorVisible
  105|      0|                #endif
  106|      0|            #endif
  107|      0|        }
  108|      0|    }
  109|       |
  110|       |    /// Function called when receiving data from server.
  111|      0|    public static func completionHandler(successHandler: SuccessHandler?, failureHandler: FailureHandler?, request: URLRequest, data: Data?, resp: URLResponse?, error: Error?) {
  112|      0|        #if os(iOS)
  113|      0|        #if !OAUTH_APP_EXTENSIONS
  114|      0|        UIApplication.shared.isNetworkActivityIndicatorVisible = false
  115|      0|        #endif
  116|      0|        #endif
  117|      0|
  118|      0|        // MARK: failure error returned by server
  119|      0|        if let error = error {
  120|      0|            var oauthError: OAuthSwiftError = .requestError(error: error, request: request)
  121|      0|            let nsError = error as NSError
  122|      0|            if nsError.code == NSURLErrorCancelled {
  123|      0|                oauthError = .cancelled
  124|      0|            } else if nsError.isExpiredToken {
  125|      0|                oauthError = .tokenExpired(error: error)
  126|      0|            }
  127|      0|
  128|      0|            failureHandler?(oauthError)
  129|      0|            return
  130|      0|        }
  131|      0|
  132|      0|        // MARK: failure no response or data returned by server
  133|      0|        guard let response = resp as? HTTPURLResponse, let responseData = data else {
  134|      0|            let badRequestCode = 400
  135|      0|            let localizedDescription = OAuthSwiftHTTPRequest.descriptionForHTTPStatus(badRequestCode, responseString: "")
  136|      0|            var userInfo: [String: Any] = [
  137|      0|                NSLocalizedDescriptionKey: localizedDescription
  138|      0|            ]
  139|      0|            if let response = resp { // there is only no data
  140|      0|                userInfo[OAuthSwiftError.ResponseKey] = response
  141|      0|            }
  142|      0|            if let response = resp as? HTTPURLResponse {
  143|      0|                userInfo["Response-Headers"] = response.allHeaderFields
  144|      0|            }
  145|      0|            let error = NSError(domain: OAuthSwiftError.Domain, code: badRequestCode, userInfo: userInfo)
  146|      0|            failureHandler?(.requestError(error:error, request: request))
  147|      0|            return
  148|      0|        }
  149|      0|
  150|      0|        // MARK: failure code > 400
  151|      0|        guard response.statusCode < 400 else {
  152|      0|            var localizedDescription = ""
  153|      0|            let responseString = String(data: responseData, encoding: OAuthSwiftDataEncoding)
  154|      0|
  155|      0|            // Try to get error information from data as json
  156|      0|            let responseJSON = try? JSONSerialization.jsonObject(with: responseData, options: .mutableContainers)
  157|      0|            var errorCode: String?
  158|      0|            if let responseJSON = responseJSON as? OAuthSwift.Parameters {
  159|      0|                if let code = responseJSON["error"] as? String {
  160|      0|                    errorCode = code
  161|      0|                    if  let description = responseJSON["error_description"] as? String {
  162|      0|                        localizedDescription = NSLocalizedString("\(code) \(description)", comment: "")
  163|      0|                    } else {
  164|      0|                        localizedDescription = NSLocalizedString("\(code)", comment: "")
  165|      0|                    }
  166|      0|                }
  167|      0|            } else {
  168|      0|                localizedDescription = OAuthSwiftHTTPRequest.descriptionForHTTPStatus(response.statusCode, responseString: String(data: responseData, encoding: OAuthSwiftDataEncoding)!)
  169|      0|            }
  170|      0|
  171|      0|            var userInfo: [String: Any] = [
  172|      0|                NSLocalizedDescriptionKey: localizedDescription,
  173|      0|                "Response-Headers": response.allHeaderFields,
  174|      0|                OAuthSwiftError.ResponseKey: response,
  175|      0|                OAuthSwiftError.ResponseDataKey: responseData
  176|      0|            ]
  177|      0|            if let string = responseString {
  178|      0|                userInfo["Response-Body"] = string
  179|      0|            }
  180|      0|            if let urlString = response.url?.absoluteString {
  181|      0|                userInfo[NSURLErrorFailingURLErrorKey] = urlString
  182|      0|            }
  183|      0|
  184|      0|            let error = NSError(domain: NSURLErrorDomain, code: response.statusCode, userInfo: userInfo)
  185|      0|            if error.isExpiredToken {
  186|      0|                failureHandler?(.tokenExpired(error: error))
  187|      0|            } else if errorCode == "authorization_pending" {
  188|      0|                failureHandler?(.authorizationPending(error: error, request: request))
  189|      0|            } else if errorCode == "slow_down" {
  190|      0|                failureHandler?(.slowDown(error: error, request: request))
  191|      0|            } else if errorCode == "access_denied" {
  192|      0|                failureHandler?(.accessDenied(error: error, request: request))
  193|      0|            } else {
  194|      0|                failureHandler?(.requestError(error: error, request: request))
  195|      0|            }
  196|      0|            return
  197|      0|        }
  198|      0|
  199|      0|        // MARK: success
  200|      0|        successHandler?(OAuthSwiftResponse(data: responseData, response: response, request: request))
  201|      0|    }
  202|       |
  203|      0|    open func cancel() {
  204|      0|        // perform lock here to prevent cancel calls on another thread while creating the request
  205|      0|        objc_sync_enter(self)
  206|      0|        defer { objc_sync_exit(self) }
  207|      0|        // either cancel the request if it's already running or set the flag to prohibit creation of the request
  208|      0|        if let task = task {
  209|      0|            task.cancel()
  210|      0|        } else {
  211|      0|            cancelRequested = true
  212|      0|        }
  213|      0|    }
  214|       |
  215|      0|    open func makeRequest() throws -> URLRequest {
  216|      0|        return try OAuthSwiftHTTPRequest.makeRequest(config: self.config)
  217|      0|    }
  218|       |
  219|      0|    open class func makeRequest(config: Config) throws -> URLRequest {
  220|      0|        var request = config.urlRequest
  221|      0|        return try setupRequestForOAuth(request: &request,
  222|      0|                                        parameters: config.parameters,
  223|      0|                                        dataEncoding: config.dataEncoding,
  224|      0|                                        paramsLocation: config.paramsLocation
  225|      0|        )
  226|      0|    }
  227|       |
  228|       |    open class func makeRequest(
  229|       |        url: Foundation.URL,
  230|       |        method: Method,
  231|       |        headers: OAuthSwift.Headers,
  232|       |        parameters: OAuthSwift.Parameters,
  233|       |        dataEncoding: String.Encoding,
  234|       |        body: Data? = nil,
  235|      0|        paramsLocation: ParamsLocation = .authorizationHeader) throws -> URLRequest {
  236|      0|
  237|      0|        var request = URLRequest(url: url)
  238|      0|        request.httpMethod = method.rawValue
  239|      0|        for (key, value) in headers {
  240|      0|            request.setValue(value, forHTTPHeaderField: key)
  241|      0|        }
  242|      0|
  243|      0|        return try setupRequestForOAuth(
  244|      0|            request: &request,
  245|      0|            parameters: parameters,
  246|      0|            dataEncoding: dataEncoding,
  247|      0|            body: body,
  248|      0|            paramsLocation: paramsLocation
  249|      0|        )
  250|      0|    }
  251|       |
  252|       |    open class func setupRequestForOAuth(
  253|       |        request: inout URLRequest,
  254|       |        parameters: OAuthSwift.Parameters,
  255|       |        dataEncoding: String.Encoding = OAuthSwiftDataEncoding,
  256|       |        body: Data? = nil,
  257|      0|        paramsLocation: ParamsLocation = .authorizationHeader) throws -> URLRequest {
  258|      0|
  259|      0|        let finalParameters: OAuthSwift.Parameters
  260|      0|        switch paramsLocation {
  261|      0|        case .authorizationHeader:
  262|      0|            finalParameters = parameters.filter { key, _ in !key.hasPrefix("oauth_") }
  263|      0|        case .requestURIQuery:
  264|      0|            finalParameters = parameters
  265|      0|        }
  266|      0|
  267|      0|        if let b = body {
  268|      0|            request.httpBody = b
  269|      0|        } else {
  270|      0|            if !finalParameters.isEmpty {
  271|      0|                let charset = dataEncoding.charset
  272|      0|                let headers = request.allHTTPHeaderFields ?? [:]
  273|      0|                if request.httpMethod == "GET" || request.httpMethod == "HEAD" || request.httpMethod == "DELETE" {
  274|      0|                    let queryString = finalParameters.urlEncodedQuery
  275|      0|                    let url = request.url!
  276|      0|                    request.url = url.urlByAppending(queryString: queryString)
  277|      0|                    if headers[kHTTPHeaderContentType] == nil {
  278|      0|                        request.setValue("application/x-www-form-urlencoded; charset=\(charset)", forHTTPHeaderField: kHTTPHeaderContentType)
  279|      0|                    }
  280|      0|                } else {
  281|      0|                    if let contentType = headers[kHTTPHeaderContentType], contentType.contains("application/json") {
  282|      0|                        let jsonData = try JSONSerialization.data(withJSONObject: finalParameters, options: [])
  283|      0|                        request.setValue("application/json; charset=\(charset)", forHTTPHeaderField: kHTTPHeaderContentType)
  284|      0|                        request.httpBody = jsonData
  285|      0|                    } else if let contentType = headers[kHTTPHeaderContentType], contentType.contains("multipart/form-data") {
  286|      0|                    // snip
  287|      0|                    } else {
  288|      0|                        request.setValue("application/x-www-form-urlencoded; charset=\(charset)", forHTTPHeaderField: kHTTPHeaderContentType)
  289|      0|                        let queryString = finalParameters.urlEncodedQuery
  290|      0|                        request.httpBody = queryString.data(using: dataEncoding, allowLossyConversion: true)
  291|      0|                    }
  292|      0|                }
  293|      0|            }
  294|      0|        }
  295|      0|        return request
  296|      0|    }
  297|       |
  298|       |}
  299|       |
  300|       |// MARK: - Request configuraiton
  301|       |extension OAuthSwiftHTTPRequest {
  302|       |
  303|       |    /// Configuration for request
  304|       |    public struct Config {
  305|       |
  306|       |        /// URLRequest (url, method, ...)
  307|       |        public var urlRequest: URLRequest
  308|       |        /// These parameters are either added to the query string for GET, HEAD and DELETE requests or
  309|       |        /// used as the http body in case of POST, PUT or PATCH requests.
  310|       |        ///
  311|       |        /// If used in the body they are either encoded as JSON or as encoded plaintext based on the Content-Type header field.
  312|       |        public var parameters: OAuthSwift.Parameters
  313|       |        public let paramsLocation: ParamsLocation
  314|       |        public let dataEncoding: String.Encoding
  315|       |        public let sessionFactory: URLSessionFactory
  316|       |
  317|       |        /// Shortcut
  318|      0|        public var httpMethod: Method {
  319|      0|            if let requestMethod = urlRequest.httpMethod {
  320|      0|                return Method(rawValue: requestMethod) ?? .GET
  321|      0|            }
  322|      0|            return .GET
  323|      0|        }
  324|       |
  325|      0|        public var url: Foundation.URL? {
  326|      0|            return urlRequest.url
  327|      0|        }
  328|       |
  329|       |        // MARK: init
  330|      0|        public init(url: URL, httpMethod: Method = .GET, httpBody: Data? = nil, headers: OAuthSwift.Headers = [:], timeoutInterval: TimeInterval = 60, httpShouldHandleCookies: Bool = false, parameters: OAuthSwift.Parameters, paramsLocation: ParamsLocation = .authorizationHeader, dataEncoding: String.Encoding = OAuthSwiftDataEncoding, sessionFactory: URLSessionFactory = .default) {
  331|      0|            var urlRequest = URLRequest(url: url)
  332|      0|            urlRequest.httpMethod = httpMethod.rawValue
  333|      0|            urlRequest.httpBody = httpBody
  334|      0|            urlRequest.allHTTPHeaderFields = headers
  335|      0|            urlRequest.timeoutInterval = timeoutInterval
  336|      0|            urlRequest.httpShouldHandleCookies = httpShouldHandleCookies
  337|      0|            self.init(urlRequest: urlRequest, parameters: parameters, paramsLocation: paramsLocation, dataEncoding: dataEncoding, sessionFactory: sessionFactory)
  338|      0|        }
  339|       |
  340|      0|        public init(urlRequest: URLRequest, parameters: OAuthSwift.Parameters = [:], paramsLocation: ParamsLocation = .authorizationHeader, dataEncoding: String.Encoding = OAuthSwiftDataEncoding, sessionFactory: URLSessionFactory = .default) {
  341|      0|            self.urlRequest = urlRequest
  342|      0|            self.parameters = parameters
  343|      0|            self.paramsLocation = paramsLocation
  344|      0|            self.dataEncoding = dataEncoding
  345|      0|            self.sessionFactory = sessionFactory
  346|      0|        }
  347|       |
  348|       |        /// Modify request with authentification
  349|      0|        public mutating func updateRequest(credential: OAuthSwiftCredential) {
  350|      0|            let method = self.httpMethod
  351|      0|            let url = self.urlRequest.url!
  352|      0|            let headers: OAuthSwift.Headers = self.urlRequest.allHTTPHeaderFields ?? [:]
  353|      0|            let paramsLocation = self.paramsLocation
  354|      0|            let parameters = self.parameters
  355|      0|
  356|      0|            var signatureUrl = url
  357|      0|            var signatureParameters = parameters
  358|      0|
  359|      0|            // Check if body must be hashed (oauth1)
  360|      0|            let body: Data? = nil
  361|      0|            if method.isBody {
  362|      0|                if let contentType = headers[kHTTPHeaderContentType]?.lowercased() {
  363|      0|
  364|      0|                    if contentType.contains("application/json") {
  365|      0|                        // TODO: oauth_body_hash create body before signing if implementing body hashing
  366|      0|                        /*do {
  367|      0|                         let jsonData: Data = try JSONSerialization.jsonObject(parameters, options: [])
  368|      0|                         request.HTTPBody = jsonData
  369|      0|                         requestHeaders["Content-Length"] = "\(jsonData.length)"
  370|      0|                         body = jsonData
  371|      0|                         }
  372|      0|                         catch {
  373|      0|                         }*/
  374|      0|
  375|      0|                        signatureParameters = [:] // parameters are not used for general signature (could only be used for body hashing
  376|      0|                    }
  377|      0|                    // else other type are not supported, see setupRequestForOAuth()
  378|      0|                }
  379|      0|            }
  380|      0|
  381|      0|            // Need to account for the fact that some consumers will have additional parameters on the
  382|      0|            // querystring, including in the case of fetching a request token. Especially in the case of
  383|      0|            // additional parameters on the request, authorize, or access token exchanges, we need to
  384|      0|            // normalize the URL and add to the parametes collection.
  385|      0|
  386|      0|            var queryStringParameters = OAuthSwift.Parameters()
  387|      0|            var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false )
  388|      0|            if let queryItems = urlComponents?.queryItems {
  389|      0|                for queryItem in queryItems {
  390|      0|                    let value = queryItem.value?.safeStringByRemovingPercentEncoding ?? ""
  391|      0|                    queryStringParameters.updateValue(value, forKey: queryItem.name)
  392|      0|                }
  393|      0|            }
  394|      0|
  395|      0|            // According to the OAuth1.0a spec, the url used for signing is ONLY scheme, path, and query
  396|      0|            if !queryStringParameters.isEmpty {
  397|      0|                urlComponents?.query = nil
  398|      0|                // This is safe to unwrap because these just came from an NSURL
  399|      0|                signatureUrl = urlComponents?.url ?? url
  400|      0|            }
  401|      0|            signatureParameters = signatureParameters.join(queryStringParameters)
  402|      0|
  403|      0|            var requestHeaders = OAuthSwift.Headers()
  404|      0|            switch paramsLocation {
  405|      0|            case .authorizationHeader:
  406|      0|                //Add oauth parameters in the Authorization header
  407|      0|                requestHeaders += credential.makeHeaders(signatureUrl, method: method, parameters: signatureParameters, body: body)
  408|      0|            case .requestURIQuery:
  409|      0|                //Add oauth parameters as request parameters
  410|      0|                self.parameters += credential.authorizationParametersWithSignature(method: method, url: signatureUrl, parameters: signatureParameters, body: body)
  411|      0|            }
  412|      0|
  413|      0|            self.urlRequest.allHTTPHeaderFields = requestHeaders + headers
  414|      0|        }
  415|       |
  416|       |    }
  417|       |}
  418|       |
  419|       |// MARK: - session configuration
  420|       |
  421|       |/// configure how URLSession is initialized
  422|       |public struct URLSessionFactory {
  423|       |
  424|       |    public static let `default` = URLSessionFactory()
  425|       |
  426|       |    public var configuration = URLSessionConfiguration.default
  427|       |    public var queue = OperationQueue.main
  428|       |    /// An optional delegate for the URLSession
  429|       |    public weak var delegate: URLSessionDelegate?
  430|       |
  431|       |    /// Monitor session: see UIApplication.shared.isNetworkActivityIndicatorVisible
  432|       |    public var isNetworkActivityIndicatorVisible = true
  433|       |
  434|       |    /// By default use a closure to receive data from server.
  435|       |    /// If you set to false, you must in `delegate` take care of server response.
  436|       |    /// and maybe call in delegate `OAuthSwiftHTTPRequest.completionHandler`
  437|       |    public var useDataTaskClosure = true
  438|       |
  439|       |    /// Create a new URLSession
  440|      0|    func build() -> URLSession {
  441|      0|        return URLSession(configuration: self.configuration, delegate: self.delegate, delegateQueue: self.queue)
  442|      0|    }
  443|       |}
  444|       |
  445|       |// MARK: - status code mapping
  446|       |
  447|       |extension OAuthSwiftHTTPRequest {
  448|       |
  449|      0|    class func descriptionForHTTPStatus(_ status: Int, responseString: String) -> String {
  450|      0|
  451|      0|        var s = "HTTP Status \(status)"
  452|      0|
  453|      0|        var description: String?
  454|      0|        // http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
  455|      0|        if status == 400 { description = "Bad Request" }
  456|      0|        if status == 401 { description = "Unauthorized" }
  457|      0|        if status == 402 { description = "Payment Required" }
  458|      0|        if status == 403 { description = "Forbidden" }
  459|      0|        if status == 404 { description = "Not Found" }
  460|      0|        if status == 405 { description = "Method Not Allowed" }
  461|      0|        if status == 406 { description = "Not Acceptable" }
  462|      0|        if status == 407 { description = "Proxy Authentication Required" }
  463|      0|        if status == 408 { description = "Request Timeout" }
  464|      0|        if status == 409 { description = "Conflict" }
  465|      0|        if status == 410 { description = "Gone" }
  466|      0|        if status == 411 { description = "Length Required" }
  467|      0|        if status == 412 { description = "Precondition Failed" }
  468|      0|        if status == 413 { description = "Payload Too Large" }
  469|      0|        if status == 414 { description = "URI Too Long" }
  470|      0|        if status == 415 { description = "Unsupported Media Type" }
  471|      0|        if status == 416 { description = "Requested Range Not Satisfiable" }
  472|      0|        if status == 417 { description = "Expectation Failed" }
  473|      0|        if status == 422 { description = "Unprocessable Entity" }
  474|      0|        if status == 423 { description = "Locked" }
  475|      0|        if status == 424 { description = "Failed Dependency" }
  476|      0|        if status == 425 { description = "Unassigned" }
  477|      0|        if status == 426 { description = "Upgrade Required" }
  478|      0|        if status == 427 { description = "Unassigned" }
  479|      0|        if status == 428 { description = "Precondition Required" }
  480|      0|        if status == 429 { description = "Too Many Requests" }
  481|      0|        if status == 430 { description = "Unassigned" }
  482|      0|        if status == 431 { description = "Request Header Fields Too Large" }
  483|      0|        if status == 432 { description = "Unassigned" }
  484|      0|        if status == 500 { description = "Internal Server Error" }
  485|      0|        if status == 501 { description = "Not Implemented" }
  486|      0|        if status == 502 { description = "Bad Gateway" }
  487|      0|        if status == 503 { description = "Service Unavailable" }
  488|      0|        if status == 504 { description = "Gateway Timeout" }
  489|      0|        if status == 505 { description = "HTTP Version Not Supported" }
  490|      0|        if status == 506 { description = "Variant Also Negotiates" }
  491|      0|        if status == 507 { description = "Insufficient Storage" }
  492|      0|        if status == 508 { description = "Loop Detected" }
  493|      0|        if status == 509 { description = "Unassigned" }
  494|      0|        if status == 510 { description = "Not Extended" }
  495|      0|        if status == 511 { description = "Network Authentication Required" }
  496|      0|
  497|      0|        if description != nil {
  498|      0|            s += ": " + description! + ", Response: " + responseString
  499|      0|        }
  500|      0|
  501|      0|        return s
  502|      0|    }
  503|       |
  504|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuthSwiftMultipartData.swift:
    1|       |//
    2|       |//  OAuthSwiftMultipartData.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Tomohiro Kawaji on 12/18/15.
    6|       |//  Copyright (c) 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public struct OAuthSwiftMultipartData {
   12|       |
   13|       |    public var name: String
   14|       |    public var data: Data
   15|       |    public var fileName: String?
   16|       |    public var mimeType: String?
   17|       |
   18|      0|    public init(name: String, data: Data, fileName: String?, mimeType: String?) {
   19|      0|        self.name = name
   20|      0|        self.data = data
   21|      0|        self.fileName = fileName
   22|      0|        self.mimeType = mimeType
   23|      0|    }
   24|       |
   25|       |}
   26|       |
   27|       |extension Data {
   28|       |
   29|      0|    public mutating func append(_ multipartData: OAuthSwiftMultipartData, encoding: String.Encoding, separatorData: Data) {
   30|      0|        var filenameClause = ""
   31|      0|        if let filename = multipartData.fileName {
   32|      0|            filenameClause = "; filename=\"\(filename)\""
   33|      0|        }
   34|      0|        let contentDispositionString = "Content-Disposition: form-data; name=\"\(multipartData.name)\"\(filenameClause)\r\n"
   35|      0|        let contentDispositionData = contentDispositionString.data(using: encoding)!
   36|      0|        self.append(contentDispositionData)
   37|      0|
   38|      0|        if let mimeType = multipartData.mimeType {
   39|      0|            let contentTypeString = "Content-Type: \(mimeType)\r\n"
   40|      0|            let contentTypeData = contentTypeString.data(using: encoding)!
   41|      0|            self.append(contentTypeData)
   42|      0|        }
   43|      0|
   44|      0|        self.append(separatorData)
   45|      0|        self.append(multipartData.data)
   46|      0|        self.append(separatorData)
   47|      0|    }
   48|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuthSwiftResponse.swift:
    1|       |//
    2|       |//  OAuthSwiftResponse.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by phimage on 04/11/16.
    6|       |//  Copyright © 2016 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |/// Response object
   12|       |@objc
   13|       |public class OAuthSwiftResponse: NSObject { // not a struct for objc
   14|       |    /// The data returned by the server.
   15|       |    public var data: Data
   16|       |    /// The server's response to the URL request.
   17|       |    public var response: HTTPURLResponse
   18|       |    /// The URL request sent to the server.
   19|       |    public var request: URLRequest?
   20|       |
   21|      0|    public init(data: Data, response: HTTPURLResponse, request: URLRequest?) {
   22|      0|        self.data = data
   23|      0|        self.response = response
   24|      0|        self.request = request
   25|      0|    }
   26|       |
   27|       |}
   28|       |
   29|       |/// Extends this object to convert data into your business objects
   30|       |extension OAuthSwiftResponse {
   31|       |
   32|      0|    public func dataString(encoding: String.Encoding = OAuthSwiftDataEncoding) -> String? {
   33|      0|        return String(data: self.data, encoding: encoding)
   34|      0|    }
   35|       |
   36|       |    /// `data` converted to string using data encoding
   37|      0|    public var string: String? {
   38|      0|        return dataString()
   39|      0|    }
   40|       |
   41|       |    /// Convert to json object using JSONSerialization
   42|      0|    public func jsonObject(options opt: JSONSerialization.ReadingOptions = []) throws -> Any {
   43|      0|        return try JSONSerialization.jsonObject(with: self.data, options: opt)
   44|      0|    }
   45|       |
   46|       |    /// Convert to object using PropertyListSerialization
   47|      0|    public func propertyList(options opt: PropertyListSerialization.ReadOptions = [], format: UnsafeMutablePointer<PropertyListSerialization.PropertyListFormat>? = nil) throws -> Any {
   48|      0|        return try PropertyListSerialization.propertyList(from: self.data, options: opt, format: format)
   49|      0|    }
   50|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuthSwiftURLHandlerType.swift:
    1|       |//
    2|       |//  OAuthSwiftURLHandlerType.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by phimage on 11/05/15.
    6|       |//  Copyright (c) 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |#if os(iOS) || os(tvOS)
   12|       |    import UIKit
   13|       |#elseif os(watchOS)
   14|       |    import WatchKit
   15|       |#elseif os(OSX)
   16|       |    import AppKit
   17|       |#endif
   18|       |
   19|       |@objc public protocol OAuthSwiftURLHandlerType {
   20|       |    func handle(_ url: URL)
   21|       |}
   22|       |
   23|       |// MARK: Open externally
   24|       |open class OAuthSwiftOpenURLExternally: OAuthSwiftURLHandlerType {
   25|       |
   26|       |    public static var sharedInstance: OAuthSwiftOpenURLExternally = OAuthSwiftOpenURLExternally()
   27|       |
   28|      0|    @objc open func handle(_ url: URL) {
   29|      0|        #if os(iOS) || os(tvOS)
   30|      0|            #if !OAUTH_APP_EXTENSIONS
   31|      0|                UIApplication.shared.openURL(url)
   32|      0|            #endif
   33|      0|        #elseif os(watchOS)
   34|      0|        // WATCHOS: not implemented
   35|      0|        #elseif os(OSX)
   36|      0|            NSWorkspace.shared.open(url)
   37|      0|        #endif
   38|      0|    }
   39|       |}
   40|       |
   41|       |// MARK: Open SFSafariViewController
   42|       |#if os(iOS)
   43|       |import SafariServices
   44|       |
   45|       |    @available(iOS 9.0, *)
   46|       |    open class SafariURLHandler: NSObject, OAuthSwiftURLHandlerType, SFSafariViewControllerDelegate {
   47|       |
   48|       |        public typealias UITransion = (_ controller: SFSafariViewController, _ handler: SafariURLHandler) -> Void
   49|       |
   50|       |        weak open var oauthSwift: OAuthSwift?
   51|       |        open var present: UITransion
   52|       |        open var dismiss: UITransion
   53|       |        /// retains observers
   54|       |        var observers = [String: NSObjectProtocol]()
   55|       |
   56|      0|        open var factory: (_ URL: URL) -> SFSafariViewController = {URL in
   57|      0|            return SFSafariViewController(url: URL)
   58|      0|        }
   59|       |
   60|       |        /// delegates
   61|       |        open weak var delegate: SFSafariViewControllerDelegate?
   62|       |
   63|       |        // configure default presentation and dismissal code
   64|       |
   65|       |        open var animated: Bool = true
   66|       |        open var presentCompletion: (() -> Void)?
   67|       |        open var dismissCompletion: (() -> Void)?
   68|       |        open var delay: UInt32? = 1
   69|       |
   70|       |        /// init
   71|      0|        public init(viewController: UIViewController, oauthSwift: OAuthSwift) {
   72|      0|            self.oauthSwift = oauthSwift
   73|      0|            self.present = { [weak viewController] controller, handler in
   74|      0|                viewController?.present(controller, animated: handler.animated, completion: handler.presentCompletion)
   75|      0|            }
   76|      0|            self.dismiss = { [weak viewController] _, handler in
   77|      0|                viewController?.dismiss(animated: handler.animated, completion: handler.dismissCompletion)
   78|      0|            }
   79|      0|        }
   80|       |
   81|      0|        public init(present: @escaping UITransion, dismiss: @escaping UITransion, oauthSwift: OAuthSwift) {
   82|      0|            self.oauthSwift = oauthSwift
   83|      0|            self.present = present
   84|      0|            self.dismiss = dismiss
   85|      0|        }
   86|       |
   87|      0|        @objc open func handle(_ url: URL) {
   88|      0|            let controller = factory(url)
   89|      0|            controller.delegate = self
   90|      0|
   91|      0|            // present controller in main thread
   92|      0|            OAuthSwift.main { [weak self] in
   93|      0|                guard let this = self else {
   94|      0|                    return
   95|      0|                }
   96|      0|                if let delay = this.delay { // sometimes safari show a blank view..
   97|      0|                    sleep(delay)
   98|      0|                }
   99|      0|                this.present(controller, this)
  100|      0|            }
  101|      0|
  102|      0|            let key = UUID().uuidString
  103|      0|
  104|      0|            observers[key] = OAuthSwift.notificationCenter.addObserver(
  105|      0|                forName: NSNotification.Name.OAuthSwiftHandleCallbackURL,
  106|      0|                object: nil,
  107|      0|                queue: OperationQueue.main,
  108|      0|                using: { [weak self] _ in
  109|      0|                    guard let this = self else {
  110|      0|                        return
  111|      0|                    }
  112|      0|                    if let observer = this.observers[key] {
  113|      0|                        OAuthSwift.notificationCenter.removeObserver(observer)
  114|      0|                        this.observers.removeValue(forKey: key)
  115|      0|                    }
  116|      0|                    OAuthSwift.main {
  117|      0|                        this.dismiss(controller, this)
  118|      0|                    }
  119|      0|                }
  120|      0|            )
  121|      0|        }
  122|       |
  123|       |        /// Clear internal observers on authentification flow
  124|      0|        open func clearObservers() {
  125|      0|            clearLocalObservers()
  126|      0|            self.oauthSwift?.removeCallbackNotificationObserver()
  127|      0|        }
  128|       |
  129|      0|        open func clearLocalObservers() {
  130|      0|            for (_, observer) in observers {
  131|      0|                OAuthSwift.notificationCenter.removeObserver(observer)
  132|      0|            }
  133|      0|            observers.removeAll()
  134|      0|        }
  135|       |
  136|       |        /// SFSafariViewControllerDelegate
  137|      0|        public func safariViewController(_ controller: SFSafariViewController, activityItemsFor URL: Foundation.URL, title: String?) -> [UIActivity] {
  138|      0|            return self.delegate?.safariViewController?(controller, activityItemsFor: URL, title: title) ?? []
  139|      0|        }
  140|       |
  141|      0|        public func safariViewControllerDidFinish(_ controller: SFSafariViewController) {
  142|      0|            // "Done" pressed
  143|      0|            self.clearObservers()
  144|      0|            self.delegate?.safariViewControllerDidFinish?(controller)
  145|      0|        }
  146|       |
  147|      0|        public func safariViewController(_ controller: SFSafariViewController, didCompleteInitialLoad didLoadSuccessfully: Bool) {
  148|      0|            self.delegate?.safariViewController?(controller, didCompleteInitialLoad: didLoadSuccessfully)
  149|      0|        }
  150|       |
  151|       |    }
  152|       |
  153|       |#endif
  154|       |
  155|       |// MARK: Open url using NSExtensionContext
  156|       |open class ExtensionContextURLHandler: OAuthSwiftURLHandlerType {
  157|       |
  158|       |    fileprivate var extensionContext: NSExtensionContext
  159|       |
  160|      0|    public init(extensionContext: NSExtensionContext) {
  161|      0|        self.extensionContext = extensionContext
  162|      0|    }
  163|       |
  164|      0|    @objc open func handle(_ url: URL) {
  165|      0|        extensionContext.open(url, completionHandler: nil)
  166|      0|    }
  167|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/OAuthWebViewController.swift:
    1|       |//
    2|       |//  OAuthWebViewController.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 2/11/15.
    6|       |//  Copyright (c) 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |#if os(iOS)  || os(tvOS)
   12|       |    import UIKit
   13|       |    public typealias OAuthViewController = UIViewController
   14|       |#elseif os(watchOS)
   15|       |    import WatchKit
   16|       |    public typealias OAuthViewController = WKInterfaceController
   17|       |#elseif os(OSX)
   18|       |    import AppKit
   19|       |    public typealias OAuthViewController = NSViewController
   20|       |#endif
   21|       |
   22|       |/// Delegate for OAuthWebViewController
   23|       |public protocol OAuthWebViewControllerDelegate: class {
   24|       |
   25|       |    #if os(iOS) || os(tvOS)
   26|       |    /// Did web view presented (work only without navigation controller)
   27|       |    func oauthWebViewControllerDidPresent()
   28|       |    /// Did web view dismiss (work only without navigation controller)
   29|       |    func oauthWebViewControllerDidDismiss()
   30|       |    #endif
   31|       |
   32|       |    func oauthWebViewControllerWillAppear()
   33|       |    func oauthWebViewControllerDidAppear()
   34|       |    func oauthWebViewControllerWillDisappear()
   35|       |    func oauthWebViewControllerDidDisappear()
   36|       |}
   37|       |
   38|       |/// A web view controller, which handler OAuthSwift authentification.
   39|       |open class OAuthWebViewController: OAuthViewController, OAuthSwiftURLHandlerType {
   40|       |
   41|       |    #if os(iOS) || os(tvOS) || os(OSX)
   42|       |    /// Delegate for this view
   43|       |    public weak var delegate: OAuthWebViewControllerDelegate?
   44|       |    #endif
   45|       |
   46|       |    #if os(iOS) || os(tvOS)
   47|       |    /// If controller have an navigation controller, application top view controller could be used if true
   48|       |    public var useTopViewControlerInsteadOfNavigation = false
   49|       |
   50|       |    /// Set false to disable present animation.
   51|       |    public var presentViewControllerAnimated = true
   52|       |    /// Set false to disable dismiss animation.
   53|       |    public var dismissViewControllerAnimated = true
   54|       |
   55|      0|    public var topViewController: UIViewController? {
   56|      0|        #if !OAUTH_APP_EXTENSIONS
   57|      0|            return UIApplication.topViewController
   58|      0|        #else
   59|      0|            return nil
   60|      0|        #endif
   61|      0|    }
   62|       |    #elseif os(OSX)
   63|       |    /// How to present this view controller if parent view controller set
   64|       |    public enum Present {
   65|       |        case asModalWindow
   66|       |        case asSheet
   67|       |        case asPopover(relativeToRect: NSRect, ofView : NSView, preferredEdge: NSRectEdge, behavior: NSPopover.Behavior)
   68|       |        case transitionFrom(fromViewController: NSViewController, options: NSViewController.TransitionOptions)
   69|       |        case animator(animator: NSViewControllerPresentationAnimator)
   70|       |        case segue(segueIdentifier: String)
   71|       |    }
   72|       |    public var present: Present = .asModalWindow
   73|       |    #endif
   74|       |
   75|      0|    open func handle(_ url: URL) {
   76|      0|        // do UI in main thread
   77|      0|        OAuthSwift.main { [unowned self] in
   78|      0|             self.doHandle(url)
   79|      0|        }
   80|      0|    }
   81|       |
   82|       |    #if os(watchOS)
   83|       |    public static var userActivityType: String = "org.github.dongri.oauthswift.connect"
   84|       |    #endif
   85|       |
   86|      0|    open func doHandle(_ url: URL) {
   87|      0|        #if os(iOS) || os(tvOS)
   88|      0|            let completion: () -> Void = { [unowned self] in
   89|      0|                self.delegate?.oauthWebViewControllerDidPresent()
   90|      0|            }
   91|      0|            if let navigationController = self.navigationController, (!useTopViewControlerInsteadOfNavigation || self.topViewController == nil) {
   92|      0|                navigationController.pushViewController(self, animated: presentViewControllerAnimated)
   93|      0|            } else if let p = self.parent {
   94|      0|                p.present(self, animated: presentViewControllerAnimated, completion: completion)
   95|      0|            } else if let topViewController = topViewController {
   96|      0|                topViewController.present(self, animated: presentViewControllerAnimated, completion: completion)
   97|      0|            } else {
   98|      0|                // assert no presentation
   99|      0|                assertionFailure("Failed to present. Maybe add a parent")
  100|      0|            }
  101|      0|        #elseif os(watchOS)
  102|      0|            if url.scheme == "http" || url.scheme == "https" {
  103|      0|                self.updateUserActivity(OAuthWebViewController.userActivityType, userInfo: nil, webpageURL: url)
  104|      0|            }
  105|      0|        #elseif os(OSX)
  106|      0|            if let p = self.parent { // default behaviour if this controller affected as child controller
  107|      0|                switch self.present {
  108|      0|                case .asSheet:
  109|      0|                    p.presentAsSheet(self)
  110|      0|                case .asModalWindow:
  111|      0|                    p.presentAsModalWindow(self)
  112|      0|                    // FIXME: if we present as window, window close must detected and oauthswift.cancel() must be called...
  113|      0|                case .asPopover(let positioningRect, let positioningView, let preferredEdge, let behavior):
  114|      0|                    p.present(self, asPopoverRelativeTo: positioningRect, of: positioningView, preferredEdge: preferredEdge, behavior: behavior)
  115|      0|                case .transitionFrom(let fromViewController, let options):
  116|      0|                    let completion: () -> Void = { /*[unowned self] in*/
  117|      0|                        //self.delegate?.oauthWebViewControllerDidPresent()
  118|      0|                    }
  119|      0|                    p.transition(from: fromViewController, to: self, options: options, completionHandler: completion)
  120|      0|                case .animator(let animator):
  121|      0|                    p.present(self, animator: animator)
  122|      0|                case .segue(let segueIdentifier):
  123|      0|                    p.performSegue(withIdentifier: segueIdentifier, sender: self) // The segue must display self.view
  124|      0|                }
  125|      0|            } else if let window = self.view.window {
  126|      0|                window.makeKeyAndOrderFront(nil)
  127|      0|            } else {
  128|      0|                assertionFailure("Failed to present. Add controller into a window or add a parent")
  129|      0|            }
  130|      0|            // or create an NSWindow or NSWindowController (/!\ keep a strong reference on it)
  131|      0|        #endif
  132|      0|    }
  133|       |
  134|      0|    open func dismissWebViewController() {
  135|      0|        #if os(iOS) || os(tvOS)
  136|      0|            let completion: () -> Void = { [unowned self] in
  137|      0|                self.delegate?.oauthWebViewControllerDidDismiss()
  138|      0|            }
  139|      0|            if let navigationController = self.navigationController, (!useTopViewControlerInsteadOfNavigation || self.topViewController == nil) {
  140|      0|                navigationController.popViewController(animated: dismissViewControllerAnimated)
  141|      0|            } else if let parentViewController = self.parent {
  142|      0|                // The presenting view controller is responsible for dismissing the view controller it presented
  143|      0|                parentViewController.dismiss(animated: dismissViewControllerAnimated, completion: completion)
  144|      0|            } else if let topViewController = topViewController {
  145|      0|                topViewController.dismiss(animated: dismissViewControllerAnimated, completion: completion)
  146|      0|            } else {
  147|      0|                // keep old code...
  148|      0|                self.dismiss(animated: dismissViewControllerAnimated, completion: completion)
  149|      0|            }
  150|      0|        #elseif os(watchOS)
  151|      0|            self.dismiss()
  152|      0|        #elseif os(OSX)
  153|      0|        if self.presentingViewController != nil {
  154|      0|                self.dismiss(nil)
  155|      0|                if self.parent != nil {
  156|      0|                    self.removeFromParent()
  157|      0|                }
  158|      0|            } else if let window = self.view.window {
  159|      0|                window.performClose(nil)
  160|      0|            }
  161|      0|        #endif
  162|      0|    }
  163|       |
  164|       |    // MARK: overrides
  165|       |    #if os(iOS) || os(tvOS)
  166|      0|    open override func viewWillAppear(_ animated: Bool) {
  167|      0|        self.delegate?.oauthWebViewControllerWillAppear()
  168|      0|    }
  169|      0|    open override func viewDidAppear(_ animated: Bool) {
  170|      0|        self.delegate?.oauthWebViewControllerDidAppear()
  171|      0|    }
  172|      0|    open override func viewWillDisappear(_ animated: Bool) {
  173|      0|        self.delegate?.oauthWebViewControllerWillDisappear()
  174|      0|    }
  175|      0|    open override func viewDidDisappear(_ animated: Bool) {
  176|      0|        self.delegate?.oauthWebViewControllerDidDisappear()
  177|      0|    }
  178|       |    #elseif os(OSX)
  179|       |    open override func viewWillAppear() {
  180|       |        self.delegate?.oauthWebViewControllerWillAppear()
  181|       |    }
  182|       |    open override func viewDidAppear() {
  183|       |        self.delegate?.oauthWebViewControllerDidAppear()
  184|       |    }
  185|       |    open override func viewWillDisappear() {
  186|       |        self.delegate?.oauthWebViewControllerWillDisappear()
  187|       |    }
  188|       |    open override func viewDidDisappear() {
  189|       |        self.delegate?.oauthWebViewControllerDidDisappear()
  190|       |    }
  191|       |
  192|       |    #endif
  193|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/Objc.swift:
    1|       |//
    2|       |//  Objc.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by phimage on 05/11/16.
    6|       |//  Copyright © 2016 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension OAuthSwift {
   12|       |    // swiftlint:disable:next type_name
   13|       |    public typealias Obj_FailureHandler = (_ error: Error) -> Void
   14|       |}
   15|       |
   16|       |extension OAuth1Swift {
   17|       |
   18|      0|    open func objc_authorize(withCallbackURL url: URLConvertible, success: @escaping TokenSuccessHandler, failure: Obj_FailureHandler?) -> OAuthSwiftRequestHandle? {
   19|      0|        guard let callbackURL = url.url else {
   20|      0|            failure?(OAuthSwiftError.encodingError(urlString: url.string))
   21|      0|            return nil
   22|      0|        }
   23|      0|        return authorize(withCallbackURL: callbackURL, success: success, failure: failure)
   24|      0|    }
   25|       |
   26|       |}
   27|       |
   28|       |extension OAuth2Swift {
   29|       |
   30|      0|    open func objc_authorize(withCallbackURL url: URLConvertible, scope: String, state: String, parameters: Parameters = [:], headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: Obj_FailureHandler?) -> OAuthSwiftRequestHandle? {
   31|      0|        guard url.url != nil else {
   32|      0|            failure?(OAuthSwiftError.encodingError(urlString: url.string))
   33|      0|            return nil
   34|      0|        }
   35|      0|        return authorize(withCallbackURL: url, scope: scope, state: state, parameters: parameters, headers: headers, success: success, failure: failure)
   36|      0|    }
   37|       |
   38|      0|	open func objc_renewAccessToken(withRefreshToken refreshToken: String, headers: OAuthSwift.Headers? = nil, success: @escaping TokenSuccessHandler, failure: Obj_FailureHandler?) -> OAuthSwiftRequestHandle? {
   39|      0|		return renewAccessToken(withRefreshToken: refreshToken, headers: headers, success: success, failure: failure)
   40|      0|	}
   41|       |
   42|       |}
   43|       |
   44|       |extension OAuthSwiftHTTPRequest {
   45|       |    // swiftlint:disable:next type_name
   46|       |    public typealias Obj_FailureHandler = (_ error: Error) -> Void
   47|       |}
   48|       |
   49|       |extension OAuthSwiftClient {
   50|       |
   51|      0|    open func objc_request(_ url: URLConvertible, method: OAuthSwiftHTTPRequest.Method, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, body: Data? = nil, checkTokenExpiration: Bool = true, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.Obj_FailureHandler?) -> OAuthSwiftRequestHandle? {
   52|      0|        return request(url, method: method, parameters: parameters, headers: headers, body: body, checkTokenExpiration: checkTokenExpiration, success: success, failure: failure)
   53|      0|    }
   54|       |
   55|      0|    open func get(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.Obj_FailureHandler?) -> OAuthSwiftRequestHandle? {
   56|      0|        return self.request(url, method: .GET, parameters: parameters, headers: headers, success: success, failure: failure)
   57|      0|    }
   58|       |
   59|      0|    open func post(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, body: Data? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.Obj_FailureHandler?) -> OAuthSwiftRequestHandle? {
   60|      0|        return self.request(url, method: .POST, parameters: parameters, headers: headers, body: body, success: success, failure: failure)
   61|      0|    }
   62|       |
   63|      0|    open func put(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, body: Data? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.Obj_FailureHandler?) -> OAuthSwiftRequestHandle? {
   64|      0|        return self.request(url, method: .PUT, parameters: parameters, headers: headers, body: body, success: success, failure: failure)
   65|      0|    }
   66|       |
   67|      0|    open func delete(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.Obj_FailureHandler?) -> OAuthSwiftRequestHandle? {
   68|      0|        return self.request(url, method: .DELETE, parameters: parameters, headers: headers, success: success, failure: failure)
   69|      0|    }
   70|       |
   71|      0|    open func patch(_ url: URLConvertible, parameters: OAuthSwift.Parameters = [:], headers: OAuthSwift.Headers? = nil, success: OAuthSwiftHTTPRequest.SuccessHandler?, failure: OAuthSwiftHTTPRequest.Obj_FailureHandler?) -> OAuthSwiftRequestHandle? {
   72|      0|        return self.request(url, method: .PATCH, parameters: parameters, headers: headers, success: success, failure: failure)
   73|      0|    }
   74|       |
   75|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/SHA1.swift:
    1|       |//
    2|       |//  SHA1.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 1/28/15.
    6|       |//  Copyright (c) 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |class SHA1 {
   12|       |
   13|       |    private var message: [UInt8]
   14|       |
   15|       |    fileprivate let h: [UInt32] = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]
   16|       |
   17|      0|    init(_ message: Data) {
   18|      0|        self.message = message.bytes
   19|      0|    }
   20|      0|    init(_ message: [UInt8]) {
   21|      0|        self.message = message
   22|      0|    }
   23|       |
   24|       |    /// Common part for hash calculation. Prepare header data.
   25|      0|    func prepare(_ message: [UInt8], _ blockSize: Int, _ allowance: Int) -> [UInt8] {
   26|      0|        var tmpMessage = message
   27|      0|
   28|      0|        // Step 1. Append Padding Bits
   29|      0|        tmpMessage.append(0x80) // append one bit (Byte with one bit) to message
   30|      0|
   31|      0|        // append "0" bit until message length in bits ≡ 448 (mod 512)
   32|      0|        var msgLength = tmpMessage.count
   33|      0|        var counter = 0
   34|      0|
   35|      0|        while msgLength % blockSize != (blockSize - allowance) {
   36|      0|            counter += 1
   37|      0|            msgLength += 1
   38|      0|        }
   39|      0|
   40|      0|        tmpMessage += [UInt8](repeating: 0, count: counter)
   41|      0|
   42|      0|        return tmpMessage
   43|      0|    }
   44|       |
   45|      0|    func calculate() -> [UInt8] {
   46|      0|        var tmpMessage = self.prepare(self.message, 64, 64 / 8)
   47|      0|
   48|      0|        // hash values
   49|      0|        var hh = h
   50|      0|
   51|      0|        // append message length, in a 64-bit big-endian integer. So now the message length is a multiple of 512 bits.
   52|      0|        tmpMessage += (self.message.count * 8).bytes(64 / 8)
   53|      0|
   54|      0|        // Process the message in successive 512-bit chunks:
   55|      0|        let chunkSizeBytes = 512 / 8 // 64
   56|      0|        for chunk in BytesSequence(data: tmpMessage, chunkSize: chunkSizeBytes) {
   57|      0|            // break chunk into sixteen 32-bit words M[j], 0 ≤ j ≤ 15, big-endian
   58|      0|            // Extend the sixteen 32-bit words into eighty 32-bit words:
   59|      0|            var M: [UInt32] = [UInt32](repeating: 0, count: 80)
   60|      0|            for x in 0..<M.count {
   61|      0|                switch x {
   62|      0|                case 0...15:
   63|      0|
   64|      0|                    let memorySize = MemoryLayout<UInt32>.size
   65|      0|                    let start = chunk.startIndex + (x * memorySize)
   66|      0|                    let end = start + memorySize
   67|      0|                    let le = chunk[start..<end].toUInt32
   68|      0|                    M[x] = le.bigEndian
   69|      0|                default:
   70|      0|                    M[x] = rotateLeft(M[x-3] ^ M[x-8] ^ M[x-14] ^ M[x-16], n: 1)
   71|      0|                }
   72|      0|            }
   73|      0|
   74|      0|            var A = hh[0]
   75|      0|            var B = hh[1]
   76|      0|            var C = hh[2]
   77|      0|            var D = hh[3]
   78|      0|            var E = hh[4]
   79|      0|
   80|      0|            // Main loop
   81|      0|            for j in 0...79 {
   82|      0|                var f: UInt32 = 0
   83|      0|                var k: UInt32 = 0
   84|      0|
   85|      0|                switch j {
   86|      0|                case 0...19:
   87|      0|                    f = (B & C) | ((~B) & D)
   88|      0|                    k = 0x5A827999
   89|      0|                case 20...39:
   90|      0|                    f = B ^ C ^ D
   91|      0|                    k = 0x6ED9EBA1
   92|      0|                case 40...59:
   93|      0|                    f = (B & C) | (B & D) | (C & D)
   94|      0|                    k = 0x8F1BBCDC
   95|      0|                case 60...79:
   96|      0|                    f = B ^ C ^ D
   97|      0|                    k = 0xCA62C1D6
   98|      0|                default:
   99|      0|                    break
  100|      0|                }
  101|      0|
  102|      0|                let temp = (rotateLeft(A, n: 5) &+ f &+ E &+ M[j] &+ k) & 0xffffffff
  103|      0|                E = D
  104|      0|                D = C
  105|      0|                C = rotateLeft(B, n: 30)
  106|      0|                B = A
  107|      0|                A = temp
  108|      0|
  109|      0|            }
  110|      0|
  111|      0|            hh[0] = (hh[0] &+ A) & 0xffffffff
  112|      0|            hh[1] = (hh[1] &+ B) & 0xffffffff
  113|      0|            hh[2] = (hh[2] &+ C) & 0xffffffff
  114|      0|            hh[3] = (hh[3] &+ D) & 0xffffffff
  115|      0|            hh[4] = (hh[4] &+ E) & 0xffffffff
  116|      0|        }
  117|      0|
  118|      0|        // Produce the final hash value (big-endian) as a 160 bit number:
  119|      0|        var result = [UInt8]()
  120|      0|        result.reserveCapacity(hh.count / 4)
  121|      0|        hh.forEach {
  122|      0|            let item = $0.bigEndian
  123|      0|            result += [UInt8(item & 0xff), UInt8((item >> 8) & 0xff), UInt8((item >> 16) & 0xff), UInt8((item >> 24) & 0xff)]
  124|      0|        }
  125|      0|
  126|      0|        return result
  127|      0|    }
  128|       |
  129|      0|    private func rotateLeft(_ v: UInt32, n: UInt32) -> UInt32 {
  130|      0|        return ((v << n) & 0xFFFFFFFF) | (v >> (32 - n))
  131|      0|    }
  132|       |
  133|       |}
  134|       |
  135|       |private struct BytesSequence<D: RandomAccessCollection>: Sequence where D.Iterator.Element == UInt8, D.Index == Int {
  136|       |    let data: D
  137|       |    let chunkSize: Int
  138|       |
  139|      0|    func makeIterator() -> AnyIterator<D.SubSequence> {
  140|      0|        var offset = data.startIndex
  141|      0|        return AnyIterator {
  142|      0|            let end = Swift.min(self.chunkSize, self.data.count - offset)
  143|      0|            let result = self.data[offset..<offset + end]
  144|      0|            offset = offset.advanced(by: result.count)
  145|      0|            if !result.isEmpty {
  146|      0|                return result
  147|      0|            }
  148|      0|            return nil
  149|      0|        }
  150|      0|    }
  151|       |
  152|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/String+OAuthSwift.swift:
    1|       |//
    2|       |//  String+OAuthSwift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 6/21/14.
    6|       |//  Copyright (c) 2014 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension String {
   12|       |
   13|      0|    var parametersFromQueryString: [String: String] {
   14|      0|        return dictionaryBySplitting("&", keyValueSeparator: "=")
   15|      0|    }
   16|       |
   17|       |    /// Encodes url string making it ready to be passed as a query parameter. This encodes pretty much everything apart from
   18|       |    /// alphanumerics and a few other characters compared to standard query encoding.
   19|      0|    var urlEncoded: String {
   20|      0|        let customAllowedSet = CharacterSet(charactersIn: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~")
   21|      0|        return self.addingPercentEncoding(withAllowedCharacters: customAllowedSet)!
   22|      0|    }
   23|       |
   24|      0|    var urlQueryEncoded: String? {
   25|      0|        return self.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)
   26|      0|    }
   27|       |
   28|       |    /// Returns new url query string by appending query parameter encoding it first, if specified.
   29|      0|    func urlQueryByAppending(parameter name: String, value: String, encode: Bool = true, _ encodeError: ((String, String) -> Void)? = nil) -> String? {
   30|      0|        if value.isEmpty {
   31|      0|            return self
   32|      0|        } else if let value = encode ? value.urlQueryEncoded : value {
   33|      0|            return "\(self)\(self.isEmpty ? "" : "&")\(name)=\(value)"
   34|      0|        } else {
   35|      0|            encodeError?(name, value)
   36|      0|            return nil
   37|      0|        }
   38|      0|    }
   39|       |
   40|       |    /// Returns new url string by appending query string at the end.
   41|      0|    func urlByAppending(query: String) -> String {
   42|      0|        return "\(self)\(self.contains("?") ? "&" : "?")\(query)"
   43|      0|    }
   44|       |
   45|      0|    fileprivate func dictionaryBySplitting(_ elementSeparator: String, keyValueSeparator: String) -> [String: String] {
   46|      0|        var string = self
   47|      0|
   48|      0|        if hasPrefix(elementSeparator) {
   49|      0|            string = String(dropFirst(1))
   50|      0|        }
   51|      0|
   52|      0|        var parameters = [String: String]()
   53|      0|
   54|      0|        let scanner = Scanner(string: string)
   55|      0|
   56|      0|        var key: NSString?
   57|      0|        var value: NSString?
   58|      0|
   59|      0|        while !scanner.isAtEnd {
   60|      0|            key = nil
   61|      0|            scanner.scanUpTo(keyValueSeparator, into: &key)
   62|      0|            scanner.scanString(keyValueSeparator, into: nil)
   63|      0|
   64|      0|            value = nil
   65|      0|            scanner.scanUpTo(elementSeparator, into: &value)
   66|      0|            scanner.scanString(elementSeparator, into: nil)
   67|      0|
   68|      0|            if let key = key as String? {
   69|      0|                if let value = value as String? {
   70|      0|                    if key.contains(elementSeparator) {
   71|      0|                        var keys = key.components(separatedBy: elementSeparator)
   72|      0|                        if let key = keys.popLast() {
   73|      0|                            parameters.updateValue(value, forKey: String(key))
   74|      0|                        }
   75|      0|                        for flag in keys {
   76|      0|                            parameters.updateValue("", forKey: flag)
   77|      0|                        }
   78|      0|                    } else {
   79|      0|                        parameters.updateValue(value, forKey: key)
   80|      0|                    }
   81|      0|                } else {
   82|      0|                    parameters.updateValue("", forKey: key)
   83|      0|                }
   84|      0|            }
   85|      0|        }
   86|      0|
   87|      0|        return parameters
   88|      0|    }
   89|       |
   90|      0|    public var headerDictionary: OAuthSwift.Headers {
   91|      0|        return dictionaryBySplitting(",", keyValueSeparator: "=")
   92|      0|    }
   93|       |
   94|      0|    var safeStringByRemovingPercentEncoding: String {
   95|      0|        return self.removingPercentEncoding ?? self
   96|      0|    }
   97|       |
   98|      0|    mutating func dropLast() {
   99|      0|        self.remove(at: self.index(before: self.endIndex))
  100|      0|    }
  101|       |
  102|      0|    subscript (bounds: CountableClosedRange<Int>) -> String {
  103|      0|        let start = index(startIndex, offsetBy: bounds.lowerBound)
  104|      0|        let end = index(startIndex, offsetBy: bounds.upperBound)
  105|      0|        return String(self[start...end])
  106|      0|    }
  107|       |
  108|      0|    subscript (bounds: CountableRange<Int>) -> String {
  109|      0|        let start = index(startIndex, offsetBy: bounds.lowerBound)
  110|      0|        let end = index(startIndex, offsetBy: bounds.upperBound)
  111|      0|        return String(self[start..<end])
  112|      0|    }
  113|       |}
  114|       |
  115|       |extension String.Encoding {
  116|       |
  117|      0|    var charset: String {
  118|      0|        let charset = CFStringConvertEncodingToIANACharSetName(CFStringConvertNSStringEncodingToEncoding(self.rawValue))
  119|      0|         // swiftlint:disable:next force_cast superfluous_disable_command
  120|      0|        return charset! as String
  121|      0|    }
  122|       |
  123|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/UIApplication+OAuthSwift.swift:
    1|       |//
    2|       |//  UIApplication+OAuthSwift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by phimage on 11/12/15.
    6|       |//  Copyright © 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |    import UIKit
   11|       |
   12|       |    extension UIApplication {
   13|      0|        @nonobjc static var topViewController: UIViewController? {
   14|      0|            #if !OAUTH_APP_EXTENSIONS
   15|      0|                return UIApplication.shared.topViewController
   16|      0|            #else
   17|      0|                return nil
   18|      0|            #endif
   19|      0|        }
   20|       |
   21|      0|        var topViewController: UIViewController? {
   22|      0|            guard let rootController = self.keyWindow?.rootViewController else {
   23|      0|                return nil
   24|      0|            }
   25|      0|            return UIViewController.topViewController(rootController)
   26|      0|        }
   27|       |    }
   28|       |
   29|       |    extension UIViewController {
   30|       |
   31|      0|        static func topViewController(_ viewController: UIViewController) -> UIViewController {
   32|      0|            guard let presentedViewController = viewController.presentedViewController else {
   33|      0|                return viewController
   34|      0|            }
   35|      0|            #if !topVCCastDisabled
   36|      0|            if let navigationController = presentedViewController as? UINavigationController {
   37|      0|                if let visibleViewController = navigationController.visibleViewController {
   38|      0|                    return topViewController(visibleViewController)
   39|      0|                }
   40|      0|            } else if let tabBarController = presentedViewController as? UITabBarController {
   41|      0|                if let selectedViewController = tabBarController.selectedViewController {
   42|      0|                    return topViewController(selectedViewController)
   43|      0|                }
   44|      0|            }
   45|      0|            #endif
   46|      0|            return topViewController(presentedViewController)
   47|      0|        }
   48|       |    }
   49|       |
   50|       |#endif

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/URL+OAuthSwift.swift:
    1|       |//
    2|       |//  URL+OAuthSwift.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 6/21/14.
    6|       |//  Copyright (c) 2014 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension URL {
   12|       |
   13|      0|    func urlByAppending(queryString: String) -> URL {
   14|      0|        if queryString.utf16.isEmpty {
   15|      0|            return self
   16|      0|        }
   17|      0|
   18|      0|        var absoluteURLString = absoluteString
   19|      0|
   20|      0|        if absoluteURLString.hasSuffix("?") {
   21|      0|            absoluteURLString.dropLast()
   22|      0|        }
   23|      0|
   24|      0|        let string = absoluteURLString + (absoluteURLString.range(of: "?") != nil ? "&" : "?") + queryString
   25|      0|
   26|      0|        return URL(string: string)!
   27|      0|    }
   28|       |
   29|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/URLConvertible.swift:
    1|       |//
    2|       |//  URLConvertible.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Arman Arutyunov on 07/02/2019.
    6|       |//  Copyright © 2019 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |/// Either a String representing URL or a URL itself
   12|       |public protocol URLConvertible {
   13|       |	var string: String { get }
   14|       |	var url: URL? { get }
   15|       |}
   16|       |
   17|       |extension String: URLConvertible {
   18|      0|	public var string: String {
   19|      0|		return self
   20|      0|	}
   21|       |
   22|      0|	public var url: URL? {
   23|      0|		return URL(string: self)
   24|      0|	}
   25|       |}
   26|       |
   27|       |extension URL: URLConvertible {
   28|      0|	public var string: String {
   29|      0|		return absoluteString
   30|      0|	}
   31|       |
   32|      0|	public var url: URL? {
   33|      0|		return self
   34|      0|	}
   35|       |}
   36|       |
   37|       |extension URLConvertible {
   38|      0|    public var encodedURL: URL {
   39|      0|        return URL(string: self.string.urlEncoded)!
   40|      0|    }
   41|       |}

/Users/aafraneokese/Documents/Learn IoS Features/Tests/Unit Tests/BookWyrm/Pods/OAuthSwift/Sources/Utils.swift:
    1|       |//
    2|       |//  Utils.swift
    3|       |//  OAuthSwift
    4|       |//
    5|       |//  Created by Dongri Jin on 1/28/15.
    6|       |//  Copyright (c) 2015 Dongri Jin. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|      0|public func generateState(withLength len: Int) -> String {
   12|      0|    let letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
   13|      0|    let length = UInt32(letters.count)
   14|      0|
   15|      0|    var randomString = ""
   16|      0|    for _ in 0..<len {
   17|      0|        let rand = arc4random_uniform(length)
   18|      0|        let idx = letters.index(letters.startIndex, offsetBy: Int(rand))
   19|      0|        let letter = letters[idx]
   20|      0|        randomString += String(letter)
   21|      0|    }
   22|      0|    return randomString
   23|      0|}

